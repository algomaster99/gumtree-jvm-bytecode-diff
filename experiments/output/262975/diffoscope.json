{"diffoscope-json-version": 1, "source1": "first/EventListenerSupport.class", "source2": "second/EventListenerSupport.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -19,94 +19,92 @@\n public class EventListenerSupport<L> implements Serializable\n {\n     private static final long serialVersionUID = 3593265990380473632L;\n     private List<L> listeners;\n     private transient L proxy;\n     private transient L[] prototypeArray;\n     \n-    public static <T> EventListenerSupport<T> create(final Class<T> listenerInterface) {\n-        return new EventListenerSupport<T>(listenerInterface);\n+    public static <T> EventListenerSupport<T> create(final Class<T> clazz) {\n+        return new EventListenerSupport<T>(clazz);\n     }\n     \n-    public EventListenerSupport(final Class<L> listenerInterface) {\n-        this(listenerInterface, Thread.currentThread().getContextClassLoader());\n+    public EventListenerSupport(final Class<L> clazz) {\n+        this(clazz, Thread.currentThread().getContextClassLoader());\n     }\n     \n-    public EventListenerSupport(final Class<L> listenerInterface, final ClassLoader classLoader) {\n+    public EventListenerSupport(final Class<L> clazz, final ClassLoader classLoader) {\n         this();\n-        Validate.notNull((Object)listenerInterface, \"Listener interface cannot be null.\", new Object[0]);\n+        Validate.notNull((Object)clazz, \"Listener interface cannot be null.\", new Object[0]);\n         Validate.notNull((Object)classLoader, \"ClassLoader cannot be null.\", new Object[0]);\n-        Validate.isTrue(listenerInterface.isInterface(), \"Class {0} is not an interface\", new Object[] { listenerInterface.getName() });\n-        this.initializeTransientFields(listenerInterface, classLoader);\n+        Validate.isTrue(clazz.isInterface(), \"Class {0} is not an interface\", new Object[] { clazz.getName() });\n+        this.initializeTransientFields(clazz, classLoader);\n     }\n     \n     private EventListenerSupport() {\n         this.listeners = new CopyOnWriteArrayList<L>();\n     }\n     \n     public L fire() {\n         return this.proxy;\n     }\n     \n-    public void addListener(final L listener) {\n-        this.addListener(listener, true);\n+    public void addListener(final L l) {\n+        this.addListener(l, true);\n     }\n     \n-    public void addListener(final L listener, final boolean allowDuplicate) {\n-        Validate.notNull((Object)listener, \"Listener object cannot be null.\", new Object[0]);\n-        if (allowDuplicate) {\n-            this.listeners.add(listener);\n+    public void addListener(final L l, final boolean b) {\n+        Validate.notNull((Object)l, \"Listener object cannot be null.\", new Object[0]);\n+        if (b) {\n+            this.listeners.add(l);\n         }\n-        else if (!this.listeners.contains(listener)) {\n-            this.listeners.add(listener);\n+        else if (!this.listeners.contains(l)) {\n+            this.listeners.add(l);\n         }\n     }\n     \n     int getListenerCount() {\n         return this.listeners.size();\n     }\n     \n-    public void removeListener(final L listener) {\n-        Validate.notNull((Object)listener, \"Listener object cannot be null.\", new Object[0]);\n-        this.listeners.remove(listener);\n+    public void removeListener(final L l) {\n+        Validate.notNull((Object)l, \"Listener object cannot be null.\", new Object[0]);\n+        this.listeners.remove(l);\n     }\n     \n     public L[] getListeners() {\n         return this.listeners.toArray(this.prototypeArray);\n     }\n     \n     private void writeObject(final ObjectOutputStream objectOutputStream) throws IOException {\n-        final ArrayList<L> serializableListeners = new ArrayList<L>();\n-        ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream());\n-        for (final L listener : this.listeners) {\n+        final ArrayList list = new ArrayList();\n+        ObjectOutputStream objectOutputStream2 = new ObjectOutputStream(new ByteArrayOutputStream());\n+        for (final L next : this.listeners) {\n             try {\n-                testObjectOutputStream.writeObject(listener);\n-                serializableListeners.add(listener);\n+                objectOutputStream2.writeObject(next);\n+                list.add(next);\n             }\n-            catch (final IOException exception) {\n-                testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream());\n+            catch (final IOException ex) {\n+                objectOutputStream2 = new ObjectOutputStream(new ByteArrayOutputStream());\n             }\n         }\n-        objectOutputStream.writeObject(serializableListeners.toArray(this.prototypeArray));\n+        objectOutputStream.writeObject(list.toArray(this.prototypeArray));\n     }\n     \n     private void readObject(final ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {\n-        final L[] srcListeners = (L[])objectInputStream.readObject();\n-        this.listeners = new CopyOnWriteArrayList<L>(srcListeners);\n-        final Class<L> listenerInterface = (Class<L>)srcListeners.getClass().getComponentType();\n-        this.initializeTransientFields(listenerInterface, Thread.currentThread().getContextClassLoader());\n+        final Object[] toCopyIn = (Object[])objectInputStream.readObject();\n+        this.listeners = new CopyOnWriteArrayList<L>((L[])toCopyIn);\n+        this.initializeTransientFields(((L[])toCopyIn).getClass().getComponentType(), Thread.currentThread().getContextClassLoader());\n     }\n     \n-    private void initializeTransientFields(final Class<L> listenerInterface, final ClassLoader classLoader) {\n-        final L[] array = (L[])Array.newInstance(listenerInterface, 0);\n-        this.prototypeArray = array;\n-        this.createProxy(listenerInterface, classLoader);\n+    private void initializeTransientFields(final Class<L> componentType, final ClassLoader classLoader) {\n+        this.prototypeArray = (L[])Array.newInstance(componentType, 0);\n+        this.createProxy(componentType, classLoader);\n     }\n     \n-    private void createProxy(final Class<L> listenerInterface, final ClassLoader classLoader) {\n-        this.proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader, (Class<?>[])new Class[] { listenerInterface }, this.createInvocationHandler()));\n+    private void createProxy(final Class<L> clazz, final ClassLoader loader) {\n+        this.proxy = clazz.cast(Proxy.newProxyInstance(loader, (Class<?>[])new Class[] { clazz }, this.createInvocationHandler()));\n     }\n     \n     protected InvocationHandler createInvocationHandler() {\n         return (InvocationHandler)new EventListenerSupport.ProxyInvocationHandler(this);\n     }\n }\n"}]}
