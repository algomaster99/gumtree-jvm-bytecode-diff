{"diffoscope-json-version": 1, "source1": "first/ReadAheadInputStream.class", "source2": "second/ReadAheadInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -29,14 +29,18 @@\n     private boolean isUnderlyingInputStreamBeingClosed;\n     private boolean isReading;\n     private final AtomicBoolean isWaiting;\n     private final ExecutorService executorService;\n     private final boolean shutdownExecutorService;\n     private final Condition asyncReadComplete;\n     \n+    static {\n+        BYTE_ARRAY_1 = ThreadLocal.withInitial(() -> new byte[1]);\n+    }\n+    \n     public static ReadAheadInputStream.Builder builder() {\n         return new ReadAheadInputStream.Builder();\n     }\n     \n     private static Thread newDaemonThread(final Runnable r) {\n         final Thread thread = new Thread(r, \"commons-io-read-ahead\");\n         thread.setDaemon(true);\n@@ -107,14 +111,15 @@\n                 isSafeToCloseUnderlyingInputStream = true;\n                 this.isUnderlyingInputStreamBeingClosed = true;\n             }\n         }\n         finally {\n             this.stateChangeLock.unlock();\n         }\n+        this.stateChangeLock.unlock();\n         if (this.shutdownExecutorService) {\n             try {\n                 this.executorService.shutdownNow();\n                 this.executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);\n             }\n             catch (final InterruptedException e) {\n                 final InterruptedIOException iio = new InterruptedIOException(e.getMessage());\n@@ -122,14 +127,17 @@\n                 throw iio;\n             }\n             finally {\n                 if (isSafeToCloseUnderlyingInputStream) {\n                     super.close();\n                 }\n             }\n+            if (isSafeToCloseUnderlyingInputStream) {\n+                super.close();\n+            }\n         }\n     }\n     \n     private void closeUnderlyingInputStreamIfNecessary() {\n         boolean needToCloseUnderlyingInputStream = false;\n         this.stateChangeLock.lock();\n         try {\n@@ -137,14 +145,15 @@\n             if (this.isClosed && !this.isUnderlyingInputStreamBeingClosed) {\n                 needToCloseUnderlyingInputStream = true;\n             }\n         }\n         finally {\n             this.stateChangeLock.unlock();\n         }\n+        this.stateChangeLock.unlock();\n         if (needToCloseUnderlyingInputStream) {\n             try {\n                 super.close();\n             }\n             catch (final IOException ex) {}\n         }\n     }\n@@ -184,71 +193,82 @@\n                 }\n                 this.swapBuffers();\n                 this.readAsync();\n             }\n             finally {\n                 this.stateChangeLock.unlock();\n             }\n+            this.stateChangeLock.unlock();\n         }\n         len = Math.min(len, this.activeBuffer.remaining());\n         this.activeBuffer.get(b, offset, len);\n         return len;\n     }\n     \n     private void readAsync() throws IOException {\n         this.stateChangeLock.lock();\n-        byte[] arr;\n         try {\n-            arr = this.readAheadBuffer.array();\n+            final byte[] arr = this.readAheadBuffer.array();\n             if (this.endOfStream || this.readInProgress) {\n                 return;\n             }\n             this.checkReadException();\n             this.readAheadBuffer.position();\n             this.readAheadBuffer.flip();\n             this.readInProgress = true;\n         }\n         finally {\n             this.stateChangeLock.unlock();\n         }\n+        this.stateChangeLock.unlock();\n         this.executorService.execute(() -> {\n             this.stateChangeLock.lock();\n             try {\n                 if (this.isClosed) {\n                     this.readInProgress = false;\n                     return;\n                 }\n                 else {\n                     this.isReading = true;\n                 }\n             }\n             finally {\n                 this.stateChangeLock.unlock();\n             }\n+            this.stateChangeLock.unlock();\n             int read = 0;\n             int off = 0;\n-            int len = arr.length;\n+            int len = b.length;\n             Throwable exception = null;\n             try {\n                 do {\n-                    read = this.in.read(arr, off, len);\n+                    read = this.in.read(b, off, len);\n                     if (read <= 0) {\n                         break;\n                     }\n                     else {\n                         off += read;\n                         len -= read;\n+                        if (len > 0) {\n+                            continue;\n+                        }\n+                        else {\n+                            break;\n+                        }\n                     }\n-                } while (len > 0 && !this.isWaiting.get());\n+                } while (!this.isWaiting.get());\n             }\n             catch (final Throwable ex) {\n                 exception = ex;\n                 if (ex instanceof Error) {\n                     throw (Error)ex;\n                 }\n+                else {\n+                    return;\n+                }\n             }\n             finally {\n                 this.stateChangeLock.lock();\n                 try {\n                     this.readAheadBuffer.limit();\n                     if (read < 0 || exception instanceof EOFException) {\n                         this.endOfStream = true;\n@@ -259,27 +279,47 @@\n                     }\n                     this.readInProgress = false;\n                     this.signalAsyncReadComplete();\n                 }\n                 finally {\n                     this.stateChangeLock.unlock();\n                 }\n+                this.stateChangeLock.unlock();\n                 this.closeUnderlyingInputStreamIfNecessary();\n             }\n+            this.stateChangeLock.lock();\n+            try {\n+                this.readAheadBuffer.limit();\n+                if (read < 0 || exception instanceof EOFException) {\n+                    this.endOfStream = true;\n+                }\n+                else if (exception != null) {\n+                    this.readAborted = true;\n+                    this.readException = exception;\n+                }\n+                this.readInProgress = false;\n+                this.signalAsyncReadComplete();\n+            }\n+            finally {\n+                this.stateChangeLock.unlock();\n+            }\n+            this.stateChangeLock.unlock();\n+            this.closeUnderlyingInputStreamIfNecessary();\n         });\n     }\n     \n     private void signalAsyncReadComplete() {\n         this.stateChangeLock.lock();\n         try {\n             this.asyncReadComplete.signalAll();\n         }\n         finally {\n             this.stateChangeLock.unlock();\n         }\n+        this.stateChangeLock.unlock();\n     }\n     \n     @Override\n     public long skip(final long n) throws IOException {\n         if (n <= 0L) {\n             return 0L;\n         }\n@@ -291,14 +331,15 @@\n         long skipped;\n         try {\n             skipped = this.skipInternal(n);\n         }\n         finally {\n             this.stateChangeLock.unlock();\n         }\n+        this.stateChangeLock.unlock();\n         return skipped;\n     }\n     \n     private long skipInternal(final long n) throws IOException {\n         assert this.stateChangeLock.isLocked();\n         this.waitForAsyncReadComplete();\n         if (this.isEndOfStream()) {\n@@ -348,15 +389,19 @@\n         finally {\n             try {\n                 this.isWaiting.set(false);\n             }\n             finally {\n                 this.stateChangeLock.unlock();\n             }\n+            this.stateChangeLock.unlock();\n+        }\n+        try {\n+            this.isWaiting.set(false);\n         }\n+        finally {\n+            this.stateChangeLock.unlock();\n+        }\n+        this.stateChangeLock.unlock();\n         this.checkReadException();\n     }\n-    \n-    static {\n-        BYTE_ARRAY_1 = ThreadLocal.withInitial(() -> new byte[1]);\n-    }\n }\n"}]}
