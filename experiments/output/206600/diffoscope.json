{"diffoscope-json-version": 1, "source1": "first/XMLConfiguration.class", "source2": "second/XMLConfiguration.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -65,36 +65,36 @@\n     private FileLocator locator;\n     \n     public XMLConfiguration() {\n         this.entityResolver = (EntityResolver)new DefaultEntityResolver();\n         this.initLogger(new ConfigurationLogger((Class)XMLConfiguration.class));\n     }\n     \n-    public XMLConfiguration(final HierarchicalConfiguration<ImmutableNode> c) {\n-        super((HierarchicalConfiguration)c);\n+    public XMLConfiguration(final HierarchicalConfiguration<ImmutableNode> hierarchicalConfiguration) {\n+        super((HierarchicalConfiguration)hierarchicalConfiguration);\n         this.entityResolver = (EntityResolver)new DefaultEntityResolver();\n-        this.rootElementName = ((c != null) ? c.getRootElementName() : null);\n+        this.rootElementName = ((hierarchicalConfiguration != null) ? hierarchicalConfiguration.getRootElementName() : null);\n         this.initLogger(new ConfigurationLogger((Class)XMLConfiguration.class));\n     }\n     \n     protected String getRootElementNameInternal() {\n-        final Document doc = this.getDocument();\n-        if (doc == null) {\n+        final Document document = this.getDocument();\n+        if (document == null) {\n             return (this.rootElementName == null) ? \"configuration\" : this.rootElementName;\n         }\n-        return doc.getDocumentElement().getNodeName();\n+        return document.getDocumentElement().getNodeName();\n     }\n     \n-    public void setRootElementName(final String name) {\n+    public void setRootElementName(final String rootElementName) {\n         this.beginRead(true);\n         try {\n             if (this.getDocument() != null) {\n                 throw new UnsupportedOperationException(\"The name of the root element cannot be changed when loaded from an XML document!\");\n             }\n-            this.rootElementName = name;\n+            this.rootElementName = rootElementName;\n         }\n         finally {\n             this.endRead();\n         }\n     }\n     \n     public DocumentBuilder getDocumentBuilder() {\n@@ -162,185 +162,181 @@\n     public void setSchemaValidation(final boolean schemaValidation) {\n         this.schemaValidation = schemaValidation;\n         if (schemaValidation) {\n             this.validating = true;\n         }\n     }\n     \n-    public void setEntityResolver(final EntityResolver resolver) {\n-        this.entityResolver = resolver;\n+    public void setEntityResolver(final EntityResolver entityResolver) {\n+        this.entityResolver = entityResolver;\n     }\n     \n     public EntityResolver getEntityResolver() {\n         return this.entityResolver;\n     }\n     \n     public Document getDocument() {\n-        final XMLDocumentHelper docHelper = this.getDocumentHelper();\n-        return (docHelper != null) ? docHelper.getDocument() : null;\n+        final XMLDocumentHelper documentHelper = this.getDocumentHelper();\n+        return (documentHelper != null) ? documentHelper.getDocument() : null;\n     }\n     \n     private XMLDocumentHelper getDocumentHelper() {\n-        final ReferenceNodeHandler handler = this.getReferenceHandler();\n-        return (XMLDocumentHelper)handler.getReference((ImmutableNode)handler.getRootNode());\n+        final ReferenceNodeHandler referenceHandler = this.getReferenceHandler();\n+        return (XMLDocumentHelper)referenceHandler.getReference((ImmutableNode)referenceHandler.getRootNode());\n     }\n     \n     private ReferenceNodeHandler getReferenceHandler() {\n         return this.getSubConfigurationParentModel().getReferenceNodeHandler();\n     }\n     \n-    private void initProperties(final XMLDocumentHelper docHelper, final boolean elemRefs) {\n-        final Document document = docHelper.getDocument();\n-        this.setPublicID(docHelper.getSourcePublicID());\n-        this.setSystemID(docHelper.getSourceSystemID());\n-        final ImmutableNode.Builder rootBuilder = new ImmutableNode.Builder();\n-        final MutableObject<String> rootValue = (MutableObject<String>)new MutableObject();\n-        final Map<ImmutableNode, Object> elemRefMap = elemRefs ? new HashMap<ImmutableNode, Object>() : null;\n-        final Map<String, String> attributes = this.constructHierarchy(rootBuilder, rootValue, document.getDocumentElement(), elemRefMap, true, 0);\n-        attributes.remove(\"config-xml:space\");\n-        final ImmutableNode top = rootBuilder.value(rootValue.getValue()).addAttributes((Map)attributes).create();\n-        this.getSubConfigurationParentModel().mergeRoot(top, document.getDocumentElement().getTagName(), (Map)elemRefMap, (Object)(elemRefs ? docHelper : null), (NodeKeyResolver)this);\n-    }\n-    \n-    private Map<String, String> constructHierarchy(final ImmutableNode.Builder node, final MutableObject<String> refValue, final Element element, final Map<ImmutableNode, Object> elemRefs, final boolean trim, final int level) {\n-        final boolean trimFlag = shouldTrim(element, trim);\n-        final Map<String, String> attributes = processAttributes(element);\n-        attributes.put(\"config-xml:space\", String.valueOf(trimFlag));\n-        final StringBuilder buffer = new StringBuilder();\n-        final NodeList list = element.getChildNodes();\n-        boolean hasChildren = false;\n-        for (int i = 0; i < list.getLength(); ++i) {\n-            final Node w3cNode = list.item(i);\n-            if (w3cNode instanceof Element) {\n-                final Element child = (Element)w3cNode;\n-                final ImmutableNode.Builder childNode = new ImmutableNode.Builder();\n-                childNode.name(child.getTagName());\n-                final MutableObject<String> refChildValue = (MutableObject<String>)new MutableObject();\n-                final Map<String, String> attrmap = this.constructHierarchy(childNode, refChildValue, child, elemRefs, trimFlag, level + 1);\n-                final boolean childTrim = Boolean.parseBoolean(attrmap.remove(\"config-xml:space\"));\n-                childNode.addAttributes((Map)attrmap);\n-                final ImmutableNode newChild = this.createChildNodeWithValue(node, childNode, child, (String)refChildValue.getValue(), childTrim, attrmap, elemRefs);\n-                if (elemRefs != null && !elemRefs.containsKey(newChild)) {\n-                    elemRefs.put(newChild, child);\n+    private void initProperties(final XMLDocumentHelper xmlDocumentHelper, final boolean b) {\n+        final Document document = xmlDocumentHelper.getDocument();\n+        this.setPublicID(xmlDocumentHelper.getSourcePublicID());\n+        this.setSystemID(xmlDocumentHelper.getSourceSystemID());\n+        final ImmutableNode.Builder builder = new ImmutableNode.Builder();\n+        final MutableObject mutableObject = new MutableObject();\n+        final HashMap hashMap = b ? new HashMap() : null;\n+        final Map<String, String> constructHierarchy = this.constructHierarchy(builder, mutableObject, document.getDocumentElement(), (Map<ImmutableNode, Object>)hashMap, true, 0);\n+        constructHierarchy.remove(\"config-xml:space\");\n+        this.getSubConfigurationParentModel().mergeRoot(builder.value(mutableObject.getValue()).addAttributes((Map)constructHierarchy).create(), document.getDocumentElement().getTagName(), (Map)hashMap, (Object)(b ? xmlDocumentHelper : null), (NodeKeyResolver)this);\n+    }\n+    \n+    private Map<String, String> constructHierarchy(final ImmutableNode.Builder builder, final MutableObject<String> mutableObject, final Element element, final Map<ImmutableNode, Object> map, final boolean b, final int n) {\n+        final boolean shouldTrim = shouldTrim(element, b);\n+        final Map<String, String> processAttributes = processAttributes(element);\n+        processAttributes.put(\"config-xml:space\", String.valueOf(shouldTrim));\n+        final StringBuilder sb = new StringBuilder();\n+        final NodeList childNodes = element.getChildNodes();\n+        boolean b2 = false;\n+        for (int i = 0; i < childNodes.getLength(); ++i) {\n+            final Node item = childNodes.item(i);\n+            if (item instanceof Element) {\n+                final Element element2 = (Element)item;\n+                final ImmutableNode.Builder builder2 = new ImmutableNode.Builder();\n+                builder2.name(element2.getTagName());\n+                final MutableObject mutableObject2 = new MutableObject();\n+                final Map<String, String> constructHierarchy = this.constructHierarchy(builder2, (MutableObject<String>)mutableObject2, element2, map, shouldTrim, n + 1);\n+                final boolean boolean1 = Boolean.parseBoolean(constructHierarchy.remove(\"config-xml:space\"));\n+                builder2.addAttributes((Map)constructHierarchy);\n+                final ImmutableNode childNodeWithValue = this.createChildNodeWithValue(builder, builder2, element2, (String)mutableObject2.getValue(), boolean1, constructHierarchy, map);\n+                if (map != null && !map.containsKey(childNodeWithValue)) {\n+                    map.put(childNodeWithValue, element2);\n                 }\n-                hasChildren = true;\n+                b2 = true;\n             }\n-            else if (w3cNode instanceof Text) {\n-                final Text data = (Text)w3cNode;\n-                buffer.append(data.getData());\n+            else if (item instanceof Text) {\n+                sb.append(((Text)item).getData());\n             }\n         }\n-        boolean childrenFlag = false;\n-        if (hasChildren || trimFlag) {\n-            childrenFlag = (hasChildren || attributes.size() > 1);\n+        boolean b3 = false;\n+        if (b2 || shouldTrim) {\n+            b3 = (b2 || processAttributes.size() > 1);\n         }\n-        final String text = determineValue(buffer.toString(), childrenFlag, trimFlag);\n-        if (!text.isEmpty() || (!childrenFlag && level != 0)) {\n-            refValue.setValue((Object)text);\n+        final String determineValue = determineValue(sb.toString(), b3, shouldTrim);\n+        if (!determineValue.isEmpty() || (!b3 && n != 0)) {\n+            mutableObject.setValue((Object)determineValue);\n         }\n-        return attributes;\n+        return processAttributes;\n     }\n     \n-    private static String determineValue(final String content, final boolean hasChildren, final boolean trimFlag) {\n-        final boolean shouldTrim = trimFlag || (StringUtils.isBlank((CharSequence)content) && hasChildren);\n-        return shouldTrim ? content.trim() : content;\n+    private static String determineValue(final String s, final boolean b, final boolean b2) {\n+        return (b2 || (StringUtils.isBlank((CharSequence)s) && b)) ? s.trim() : s;\n     }\n     \n     private static Map<String, String> processAttributes(final Element element) {\n         final NamedNodeMap attributes = element.getAttributes();\n-        final Map<String, String> attrmap = new HashMap<String, String>();\n+        final HashMap hashMap = new HashMap();\n         for (int i = 0; i < attributes.getLength(); ++i) {\n-            final Node w3cNode = attributes.item(i);\n-            if (w3cNode instanceof Attr) {\n-                final Attr attr = (Attr)w3cNode;\n-                attrmap.put(attr.getName(), attr.getValue());\n+            final Node item = attributes.item(i);\n+            if (item instanceof Attr) {\n+                final Attr attr = (Attr)item;\n+                hashMap.put(attr.getName(), attr.getValue());\n             }\n         }\n-        return attrmap;\n+        return hashMap;\n     }\n     \n-    private ImmutableNode createChildNodeWithValue(final ImmutableNode.Builder parent, final ImmutableNode.Builder child, final Element elem, final String value, final boolean trim, final Map<String, String> attrmap, final Map<ImmutableNode, Object> elemRefs) {\n-        Collection<String> values;\n-        if (value != null) {\n-            values = this.getListDelimiterHandler().split(value, trim);\n+    private ImmutableNode createChildNodeWithValue(final ImmutableNode.Builder builder, final ImmutableNode.Builder builder2, final Element element, final String s, final boolean b, final Map<String, String> map, final Map<ImmutableNode, Object> map2) {\n+        Collection<Object> collection;\n+        if (s != null) {\n+            collection = this.getListDelimiterHandler().split(s, b);\n         }\n         else {\n-            values = (Collection<String>)Collections.emptyList();\n+            collection = Collections.emptyList();\n         }\n-        ImmutableNode addedChildNode;\n-        if (values.size() > 1) {\n-            final Map<ImmutableNode, Object> refs = isSingleElementList(elem) ? elemRefs : null;\n-            final Iterator<String> it = values.iterator();\n-            child.value((Object)it.next());\n-            addedChildNode = child.create();\n-            parent.addChild(addedChildNode);\n-            XMLListReference.assignListReference((Map)refs, addedChildNode, elem);\n-            while (it.hasNext()) {\n-                final ImmutableNode.Builder c = new ImmutableNode.Builder();\n-                c.name(addedChildNode.getNodeName());\n-                c.value((Object)it.next());\n-                c.addAttributes((Map)attrmap);\n-                final ImmutableNode newChild = c.create();\n-                parent.addChild(newChild);\n-                XMLListReference.assignListReference((Map)refs, newChild, (Element)null);\n+        ImmutableNode immutableNode;\n+        if (collection.size() > 1) {\n+            final Map<ImmutableNode, Object> map3 = isSingleElementList(element) ? map2 : null;\n+            final Iterator<Object> iterator = collection.iterator();\n+            builder2.value(iterator.next());\n+            immutableNode = builder2.create();\n+            builder.addChild(immutableNode);\n+            XMLListReference.assignListReference((Map)map3, immutableNode, element);\n+            while (iterator.hasNext()) {\n+                final ImmutableNode.Builder builder3 = new ImmutableNode.Builder();\n+                builder3.name(immutableNode.getNodeName());\n+                builder3.value(iterator.next());\n+                builder3.addAttributes((Map)map);\n+                final ImmutableNode create = builder3.create();\n+                builder.addChild(create);\n+                XMLListReference.assignListReference((Map)map3, create, (Element)null);\n             }\n         }\n         else {\n-            if (values.size() == 1) {\n-                child.value((Object)values.iterator().next());\n+            if (collection.size() == 1) {\n+                builder2.value(collection.iterator().next());\n             }\n-            addedChildNode = child.create();\n-            parent.addChild(addedChildNode);\n+            immutableNode = builder2.create();\n+            builder.addChild(immutableNode);\n         }\n-        return addedChildNode;\n+        return immutableNode;\n     }\n     \n     private static boolean isSingleElementList(final Element element) {\n-        final Node parentNode = element.getParentNode();\n-        return countChildElements(parentNode, element.getTagName()) == 1;\n+        return countChildElements(element.getParentNode(), element.getTagName()) == 1;\n     }\n     \n-    private static int countChildElements(final Node parent, final String name) {\n-        final NodeList childNodes = parent.getChildNodes();\n-        int count = 0;\n+    private static int countChildElements(final Node node, final String s) {\n+        final NodeList childNodes = node.getChildNodes();\n+        int n = 0;\n         for (int i = 0; i < childNodes.getLength(); ++i) {\n             final Node item = childNodes.item(i);\n-            if (item instanceof Element && name.equals(((Element)item).getTagName())) {\n-                ++count;\n+            if (item instanceof Element && s.equals(((Element)item).getTagName())) {\n+                ++n;\n             }\n         }\n-        return count;\n+        return n;\n     }\n     \n-    private static boolean shouldTrim(final Element element, final boolean currentTrim) {\n-        final Attr attr = element.getAttributeNode(\"xml:space\");\n-        if (attr == null) {\n-            return currentTrim;\n+    private static boolean shouldTrim(final Element element, final boolean b) {\n+        final Attr attributeNode = element.getAttributeNode(\"xml:space\");\n+        if (attributeNode == null) {\n+            return b;\n         }\n-        return !\"preserve\".equals(attr.getValue());\n+        return !\"preserve\".equals(attributeNode.getValue());\n     }\n     \n     protected DocumentBuilder createDocumentBuilder() throws ParserConfigurationException {\n         if (this.getDocumentBuilder() != null) {\n             return this.getDocumentBuilder();\n         }\n-        final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n+        final DocumentBuilderFactory instance = DocumentBuilderFactory.newInstance();\n         if (this.isValidating()) {\n-            factory.setValidating(true);\n+            instance.setValidating(true);\n             if (this.isSchemaValidation()) {\n-                factory.setNamespaceAware(true);\n-                factory.setAttribute(\"http://java.sun.com/xml/jaxp/properties/schemaLanguage\", \"http://www.w3.org/2001/XMLSchema\");\n+                instance.setNamespaceAware(true);\n+                instance.setAttribute(\"http://java.sun.com/xml/jaxp/properties/schemaLanguage\", \"http://www.w3.org/2001/XMLSchema\");\n             }\n         }\n-        final DocumentBuilder result = factory.newDocumentBuilder();\n-        result.setEntityResolver(this.entityResolver);\n+        final DocumentBuilder documentBuilder = instance.newDocumentBuilder();\n+        documentBuilder.setEntityResolver(this.entityResolver);\n         if (this.isValidating()) {\n-            result.setErrorHandler((ErrorHandler)new XMLConfiguration.XMLConfiguration$1(this));\n+            documentBuilder.setErrorHandler((ErrorHandler)new XMLConfiguration.XMLConfiguration$1(this));\n         }\n-        return result;\n+        return documentBuilder;\n     }\n     \n     protected Transformer createTransformer() throws ConfigurationException {\n         final Transformer transformer = XMLDocumentHelper.createTransformer();\n         transformer.setOutputProperty(\"indent\", \"yes\");\n         transformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", Integer.toString(2));\n         if (this.locator != null && this.locator.getEncoding() != null) {\n@@ -352,96 +348,88 @@\n         if (this.systemID != null) {\n             transformer.setOutputProperty(\"doctype-system\", this.systemID);\n         }\n         return transformer;\n     }\n     \n     private Document createDocument() throws ConfigurationException {\n-        final ReferenceNodeHandler handler = this.getReferenceHandler();\n-        final XMLDocumentHelper docHelper = (XMLDocumentHelper)handler.getReference((ImmutableNode)handler.getRootNode());\n-        final XMLDocumentHelper newHelper = (docHelper == null) ? XMLDocumentHelper.forNewDocument(this.getRootElementName()) : docHelper.createCopy();\n-        final XMLConfiguration.XMLBuilderVisitor builder = new XMLConfiguration.XMLBuilderVisitor(newHelper, this.getListDelimiterHandler());\n-        builder.handleRemovedNodes(handler);\n-        builder.processDocument(handler);\n-        this.initRootElementText(newHelper.getDocument(), ((ImmutableNode)this.getModel().getNodeHandler().getRootNode()).getValue());\n-        return newHelper.getDocument();\n-    }\n-    \n-    private void initRootElementText(final Document doc, final Object value) {\n-        final Element elem = doc.getDocumentElement();\n-        final NodeList children = elem.getChildNodes();\n-        for (int i = 0; i < children.getLength(); ++i) {\n-            final Node nd = children.item(i);\n-            if (nd.getNodeType() == 3) {\n-                elem.removeChild(nd);\n+        final ReferenceNodeHandler referenceHandler = this.getReferenceHandler();\n+        final XMLDocumentHelper xmlDocumentHelper = (XMLDocumentHelper)referenceHandler.getReference((ImmutableNode)referenceHandler.getRootNode());\n+        final XMLDocumentHelper xmlDocumentHelper2 = (xmlDocumentHelper == null) ? XMLDocumentHelper.forNewDocument(this.getRootElementName()) : xmlDocumentHelper.createCopy();\n+        final XMLConfiguration.XMLBuilderVisitor xmlBuilderVisitor = new XMLConfiguration.XMLBuilderVisitor(xmlDocumentHelper2, this.getListDelimiterHandler());\n+        xmlBuilderVisitor.handleRemovedNodes(referenceHandler);\n+        xmlBuilderVisitor.processDocument(referenceHandler);\n+        this.initRootElementText(xmlDocumentHelper2.getDocument(), ((ImmutableNode)this.getModel().getNodeHandler().getRootNode()).getValue());\n+        return xmlDocumentHelper2.getDocument();\n+    }\n+    \n+    private void initRootElementText(final Document document, final Object obj) {\n+        final Element documentElement = document.getDocumentElement();\n+        final NodeList childNodes = documentElement.getChildNodes();\n+        for (int i = 0; i < childNodes.getLength(); ++i) {\n+            final Node item = childNodes.item(i);\n+            if (item.getNodeType() == 3) {\n+                documentElement.removeChild(item);\n             }\n         }\n-        if (value != null) {\n-            elem.appendChild(doc.createTextNode(String.valueOf(value)));\n+        if (obj != null) {\n+            documentElement.appendChild(document.createTextNode(String.valueOf(obj)));\n         }\n     }\n     \n-    public void initFileLocator(final FileLocator loc) {\n-        this.locator = loc;\n+    public void initFileLocator(final FileLocator locator) {\n+        this.locator = locator;\n     }\n     \n-    public void read(final Reader in) throws ConfigurationException, IOException {\n-        this.load(new InputSource(in));\n+    public void read(final Reader characterStream) throws ConfigurationException, IOException {\n+        this.load(new InputSource(characterStream));\n     }\n     \n-    public void read(final InputStream in) throws ConfigurationException, IOException {\n-        this.load(new InputSource(in));\n+    public void read(final InputStream byteStream) throws ConfigurationException, IOException {\n+        this.load(new InputSource(byteStream));\n     }\n     \n-    private void load(final InputSource source) throws ConfigurationException {\n+    private void load(final InputSource inputSource) throws ConfigurationException {\n         if (this.locator == null) {\n             throw new ConfigurationException(\"Load operation not properly initialized! Do not call read(InputStream) directly, but use a FileHandler to load a configuration.\");\n         }\n         try {\n             final URL sourceURL = this.locator.getSourceURL();\n             if (sourceURL != null) {\n-                source.setSystemId(sourceURL.toString());\n+                inputSource.setSystemId(sourceURL.toString());\n             }\n-            final DocumentBuilder builder = this.createDocumentBuilder();\n-            final Document newDocument = builder.parse(source);\n-            final Document oldDocument = this.getDocument();\n-            this.initProperties(XMLDocumentHelper.forSourceDocument(newDocument), oldDocument == null);\n-        }\n-        catch (final SAXParseException spe) {\n-            throw new ConfigurationException(\"Error parsing \" + source.getSystemId(), (Throwable)spe);\n-        }\n-        catch (final Exception e) {\n-            this.getLogger().debug(\"Unable to load the configuration: \" + e);\n-            throw new ConfigurationException(\"Unable to load the configuration\", (Throwable)e);\n+            this.initProperties(XMLDocumentHelper.forSourceDocument(this.createDocumentBuilder().parse(inputSource)), this.getDocument() == null);\n+        }\n+        catch (final SAXParseException ex) {\n+            throw new ConfigurationException(\"Error parsing \" + inputSource.getSystemId(), (Throwable)ex);\n+        }\n+        catch (final Exception obj) {\n+            this.getLogger().debug(\"Unable to load the configuration: \" + obj);\n+            throw new ConfigurationException(\"Unable to load the configuration\", (Throwable)obj);\n         }\n     }\n     \n     public void write(final Writer writer) throws ConfigurationException, IOException {\n         this.write(writer, this.createTransformer());\n     }\n     \n     public void write(final Writer writer, final Transformer transformer) throws ConfigurationException {\n-        final Source source = new DOMSource(this.createDocument());\n-        final Result result = new StreamResult(writer);\n-        XMLDocumentHelper.transform(transformer, source, result);\n+        XMLDocumentHelper.transform(transformer, (Source)new DOMSource(this.createDocument()), (Result)new StreamResult(writer));\n     }\n     \n     public void validate() throws ConfigurationException {\n         this.beginWrite(false);\n         try {\n             final Transformer transformer = this.createTransformer();\n-            final Source source = new DOMSource(this.createDocument());\n+            final DOMSource domSource = new DOMSource(this.createDocument());\n             final StringWriter writer = new StringWriter();\n-            final Result result = new StreamResult(writer);\n-            XMLDocumentHelper.transform(transformer, source, result);\n-            final Reader reader = new StringReader(writer.getBuffer().toString());\n-            final DocumentBuilder builder = this.createDocumentBuilder();\n-            builder.parse(new InputSource(reader));\n+            XMLDocumentHelper.transform(transformer, (Source)domSource, (Result)new StreamResult(writer));\n+            this.createDocumentBuilder().parse(new InputSource((Reader)new StringReader(writer.getBuffer().toString())));\n         }\n-        catch (final SAXException | IOException | ParserConfigurationException pce) {\n-            throw new ConfigurationException(\"Validation failed\", (Throwable)pce);\n+        catch (final SAXException | IOException | ParserConfigurationException ex) {\n+            throw new ConfigurationException(\"Validation failed\", (Throwable)ex);\n         }\n         finally {\n             this.endWrite();\n         }\n     }\n }\n"}]}
