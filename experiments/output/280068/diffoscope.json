{"diffoscope-json-version": 1, "source1": "first/DefaultExpressionEngine.class", "source2": "second/DefaultExpressionEngine.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -9,127 +9,128 @@\n \n public class DefaultExpressionEngine implements ExpressionEngine\n {\n     public static final DefaultExpressionEngine INSTANCE;\n     private final DefaultExpressionEngineSymbols symbols;\n     private final NodeMatcher<String> nameMatcher;\n     \n-    public DefaultExpressionEngine(final DefaultExpressionEngineSymbols syms) {\n-        this(syms, null);\n+    public DefaultExpressionEngine(final DefaultExpressionEngineSymbols defaultExpressionEngineSymbols) {\n+        this(defaultExpressionEngineSymbols, null);\n     }\n     \n-    public DefaultExpressionEngine(final DefaultExpressionEngineSymbols syms, final NodeMatcher<String> nodeNameMatcher) {\n-        if (syms == null) {\n+    public DefaultExpressionEngine(final DefaultExpressionEngineSymbols symbols, final NodeMatcher<String> nodeMatcher) {\n+        if (symbols == null) {\n             throw new IllegalArgumentException(\"Symbols must not be null!\");\n         }\n-        this.symbols = syms;\n-        this.nameMatcher = (NodeMatcher<String>)((nodeNameMatcher != null) ? nodeNameMatcher : NodeNameMatchers.EQUALS);\n+        this.symbols = symbols;\n+        this.nameMatcher = (NodeMatcher<String>)((nodeMatcher != null) ? nodeMatcher : NodeNameMatchers.EQUALS);\n     }\n     \n     public DefaultExpressionEngineSymbols getSymbols() {\n         return this.symbols;\n     }\n     \n-    public <T> List<QueryResult<T>> query(final T root, final String key, final NodeHandler<T> handler) {\n-        final List<QueryResult<T>> results = new LinkedList<QueryResult<T>>();\n-        this.findNodesForKey(new DefaultConfigurationKey(this, key).iterator(), root, results, handler);\n-        return results;\n+    public <T> List<QueryResult<T>> query(final T t, final String s, final NodeHandler<T> nodeHandler) {\n+        final LinkedList list = new LinkedList();\n+        this.findNodesForKey(new DefaultConfigurationKey(this, s).iterator(), t, list, nodeHandler);\n+        return list;\n     }\n     \n-    public <T> String nodeKey(final T node, final String parentKey, final NodeHandler<T> handler) {\n-        if (parentKey == null) {\n+    public <T> String nodeKey(final T t, final String s, final NodeHandler<T> nodeHandler) {\n+        if (s == null) {\n             return \"\";\n         }\n-        final DefaultConfigurationKey key = new DefaultConfigurationKey(this, parentKey);\n-        key.append(handler.nodeName((Object)node), true);\n-        return key.toString();\n-    }\n-    \n-    public String attributeKey(final String parentKey, final String attributeName) {\n-        final DefaultConfigurationKey key = new DefaultConfigurationKey(this, parentKey);\n-        key.appendAttribute(attributeName);\n-        return key.toString();\n-    }\n-    \n-    public <T> String canonicalKey(final T node, final String parentKey, final NodeHandler<T> handler) {\n-        final String nodeName = handler.nodeName((Object)node);\n-        final T parent = (T)handler.getParent((Object)node);\n-        final DefaultConfigurationKey key = new DefaultConfigurationKey(this, parentKey);\n-        key.append(StringUtils.defaultString(nodeName));\n+        final DefaultConfigurationKey defaultConfigurationKey = new DefaultConfigurationKey(this, s);\n+        defaultConfigurationKey.append(nodeHandler.nodeName((Object)t), true);\n+        return defaultConfigurationKey.toString();\n+    }\n+    \n+    public String attributeKey(final String s, final String s2) {\n+        final DefaultConfigurationKey defaultConfigurationKey = new DefaultConfigurationKey(this, s);\n+        defaultConfigurationKey.appendAttribute(s2);\n+        return defaultConfigurationKey.toString();\n+    }\n+    \n+    public <T> String canonicalKey(final T t, final String s, final NodeHandler<T> nodeHandler) {\n+        final String nodeName = nodeHandler.nodeName((Object)t);\n+        final Object parent = nodeHandler.getParent((Object)t);\n+        final DefaultConfigurationKey defaultConfigurationKey = new DefaultConfigurationKey(this, s);\n+        defaultConfigurationKey.append(StringUtils.defaultString(nodeName));\n         if (parent != null) {\n-            key.appendIndex(this.determineIndex(node, parent, nodeName, handler));\n+            defaultConfigurationKey.appendIndex(this.determineIndex((Object)t, parent, nodeName, (org.apache.commons.configuration2.tree.NodeHandler<Object>)nodeHandler));\n         }\n-        return key.toString();\n+        return defaultConfigurationKey.toString();\n     }\n     \n-    public <T> NodeAddData<T> prepareAdd(final T root, final String key, final NodeHandler<T> handler) {\n-        final DefaultConfigurationKey.KeyIterator it = new DefaultConfigurationKey(this, key).iterator();\n-        if (!it.hasNext()) {\n+    public <T> NodeAddData<T> prepareAdd(final T t, final String str, final NodeHandler<T> nodeHandler) {\n+        final DefaultConfigurationKey.KeyIterator iterator = new DefaultConfigurationKey(this, str).iterator();\n+        if (!iterator.hasNext()) {\n             throw new IllegalArgumentException(\"Key for add operation must be defined!\");\n         }\n-        final T parent = this.findLastPathNode(it, root, handler);\n-        final List<String> pathNodes = new LinkedList<String>();\n-        while (it.hasNext()) {\n-            if (!it.isPropertyKey()) {\n-                throw new IllegalArgumentException(\"Invalid key for add operation: \" + key + \" (Attribute key in the middle.)\");\n+        final T lastPathNode = this.findLastPathNode(iterator, t, nodeHandler);\n+        final LinkedList list = new LinkedList();\n+        while (iterator.hasNext()) {\n+            if (!iterator.isPropertyKey()) {\n+                throw new IllegalArgumentException(\"Invalid key for add operation: \" + str + \" (Attribute key in the middle.)\");\n             }\n-            pathNodes.add(it.currentKey());\n-            it.next();\n+            list.add(iterator.currentKey());\n+            iterator.next();\n         }\n-        return (NodeAddData<T>)new NodeAddData((Object)parent, it.currentKey(), !it.isPropertyKey(), (Collection)pathNodes);\n+        return (NodeAddData<T>)new NodeAddData((Object)lastPathNode, iterator.currentKey(), !iterator.isPropertyKey(), (Collection)list);\n     }\n     \n-    protected <T> void findNodesForKey(final DefaultConfigurationKey.KeyIterator keyPart, final T node, final Collection<QueryResult<T>> results, final NodeHandler<T> handler) {\n-        if (!keyPart.hasNext()) {\n-            results.add((QueryResult<T>)QueryResult.createNodeResult((Object)node));\n+    protected <T> void findNodesForKey(final DefaultConfigurationKey.KeyIterator keyIterator, final T t, final Collection<QueryResult<T>> collection, final NodeHandler<T> nodeHandler) {\n+        if (!keyIterator.hasNext()) {\n+            collection.add((org.apache.commons.configuration2.tree.QueryResult<Object>)QueryResult.createNodeResult((Object)t));\n         }\n         else {\n-            final String key = keyPart.nextKey(false);\n-            if (keyPart.isPropertyKey()) {\n-                this.processSubNodes(keyPart, (List<T>)this.findChildNodesByName((org.apache.commons.configuration2.tree.NodeHandler<T>)handler, (T)node, key), results, handler);\n+            final String nextKey = keyIterator.nextKey(false);\n+            if (keyIterator.isPropertyKey()) {\n+                this.processSubNodes(keyIterator, (List<Object>)this.findChildNodesByName((org.apache.commons.configuration2.tree.NodeHandler<T>)nodeHandler, (T)t, nextKey), (Collection<org.apache.commons.configuration2.tree.QueryResult<Object>>)collection, (org.apache.commons.configuration2.tree.NodeHandler<Object>)nodeHandler);\n             }\n-            if (keyPart.isAttribute() && !keyPart.hasNext() && handler.getAttributeValue((Object)node, key) != null) {\n-                results.add((QueryResult<T>)QueryResult.createAttributeResult((Object)node, key));\n+            if (keyIterator.isAttribute() && !keyIterator.hasNext() && nodeHandler.getAttributeValue((Object)t, nextKey) != null) {\n+                collection.add((org.apache.commons.configuration2.tree.QueryResult<Object>)QueryResult.createAttributeResult((Object)t, nextKey));\n             }\n         }\n     }\n     \n-    protected <T> T findLastPathNode(final DefaultConfigurationKey.KeyIterator keyIt, final T node, final NodeHandler<T> handler) {\n-        final String keyPart = keyIt.nextKey(false);\n-        if (!keyIt.hasNext()) {\n-            return node;\n+    protected <T> T findLastPathNode(final DefaultConfigurationKey.KeyIterator keyIterator, final T t, final NodeHandler<T> nodeHandler) {\n+        final String nextKey = keyIterator.nextKey(false);\n+        if (!keyIterator.hasNext()) {\n+            return t;\n         }\n-        if (!keyIt.isPropertyKey()) {\n+        if (!keyIterator.isPropertyKey()) {\n             throw new IllegalArgumentException(\"Invalid path for add operation: Attribute key in the middle!\");\n         }\n-        final int idx = keyIt.hasIndex() ? keyIt.getIndex() : (handler.getMatchingChildrenCount((Object)node, (NodeMatcher)this.nameMatcher, (Object)keyPart) - 1);\n-        if (idx < 0 || idx >= handler.getMatchingChildrenCount((Object)node, (NodeMatcher)this.nameMatcher, (Object)keyPart)) {\n-            return node;\n+        final int n = keyIterator.hasIndex() ? keyIterator.getIndex() : (nodeHandler.getMatchingChildrenCount((Object)t, (NodeMatcher)this.nameMatcher, (Object)nextKey) - 1);\n+        if (n < 0 || n >= nodeHandler.getMatchingChildrenCount((Object)t, (NodeMatcher)this.nameMatcher, (Object)nextKey)) {\n+            return t;\n         }\n-        return (T)this.findLastPathNode(keyIt, this.findChildNodesByName(handler, node, keyPart).get(idx), (org.apache.commons.configuration2.tree.NodeHandler<Object>)handler);\n+        return (T)this.findLastPathNode(keyIterator, this.findChildNodesByName(nodeHandler, t, nextKey).get(n), (org.apache.commons.configuration2.tree.NodeHandler<Object>)nodeHandler);\n     }\n     \n-    private <T> void processSubNodes(final DefaultConfigurationKey.KeyIterator keyPart, final List<T> subNodes, final Collection<QueryResult<T>> nodes, final NodeHandler<T> handler) {\n-        if (keyPart.hasIndex()) {\n-            if (keyPart.getIndex() >= 0 && keyPart.getIndex() < subNodes.size()) {\n-                this.findNodesForKey((DefaultConfigurationKey.KeyIterator)keyPart.clone(), subNodes.get(keyPart.getIndex()), nodes, handler);\n+    private <T> void processSubNodes(final DefaultConfigurationKey.KeyIterator keyIterator, final List<T> list, final Collection<QueryResult<T>> collection, final NodeHandler<T> nodeHandler) {\n+        if (keyIterator.hasIndex()) {\n+            if (keyIterator.getIndex() >= 0 && keyIterator.getIndex() < list.size()) {\n+                this.findNodesForKey((DefaultConfigurationKey.KeyIterator)keyIterator.clone(), list.get(keyIterator.getIndex()), collection, nodeHandler);\n             }\n         }\n         else {\n-            for (final T node : subNodes) {\n-                this.findNodesForKey((DefaultConfigurationKey.KeyIterator)keyPart.clone(), node, nodes, handler);\n+            final Iterator iterator = list.iterator();\n+            while (iterator.hasNext()) {\n+                this.findNodesForKey((DefaultConfigurationKey.KeyIterator)keyIterator.clone(), iterator.next(), (Collection<org.apache.commons.configuration2.tree.QueryResult<Object>>)collection, (org.apache.commons.configuration2.tree.NodeHandler<Object>)nodeHandler);\n             }\n         }\n     }\n     \n-    private <T> int determineIndex(final T node, final T parent, final String nodeName, final NodeHandler<T> handler) {\n-        return this.findChildNodesByName(handler, parent, nodeName).indexOf(node);\n+    private <T> int determineIndex(final T t, final T t2, final String s, final NodeHandler<T> nodeHandler) {\n+        return this.findChildNodesByName(nodeHandler, t2, s).indexOf(t);\n     }\n     \n-    private <T> List<T> findChildNodesByName(final NodeHandler<T> handler, final T parent, final String nodeName) {\n-        return handler.getMatchingChildren((Object)parent, (NodeMatcher)this.nameMatcher, (Object)nodeName);\n+    private <T> List<T> findChildNodesByName(final NodeHandler<T> nodeHandler, final T t, final String s) {\n+        return nodeHandler.getMatchingChildren((Object)t, (NodeMatcher)this.nameMatcher, (Object)s);\n     }\n     \n     static {\n         INSTANCE = new DefaultExpressionEngine(DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS);\n     }\n }\n"}]}
