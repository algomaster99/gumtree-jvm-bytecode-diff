{"diffoscope-json-version": 1, "source1": "first/ExtraFieldUtils.class", "source2": "second/ExtraFieldUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,21 +1,39 @@\n \n package org.apache.commons.compress.archivers.zip;\n \n-import java.util.concurrent.ConcurrentHashMap;\n import java.util.List;\n import java.util.ArrayList;\n import java.util.zip.ZipException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.Map;\n \n public class ExtraFieldUtils\n {\n     private static final int WORD = 4;\n     private static final Map<ZipShort, Class<?>> implementations;\n     \n+    static {\n+        implementations = new ConcurrentHashMap<ZipShort, Class<?>>();\n+        register(AsiExtraField.class);\n+        register(X5455_ExtendedTimestamp.class);\n+        register(X7875_NewUnix.class);\n+        register(JarMarker.class);\n+        register(UnicodePathExtraField.class);\n+        register(UnicodeCommentExtraField.class);\n+        register(Zip64ExtendedInformationExtraField.class);\n+        register(X000A_NTFS.class);\n+        register(X0014_X509Certificates.class);\n+        register(X0015_CertificateIdForFile.class);\n+        register(X0016_CertificateIdForCentralDirectory.class);\n+        register(X0017_StrongEncryptionHeader.class);\n+        register(X0019_EncryptionRecipientCertificateList.class);\n+        register(ResourceAlignmentExtraField.class);\n+    }\n+    \n     public static void register(final Class<?> c) {\n         try {\n             final ZipExtraField ze = (ZipExtraField)c.newInstance();\n             ExtraFieldUtils.implementations.put(ze.getHeaderId(), c);\n         }\n         catch (final ClassCastException cc) {\n             throw new RuntimeException(c + \" doesn't implement ZipExtraField\");\n@@ -45,35 +63,35 @@\n     public static ZipExtraField[] parse(final byte[] data, final boolean local) throws ZipException {\n         return parse(data, local, ExtraFieldUtils.UnparseableExtraField.THROW);\n     }\n     \n     public static ZipExtraField[] parse(final byte[] data, final boolean local, final ExtraFieldUtils.UnparseableExtraField onUnparseableData) throws ZipException {\n         final List<ZipExtraField> v = new ArrayList<ZipExtraField>();\n         int start = 0;\n-    Label_0276:\n+    Label_0320:\n         while (start <= data.length - 4) {\n             final ZipShort headerId = new ZipShort(data, start);\n             final int length = new ZipShort(data, start + 2).getValue();\n             if (start + 4 + length > data.length) {\n                 switch (onUnparseableData.getKey()) {\n                     case 0: {\n-                        throw new ZipException(\"bad extra field starting at \" + start + \".  Block length of \" + length + \" bytes exceeds remaining data of \" + (data.length - start - 4) + \" bytes.\");\n+                        throw new ZipException(\"bad extra field starting at \" + start + \".  Block length of \" + length + \" bytes exceeds remaining\" + \" data of \" + (data.length - start - 4) + \" bytes.\");\n                     }\n                     case 2: {\n                         final UnparseableExtraFieldData field = new UnparseableExtraFieldData();\n                         if (local) {\n                             field.parseFromLocalFileData(data, start, data.length - start);\n                         }\n                         else {\n                             field.parseFromCentralDirectoryData(data, start, data.length - start);\n                         }\n                         v.add((ZipExtraField)field);\n                     }\n                     case 1: {\n-                        break Label_0276;\n+                        break Label_0320;\n                     }\n                     default: {\n                         throw new ZipException(\"unknown UnparseableExtraField key: \" + onUnparseableData.getKey());\n                     }\n                 }\n             }\n             else {\n@@ -148,26 +166,8 @@\n             final byte[] local2 = data[data.length - 1].getCentralDirectoryData();\n             if (local2 != null) {\n                 System.arraycopy(local2, 0, result, start, local2.length);\n             }\n         }\n         return result;\n     }\n-    \n-    static {\n-        implementations = new ConcurrentHashMap<ZipShort, Class<?>>();\n-        register(AsiExtraField.class);\n-        register(X5455_ExtendedTimestamp.class);\n-        register(X7875_NewUnix.class);\n-        register(JarMarker.class);\n-        register(UnicodePathExtraField.class);\n-        register(UnicodeCommentExtraField.class);\n-        register(Zip64ExtendedInformationExtraField.class);\n-        register(X000A_NTFS.class);\n-        register(X0014_X509Certificates.class);\n-        register(X0015_CertificateIdForFile.class);\n-        register(X0016_CertificateIdForCentralDirectory.class);\n-        register(X0017_StrongEncryptionHeader.class);\n-        register(X0019_EncryptionRecipientCertificateList.class);\n-        register(ResourceAlignmentExtraField.class);\n-    }\n }\n"}]}
