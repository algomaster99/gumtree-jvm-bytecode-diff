{"diffoscope-json-version": 1, "source1": "first/AbstractClassCouplingCheck$ClassContext.class", "source2": "second/AbstractClassCouplingCheck$ClassContext.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -12,89 +12,85 @@\n \n private final class ClassContext\n {\n     private final Set<String> referencedClassNames;\n     private final String className;\n     private final DetailAST classAst;\n     \n-    private ClassContext(final AbstractClassCouplingCheck this$0, final String className, final DetailAST ast) {\n+    private ClassContext(final AbstractClassCouplingCheck this$0, final String className, final DetailAST classAst) {\n         this.this$0 = this$0;\n         this.referencedClassNames = new TreeSet();\n         this.className = className;\n-        this.classAst = ast;\n+        this.classAst = classAst;\n     }\n     \n-    public void visitLiteralThrows(final DetailAST literalThrows) {\n-        for (DetailAST childAST = literalThrows.getFirstChild(); childAST != null; childAST = childAST.getNextSibling()) {\n-            if (childAST.getType() != 74) {\n-                this.addReferencedClassName(childAST);\n+    public void visitLiteralThrows(final DetailAST detailAST) {\n+        for (DetailAST detailAST2 = detailAST.getFirstChild(); detailAST2 != null; detailAST2 = detailAST2.getNextSibling()) {\n+            if (detailAST2.getType() != 74) {\n+                this.addReferencedClassName(detailAST2);\n             }\n         }\n     }\n     \n-    public void visitType(final DetailAST ast) {\n-        for (DetailAST child = ast.getFirstChild(); child != null; child = child.getNextSibling()) {\n-            if (TokenUtil.isOfType(child, new int[] { 58, 59 })) {\n-                final String fullTypeName = FullIdent.createFullIdent(child).getText();\n-                final String trimmed = AbstractClassCouplingCheck.BRACKET_PATTERN.matcher(fullTypeName).replaceAll(\"\");\n-                this.addReferencedClassName(trimmed);\n+    public void visitType(final DetailAST detailAST) {\n+        for (DetailAST detailAST2 = detailAST.getFirstChild(); detailAST2 != null; detailAST2 = detailAST2.getNextSibling()) {\n+            if (TokenUtil.isOfType(detailAST2, new int[] { 58, 59 })) {\n+                this.addReferencedClassName(AbstractClassCouplingCheck.BRACKET_PATTERN.matcher(FullIdent.createFullIdent(detailAST2).getText()).replaceAll(\"\"));\n             }\n         }\n     }\n     \n-    public void visitLiteralNew(final DetailAST ast) {\n-        this.addReferencedClassName(ast.getFirstChild());\n+    public void visitLiteralNew(final DetailAST detailAST) {\n+        this.addReferencedClassName(detailAST.getFirstChild());\n     }\n     \n-    private void addReferencedClassName(final DetailAST ast) {\n-        final String fullIdentName = FullIdent.createFullIdent(ast).getText();\n-        final String trimmed = AbstractClassCouplingCheck.BRACKET_PATTERN.matcher(fullIdentName).replaceAll(\"\");\n-        this.addReferencedClassName(trimmed);\n+    private void addReferencedClassName(final DetailAST detailAST) {\n+        this.addReferencedClassName(AbstractClassCouplingCheck.BRACKET_PATTERN.matcher(FullIdent.createFullIdent(detailAST).getText()).replaceAll(\"\"));\n     }\n     \n-    private void addReferencedClassName(final String referencedClassName) {\n-        if (this.isSignificant(referencedClassName)) {\n-            this.referencedClassNames.add(referencedClassName);\n+    private void addReferencedClassName(final String s) {\n+        if (this.isSignificant(s)) {\n+            this.referencedClassNames.add(s);\n         }\n     }\n     \n     public void checkCoupling() {\n         this.referencedClassNames.remove(this.className);\n         this.referencedClassNames.remove(this.this$0.packageName + \".\" + this.className);\n         if (this.referencedClassNames.size() > this.this$0.max) {\n             this.this$0.log(this.classAst, this.this$0.getLogMessageId(), new Object[] { Integer.valueOf(this.referencedClassNames.size()), Integer.valueOf(this.this$0.max), this.referencedClassNames.toString() });\n         }\n     }\n     \n-    private boolean isSignificant(final String candidateClassName) {\n-        return !this.this$0.excludedClasses.contains(candidateClassName) && !this.isFromExcludedPackage(candidateClassName) && !this.isExcludedClassRegexp(candidateClassName);\n+    private boolean isSignificant(final String s) {\n+        return !this.this$0.excludedClasses.contains(s) && !this.isFromExcludedPackage(s) && !this.isExcludedClassRegexp(s);\n     }\n     \n-    private boolean isFromExcludedPackage(final String candidateClassName) {\n-        String classNameWithPackage = candidateClassName;\n-        if (candidateClassName.indexOf(46) == -1) {\n-            classNameWithPackage = this.getClassNameWithPackage(candidateClassName).orElse(\"\");\n+    private boolean isFromExcludedPackage(final String s) {\n+        String s2 = s;\n+        if (s.indexOf(46) == -1) {\n+            s2 = this.getClassNameWithPackage(s).orElse(\"\");\n         }\n-        boolean isFromExcludedPackage = false;\n-        if (classNameWithPackage.indexOf(46) != -1) {\n-            final int lastDotIndex = classNameWithPackage.lastIndexOf(46);\n-            final String candidatePackageName = classNameWithPackage.substring(0, lastDotIndex);\n-            isFromExcludedPackage = (candidatePackageName.startsWith(\"java.lang\") || this.this$0.excludedPackages.contains(candidatePackageName));\n+        boolean b = false;\n+        if (s2.indexOf(46) != -1) {\n+            final String substring = s2.substring(0, s2.lastIndexOf(46));\n+            b = (substring.startsWith(\"java.lang\") || this.this$0.excludedPackages.contains(substring));\n         }\n-        return isFromExcludedPackage;\n+        return b;\n     }\n     \n-    private Optional<String> getClassNameWithPackage(final String examineClassName) {\n-        return Optional.ofNullable((String)(T)this.this$0.importedClassPackages.get(examineClassName));\n+    private Optional<String> getClassNameWithPackage(final String s) {\n+        return Optional.ofNullable((String)(T)this.this$0.importedClassPackages.get(s));\n     }\n     \n-    private boolean isExcludedClassRegexp(final String candidateClassName) {\n-        boolean result = false;\n-        for (final Pattern pattern : this.this$0.excludeClassesRegexps) {\n-            if (pattern.matcher(candidateClassName).matches()) {\n-                result = true;\n+    private boolean isExcludedClassRegexp(final String input) {\n+        boolean b = false;\n+        final Iterator iterator = this.this$0.excludeClassesRegexps.iterator();\n+        while (iterator.hasNext()) {\n+            if (((Pattern)iterator.next()).matcher(input).matches()) {\n+                b = true;\n                 break;\n             }\n         }\n-        return result;\n+        return b;\n     }\n }\n"}]}
