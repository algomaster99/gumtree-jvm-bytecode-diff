{"diffoscope-json-version": 1, "source1": "first/IcTuple.class", "source2": "second/IcTuple.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -23,61 +23,61 @@\n     private boolean outerIsAnonymous;\n     private boolean member;\n     private int cachedOuterClassIndex;\n     private int cachedSimpleClassNameIndex;\n     private boolean hashcodeComputed;\n     private int cachedHashCode;\n     \n-    public IcTuple(final String C, final int F, final String C2, final String N, final int cIndex, final int c2Index, final int nIndex, final int tIndex) {\n+    public IcTuple(final String c, final int f, final String c2, final String n, final int cIndex, final int c2Index, final int nIndex, final int tIndex) {\n         this.member = true;\n         this.cachedOuterClassIndex = -1;\n         this.cachedSimpleClassNameIndex = -1;\n-        this.C = C;\n-        this.F = F;\n-        this.C2 = C2;\n-        this.N = N;\n+        this.C = c;\n+        this.F = f;\n+        this.C2 = c2;\n+        this.N = n;\n         this.cIndex = cIndex;\n         this.c2Index = c2Index;\n         this.nIndex = nIndex;\n         this.tIndex = tIndex;\n-        if (null == N) {\n+        if (null == n) {\n             this.predictSimple = true;\n         }\n-        if (null == C2) {\n+        if (null == c2) {\n             this.predictOuter = true;\n         }\n         this.initializeClassStrings();\n     }\n     \n     public boolean predicted() {\n         return this.predictOuter || this.predictSimple;\n     }\n     \n     public boolean nestedExplicitFlagSet() {\n         return (this.F & 0x10000) == 0x10000;\n     }\n     \n-    public String[] innerBreakAtDollar(final String className) {\n-        final ArrayList resultList = new ArrayList();\n-        int start = 0;\n-        int index = 0;\n-        while (index < className.length()) {\n-            if (className.charAt(index) <= '$') {\n-                resultList.add(className.substring(start, index));\n-                start = index + 1;\n-            }\n-            if (++index >= className.length()) {\n-                resultList.add(className.substring(start));\n-            }\n-        }\n-        final String[] result = new String[resultList.size()];\n-        for (int i = 0; i < resultList.size(); ++i) {\n-            result[i] = resultList.get(i);\n+    public String[] innerBreakAtDollar(final String s) {\n+        final ArrayList list = new ArrayList();\n+        int n = 0;\n+        int i = 0;\n+        while (i < s.length()) {\n+            if (s.charAt(i) <= '$') {\n+                list.add(s.substring(n, i));\n+                n = i + 1;\n+            }\n+            if (++i >= s.length()) {\n+                list.add(s.substring(n));\n+            }\n+        }\n+        final String[] array = new String[list.size()];\n+        for (int j = 0; j < list.size(); ++j) {\n+            array[j] = (String)list.get(j);\n         }\n-        return result;\n+        return array;\n     }\n     \n     public String outerClassString() {\n         return this.cachedOuterClassString;\n     }\n     \n     public String simpleClassName() {\n@@ -100,20 +100,20 @@\n     }\n     \n     public boolean outerIsAnonymous() {\n         return this.outerIsAnonymous;\n     }\n     \n     private boolean computeOuterIsAnonymous() {\n-        final String[] result = this.innerBreakAtDollar(this.cachedOuterClassString);\n-        if (result.length == 0) {\n+        final String[] innerBreakAtDollar = this.innerBreakAtDollar(this.cachedOuterClassString);\n+        if (innerBreakAtDollar.length == 0) {\n             throw new Error(\"Should have an outer before checking if it's anonymous\");\n         }\n-        for (int index = 0; index < result.length; ++index) {\n-            if (this.isAllDigits(result[index])) {\n+        for (int i = 0; i < innerBreakAtDollar.length; ++i) {\n+            if (this.isAllDigits(innerBreakAtDollar[i])) {\n                 return true;\n             }\n         }\n         return false;\n     }\n     \n     private void initializeClassStrings() {\n@@ -123,29 +123,29 @@\n         this.initialized = true;\n         if (!this.predictSimple) {\n             this.cachedSimpleClassName = this.N;\n         }\n         if (!this.predictOuter) {\n             this.cachedOuterClassString = this.C2;\n         }\n-        final String[] nameComponents = this.innerBreakAtDollar(this.C);\n-        if (nameComponents.length == 0) {}\n-        if (nameComponents.length == 1) {}\n-        if (nameComponents.length < 2) {\n+        final String[] innerBreakAtDollar = this.innerBreakAtDollar(this.C);\n+        if (innerBreakAtDollar.length == 0) {}\n+        if (innerBreakAtDollar.length == 1) {}\n+        if (innerBreakAtDollar.length < 2) {\n             return;\n         }\n-        final int lastPosition = nameComponents.length - 1;\n-        this.cachedSimpleClassName = nameComponents[lastPosition];\n+        final int n = innerBreakAtDollar.length - 1;\n+        this.cachedSimpleClassName = innerBreakAtDollar[n];\n         this.cachedOuterClassString = \"\";\n-        for (int index = 0; index < lastPosition; ++index) {\n-            this.cachedOuterClassString += nameComponents[index];\n-            if (this.isAllDigits(nameComponents[index])) {\n+        for (int i = 0; i < n; ++i) {\n+            this.cachedOuterClassString += innerBreakAtDollar[i];\n+            if (this.isAllDigits(innerBreakAtDollar[i])) {\n                 this.member = false;\n             }\n-            if (index + 1 != lastPosition) {\n+            if (i + 1 != n) {\n                 this.cachedOuterClassString += '$';\n             }\n         }\n         if (!this.predictSimple) {\n             this.cachedSimpleClassName = this.N;\n             this.cachedSimpleClassNameIndex = this.nIndex;\n         }\n@@ -159,52 +159,52 @@\n             if (this.nestedExplicitFlagSet()) {\n                 this.member = true;\n             }\n         }\n         this.outerIsAnonymous = this.computeOuterIsAnonymous();\n     }\n     \n-    private boolean isAllDigits(final String nameString) {\n-        if (null == nameString) {\n+    private boolean isAllDigits(final String s) {\n+        if (null == s) {\n             return false;\n         }\n-        for (int index = 0; index < nameString.length(); ++index) {\n-            if (!Character.isDigit(nameString.charAt(index))) {\n+        for (int i = 0; i < s.length(); ++i) {\n+            if (!Character.isDigit(s.charAt(i))) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n     @Override\n     public String toString() {\n-        final StringBuffer result = new StringBuffer();\n-        result.append(\"IcTuple \");\n-        result.append('(');\n-        result.append(this.simpleClassName());\n-        result.append(\" in \");\n-        result.append(this.outerClassString());\n-        result.append(')');\n-        return result.toString();\n+        final StringBuffer sb = new StringBuffer();\n+        sb.append(\"IcTuple \");\n+        sb.append('(');\n+        sb.append(this.simpleClassName());\n+        sb.append(\" in \");\n+        sb.append(this.outerClassString());\n+        sb.append(')');\n+        return sb.toString();\n     }\n     \n-    public boolean nullSafeEquals(final String stringOne, final String stringTwo) {\n-        if (null == stringOne) {\n-            return null == stringTwo;\n+    public boolean nullSafeEquals(final String s, final String anObject) {\n+        if (null == s) {\n+            return null == anObject;\n         }\n-        return stringOne.equals(stringTwo);\n+        return s.equals(anObject);\n     }\n     \n     @Override\n-    public boolean equals(final Object object) {\n-        if (object == null || object.getClass() != this.getClass()) {\n+    public boolean equals(final Object o) {\n+        if (o == null || o.getClass() != this.getClass()) {\n             return false;\n         }\n-        final IcTuple compareTuple = (IcTuple)object;\n-        return this.nullSafeEquals(this.C, compareTuple.C) && this.nullSafeEquals(this.C2, compareTuple.C2) && this.nullSafeEquals(this.N, compareTuple.N);\n+        final IcTuple icTuple = (IcTuple)o;\n+        return this.nullSafeEquals(this.C, icTuple.C) && this.nullSafeEquals(this.C2, icTuple.C2) && this.nullSafeEquals(this.N, icTuple.N);\n     }\n     \n     private void generateHashCode() {\n         this.hashcodeComputed = true;\n         this.cachedHashCode = 17;\n         if (this.C != null) {\n             this.cachedHashCode = this.C.hashCode();\n"}]}
