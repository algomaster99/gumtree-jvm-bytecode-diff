{"diffoscope-json-version": 1, "source1": "first/ValidatingObjectInputStream.class", "source2": "second/ValidatingObjectInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -3,15 +3,14 @@\n \n import java.util.Iterator;\n import java.io.ObjectStreamClass;\n import java.io.InvalidClassException;\n import java.util.function.Function;\n import java.util.regex.Pattern;\n import java.util.function.Consumer;\n-import java.util.Objects;\n import java.util.stream.Stream;\n import java.io.IOException;\n import java.util.ArrayList;\n import java.io.InputStream;\n import java.util.List;\n import java.io.ObjectInputStream;\n \n@@ -23,72 +22,60 @@\n     public ValidatingObjectInputStream(final InputStream input) throws IOException {\n         super(input);\n         this.acceptMatchers = new ArrayList<ClassNameMatcher>();\n         this.rejectMatchers = new ArrayList<ClassNameMatcher>();\n     }\n     \n     public ValidatingObjectInputStream accept(final Class<?>... classes) {\n-        final Stream<Object> map = Stream.of(classes).map(c -> {\n+        Stream.of(classes).map(c -> {\n             new FullClassNameMatcher(new String[] { c.getName() });\n             return;\n-        });\n-        final List<ClassNameMatcher> acceptMatchers = this.acceptMatchers;\n-        Objects.requireNonNull(acceptMatchers);\n-        map.forEach(acceptMatchers::add);\n+        }).forEach(this.acceptMatchers::add);\n         return this;\n     }\n     \n     public ValidatingObjectInputStream accept(final ClassNameMatcher m) {\n         this.acceptMatchers.add(m);\n         return this;\n     }\n     \n     public ValidatingObjectInputStream accept(final Pattern pattern) {\n         this.acceptMatchers.add((ClassNameMatcher)new RegexpClassNameMatcher(pattern));\n         return this;\n     }\n     \n     public ValidatingObjectInputStream accept(final String... patterns) {\n-        final Stream<Object> map = Stream.of(patterns).map((Function<? super String, ?>)WildcardClassNameMatcher::new);\n-        final List<ClassNameMatcher> acceptMatchers = this.acceptMatchers;\n-        Objects.requireNonNull(acceptMatchers);\n-        map.forEach(acceptMatchers::add);\n+        Stream.of(patterns).map((Function<? super String, ?>)WildcardClassNameMatcher::new).forEach(this.acceptMatchers::add);\n         return this;\n     }\n     \n     protected void invalidClassNameFound(final String className) throws InvalidClassException {\n         throw new InvalidClassException(\"Class name not accepted: \" + className);\n     }\n     \n     public ValidatingObjectInputStream reject(final Class<?>... classes) {\n-        final Stream<Object> map = Stream.of(classes).map(c -> {\n+        Stream.of(classes).map(c -> {\n             new FullClassNameMatcher(new String[] { c.getName() });\n             return;\n-        });\n-        final List<ClassNameMatcher> rejectMatchers = this.rejectMatchers;\n-        Objects.requireNonNull(rejectMatchers);\n-        map.forEach(rejectMatchers::add);\n+        }).forEach(this.rejectMatchers::add);\n         return this;\n     }\n     \n     public ValidatingObjectInputStream reject(final ClassNameMatcher m) {\n         this.rejectMatchers.add(m);\n         return this;\n     }\n     \n     public ValidatingObjectInputStream reject(final Pattern pattern) {\n         this.rejectMatchers.add((ClassNameMatcher)new RegexpClassNameMatcher(pattern));\n         return this;\n     }\n     \n     public ValidatingObjectInputStream reject(final String... patterns) {\n-        final Stream<Object> map = Stream.of(patterns).map((Function<? super String, ?>)WildcardClassNameMatcher::new);\n-        final List<ClassNameMatcher> rejectMatchers = this.rejectMatchers;\n-        Objects.requireNonNull(rejectMatchers);\n-        map.forEach(rejectMatchers::add);\n+        Stream.of(patterns).map((Function<? super String, ?>)WildcardClassNameMatcher::new).forEach(this.rejectMatchers::add);\n         return this;\n     }\n     \n     @Override\n     protected Class<?> resolveClass(final ObjectStreamClass osc) throws IOException, ClassNotFoundException {\n         this.validateClassName(osc.getName());\n         return super.resolveClass(osc);\n"}]}
