{"diffoscope-json-version": 1, "source1": "first/UTF8JsonGenerator.class", "source2": "second/UTF8JsonGenerator.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -9,17 +9,17 @@\n import java.io.InputStream;\n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.Base64Variant;\n import java.io.Reader;\n import com.fasterxml.jackson.core.SerializableString;\n import java.io.IOException;\n import com.fasterxml.jackson.core.JsonGenerator;\n-import com.fasterxml.jackson.core.io.CharTypes;\n import com.fasterxml.jackson.core.ObjectCodec;\n import com.fasterxml.jackson.core.io.IOContext;\n+import com.fasterxml.jackson.core.io.CharTypes;\n import java.io.OutputStream;\n \n public class UTF8JsonGenerator extends JsonGeneratorImpl\n {\n     private static final byte BYTE_u = 117;\n     private static final byte BYTE_0 = 48;\n     private static final byte BYTE_LBRACKET = 91;\n@@ -42,14 +42,22 @@\n     protected final int _outputEnd;\n     protected final int _outputMaxContiguous;\n     protected char[] _charBuffer;\n     protected final int _charBufferLength;\n     protected byte[] _entityBuffer;\n     protected boolean _bufferRecyclable;\n     \n+    static {\n+        HEX_BYTES_UPPER = CharTypes.copyHexBytes(true);\n+        HEX_BYTES_LOWER = CharTypes.copyHexBytes(false);\n+        NULL_BYTES = new byte[] { 110, 117, 108, 108 };\n+        TRUE_BYTES = new byte[] { 116, 114, 117, 101 };\n+        FALSE_BYTES = new byte[] { 102, 97, 108, 115, 101 };\n+    }\n+    \n     public UTF8JsonGenerator(final IOContext ctxt, final int features, final ObjectCodec codec, final OutputStream out, final char quoteChar) {\n         super(ctxt, features, codec);\n         this._outputStream = out;\n         this._quoteChar = (byte)quoteChar;\n         if (quoteChar != '\\\"') {\n             this._outputEscapes = CharTypes.get7BitOutputEscapes((int)quoteChar);\n         }\n@@ -564,34 +572,33 @@\n             if (this._outputEnd < len2) {\n                 this._writeSegmentedRaw(cbuf, offset, len);\n                 return;\n             }\n             this._flushBuffer();\n         }\n         len += offset;\n-    Label_0190:\n+    Label_0182:\n         while (offset < len) {\n-            while (true) {\n+            do {\n                 final int ch = cbuf[offset];\n                 if (ch > 127) {\n                     final char ch2 = cbuf[offset++];\n                     if (ch2 < '\\u0800') {\n                         this._outputBuffer[this._outputTail++] = (byte)(0xC0 | ch2 >> 6);\n                         this._outputBuffer[this._outputTail++] = (byte)(0x80 | (ch2 & '?'));\n+                        continue Label_0182;\n                     }\n-                    else {\n-                        offset = this._outputRawMultiByteChar(ch2, cbuf, offset, len);\n-                    }\n-                    break;\n+                    offset = this._outputRawMultiByteChar(ch2, cbuf, offset, len);\n+                    continue Label_0182;\n                 }\n-                this._outputBuffer[this._outputTail++] = (byte)ch;\n-                if (++offset >= len) {\n-                    break Label_0190;\n+                else {\n+                    this._outputBuffer[this._outputTail++] = (byte)ch;\n                 }\n-            }\n+            } while (++offset < len);\n+            break;\n         }\n     }\n     \n     public void writeRaw(final char ch) throws IOException {\n         if (this._outputTail + 3 >= this._outputEnd) {\n             this._flushBuffer();\n         }\n@@ -608,64 +615,62 @@\n         }\n     }\n     \n     private final void _writeSegmentedRaw(final char[] cbuf, int offset, final int len) throws IOException {\n         final int end = this._outputEnd;\n         final byte[] bbuf = this._outputBuffer;\n         final int inputEnd = offset + len;\n-    Label_0182:\n+    Label_0173:\n         while (offset < inputEnd) {\n-            while (true) {\n+            do {\n                 final int ch = cbuf[offset];\n                 if (ch >= 128) {\n                     if (this._outputTail + 3 >= this._outputEnd) {\n                         this._flushBuffer();\n                     }\n                     final char ch2 = cbuf[offset++];\n                     if (ch2 < '\\u0800') {\n                         bbuf[this._outputTail++] = (byte)(0xC0 | ch2 >> 6);\n                         bbuf[this._outputTail++] = (byte)(0x80 | (ch2 & '?'));\n+                        continue Label_0173;\n                     }\n-                    else {\n-                        offset = this._outputRawMultiByteChar(ch2, cbuf, offset, inputEnd);\n-                    }\n-                    break;\n+                    offset = this._outputRawMultiByteChar(ch2, cbuf, offset, inputEnd);\n+                    continue Label_0173;\n                 }\n-                if (this._outputTail >= end) {\n-                    this._flushBuffer();\n-                }\n-                bbuf[this._outputTail++] = (byte)ch;\n-                if (++offset >= inputEnd) {\n-                    break Label_0182;\n+                else {\n+                    if (this._outputTail >= end) {\n+                        this._flushBuffer();\n+                    }\n+                    bbuf[this._outputTail++] = (byte)ch;\n                 }\n-            }\n+            } while (++offset < inputEnd);\n+            break;\n         }\n     }\n     \n     private void _writeRawSegment(final char[] cbuf, int offset, final int end) throws IOException {\n-    Label_0137:\n+    Label_0129:\n         while (offset < end) {\n-            while (true) {\n+            do {\n                 final int ch = cbuf[offset];\n                 if (ch > 127) {\n                     final char ch2 = cbuf[offset++];\n                     if (ch2 < '\\u0800') {\n                         this._outputBuffer[this._outputTail++] = (byte)(0xC0 | ch2 >> 6);\n                         this._outputBuffer[this._outputTail++] = (byte)(0x80 | (ch2 & '?'));\n+                        continue Label_0129;\n                     }\n-                    else {\n-                        offset = this._outputRawMultiByteChar(ch2, cbuf, offset, end);\n-                    }\n-                    break;\n+                    offset = this._outputRawMultiByteChar(ch2, cbuf, offset, end);\n+                    continue Label_0129;\n                 }\n-                this._outputBuffer[this._outputTail++] = (byte)ch;\n-                if (++offset >= end) {\n-                    break Label_0137;\n+                else {\n+                    this._outputBuffer[this._outputTail++] = (byte)ch;\n                 }\n-            }\n+            } while (++offset < end);\n+            break;\n         }\n     }\n     \n     public void writeBinary(final Base64Variant b64variant, final byte[] data, final int offset, final int len) throws IOException, JsonGenerationException {\n         this._checkRangeBoundsForByteArray(data, offset, len);\n         this._verifyValueWrite(\"write a binary value\");\n         if (this._outputTail >= this._outputEnd) {\n@@ -698,14 +703,15 @@\n                 }\n                 bytes = dataLength;\n             }\n         }\n         finally {\n             this._ioContext.releaseBase64Buffer(encodingBuffer);\n         }\n+        this._ioContext.releaseBase64Buffer(encodingBuffer);\n         if (this._outputTail >= this._outputEnd) {\n             this._flushBuffer();\n         }\n         this._outputBuffer[this._outputTail++] = this._quoteChar;\n         return bytes;\n     }\n     \n@@ -1692,16 +1698,8 @@\n             this._outputStream.write(this._outputBuffer, 0, len);\n         }\n     }\n     \n     private byte[] getHexBytes() {\n         return this._cfgWriteHexUppercase ? UTF8JsonGenerator.HEX_BYTES_UPPER : UTF8JsonGenerator.HEX_BYTES_LOWER;\n     }\n-    \n-    static {\n-        HEX_BYTES_UPPER = CharTypes.copyHexBytes(true);\n-        HEX_BYTES_LOWER = CharTypes.copyHexBytes(false);\n-        NULL_BYTES = new byte[] { 110, 117, 108, 108 };\n-        TRUE_BYTES = new byte[] { 116, 114, 117, 101 };\n-        FALSE_BYTES = new byte[] { 102, 97, 108, 115, 101 };\n-    }\n }\n"}]}
