{"diffoscope-json-version": 1, "source1": "first/BufferedFileChannelInputStream.class", "source2": "second/BufferedFileChannelInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -16,81 +16,78 @@\n public final class BufferedFileChannelInputStream extends InputStream\n {\n     private final ByteBuffer byteBuffer;\n     private final FileChannel fileChannel;\n     private static final Class<?> DIRECT_BUFFER_CLASS;\n     \n     private static Class<?> getDirectBufferClass() {\n-        Class<?> res = null;\n+        Class<?> forName = null;\n         try {\n-            res = Class.forName(\"sun.nio.ch.DirectBuffer\");\n+            forName = Class.forName(\"sun.nio.ch.DirectBuffer\");\n         }\n         catch (final IllegalAccessError | ClassNotFoundException ex) {}\n-        return res;\n+        return forName;\n     }\n     \n-    private static boolean isDirectBuffer(final Object object) {\n-        return BufferedFileChannelInputStream.DIRECT_BUFFER_CLASS != null && BufferedFileChannelInputStream.DIRECT_BUFFER_CLASS.isInstance(object);\n+    private static boolean isDirectBuffer(final Object o) {\n+        return BufferedFileChannelInputStream.DIRECT_BUFFER_CLASS != null && BufferedFileChannelInputStream.DIRECT_BUFFER_CLASS.isInstance(o);\n     }\n     \n     public BufferedFileChannelInputStream(final File file) throws IOException {\n         this(file, 8192);\n     }\n     \n-    public BufferedFileChannelInputStream(final File file, final int bufferSizeInBytes) throws IOException {\n-        this(file.toPath(), bufferSizeInBytes);\n+    public BufferedFileChannelInputStream(final File file, final int n) throws IOException {\n+        this(file.toPath(), n);\n     }\n     \n     public BufferedFileChannelInputStream(final Path path) throws IOException {\n         this(path, 8192);\n     }\n     \n-    public BufferedFileChannelInputStream(final Path path, final int bufferSizeInBytes) throws IOException {\n+    public BufferedFileChannelInputStream(final Path path, final int capacity) throws IOException {\n         Objects.requireNonNull(path, \"path\");\n         this.fileChannel = FileChannel.open(path, StandardOpenOption.READ);\n-        (this.byteBuffer = ByteBuffer.allocateDirect(bufferSizeInBytes)).flip();\n+        (this.byteBuffer = ByteBuffer.allocateDirect(capacity)).flip();\n     }\n     \n     @Override\n     public synchronized int available() throws IOException {\n         return this.byteBuffer.remaining();\n     }\n     \n-    private void clean(final ByteBuffer buffer) {\n-        if (isDirectBuffer(buffer)) {\n-            this.cleanDirectBuffer(buffer);\n+    private void clean(final ByteBuffer byteBuffer) {\n+        if (isDirectBuffer(byteBuffer)) {\n+            this.cleanDirectBuffer(byteBuffer);\n         }\n     }\n     \n-    private void cleanDirectBuffer(final ByteBuffer buffer) {\n-        final String specVer = System.getProperty(\"java.specification.version\");\n-        if (\"1.8\".equals(specVer)) {\n+    private void cleanDirectBuffer(final ByteBuffer obj) {\n+        if (\"1.8\".equals(System.getProperty(\"java.specification.version\"))) {\n             try {\n-                final Class<?> clsCleaner = Class.forName(\"sun.misc.Cleaner\");\n-                final Method cleanerMethod = BufferedFileChannelInputStream.DIRECT_BUFFER_CLASS.getMethod(\"cleaner\", (Class<?>[])new Class[0]);\n-                final Object cleaner = cleanerMethod.invoke(buffer, new Object[0]);\n-                if (cleaner != null) {\n-                    final Method cleanMethod = clsCleaner.getMethod(\"clean\", (Class<?>[])new Class[0]);\n-                    cleanMethod.invoke(cleaner, new Object[0]);\n+                final Class<?> forName = Class.forName(\"sun.misc.Cleaner\");\n+                final Object invoke = BufferedFileChannelInputStream.DIRECT_BUFFER_CLASS.getMethod(\"cleaner\", (Class<?>[])new Class[0]).invoke(obj, new Object[0]);\n+                if (invoke != null) {\n+                    forName.getMethod(\"clean\", (Class[])new Class[0]).invoke(invoke, new Object[0]);\n                 }\n                 return;\n             }\n-            catch (final ReflectiveOperationException e) {\n-                throw new IllegalStateException(e);\n+            catch (final ReflectiveOperationException cause) {\n+                throw new IllegalStateException(cause);\n             }\n         }\n         try {\n-            final Class<?> clsUnsafe = Class.forName(\"sun.misc.Unsafe\");\n-            final Method cleanerMethod = clsUnsafe.getMethod(\"invokeCleaner\", ByteBuffer.class);\n-            final Field unsafeField = clsUnsafe.getDeclaredField(\"theUnsafe\");\n-            unsafeField.setAccessible(true);\n-            cleanerMethod.invoke(unsafeField.get((Object)null), buffer);\n+            final Class<?> forName2 = Class.forName(\"sun.misc.Unsafe\");\n+            final Method method = forName2.getMethod(\"invokeCleaner\", ByteBuffer.class);\n+            final Field declaredField = forName2.getDeclaredField(\"theUnsafe\");\n+            declaredField.setAccessible(true);\n+            method.invoke(declaredField.get((Object)null), obj);\n         }\n-        catch (final ReflectiveOperationException e) {\n-            throw new IllegalStateException(e);\n+        catch (final ReflectiveOperationException cause2) {\n+            throw new IllegalStateException(cause2);\n         }\n     }\n     \n     @Override\n     public synchronized void close() throws IOException {\n         try {\n             this.fileChannel.close();\n@@ -105,61 +102,61 @@\n         if (!this.refill()) {\n             return -1;\n         }\n         return this.byteBuffer.get() & 0xFF;\n     }\n     \n     @Override\n-    public synchronized int read(final byte[] b, final int offset, int len) throws IOException {\n-        if (offset < 0 || len < 0 || offset + len < 0 || offset + len > b.length) {\n+    public synchronized int read(final byte[] dst, final int offset, int min) throws IOException {\n+        if (offset < 0 || min < 0 || offset + min < 0 || offset + min > dst.length) {\n             throw new IndexOutOfBoundsException();\n         }\n         if (!this.refill()) {\n             return -1;\n         }\n-        len = Math.min(len, this.byteBuffer.remaining());\n-        this.byteBuffer.get(b, offset, len);\n-        return len;\n+        min = Math.min(min, this.byteBuffer.remaining());\n+        this.byteBuffer.get(dst, offset, min);\n+        return min;\n     }\n     \n     private boolean refill() throws IOException {\n         if (!this.byteBuffer.hasRemaining()) {\n             this.byteBuffer.clear();\n-            int nRead;\n-            for (nRead = 0; nRead == 0; nRead = this.fileChannel.read(this.byteBuffer)) {}\n+            int i;\n+            for (i = 0; i == 0; i = this.fileChannel.read(this.byteBuffer)) {}\n             this.byteBuffer.flip();\n-            return nRead >= 0;\n+            return i >= 0;\n         }\n         return true;\n     }\n     \n     @Override\n     public synchronized long skip(final long n) throws IOException {\n         if (n <= 0L) {\n             return 0L;\n         }\n         if (this.byteBuffer.remaining() >= n) {\n             this.byteBuffer.position();\n             return n;\n         }\n-        final long skippedFromBuffer = (long)this.byteBuffer.remaining();\n-        final long toSkipFromFileChannel = n - skippedFromBuffer;\n+        final long n2 = (long)this.byteBuffer.remaining();\n+        final long n3 = n - n2;\n         this.byteBuffer.position();\n         this.byteBuffer.flip();\n-        return skippedFromBuffer + this.skipFromFileChannel(toSkipFromFileChannel);\n+        return n2 + this.skipFromFileChannel(n3);\n     }\n     \n     private long skipFromFileChannel(final long n) throws IOException {\n-        final long currentFilePosition = this.fileChannel.position();\n+        final long position = this.fileChannel.position();\n         final long size = this.fileChannel.size();\n-        if (n > size - currentFilePosition) {\n+        if (n > size - position) {\n             this.fileChannel.position(size);\n-            return size - currentFilePosition;\n+            return size - position;\n         }\n-        this.fileChannel.position(currentFilePosition + n);\n+        this.fileChannel.position(position + n);\n         return n;\n     }\n     \n     static {\n         DIRECT_BUFFER_CLASS = getDirectBufferClass();\n     }\n }\n"}]}
