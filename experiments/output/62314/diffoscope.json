{"diffoscope-json-version": 1, "source1": "first/FTPSClient.class", "source2": "second/FTPSClient.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -64,14 +64,18 @@\n     private String[] suites;\n     private String[] protocols;\n     private TrustManager trustManager;\n     private KeyManager keyManager;\n     private HostnameVerifier hostnameVerifier;\n     private boolean tlsEndpointChecking;\n     \n+    static {\n+        PROT_COMMAND_VALUE = new String[] { \"C\", \"E\", \"S\", \"P\" };\n+    }\n+    \n     public FTPSClient() {\n         this(\"TLS\", false);\n     }\n     \n     public FTPSClient(final boolean isImplicit) {\n         this(\"TLS\", isImplicit);\n     }\n@@ -140,15 +144,17 @@\n         return socket;\n     }\n     \n     protected void _prepareDataSocket_(final Socket socket) throws IOException {\n     }\n     \n     private boolean checkPROTValue(final String prot) {\n-        for (final String element : FTPSClient.PROT_COMMAND_VALUE) {\n+        String[] prot_COMMAND_VALUE;\n+        for (int length = (prot_COMMAND_VALUE = FTPSClient.PROT_COMMAND_VALUE).length, i = 0; i < length; ++i) {\n+            final String element = prot_COMMAND_VALUE[i];\n             if (element.equals(prot)) {\n                 return true;\n             }\n         }\n         return false;\n     }\n     \n@@ -183,18 +189,16 @@\n             return this.sendCommand(\"ADAT\", Base64.encodeBase64StringUnChunked(data));\n         }\n         return this.sendCommand(\"ADAT\");\n     }\n     \n     protected void execAUTH() throws SSLException, IOException {\n         final int replyCode = this.sendCommand(\"AUTH\", this.auth);\n-        if (334 != replyCode) {\n-            if (234 != replyCode) {\n-                throw new SSLException(this.getReplyString());\n-            }\n+        if (334 != replyCode && 234 != replyCode) {\n+            throw new SSLException(this.getReplyString());\n         }\n     }\n     \n     public int execAUTH(final String mechanism) throws IOException {\n         return this.sendCommand(\"AUTH\", mechanism);\n     }\n     \n@@ -322,47 +326,69 @@\n     private Socket openDataSecureConnection(final String command, final String arg) throws IOException {\n         if (this.getDataConnectionMode() != 0 && this.getDataConnectionMode() != 2) {\n             return null;\n         }\n         final boolean isInet6Address = this.getRemoteAddress() instanceof Inet6Address;\n         Socket sslSocket = null;\n         final int soTimeoutMillis = DurationUtils.toMillisInt(this.getDataTimeout());\n-        Socket socket;\n-        if (this.getDataConnectionMode() == 0) {\n-            try (final ServerSocket server = this._serverSocketFactory_.createServerSocket(this.getActivePort(), 1, this.getHostAddress())) {\n-                if (isInet6Address) {\n-                    if (!FTPReply.isPositiveCompletion(this.eprt(this.getReportHostAddress(), server.getLocalPort()))) {\n-                        return null;\n+        Socket socket = null;\n+        Label_0602: {\n+            if (this.getDataConnectionMode() == 0) {\n+                Throwable t = null;\n+                try {\n+                    final ServerSocket server = this._serverSocketFactory_.createServerSocket(this.getActivePort(), 1, this.getHostAddress());\n+                    try {\n+                        if (isInet6Address) {\n+                            if (!FTPReply.isPositiveCompletion(this.eprt(this.getReportHostAddress(), server.getLocalPort()))) {\n+                                return null;\n+                            }\n+                        }\n+                        else if (!FTPReply.isPositiveCompletion(this.port(this.getReportHostAddress(), server.getLocalPort()))) {\n+                            return null;\n+                        }\n+                        if (this.getRestartOffset() > 0L && !this.restart(this.getRestartOffset())) {\n+                            return null;\n+                        }\n+                        if (!FTPReply.isPositivePreliminary(this.sendCommand(command, arg))) {\n+                            return null;\n+                        }\n+                        if (soTimeoutMillis >= 0) {\n+                            server.setSoTimeout(soTimeoutMillis);\n+                        }\n+                        socket = server.accept();\n+                        if (soTimeoutMillis >= 0) {\n+                            socket.setSoTimeout(soTimeoutMillis);\n+                        }\n+                        if (this.getReceiveDataSocketBufferSize() > 0) {\n+                            socket.setReceiveBufferSize(this.getReceiveDataSocketBufferSize());\n+                        }\n+                        if (this.getSendDataSocketBufferSize() > 0) {\n+                            socket.setSendBufferSize(this.getSendDataSocketBufferSize());\n+                        }\n+                        break Label_0602;\n+                    }\n+                    finally {\n+                        if (server != null) {\n+                            server.close();\n+                        }\n                     }\n                 }\n-                else if (!FTPReply.isPositiveCompletion(this.port(this.getReportHostAddress(), server.getLocalPort()))) {\n-                    return null;\n-                }\n-                if (this.getRestartOffset() > 0L && !this.restart(this.getRestartOffset())) {\n-                    return null;\n-                }\n-                if (!FTPReply.isPositivePreliminary(this.sendCommand(command, arg))) {\n-                    return null;\n-                }\n-                if (soTimeoutMillis >= 0) {\n-                    server.setSoTimeout(soTimeoutMillis);\n-                }\n-                socket = server.accept();\n-                if (soTimeoutMillis >= 0) {\n-                    socket.setSoTimeout(soTimeoutMillis);\n-                }\n-                if (this.getReceiveDataSocketBufferSize() > 0) {\n-                    socket.setReceiveBufferSize(this.getReceiveDataSocketBufferSize());\n-                }\n-                if (this.getSendDataSocketBufferSize() > 0) {\n-                    socket.setSendBufferSize(this.getSendDataSocketBufferSize());\n+                finally {\n+                    if (t == null) {\n+                        final Throwable exception;\n+                        t = exception;\n+                    }\n+                    else {\n+                        final Throwable exception;\n+                        if (t != exception) {\n+                            t.addSuppressed(exception);\n+                        }\n+                    }\n                 }\n             }\n-        }\n-        else {\n             final boolean attemptEPSV = this.isUseEPSVwithIPv4() || isInet6Address;\n             if (attemptEPSV && this.epsv() == 229) {\n                 this._parseExtendedPassiveModeReply((String)this._replyLines.get(0));\n             }\n             else {\n                 if (isInet6Address) {\n                     return null;\n@@ -514,12 +540,8 @@\n         this._socket_ = socket;\n         this._controlInput_ = new BufferedReader(new InputStreamReader(socket.getInputStream(), this.getControlEncoding()));\n         this._controlOutput_ = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), this.getControlEncoding()));\n         if (this.isClientMode && this.hostnameVerifier != null && !this.hostnameVerifier.verify(this._hostname_, socket.getSession())) {\n             throw new SSLHandshakeException(\"Hostname doesn't match certificate\");\n         }\n     }\n-    \n-    static {\n-        PROT_COMMAND_VALUE = new String[] { \"C\", \"E\", \"S\", \"P\" };\n-    }\n }\n"}]}
