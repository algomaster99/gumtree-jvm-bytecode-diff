{"diffoscope-json-version": 1, "source1": "first/TarArchiveOutputStream.class", "source2": "second/TarArchiveOutputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -50,69 +50,69 @@\n     private final CountingOutputStream countingOut;\n     private final ZipEncoding zipEncoding;\n     final String encoding;\n     private boolean addPaxHeadersForNonAsciiNames;\n     private static final ZipEncoding ASCII;\n     private static final int BLOCK_SIZE_UNSPECIFIED = -511;\n     \n-    public TarArchiveOutputStream(final OutputStream os) {\n-        this(os, -511);\n+    public TarArchiveOutputStream(final OutputStream outputStream) {\n+        this(outputStream, -511);\n     }\n     \n-    public TarArchiveOutputStream(final OutputStream os, final String encoding) {\n-        this(os, -511, encoding);\n+    public TarArchiveOutputStream(final OutputStream outputStream, final String s) {\n+        this(outputStream, -511, s);\n     }\n     \n-    public TarArchiveOutputStream(final OutputStream os, final int blockSize) {\n-        this(os, blockSize, null);\n+    public TarArchiveOutputStream(final OutputStream outputStream, final int n) {\n+        this(outputStream, n, null);\n     }\n     \n     @Deprecated\n-    public TarArchiveOutputStream(final OutputStream os, final int blockSize, final int recordSize) {\n-        this(os, blockSize, recordSize, null);\n+    public TarArchiveOutputStream(final OutputStream outputStream, final int n, final int n2) {\n+        this(outputStream, n, n2, null);\n     }\n     \n     @Deprecated\n-    public TarArchiveOutputStream(final OutputStream os, final int blockSize, final int recordSize, final String encoding) {\n-        this(os, blockSize, encoding);\n-        if (recordSize != 512) {\n-            throw new IllegalArgumentException(\"Tar record size must always be 512 bytes. Attempt to set size of \" + recordSize);\n+    public TarArchiveOutputStream(final OutputStream outputStream, final int n, final int i, final String s) {\n+        this(outputStream, n, s);\n+        if (i != 512) {\n+            throw new IllegalArgumentException(\"Tar record size must always be 512 bytes. Attempt to set size of \" + i);\n         }\n     }\n     \n-    public TarArchiveOutputStream(final OutputStream os, final int blockSize, final String encoding) {\n+    public TarArchiveOutputStream(final OutputStream outputStream, final int i, final String encoding) {\n         this.longFileMode = 0;\n         this.bigNumberMode = 0;\n-        int realBlockSize;\n-        if (-511 == blockSize) {\n-            realBlockSize = 512;\n+        int n;\n+        if (-511 == i) {\n+            n = 512;\n         }\n         else {\n-            realBlockSize = blockSize;\n+            n = i;\n         }\n-        if (realBlockSize <= 0 || realBlockSize % 512 != 0) {\n-            throw new IllegalArgumentException(\"Block size must be a multiple of 512 bytes. Attempt to use set size of \" + blockSize);\n+        if (n <= 0 || n % 512 != 0) {\n+            throw new IllegalArgumentException(\"Block size must be a multiple of 512 bytes. Attempt to use set size of \" + i);\n         }\n-        this.out = new FixedLengthBlockOutputStream((OutputStream)(this.countingOut = new CountingOutputStream(os)), 512);\n+        this.out = new FixedLengthBlockOutputStream((OutputStream)(this.countingOut = new CountingOutputStream(outputStream)), 512);\n         this.encoding = encoding;\n         this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n         this.recordBuf = new byte[512];\n-        this.recordsPerBlock = realBlockSize / 512;\n+        this.recordsPerBlock = n / 512;\n     }\n     \n     public void setLongFileMode(final int longFileMode) {\n         this.longFileMode = longFileMode;\n     }\n     \n     public void setBigNumberMode(final int bigNumberMode) {\n         this.bigNumberMode = bigNumberMode;\n     }\n     \n-    public void setAddPaxHeadersForNonAsciiNames(final boolean b) {\n-        this.addPaxHeadersForNonAsciiNames = b;\n+    public void setAddPaxHeadersForNonAsciiNames(final boolean addPaxHeadersForNonAsciiNames) {\n+        this.addPaxHeadersForNonAsciiNames = addPaxHeadersForNonAsciiNames;\n     }\n     \n     @Deprecated\n     public int getCount() {\n         return (int)this.getBytesWritten();\n     }\n     \n@@ -153,58 +153,58 @@\n         return 512;\n     }\n     \n     public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\n         if (this.finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n-        final TarArchiveEntry entry = (TarArchiveEntry)archiveEntry;\n-        if (entry.isGlobalPaxHeader()) {\n-            final byte[] data = this.encodeExtendedPaxHeadersContents(entry.getExtraPaxHeaders());\n-            entry.setSize((long)data.length);\n-            entry.writeEntryHeader(this.recordBuf, this.zipEncoding, this.bigNumberMode == 1);\n+        final TarArchiveEntry tarArchiveEntry = (TarArchiveEntry)archiveEntry;\n+        if (tarArchiveEntry.isGlobalPaxHeader()) {\n+            final byte[] encodeExtendedPaxHeadersContents = this.encodeExtendedPaxHeadersContents(tarArchiveEntry.getExtraPaxHeaders());\n+            tarArchiveEntry.setSize((long)encodeExtendedPaxHeadersContents.length);\n+            tarArchiveEntry.writeEntryHeader(this.recordBuf, this.zipEncoding, this.bigNumberMode == 1);\n             this.writeRecord(this.recordBuf);\n-            this.currSize = entry.getSize();\n+            this.currSize = tarArchiveEntry.getSize();\n             this.currBytes = 0L;\n             this.haveUnclosedEntry = true;\n-            this.write(data);\n+            this.write(encodeExtendedPaxHeadersContents);\n             this.closeArchiveEntry();\n         }\n         else {\n-            final Map<String, String> paxHeaders = new HashMap<String, String>();\n-            final String entryName = entry.getName();\n-            final boolean paxHeaderContainsPath = this.handleLongName(entry, entryName, paxHeaders, \"path\", (byte)76, \"file name\");\n-            final String linkName = entry.getLinkName();\n-            final boolean paxHeaderContainsLinkPath = linkName != null && !linkName.isEmpty() && this.handleLongName(entry, linkName, paxHeaders, \"linkpath\", (byte)75, \"link name\");\n+            final HashMap hashMap = new HashMap();\n+            final String name = tarArchiveEntry.getName();\n+            final boolean handleLongName = this.handleLongName(tarArchiveEntry, name, hashMap, \"path\", (byte)76, \"file name\");\n+            final String linkName = tarArchiveEntry.getLinkName();\n+            final boolean b = linkName != null && !linkName.isEmpty() && this.handleLongName(tarArchiveEntry, linkName, hashMap, \"linkpath\", (byte)75, \"link name\");\n             if (this.bigNumberMode == 2) {\n-                this.addPaxHeadersForBigNumbers(paxHeaders, entry);\n+                this.addPaxHeadersForBigNumbers(hashMap, tarArchiveEntry);\n             }\n             else if (this.bigNumberMode != 1) {\n-                this.failForBigNumbers(entry);\n+                this.failForBigNumbers(tarArchiveEntry);\n             }\n-            if (this.addPaxHeadersForNonAsciiNames && !paxHeaderContainsPath && !TarArchiveOutputStream.ASCII.canEncode(entryName)) {\n-                paxHeaders.put(\"path\", entryName);\n+            if (this.addPaxHeadersForNonAsciiNames && !handleLongName && !TarArchiveOutputStream.ASCII.canEncode(name)) {\n+                hashMap.put(\"path\", name);\n             }\n-            if (this.addPaxHeadersForNonAsciiNames && !paxHeaderContainsLinkPath && (entry.isLink() || entry.isSymbolicLink()) && !TarArchiveOutputStream.ASCII.canEncode(linkName)) {\n-                paxHeaders.put(\"linkpath\", linkName);\n+            if (this.addPaxHeadersForNonAsciiNames && !b && (tarArchiveEntry.isLink() || tarArchiveEntry.isSymbolicLink()) && !TarArchiveOutputStream.ASCII.canEncode(linkName)) {\n+                hashMap.put(\"linkpath\", linkName);\n             }\n-            paxHeaders.putAll(entry.getExtraPaxHeaders());\n-            if (!paxHeaders.isEmpty()) {\n-                this.writePaxHeaders(entry, entryName, paxHeaders);\n+            hashMap.putAll(tarArchiveEntry.getExtraPaxHeaders());\n+            if (!hashMap.isEmpty()) {\n+                this.writePaxHeaders(tarArchiveEntry, name, hashMap);\n             }\n-            entry.writeEntryHeader(this.recordBuf, this.zipEncoding, this.bigNumberMode == 1);\n+            tarArchiveEntry.writeEntryHeader(this.recordBuf, this.zipEncoding, this.bigNumberMode == 1);\n             this.writeRecord(this.recordBuf);\n             this.currBytes = 0L;\n-            if (entry.isDirectory()) {\n+            if (tarArchiveEntry.isDirectory()) {\n                 this.currSize = 0L;\n             }\n             else {\n-                this.currSize = entry.getSize();\n+                this.currSize = tarArchiveEntry.getSize();\n             }\n-            this.currName = entryName;\n+            this.currName = name;\n             this.haveUnclosedEntry = true;\n         }\n     }\n     \n     public void closeArchiveEntry() throws IOException {\n         if (this.finished) {\n             throw new IOException(\"Stream has already been finished\");\n@@ -219,64 +219,67 @@\n         this.recordsWritten = ExactMath.add(this.recordsWritten, this.currSize / 512L);\n         if (0L != this.currSize % 512L) {\n             ++this.recordsWritten;\n         }\n         this.haveUnclosedEntry = false;\n     }\n     \n-    public void write(final byte[] wBuf, final int wOffset, final int numToWrite) throws IOException {\n+    public void write(final byte[] array, final int n, final int i) throws IOException {\n         if (!this.haveUnclosedEntry) {\n             throw new IllegalStateException(\"No current tar entry\");\n         }\n-        if (this.currBytes + numToWrite > this.currSize) {\n-            throw new IOException(\"Request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + this.currSize + \"' bytes for entry '\" + this.currName + \"'\");\n+        if (this.currBytes + i > this.currSize) {\n+            throw new IOException(\"Request to write '\" + i + \"' bytes exceeds size in header of '\" + this.currSize + \"' bytes for entry '\" + this.currName + \"'\");\n         }\n-        this.out.write(wBuf, wOffset, numToWrite);\n-        this.currBytes += numToWrite;\n+        this.out.write(array, n, i);\n+        this.currBytes += i;\n     }\n     \n-    void writePaxHeaders(final TarArchiveEntry entry, final String entryName, final Map<String, String> headers) throws IOException {\n-        String name = \"./PaxHeaders.X/\" + this.stripTo7Bits(entryName);\n-        if (name.length() >= 100) {\n-            name = name.substring(0, 99);\n-        }\n-        final TarArchiveEntry pex = new TarArchiveEntry(name, (byte)120);\n-        this.transferModTime(entry, pex);\n-        final byte[] data = this.encodeExtendedPaxHeadersContents(headers);\n-        pex.setSize((long)data.length);\n-        this.putArchiveEntry((ArchiveEntry)pex);\n-        this.write(data);\n+    void writePaxHeaders(final TarArchiveEntry tarArchiveEntry, final String s, final Map<String, String> map) throws IOException {\n+        String s2 = \"./PaxHeaders.X/\" + this.stripTo7Bits(s);\n+        if (s2.length() >= 100) {\n+            s2 = s2.substring(0, 99);\n+        }\n+        final TarArchiveEntry tarArchiveEntry2 = new TarArchiveEntry(s2, (byte)120);\n+        this.transferModTime(tarArchiveEntry, tarArchiveEntry2);\n+        final byte[] encodeExtendedPaxHeadersContents = this.encodeExtendedPaxHeadersContents(map);\n+        tarArchiveEntry2.setSize((long)encodeExtendedPaxHeadersContents.length);\n+        this.putArchiveEntry((ArchiveEntry)tarArchiveEntry2);\n+        this.write(encodeExtendedPaxHeadersContents);\n         this.closeArchiveEntry();\n     }\n     \n-    private byte[] encodeExtendedPaxHeadersContents(final Map<String, String> headers) {\n-        final StringWriter w = new StringWriter();\n-        headers.forEach((k, v) -> {\n-            int len = k.length() + v.length() + 3 + 2;\n-            String line = len + \" \" + k + \"=\" + v + \"\\n\";\n-            for (int actualLength = line.getBytes(StandardCharsets.UTF_8).length; len != actualLength; len = actualLength, line = len + \" \" + k + \"=\" + v + \"\\n\", actualLength = line.getBytes(StandardCharsets.UTF_8).length) {}\n-            w.write(line);\n+    private byte[] encodeExtendedPaxHeadersContents(final Map<String, String> map) {\n+        final StringWriter stringWriter = new StringWriter();\n+        map.forEach((s, s2) -> {\n+            final int i = s.length() + s2.length() + 3 + 2;\n+            new StringBuilder().append(i).append(\" \").append(s).append(\"=\").append(s2).append(\"\\n\").toString();\n+            final String str;\n+            for (int n = str.getBytes(StandardCharsets.UTF_8).length; i != n; n = str.getBytes(StandardCharsets.UTF_8).length) {\n+                new StringBuilder().append(i).append(\" \").append(s).append(\"=\").append(s2).append(\"\\n\").toString();\n+            }\n+            stringWriter2.write(str);\n             return;\n         });\n-        return w.toString().getBytes(StandardCharsets.UTF_8);\n+        return stringWriter.toString().getBytes(StandardCharsets.UTF_8);\n     }\n     \n-    private String stripTo7Bits(final String name) {\n-        final int length = name.length();\n-        final StringBuilder result = new StringBuilder(length);\n+    private String stripTo7Bits(final String s) {\n+        final int length = s.length();\n+        final StringBuilder sb = new StringBuilder(length);\n         for (int i = 0; i < length; ++i) {\n-            final char stripped = (char)(name.charAt(i) & '\\u007f');\n-            if (this.shouldBeReplaced(stripped)) {\n-                result.append(\"_\");\n+            final char c = (char)(s.charAt(i) & '\\u007f');\n+            if (this.shouldBeReplaced(c)) {\n+                sb.append(\"_\");\n             }\n             else {\n-                result.append(stripped);\n+                sb.append(c);\n             }\n         }\n-        return result.toString();\n+        return sb.toString();\n     }\n     \n     private boolean shouldBeReplaced(final char c) {\n         return c == '\\0' || c == '/' || c == '\\\\';\n     }\n     \n     private void writeEOFRecord() throws IOException {\n@@ -284,157 +287,154 @@\n         this.writeRecord(this.recordBuf);\n     }\n     \n     public void flush() throws IOException {\n         this.out.flush();\n     }\n     \n-    public ArchiveEntry createArchiveEntry(final File inputFile, final String entryName) throws IOException {\n+    public ArchiveEntry createArchiveEntry(final File file, final String s) throws IOException {\n         if (this.finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n-        return (ArchiveEntry)new TarArchiveEntry(inputFile, entryName);\n+        return (ArchiveEntry)new TarArchiveEntry(file, s);\n     }\n     \n-    public ArchiveEntry createArchiveEntry(final Path inputPath, final String entryName, final LinkOption... options) throws IOException {\n+    public ArchiveEntry createArchiveEntry(final Path path, final String s, final LinkOption... array) throws IOException {\n         if (this.finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n-        return (ArchiveEntry)new TarArchiveEntry(inputPath, entryName, options);\n+        return (ArchiveEntry)new TarArchiveEntry(path, s, array);\n     }\n     \n-    private void writeRecord(final byte[] record) throws IOException {\n-        if (record.length != 512) {\n-            throw new IOException(\"Record to write has length '\" + record.length + \"' which is not the record size of '\" + 512 + \"'\");\n+    private void writeRecord(final byte[] array) throws IOException {\n+        if (array.length != 512) {\n+            throw new IOException(\"Record to write has length '\" + array.length + \"' which is not the record size of '\" + 512 + \"'\");\n         }\n-        this.out.write(record);\n+        this.out.write(array);\n         ++this.recordsWritten;\n     }\n     \n     private void padAsNeeded() throws IOException {\n-        final int start = this.recordsWritten % this.recordsPerBlock;\n-        if (start != 0) {\n-            for (int i = start; i < this.recordsPerBlock; ++i) {\n+        final int n = this.recordsWritten % this.recordsPerBlock;\n+        if (n != 0) {\n+            for (int i = n; i < this.recordsPerBlock; ++i) {\n                 this.writeEOFRecord();\n             }\n         }\n     }\n     \n-    private void addPaxHeadersForBigNumbers(final Map<String, String> paxHeaders, final TarArchiveEntry entry) {\n-        this.addPaxHeaderForBigNumber(paxHeaders, \"size\", entry.getSize(), 8589934591L);\n-        this.addPaxHeaderForBigNumber(paxHeaders, \"gid\", entry.getLongGroupId(), 2097151L);\n-        this.addFileTimePaxHeaderForBigNumber(paxHeaders, \"mtime\", entry.getLastModifiedTime(), 8589934591L);\n-        this.addFileTimePaxHeader(paxHeaders, \"atime\", entry.getLastAccessTime());\n-        if (entry.getStatusChangeTime() != null) {\n-            this.addFileTimePaxHeader(paxHeaders, \"ctime\", entry.getStatusChangeTime());\n+    private void addPaxHeadersForBigNumbers(final Map<String, String> map, final TarArchiveEntry tarArchiveEntry) {\n+        this.addPaxHeaderForBigNumber(map, \"size\", tarArchiveEntry.getSize(), 8589934591L);\n+        this.addPaxHeaderForBigNumber(map, \"gid\", tarArchiveEntry.getLongGroupId(), 2097151L);\n+        this.addFileTimePaxHeaderForBigNumber(map, \"mtime\", tarArchiveEntry.getLastModifiedTime(), 8589934591L);\n+        this.addFileTimePaxHeader(map, \"atime\", tarArchiveEntry.getLastAccessTime());\n+        if (tarArchiveEntry.getStatusChangeTime() != null) {\n+            this.addFileTimePaxHeader(map, \"ctime\", tarArchiveEntry.getStatusChangeTime());\n         }\n         else {\n-            this.addFileTimePaxHeader(paxHeaders, \"ctime\", entry.getCreationTime());\n+            this.addFileTimePaxHeader(map, \"ctime\", tarArchiveEntry.getCreationTime());\n         }\n-        this.addPaxHeaderForBigNumber(paxHeaders, \"uid\", entry.getLongUserId(), 2097151L);\n-        this.addFileTimePaxHeader(paxHeaders, \"LIBARCHIVE.creationtime\", entry.getCreationTime());\n-        this.addPaxHeaderForBigNumber(paxHeaders, \"SCHILY.devmajor\", entry.getDevMajor(), 2097151L);\n-        this.addPaxHeaderForBigNumber(paxHeaders, \"SCHILY.devminor\", entry.getDevMinor(), 2097151L);\n-        this.failForBigNumber(\"mode\", entry.getMode(), 2097151L);\n+        this.addPaxHeaderForBigNumber(map, \"uid\", tarArchiveEntry.getLongUserId(), 2097151L);\n+        this.addFileTimePaxHeader(map, \"LIBARCHIVE.creationtime\", tarArchiveEntry.getCreationTime());\n+        this.addPaxHeaderForBigNumber(map, \"SCHILY.devmajor\", tarArchiveEntry.getDevMajor(), 2097151L);\n+        this.addPaxHeaderForBigNumber(map, \"SCHILY.devminor\", tarArchiveEntry.getDevMinor(), 2097151L);\n+        this.failForBigNumber(\"mode\", tarArchiveEntry.getMode(), 2097151L);\n     }\n     \n-    private void addPaxHeaderForBigNumber(final Map<String, String> paxHeaders, final String header, final long value, final long maxValue) {\n-        if (value < 0L || value > maxValue) {\n-            paxHeaders.put(header, String.valueOf(value));\n+    private void addPaxHeaderForBigNumber(final Map<String, String> map, final String s, final long l, final long n) {\n+        if (l < 0L || l > n) {\n+            map.put(s, String.valueOf(l));\n         }\n     }\n     \n-    private void addFileTimePaxHeaderForBigNumber(final Map<String, String> paxHeaders, final String header, final FileTime value, final long maxValue) {\n-        if (value != null) {\n-            final Instant instant = value.toInstant();\n-            final long seconds = instant.getEpochSecond();\n-            final int nanos = instant.getNano();\n-            if (nanos == 0) {\n-                this.addPaxHeaderForBigNumber(paxHeaders, header, seconds, maxValue);\n+    private void addFileTimePaxHeaderForBigNumber(final Map<String, String> map, final String s, final FileTime fileTime, final long n) {\n+        if (fileTime != null) {\n+            final Instant instant = fileTime.toInstant();\n+            final long epochSecond = instant.getEpochSecond();\n+            final int nano = instant.getNano();\n+            if (nano == 0) {\n+                this.addPaxHeaderForBigNumber(map, s, epochSecond, n);\n             }\n             else {\n-                this.addInstantPaxHeader(paxHeaders, header, seconds, nanos);\n+                this.addInstantPaxHeader(map, s, epochSecond, nano);\n             }\n         }\n     }\n     \n-    private void addFileTimePaxHeader(final Map<String, String> paxHeaders, final String header, final FileTime value) {\n-        if (value != null) {\n-            final Instant instant = value.toInstant();\n-            final long seconds = instant.getEpochSecond();\n-            final int nanos = instant.getNano();\n-            if (nanos == 0) {\n-                paxHeaders.put(header, String.valueOf(seconds));\n+    private void addFileTimePaxHeader(final Map<String, String> map, final String s, final FileTime fileTime) {\n+        if (fileTime != null) {\n+            final Instant instant = fileTime.toInstant();\n+            final long epochSecond = instant.getEpochSecond();\n+            final int nano = instant.getNano();\n+            if (nano == 0) {\n+                map.put(s, String.valueOf(epochSecond));\n             }\n             else {\n-                this.addInstantPaxHeader(paxHeaders, header, seconds, nanos);\n+                this.addInstantPaxHeader(map, s, epochSecond, nano);\n             }\n         }\n     }\n     \n-    private void addInstantPaxHeader(final Map<String, String> paxHeaders, final String header, final long seconds, final int nanos) {\n-        final BigDecimal bdSeconds = BigDecimal.valueOf(seconds);\n-        final BigDecimal bdNanos = BigDecimal.valueOf(nanos).movePointLeft(9).setScale(7, RoundingMode.DOWN);\n-        final BigDecimal timestamp = bdSeconds.add(bdNanos);\n-        paxHeaders.put(header, timestamp.toPlainString());\n+    private void addInstantPaxHeader(final Map<String, String> map, final String s, final long val, final int n) {\n+        map.put(s, BigDecimal.valueOf(val).add(BigDecimal.valueOf(n).movePointLeft(9).setScale(7, RoundingMode.DOWN)).toPlainString());\n     }\n     \n-    private void failForBigNumbers(final TarArchiveEntry entry) {\n-        this.failForBigNumber(\"entry size\", entry.getSize(), 8589934591L);\n-        this.failForBigNumberWithPosixMessage(\"group id\", entry.getLongGroupId(), 2097151L);\n-        this.failForBigNumber(\"last modification time\", entry.getLastModifiedTime().to(TimeUnit.SECONDS), 8589934591L);\n-        this.failForBigNumber(\"user id\", entry.getLongUserId(), 2097151L);\n-        this.failForBigNumber(\"mode\", entry.getMode(), 2097151L);\n-        this.failForBigNumber(\"major device number\", entry.getDevMajor(), 2097151L);\n-        this.failForBigNumber(\"minor device number\", entry.getDevMinor(), 2097151L);\n+    private void failForBigNumbers(final TarArchiveEntry tarArchiveEntry) {\n+        this.failForBigNumber(\"entry size\", tarArchiveEntry.getSize(), 8589934591L);\n+        this.failForBigNumberWithPosixMessage(\"group id\", tarArchiveEntry.getLongGroupId(), 2097151L);\n+        this.failForBigNumber(\"last modification time\", tarArchiveEntry.getLastModifiedTime().to(TimeUnit.SECONDS), 8589934591L);\n+        this.failForBigNumber(\"user id\", tarArchiveEntry.getLongUserId(), 2097151L);\n+        this.failForBigNumber(\"mode\", tarArchiveEntry.getMode(), 2097151L);\n+        this.failForBigNumber(\"major device number\", tarArchiveEntry.getDevMajor(), 2097151L);\n+        this.failForBigNumber(\"minor device number\", tarArchiveEntry.getDevMinor(), 2097151L);\n     }\n     \n-    private void failForBigNumber(final String field, final long value, final long maxValue) {\n-        this.failForBigNumber(field, value, maxValue, \"\");\n+    private void failForBigNumber(final String s, final long n, final long n2) {\n+        this.failForBigNumber(s, n, n2, \"\");\n     }\n     \n-    private void failForBigNumberWithPosixMessage(final String field, final long value, final long maxValue) {\n-        this.failForBigNumber(field, value, maxValue, \" Use STAR or POSIX extensions to overcome this limit\");\n+    private void failForBigNumberWithPosixMessage(final String s, final long n, final long n2) {\n+        this.failForBigNumber(s, n, n2, \" Use STAR or POSIX extensions to overcome this limit\");\n     }\n     \n-    private void failForBigNumber(final String field, final long value, final long maxValue, final String additionalMsg) {\n-        if (value < 0L || value > maxValue) {\n-            throw new IllegalArgumentException(field + \" '\" + value + \"' is too big ( > \" + maxValue + \" ).\" + additionalMsg);\n+    private void failForBigNumber(final String str, final long lng, final long lng2, final String str2) {\n+        if (lng < 0L || lng > lng2) {\n+            throw new IllegalArgumentException(str + \" '\" + lng + \"' is too big ( > \" + lng2 + \" ).\" + str2);\n         }\n     }\n     \n-    private boolean handleLongName(final TarArchiveEntry entry, final String name, final Map<String, String> paxHeaders, final String paxHeaderName, final byte linkType, final String fieldName) throws IOException {\n-        final ByteBuffer encodedName = this.zipEncoding.encode(name);\n-        final int len = encodedName.limit() - encodedName.position();\n-        if (len >= 100) {\n+    private boolean handleLongName(final TarArchiveEntry tarArchiveEntry, final String str, final Map<String, String> map, final String s, final byte b, final String str2) throws IOException {\n+        final ByteBuffer encode = this.zipEncoding.encode(str);\n+        final int n = encode.limit() - encode.position();\n+        if (n >= 100) {\n             if (this.longFileMode == 3) {\n-                paxHeaders.put(paxHeaderName, name);\n+                map.put(s, str);\n                 return true;\n             }\n             if (this.longFileMode == 2) {\n-                final TarArchiveEntry longLinkEntry = new TarArchiveEntry(\"././@LongLink\", linkType);\n-                longLinkEntry.setSize((long)len + 1L);\n-                this.transferModTime(entry, longLinkEntry);\n-                this.putArchiveEntry((ArchiveEntry)longLinkEntry);\n-                this.write(encodedName.array(), encodedName.arrayOffset(), len);\n+                final TarArchiveEntry tarArchiveEntry2 = new TarArchiveEntry(\"././@LongLink\", b);\n+                tarArchiveEntry2.setSize((long)n + 1L);\n+                this.transferModTime(tarArchiveEntry, tarArchiveEntry2);\n+                this.putArchiveEntry((ArchiveEntry)tarArchiveEntry2);\n+                this.write(encode.array(), encode.arrayOffset(), n);\n                 this.write(0);\n                 this.closeArchiveEntry();\n             }\n             else if (this.longFileMode != 1) {\n-                throw new IllegalArgumentException(fieldName + \" '\" + name + \"' is too long ( > \" + 100 + \" bytes)\");\n+                throw new IllegalArgumentException(str2 + \" '\" + str + \"' is too long ( > \" + 100 + \" bytes)\");\n             }\n         }\n         return false;\n     }\n     \n-    private void transferModTime(final TarArchiveEntry from, final TarArchiveEntry to) {\n-        long fromModTimeSeconds = from.getLastModifiedTime().to(TimeUnit.SECONDS);\n-        if (fromModTimeSeconds < 0L || fromModTimeSeconds > 8589934591L) {\n-            fromModTimeSeconds = 0L;\n+    private void transferModTime(final TarArchiveEntry tarArchiveEntry, final TarArchiveEntry tarArchiveEntry2) {\n+        long to = tarArchiveEntry.getLastModifiedTime().to(TimeUnit.SECONDS);\n+        if (to < 0L || to > 8589934591L) {\n+            to = 0L;\n         }\n-        to.setLastModifiedTime(FileTime.from(fromModTimeSeconds, TimeUnit.SECONDS));\n+        tarArchiveEntry2.setLastModifiedTime(FileTime.from(to, TimeUnit.SECONDS));\n     }\n     \n     static {\n         ASCII = ZipEncodingHelper.getZipEncoding(\"ASCII\");\n     }\n }\n"}]}
