{"diffoscope-json-version": 1, "source1": "first/ModelTransaction$ChildrenUpdateOperation.class", "source2": "second/ModelTransaction$ChildrenUpdateOperation.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -13,57 +13,57 @@\n {\n     private Collection<ImmutableNode> newNodes;\n     private Set<ImmutableNode> nodesToRemove;\n     private Map<ImmutableNode, ImmutableNode> nodesToReplace;\n     \n     private ChildrenUpdateOperation(final ModelTransaction this$0) {\n         this.this$0 = this$0;\n-        super((ModelTransaction.ModelTransaction$1)null);\n+        super((ModelTransaction.Operation)null);\n     }\n     \n     public void combine(final ChildrenUpdateOperation op) {\n-        this.newNodes = ModelTransaction.access$600(this.newNodes, op.newNodes);\n-        this.nodesToReplace = ModelTransaction.access$700(this.nodesToReplace, op.nodesToReplace);\n-        this.nodesToRemove = ModelTransaction.access$800(this.nodesToRemove, op.nodesToRemove);\n+        this.newNodes = ModelTransaction.access$0(this.newNodes, op.newNodes);\n+        this.nodesToReplace = ModelTransaction.access$1(this.nodesToReplace, op.nodesToReplace);\n+        this.nodesToRemove = ModelTransaction.access$2(this.nodesToRemove, op.nodesToRemove);\n     }\n     \n     public void addNewNode(final ImmutableNode node) {\n-        this.newNodes = ModelTransaction.access$900(this.newNodes, (Object)node);\n+        this.newNodes = ModelTransaction.access$3(this.newNodes, (Object)node);\n     }\n     \n     public void addNewNodes(final Collection<? extends ImmutableNode> nodes) {\n-        this.newNodes = ModelTransaction.access$600(this.newNodes, (Collection)nodes);\n+        this.newNodes = ModelTransaction.access$0(this.newNodes, (Collection)nodes);\n     }\n     \n     public void addNodeToReplace(final ImmutableNode org, final ImmutableNode replacement) {\n-        this.nodesToReplace = ModelTransaction.access$1000(this.nodesToReplace, (Object)org, (Object)replacement);\n+        this.nodesToReplace = ModelTransaction.access$4(this.nodesToReplace, (Object)org, (Object)replacement);\n     }\n     \n     public void addNodeToRemove(final ImmutableNode node) {\n-        this.nodesToRemove = ModelTransaction.access$1100(this.nodesToRemove, (Object)node);\n+        this.nodesToRemove = ModelTransaction.access$5(this.nodesToRemove, (Object)node);\n     }\n     \n     protected ImmutableNode apply(final ImmutableNode target, final ModelTransaction.Operations operations) {\n         final Map<ImmutableNode, ImmutableNode> replacements = this.fetchReplacementMap();\n         final Set<ImmutableNode> removals = this.fetchRemovalSet();\n         final List<ImmutableNode> resultNodes = new LinkedList<ImmutableNode>();\n         for (final ImmutableNode nd : target) {\n             final ImmutableNode repl = (ImmutableNode)replacements.get(nd);\n             if (repl != null) {\n                 resultNodes.add(repl);\n-                ModelTransaction.access$1200(this.this$0).put(nd, repl);\n+                ModelTransaction.access$6(this.this$0).put(nd, repl);\n             }\n             else if (removals.contains(nd)) {\n-                ModelTransaction.access$1300(this.this$0).add(nd);\n+                ModelTransaction.access$7(this.this$0).add(nd);\n             }\n             else {\n                 resultNodes.add(nd);\n             }\n         }\n-        ModelTransaction.access$600((Collection)resultNodes, this.newNodes);\n+        ModelTransaction.access$0((Collection)resultNodes, this.newNodes);\n         operations.newNodesAdded(this.newNodes);\n         return target.replaceChildren((Collection)resultNodes);\n     }\n     \n     private Map<ImmutableNode, ImmutableNode> fetchReplacementMap() {\n         return (this.nodesToReplace != null) ? this.nodesToReplace : Collections.emptyMap();\n     }\n"}]}
