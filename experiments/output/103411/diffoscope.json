{"diffoscope-json-version": 1, "source1": "first/ZipArchiveOutputStream.class", "source2": "second/ZipArchiveOutputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -98,14 +98,26 @@\n     private ZipArchiveOutputStream.UnicodeExtraFieldPolicy createUnicodeExtraFields;\n     private boolean hasUsedZip64;\n     private Zip64Mode zip64Mode;\n     private final byte[] copyBuffer;\n     private final boolean isSplitZip;\n     private final Map<Integer, Integer> numberOfCDInDiskData;\n     \n+    static {\n+        ZERO = new byte[2];\n+        LZERO = new byte[4];\n+        ONE = ZipLong.getBytes(1L);\n+        LFH_SIG = ZipLong.LFH_SIG.getBytes();\n+        DD_SIG = ZipLong.DD_SIG.getBytes();\n+        CFH_SIG = ZipLong.CFH_SIG.getBytes();\n+        EOCD_SIG = ZipLong.getBytes(101010256L);\n+        ZIP64_EOCD_SIG = ZipLong.getBytes(101075792L);\n+        ZIP64_EOCD_LOC_SIG = ZipLong.getBytes(117853008L);\n+    }\n+    \n     public ZipArchiveOutputStream(final File file) throws IOException {\n         this(file.toPath(), new OpenOption[0]);\n     }\n     \n     public ZipArchiveOutputStream(final File file, final long zipSplitSize) throws IOException {\n         this(file.toPath(), zipSplitSize);\n     }\n@@ -233,68 +245,69 @@\n             final ZipArchiveEntry zae = (ZipArchiveEntry)ae;\n             return zae.getMethod() != ZipMethod.IMPLODING.getCode() && zae.getMethod() != ZipMethod.UNSHRINKING.getCode() && ZipUtil.canHandleEntryData(zae);\n         }\n         return false;\n     }\n     \n     private boolean checkIfNeedsZip64(final Zip64Mode effectiveMode) throws ZipException {\n-        final boolean actuallyNeedsZip64 = this.isZip64Required(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry), effectiveMode);\n+        final boolean actuallyNeedsZip64 = this.isZip64Required(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry), effectiveMode);\n         if (actuallyNeedsZip64 && effectiveMode == Zip64Mode.Never) {\n-            throw new Zip64RequiredException(Zip64RequiredException.getEntryTooBigMessage(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry)));\n+            throw new Zip64RequiredException(Zip64RequiredException.getEntryTooBigMessage(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry)));\n         }\n         return actuallyNeedsZip64;\n     }\n     \n     public void close() throws IOException {\n         try {\n             if (!this.finished) {\n                 this.finish();\n             }\n         }\n         finally {\n             this.destroy();\n         }\n+        this.destroy();\n     }\n     \n     public void closeArchiveEntry() throws IOException {\n         this.preClose();\n         this.flushDeflater();\n-        final long bytesWritten = this.streamCompressor.getTotalBytesWritten() - ZipArchiveOutputStream.CurrentEntry.access$100(this.entry);\n+        final long bytesWritten = this.streamCompressor.getTotalBytesWritten() - ZipArchiveOutputStream.CurrentEntry.access$1(this.entry);\n         final long realCrc = this.streamCompressor.getCrc32();\n-        ZipArchiveOutputStream.CurrentEntry.access$202(this.entry, this.streamCompressor.getBytesRead());\n-        final Zip64Mode effectiveMode = this.getEffectiveZip64Mode(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry));\n+        ZipArchiveOutputStream.CurrentEntry.access$2(this.entry, this.streamCompressor.getBytesRead());\n+        final Zip64Mode effectiveMode = this.getEffectiveZip64Mode(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry));\n         final boolean actuallyNeedsZip64 = this.handleSizesAndCrc(bytesWritten, realCrc, effectiveMode);\n         this.closeEntry(actuallyNeedsZip64, false);\n         this.streamCompressor.reset();\n     }\n     \n     private void closeCopiedEntry(final boolean phased) throws IOException {\n         this.preClose();\n-        ZipArchiveOutputStream.CurrentEntry.access$202(this.entry, ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getSize());\n-        final Zip64Mode effectiveMode = this.getEffectiveZip64Mode(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry));\n+        ZipArchiveOutputStream.CurrentEntry.access$2(this.entry, ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getSize());\n+        final Zip64Mode effectiveMode = this.getEffectiveZip64Mode(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry));\n         final boolean actuallyNeedsZip64 = this.checkIfNeedsZip64(effectiveMode);\n         this.closeEntry(actuallyNeedsZip64, phased);\n     }\n     \n     private void closeEntry(final boolean actuallyNeedsZip64, final boolean phased) throws IOException {\n         if (!phased && this.channel != null) {\n             this.rewriteSizesAndCrc(actuallyNeedsZip64);\n         }\n         if (!phased) {\n-            this.writeDataDescriptor(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry));\n+            this.writeDataDescriptor(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry));\n         }\n         this.entry = null;\n     }\n     \n     private void copyFromZipInputStream(final InputStream src) throws IOException {\n         if (this.entry == null) {\n             throw new IllegalStateException(\"No current entry\");\n         }\n-        ZipUtil.checkRequestedFeatures(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry));\n-        ZipArchiveOutputStream.CurrentEntry.access$302(this.entry, true);\n+        ZipUtil.checkRequestedFeatures(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry));\n+        ZipArchiveOutputStream.CurrentEntry.access$3(this.entry, true);\n         int length;\n         while ((length = src.read(this.copyBuffer)) >= 0) {\n             this.streamCompressor.writeCounted(this.copyBuffer, 0, length);\n             this.count(length);\n         }\n     }\n     \n@@ -310,19 +323,19 @@\n             throw new IOException(\"Stream has already been finished\");\n         }\n         return (ArchiveEntry)new ZipArchiveEntry(inputPath, entryName, new LinkOption[0]);\n     }\n     \n     private byte[] createCentralFileHeader(final ZipArchiveEntry ze) throws IOException {\n         final ZipArchiveOutputStream.EntryMetaData entryMetaData = (ZipArchiveOutputStream.EntryMetaData)this.metaData.get(ze);\n-        final boolean needsZip64Extra = this.hasZip64Extra(ze) || ze.getCompressedSize() >= 4294967295L || ze.getSize() >= 4294967295L || ZipArchiveOutputStream.EntryMetaData.access$400(entryMetaData) >= 4294967295L || ze.getDiskNumberStart() >= 65535L || this.zip64Mode == Zip64Mode.Always || this.zip64Mode == Zip64Mode.AlwaysWithCompatibility;\n+        final boolean needsZip64Extra = this.hasZip64Extra(ze) || ze.getCompressedSize() >= 4294967295L || ze.getSize() >= 4294967295L || ZipArchiveOutputStream.EntryMetaData.access$0(entryMetaData) >= 4294967295L || ze.getDiskNumberStart() >= 65535L || this.zip64Mode == Zip64Mode.Always || this.zip64Mode == Zip64Mode.AlwaysWithCompatibility;\n         if (needsZip64Extra && this.zip64Mode == Zip64Mode.Never) {\n             throw new Zip64RequiredException(\"Archive's size exceeds the limit of 4GByte.\");\n         }\n-        this.handleZip64Extra(ze, ZipArchiveOutputStream.EntryMetaData.access$400(entryMetaData), needsZip64Extra);\n+        this.handleZip64Extra(ze, ZipArchiveOutputStream.EntryMetaData.access$0(entryMetaData), needsZip64Extra);\n         return this.createCentralFileHeader(ze, this.getName(ze), entryMetaData, needsZip64Extra);\n     }\n     \n     private byte[] createCentralFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final ZipArchiveOutputStream.EntryMetaData entryMetaData, final boolean needsZip64Extra) throws IOException {\n         if (this.isSplitZip) {\n             final int currentSplitSegment = ((ZipSplitOutputStream)this.outputStream).getCurrentSplitSegmentIndex();\n             if (this.numberOfCDInDiskData.get(Integer.valueOf(currentSplitSegment)) == null) {\n@@ -344,16 +357,16 @@\n         final int commentLen = commentB.limit() - commentB.position();\n         final int len = 46 + nameLen + extraLength + commentLen;\n         final byte[] buf = new byte[len];\n         System.arraycopy(ZipArchiveOutputStream.CFH_SIG, 0, buf, 0, 4);\n         ZipShort.putShort(ze.getPlatform() << 8 | (this.hasUsedZip64 ? 45 : 20), buf, 4);\n         final int zipMethod = ze.getMethod();\n         final boolean encodable = this.zipEncoding.canEncode(ze.getName());\n-        ZipShort.putShort(this.versionNeededToExtract(zipMethod, needsZip64Extra, ZipArchiveOutputStream.EntryMetaData.access$500(entryMetaData)), buf, 6);\n-        this.getGeneralPurposeBits(!encodable && this.fallbackToUTF8, ZipArchiveOutputStream.EntryMetaData.access$500(entryMetaData)).encode(buf, 8);\n+        ZipShort.putShort(this.versionNeededToExtract(zipMethod, needsZip64Extra, ZipArchiveOutputStream.EntryMetaData.access$1(entryMetaData)), buf, 6);\n+        this.getGeneralPurposeBits(!encodable && this.fallbackToUTF8, ZipArchiveOutputStream.EntryMetaData.access$1(entryMetaData)).encode(buf, 8);\n         ZipShort.putShort(zipMethod, buf, 10);\n         ZipUtil.toDosTime(ze.getTime(), buf, 12);\n         ZipLong.putLong(ze.getCrc(), buf, 16);\n         if (ze.getCompressedSize() >= 4294967295L || ze.getSize() >= 4294967295L || this.zip64Mode == Zip64Mode.Always || this.zip64Mode == Zip64Mode.AlwaysWithCompatibility) {\n             ZipLong.ZIP64_MAGIC.putLong(buf, 20);\n             ZipLong.ZIP64_MAGIC.putLong(buf, 24);\n         }\n@@ -373,19 +386,19 @@\n             }\n         }\n         else {\n             System.arraycopy(ZipArchiveOutputStream.ZERO, 0, buf, 34, 2);\n         }\n         ZipShort.putShort(ze.getInternalAttributes(), buf, 36);\n         ZipLong.putLong(ze.getExternalAttributes(), buf, 38);\n-        if (ZipArchiveOutputStream.EntryMetaData.access$400(entryMetaData) >= 4294967295L || this.zip64Mode == Zip64Mode.Always) {\n+        if (ZipArchiveOutputStream.EntryMetaData.access$0(entryMetaData) >= 4294967295L || this.zip64Mode == Zip64Mode.Always) {\n             ZipLong.putLong(4294967295L, buf, 42);\n         }\n         else {\n-            ZipLong.putLong(Math.min(ZipArchiveOutputStream.EntryMetaData.access$400(entryMetaData), 4294967295L), buf, 42);\n+            ZipLong.putLong(Math.min(ZipArchiveOutputStream.EntryMetaData.access$0(entryMetaData), 4294967295L), buf, 42);\n         }\n         System.arraycopy(name.array(), name.arrayOffset(), buf, 46, nameLen);\n         final int extraStart = 46 + nameLen;\n         System.arraycopy(extra, 0, buf, extraStart, extraLength);\n         final int commentStart = extraStart + extraLength;\n         System.arraycopy(commentB.array(), commentB.arrayOffset(), buf, commentStart, commentLen);\n         return buf;\n@@ -420,15 +433,15 @@\n         ZipUtil.toDosTime(ze.getTime(), buf, 10);\n         if (phased || (zipMethod != 8 && this.channel == null)) {\n             ZipLong.putLong(ze.getCrc(), buf, 14);\n         }\n         else {\n             System.arraycopy(ZipArchiveOutputStream.LZERO, 0, buf, 14, 4);\n         }\n-        if (this.hasZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry))) {\n+        if (this.hasZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry))) {\n             ZipLong.ZIP64_MAGIC.putLong(buf, 18);\n             ZipLong.ZIP64_MAGIC.putLong(buf, 22);\n         }\n         else if (phased) {\n             ZipLong.putLong(ze.getCompressedSize(), buf, 18);\n             ZipLong.putLong(ze.getSize(), buf, 22);\n         }\n@@ -458,14 +471,17 @@\n             }\n         }\n         finally {\n             if (this.outputStream != null) {\n                 this.outputStream.close();\n             }\n         }\n+        if (this.outputStream != null) {\n+            this.outputStream.close();\n+        }\n     }\n     \n     public void finish() throws IOException {\n         if (this.finished) {\n             throw new IOException(\"This archive has already been finished\");\n         }\n         if (this.entry != null) {\n@@ -497,15 +513,15 @@\n     public void flush() throws IOException {\n         if (this.outputStream != null) {\n             this.outputStream.flush();\n         }\n     }\n     \n     private void flushDeflater() throws IOException {\n-        if (ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getMethod() == 8) {\n+        if (ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getMethod() == 8) {\n             this.streamCompressor.flushDeflater();\n         }\n     }\n     \n     public long getBytesWritten() {\n         return this.streamCompressor.getTotalBytesWritten();\n     }\n@@ -537,44 +553,44 @@\n     \n     private ByteBuffer getName(final ZipArchiveEntry ze) throws IOException {\n         return this.getEntryEncoding(ze).encode(ze.getName());\n     }\n     \n     private Zip64ExtendedInformationExtraField getZip64Extra(final ZipArchiveEntry ze) {\n         if (this.entry != null) {\n-            ZipArchiveOutputStream.CurrentEntry.access$602(this.entry, !this.hasUsedZip64);\n+            ZipArchiveOutputStream.CurrentEntry.access$4(this.entry, !this.hasUsedZip64);\n         }\n         this.hasUsedZip64 = true;\n         final ZipExtraField extra = ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n         Zip64ExtendedInformationExtraField z64 = (extra instanceof Zip64ExtendedInformationExtraField) ? ((Zip64ExtendedInformationExtraField)extra) : null;\n         if (z64 == null) {\n             z64 = new Zip64ExtendedInformationExtraField();\n         }\n         ze.addAsFirstExtraField((ZipExtraField)z64);\n         return z64;\n     }\n     \n     private boolean handleSizesAndCrc(final long bytesWritten, final long crc, final Zip64Mode effectiveMode) throws ZipException {\n-        if (ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getMethod() == 8) {\n-            ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).setSize(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n-            ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).setCompressedSize(bytesWritten);\n-            ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).setCrc(crc);\n+        if (ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getMethod() == 8) {\n+            ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).setSize(ZipArchiveOutputStream.CurrentEntry.access$5(this.entry));\n+            ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).setCompressedSize(bytesWritten);\n+            ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).setCrc(crc);\n         }\n         else if (this.channel == null) {\n-            if (ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getCrc() != crc) {\n-                throw new ZipException(\"Bad CRC checksum for entry \" + ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getName() + \": \" + Long.toHexString(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getCrc()) + \" instead of \" + Long.toHexString(crc));\n+            if (ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getCrc() != crc) {\n+                throw new ZipException(\"Bad CRC checksum for entry \" + ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getName() + \": \" + Long.toHexString(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getCrc()) + \" instead of \" + Long.toHexString(crc));\n             }\n-            if (ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getSize() != bytesWritten) {\n-                throw new ZipException(\"Bad size for entry \" + ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getName() + \": \" + ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getSize() + \" instead of \" + bytesWritten);\n+            if (ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getSize() != bytesWritten) {\n+                throw new ZipException(\"Bad size for entry \" + ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getName() + \": \" + ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getSize() + \" instead of \" + bytesWritten);\n             }\n         }\n         else {\n-            ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).setSize(bytesWritten);\n-            ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).setCompressedSize(bytesWritten);\n-            ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).setCrc(crc);\n+            ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).setSize(bytesWritten);\n+            ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).setCompressedSize(bytesWritten);\n+            ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).setCrc(crc);\n         }\n         return this.checkIfNeedsZip64(effectiveMode);\n     }\n     \n     private void handleZip64Extra(final ZipArchiveEntry ze, final long lfhOffset, final boolean needsZip64Extra) {\n         if (needsZip64Extra) {\n             final Zip64ExtendedInformationExtraField z64 = this.getZip64Extra(ze);\n@@ -617,15 +633,15 @@\n     private void preClose() throws IOException {\n         if (this.finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n         if (this.entry == null) {\n             throw new IOException(\"No current entry to close\");\n         }\n-        if (!ZipArchiveOutputStream.CurrentEntry.access$300(this.entry)) {\n+        if (!ZipArchiveOutputStream.CurrentEntry.access$6(this.entry)) {\n             this.write(ByteUtils.EMPTY_BYTE_ARRAY, 0, 0);\n         }\n     }\n     \n     public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\n         this.putArchiveEntry((ZipArchiveEntry)archiveEntry, false);\n     }\n@@ -633,68 +649,68 @@\n     private void putArchiveEntry(final ZipArchiveEntry archiveEntry, final boolean phased) throws IOException {\n         if (this.finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n         if (this.entry != null) {\n             this.closeArchiveEntry();\n         }\n-        this.entry = new ZipArchiveOutputStream.CurrentEntry(archiveEntry, (ZipArchiveOutputStream.ZipArchiveOutputStream$1)null);\n-        this.entries.add(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry));\n-        this.setDefaults(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry));\n-        final Zip64Mode effectiveMode = this.getEffectiveZip64Mode(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry));\n+        this.entry = new ZipArchiveOutputStream.CurrentEntry(archiveEntry, (ZipArchiveOutputStream.CurrentEntry)null);\n+        this.entries.add(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry));\n+        this.setDefaults(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry));\n+        final Zip64Mode effectiveMode = this.getEffectiveZip64Mode(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry));\n         this.validateSizeInformation(effectiveMode);\n-        if (this.shouldAddZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry), effectiveMode)) {\n-            final Zip64ExtendedInformationExtraField z64 = this.getZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry));\n+        if (this.shouldAddZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry), effectiveMode)) {\n+            final Zip64ExtendedInformationExtraField z64 = this.getZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry));\n             ZipEightByteInteger size;\n             ZipEightByteInteger compressedSize;\n             if (phased) {\n-                size = new ZipEightByteInteger(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getSize());\n-                compressedSize = new ZipEightByteInteger(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getCompressedSize());\n+                size = new ZipEightByteInteger(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getSize());\n+                compressedSize = new ZipEightByteInteger(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getCompressedSize());\n             }\n-            else if (ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getMethod() == 0 && ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getSize() != -1L) {\n-                size = (compressedSize = new ZipEightByteInteger(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getSize()));\n+            else if (ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getMethod() == 0 && ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getSize() != -1L) {\n+                size = (compressedSize = new ZipEightByteInteger(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getSize()));\n             }\n             else {\n                 size = (compressedSize = ZipEightByteInteger.ZERO);\n             }\n             z64.setSize(size);\n             z64.setCompressedSize(compressedSize);\n-            ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).setExtra();\n+            ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).setExtra();\n         }\n-        if (ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getMethod() == 8 && this.hasCompressionLevelChanged) {\n+        if (ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getMethod() == 8 && this.hasCompressionLevelChanged) {\n             this.def.setLevel(this.level);\n             this.hasCompressionLevelChanged = false;\n         }\n         this.writeLocalFileHeader(archiveEntry, phased);\n     }\n     \n     private void rewriteSizesAndCrc(final boolean actuallyNeedsZip64) throws IOException {\n         final long save = this.channel.position();\n-        this.channel.position(ZipArchiveOutputStream.CurrentEntry.access$800(this.entry));\n-        this.writeOut(ZipLong.getBytes(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getCrc()));\n-        if (!this.hasZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry)) || !actuallyNeedsZip64) {\n-            this.writeOut(ZipLong.getBytes(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getCompressedSize()));\n-            this.writeOut(ZipLong.getBytes(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getSize()));\n+        this.channel.position(ZipArchiveOutputStream.CurrentEntry.access$8(this.entry));\n+        this.writeOut(ZipLong.getBytes(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getCrc()));\n+        if (!this.hasZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry)) || !actuallyNeedsZip64) {\n+            this.writeOut(ZipLong.getBytes(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getCompressedSize()));\n+            this.writeOut(ZipLong.getBytes(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getSize()));\n         }\n         else {\n             this.writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n             this.writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n         }\n-        if (this.hasZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry))) {\n-            final ByteBuffer name = this.getName(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry));\n+        if (this.hasZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry))) {\n+            final ByteBuffer name = this.getName(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry));\n             final int nameLen = name.limit() - name.position();\n-            this.channel.position(ZipArchiveOutputStream.CurrentEntry.access$800(this.entry) + 12L + 4L + nameLen + 4L);\n-            this.writeOut(ZipEightByteInteger.getBytes(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getSize()));\n-            this.writeOut(ZipEightByteInteger.getBytes(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getCompressedSize()));\n+            this.channel.position(ZipArchiveOutputStream.CurrentEntry.access$8(this.entry) + 12L + 4L + nameLen + 4L);\n+            this.writeOut(ZipEightByteInteger.getBytes(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getSize()));\n+            this.writeOut(ZipEightByteInteger.getBytes(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getCompressedSize()));\n             if (!actuallyNeedsZip64) {\n-                this.channel.position(ZipArchiveOutputStream.CurrentEntry.access$800(this.entry) - 10L);\n-                this.writeOut(ZipShort.getBytes(this.versionNeededToExtract(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getMethod(), false, false)));\n-                ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).removeExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n-                ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).setExtra();\n-                if (ZipArchiveOutputStream.CurrentEntry.access$600(this.entry)) {\n+                this.channel.position(ZipArchiveOutputStream.CurrentEntry.access$8(this.entry) - 10L);\n+                this.writeOut(ZipShort.getBytes(this.versionNeededToExtract(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getMethod(), false, false)));\n+                ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).removeExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n+                ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).setExtra();\n+                if (ZipArchiveOutputStream.CurrentEntry.access$9(this.entry)) {\n                     this.hasUsedZip64 = false;\n                 }\n             }\n         }\n         this.channel.position(save);\n     }\n     \n@@ -793,25 +809,25 @@\n         }\n         if (this.cdOffset >= 4294967295L) {\n             throw new Zip64RequiredException(\"Archive's size exceeds the limit of 4GByte.\");\n         }\n     }\n     \n     private void validateSizeInformation(final Zip64Mode effectiveMode) throws ZipException {\n-        if (ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getMethod() == 0 && this.channel == null) {\n-            if (ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getSize() == -1L) {\n+        if (ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getMethod() == 0 && this.channel == null) {\n+            if (ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getSize() == -1L) {\n                 throw new ZipException(\"Uncompressed size is required for STORED method when not writing to a file\");\n             }\n-            if (ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getCrc() == -1L) {\n+            if (ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getCrc() == -1L) {\n                 throw new ZipException(\"CRC checksum is required for STORED method when not writing to a file\");\n             }\n-            ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).setCompressedSize(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getSize());\n+            ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).setCompressedSize(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getSize());\n         }\n-        if ((ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getSize() >= 4294967295L || ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getCompressedSize() >= 4294967295L) && effectiveMode == Zip64Mode.Never) {\n-            throw new Zip64RequiredException(Zip64RequiredException.getEntryTooBigMessage(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry)));\n+        if ((ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getSize() >= 4294967295L || ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getCompressedSize() >= 4294967295L) && effectiveMode == Zip64Mode.Never) {\n+            throw new Zip64RequiredException(Zip64RequiredException.getEntryTooBigMessage(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry)));\n         }\n     }\n     \n     private int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n         if (zip64) {\n             return 45;\n         }\n@@ -825,16 +841,16 @@\n         return (zipMethod == 8) ? 20 : 10;\n     }\n     \n     public void write(final byte[] b, final int offset, final int length) throws IOException {\n         if (this.entry == null) {\n             throw new IllegalStateException(\"No current entry\");\n         }\n-        ZipUtil.checkRequestedFeatures(ZipArchiveOutputStream.CurrentEntry.access$000(this.entry));\n-        final long writtenThisTime = this.streamCompressor.write(b, offset, length, ZipArchiveOutputStream.CurrentEntry.access$000(this.entry).getMethod());\n+        ZipUtil.checkRequestedFeatures(ZipArchiveOutputStream.CurrentEntry.access$0(this.entry));\n+        final long writtenThisTime = this.streamCompressor.write(b, offset, length, ZipArchiveOutputStream.CurrentEntry.access$0(this.entry).getMethod());\n         this.count(writtenThisTime);\n     }\n     \n     protected void writeCentralDirectoryEnd() throws IOException {\n         if (!this.hasUsedZip64 && this.isSplitZip) {\n             ((ZipSplitOutputStream)this.outputStream).prepareToWriteUnsplittableContent(this.eocdLength);\n         }\n@@ -913,18 +929,18 @@\n         long localHeaderStart = this.streamCompressor.getTotalBytesWritten();\n         if (this.isSplitZip) {\n             final ZipSplitOutputStream splitOutputStream = (ZipSplitOutputStream)this.outputStream;\n             ze.setDiskNumberStart((long)splitOutputStream.getCurrentSplitSegmentIndex());\n             localHeaderStart = splitOutputStream.getCurrentSplitSegmentBytesWritten();\n         }\n         final byte[] localHeader = this.createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n-        this.metaData.put(ze, new ZipArchiveOutputStream.EntryMetaData(localHeaderStart, this.usesDataDescriptor(ze.getMethod(), phased), (ZipArchiveOutputStream.ZipArchiveOutputStream$1)null));\n-        ZipArchiveOutputStream.CurrentEntry.access$802(this.entry, localHeaderStart + 14L);\n+        this.metaData.put(ze, new ZipArchiveOutputStream.EntryMetaData(localHeaderStart, this.usesDataDescriptor(ze.getMethod(), phased), (ZipArchiveOutputStream.EntryMetaData)null));\n+        ZipArchiveOutputStream.CurrentEntry.access$10(this.entry, localHeaderStart + 14L);\n         this.writeCounted(localHeader);\n-        ZipArchiveOutputStream.CurrentEntry.access$102(this.entry, this.streamCompressor.getTotalBytesWritten());\n+        ZipArchiveOutputStream.CurrentEntry.access$11(this.entry, this.streamCompressor.getTotalBytesWritten());\n     }\n     \n     protected final void writeOut(final byte[] data) throws IOException {\n         this.streamCompressor.writeOut(data, 0, data.length);\n     }\n     \n     protected final void writeOut(final byte[] data, final int offset, final int length) throws IOException {\n@@ -988,20 +1004,8 @@\n             final int totalNumberOfDisks = ((ZipSplitOutputStream)this.outputStream).getCurrentSplitSegmentIndex() + 1;\n             this.writeOut(ZipLong.getBytes((long)totalNumberOfDisks));\n         }\n         else {\n             this.writeOut(ZipArchiveOutputStream.ONE);\n         }\n     }\n-    \n-    static {\n-        ZERO = new byte[] { 0, 0 };\n-        LZERO = new byte[] { 0, 0, 0, 0 };\n-        ONE = ZipLong.getBytes(1L);\n-        LFH_SIG = ZipLong.LFH_SIG.getBytes();\n-        DD_SIG = ZipLong.DD_SIG.getBytes();\n-        CFH_SIG = ZipLong.CFH_SIG.getBytes();\n-        EOCD_SIG = ZipLong.getBytes(101010256L);\n-        ZIP64_EOCD_SIG = ZipLong.getBytes(101075792L);\n-        ZIP64_EOCD_LOC_SIG = ZipLong.getBytes(117853008L);\n-    }\n }\n"}]}
