{"diffoscope-json-version": 1, "source1": "first/Pass2Verifier$CPESSC_Visitor.class", "source2": "second/Pass2Verifier$CPESSC_Visitor.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -15,15 +15,14 @@\n import org.apache.bcel.classfile.Field;\n import org.apache.bcel.classfile.ConstantValue;\n import org.apache.bcel.classfile.ConstantMethodref;\n import org.apache.bcel.classfile.ConstantInterfaceMethodref;\n import org.apache.bcel.classfile.ConstantFieldref;\n import org.apache.bcel.classfile.LocalVariable;\n import org.apache.bcel.classfile.Attribute;\n-import org.apache.bcel.verifier.Verifier;\n import org.apache.bcel.classfile.CodeException;\n import org.apache.bcel.verifier.exc.LocalVariableInfoInconsistentException;\n import org.apache.bcel.classfile.ClassFormatException;\n import org.apache.bcel.classfile.LocalVariableTable;\n import org.apache.bcel.classfile.LineNumberTable;\n import org.apache.bcel.verifier.exc.AssertionViolatedException;\n import org.apache.bcel.generic.Type;\n@@ -89,135 +88,129 @@\n         (this.carrier = new DescendingVisitor(jc, (Visitor)this)).visit();\n     }\n     \n     private void checkIndex(final Node referrer, final int index, final Class<?> shouldbe) {\n         if (index < 0 || index >= this.cplen) {\n             throw new ClassConstraintException(\"Invalid index '\" + index + \"' used by '\" + Pass2Verifier.access$000(referrer) + \"'.\");\n         }\n-        final Constant c = this.cp.getConstant(index);\n-        if (!shouldbe.isInstance(c)) {\n-            throw new ClassConstraintException(\"Illegal constant '\" + Pass2Verifier.access$000((Node)c) + \"' at index '\" + index + \"'. '\" + Pass2Verifier.access$000(referrer) + \"' expects a '\" + shouldbe + \"'.\");\n+        final Constant constant = this.cp.getConstant(index);\n+        if (!shouldbe.isInstance(constant)) {\n+            throw new ClassConstraintException(\"Illegal constant '\" + Pass2Verifier.access$000((Node)constant) + \"' at index '\" + index + \"'. '\" + Pass2Verifier.access$000(referrer) + \"' expects a '\" + shouldbe + \"'.\");\n         }\n     }\n     \n     public void visitCode(final Code obj) {\n         try {\n             this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n-            final String name = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n-            if (!name.equals(\"Code\")) {\n-                throw new ClassConstraintException(\"The Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' is not correctly named 'Code' but '\" + name + \"'.\");\n+            final String bytes = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n+            if (!bytes.equals(\"Code\")) {\n+                throw new ClassConstraintException(\"The Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' is not correctly named 'Code' but '\" + bytes + \"'.\");\n             }\n             if (!(this.carrier.predecessor() instanceof Method)) {\n                 this.this$0.addMessage(\"Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' is not declared in a method_info structure but in '\" + this.carrier.predecessor() + \"'. Ignored.\");\n                 return;\n             }\n-            final Method m = (Method)this.carrier.predecessor();\n+            final Method method = (Method)this.carrier.predecessor();\n             if (obj.getCode().length == 0) {\n-                throw new ClassConstraintException(\"Code array of Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' (method '\" + m + \"') must not be empty.\");\n+                throw new ClassConstraintException(\"Code array of Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' (method '\" + method + \"') must not be empty.\");\n             }\n-            final CodeException[] exceptionTable;\n-            final CodeException[] excTable = exceptionTable = obj.getExceptionTable();\n-            for (final CodeException element : exceptionTable) {\n-                final int excIndex = element.getCatchType();\n-                if (excIndex != 0) {\n-                    this.checkIndex((Node)obj, excIndex, this.CONST_Class);\n-                    final ConstantClass cc = (ConstantClass)this.cp.getConstant(excIndex);\n-                    this.checkIndex((Node)cc, cc.getNameIndex(), this.CONST_Utf8);\n-                    final String cname = Utility.pathToPackage(((ConstantUtf8)this.cp.getConstant(cc.getNameIndex())).getBytes());\n-                    Verifier v = VerifierFactory.getVerifier(cname);\n-                    VerificationResult vr = v.doPass1();\n-                    if (vr != VerificationResult.VR_OK) {\n-                        throw new ClassConstraintException(\"Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' (method '\" + m + \"') has an exception_table entry '\" + Pass2Verifier.access$000((Node)element) + \"' that references '\" + cname + \"' as an Exception but it does not pass verification pass 1: \" + vr);\n+            for (final CodeException ex : obj.getExceptionTable()) {\n+                final int catchType = ex.getCatchType();\n+                if (catchType != 0) {\n+                    this.checkIndex((Node)obj, catchType, this.CONST_Class);\n+                    final ConstantClass constantClass = (ConstantClass)this.cp.getConstant(catchType);\n+                    this.checkIndex((Node)constantClass, constantClass.getNameIndex(), this.CONST_Utf8);\n+                    final String pathToPackage = Utility.pathToPackage(((ConstantUtf8)this.cp.getConstant(constantClass.getNameIndex())).getBytes());\n+                    final VerificationResult doPass1 = VerifierFactory.getVerifier(pathToPackage).doPass1();\n+                    if (doPass1 != VerificationResult.VR_OK) {\n+                        throw new ClassConstraintException(\"Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' (method '\" + method + \"') has an exception_table entry '\" + Pass2Verifier.access$000((Node)ex) + \"' that references '\" + pathToPackage + \"' as an Exception but it does not pass verification pass 1: \" + doPass1);\n                     }\n-                    JavaClass e = Repository.lookupClass(cname);\n-                    final JavaClass t = Repository.lookupClass(Type.THROWABLE.getClassName());\n-                    for (JavaClass o = Repository.lookupClass(Type.OBJECT.getClassName()); e != o && e != t; e = Repository.lookupClass(e.getSuperclassName())) {\n-                        v = VerifierFactory.getVerifier(e.getSuperclassName());\n-                        vr = v.doPass1();\n-                        if (vr != VerificationResult.VR_OK) {\n-                            throw new ClassConstraintException(\"Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' (method '\" + m + \"') has an exception_table entry '\" + Pass2Verifier.access$000((Node)element) + \"' that references '\" + cname + \"' as an Exception but '\" + e.getSuperclassName() + \"' in the ancestor hierachy does not pass verification pass 1: \" + vr);\n+                    JavaClass javaClass;\n+                    JavaClass lookupClass;\n+                    for (javaClass = Repository.lookupClass(pathToPackage), lookupClass = Repository.lookupClass(Type.THROWABLE.getClassName()); javaClass != Repository.lookupClass(Type.OBJECT.getClassName()) && javaClass != lookupClass; javaClass = Repository.lookupClass(javaClass.getSuperclassName())) {\n+                        final VerificationResult doPass2 = VerifierFactory.getVerifier(javaClass.getSuperclassName()).doPass1();\n+                        if (doPass2 != VerificationResult.VR_OK) {\n+                            throw new ClassConstraintException(\"Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' (method '\" + method + \"') has an exception_table entry '\" + Pass2Verifier.access$000((Node)ex) + \"' that references '\" + pathToPackage + \"' as an Exception but '\" + javaClass.getSuperclassName() + \"' in the ancestor hierachy does not pass verification pass 1: \" + doPass2);\n                         }\n                     }\n-                    if (e != t) {\n-                        throw new ClassConstraintException(\"Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' (method '\" + m + \"') has an exception_table entry '\" + Pass2Verifier.access$000((Node)element) + \"' that references '\" + cname + \"' as an Exception but it is not a subclass of '\" + t.getClassName() + \"'.\");\n+                    if (javaClass != lookupClass) {\n+                        throw new ClassConstraintException(\"Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' (method '\" + method + \"') has an exception_table entry '\" + Pass2Verifier.access$000((Node)ex) + \"' that references '\" + pathToPackage + \"' as an Exception but it is not a subclass of '\" + lookupClass.getClassName() + \"'.\");\n                     }\n                 }\n             }\n-            int methodNumber = -1;\n-            final Method[] ms = Repository.lookupClass(Pass2Verifier.access$100(this.this$0).getClassName()).getMethods();\n-            for (int mn = 0; mn < ms.length; ++mn) {\n-                if (m == ms[mn]) {\n-                    methodNumber = mn;\n+            int n = -1;\n+            final Method[] methods = Repository.lookupClass(Pass2Verifier.access$100(this.this$0).getClassName()).getMethods();\n+            for (int j = 0; j < methods.length; ++j) {\n+                if (method == methods[j]) {\n+                    n = j;\n                     break;\n                 }\n             }\n-            if (methodNumber < 0) {\n-                for (int mn = 0; mn < ms.length; ++mn) {\n-                    if (m.getName().equals(ms[mn].getName())) {\n-                        methodNumber = mn;\n+            if (n < 0) {\n+                for (int k = 0; k < methods.length; ++k) {\n+                    if (method.getName().equals(methods[k].getName())) {\n+                        n = k;\n                         break;\n                     }\n                 }\n             }\n-            if (methodNumber < 0) {\n+            if (n < 0) {\n                 throw new AssertionViolatedException(\"Could not find a known BCEL Method object in the corresponding BCEL JavaClass object.\");\n             }\n-            Pass2Verifier.access$200(this.this$0)[methodNumber] = new LocalVariablesInfo(obj.getMaxLocals());\n-            int numOfLvtAttribs = 0;\n-            final Attribute[] attributes;\n-            final Attribute[] atts = attributes = obj.getAttributes();\n-            for (final Attribute att : attributes) {\n-                if (!(att instanceof LineNumberTable) && !(att instanceof LocalVariableTable)) {\n-                    this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$000((Node)att) + \"' as an attribute of Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' (method '\" + m + \"') is unknown and will therefore be ignored.\");\n+            Pass2Verifier.access$200(this.this$0)[n] = new LocalVariablesInfo(obj.getMaxLocals());\n+            int n2 = 0;\n+            for (final Attribute attribute : obj.getAttributes()) {\n+                if (!(attribute instanceof LineNumberTable) && !(attribute instanceof LocalVariableTable)) {\n+                    this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$000((Node)attribute) + \"' as an attribute of Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' (method '\" + method + \"') is unknown and will therefore be ignored.\");\n                 }\n                 else {\n-                    this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$000((Node)att) + \"' as an attribute of Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' (method '\" + m + \"') will effectively be ignored and is only useful for debuggers and such.\");\n+                    this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$000((Node)attribute) + \"' as an attribute of Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' (method '\" + method + \"') will effectively be ignored and is only useful for debuggers and such.\");\n                 }\n-                if (att instanceof LocalVariableTable) {\n-                    final LocalVariableTable lvt = (LocalVariableTable)att;\n-                    this.checkIndex((Node)lvt, lvt.getNameIndex(), this.CONST_Utf8);\n-                    final String lvtname = ((ConstantUtf8)this.cp.getConstant(lvt.getNameIndex())).getBytes();\n-                    if (!lvtname.equals(\"LocalVariableTable\")) {\n-                        throw new ClassConstraintException(\"The LocalVariableTable attribute '\" + Pass2Verifier.access$000((Node)lvt) + \"' is not correctly named 'LocalVariableTable' but '\" + lvtname + \"'.\");\n+                if (attribute instanceof LocalVariableTable) {\n+                    final LocalVariableTable localVariableTable = (LocalVariableTable)attribute;\n+                    this.checkIndex((Node)localVariableTable, localVariableTable.getNameIndex(), this.CONST_Utf8);\n+                    final String bytes2 = ((ConstantUtf8)this.cp.getConstant(localVariableTable.getNameIndex())).getBytes();\n+                    if (!bytes2.equals(\"LocalVariableTable\")) {\n+                        throw new ClassConstraintException(\"The LocalVariableTable attribute '\" + Pass2Verifier.access$000((Node)localVariableTable) + \"' is not correctly named 'LocalVariableTable' but '\" + bytes2 + \"'.\");\n                     }\n-                    for (final LocalVariable localvariable : lvt.getLocalVariableTable()) {\n-                        this.checkIndex((Node)lvt, localvariable.getNameIndex(), this.CONST_Utf8);\n-                        final String localname = ((ConstantUtf8)this.cp.getConstant(localvariable.getNameIndex())).getBytes();\n-                        if (!Pass2Verifier.access$300(localname)) {\n-                            throw new ClassConstraintException(\"LocalVariableTable '\" + Pass2Verifier.access$000((Node)lvt) + \"' references a local variable by the name '\" + localname + \"' which is not a legal Java simple name.\");\n+                    for (final LocalVariable localVariable : localVariableTable.getLocalVariableTable()) {\n+                        this.checkIndex((Node)localVariableTable, localVariable.getNameIndex(), this.CONST_Utf8);\n+                        final String bytes3 = ((ConstantUtf8)this.cp.getConstant(localVariable.getNameIndex())).getBytes();\n+                        if (!Pass2Verifier.access$300(bytes3)) {\n+                            throw new ClassConstraintException(\"LocalVariableTable '\" + Pass2Verifier.access$000((Node)localVariableTable) + \"' references a local variable by the name '\" + bytes3 + \"' which is not a legal Java simple name.\");\n                         }\n-                        this.checkIndex((Node)lvt, localvariable.getSignatureIndex(), this.CONST_Utf8);\n-                        final String localsig = ((ConstantUtf8)this.cp.getConstant(localvariable.getSignatureIndex())).getBytes();\n-                        Type t2;\n+                        this.checkIndex((Node)localVariableTable, localVariable.getSignatureIndex(), this.CONST_Utf8);\n+                        final String bytes4 = ((ConstantUtf8)this.cp.getConstant(localVariable.getSignatureIndex())).getBytes();\n+                        Type type;\n                         try {\n-                            t2 = Type.getType(localsig);\n+                            type = Type.getType(bytes4);\n                         }\n-                        catch (final ClassFormatException cfe) {\n-                            throw new ClassConstraintException(\"Illegal descriptor (==signature) '\" + localsig + \"' used by LocalVariable '\" + Pass2Verifier.access$000((Node)localvariable) + \"' referenced by '\" + Pass2Verifier.access$000((Node)lvt) + \"'.\", (Throwable)cfe);\n+                        catch (final ClassFormatException ex2) {\n+                            throw new ClassConstraintException(\"Illegal descriptor (==signature) '\" + bytes4 + \"' used by LocalVariable '\" + Pass2Verifier.access$000((Node)localVariable) + \"' referenced by '\" + Pass2Verifier.access$000((Node)localVariableTable) + \"'.\", (Throwable)ex2);\n                         }\n-                        final int localindex = localvariable.getIndex();\n-                        if (((t2 == Type.LONG || t2 == Type.DOUBLE) ? (localindex + 1) : localindex) >= obj.getMaxLocals()) {\n-                            throw new ClassConstraintException(\"LocalVariableTable attribute '\" + Pass2Verifier.access$000((Node)lvt) + \"' references a LocalVariable '\" + Pass2Verifier.access$000((Node)localvariable) + \"' with an index that exceeds the surrounding Code attribute's max_locals value of '\" + obj.getMaxLocals() + \"'.\");\n+                        final int index = localVariable.getIndex();\n+                        if (((type == Type.LONG || type == Type.DOUBLE) ? (index + 1) : index) >= obj.getMaxLocals()) {\n+                            throw new ClassConstraintException(\"LocalVariableTable attribute '\" + Pass2Verifier.access$000((Node)localVariableTable) + \"' references a LocalVariable '\" + Pass2Verifier.access$000((Node)localVariable) + \"' with an index that exceeds the surrounding Code attribute's max_locals value of '\" + obj.getMaxLocals() + \"'.\");\n                         }\n                         try {\n-                            Pass2Verifier.access$200(this.this$0)[methodNumber].add(localindex, localname, localvariable.getStartPC(), localvariable.getLength(), t2);\n+                            Pass2Verifier.access$200(this.this$0)[n].add(index, bytes3, localVariable.getStartPC(), localVariable.getLength(), type);\n                         }\n-                        catch (final LocalVariableInfoInconsistentException lviie) {\n-                            throw new ClassConstraintException(\"Conflicting information in LocalVariableTable '\" + Pass2Verifier.access$000((Node)lvt) + \"' found in Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' (method '\" + Pass2Verifier.access$000((Node)m) + \"'). \" + lviie.getMessage(), (Throwable)lviie);\n+                        catch (final LocalVariableInfoInconsistentException ex3) {\n+                            throw new ClassConstraintException(\"Conflicting information in LocalVariableTable '\" + Pass2Verifier.access$000((Node)localVariableTable) + \"' found in Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' (method '\" + Pass2Verifier.access$000((Node)method) + \"'). \" + ex3.getMessage(), (Throwable)ex3);\n                         }\n                     }\n-                    ++numOfLvtAttribs;\n-                    if (!m.isStatic() && numOfLvtAttribs > obj.getMaxLocals()) {\n-                        throw new ClassConstraintException(\"Number of LocalVariableTable attributes of Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' (method '\" + Pass2Verifier.access$000((Node)m) + \"') exceeds number of local variable slots '\" + obj.getMaxLocals() + \"' ('There may be at most one LocalVariableTable attribute per local variable in the Code attribute.').\");\n+                    ++n2;\n+                    if (!method.isStatic() && n2 > obj.getMaxLocals()) {\n+                        throw new ClassConstraintException(\"Number of LocalVariableTable attributes of Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' (method '\" + Pass2Verifier.access$000((Node)method) + \"') exceeds number of local variable slots '\" + obj.getMaxLocals() + \"' ('There may be at most one LocalVariableTable attribute per local variable in the Code attribute.').\");\n                     }\n                 }\n             }\n         }\n-        catch (final ClassNotFoundException e2) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e2, (Throwable)e2);\n+        catch (final ClassNotFoundException obj2) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj2, (Throwable)obj2);\n         }\n     }\n     \n     public void visitCodeException(final CodeException obj) {\n     }\n     \n     public void visitConstantClass(final ConstantClass obj) {\n@@ -297,103 +290,99 @@\n         if (obj.getTag() != 1) {\n             throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n         }\n     }\n     \n     public void visitConstantValue(final ConstantValue obj) {\n         this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n-        final String name = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n-        if (!name.equals(\"ConstantValue\")) {\n-            throw new ClassConstraintException(\"The ConstantValue attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' is not correctly named 'ConstantValue' but '\" + name + \"'.\");\n+        final String bytes = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n+        if (!bytes.equals(\"ConstantValue\")) {\n+            throw new ClassConstraintException(\"The ConstantValue attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' is not correctly named 'ConstantValue' but '\" + bytes + \"'.\");\n         }\n-        final Object pred = this.carrier.predecessor();\n-        if (!(pred instanceof Field)) {\n+        final Object predecessor = this.carrier.predecessor();\n+        if (!(predecessor instanceof Field)) {\n             return;\n         }\n-        final Field f = (Field)pred;\n-        final Type fieldType = Type.getType(((ConstantUtf8)this.cp.getConstant(f.getSignatureIndex())).getBytes());\n-        final int index = obj.getConstantValueIndex();\n-        if (index < 0 || index >= this.cplen) {\n-            throw new ClassConstraintException(\"Invalid index '\" + index + \"' used by '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n+        final Field field = (Field)predecessor;\n+        final Type type = Type.getType(((ConstantUtf8)this.cp.getConstant(field.getSignatureIndex())).getBytes());\n+        final int constantValueIndex = obj.getConstantValueIndex();\n+        if (constantValueIndex < 0 || constantValueIndex >= this.cplen) {\n+            throw new ClassConstraintException(\"Invalid index '\" + constantValueIndex + \"' used by '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n         }\n-        final Constant c = this.cp.getConstant(index);\n-        if ((this.CONST_Long.isInstance(c) && fieldType.equals((Object)Type.LONG)) || (this.CONST_Float.isInstance(c) && fieldType.equals((Object)Type.FLOAT))) {\n+        final Constant constant = this.cp.getConstant(constantValueIndex);\n+        if ((this.CONST_Long.isInstance(constant) && type.equals((Object)Type.LONG)) || (this.CONST_Float.isInstance(constant) && type.equals((Object)Type.FLOAT))) {\n             return;\n         }\n-        if (this.CONST_Double.isInstance(c) && fieldType.equals((Object)Type.DOUBLE)) {\n+        if (this.CONST_Double.isInstance(constant) && type.equals((Object)Type.DOUBLE)) {\n             return;\n         }\n-        if (this.CONST_Integer.isInstance(c) && (fieldType.equals((Object)Type.INT) || fieldType.equals((Object)Type.SHORT) || fieldType.equals((Object)Type.CHAR) || fieldType.equals((Object)Type.BYTE) || fieldType.equals((Object)Type.BOOLEAN))) {\n+        if (this.CONST_Integer.isInstance(constant) && (type.equals((Object)Type.INT) || type.equals((Object)Type.SHORT) || type.equals((Object)Type.CHAR) || type.equals((Object)Type.BYTE) || type.equals((Object)Type.BOOLEAN))) {\n             return;\n         }\n-        if (this.CONST_String.isInstance(c) && fieldType.equals((Object)Type.STRING)) {\n+        if (this.CONST_String.isInstance(constant) && type.equals((Object)Type.STRING)) {\n             return;\n         }\n-        throw new ClassConstraintException(\"Illegal type of ConstantValue '\" + obj + \"' embedding Constant '\" + c + \"'. It is referenced by field '\" + Pass2Verifier.access$000((Node)f) + \"' expecting a different type: '\" + fieldType + \"'.\");\n+        throw new ClassConstraintException(\"Illegal type of ConstantValue '\" + obj + \"' embedding Constant '\" + constant + \"'. It is referenced by field '\" + Pass2Verifier.access$000((Node)field) + \"' expecting a different type: '\" + type + \"'.\");\n     }\n     \n     public void visitDeprecated(final Deprecated obj) {\n         this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n-        final String name = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n-        if (!name.equals(\"Deprecated\")) {\n-            throw new ClassConstraintException(\"The Deprecated attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' is not correctly named 'Deprecated' but '\" + name + \"'.\");\n+        final String bytes = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n+        if (!bytes.equals(\"Deprecated\")) {\n+            throw new ClassConstraintException(\"The Deprecated attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' is not correctly named 'Deprecated' but '\" + bytes + \"'.\");\n         }\n     }\n     \n     public void visitExceptionTable(final ExceptionTable obj) {\n         try {\n             this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n-            final String name = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n-            if (!name.equals(\"Exceptions\")) {\n-                throw new ClassConstraintException(\"The Exceptions attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' is not correctly named 'Exceptions' but '\" + name + \"'.\");\n-            }\n-            final int[] exceptionIndexTable;\n-            final int[] excIndices = exceptionIndexTable = obj.getExceptionIndexTable();\n-            for (final int excIndice : exceptionIndexTable) {\n-                this.checkIndex((Node)obj, excIndice, this.CONST_Class);\n-                final ConstantClass cc = (ConstantClass)this.cp.getConstant(excIndice);\n-                this.checkIndex((Node)cc, cc.getNameIndex(), this.CONST_Utf8);\n-                final String cname = Utility.pathToPackage(((ConstantUtf8)this.cp.getConstant(cc.getNameIndex())).getBytes());\n-                Verifier v = VerifierFactory.getVerifier(cname);\n-                VerificationResult vr = v.doPass1();\n-                if (vr != VerificationResult.VR_OK) {\n-                    throw new ClassConstraintException(\"Exceptions attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' references '\" + cname + \"' as an Exception but it does not pass verification pass 1: \" + vr);\n-                }\n-                JavaClass e = Repository.lookupClass(cname);\n-                final JavaClass t = Repository.lookupClass(Type.THROWABLE.getClassName());\n-                for (JavaClass o = Repository.lookupClass(Type.OBJECT.getClassName()); e != o && e != t; e = Repository.lookupClass(e.getSuperclassName())) {\n-                    v = VerifierFactory.getVerifier(e.getSuperclassName());\n-                    vr = v.doPass1();\n-                    if (vr != VerificationResult.VR_OK) {\n-                        throw new ClassConstraintException(\"Exceptions attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' references '\" + cname + \"' as an Exception but '\" + e.getSuperclassName() + \"' in the ancestor hierachy does not pass verification pass 1: \" + vr);\n+            final String bytes = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n+            if (!bytes.equals(\"Exceptions\")) {\n+                throw new ClassConstraintException(\"The Exceptions attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' is not correctly named 'Exceptions' but '\" + bytes + \"'.\");\n+            }\n+            for (final int n : obj.getExceptionIndexTable()) {\n+                this.checkIndex((Node)obj, n, this.CONST_Class);\n+                final ConstantClass constantClass = (ConstantClass)this.cp.getConstant(n);\n+                this.checkIndex((Node)constantClass, constantClass.getNameIndex(), this.CONST_Utf8);\n+                final String pathToPackage = Utility.pathToPackage(((ConstantUtf8)this.cp.getConstant(constantClass.getNameIndex())).getBytes());\n+                final VerificationResult doPass1 = VerifierFactory.getVerifier(pathToPackage).doPass1();\n+                if (doPass1 != VerificationResult.VR_OK) {\n+                    throw new ClassConstraintException(\"Exceptions attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' references '\" + pathToPackage + \"' as an Exception but it does not pass verification pass 1: \" + doPass1);\n+                }\n+                JavaClass javaClass;\n+                JavaClass lookupClass;\n+                for (javaClass = Repository.lookupClass(pathToPackage), lookupClass = Repository.lookupClass(Type.THROWABLE.getClassName()); javaClass != Repository.lookupClass(Type.OBJECT.getClassName()) && javaClass != lookupClass; javaClass = Repository.lookupClass(javaClass.getSuperclassName())) {\n+                    final VerificationResult doPass2 = VerifierFactory.getVerifier(javaClass.getSuperclassName()).doPass1();\n+                    if (doPass2 != VerificationResult.VR_OK) {\n+                        throw new ClassConstraintException(\"Exceptions attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' references '\" + pathToPackage + \"' as an Exception but '\" + javaClass.getSuperclassName() + \"' in the ancestor hierachy does not pass verification pass 1: \" + doPass2);\n                     }\n                 }\n-                if (e != t) {\n-                    throw new ClassConstraintException(\"Exceptions attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' references '\" + cname + \"' as an Exception but it is not a subclass of '\" + t.getClassName() + \"'.\");\n+                if (javaClass != lookupClass) {\n+                    throw new ClassConstraintException(\"Exceptions attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' references '\" + pathToPackage + \"' as an Exception but it is not a subclass of '\" + lookupClass.getClassName() + \"'.\");\n                 }\n             }\n         }\n-        catch (final ClassNotFoundException e2) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e2, (Throwable)e2);\n+        catch (final ClassNotFoundException obj2) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj2, (Throwable)obj2);\n         }\n     }\n     \n     public void visitField(final Field obj) {\n         if (this.jc.isClass()) {\n-            int maxone = 0;\n+            int n = 0;\n             if (obj.isPrivate()) {\n-                ++maxone;\n+                ++n;\n             }\n             if (obj.isProtected()) {\n-                ++maxone;\n+                ++n;\n             }\n             if (obj.isPublic()) {\n-                ++maxone;\n+                ++n;\n             }\n-            if (maxone > 1) {\n+            if (n > 1) {\n                 throw new ClassConstraintException(\"Field '\" + Pass2Verifier.access$000((Node)obj) + \"' must only have at most one of its ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC modifiers set.\");\n             }\n             if (obj.isFinal() && obj.isVolatile()) {\n                 throw new ClassConstraintException(\"Field '\" + Pass2Verifier.access$000((Node)obj) + \"' must only have at most one of its ACC_FINAL, ACC_VOLATILE modifiers set.\");\n             }\n         }\n         else {\n@@ -412,94 +401,92 @@\n         }\n         this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n         final String name = obj.getName();\n         if (!Pass2Verifier.access$400(name)) {\n             throw new ClassConstraintException(\"Field '\" + Pass2Verifier.access$000((Node)obj) + \"' has illegal name '\" + obj.getName() + \"'.\");\n         }\n         this.checkIndex((Node)obj, obj.getSignatureIndex(), this.CONST_Utf8);\n-        final String sig = ((ConstantUtf8)this.cp.getConstant(obj.getSignatureIndex())).getBytes();\n+        final String bytes = ((ConstantUtf8)this.cp.getConstant(obj.getSignatureIndex())).getBytes();\n         try {\n-            Type.getType(sig);\n+            Type.getType(bytes);\n         }\n-        catch (final ClassFormatException cfe) {\n-            throw new ClassConstraintException(\"Illegal descriptor (==signature) '\" + sig + \"' used by '\" + Pass2Verifier.access$000((Node)obj) + \"'.\", (Throwable)cfe);\n+        catch (final ClassFormatException ex) {\n+            throw new ClassConstraintException(\"Illegal descriptor (==signature) '\" + bytes + \"' used by '\" + Pass2Verifier.access$000((Node)obj) + \"'.\", (Throwable)ex);\n         }\n-        final String nameanddesc = name + sig;\n-        if (this.fieldNamesAndDesc.contains(nameanddesc)) {\n+        final String string = name + bytes;\n+        if (this.fieldNamesAndDesc.contains(string)) {\n             throw new ClassConstraintException(\"No two fields (like '\" + Pass2Verifier.access$000((Node)obj) + \"') are allowed have same names and descriptors!\");\n         }\n         if (this.fieldNames.contains(name)) {\n             this.this$0.addMessage(\"More than one field of name '\" + name + \"' detected (but with different type descriptors). This is very unusual.\");\n         }\n-        this.fieldNamesAndDesc.add(nameanddesc);\n+        this.fieldNamesAndDesc.add(string);\n         this.fieldNames.add(name);\n-        final Attribute[] attributes;\n-        final Attribute[] atts = attributes = obj.getAttributes();\n-        for (final Attribute att : attributes) {\n-            if (!(att instanceof ConstantValue) && !(att instanceof Synthetic) && !(att instanceof Deprecated)) {\n-                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$000((Node)att) + \"' as an attribute of Field '\" + Pass2Verifier.access$000((Node)obj) + \"' is unknown and will therefore be ignored.\");\n+        for (final Attribute attribute : obj.getAttributes()) {\n+            if (!(attribute instanceof ConstantValue) && !(attribute instanceof Synthetic) && !(attribute instanceof Deprecated)) {\n+                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$000((Node)attribute) + \"' as an attribute of Field '\" + Pass2Verifier.access$000((Node)obj) + \"' is unknown and will therefore be ignored.\");\n             }\n-            if (!(att instanceof ConstantValue)) {\n-                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$000((Node)att) + \"' as an attribute of Field '\" + Pass2Verifier.access$000((Node)obj) + \"' is not a ConstantValue and is therefore only of use for debuggers and such.\");\n+            if (!(attribute instanceof ConstantValue)) {\n+                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$000((Node)attribute) + \"' as an attribute of Field '\" + Pass2Verifier.access$000((Node)obj) + \"' is not a ConstantValue and is therefore only of use for debuggers and such.\");\n             }\n         }\n     }\n     \n     public void visitInnerClass(final InnerClass obj) {\n     }\n     \n     public void visitInnerClasses(final InnerClasses innerClasses) {\n         this.checkIndex((Node)innerClasses, innerClasses.getNameIndex(), this.CONST_Utf8);\n-        final String name = ((ConstantUtf8)this.cp.getConstant(innerClasses.getNameIndex())).getBytes();\n-        if (!name.equals(\"InnerClasses\")) {\n-            throw new ClassConstraintException(\"The InnerClasses attribute '\" + Pass2Verifier.access$000((Node)innerClasses) + \"' is not correctly named 'InnerClasses' but '\" + name + \"'.\");\n+        final String bytes = ((ConstantUtf8)this.cp.getConstant(innerClasses.getNameIndex())).getBytes();\n+        if (!bytes.equals(\"InnerClasses\")) {\n+            throw new ClassConstraintException(\"The InnerClasses attribute '\" + Pass2Verifier.access$000((Node)innerClasses) + \"' is not correctly named 'InnerClasses' but '\" + bytes + \"'.\");\n         }\n         innerClasses.forEach(this::lambda$visitInnerClasses$0);\n     }\n     \n     public void visitJavaClass(final JavaClass obj) {\n-        final Attribute[] atts = obj.getAttributes();\n-        boolean foundSourceFile = false;\n-        boolean foundInnerClasses = false;\n-        final boolean hasInnerClass = new Pass2Verifier.InnerClassDetector(this.jc).innerClassReferenced();\n-        for (final Attribute att : atts) {\n-            if (!(att instanceof SourceFile) && !(att instanceof Deprecated) && !(att instanceof InnerClasses) && !(att instanceof Synthetic)) {\n-                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$000((Node)att) + \"' as an attribute of the ClassFile structure '\" + Pass2Verifier.access$000((Node)obj) + \"' is unknown and will therefore be ignored.\");\n+        final Attribute[] attributes = obj.getAttributes();\n+        int n = 0;\n+        int n2 = 0;\n+        final boolean innerClassReferenced = new Pass2Verifier.InnerClassDetector(this.jc).innerClassReferenced();\n+        for (final Attribute attribute : attributes) {\n+            if (!(attribute instanceof SourceFile) && !(attribute instanceof Deprecated) && !(attribute instanceof InnerClasses) && !(attribute instanceof Synthetic)) {\n+                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$000((Node)attribute) + \"' as an attribute of the ClassFile structure '\" + Pass2Verifier.access$000((Node)obj) + \"' is unknown and will therefore be ignored.\");\n             }\n-            if (att instanceof SourceFile) {\n-                if (foundSourceFile) {\n+            if (attribute instanceof SourceFile) {\n+                if (n != 0) {\n                     throw new ClassConstraintException(\"A ClassFile structure (like '\" + Pass2Verifier.access$000((Node)obj) + \"') may have no more than one SourceFile attribute.\");\n                 }\n-                foundSourceFile = true;\n+                n = 1;\n             }\n-            if (att instanceof InnerClasses) {\n-                if (!foundInnerClasses) {\n-                    foundInnerClasses = true;\n+            if (attribute instanceof InnerClasses) {\n+                if (n2 == 0) {\n+                    n2 = 1;\n                 }\n-                else if (hasInnerClass) {\n+                else if (innerClassReferenced) {\n                     throw new ClassConstraintException(\"A Classfile structure (like '\" + Pass2Verifier.access$000((Node)obj) + \"') must have exactly one InnerClasses attribute if at least one Inner Class is referenced (which is the case). More than one InnerClasses attribute was found.\");\n                 }\n-                if (!hasInnerClass) {\n-                    this.this$0.addMessage(\"No referenced Inner Class found, but InnerClasses attribute '\" + Pass2Verifier.access$000((Node)att) + \"' found. Strongly suggest removal of that attribute.\");\n+                if (!innerClassReferenced) {\n+                    this.this$0.addMessage(\"No referenced Inner Class found, but InnerClasses attribute '\" + Pass2Verifier.access$000((Node)attribute) + \"' found. Strongly suggest removal of that attribute.\");\n                 }\n             }\n         }\n-        if (hasInnerClass && !foundInnerClasses) {\n+        if (innerClassReferenced && n2 == 0) {\n             this.this$0.addMessage(\"A Classfile structure (like '\" + Pass2Verifier.access$000((Node)obj) + \"') must have exactly one InnerClasses attribute if at least one Inner Class is referenced (which is the case). No InnerClasses attribute was found.\");\n         }\n     }\n     \n     public void visitLineNumber(final LineNumber obj) {\n     }\n     \n     public void visitLineNumberTable(final LineNumberTable obj) {\n         this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n-        final String name = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n-        if (!name.equals(\"LineNumberTable\")) {\n-            throw new ClassConstraintException(\"The LineNumberTable attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' is not correctly named 'LineNumberTable' but '\" + name + \"'.\");\n+        final String bytes = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n+        if (!bytes.equals(\"LineNumberTable\")) {\n+            throw new ClassConstraintException(\"The LineNumberTable attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' is not correctly named 'LineNumberTable' but '\" + bytes + \"'.\");\n         }\n     }\n     \n     public void visitLocalVariable(final LocalVariable obj) {\n     }\n     \n     public void visitLocalVariableTable(final LocalVariableTable obj) {\n@@ -508,64 +495,60 @@\n     public void visitMethod(final Method obj) {\n         this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n         final String name = obj.getName();\n         if (!Pass2Verifier.access$500(name, true)) {\n             throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$000((Node)obj) + \"' has illegal name '\" + name + \"'.\");\n         }\n         this.checkIndex((Node)obj, obj.getSignatureIndex(), this.CONST_Utf8);\n-        final String sig = ((ConstantUtf8)this.cp.getConstant(obj.getSignatureIndex())).getBytes();\n-        Type t;\n-        Type[] ts;\n+        final String bytes = ((ConstantUtf8)this.cp.getConstant(obj.getSignatureIndex())).getBytes();\n+        Type returnType;\n+        Type[] argumentTypes;\n         try {\n-            t = Type.getReturnType(sig);\n-            ts = Type.getArgumentTypes(sig);\n+            returnType = Type.getReturnType(bytes);\n+            argumentTypes = Type.getArgumentTypes(bytes);\n         }\n-        catch (final ClassFormatException cfe) {\n-            throw new ClassConstraintException(\"Illegal descriptor (==signature) '\" + sig + \"' used by Method '\" + Pass2Verifier.access$000((Node)obj) + \"'.\", (Throwable)cfe);\n+        catch (final ClassFormatException ex) {\n+            throw new ClassConstraintException(\"Illegal descriptor (==signature) '\" + bytes + \"' used by Method '\" + Pass2Verifier.access$000((Node)obj) + \"'.\", (Throwable)ex);\n         }\n-        Type act = t;\n-        if (act instanceof ArrayType) {\n-            act = ((ArrayType)act).getBasicType();\n+        Type basicType = returnType;\n+        if (basicType instanceof ArrayType) {\n+            basicType = ((ArrayType)basicType).getBasicType();\n         }\n-        if (act instanceof ObjectType) {\n-            final Verifier v = VerifierFactory.getVerifier(((ObjectType)act).getClassName());\n-            final VerificationResult vr = v.doPass1();\n-            if (vr != VerificationResult.VR_OK) {\n-                throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$000((Node)obj) + \"' has a return type that does not pass verification pass 1: '\" + vr + \"'.\");\n+        if (basicType instanceof ObjectType) {\n+            final VerificationResult doPass1 = VerifierFactory.getVerifier(((ObjectType)basicType).getClassName()).doPass1();\n+            if (doPass1 != VerificationResult.VR_OK) {\n+                throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$000((Node)obj) + \"' has a return type that does not pass verification pass 1: '\" + doPass1 + \"'.\");\n             }\n         }\n-        final Type[] array = ts;\n-        for (int length = array.length, i = 0; i < length; ++i) {\n-            final Type element = act = array[i];\n-            if (act instanceof ArrayType) {\n-                act = ((ArrayType)act).getBasicType();\n+        for (Type basicType2 : argumentTypes) {\n+            if (basicType2 instanceof ArrayType) {\n+                basicType2 = ((ArrayType)basicType2).getBasicType();\n             }\n-            if (act instanceof ObjectType) {\n-                final Verifier v2 = VerifierFactory.getVerifier(((ObjectType)act).getClassName());\n-                final VerificationResult vr2 = v2.doPass1();\n-                if (vr2 != VerificationResult.VR_OK) {\n-                    throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$000((Node)obj) + \"' has an argument type that does not pass verification pass 1: '\" + vr2 + \"'.\");\n+            if (basicType2 instanceof ObjectType) {\n+                final VerificationResult doPass2 = VerifierFactory.getVerifier(((ObjectType)basicType2).getClassName()).doPass1();\n+                if (doPass2 != VerificationResult.VR_OK) {\n+                    throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$000((Node)obj) + \"' has an argument type that does not pass verification pass 1: '\" + doPass2 + \"'.\");\n                 }\n             }\n         }\n-        if (name.equals(\"<clinit>\") && ts.length != 0) {\n+        if (name.equals(\"<clinit>\") && argumentTypes.length != 0) {\n             throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$000((Node)obj) + \"' has illegal name '\" + name + \"'. Its name resembles the class or interface initialization method which it isn't because of its arguments (==descriptor).\");\n         }\n         if (this.jc.isClass()) {\n-            int maxone = 0;\n+            int n = 0;\n             if (obj.isPrivate()) {\n-                ++maxone;\n+                ++n;\n             }\n             if (obj.isProtected()) {\n-                ++maxone;\n+                ++n;\n             }\n             if (obj.isPublic()) {\n-                ++maxone;\n+                ++n;\n             }\n-            if (maxone > 1) {\n+            if (n > 1) {\n                 throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$000((Node)obj) + \"' must only have at most one of its ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC modifiers set.\");\n             }\n             if (obj.isAbstract()) {\n                 if (obj.isFinal()) {\n                     throw new ClassConstraintException(\"Abstract method '\" + Pass2Verifier.access$000((Node)obj) + \"' must not have the ACC_FINAL modifier set.\");\n                 }\n                 if (obj.isNative()) {\n@@ -608,59 +591,59 @@\n                     throw new ClassConstraintException(\"Interface method '\" + Pass2Verifier.access$000((Node)obj) + \"' must not have any of the ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT, ACC_STRICT modifiers set.\");\n                 }\n             }\n         }\n         if ((obj.getAccessFlags() & 0xFFFFF2C0) > 0) {\n             this.this$0.addMessage(\"Method '\" + Pass2Verifier.access$000((Node)obj) + \"' has access flag(s) other than ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT, ACC_STRICT set (ignored).\");\n         }\n-        final String nameanddesc = name + sig;\n-        if (this.methodNamesAndDesc.contains(nameanddesc)) {\n+        final String string = name + bytes;\n+        if (this.methodNamesAndDesc.contains(string)) {\n             throw new ClassConstraintException(\"No two methods (like '\" + Pass2Verifier.access$000((Node)obj) + \"') are allowed have same names and desciptors!\");\n         }\n-        this.methodNamesAndDesc.add(nameanddesc);\n-        final Attribute[] atts = obj.getAttributes();\n-        int numCodeAtts = 0;\n-        for (final Attribute att : atts) {\n-            if (!(att instanceof Code) && !(att instanceof ExceptionTable) && !(att instanceof Synthetic) && !(att instanceof Deprecated)) {\n-                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$000((Node)att) + \"' as an attribute of Method '\" + Pass2Verifier.access$000((Node)obj) + \"' is unknown and will therefore be ignored.\");\n+        this.methodNamesAndDesc.add(string);\n+        final Attribute[] attributes = obj.getAttributes();\n+        int j = 0;\n+        for (final Attribute attribute : attributes) {\n+            if (!(attribute instanceof Code) && !(attribute instanceof ExceptionTable) && !(attribute instanceof Synthetic) && !(attribute instanceof Deprecated)) {\n+                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$000((Node)attribute) + \"' as an attribute of Method '\" + Pass2Verifier.access$000((Node)obj) + \"' is unknown and will therefore be ignored.\");\n             }\n-            if (!(att instanceof Code) && !(att instanceof ExceptionTable)) {\n-                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$000((Node)att) + \"' as an attribute of Method '\" + Pass2Verifier.access$000((Node)obj) + \"' is neither Code nor Exceptions and is therefore only of use for debuggers and such.\");\n+            if (!(attribute instanceof Code) && !(attribute instanceof ExceptionTable)) {\n+                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$000((Node)attribute) + \"' as an attribute of Method '\" + Pass2Verifier.access$000((Node)obj) + \"' is neither Code nor Exceptions and is therefore only of use for debuggers and such.\");\n             }\n-            if (att instanceof Code && (obj.isNative() || obj.isAbstract())) {\n-                throw new ClassConstraintException(\"Native or abstract methods like '\" + Pass2Verifier.access$000((Node)obj) + \"' must not have a Code attribute like '\" + Pass2Verifier.access$000((Node)att) + \"'.\");\n+            if (attribute instanceof Code && (obj.isNative() || obj.isAbstract())) {\n+                throw new ClassConstraintException(\"Native or abstract methods like '\" + Pass2Verifier.access$000((Node)obj) + \"' must not have a Code attribute like '\" + Pass2Verifier.access$000((Node)attribute) + \"'.\");\n             }\n-            if (att instanceof Code) {\n-                ++numCodeAtts;\n+            if (attribute instanceof Code) {\n+                ++j;\n             }\n         }\n-        if (!obj.isNative() && !obj.isAbstract() && numCodeAtts != 1) {\n-            throw new ClassConstraintException(\"Non-native, non-abstract methods like '\" + Pass2Verifier.access$000((Node)obj) + \"' must have exactly one Code attribute (found: \" + numCodeAtts + \").\");\n+        if (!obj.isNative() && !obj.isAbstract() && j != 1) {\n+            throw new ClassConstraintException(\"Non-native, non-abstract methods like '\" + Pass2Verifier.access$000((Node)obj) + \"' must have exactly one Code attribute (found: \" + j + \").\");\n         }\n     }\n     \n     public void visitSourceFile(final SourceFile obj) {\n         this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n-        final String name = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n-        if (!name.equals(\"SourceFile\")) {\n-            throw new ClassConstraintException(\"The SourceFile attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' is not correctly named 'SourceFile' but '\" + name + \"'.\");\n+        final String bytes = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n+        if (!bytes.equals(\"SourceFile\")) {\n+            throw new ClassConstraintException(\"The SourceFile attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' is not correctly named 'SourceFile' but '\" + bytes + \"'.\");\n         }\n         this.checkIndex((Node)obj, obj.getSourceFileIndex(), this.CONST_Utf8);\n-        final String sourceFileName = ((ConstantUtf8)this.cp.getConstant(obj.getSourceFileIndex())).getBytes();\n-        final String sourceFileNameLc = sourceFileName.toLowerCase(Locale.ENGLISH);\n-        if (sourceFileName.indexOf(47) != -1 || sourceFileName.indexOf(92) != -1 || sourceFileName.indexOf(58) != -1 || sourceFileNameLc.lastIndexOf(\".java\") == -1) {\n-            this.this$0.addMessage(\"SourceFile attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' has a funny name: remember not to confuse certain parsers working on javap's output. Also, this name ('\" + sourceFileName + \"') is considered an unqualified (simple) file name only.\");\n+        final String bytes2 = ((ConstantUtf8)this.cp.getConstant(obj.getSourceFileIndex())).getBytes();\n+        final String lowerCase = bytes2.toLowerCase(Locale.ENGLISH);\n+        if (bytes2.indexOf(47) != -1 || bytes2.indexOf(92) != -1 || bytes2.indexOf(58) != -1 || lowerCase.lastIndexOf(\".java\") == -1) {\n+            this.this$0.addMessage(\"SourceFile attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' has a funny name: remember not to confuse certain parsers working on javap's output. Also, this name ('\" + bytes2 + \"') is considered an unqualified (simple) file name only.\");\n         }\n     }\n     \n     public void visitSynthetic(final Synthetic obj) {\n         this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n-        final String name = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n-        if (!name.equals(\"Synthetic\")) {\n-            throw new ClassConstraintException(\"The Synthetic attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' is not correctly named 'Synthetic' but '\" + name + \"'.\");\n+        final String bytes = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n+        if (!bytes.equals(\"Synthetic\")) {\n+            throw new ClassConstraintException(\"The Synthetic attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' is not correctly named 'Synthetic' but '\" + bytes + \"'.\");\n         }\n     }\n     \n     public void visitUnknown(final Unknown obj) {\n         this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n         this.this$0.addMessage(\"Unknown attribute '\" + Pass2Verifier.access$000((Node)obj) + \"'. This attribute is not known in any context!\");\n     }\n"}]}
