{"diffoscope-json-version": 1, "source1": "first/SevenZFile.class", "source2": "second/SevenZFile.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -37,57 +37,57 @@\n     private int currentEntryIndex;\n     private int currentFolderIndex;\n     private InputStream currentFolderInputStream;\n     private byte[] password;\n     private final ArrayList<InputStream> deferredBlockStreams;\n     static final byte[] sevenZSignature;\n     \n-    public SevenZFile(final File filename, final byte[] password) throws IOException {\n-        this(Files.newByteChannel(filename.toPath(), (Set<? extends OpenOption>)EnumSet.of(StandardOpenOption.READ), (FileAttribute<?>[])new FileAttribute[0]), filename.getAbsolutePath(), password, true);\n+    public SevenZFile(final File file, final byte[] array) throws IOException {\n+        this(Files.newByteChannel(file.toPath(), (Set<? extends OpenOption>)EnumSet.of(StandardOpenOption.READ), (FileAttribute<?>[])new FileAttribute[0]), file.getAbsolutePath(), array, true);\n     }\n     \n-    public SevenZFile(final SeekableByteChannel channel) throws IOException {\n-        this(channel, \"unknown archive\", null);\n+    public SevenZFile(final SeekableByteChannel seekableByteChannel) throws IOException {\n+        this(seekableByteChannel, \"unknown archive\", null);\n     }\n     \n-    public SevenZFile(final SeekableByteChannel channel, final byte[] password) throws IOException {\n-        this(channel, \"unknown archive\", password);\n+    public SevenZFile(final SeekableByteChannel seekableByteChannel, final byte[] array) throws IOException {\n+        this(seekableByteChannel, \"unknown archive\", array);\n     }\n     \n-    public SevenZFile(final SeekableByteChannel channel, final String filename, final byte[] password) throws IOException {\n-        this(channel, filename, password, false);\n+    public SevenZFile(final SeekableByteChannel seekableByteChannel, final String s, final byte[] array) throws IOException {\n+        this(seekableByteChannel, s, array, false);\n     }\n     \n-    private SevenZFile(final SeekableByteChannel channel, final String filename, final byte[] password, final boolean closeOnError) throws IOException {\n+    private SevenZFile(final SeekableByteChannel channel, final String fileName, final byte[] array, final boolean b) throws IOException {\n         this.currentEntryIndex = -1;\n         this.currentFolderIndex = -1;\n         this.currentFolderInputStream = null;\n         this.deferredBlockStreams = new ArrayList<InputStream>();\n-        boolean succeeded = false;\n+        boolean b2 = false;\n         this.channel = channel;\n-        this.fileName = filename;\n+        this.fileName = fileName;\n         try {\n-            this.archive = this.readHeaders(password);\n-            if (password != null) {\n-                System.arraycopy(password, 0, this.password = new byte[password.length], 0, password.length);\n+            this.archive = this.readHeaders(array);\n+            if (array != null) {\n+                System.arraycopy(array, 0, this.password = new byte[array.length], 0, array.length);\n             }\n             else {\n                 this.password = null;\n             }\n-            succeeded = true;\n+            b2 = true;\n         }\n         finally {\n-            if (!succeeded && closeOnError) {\n+            if (!b2 && b) {\n                 this.channel.close();\n             }\n         }\n     }\n     \n-    public SevenZFile(final File filename) throws IOException {\n-        this(filename, null);\n+    public SevenZFile(final File file) throws IOException {\n+        this(file, null);\n     }\n     \n     @Override\n     public void close() throws IOException {\n         if (this.channel != null) {\n             try {\n                 this.channel.close();\n@@ -103,721 +103,705 @@\n     }\n     \n     public SevenZArchiveEntry getNextEntry() throws IOException {\n         if (this.currentEntryIndex >= this.archive.files.length - 1) {\n             return null;\n         }\n         ++this.currentEntryIndex;\n-        final SevenZArchiveEntry entry = this.archive.files[this.currentEntryIndex];\n+        final SevenZArchiveEntry sevenZArchiveEntry = this.archive.files[this.currentEntryIndex];\n         this.buildDecodingStream();\n-        return entry;\n+        return sevenZArchiveEntry;\n     }\n     \n     public Iterable<SevenZArchiveEntry> getEntries() {\n         return Arrays.asList(this.archive.files);\n     }\n     \n-    private Archive readHeaders(final byte[] password) throws IOException {\n-        ByteBuffer buf = ByteBuffer.allocate(12).order(ByteOrder.LITTLE_ENDIAN);\n-        this.readFully(buf);\n-        final byte[] signature = new byte[6];\n-        buf.get(signature);\n-        if (!Arrays.equals(signature, SevenZFile.sevenZSignature)) {\n+    private Archive readHeaders(final byte[] array) throws IOException {\n+        final ByteBuffer order = ByteBuffer.allocate(12).order(ByteOrder.LITTLE_ENDIAN);\n+        this.readFully(order);\n+        final byte[] array2 = new byte[6];\n+        order.get(array2);\n+        if (!Arrays.equals(array2, SevenZFile.sevenZSignature)) {\n             throw new IOException(\"Bad 7z signature\");\n         }\n-        final byte archiveVersionMajor = buf.get();\n-        final byte archiveVersionMinor = buf.get();\n-        if (archiveVersionMajor != 0) {\n-            throw new IOException(String.format(\"Unsupported 7z version (%d,%d)\", Byte.valueOf(archiveVersionMajor), Byte.valueOf(archiveVersionMinor)));\n-        }\n-        final long startHeaderCrc = 0xFFFFFFFFL & (long)buf.getInt();\n-        final StartHeader startHeader = this.readStartHeader(startHeaderCrc);\n-        final int nextHeaderSizeInt = (int)startHeader.nextHeaderSize;\n-        if (nextHeaderSizeInt != startHeader.nextHeaderSize) {\n+        final byte value = order.get();\n+        final byte value2 = order.get();\n+        if (value != 0) {\n+            throw new IOException(String.format(\"Unsupported 7z version (%d,%d)\", Byte.valueOf(value), Byte.valueOf(value2)));\n+        }\n+        final StartHeader startHeader = this.readStartHeader(0xFFFFFFFFL & (long)order.getInt());\n+        final int capacity = (int)startHeader.nextHeaderSize;\n+        if (capacity != startHeader.nextHeaderSize) {\n             throw new IOException(\"cannot handle nextHeaderSize \" + startHeader.nextHeaderSize);\n         }\n         this.channel.position(32L + startHeader.nextHeaderOffset);\n-        buf = ByteBuffer.allocate(nextHeaderSizeInt).order(ByteOrder.LITTLE_ENDIAN);\n-        this.readFully(buf);\n-        final CRC32 crc = new CRC32();\n-        crc.update(buf.array());\n-        if (startHeader.nextHeaderCrc != crc.getValue()) {\n+        ByteBuffer byteBuffer = ByteBuffer.allocate(capacity).order(ByteOrder.LITTLE_ENDIAN);\n+        this.readFully(byteBuffer);\n+        final CRC32 crc32 = new CRC32();\n+        crc32.update(byteBuffer.array());\n+        if (startHeader.nextHeaderCrc != crc32.getValue()) {\n             throw new IOException(\"NextHeader CRC mismatch\");\n         }\n         Archive archive = new Archive();\n-        int nid = getUnsignedByte(buf);\n-        if (nid == 23) {\n-            buf = this.readEncodedHeader(buf, archive, password);\n+        int n = getUnsignedByte(byteBuffer);\n+        if (n == 23) {\n+            byteBuffer = this.readEncodedHeader(byteBuffer, archive, array);\n             archive = new Archive();\n-            nid = getUnsignedByte(buf);\n+            n = getUnsignedByte(byteBuffer);\n         }\n-        if (nid == 1) {\n-            this.readHeader(buf, archive);\n+        if (n == 1) {\n+            this.readHeader(byteBuffer, archive);\n             return archive;\n         }\n         throw new IOException(\"Broken or unsupported archive: no Header\");\n     }\n     \n-    private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\n+    private StartHeader readStartHeader(final long n) throws IOException {\n         final StartHeader startHeader = new StartHeader();\n-        try (final DataInputStream dataInputStream = new DataInputStream((InputStream)new CRC32VerifyingInputStream((InputStream)new BoundedSeekableByteChannelInputStream(this.channel, 20L), 20L, startHeaderCrc))) {\n+        try (final DataInputStream dataInputStream = new DataInputStream((InputStream)new CRC32VerifyingInputStream((InputStream)new BoundedSeekableByteChannelInputStream(this.channel, 20L), 20L, n))) {\n             startHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\n             startHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\n             startHeader.nextHeaderCrc = (0xFFFFFFFFL & (long)Integer.reverseBytes(dataInputStream.readInt()));\n             return startHeader;\n         }\n     }\n     \n-    private void readHeader(final ByteBuffer header, final Archive archive) throws IOException {\n-        int nid = getUnsignedByte(header);\n-        if (nid == 2) {\n-            this.readArchiveProperties(header);\n-            nid = getUnsignedByte(header);\n+    private void readHeader(final ByteBuffer byteBuffer, final Archive archive) throws IOException {\n+        int i = getUnsignedByte(byteBuffer);\n+        if (i == 2) {\n+            this.readArchiveProperties(byteBuffer);\n+            i = getUnsignedByte(byteBuffer);\n         }\n-        if (nid == 3) {\n+        if (i == 3) {\n             throw new IOException(\"Additional streams unsupported\");\n         }\n-        if (nid == 4) {\n-            this.readStreamsInfo(header, archive);\n-            nid = getUnsignedByte(header);\n+        if (i == 4) {\n+            this.readStreamsInfo(byteBuffer, archive);\n+            i = getUnsignedByte(byteBuffer);\n         }\n-        if (nid == 5) {\n-            this.readFilesInfo(header, archive);\n-            nid = getUnsignedByte(header);\n+        if (i == 5) {\n+            this.readFilesInfo(byteBuffer, archive);\n+            i = getUnsignedByte(byteBuffer);\n         }\n-        if (nid != 0) {\n-            throw new IOException(\"Badly terminated header, found \" + nid);\n+        if (i != 0) {\n+            throw new IOException(\"Badly terminated header, found \" + i);\n         }\n     }\n     \n-    private void readArchiveProperties(final ByteBuffer input) throws IOException {\n-        for (int nid = getUnsignedByte(input); nid != 0; nid = getUnsignedByte(input)) {\n-            final long propertySize = readUint64(input);\n-            final byte[] property = new byte[(int)propertySize];\n-            input.get(property);\n+    private void readArchiveProperties(final ByteBuffer byteBuffer) throws IOException {\n+        for (int i = getUnsignedByte(byteBuffer); i != 0; i = getUnsignedByte(byteBuffer)) {\n+            byteBuffer.get(new byte[(int)readUint64(byteBuffer)]);\n         }\n     }\n     \n-    private ByteBuffer readEncodedHeader(final ByteBuffer header, final Archive archive, final byte[] password) throws IOException {\n-        this.readStreamsInfo(header, archive);\n+    private ByteBuffer readEncodedHeader(final ByteBuffer byteBuffer, final Archive archive, final byte[] array) throws IOException {\n+        this.readStreamsInfo(byteBuffer, archive);\n         final Folder folder = archive.folders[0];\n-        final int firstPackStreamIndex = 0;\n-        final long folderOffset = 32L + archive.packPos + 0L;\n-        this.channel.position(folderOffset);\n-        InputStream inputStreamStack = (InputStream)new BoundedSeekableByteChannelInputStream(this.channel, archive.packSizes[0]);\n+        this.channel.position(32L + archive.packPos + 0L);\n+        Object addDecoder = new BoundedSeekableByteChannelInputStream(this.channel, archive.packSizes[0]);\n         for (final Coder coder : folder.getOrderedCoders()) {\n             if (coder.numInStreams != 1L || coder.numOutStreams != 1L) {\n                 throw new IOException(\"Multi input/output stream coders are not yet supported\");\n             }\n-            inputStreamStack = Coders.addDecoder(this.fileName, inputStreamStack, folder.getUnpackSizeForCoder(coder), coder, password);\n+            addDecoder = Coders.addDecoder(this.fileName, (InputStream)addDecoder, folder.getUnpackSizeForCoder(coder), coder, array);\n         }\n         if (folder.hasCrc) {\n-            inputStreamStack = (InputStream)new CRC32VerifyingInputStream(inputStreamStack, folder.getUnpackSize(), folder.crc);\n+            addDecoder = new CRC32VerifyingInputStream((InputStream)addDecoder, folder.getUnpackSize(), folder.crc);\n         }\n-        final byte[] nextHeader = new byte[(int)folder.getUnpackSize()];\n-        try (final DataInputStream nextHeaderInputStream = new DataInputStream(inputStreamStack)) {\n-            nextHeaderInputStream.readFully(nextHeader);\n+        final byte[] array2 = new byte[(int)folder.getUnpackSize()];\n+        try (final DataInputStream dataInputStream = new DataInputStream((InputStream)addDecoder)) {\n+            dataInputStream.readFully(array2);\n         }\n-        return ByteBuffer.wrap(nextHeader).order(ByteOrder.LITTLE_ENDIAN);\n+        return ByteBuffer.wrap(array2).order(ByteOrder.LITTLE_ENDIAN);\n     }\n     \n-    private void readStreamsInfo(final ByteBuffer header, final Archive archive) throws IOException {\n-        int nid = getUnsignedByte(header);\n-        if (nid == 6) {\n-            this.readPackInfo(header, archive);\n-            nid = getUnsignedByte(header);\n+    private void readStreamsInfo(final ByteBuffer byteBuffer, final Archive archive) throws IOException {\n+        int n = getUnsignedByte(byteBuffer);\n+        if (n == 6) {\n+            this.readPackInfo(byteBuffer, archive);\n+            n = getUnsignedByte(byteBuffer);\n         }\n-        if (nid == 7) {\n-            this.readUnpackInfo(header, archive);\n-            nid = getUnsignedByte(header);\n+        if (n == 7) {\n+            this.readUnpackInfo(byteBuffer, archive);\n+            n = getUnsignedByte(byteBuffer);\n         }\n         else {\n             archive.folders = new Folder[0];\n         }\n-        if (nid == 8) {\n-            this.readSubStreamsInfo(header, archive);\n-            nid = getUnsignedByte(header);\n+        if (n == 8) {\n+            this.readSubStreamsInfo(byteBuffer, archive);\n+            n = getUnsignedByte(byteBuffer);\n         }\n-        if (nid != 0) {\n+        if (n != 0) {\n             throw new IOException(\"Badly terminated StreamsInfo\");\n         }\n     }\n     \n-    private void readPackInfo(final ByteBuffer header, final Archive archive) throws IOException {\n-        archive.packPos = readUint64(header);\n-        final long numPackStreams = readUint64(header);\n-        int nid = getUnsignedByte(header);\n-        if (nid == 9) {\n-            archive.packSizes = new long[(int)numPackStreams];\n-            for (int i = 0; i < archive.packSizes.length; ++i) {\n-                archive.packSizes[i] = readUint64(header);\n+    private void readPackInfo(final ByteBuffer byteBuffer, final Archive archive) throws IOException {\n+        archive.packPos = readUint64(byteBuffer);\n+        final long uint64 = readUint64(byteBuffer);\n+        int i = getUnsignedByte(byteBuffer);\n+        if (i == 9) {\n+            archive.packSizes = new long[(int)uint64];\n+            for (int j = 0; j < archive.packSizes.length; ++j) {\n+                archive.packSizes[j] = readUint64(byteBuffer);\n             }\n-            nid = getUnsignedByte(header);\n+            i = getUnsignedByte(byteBuffer);\n         }\n-        if (nid == 10) {\n-            archive.packCrcsDefined = this.readAllOrBits(header, (int)numPackStreams);\n-            archive.packCrcs = new long[(int)numPackStreams];\n-            for (int i = 0; i < (int)numPackStreams; ++i) {\n-                if (archive.packCrcsDefined.get(i)) {\n-                    archive.packCrcs[i] = (0xFFFFFFFFL & (long)header.getInt());\n+        if (i == 10) {\n+            archive.packCrcsDefined = this.readAllOrBits(byteBuffer, (int)uint64);\n+            archive.packCrcs = new long[(int)uint64];\n+            for (int k = 0; k < (int)uint64; ++k) {\n+                if (archive.packCrcsDefined.get(k)) {\n+                    archive.packCrcs[k] = (0xFFFFFFFFL & (long)byteBuffer.getInt());\n                 }\n             }\n-            nid = getUnsignedByte(header);\n+            i = getUnsignedByte(byteBuffer);\n         }\n-        if (nid != 0) {\n-            throw new IOException(\"Badly terminated PackInfo (\" + nid + \")\");\n+        if (i != 0) {\n+            throw new IOException(\"Badly terminated PackInfo (\" + i + \")\");\n         }\n     }\n     \n-    private void readUnpackInfo(final ByteBuffer header, final Archive archive) throws IOException {\n-        int nid = getUnsignedByte(header);\n-        if (nid != 11) {\n-            throw new IOException(\"Expected kFolder, got \" + nid);\n+    private void readUnpackInfo(final ByteBuffer byteBuffer, final Archive archive) throws IOException {\n+        final int unsignedByte = getUnsignedByte(byteBuffer);\n+        if (unsignedByte != 11) {\n+            throw new IOException(\"Expected kFolder, got \" + unsignedByte);\n         }\n-        final long numFolders = readUint64(header);\n-        final Folder[] folders = new Folder[(int)numFolders];\n+        final long uint64 = readUint64(byteBuffer);\n+        final Folder[] folders = new Folder[(int)uint64];\n         archive.folders = folders;\n-        final int external = getUnsignedByte(header);\n-        if (external != 0) {\n+        if (getUnsignedByte(byteBuffer) != 0) {\n             throw new IOException(\"External unsupported\");\n         }\n-        for (int i = 0; i < (int)numFolders; ++i) {\n-            folders[i] = this.readFolder(header);\n+        for (int i = 0; i < (int)uint64; ++i) {\n+            folders[i] = this.readFolder(byteBuffer);\n         }\n-        nid = getUnsignedByte(header);\n-        if (nid != 12) {\n-            throw new IOException(\"Expected kCodersUnpackSize, got \" + nid);\n+        final int unsignedByte2 = getUnsignedByte(byteBuffer);\n+        if (unsignedByte2 != 12) {\n+            throw new IOException(\"Expected kCodersUnpackSize, got \" + unsignedByte2);\n         }\n         for (final Folder folder : folders) {\n             folder.unpackSizes = new long[(int)folder.totalOutputStreams];\n-            for (int j = 0; j < folder.totalOutputStreams; ++j) {\n-                folder.unpackSizes[j] = readUint64(header);\n+            for (int n = 0; n < folder.totalOutputStreams; ++n) {\n+                folder.unpackSizes[n] = readUint64(byteBuffer);\n             }\n         }\n-        nid = getUnsignedByte(header);\n-        if (nid == 10) {\n-            final BitSet crcsDefined = this.readAllOrBits(header, (int)numFolders);\n-            for (int k = 0; k < (int)numFolders; ++k) {\n-                if (crcsDefined.get(k)) {\n+        int n2 = getUnsignedByte(byteBuffer);\n+        if (n2 == 10) {\n+            final BitSet allOrBits = this.readAllOrBits(byteBuffer, (int)uint64);\n+            for (int k = 0; k < (int)uint64; ++k) {\n+                if (allOrBits.get(k)) {\n                     folders[k].hasCrc = true;\n-                    folders[k].crc = (0xFFFFFFFFL & (long)header.getInt());\n+                    folders[k].crc = (0xFFFFFFFFL & (long)byteBuffer.getInt());\n                 }\n                 else {\n                     folders[k].hasCrc = false;\n                 }\n             }\n-            nid = getUnsignedByte(header);\n+            n2 = getUnsignedByte(byteBuffer);\n         }\n-        if (nid != 0) {\n+        if (n2 != 0) {\n             throw new IOException(\"Badly terminated UnpackInfo\");\n         }\n     }\n     \n-    private void readSubStreamsInfo(final ByteBuffer header, final Archive archive) throws IOException {\n-        for (final Folder folder : archive.folders) {\n-            folder.numUnpackSubStreams = 1;\n-        }\n-        int totalUnpackStreams = archive.folders.length;\n-        int nid = getUnsignedByte(header);\n-        if (nid == 13) {\n-            totalUnpackStreams = 0;\n-            for (final Folder folder2 : archive.folders) {\n-                final long numStreams = readUint64(header);\n-                folder2.numUnpackSubStreams = (int)numStreams;\n-                totalUnpackStreams += numStreams;\n+    private void readSubStreamsInfo(final ByteBuffer byteBuffer, final Archive archive) throws IOException {\n+        final Folder[] folders = archive.folders;\n+        for (int length = folders.length, i = 0; i < length; ++i) {\n+            folders[i].numUnpackSubStreams = 1;\n+        }\n+        int length2 = archive.folders.length;\n+        int n = getUnsignedByte(byteBuffer);\n+        if (n == 13) {\n+            length2 = 0;\n+            for (final Folder folder : archive.folders) {\n+                final long uint64 = readUint64(byteBuffer);\n+                folder.numUnpackSubStreams = (int)uint64;\n+                length2 += uint64;\n             }\n-            nid = getUnsignedByte(header);\n+            n = getUnsignedByte(byteBuffer);\n         }\n         final SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\n-        subStreamsInfo.unpackSizes = new long[totalUnpackStreams];\n-        subStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\n-        subStreamsInfo.crcs = new long[totalUnpackStreams];\n-        int nextUnpackStream = 0;\n+        subStreamsInfo.unpackSizes = new long[length2];\n+        subStreamsInfo.hasCrc = new BitSet(length2);\n+        subStreamsInfo.crcs = new long[length2];\n+        int n2 = 0;\n+        for (final Folder folder2 : archive.folders) {\n+            if (folder2.numUnpackSubStreams != 0) {\n+                long n3 = 0L;\n+                if (n == 9) {\n+                    for (int l = 0; l < folder2.numUnpackSubStreams - 1; ++l) {\n+                        final long uint65 = readUint64(byteBuffer);\n+                        subStreamsInfo.unpackSizes[n2++] = uint65;\n+                        n3 += uint65;\n+                    }\n+                }\n+                subStreamsInfo.unpackSizes[n2++] = folder2.getUnpackSize() - n3;\n+            }\n+        }\n+        if (n == 9) {\n+            n = getUnsignedByte(byteBuffer);\n+        }\n+        int n4 = 0;\n         for (final Folder folder3 : archive.folders) {\n-            if (folder3.numUnpackSubStreams != 0) {\n-                long sum = 0L;\n-                if (nid == 9) {\n-                    for (int i = 0; i < folder3.numUnpackSubStreams - 1; ++i) {\n-                        final long size = readUint64(header);\n-                        subStreamsInfo.unpackSizes[nextUnpackStream++] = size;\n-                        sum += size;\n-                    }\n-                }\n-                subStreamsInfo.unpackSizes[nextUnpackStream++] = folder3.getUnpackSize() - sum;\n-            }\n-        }\n-        if (nid == 9) {\n-            nid = getUnsignedByte(header);\n-        }\n-        int numDigests = 0;\n-        for (final Folder folder4 : archive.folders) {\n-            if (folder4.numUnpackSubStreams != 1 || !folder4.hasCrc) {\n-                numDigests += folder4.numUnpackSubStreams;\n-            }\n-        }\n-        if (nid == 10) {\n-            final BitSet hasMissingCrc = this.readAllOrBits(header, numDigests);\n-            final long[] missingCrcs = new long[numDigests];\n-            for (int j = 0; j < numDigests; ++j) {\n-                if (hasMissingCrc.get(j)) {\n-                    missingCrcs[j] = (0xFFFFFFFFL & (long)header.getInt());\n-                }\n-            }\n-            int nextCrc = 0;\n-            int nextMissingCrc = 0;\n-            for (final Folder folder5 : archive.folders) {\n-                if (folder5.numUnpackSubStreams == 1 && folder5.hasCrc) {\n-                    subStreamsInfo.hasCrc.set(nextCrc, true);\n-                    subStreamsInfo.crcs[nextCrc] = folder5.crc;\n-                    ++nextCrc;\n+            if (folder3.numUnpackSubStreams != 1 || !folder3.hasCrc) {\n+                n4 += folder3.numUnpackSubStreams;\n+            }\n+        }\n+        if (n == 10) {\n+            final BitSet allOrBits = this.readAllOrBits(byteBuffer, n4);\n+            final long[] array = new long[n4];\n+            for (int bitIndex = 0; bitIndex < n4; ++bitIndex) {\n+                if (allOrBits.get(bitIndex)) {\n+                    array[bitIndex] = (0xFFFFFFFFL & (long)byteBuffer.getInt());\n+                }\n+            }\n+            int n6 = 0;\n+            int bitIndex2 = 0;\n+            for (final Folder folder4 : archive.folders) {\n+                if (folder4.numUnpackSubStreams == 1 && folder4.hasCrc) {\n+                    subStreamsInfo.hasCrc.set(n6, true);\n+                    subStreamsInfo.crcs[n6] = folder4.crc;\n+                    ++n6;\n                 }\n                 else {\n-                    for (int k = 0; k < folder5.numUnpackSubStreams; ++k) {\n-                        subStreamsInfo.hasCrc.set(nextCrc, hasMissingCrc.get(nextMissingCrc));\n-                        subStreamsInfo.crcs[nextCrc] = missingCrcs[nextMissingCrc];\n-                        ++nextCrc;\n-                        ++nextMissingCrc;\n+                    for (int n8 = 0; n8 < folder4.numUnpackSubStreams; ++n8) {\n+                        subStreamsInfo.hasCrc.set(n6, allOrBits.get(bitIndex2));\n+                        subStreamsInfo.crcs[n6] = array[bitIndex2];\n+                        ++n6;\n+                        ++bitIndex2;\n                     }\n                 }\n             }\n-            nid = getUnsignedByte(header);\n+            n = getUnsignedByte(byteBuffer);\n         }\n-        if (nid != 0) {\n+        if (n != 0) {\n             throw new IOException(\"Badly terminated SubStreamsInfo\");\n         }\n         archive.subStreamsInfo = subStreamsInfo;\n     }\n     \n-    private Folder readFolder(final ByteBuffer header) throws IOException {\n+    private Folder readFolder(final ByteBuffer byteBuffer) throws IOException {\n         final Folder folder = new Folder();\n-        final long numCoders = readUint64(header);\n-        final Coder[] coders = new Coder[(int)numCoders];\n-        long totalInStreams = 0L;\n-        long totalOutStreams = 0L;\n+        final Coder[] coders = new Coder[(int)readUint64(byteBuffer)];\n+        long totalInputStreams = 0L;\n+        long totalOutputStreams = 0L;\n         for (int i = 0; i < coders.length; ++i) {\n             coders[i] = new Coder();\n-            final int bits = getUnsignedByte(header);\n-            final int idSize = bits & 0xF;\n-            final boolean isSimple = (bits & 0x10) == 0x0;\n-            final boolean hasAttributes = (bits & 0x20) != 0x0;\n-            final boolean moreAlternativeMethods = (bits & 0x80) != 0x0;\n-            header.get(coders[i].decompressionMethodId = new byte[idSize]);\n-            if (isSimple) {\n+            final int unsignedByte = getUnsignedByte(byteBuffer);\n+            final int n = unsignedByte & 0xF;\n+            final boolean b = (unsignedByte & 0x10) == 0x0;\n+            final boolean b2 = (unsignedByte & 0x20) != 0x0;\n+            final boolean b3 = (unsignedByte & 0x80) != 0x0;\n+            byteBuffer.get(coders[i].decompressionMethodId = new byte[n]);\n+            if (b) {\n                 coders[i].numInStreams = 1L;\n                 coders[i].numOutStreams = 1L;\n             }\n             else {\n-                coders[i].numInStreams = readUint64(header);\n-                coders[i].numOutStreams = readUint64(header);\n+                coders[i].numInStreams = readUint64(byteBuffer);\n+                coders[i].numOutStreams = readUint64(byteBuffer);\n             }\n-            totalInStreams += coders[i].numInStreams;\n-            totalOutStreams += coders[i].numOutStreams;\n-            if (hasAttributes) {\n-                final long propertiesSize = readUint64(header);\n-                header.get(coders[i].properties = new byte[(int)propertiesSize]);\n+            totalInputStreams += coders[i].numInStreams;\n+            totalOutputStreams += coders[i].numOutStreams;\n+            if (b2) {\n+                byteBuffer.get(coders[i].properties = new byte[(int)readUint64(byteBuffer)]);\n             }\n-            if (moreAlternativeMethods) {\n+            if (b3) {\n                 throw new IOException(\"Alternative methods are unsupported, please report. The reference implementation doesn't support them either.\");\n             }\n         }\n         folder.coders = coders;\n-        folder.totalInputStreams = totalInStreams;\n-        folder.totalOutputStreams = totalOutStreams;\n-        if (totalOutStreams == 0L) {\n+        folder.totalInputStreams = totalInputStreams;\n+        folder.totalOutputStreams = totalOutputStreams;\n+        if (totalOutputStreams == 0L) {\n             throw new IOException(\"Total output streams can't be 0\");\n         }\n-        final long numBindPairs = totalOutStreams - 1L;\n-        final BindPair[] bindPairs = new BindPair[(int)numBindPairs];\n+        final long n2 = totalOutputStreams - 1L;\n+        final BindPair[] bindPairs = new BindPair[(int)n2];\n         for (int j = 0; j < bindPairs.length; ++j) {\n             bindPairs[j] = new BindPair();\n-            bindPairs[j].inIndex = readUint64(header);\n-            bindPairs[j].outIndex = readUint64(header);\n+            bindPairs[j].inIndex = readUint64(byteBuffer);\n+            bindPairs[j].outIndex = readUint64(byteBuffer);\n         }\n         folder.bindPairs = bindPairs;\n-        if (totalInStreams < numBindPairs) {\n+        if (totalInputStreams < n2) {\n             throw new IOException(\"Total input streams can't be less than the number of bind pairs\");\n         }\n-        final long numPackedStreams = totalInStreams - numBindPairs;\n-        final long[] packedStreams = new long[(int)numPackedStreams];\n-        if (numPackedStreams == 1L) {\n-            int k;\n-            for (k = 0; k < (int)totalInStreams && folder.findBindPairForInStream(k) >= 0; ++k) {}\n-            if (k == (int)totalInStreams) {\n+        final long n3 = totalInputStreams - n2;\n+        final long[] packedStreams = new long[(int)n3];\n+        if (n3 == 1L) {\n+            int n4;\n+            for (n4 = 0; n4 < (int)totalInputStreams && folder.findBindPairForInStream(n4) >= 0; ++n4) {}\n+            if (n4 == (int)totalInputStreams) {\n                 throw new IOException(\"Couldn't find stream's bind pair index\");\n             }\n-            packedStreams[0] = k;\n+            packedStreams[0] = n4;\n         }\n         else {\n-            for (int k = 0; k < (int)numPackedStreams; ++k) {\n-                packedStreams[k] = readUint64(header);\n+            for (int k = 0; k < (int)n3; ++k) {\n+                packedStreams[k] = readUint64(byteBuffer);\n             }\n         }\n         folder.packedStreams = packedStreams;\n         return folder;\n     }\n     \n-    private BitSet readAllOrBits(final ByteBuffer header, final int size) throws IOException {\n-        final int areAllDefined = getUnsignedByte(header);\n+    private BitSet readAllOrBits(final ByteBuffer byteBuffer, final int nbits) throws IOException {\n         BitSet bits;\n-        if (areAllDefined != 0) {\n-            bits = new BitSet(size);\n-            for (int i = 0; i < size; ++i) {\n+        if (getUnsignedByte(byteBuffer) != 0) {\n+            bits = new BitSet(nbits);\n+            for (int i = 0; i < nbits; ++i) {\n                 bits.set(i, true);\n             }\n         }\n         else {\n-            bits = this.readBits(header, size);\n+            bits = this.readBits(byteBuffer, nbits);\n         }\n         return bits;\n     }\n     \n-    private BitSet readBits(final ByteBuffer header, final int size) throws IOException {\n-        final BitSet bits = new BitSet(size);\n-        int mask = 0;\n-        int cache = 0;\n-        for (int i = 0; i < size; ++i) {\n-            if (mask == 0) {\n-                mask = 128;\n-                cache = getUnsignedByte(header);\n+    private BitSet readBits(final ByteBuffer byteBuffer, final int nbits) throws IOException {\n+        final BitSet set = new BitSet(nbits);\n+        int n = 0;\n+        int unsignedByte = 0;\n+        for (int i = 0; i < nbits; ++i) {\n+            if (n == 0) {\n+                n = 128;\n+                unsignedByte = getUnsignedByte(byteBuffer);\n             }\n-            bits.set(i, (cache & mask) != 0x0);\n-            mask >>>= 1;\n+            set.set(i, (unsignedByte & n) != 0x0);\n+            n >>>= 1;\n         }\n-        return bits;\n+        return set;\n     }\n     \n-    private void readFilesInfo(final ByteBuffer header, final Archive archive) throws IOException {\n-        final long numFiles = readUint64(header);\n-        final SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\n+    private void readFilesInfo(final ByteBuffer byteBuffer, final Archive archive) throws IOException {\n+        final SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)readUint64(byteBuffer)];\n         for (int i = 0; i < files.length; ++i) {\n             files[i] = new SevenZArchiveEntry();\n         }\n-        BitSet isEmptyStream = null;\n-        BitSet isEmptyFile = null;\n-        BitSet isAnti = null;\n+        BitSet bits = null;\n+        BitSet bits2 = null;\n+        BitSet bits3 = null;\n         while (true) {\n-            final int propertyType = getUnsignedByte(header);\n-            if (propertyType == 0) {\n-                int nonEmptyFileCounter = 0;\n-                int emptyFileCounter = 0;\n+            final int unsignedByte = getUnsignedByte(byteBuffer);\n+            if (unsignedByte == 0) {\n+                int bitIndex = 0;\n+                int n = 0;\n                 for (int j = 0; j < files.length; ++j) {\n-                    files[j].setHasStream(isEmptyStream == null || !isEmptyStream.get(j));\n+                    files[j].setHasStream(bits == null || !bits.get(j));\n                     if (files[j].hasStream()) {\n                         files[j].setDirectory(false);\n                         files[j].setAntiItem(false);\n-                        files[j].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\n-                        files[j].setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\n-                        files[j].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n-                        ++nonEmptyFileCounter;\n+                        files[j].setHasCrc(archive.subStreamsInfo.hasCrc.get(bitIndex));\n+                        files[j].setCrcValue(archive.subStreamsInfo.crcs[bitIndex]);\n+                        files[j].setSize(archive.subStreamsInfo.unpackSizes[bitIndex]);\n+                        ++bitIndex;\n                     }\n                     else {\n-                        files[j].setDirectory(isEmptyFile == null || !isEmptyFile.get(emptyFileCounter));\n-                        files[j].setAntiItem(isAnti != null && isAnti.get(emptyFileCounter));\n+                        files[j].setDirectory(bits2 == null || !bits2.get(n));\n+                        files[j].setAntiItem(bits3 != null && bits3.get(n));\n                         files[j].setHasCrc(false);\n                         files[j].setSize(0L);\n-                        ++emptyFileCounter;\n+                        ++n;\n                     }\n                 }\n                 archive.files = files;\n                 this.calculateStreamMap(archive);\n                 return;\n             }\n-            final long size = readUint64(header);\n-            switch (propertyType) {\n+            final long uint64 = readUint64(byteBuffer);\n+            switch (unsignedByte) {\n                 case 14: {\n-                    isEmptyStream = this.readBits(header, files.length);\n+                    bits = this.readBits(byteBuffer, files.length);\n                     continue;\n                 }\n                 case 15: {\n-                    if (isEmptyStream == null) {\n+                    if (bits == null) {\n                         throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n                     }\n-                    isEmptyFile = this.readBits(header, isEmptyStream.cardinality());\n+                    bits2 = this.readBits(byteBuffer, bits.cardinality());\n                     continue;\n                 }\n                 case 16: {\n-                    if (isEmptyStream == null) {\n+                    if (bits == null) {\n                         throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n                     }\n-                    isAnti = this.readBits(header, isEmptyStream.cardinality());\n+                    bits3 = this.readBits(byteBuffer, bits.cardinality());\n                     continue;\n                 }\n                 case 17: {\n-                    final int external = getUnsignedByte(header);\n-                    if (external != 0) {\n+                    if (getUnsignedByte(byteBuffer) != 0) {\n                         throw new IOException(\"Not implemented\");\n                     }\n-                    if ((size - 1L & 0x1L) != 0x0L) {\n+                    if ((uint64 - 1L & 0x1L) != 0x0L) {\n                         throw new IOException(\"File names length invalid\");\n                     }\n-                    final byte[] names = new byte[(int)(size - 1L)];\n-                    header.get(names);\n-                    int nextFile = 0;\n-                    int nextName = 0;\n-                    for (int k = 0; k < names.length; k += 2) {\n-                        if (names[k] == 0 && names[k + 1] == 0) {\n-                            files[nextFile++].setName(new String(names, nextName, k - nextName, \"UTF-16LE\"));\n-                            nextName = k + 2;\n+                    final byte[] array = new byte[(int)(uint64 - 1L)];\n+                    byteBuffer.get(array);\n+                    int n2 = 0;\n+                    int offset = 0;\n+                    for (int k = 0; k < array.length; k += 2) {\n+                        if (array[k] == 0 && array[k + 1] == 0) {\n+                            files[n2++].setName(new String(array, offset, k - offset, \"UTF-16LE\"));\n+                            offset = k + 2;\n                         }\n                     }\n-                    if (nextName != names.length || nextFile != files.length) {\n+                    if (offset != array.length || n2 != files.length) {\n                         throw new IOException(\"Error parsing file names\");\n                     }\n                     continue;\n                 }\n                 case 18: {\n-                    final BitSet timesDefined = this.readAllOrBits(header, files.length);\n-                    final int external2 = getUnsignedByte(header);\n-                    if (external2 != 0) {\n+                    final BitSet allOrBits = this.readAllOrBits(byteBuffer, files.length);\n+                    if (getUnsignedByte(byteBuffer) != 0) {\n                         throw new IOException(\"Unimplemented\");\n                     }\n                     for (int l = 0; l < files.length; ++l) {\n-                        files[l].setHasCreationDate(timesDefined.get(l));\n+                        files[l].setHasCreationDate(allOrBits.get(l));\n                         if (files[l].getHasCreationDate()) {\n-                            files[l].setCreationDate(header.getLong());\n+                            files[l].setCreationDate(byteBuffer.getLong());\n                         }\n                     }\n                     continue;\n                 }\n                 case 19: {\n-                    final BitSet timesDefined = this.readAllOrBits(header, files.length);\n-                    final int external2 = getUnsignedByte(header);\n-                    if (external2 != 0) {\n+                    final BitSet allOrBits2 = this.readAllOrBits(byteBuffer, files.length);\n+                    if (getUnsignedByte(byteBuffer) != 0) {\n                         throw new IOException(\"Unimplemented\");\n                     }\n-                    for (int l = 0; l < files.length; ++l) {\n-                        files[l].setHasAccessDate(timesDefined.get(l));\n-                        if (files[l].getHasAccessDate()) {\n-                            files[l].setAccessDate(header.getLong());\n+                    for (int bitIndex2 = 0; bitIndex2 < files.length; ++bitIndex2) {\n+                        files[bitIndex2].setHasAccessDate(allOrBits2.get(bitIndex2));\n+                        if (files[bitIndex2].getHasAccessDate()) {\n+                            files[bitIndex2].setAccessDate(byteBuffer.getLong());\n                         }\n                     }\n                     continue;\n                 }\n                 case 20: {\n-                    final BitSet timesDefined = this.readAllOrBits(header, files.length);\n-                    final int external2 = getUnsignedByte(header);\n-                    if (external2 != 0) {\n+                    final BitSet allOrBits3 = this.readAllOrBits(byteBuffer, files.length);\n+                    if (getUnsignedByte(byteBuffer) != 0) {\n                         throw new IOException(\"Unimplemented\");\n                     }\n-                    for (int l = 0; l < files.length; ++l) {\n-                        files[l].setHasLastModifiedDate(timesDefined.get(l));\n-                        if (files[l].getHasLastModifiedDate()) {\n-                            files[l].setLastModifiedDate(header.getLong());\n+                    for (int bitIndex3 = 0; bitIndex3 < files.length; ++bitIndex3) {\n+                        files[bitIndex3].setHasLastModifiedDate(allOrBits3.get(bitIndex3));\n+                        if (files[bitIndex3].getHasLastModifiedDate()) {\n+                            files[bitIndex3].setLastModifiedDate(byteBuffer.getLong());\n                         }\n                     }\n                     continue;\n                 }\n                 case 21: {\n-                    final BitSet attributesDefined = this.readAllOrBits(header, files.length);\n-                    final int external2 = getUnsignedByte(header);\n-                    if (external2 != 0) {\n+                    final BitSet allOrBits4 = this.readAllOrBits(byteBuffer, files.length);\n+                    if (getUnsignedByte(byteBuffer) != 0) {\n                         throw new IOException(\"Unimplemented\");\n                     }\n-                    for (int l = 0; l < files.length; ++l) {\n-                        files[l].setHasWindowsAttributes(attributesDefined.get(l));\n-                        if (files[l].getHasWindowsAttributes()) {\n-                            files[l].setWindowsAttributes(header.getInt());\n+                    for (int bitIndex4 = 0; bitIndex4 < files.length; ++bitIndex4) {\n+                        files[bitIndex4].setHasWindowsAttributes(allOrBits4.get(bitIndex4));\n+                        if (files[bitIndex4].getHasWindowsAttributes()) {\n+                            files[bitIndex4].setWindowsAttributes(byteBuffer.getInt());\n                         }\n                     }\n                     continue;\n                 }\n                 case 24: {\n                     throw new IOException(\"kStartPos is unsupported, please report\");\n                 }\n                 case 25: {\n-                    if (skipBytesFully(header, size) < size) {\n+                    if (skipBytesFully(byteBuffer, uint64) < uint64) {\n                         throw new IOException(\"Incomplete kDummy property\");\n                     }\n                     continue;\n                 }\n                 default: {\n-                    if (skipBytesFully(header, size) < size) {\n-                        throw new IOException(\"Incomplete property of type \" + propertyType);\n+                    if (skipBytesFully(byteBuffer, uint64) < uint64) {\n+                        throw new IOException(\"Incomplete property of type \" + unsignedByte);\n                     }\n                     continue;\n                 }\n             }\n         }\n     }\n     \n     private void calculateStreamMap(final Archive archive) throws IOException {\n         final StreamMap streamMap = new StreamMap();\n-        int nextFolderPackStreamIndex = 0;\n-        final int numFolders = (archive.folders != null) ? archive.folders.length : 0;\n-        streamMap.folderFirstPackStreamIndex = new int[numFolders];\n-        for (int i = 0; i < numFolders; ++i) {\n-            streamMap.folderFirstPackStreamIndex[i] = nextFolderPackStreamIndex;\n-            nextFolderPackStreamIndex += archive.folders[i].packedStreams.length;\n-        }\n-        long nextPackStreamOffset = 0L;\n-        final int numPackSizes = (archive.packSizes != null) ? archive.packSizes.length : 0;\n-        streamMap.packStreamOffsets = new long[numPackSizes];\n-        for (int j = 0; j < numPackSizes; ++j) {\n-            streamMap.packStreamOffsets[j] = nextPackStreamOffset;\n-            nextPackStreamOffset += archive.packSizes[j];\n+        int n = 0;\n+        final int n2 = (archive.folders != null) ? archive.folders.length : 0;\n+        streamMap.folderFirstPackStreamIndex = new int[n2];\n+        for (int i = 0; i < n2; ++i) {\n+            streamMap.folderFirstPackStreamIndex[i] = n;\n+            n += archive.folders[i].packedStreams.length;\n+        }\n+        long n3 = 0L;\n+        final int n4 = (archive.packSizes != null) ? archive.packSizes.length : 0;\n+        streamMap.packStreamOffsets = new long[n4];\n+        for (int j = 0; j < n4; ++j) {\n+            streamMap.packStreamOffsets[j] = n3;\n+            n3 += archive.packSizes[j];\n         }\n-        streamMap.folderFirstFileIndex = new int[numFolders];\n+        streamMap.folderFirstFileIndex = new int[n2];\n         streamMap.fileFolderIndex = new int[archive.files.length];\n-        int nextFolderIndex = 0;\n-        int nextFolderUnpackStreamIndex = 0;\n-        for (int k = 0; k < archive.files.length; ++k) {\n-            if (!archive.files[k].hasStream() && nextFolderUnpackStreamIndex == 0) {\n-                streamMap.fileFolderIndex[k] = -1;\n+        int k = 0;\n+        int n5 = 0;\n+        for (int l = 0; l < archive.files.length; ++l) {\n+            if (!archive.files[l].hasStream() && n5 == 0) {\n+                streamMap.fileFolderIndex[l] = -1;\n             }\n             else {\n-                if (nextFolderUnpackStreamIndex == 0) {\n-                    while (nextFolderIndex < archive.folders.length) {\n-                        streamMap.folderFirstFileIndex[nextFolderIndex] = k;\n-                        if (archive.folders[nextFolderIndex].numUnpackSubStreams > 0) {\n+                if (n5 == 0) {\n+                    while (k < archive.folders.length) {\n+                        streamMap.folderFirstFileIndex[k] = l;\n+                        if (archive.folders[k].numUnpackSubStreams > 0) {\n                             break;\n                         }\n-                        ++nextFolderIndex;\n+                        ++k;\n                     }\n-                    if (nextFolderIndex >= archive.folders.length) {\n+                    if (k >= archive.folders.length) {\n                         throw new IOException(\"Too few folders in archive\");\n                     }\n                 }\n-                streamMap.fileFolderIndex[k] = nextFolderIndex;\n-                if (archive.files[k].hasStream()) {\n-                    if (++nextFolderUnpackStreamIndex >= archive.folders[nextFolderIndex].numUnpackSubStreams) {\n-                        ++nextFolderIndex;\n-                        nextFolderUnpackStreamIndex = 0;\n+                streamMap.fileFolderIndex[l] = k;\n+                if (archive.files[l].hasStream()) {\n+                    if (++n5 >= archive.folders[k].numUnpackSubStreams) {\n+                        ++k;\n+                        n5 = 0;\n                     }\n                 }\n             }\n         }\n         archive.streamMap = streamMap;\n     }\n     \n     private void buildDecodingStream() throws IOException {\n-        final int folderIndex = this.archive.streamMap.fileFolderIndex[this.currentEntryIndex];\n-        if (folderIndex < 0) {\n+        final int currentFolderIndex = this.archive.streamMap.fileFolderIndex[this.currentEntryIndex];\n+        if (currentFolderIndex < 0) {\n             this.deferredBlockStreams.clear();\n             return;\n         }\n-        final SevenZArchiveEntry file = this.archive.files[this.currentEntryIndex];\n-        if (this.currentFolderIndex == folderIndex) {\n-            file.setContentMethods(this.archive.files[this.currentEntryIndex - 1].getContentMethods());\n+        final SevenZArchiveEntry sevenZArchiveEntry = this.archive.files[this.currentEntryIndex];\n+        if (this.currentFolderIndex == currentFolderIndex) {\n+            sevenZArchiveEntry.setContentMethods(this.archive.files[this.currentEntryIndex - 1].getContentMethods());\n         }\n         else {\n-            this.currentFolderIndex = folderIndex;\n+            this.currentFolderIndex = currentFolderIndex;\n             this.deferredBlockStreams.clear();\n             if (this.currentFolderInputStream != null) {\n                 this.currentFolderInputStream.close();\n                 this.currentFolderInputStream = null;\n             }\n-            final Folder folder = this.archive.folders[folderIndex];\n-            final int firstPackStreamIndex = this.archive.streamMap.folderFirstPackStreamIndex[folderIndex];\n-            final long folderOffset = 32L + this.archive.packPos + this.archive.streamMap.packStreamOffsets[firstPackStreamIndex];\n-            this.currentFolderInputStream = this.buildDecoderStack(folder, folderOffset, firstPackStreamIndex, file);\n-        }\n-        InputStream fileStream = (InputStream)new BoundedInputStream(this.currentFolderInputStream, file.getSize());\n-        if (file.getHasCrc()) {\n-            fileStream = (InputStream)new CRC32VerifyingInputStream(fileStream, file.getSize(), file.getCrcValue());\n-        }\n-        this.deferredBlockStreams.add(fileStream);\n-    }\n-    \n-    private InputStream buildDecoderStack(final Folder folder, final long folderOffset, final int firstPackStreamIndex, final SevenZArchiveEntry entry) throws IOException {\n-        this.channel.position(folderOffset);\n-        InputStream inputStreamStack = new BufferedInputStream((InputStream)new BoundedSeekableByteChannelInputStream(this.channel, this.archive.packSizes[firstPackStreamIndex]));\n-        final LinkedList<SevenZMethodConfiguration> methods = new LinkedList<SevenZMethodConfiguration>();\n+            final Folder folder = this.archive.folders[currentFolderIndex];\n+            final int n = this.archive.streamMap.folderFirstPackStreamIndex[currentFolderIndex];\n+            this.currentFolderInputStream = this.buildDecoderStack(folder, 32L + this.archive.packPos + this.archive.streamMap.packStreamOffsets[n], n, sevenZArchiveEntry);\n+        }\n+        Object e = new BoundedInputStream(this.currentFolderInputStream, sevenZArchiveEntry.getSize());\n+        if (sevenZArchiveEntry.getHasCrc()) {\n+            e = new CRC32VerifyingInputStream((InputStream)e, sevenZArchiveEntry.getSize(), sevenZArchiveEntry.getCrcValue());\n+        }\n+        this.deferredBlockStreams.add((InputStream)e);\n+    }\n+    \n+    private InputStream buildDecoderStack(final Folder folder, final long n, final int n2, final SevenZArchiveEntry sevenZArchiveEntry) throws IOException {\n+        this.channel.position(n);\n+        InputStream addDecoder = new BufferedInputStream((InputStream)new BoundedSeekableByteChannelInputStream(this.channel, this.archive.packSizes[n2]));\n+        final LinkedList contentMethods = new LinkedList();\n         for (final Coder coder : folder.getOrderedCoders()) {\n             if (coder.numInStreams != 1L || coder.numOutStreams != 1L) {\n                 throw new IOException(\"Multi input/output stream coders are not yet supported\");\n             }\n-            final SevenZMethod method = SevenZMethod.byId(coder.decompressionMethodId);\n-            inputStreamStack = Coders.addDecoder(this.fileName, inputStreamStack, folder.getUnpackSizeForCoder(coder), coder, this.password);\n-            methods.addFirst(new SevenZMethodConfiguration(method, Coders.findByMethod(method).getOptionsFromCoder(coder, inputStreamStack)));\n+            final SevenZMethod byId = SevenZMethod.byId(coder.decompressionMethodId);\n+            addDecoder = Coders.addDecoder(this.fileName, addDecoder, folder.getUnpackSizeForCoder(coder), coder, this.password);\n+            contentMethods.addFirst(new SevenZMethodConfiguration(byId, Coders.findByMethod(byId).getOptionsFromCoder(coder, addDecoder)));\n         }\n-        entry.setContentMethods((Iterable)methods);\n+        sevenZArchiveEntry.setContentMethods((Iterable)contentMethods);\n         if (folder.hasCrc) {\n-            return (InputStream)new CRC32VerifyingInputStream(inputStreamStack, folder.getUnpackSize(), folder.crc);\n+            return (InputStream)new CRC32VerifyingInputStream(addDecoder, folder.getUnpackSize(), folder.crc);\n         }\n-        return inputStreamStack;\n+        return addDecoder;\n     }\n     \n     public int read() throws IOException {\n         return this.getCurrentStream().read();\n     }\n     \n     private InputStream getCurrentStream() throws IOException {\n         if (this.archive.files[this.currentEntryIndex].getSize() == 0L) {\n             return new ByteArrayInputStream(new byte[0]);\n         }\n         if (this.deferredBlockStreams.isEmpty()) {\n             throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n         }\n         while (this.deferredBlockStreams.size() > 1) {\n-            try (final InputStream stream = (InputStream)this.deferredBlockStreams.remove(0)) {\n-                IOUtils.skip(stream, Long.MAX_VALUE);\n-                if (stream == null) {\n+            try (final InputStream inputStream = (InputStream)this.deferredBlockStreams.remove(0)) {\n+                IOUtils.skip(inputStream, Long.MAX_VALUE);\n+                if (inputStream == null) {\n                     continue;\n                 }\n             }\n         }\n         return this.deferredBlockStreams.get(0);\n     }\n     \n-    public int read(final byte[] b) throws IOException {\n-        return this.read(b, 0, b.length);\n+    public int read(final byte[] array) throws IOException {\n+        return this.read(array, 0, array.length);\n     }\n     \n     public int read(final byte[] b, final int off, final int len) throws IOException {\n         return this.getCurrentStream().read(b, off, len);\n     }\n     \n-    private static long readUint64(final ByteBuffer in) throws IOException {\n-        final long firstByte = (long)getUnsignedByte(in);\n-        int mask = 128;\n-        long value = 0L;\n+    private static long readUint64(final ByteBuffer byteBuffer) throws IOException {\n+        final long n = (long)getUnsignedByte(byteBuffer);\n+        int n2 = 128;\n+        long n3 = 0L;\n         for (int i = 0; i < 8; ++i) {\n-            if ((firstByte & (long)mask) == 0x0L) {\n-                return value | (firstByte & (long)(mask - 1)) << 8 * i;\n+            if ((n & (long)n2) == 0x0L) {\n+                return n3 | (n & (long)(n2 - 1)) << 8 * i;\n             }\n-            final long nextByte = (long)getUnsignedByte(in);\n-            value |= nextByte << 8 * i;\n-            mask >>>= 1;\n+            n3 |= (long)getUnsignedByte(byteBuffer) << 8 * i;\n+            n2 >>>= 1;\n         }\n-        return value;\n+        return n3;\n     }\n     \n-    private static int getUnsignedByte(final ByteBuffer buf) {\n-        return buf.get() & 0xFF;\n+    private static int getUnsignedByte(final ByteBuffer byteBuffer) {\n+        return byteBuffer.get() & 0xFF;\n     }\n     \n-    public static boolean matches(final byte[] signature, final int length) {\n-        if (length < SevenZFile.sevenZSignature.length) {\n+    public static boolean matches(final byte[] array, final int n) {\n+        if (n < SevenZFile.sevenZSignature.length) {\n             return false;\n         }\n         for (int i = 0; i < SevenZFile.sevenZSignature.length; ++i) {\n-            if (signature[i] != SevenZFile.sevenZSignature[i]) {\n+            if (array[i] != SevenZFile.sevenZSignature[i]) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    private static long skipBytesFully(final ByteBuffer input, long bytesToSkip) throws IOException {\n-        if (bytesToSkip < 1L) {\n+    private static long skipBytesFully(final ByteBuffer byteBuffer, long n) throws IOException {\n+        if (n < 1L) {\n             return 0L;\n         }\n-        final int current = input.position();\n-        final int maxSkip = input.remaining();\n-        if (maxSkip < bytesToSkip) {\n-            bytesToSkip = maxSkip;\n-        }\n-        input.position(current + (int)bytesToSkip);\n-        return bytesToSkip;\n+        final int position = byteBuffer.position();\n+        final int remaining = byteBuffer.remaining();\n+        if (remaining < n) {\n+            n = remaining;\n+        }\n+        byteBuffer.position(position + (int)n);\n+        return n;\n     }\n     \n-    private void readFully(final ByteBuffer buf) throws IOException {\n-        buf.rewind();\n-        IOUtils.readFully((ReadableByteChannel)this.channel, buf);\n-        buf.flip();\n+    private void readFully(final ByteBuffer byteBuffer) throws IOException {\n+        byteBuffer.rewind();\n+        IOUtils.readFully((ReadableByteChannel)this.channel, byteBuffer);\n+        byteBuffer.flip();\n     }\n     \n     @Override\n     public String toString() {\n         return this.archive.toString();\n     }\n     \n"}]}
