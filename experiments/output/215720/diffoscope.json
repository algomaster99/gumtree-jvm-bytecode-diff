{"diffoscope-json-version": 1, "source1": "first/Pass3aVerifier.class", "source2": "second/Pass3aVerifier.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -19,15 +19,14 @@\n import org.apache.bcel.classfile.CodeException;\n import org.apache.bcel.classfile.LocalVariable;\n import org.apache.bcel.classfile.Attribute;\n import org.apache.bcel.classfile.LineNumber;\n import org.apache.bcel.classfile.LineNumberTable;\n import org.apache.bcel.classfile.LocalVariableTable;\n import org.apache.bcel.classfile.Method;\n-import org.apache.bcel.classfile.JavaClass;\n import org.apache.bcel.verifier.exc.AssertionViolatedException;\n import org.apache.bcel.verifier.exc.StaticCodeConstraintException;\n import org.apache.bcel.verifier.exc.ClassConstraintException;\n import org.apache.bcel.verifier.exc.InvalidMethodException;\n import org.apache.bcel.Repository;\n import org.apache.bcel.verifier.VerificationResult;\n import org.apache.bcel.classfile.Code;\n@@ -38,183 +37,173 @@\n public final class Pass3aVerifier extends PassVerifier\n {\n     private final Verifier myOwner;\n     private final int methodNo;\n     private InstructionList instructionList;\n     private Code code;\n     \n-    public Pass3aVerifier(final Verifier owner, final int methodNo) {\n-        this.myOwner = owner;\n+    public Pass3aVerifier(final Verifier myOwner, final int methodNo) {\n+        this.myOwner = myOwner;\n         this.methodNo = methodNo;\n     }\n     \n     public VerificationResult do_verify() {\n         try {\n             if (!this.myOwner.doPass2().equals((Object)VerificationResult.VR_OK)) {\n                 return VerificationResult.VR_NOTYET;\n             }\n-            final JavaClass jc = Repository.lookupClass(this.myOwner.getClassName());\n-            final Method[] methods = jc.getMethods();\n+            final Method[] methods = Repository.lookupClass(this.myOwner.getClassName()).getMethods();\n             if (this.methodNo >= methods.length) {\n                 throw new InvalidMethodException(\"METHOD DOES NOT EXIST!\");\n             }\n-            final Method method = methods[this.methodNo];\n-            this.code = method.getCode();\n-            if (method.isAbstract() || method.isNative()) {\n+            final Method obj = methods[this.methodNo];\n+            this.code = obj.getCode();\n+            if (obj.isAbstract() || obj.isNative()) {\n                 return VerificationResult.VR_OK;\n             }\n             try {\n-                this.instructionList = new InstructionList(method.getCode().getCode());\n+                this.instructionList = new InstructionList(obj.getCode().getCode());\n             }\n-            catch (final RuntimeException re) {\n-                return new VerificationResult(2, \"Bad bytecode in the code array of the Code attribute of method '\" + method + \"'.\");\n+            catch (final RuntimeException ex) {\n+                return new VerificationResult(2, \"Bad bytecode in the code array of the Code attribute of method '\" + obj + \"'.\");\n             }\n             this.instructionList.setPositions(true);\n-            VerificationResult vr = VerificationResult.VR_OK;\n+            VerificationResult vr_OK = VerificationResult.VR_OK;\n             try {\n                 this.delayedPass2Checks();\n             }\n-            catch (final ClassConstraintException cce) {\n-                vr = new VerificationResult(2, cce.getMessage());\n-                return vr;\n+            catch (final ClassConstraintException ex2) {\n+                return new VerificationResult(2, ex2.getMessage());\n             }\n             try {\n                 this.pass3StaticInstructionChecks();\n                 this.pass3StaticInstructionOperandsChecks();\n             }\n-            catch (final StaticCodeConstraintException scce) {\n-                vr = new VerificationResult(2, scce.getMessage());\n+            catch (final StaticCodeConstraintException ex3) {\n+                vr_OK = new VerificationResult(2, ex3.getMessage());\n             }\n-            catch (final ClassCastException cce2) {\n-                vr = new VerificationResult(2, \"Class Cast Exception: \" + cce2.getMessage());\n+            catch (final ClassCastException ex4) {\n+                vr_OK = new VerificationResult(2, \"Class Cast Exception: \" + ex4.getMessage());\n             }\n-            return vr;\n+            return vr_OK;\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj2) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj2, (Throwable)obj2);\n         }\n     }\n     \n     private void delayedPass2Checks() {\n         final int[] instructionPositions = this.instructionList.getInstructionPositions();\n-        final int codeLength = this.code.getCode().length;\n-        final LineNumberTable lnt = this.code.getLineNumberTable();\n-        if (lnt != null) {\n-            final LineNumber[] lineNumbers = lnt.getLineNumberTable();\n-            final IntList offsets = new IntList();\n-            final LineNumber[] array = lineNumbers;\n+        final int length = this.code.getCode().length;\n+        final LineNumberTable lineNumberTable = this.code.getLineNumberTable();\n+        if (lineNumberTable != null) {\n+            final LineNumber[] lineNumberTable2 = lineNumberTable.getLineNumberTable();\n+            final IntList list = new IntList();\n+            final LineNumber[] array = lineNumberTable2;\n             final int length2 = array.length;\n             int i = 0;\n         Label_0056:\n             while (i < length2) {\n                 final LineNumber lineNumber = array[i];\n-                for (final int instructionPosition : instructionPositions) {\n-                    final int offset = lineNumber.getStartPC();\n-                    if (instructionPosition == offset) {\n-                        if (offsets.contains(offset)) {\n-                            this.addMessage(\"LineNumberTable attribute '\" + this.code.getLineNumberTable() + \"' refers to the same code offset ('\" + offset + \"') more than once which is violating the semantics [but is sometimes produced by IBM's 'jikes' compiler].\");\n+                for (final int n : instructionPositions) {\n+                    final int startPC = lineNumber.getStartPC();\n+                    if (n == startPC) {\n+                        if (list.contains(startPC)) {\n+                            this.addMessage(\"LineNumberTable attribute '\" + this.code.getLineNumberTable() + \"' refers to the same code offset ('\" + startPC + \"') more than once which is violating the semantics [but is sometimes produced by IBM's 'jikes' compiler].\");\n                         }\n                         else {\n-                            offsets.add(offset);\n+                            list.add(startPC);\n                         }\n                         ++i;\n                         continue Label_0056;\n                     }\n                 }\n                 throw new ClassConstraintException(\"Code attribute '\" + this.code + \"' has a LineNumberTable attribute '\" + this.code.getLineNumberTable() + \"' referring to a code offset ('\" + lineNumber.getStartPC() + \"') that does not exist.\");\n             }\n         }\n-        final Attribute[] attributes;\n-        final Attribute[] atts = attributes = this.code.getAttributes();\n-        for (final Attribute att : attributes) {\n-            if (att instanceof LocalVariableTable) {\n-                final LocalVariableTable lvt = (LocalVariableTable)att;\n-                final LocalVariable[] localVariableTable;\n-                final LocalVariable[] localVariables = localVariableTable = lvt.getLocalVariableTable();\n-                for (final LocalVariable localVariable : localVariableTable) {\n-                    final int startpc = localVariable.getStartPC();\n-                    final int length = localVariable.getLength();\n-                    if (!contains(instructionPositions, startpc)) {\n-                        throw new ClassConstraintException(\"Code attribute '\" + this.code + \"' has a LocalVariableTable attribute '\" + this.code.getLocalVariableTable() + \"' referring to a code offset ('\" + startpc + \"') that does not exist.\");\n+        for (final Attribute attribute : this.code.getAttributes()) {\n+            if (attribute instanceof LocalVariableTable) {\n+                for (final LocalVariable localVariable : ((LocalVariableTable)attribute).getLocalVariableTable()) {\n+                    final int startPC2 = localVariable.getStartPC();\n+                    final int length6 = localVariable.getLength();\n+                    if (!contains(instructionPositions, startPC2)) {\n+                        throw new ClassConstraintException(\"Code attribute '\" + this.code + \"' has a LocalVariableTable attribute '\" + this.code.getLocalVariableTable() + \"' referring to a code offset ('\" + startPC2 + \"') that does not exist.\");\n                     }\n-                    if (!contains(instructionPositions, startpc + length) && startpc + length != codeLength) {\n-                        throw new ClassConstraintException(\"Code attribute '\" + this.code + \"' has a LocalVariableTable attribute '\" + this.code.getLocalVariableTable() + \"' referring to a code offset start_pc+length ('\" + (startpc + length) + \"') that does not exist.\");\n+                    if (!contains(instructionPositions, startPC2 + length6) && startPC2 + length6 != length) {\n+                        throw new ClassConstraintException(\"Code attribute '\" + this.code + \"' has a LocalVariableTable attribute '\" + this.code.getLocalVariableTable() + \"' referring to a code offset start_pc+length ('\" + (startPC2 + length6) + \"') that does not exist.\");\n                     }\n                 }\n             }\n         }\n-        final CodeException[] exceptionTable2;\n-        final CodeException[] exceptionTable = exceptionTable2 = this.code.getExceptionTable();\n-        for (final CodeException element : exceptionTable2) {\n-            final int startpc2 = element.getStartPC();\n-            final int endpc = element.getEndPC();\n-            final int handlerpc = element.getHandlerPC();\n-            if (startpc2 >= endpc) {\n-                throw new ClassConstraintException(\"Code attribute '\" + this.code + \"' has an exception_table entry '\" + element + \"' that has its start_pc ('\" + startpc2 + \"') not smaller than its end_pc ('\" + endpc + \"').\");\n+        for (final CodeException ex : this.code.getExceptionTable()) {\n+            final int startPC3 = ex.getStartPC();\n+            final int endPC = ex.getEndPC();\n+            final int handlerPC = ex.getHandlerPC();\n+            if (startPC3 >= endPC) {\n+                throw new ClassConstraintException(\"Code attribute '\" + this.code + \"' has an exception_table entry '\" + ex + \"' that has its start_pc ('\" + startPC3 + \"') not smaller than its end_pc ('\" + endPC + \"').\");\n             }\n-            if (!contains(instructionPositions, startpc2)) {\n-                throw new ClassConstraintException(\"Code attribute '\" + this.code + \"' has an exception_table entry '\" + element + \"' that has a non-existant bytecode offset as its start_pc ('\" + startpc2 + \"').\");\n+            if (!contains(instructionPositions, startPC3)) {\n+                throw new ClassConstraintException(\"Code attribute '\" + this.code + \"' has an exception_table entry '\" + ex + \"' that has a non-existant bytecode offset as its start_pc ('\" + startPC3 + \"').\");\n             }\n-            if (!contains(instructionPositions, endpc) && endpc != codeLength) {\n-                throw new ClassConstraintException(\"Code attribute '\" + this.code + \"' has an exception_table entry '\" + element + \"' that has a non-existant bytecode offset as its end_pc ('\" + startpc2 + \"') [that is also not equal to code_length ('\" + codeLength + \"')].\");\n+            if (!contains(instructionPositions, endPC) && endPC != length) {\n+                throw new ClassConstraintException(\"Code attribute '\" + this.code + \"' has an exception_table entry '\" + ex + \"' that has a non-existant bytecode offset as its end_pc ('\" + startPC3 + \"') [that is also not equal to code_length ('\" + length + \"')].\");\n             }\n-            if (!contains(instructionPositions, handlerpc)) {\n-                throw new ClassConstraintException(\"Code attribute '\" + this.code + \"' has an exception_table entry '\" + element + \"' that has a non-existant bytecode offset as its handler_pc ('\" + handlerpc + \"').\");\n+            if (!contains(instructionPositions, handlerPC)) {\n+                throw new ClassConstraintException(\"Code attribute '\" + this.code + \"' has an exception_table entry '\" + ex + \"' that has a non-existant bytecode offset as its handler_pc ('\" + handlerPC + \"').\");\n             }\n         }\n     }\n     \n     private void pass3StaticInstructionChecks() {\n         if (this.code.getCode().length >= 65536) {\n             throw new StaticCodeInstructionConstraintException(\"Code array in code attribute '\" + this.code + \"' too big: must be smaller than \" + 65536 + \"65536 bytes.\");\n         }\n-        for (InstructionHandle ih = this.instructionList.getStart(); ih != null; ih = ih.getNext()) {\n-            final Instruction i = ih.getInstruction();\n-            if (i instanceof IMPDEP1) {\n+        for (InstructionHandle instructionHandle = this.instructionList.getStart(); instructionHandle != null; instructionHandle = instructionHandle.getNext()) {\n+            final Instruction instruction = instructionHandle.getInstruction();\n+            if (instruction instanceof IMPDEP1) {\n                 throw new StaticCodeInstructionConstraintException(\"IMPDEP1 must not be in the code, it is an illegal instruction for _internal_ JVM use!\");\n             }\n-            if (i instanceof IMPDEP2) {\n+            if (instruction instanceof IMPDEP2) {\n                 throw new StaticCodeInstructionConstraintException(\"IMPDEP2 must not be in the code, it is an illegal instruction for _internal_ JVM use!\");\n             }\n-            if (i instanceof BREAKPOINT) {\n+            if (instruction instanceof BREAKPOINT) {\n                 throw new StaticCodeInstructionConstraintException(\"BREAKPOINT must not be in the code, it is an illegal instruction for _internal_ JVM use!\");\n             }\n         }\n-        final Instruction last = this.instructionList.getEnd().getInstruction();\n-        if (!(last instanceof ReturnInstruction) && !(last instanceof RET) && !(last instanceof GotoInstruction) && !(last instanceof ATHROW)) {\n+        final Instruction instruction2 = this.instructionList.getEnd().getInstruction();\n+        if (!(instruction2 instanceof ReturnInstruction) && !(instruction2 instanceof RET) && !(instruction2 instanceof GotoInstruction) && !(instruction2 instanceof ATHROW)) {\n             throw new StaticCodeInstructionConstraintException(\"Execution must not fall off the bottom of the code array. This constraint is enforced statically as some existing verifiers do - so it may be a false alarm if the last instruction is not reachable.\");\n         }\n     }\n     \n     private void pass3StaticInstructionOperandsChecks() {\n         try {\n-            final ConstantPoolGen cpg = new ConstantPoolGen(Repository.lookupClass(this.myOwner.getClassName()).getConstantPool());\n-            final Pass3aVerifier.InstOperandConstraintVisitor v = new Pass3aVerifier.InstOperandConstraintVisitor(this, cpg);\n-            for (InstructionHandle ih = this.instructionList.getStart(); ih != null; ih = ih.getNext()) {\n-                final Instruction i = ih.getInstruction();\n-                if (i instanceof JsrInstruction) {\n-                    final InstructionHandle target = ((JsrInstruction)i).getTarget();\n+            final Pass3aVerifier.InstOperandConstraintVisitor instOperandConstraintVisitor = new Pass3aVerifier.InstOperandConstraintVisitor(this, new ConstantPoolGen(Repository.lookupClass(this.myOwner.getClassName()).getConstantPool()));\n+            for (InstructionHandle instructionHandle = this.instructionList.getStart(); instructionHandle != null; instructionHandle = instructionHandle.getNext()) {\n+                final Instruction instruction = instructionHandle.getInstruction();\n+                if (instruction instanceof JsrInstruction) {\n+                    final InstructionHandle target = ((JsrInstruction)instruction).getTarget();\n                     if (target == this.instructionList.getStart()) {\n-                        throw new StaticCodeInstructionOperandConstraintException(\"Due to JustIce's clear definition of subroutines, no JSR or JSR_W may have a top-level instruction (such as the very first instruction, which is targeted by instruction '\" + ih + \"' as its target.\");\n+                        throw new StaticCodeInstructionOperandConstraintException(\"Due to JustIce's clear definition of subroutines, no JSR or JSR_W may have a top-level instruction (such as the very first instruction, which is targeted by instruction '\" + instructionHandle + \"' as its target.\");\n                     }\n                     if (!(target.getInstruction() instanceof ASTORE)) {\n-                        throw new StaticCodeInstructionOperandConstraintException(\"Due to JustIce's clear definition of subroutines, no JSR or JSR_W may target anything else than an ASTORE instruction. Instruction '\" + ih + \"' targets '\" + target + \"'.\");\n+                        throw new StaticCodeInstructionOperandConstraintException(\"Due to JustIce's clear definition of subroutines, no JSR or JSR_W may target anything else than an ASTORE instruction. Instruction '\" + instructionHandle + \"' targets '\" + target + \"'.\");\n                     }\n                 }\n-                ih.accept((Visitor)v);\n+                instructionHandle.accept((Visitor)instOperandConstraintVisitor);\n             }\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj, (Throwable)obj);\n         }\n     }\n     \n-    private static boolean contains(final int[] ints, final int i) {\n-        for (final int k : ints) {\n-            if (k == i) {\n+    private static boolean contains(final int[] array, final int n) {\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            if (array[i] == n) {\n                 return true;\n             }\n         }\n         return false;\n     }\n     \n     public int getMethodNo() {\n"}]}
