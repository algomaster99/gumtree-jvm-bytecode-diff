{"diffoscope-json-version": 1, "source1": "first/AES256SHA256Decoder.class", "source2": "second/AES256SHA256Decoder.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -8,74 +8,73 @@\n import java.nio.CharBuffer;\n import java.nio.charset.StandardCharsets;\n import java.security.NoSuchAlgorithmException;\n import java.security.MessageDigest;\n \n class AES256SHA256Decoder extends AbstractCoder\n {\n-    static byte[] sha256Password(final byte[] password, final int numCyclesPower, final byte[] salt) {\n-        MessageDigest digest;\n+    static byte[] sha256Password(final byte[] input, final int n, final byte[] input2) {\n+        MessageDigest instance;\n         try {\n-            digest = MessageDigest.getInstance(\"SHA-256\");\n+            instance = MessageDigest.getInstance(\"SHA-256\");\n         }\n-        catch (final NoSuchAlgorithmException noSuchAlgorithmException) {\n-            throw new IllegalStateException(\"SHA-256 is unsupported by your Java implementation\", noSuchAlgorithmException);\n+        catch (final NoSuchAlgorithmException cause) {\n+            throw new IllegalStateException(\"SHA-256 is unsupported by your Java implementation\", cause);\n         }\n-        final byte[] extra = new byte[8];\n-        for (long j = 0L; j < 1L << numCyclesPower; ++j) {\n-            digest.update(salt);\n-            digest.update(password);\n-            digest.update(extra);\n-            for (int k = 0; k < extra.length; ++k) {\n-                final byte[] array = extra;\n-                final int n = k;\n-                ++array[n];\n-                if (extra[k] != 0) {\n+        final byte[] input3 = new byte[8];\n+        for (long n2 = 0L; n2 < 1L << n; ++n2) {\n+            instance.update(input2);\n+            instance.update(input);\n+            instance.update(input3);\n+            for (int i = 0; i < input3.length; ++i) {\n+                final byte[] array = input3;\n+                final int n3 = i;\n+                ++array[n3];\n+                if (input3[i] != 0) {\n                     break;\n                 }\n             }\n         }\n-        return digest.digest();\n+        return instance.digest();\n     }\n     \n-    static byte[] sha256Password(final char[] password, final int numCyclesPower, final byte[] salt) {\n-        return sha256Password(utf16Decode(password), numCyclesPower, salt);\n+    static byte[] sha256Password(final char[] array, final int n, final byte[] array2) {\n+        return sha256Password(utf16Decode(array), n, array2);\n     }\n     \n-    static byte[] utf16Decode(final char[] chars) {\n-        if (chars == null) {\n+    static byte[] utf16Decode(final char[] array) {\n+        if (array == null) {\n             return null;\n         }\n-        final ByteBuffer encoded = StandardCharsets.UTF_16LE.encode(CharBuffer.wrap(chars));\n-        if (encoded.hasArray()) {\n-            return encoded.array();\n-        }\n-        final byte[] e = new byte[encoded.remaining()];\n-        encoded.get(e);\n-        return e;\n+        final ByteBuffer encode = StandardCharsets.UTF_16LE.encode(CharBuffer.wrap(array));\n+        if (encode.hasArray()) {\n+            return encode.array();\n+        }\n+        final byte[] dst = new byte[encode.remaining()];\n+        encode.get(dst);\n+        return dst;\n     }\n     \n     AES256SHA256Decoder() {\n         super(new Class[] { AES256Options.class });\n     }\n     \n-    InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength, final Coder coder, final byte[] passwordBytes, final int maxMemoryLimitInKb) {\n-        return (InputStream)new AES256SHA256Decoder.AES256SHA256Decoder$1(this, coder, archiveName, passwordBytes, in);\n+    InputStream decode(final String s, final InputStream inputStream, final long n, final Coder coder, final byte[] array, final int n2) {\n+        return (InputStream)new AES256SHA256Decoder.AES256SHA256Decoder$1(this, coder, s, array, inputStream);\n     }\n     \n-    OutputStream encode(final OutputStream out, final Object options) throws IOException {\n-        final AES256Options opts = (AES256Options)options;\n-        return (OutputStream)new AES256SHA256Decoder.AES256SHA256Decoder$2(this, out, opts);\n+    OutputStream encode(final OutputStream outputStream, final Object o) throws IOException {\n+        return (OutputStream)new AES256SHA256Decoder.AES256SHA256Decoder$2(this, outputStream, (AES256Options)o);\n     }\n     \n-    byte[] getOptionsAsProperties(final Object options) throws IOException {\n-        final AES256Options opts = (AES256Options)options;\n-        final byte[] props = new byte[2 + opts.getSalt().length + opts.getIv().length];\n-        props[0] = (byte)(opts.getNumCyclesPower() | ((opts.getSalt().length == 0) ? 0 : 128) | ((opts.getIv().length == 0) ? 0 : 64));\n-        if (opts.getSalt().length != 0 || opts.getIv().length != 0) {\n-            props[1] = (byte)(((opts.getSalt().length == 0) ? 0 : (opts.getSalt().length - 1)) << 4 | ((opts.getIv().length == 0) ? 0 : (opts.getIv().length - 1)));\n-            System.arraycopy(opts.getSalt(), 0, props, 2, opts.getSalt().length);\n-            System.arraycopy(opts.getIv(), 0, props, 2 + opts.getSalt().length, opts.getIv().length);\n+    byte[] getOptionsAsProperties(final Object o) throws IOException {\n+        final AES256Options aes256Options = (AES256Options)o;\n+        final byte[] array = new byte[2 + aes256Options.getSalt().length + aes256Options.getIv().length];\n+        array[0] = (byte)(aes256Options.getNumCyclesPower() | ((aes256Options.getSalt().length == 0) ? 0 : 128) | ((aes256Options.getIv().length == 0) ? 0 : 64));\n+        if (aes256Options.getSalt().length != 0 || aes256Options.getIv().length != 0) {\n+            array[1] = (byte)(((aes256Options.getSalt().length == 0) ? 0 : (aes256Options.getSalt().length - 1)) << 4 | ((aes256Options.getIv().length == 0) ? 0 : (aes256Options.getIv().length - 1)));\n+            System.arraycopy(aes256Options.getSalt(), 0, array, 2, aes256Options.getSalt().length);\n+            System.arraycopy(aes256Options.getIv(), 0, array, 2 + aes256Options.getSalt().length, aes256Options.getIv().length);\n         }\n-        return props;\n+        return array;\n     }\n }\n"}]}
