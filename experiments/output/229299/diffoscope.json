{"diffoscope-json-version": 1, "source1": "first/FramedSnappyCompressorInputStream.class", "source2": "second/FramedSnappyCompressorInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -29,20 +29,20 @@\n     private boolean inUncompressedChunk;\n     private int uncompressedBytesRemaining;\n     private long expectedChecksum;\n     private final int blockSize;\n     private final PureJavaCrc32C checksum;\n     private final ByteUtils.ByteSupplier supplier;\n     \n-    public FramedSnappyCompressorInputStream(final InputStream in) throws IOException {\n-        this(in, FramedSnappyDialect.STANDARD);\n+    public FramedSnappyCompressorInputStream(final InputStream inputStream) throws IOException {\n+        this(inputStream, FramedSnappyDialect.STANDARD);\n     }\n     \n-    public FramedSnappyCompressorInputStream(final InputStream in, final FramedSnappyDialect dialect) throws IOException {\n-        this(in, 32768, dialect);\n+    public FramedSnappyCompressorInputStream(final InputStream inputStream, final FramedSnappyDialect framedSnappyDialect) throws IOException {\n+        this(inputStream, 32768, framedSnappyDialect);\n     }\n     \n     public FramedSnappyCompressorInputStream(final InputStream in, final int blockSize, final FramedSnappyDialect dialect) throws IOException {\n         this.oneByte = new byte[1];\n         this.expectedChecksum = -1L;\n         this.checksum = new PureJavaCrc32C();\n         this.supplier = (ByteUtils.ByteSupplier)new FramedSnappyCompressorInputStream.FramedSnappyCompressorInputStream$1(this);\n@@ -62,174 +62,174 @@\n         if (this.currentCompressedChunk != null) {\n             this.currentCompressedChunk.close();\n             this.currentCompressedChunk = null;\n         }\n         this.in.close();\n     }\n     \n-    public int read(final byte[] b, final int off, final int len) throws IOException {\n-        int read = this.readOnce(b, off, len);\n-        if (read == -1) {\n+    public int read(final byte[] array, final int n, final int n2) throws IOException {\n+        int n3 = this.readOnce(array, n, n2);\n+        if (n3 == -1) {\n             this.readNextBlock();\n             if (this.endReached) {\n                 return -1;\n             }\n-            read = this.readOnce(b, off, len);\n+            n3 = this.readOnce(array, n, n2);\n         }\n-        return read;\n+        return n3;\n     }\n     \n     public int available() throws IOException {\n         if (this.inUncompressedChunk) {\n             return Math.min(this.uncompressedBytesRemaining, this.in.available());\n         }\n         if (this.currentCompressedChunk != null) {\n             return this.currentCompressedChunk.available();\n         }\n         return 0;\n     }\n     \n-    private int readOnce(final byte[] b, final int off, final int len) throws IOException {\n-        int read = -1;\n+    private int readOnce(final byte[] b, final int off, final int b2) throws IOException {\n+        int n = -1;\n         if (this.inUncompressedChunk) {\n-            final int amount = Math.min(this.uncompressedBytesRemaining, len);\n-            if (amount == 0) {\n+            final int min = Math.min(this.uncompressedBytesRemaining, b2);\n+            if (min == 0) {\n                 return -1;\n             }\n-            read = this.in.read(b, off, amount);\n-            if (read != -1) {\n-                this.uncompressedBytesRemaining -= read;\n-                this.count(read);\n+            n = this.in.read(b, off, min);\n+            if (n != -1) {\n+                this.uncompressedBytesRemaining -= n;\n+                this.count(n);\n             }\n         }\n         else if (this.currentCompressedChunk != null) {\n-            final long before = this.currentCompressedChunk.getBytesRead();\n-            read = this.currentCompressedChunk.read(b, off, len);\n-            if (read == -1) {\n+            final long bytesRead = this.currentCompressedChunk.getBytesRead();\n+            n = this.currentCompressedChunk.read(b, off, b2);\n+            if (n == -1) {\n                 this.currentCompressedChunk.close();\n                 this.currentCompressedChunk = null;\n             }\n             else {\n-                this.count(this.currentCompressedChunk.getBytesRead() - before);\n+                this.count(this.currentCompressedChunk.getBytesRead() - bytesRead);\n             }\n         }\n-        if (read > 0) {\n-            this.checksum.update(b, off, read);\n+        if (n > 0) {\n+            this.checksum.update(b, off, n);\n         }\n-        return read;\n+        return n;\n     }\n     \n     private void readNextBlock() throws IOException {\n         this.verifyLastChecksumAndReset();\n         this.inUncompressedChunk = false;\n-        final int type = this.readOneByte();\n-        if (type == -1) {\n+        final int oneByte = this.readOneByte();\n+        if (oneByte == -1) {\n             this.endReached = true;\n         }\n-        else if (type == 255) {\n-            this.in.unread(type);\n+        else if (oneByte == 255) {\n+            this.in.unread(oneByte);\n             this.pushedBackBytes(1L);\n             this.readStreamIdentifier();\n             this.readNextBlock();\n         }\n-        else if (type == 254 || (type > 127 && type <= 253)) {\n+        else if (oneByte == 254 || (oneByte > 127 && oneByte <= 253)) {\n             this.skipBlock();\n             this.readNextBlock();\n         }\n         else {\n-            if (type >= 2 && type <= 127) {\n-                throw new IOException(\"unskippable chunk with type \" + type + \" (hex \" + Integer.toHexString(type) + \") detected.\");\n+            if (oneByte >= 2 && oneByte <= 127) {\n+                throw new IOException(\"unskippable chunk with type \" + oneByte + \" (hex \" + Integer.toHexString(oneByte) + \") detected.\");\n             }\n-            if (type == 1) {\n+            if (oneByte == 1) {\n                 this.inUncompressedChunk = true;\n                 this.uncompressedBytesRemaining = this.readSize() - 4;\n                 this.expectedChecksum = unmask(this.readCrc());\n             }\n             else {\n-                if (type != 0) {\n-                    throw new IOException(\"unknown chunk type \" + type + \" detected.\");\n+                if (oneByte != 0) {\n+                    throw new IOException(\"unknown chunk type \" + oneByte + \" detected.\");\n                 }\n-                final boolean expectChecksum = this.dialect.usesChecksumWithCompressedChunks();\n-                final long size = this.readSize() - (expectChecksum ? 4L : 0L);\n-                if (expectChecksum) {\n+                final boolean usesChecksumWithCompressedChunks = this.dialect.usesChecksumWithCompressedChunks();\n+                final long n = this.readSize() - (usesChecksumWithCompressedChunks ? 4L : 0L);\n+                if (usesChecksumWithCompressedChunks) {\n                     this.expectedChecksum = unmask(this.readCrc());\n                 }\n                 else {\n                     this.expectedChecksum = -1L;\n                 }\n-                this.currentCompressedChunk = new SnappyCompressorInputStream((InputStream)new BoundedInputStream((InputStream)this.in, size), this.blockSize);\n+                this.currentCompressedChunk = new SnappyCompressorInputStream((InputStream)new BoundedInputStream((InputStream)this.in, n), this.blockSize);\n                 this.count(this.currentCompressedChunk.getBytesRead());\n             }\n         }\n     }\n     \n     private long readCrc() throws IOException {\n-        final byte[] b = new byte[4];\n-        final int read = IOUtils.readFully((InputStream)this.in, b);\n-        this.count(read);\n-        if (read != 4) {\n+        final byte[] array = new byte[4];\n+        final int fully = IOUtils.readFully((InputStream)this.in, array);\n+        this.count(fully);\n+        if (fully != 4) {\n             throw new IOException(\"premature end of stream\");\n         }\n-        return ByteUtils.fromLittleEndian(b);\n+        return ByteUtils.fromLittleEndian(array);\n     }\n     \n-    static long unmask(long x) {\n-        x -= 2726488792L;\n-        x &= 0xFFFFFFFFL;\n-        return (x >> 17 | x << 15) & 0xFFFFFFFFL;\n+    static long unmask(long n) {\n+        n -= 2726488792L;\n+        n &= 0xFFFFFFFFL;\n+        return (n >> 17 | n << 15) & 0xFFFFFFFFL;\n     }\n     \n     private int readSize() throws IOException {\n         return (int)ByteUtils.fromLittleEndian(this.supplier, 3);\n     }\n     \n     private void skipBlock() throws IOException {\n         final int size = this.readSize();\n-        final long read = IOUtils.skip((InputStream)this.in, (long)size);\n-        this.count(read);\n-        if (read != size) {\n+        final long skip = IOUtils.skip((InputStream)this.in, (long)size);\n+        this.count(skip);\n+        if (skip != size) {\n             throw new IOException(\"premature end of stream\");\n         }\n     }\n     \n     private void readStreamIdentifier() throws IOException {\n-        final byte[] b = new byte[10];\n-        final int read = IOUtils.readFully((InputStream)this.in, b);\n-        this.count(read);\n-        if (10 != read || !matches(b, 10)) {\n+        final byte[] array = new byte[10];\n+        final int fully = IOUtils.readFully((InputStream)this.in, array);\n+        this.count(fully);\n+        if (10 != fully || !matches(array, 10)) {\n             throw new IOException(\"Not a framed Snappy stream\");\n         }\n     }\n     \n     private int readOneByte() throws IOException {\n-        final int b = this.in.read();\n-        if (b != -1) {\n+        final int read = this.in.read();\n+        if (read != -1) {\n             this.count(1);\n-            return b & 0xFF;\n+            return read & 0xFF;\n         }\n         return -1;\n     }\n     \n     private void verifyLastChecksumAndReset() throws IOException {\n         if (this.expectedChecksum >= 0L && this.expectedChecksum != this.checksum.getValue()) {\n             throw new IOException(\"Checksum verification failed\");\n         }\n         this.expectedChecksum = -1L;\n         this.checksum.reset();\n     }\n     \n-    public static boolean matches(final byte[] signature, final int length) {\n-        if (length < FramedSnappyCompressorInputStream.SZ_SIGNATURE.length) {\n+    public static boolean matches(final byte[] array, final int n) {\n+        if (n < FramedSnappyCompressorInputStream.SZ_SIGNATURE.length) {\n             return false;\n         }\n-        byte[] shortenedSig = signature;\n-        if (signature.length > FramedSnappyCompressorInputStream.SZ_SIGNATURE.length) {\n-            shortenedSig = new byte[FramedSnappyCompressorInputStream.SZ_SIGNATURE.length];\n-            System.arraycopy(signature, 0, shortenedSig, 0, FramedSnappyCompressorInputStream.SZ_SIGNATURE.length);\n+        byte[] a = array;\n+        if (array.length > FramedSnappyCompressorInputStream.SZ_SIGNATURE.length) {\n+            a = new byte[FramedSnappyCompressorInputStream.SZ_SIGNATURE.length];\n+            System.arraycopy(array, 0, a, 0, FramedSnappyCompressorInputStream.SZ_SIGNATURE.length);\n         }\n-        return Arrays.equals(shortenedSig, FramedSnappyCompressorInputStream.SZ_SIGNATURE);\n+        return Arrays.equals(a, FramedSnappyCompressorInputStream.SZ_SIGNATURE);\n     }\n     \n     static {\n         SZ_SIGNATURE = new byte[] { -1, 6, 0, 0, 115, 78, 97, 80, 112, 89 };\n     }\n }\n"}]}
