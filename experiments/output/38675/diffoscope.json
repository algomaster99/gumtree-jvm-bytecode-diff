{"diffoscope-json-version": 1, "source1": "first/TarUtils.class", "source2": "second/TarUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,22 +1,27 @@\n \n package org.apache.commons.compress.archivers.tar;\n \n-import org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\n import java.nio.ByteBuffer;\n import java.io.IOException;\n import java.math.BigInteger;\n+import org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\n import org.apache.commons.compress.archivers.zip.ZipEncoding;\n \n public class TarUtils\n {\n     private static final int BYTE_MASK = 255;\n     static final ZipEncoding DEFAULT_ENCODING;\n     static final ZipEncoding FALLBACK_ENCODING;\n     \n+    static {\n+        DEFAULT_ENCODING = ZipEncodingHelper.getZipEncoding((String)null);\n+        FALLBACK_ENCODING = (ZipEncoding)new TarUtils.TarUtils$1();\n+    }\n+    \n     private TarUtils() {\n     }\n     \n     public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n         long result = 0L;\n         int end = offset + length;\n         int start = offset;\n@@ -25,15 +30,22 @@\n         }\n         if (buffer[start] == 0) {\n             return 0L;\n         }\n         while (start < end && buffer[start] == 32) {\n             ++start;\n         }\n-        for (byte trailer = buffer[end - 1]; start < end && (trailer == 0 || trailer == 32); --end, trailer = buffer[end - 1]) {}\n+        byte trailer = buffer[end - 1];\n+        while (start < end) {\n+            if (trailer != 0 && trailer != 32) {\n+                break;\n+            }\n+            --end;\n+            trailer = buffer[end - 1];\n+        }\n         while (start < end) {\n             final byte currentByte = buffer[start];\n             if (currentByte < 48 || currentByte > 55) {\n                 throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));\n             }\n             result = (result << 3) + (currentByte - 48);\n             ++start;\n@@ -50,15 +62,15 @@\n             return parseBinaryLong(buffer, offset, length, negative);\n         }\n         return parseBinaryBigInteger(buffer, offset, length, negative);\n     }\n     \n     private static long parseBinaryLong(final byte[] buffer, final int offset, final int length, final boolean negative) {\n         if (length >= 9) {\n-            throw new IllegalArgumentException(\"At offset \" + offset + \", \" + length + \" byte binary number exceeds maximum signed long value\");\n+            throw new IllegalArgumentException(\"At offset \" + offset + \", \" + length + \" byte binary number\" + \" exceeds maximum signed long\" + \" value\");\n         }\n         long val = 0L;\n         for (int i = 1; i < length; ++i) {\n             val = (val << 8) + (buffer[offset + i] & 0xFF);\n         }\n         if (negative) {\n             --val;\n@@ -71,15 +83,15 @@\n         final byte[] remainder = new byte[length - 1];\n         System.arraycopy(buffer, offset + 1, remainder, 0, length - 1);\n         BigInteger val = new BigInteger(remainder);\n         if (negative) {\n             val = val.add(BigInteger.valueOf(-1L)).not();\n         }\n         if (val.bitLength() > 63) {\n-            throw new IllegalArgumentException(\"At offset \" + offset + \", \" + length + \" byte binary number exceeds maximum signed long value\");\n+            throw new IllegalArgumentException(\"At offset \" + offset + \", \" + length + \" byte binary number\" + \" exceeds maximum signed long\" + \" value\");\n         }\n         return negative ? (-val.longValue()) : val.longValue();\n     }\n     \n     public static boolean parseBoolean(final byte[] buffer, final int offset) {\n         return buffer[offset] == 1;\n     }\n@@ -90,15 +102,15 @@\n         return \"Invalid byte \" + currentByte + \" at offset \" + (current - offset) + \" in '\" + string + \"' len=\" + length;\n     }\n     \n     public static String parseName(final byte[] buffer, final int offset, final int length) {\n         try {\n             return parseName(buffer, offset, length, TarUtils.DEFAULT_ENCODING);\n         }\n-        catch (final IOException ex) {\n+        catch (final IOException ex3) {\n             try {\n                 return parseName(buffer, offset, length, TarUtils.FALLBACK_ENCODING);\n             }\n             catch (final IOException ex2) {\n                 throw new RuntimeException(ex2);\n             }\n         }\n@@ -115,15 +127,15 @@\n         return \"\";\n     }\n     \n     public static int formatNameBytes(final String name, final byte[] buf, final int offset, final int length) {\n         try {\n             return formatNameBytes(name, buf, offset, length, TarUtils.DEFAULT_ENCODING);\n         }\n-        catch (final IOException ex) {\n+        catch (final IOException ex3) {\n             try {\n                 return formatNameBytes(name, buf, offset, length, TarUtils.FALLBACK_ENCODING);\n             }\n             catch (final IOException ex2) {\n                 throw new RuntimeException(ex2);\n             }\n         }\n@@ -149,15 +161,15 @@\n         }\n         else {\n             long val;\n             for (val = value; remaining >= 0 && val != 0L; val >>>= 3, --remaining) {\n                 buffer[offset + remaining] = (byte)(48 + (byte)(val & 0x7L));\n             }\n             if (val != 0L) {\n-                throw new IllegalArgumentException(value + \"=\" + Long.toOctalString(value) + \" will not fit in octal number buffer of length \" + length);\n+                throw new IllegalArgumentException(String.valueOf(value) + \"=\" + Long.toOctalString(value) + \" will not fit in octal number buffer of length \" + length);\n             }\n         }\n         while (remaining >= 0) {\n             buffer[offset + remaining] = 48;\n             --remaining;\n         }\n     }\n@@ -252,13 +264,8 @@\n                 b = 32;\n             }\n             unsignedSum += (0xFF & b);\n             signedSum += b;\n         }\n         return storedSum == unsignedSum || storedSum == signedSum;\n     }\n-    \n-    static {\n-        DEFAULT_ENCODING = ZipEncodingHelper.getZipEncoding((String)null);\n-        FALLBACK_ENCODING = (ZipEncoding)new TarUtils.TarUtils$1();\n-    }\n }\n"}]}
