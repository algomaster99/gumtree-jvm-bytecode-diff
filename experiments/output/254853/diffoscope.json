{"diffoscope-json-version": 1, "source1": "first/Base16.class", "source2": "second/Base16.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -16,95 +16,94 @@\n     private final byte[] decodeTable;\n     private final byte[] encodeTable;\n     \n     public Base16() {\n         this(false);\n     }\n     \n-    public Base16(final boolean lowerCase) {\n-        this(lowerCase, Base16.DECODING_POLICY_DEFAULT);\n+    public Base16(final boolean b) {\n+        this(b, Base16.DECODING_POLICY_DEFAULT);\n     }\n     \n-    public Base16(final boolean lowerCase, final CodecPolicy decodingPolicy) {\n-        super(1, 2, 0, 0, (byte)61, decodingPolicy);\n-        if (lowerCase) {\n+    public Base16(final boolean b, final CodecPolicy codecPolicy) {\n+        super(1, 2, 0, 0, (byte)61, codecPolicy);\n+        if (b) {\n             this.encodeTable = Base16.LOWER_CASE_ENCODE_TABLE;\n             this.decodeTable = Base16.LOWER_CASE_DECODE_TABLE;\n         }\n         else {\n             this.encodeTable = Base16.UPPER_CASE_ENCODE_TABLE;\n             this.decodeTable = Base16.UPPER_CASE_DECODE_TABLE;\n         }\n     }\n     \n-    void decode(final byte[] data, int offset, final int length, final BaseNCodec.Context context) {\n-        if (context.eof || length < 0) {\n+    void decode(final byte[] array, int i, final int b, final BaseNCodec.Context context) {\n+        if (context.eof || b < 0) {\n             context.eof = true;\n             if (context.ibitWorkArea != 0) {\n                 this.validateTrailingCharacter();\n             }\n             return;\n         }\n-        final int dataLen = Math.min(data.length - offset, length);\n-        final int availableChars = ((context.ibitWorkArea != 0) ? 1 : 0) + dataLen;\n-        if (availableChars == 1 && availableChars == dataLen) {\n-            context.ibitWorkArea = this.decodeOctet(data[offset]) + 1;\n+        final int min = Math.min(array.length - i, b);\n+        final int n = ((context.ibitWorkArea != 0) ? 1 : 0) + min;\n+        if (n == 1 && n == min) {\n+            context.ibitWorkArea = this.decodeOctet(array[i]) + 1;\n             return;\n         }\n-        final int charsToProcess = (availableChars % 2 == 0) ? availableChars : (availableChars - 1);\n-        final int end = offset + dataLen;\n-        final byte[] buffer = this.ensureBufferSize(charsToProcess / 2, context);\n-        if (dataLen < availableChars) {\n-            int result = context.ibitWorkArea - 1 << 4;\n-            result |= this.decodeOctet(data[offset++]);\n-            buffer[context.pos++] = (byte)result;\n+        final int n2 = (n % 2 == 0) ? n : (n - 1);\n+        final int n3 = i + min;\n+        final byte[] ensureBufferSize = this.ensureBufferSize(n2 / 2, context);\n+        if (min < n) {\n+            ensureBufferSize[context.pos++] = (byte)(context.ibitWorkArea - 1 << 4 | this.decodeOctet(array[i++]));\n             context.ibitWorkArea = 0;\n         }\n-        int result;\n-        for (int loopEnd = end - 1; offset < loopEnd; result = this.decodeOctet(data[offset++]) << 4, result |= this.decodeOctet(data[offset++]), buffer[context.pos++] = (byte)result) {}\n-        if (offset < end) {\n-            context.ibitWorkArea = this.decodeOctet(data[offset]) + 1;\n+        while (i < n3 - 1) {\n+            ensureBufferSize[context.pos++] = (byte)(this.decodeOctet(array[i++]) << 4 | this.decodeOctet(array[i++]));\n+        }\n+        if (i < n3) {\n+            context.ibitWorkArea = this.decodeOctet(array[i]) + 1;\n         }\n     }\n     \n-    private int decodeOctet(final byte octet) {\n-        int decoded = -1;\n-        if ((octet & 0xFF) < this.decodeTable.length) {\n-            decoded = this.decodeTable[octet];\n+    private int decodeOctet(final byte i) {\n+        int n = -1;\n+        if ((i & 0xFF) < this.decodeTable.length) {\n+            n = this.decodeTable[i];\n         }\n-        if (decoded == -1) {\n-            throw new IllegalArgumentException(\"Invalid octet in encoded value: \" + octet);\n+        if (n == -1) {\n+            throw new IllegalArgumentException(\"Invalid octet in encoded value: \" + i);\n         }\n-        return decoded;\n+        return n;\n     }\n     \n-    void encode(final byte[] data, final int offset, final int length, final BaseNCodec.Context context) {\n+    void encode(final byte[] array, final int n, final int i, final BaseNCodec.Context context) {\n         if (context.eof) {\n             return;\n         }\n-        if (length < 0) {\n+        if (i < 0) {\n             context.eof = true;\n             return;\n         }\n-        final int size = length * 2;\n-        if (size < 0) {\n-            throw new IllegalArgumentException(\"Input length exceeds maximum size for encoded data: \" + length);\n-        }\n-        final byte[] buffer = this.ensureBufferSize(size, context);\n-        for (int end = offset + length, i = offset; i < end; ++i) {\n-            final int value = data[i];\n-            final int high = value >> 4 & 0xF;\n-            final int low = value & 0xF;\n-            buffer[context.pos++] = this.encodeTable[high];\n-            buffer[context.pos++] = this.encodeTable[low];\n+        final int n2 = i * 2;\n+        if (n2 < 0) {\n+            throw new IllegalArgumentException(\"Input length exceeds maximum size for encoded data: \" + i);\n+        }\n+        final byte[] ensureBufferSize = this.ensureBufferSize(n2, context);\n+        for (int n3 = n + i, j = n; j < n3; ++j) {\n+            final byte b = array[j];\n+            final int n4 = b >> 4 & 0xF;\n+            final int n5 = b & 0xF;\n+            ensureBufferSize[context.pos++] = this.encodeTable[n4];\n+            ensureBufferSize[context.pos++] = this.encodeTable[n5];\n         }\n     }\n     \n-    public boolean isInAlphabet(final byte octet) {\n-        return (octet & 0xFF) < this.decodeTable.length && this.decodeTable[octet] != -1;\n+    public boolean isInAlphabet(final byte b) {\n+        return (b & 0xFF) < this.decodeTable.length && this.decodeTable[b] != -1;\n     }\n     \n     private void validateTrailingCharacter() {\n         if (this.isStrictDecoding()) {\n             throw new IllegalArgumentException(\"Strict decoding: Last encoded character is a valid base 16 alphabetcharacter but not a possible encoding. Decoding requires at least two characters to create one byte.\");\n         }\n     }\n"}]}
