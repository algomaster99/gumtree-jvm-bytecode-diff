{"diffoscope-json-version": 1, "source1": "first/DaitchMokotoffSoundex.class", "source2": "second/DaitchMokotoffSoundex.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,20 +1,20 @@\n \n package org.apache.commons.codec.language;\n \n-import org.apache.commons.codec.Resources;\n-import java.util.HashMap;\n import java.util.Iterator;\n import java.util.Set;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.LinkedHashSet;\n import org.apache.commons.codec.EncoderException;\n import java.util.ArrayList;\n import java.util.Scanner;\n+import org.apache.commons.codec.Resources;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import org.apache.commons.codec.StringEncoder;\n \n public class DaitchMokotoffSoundex implements StringEncoder\n {\n     private static final String COMMENT = \"//\";\n@@ -23,14 +23,44 @@\n     private static final String MULTILINE_COMMENT_START = \"/*\";\n     private static final String RESOURCE_FILE = \"org/apache/commons/codec/language/dmrules.txt\";\n     private static final int MAX_LENGTH = 6;\n     private static final Map<Character, List<DaitchMokotoffSoundex.Rule>> RULES;\n     private static final Map<Character, Character> FOLDINGS;\n     private final boolean folding;\n     \n+    static {\n+        RULES = new HashMap<Character, List<DaitchMokotoffSoundex.Rule>>();\n+        FOLDINGS = new HashMap<Character, Character>();\n+        Throwable t = null;\n+        try {\n+            final Scanner scanner = new Scanner(Resources.getInputStream(\"org/apache/commons/codec/language/dmrules.txt\"), \"UTF-8\");\n+            try {\n+                parseRules(scanner, \"org/apache/commons/codec/language/dmrules.txt\", DaitchMokotoffSoundex.RULES, DaitchMokotoffSoundex.FOLDINGS);\n+            }\n+            finally {\n+                if (scanner != null) {\n+                    scanner.close();\n+                }\n+            }\n+        }\n+        finally {\n+            if (t == null) {\n+                final Throwable exception;\n+                t = exception;\n+            }\n+            else {\n+                final Throwable exception;\n+                if (t != exception) {\n+                    t.addSuppressed(exception);\n+                }\n+            }\n+        }\n+        DaitchMokotoffSoundex.RULES.forEach((k, v) -> v.sort((rule1, rule2) -> rule2.getPatternLength() - rule1.getPatternLength()));\n+    }\n+    \n     private static void parseRules(final Scanner scanner, final String location, final Map<Character, List<DaitchMokotoffSoundex.Rule>> ruleMapping, final Map<Character, Character> asciiFoldings) {\n         int currentLine = 0;\n         boolean inMultilineComment = false;\n         while (scanner.hasNextLine()) {\n             ++currentLine;\n             String line;\n             final String rawLine = line = scanner.nextLine();\n@@ -71,15 +101,15 @@\n                     }\n                     try {\n                         final String pattern = stripQuotes(parts[0]);\n                         final String replacement1 = stripQuotes(parts[1]);\n                         final String replacement2 = stripQuotes(parts[2]);\n                         final String replacement3 = stripQuotes(parts[3]);\n                         final DaitchMokotoffSoundex.Rule r = new DaitchMokotoffSoundex.Rule(pattern, replacement1, replacement2, replacement3);\n-                        final char patternKey = DaitchMokotoffSoundex.Rule.access$000(r).charAt(0);\n+                        final char patternKey = DaitchMokotoffSoundex.Rule.access$0(r).charAt(0);\n                         final List<DaitchMokotoffSoundex.Rule> rules = (List<DaitchMokotoffSoundex.Rule>)ruleMapping.computeIfAbsent(Character.valueOf(patternKey), k -> new ArrayList());\n                         rules.add(r);\n                     }\n                     catch (final IllegalArgumentException e) {\n                         throw new IllegalStateException(\"Problem parsing line '\" + currentLine + \"' in \" + location, e);\n                     }\n                 }\n@@ -103,15 +133,17 @@\n     \n     public DaitchMokotoffSoundex(final boolean folding) {\n         this.folding = folding;\n     }\n     \n     private String cleanup(final String input) {\n         final StringBuilder sb = new StringBuilder();\n-        for (char ch : input.toCharArray()) {\n+        char[] charArray;\n+        for (int length = (charArray = input.toCharArray()).length, i = 0; i < length; ++i) {\n+            char ch = charArray[i];\n             if (!Character.isWhitespace(ch)) {\n                 ch = Character.toLowerCase(ch);\n                 final Character character = Character.valueOf(DaitchMokotoffSoundex.FOLDINGS.get((Object)Character.valueOf(ch)));\n                 if (this.folding && character != null) {\n                     ch = character;\n                 }\n                 sb.append(ch);\n@@ -134,30 +166,32 @@\n         return this.soundex(source, false)[0];\n     }\n     \n     public String soundex(final String source) {\n         final String[] branches = this.soundex(source, true);\n         final StringBuilder sb = new StringBuilder();\n         int index = 0;\n-        for (final String branch : branches) {\n+        String[] array;\n+        for (int length = (array = branches).length, i = 0; i < length; ++i) {\n+            final String branch = array[i];\n             sb.append(branch);\n             if (++index < branches.length) {\n                 sb.append('|');\n             }\n         }\n         return sb.toString();\n     }\n     \n     private String[] soundex(final String source, final boolean branching) {\n         if (source == null) {\n             return null;\n         }\n         final String input = this.cleanup(source);\n         final Set<DaitchMokotoffSoundex.Branch> currentBranches = new LinkedHashSet<DaitchMokotoffSoundex.Branch>();\n-        currentBranches.add(new DaitchMokotoffSoundex.Branch((DaitchMokotoffSoundex.DaitchMokotoffSoundex$1)null));\n+        currentBranches.add(new DaitchMokotoffSoundex.Branch((DaitchMokotoffSoundex.Branch)null));\n         char lastChar = '\\0';\n         for (int index = 0; index < input.length(); ++index) {\n             final char ch = input.charAt(index);\n             if (!Character.isWhitespace(ch)) {\n                 final String inputContext = input.substring(index);\n                 final List<DaitchMokotoffSoundex.Rule> rules = (List<DaitchMokotoffSoundex.Rule>)DaitchMokotoffSoundex.RULES.get(Character.valueOf(ch));\n                 if (rules != null) {\n@@ -166,15 +200,17 @@\n                         if (rule.matches(inputContext)) {\n                             if (branching) {\n                                 nextBranches.clear();\n                             }\n                             final String[] replacements = rule.getReplacements(inputContext, lastChar == '\\0');\n                             final boolean branchingRequired = replacements.length > 1 && branching;\n                             for (final DaitchMokotoffSoundex.Branch branch : currentBranches) {\n-                                for (final String nextReplacement : replacements) {\n+                                String[] array;\n+                                for (int length = (array = replacements).length, i = 0; i < length; ++i) {\n+                                    final String nextReplacement = array[i];\n                                     final DaitchMokotoffSoundex.Branch nextBranch = branchingRequired ? branch.createBranch() : branch;\n                                     final boolean force = (lastChar == 'm' && ch == 'n') || (lastChar == 'n' && ch == 'm');\n                                     nextBranch.processNextReplacement(nextReplacement, force);\n                                     if (!branching) {\n                                         break;\n                                     }\n                                     nextBranches.add(nextBranch);\n@@ -196,17 +232,8 @@\n         int index2 = 0;\n         for (final DaitchMokotoffSoundex.Branch branch2 : currentBranches) {\n             branch2.finish();\n             result[index2++] = branch2.toString();\n         }\n         return result;\n     }\n-    \n-    static {\n-        RULES = new HashMap<Character, List<DaitchMokotoffSoundex.Rule>>();\n-        FOLDINGS = new HashMap<Character, Character>();\n-        try (final Scanner scanner = new Scanner(Resources.getInputStream(\"org/apache/commons/codec/language/dmrules.txt\"), \"UTF-8\")) {\n-            parseRules(scanner, \"org/apache/commons/codec/language/dmrules.txt\", DaitchMokotoffSoundex.RULES, DaitchMokotoffSoundex.FOLDINGS);\n-        }\n-        DaitchMokotoffSoundex.RULES.forEach((k, v) -> v.sort((rule1, rule2) -> rule2.getPatternLength() - rule1.getPatternLength()));\n-    }\n }\n"}]}
