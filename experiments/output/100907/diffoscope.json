{"diffoscope-json-version": 1, "source1": "first/MultipleStringLiteralsCheck.class", "source2": "second/MultipleStringLiteralsCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -24,14 +24,18 @@\n     private static final String QUOTE = \"\\\"\";\n     private final Map<String, List<DetailAST>> stringMap;\n     @XdocsPropertyType(PropertyType.TOKEN_ARRAY)\n     private final BitSet ignoreOccurrenceContext;\n     private int allowedDuplicates;\n     private Pattern ignoreStringsRegexp;\n     \n+    static {\n+        ALL_NEW_LINES = Pattern.compile(\"\\\\R\");\n+    }\n+    \n     public MultipleStringLiteralsCheck() {\n         this.stringMap = new HashMap<String, List<DetailAST>>();\n         this.ignoreOccurrenceContext = new BitSet();\n         this.allowedDuplicates = 1;\n         this.setIgnoreStringsRegexp(Pattern.compile(\"^\\\"\\\"$\"));\n         this.ignoreOccurrenceContext.set(159);\n     }\n@@ -70,15 +74,15 @@\n     }\n     \n     public void visitToken(final DetailAST ast) {\n         if (!this.isInIgnoreOccurrenceContext(ast)) {\n             String currentString;\n             if (ast.getType() == 205) {\n                 final String strippedString = CheckUtil.stripIndentAndInitialNewLineFromTextBlock(ast.getText());\n-                currentString = \"\\\"\" + strippedString;\n+                currentString = \"\\\"\" + strippedString + \"\\\"\";\n             }\n             else {\n                 currentString = ast.getText();\n             }\n             if (this.ignoreStringsRegexp == null || !this.ignoreStringsRegexp.matcher(currentString).find()) {\n                 ((List<DetailAST>)this.stringMap.computeIfAbsent(currentString, key -> new ArrayList())).add(ast);\n             }\n@@ -107,12 +111,8 @@\n             if (hits.size() > this.allowedDuplicates) {\n                 final DetailAST firstFinding = (DetailAST)hits.get(0);\n                 final String recurringString = MultipleStringLiteralsCheck.ALL_NEW_LINES.matcher(stringListEntry.getKey()).replaceAll(\"\\\\\\\\n\");\n                 this.log(firstFinding, \"multiple.string.literal\", new Object[] { recurringString, Integer.valueOf(hits.size()) });\n             }\n         }\n     }\n-    \n-    static {\n-        ALL_NEW_LINES = Pattern.compile(\"\\\\R\");\n-    }\n }\n"}]}
