{"diffoscope-json-version": 1, "source1": "first/BlockLZ4CompressorOutputStream$Pair.class", "source2": "second/BlockLZ4CompressorOutputStream$Pair.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -19,40 +19,38 @@\n     private int brLength;\n     private boolean written;\n     \n     Pair() {\n         this.literals = new LinkedList();\n     }\n     \n-    private static int lengths(final int litLength, final int brLength) {\n-        final int l = Math.min(litLength, 15);\n-        final int br = (brLength < 4) ? 0 : ((brLength < 19) ? (brLength - 4) : 15);\n-        return l << 4 | br;\n+    private static int lengths(final int a, final int n) {\n+        return Math.min(a, 15) << 4 | ((n < 4) ? 0 : ((n < 19) ? (n - 4) : 15));\n     }\n     \n-    private static void writeLength(int length, final OutputStream out) throws IOException {\n-        while (length >= 255) {\n-            out.write(255);\n-            length -= 255;\n+    private static void writeLength(int i, final OutputStream outputStream) throws IOException {\n+        while (i >= 255) {\n+            outputStream.write(255);\n+            i -= 255;\n         }\n-        out.write(length);\n+        outputStream.write(i);\n     }\n     \n-    byte[] addLiteral(final LZ77Compressor.LiteralBlock block) {\n-        final byte[] copy = Arrays.copyOfRange(block.getData(), block.getOffset(), block.getOffset() + block.getLength());\n-        this.literals.add(copy);\n-        return copy;\n+    byte[] addLiteral(final LZ77Compressor.LiteralBlock literalBlock) {\n+        final byte[] copyOfRange = Arrays.copyOfRange(literalBlock.getData(), literalBlock.getOffset(), literalBlock.getOffset() + literalBlock.getLength());\n+        this.literals.add(copyOfRange);\n+        return copyOfRange;\n     }\n     \n     private int backReferenceLength() {\n         return this.brLength;\n     }\n     \n-    boolean canBeWritten(final int lengthOfBlocksAfterThisPair) {\n-        return this.hasBackReference() && lengthOfBlocksAfterThisPair >= 16;\n+    boolean canBeWritten(final int n) {\n+        return this.hasBackReference() && n >= 16;\n     }\n     \n     boolean hasBackReference() {\n         return this.brOffset > 0;\n     }\n     \n     private boolean hasBeenWritten() {\n@@ -63,52 +61,53 @@\n         return this.literalLength() + this.brLength;\n     }\n     \n     private int literalLength() {\n         return this.literals.stream().mapToInt(Pair::lambda$literalLength$0).sum();\n     }\n     \n-    private void prependLiteral(final byte[] data) {\n-        this.literals.addFirst(data);\n+    private void prependLiteral(final byte[] array) {\n+        this.literals.addFirst(array);\n     }\n     \n-    private void prependTo(final Pair other) {\n-        final Iterator<byte[]> listBackwards = this.literals.descendingIterator();\n-        while (listBackwards.hasNext()) {\n-            other.prependLiteral((byte[])listBackwards.next());\n+    private void prependTo(final Pair pair) {\n+        final Iterator descendingIterator = this.literals.descendingIterator();\n+        while (descendingIterator.hasNext()) {\n+            pair.prependLiteral((byte[])descendingIterator.next());\n         }\n     }\n     \n-    void setBackReference(final LZ77Compressor.BackReference block) {\n+    void setBackReference(final LZ77Compressor.BackReference backReference) {\n         if (this.hasBackReference()) {\n             throw new IllegalStateException();\n         }\n-        this.brOffset = block.getOffset();\n-        this.brLength = block.getLength();\n+        this.brOffset = backReference.getOffset();\n+        this.brLength = backReference.getLength();\n     }\n     \n-    private Pair splitWithNewBackReferenceLengthOf(final int newBackReferenceLength) {\n-        final Pair p = new Pair();\n-        p.literals.addAll(this.literals);\n-        p.brOffset = this.brOffset;\n-        p.brLength = newBackReferenceLength;\n-        return p;\n-    }\n-    \n-    void writeTo(final OutputStream out) throws IOException {\n-        final int litLength = this.literalLength();\n-        out.write(lengths(litLength, this.brLength));\n-        if (litLength >= 15) {\n-            writeLength(litLength - 15, out);\n-        }\n-        for (final byte[] b : this.literals) {\n-            out.write(b);\n+    private Pair splitWithNewBackReferenceLengthOf(final int brLength) {\n+        final Pair pair = new Pair();\n+        pair.literals.addAll(this.literals);\n+        pair.brOffset = this.brOffset;\n+        pair.brLength = brLength;\n+        return pair;\n+    }\n+    \n+    void writeTo(final OutputStream outputStream) throws IOException {\n+        final int literalLength = this.literalLength();\n+        outputStream.write(lengths(literalLength, this.brLength));\n+        if (literalLength >= 15) {\n+            writeLength(literalLength - 15, outputStream);\n+        }\n+        final Iterator iterator = this.literals.iterator();\n+        while (iterator.hasNext()) {\n+            outputStream.write((byte[])iterator.next());\n         }\n         if (this.hasBackReference()) {\n-            ByteUtils.toLittleEndian(out, (long)this.brOffset, 2);\n+            ByteUtils.toLittleEndian(outputStream, (long)this.brOffset, 2);\n             if (this.brLength - 4 >= 15) {\n-                writeLength(this.brLength - 4 - 15, out);\n+                writeLength(this.brLength - 4 - 15, outputStream);\n             }\n         }\n         this.written = true;\n     }\n }\n"}]}
