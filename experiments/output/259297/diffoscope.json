{"diffoscope-json-version": 1, "source1": "first/IOUtils.class", "source2": "second/IOUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -78,111 +78,111 @@\n     }\n     \n     public static BufferedOutputStream buffer(final OutputStream outputStream, final int size) {\n         Objects.requireNonNull(outputStream, \"outputStream\");\n         return (outputStream instanceof BufferedOutputStream) ? ((BufferedOutputStream)outputStream) : new BufferedOutputStream(outputStream, size);\n     }\n     \n-    public static BufferedReader buffer(final Reader reader) {\n-        return (reader instanceof BufferedReader) ? ((BufferedReader)reader) : new BufferedReader(reader);\n+    public static BufferedReader buffer(final Reader in) {\n+        return (in instanceof BufferedReader) ? ((BufferedReader)in) : new BufferedReader(in);\n     }\n     \n-    public static BufferedReader buffer(final Reader reader, final int size) {\n-        return (reader instanceof BufferedReader) ? ((BufferedReader)reader) : new BufferedReader(reader, size);\n+    public static BufferedReader buffer(final Reader in, final int sz) {\n+        return (in instanceof BufferedReader) ? ((BufferedReader)in) : new BufferedReader(in, sz);\n     }\n     \n-    public static BufferedWriter buffer(final Writer writer) {\n-        return (writer instanceof BufferedWriter) ? ((BufferedWriter)writer) : new BufferedWriter(writer);\n+    public static BufferedWriter buffer(final Writer out) {\n+        return (out instanceof BufferedWriter) ? ((BufferedWriter)out) : new BufferedWriter(out);\n     }\n     \n-    public static BufferedWriter buffer(final Writer writer, final int size) {\n-        return (writer instanceof BufferedWriter) ? ((BufferedWriter)writer) : new BufferedWriter(writer, size);\n+    public static BufferedWriter buffer(final Writer out, final int sz) {\n+        return (out instanceof BufferedWriter) ? ((BufferedWriter)out) : new BufferedWriter(out, sz);\n     }\n     \n     public static byte[] byteArray() {\n         return byteArray(8192);\n     }\n     \n-    public static byte[] byteArray(final int size) {\n-        return new byte[size];\n+    public static byte[] byteArray(final int n) {\n+        return new byte[n];\n     }\n     \n     private static char[] charArray() {\n         return charArray(8192);\n     }\n     \n-    private static char[] charArray(final int size) {\n-        return new char[size];\n+    private static char[] charArray(final int n) {\n+        return new char[n];\n     }\n     \n     public static void close(final Closeable closeable) throws IOException {\n         if (closeable != null) {\n             closeable.close();\n         }\n     }\n     \n-    public static void close(final Closeable... closeables) throws IOException {\n-        if (closeables != null) {\n-            for (final Closeable closeable : closeables) {\n-                close(closeable);\n+    public static void close(final Closeable... array) throws IOException {\n+        if (array != null) {\n+            for (int length = array.length, i = 0; i < length; ++i) {\n+                close(array[i]);\n             }\n         }\n     }\n     \n-    public static void close(final Closeable closeable, final IOConsumer<IOException> consumer) throws IOException {\n+    public static void close(final Closeable closeable, final IOConsumer<IOException> ioConsumer) throws IOException {\n         if (closeable != null) {\n             try {\n                 closeable.close();\n             }\n-            catch (final IOException e) {\n-                if (consumer != null) {\n-                    consumer.accept((Object)e);\n+            catch (final IOException ex) {\n+                if (ioConsumer != null) {\n+                    ioConsumer.accept((Object)ex);\n                 }\n             }\n         }\n     }\n     \n-    public static void close(final URLConnection conn) {\n-        if (conn instanceof HttpURLConnection) {\n-            ((HttpURLConnection)conn).disconnect();\n+    public static void close(final URLConnection urlConnection) {\n+        if (urlConnection instanceof HttpURLConnection) {\n+            ((HttpURLConnection)urlConnection).disconnect();\n         }\n     }\n     \n     public static void closeQuietly(final Closeable closeable) {\n         closeQuietly(closeable, null);\n     }\n     \n-    public static void closeQuietly(final Closeable... closeables) {\n-        if (closeables == null) {\n+    public static void closeQuietly(final Closeable... array) {\n+        if (array == null) {\n             return;\n         }\n-        for (final Closeable closeable : closeables) {\n-            closeQuietly(closeable);\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            closeQuietly(array[i]);\n         }\n     }\n     \n     public static void closeQuietly(final Closeable closeable, final Consumer<IOException> consumer) {\n         if (closeable != null) {\n             try {\n                 closeable.close();\n             }\n-            catch (final IOException e) {\n+            catch (final IOException ex) {\n                 if (consumer != null) {\n-                    consumer.accept(e);\n+                    consumer.accept(ex);\n                 }\n             }\n         }\n     }\n     \n-    public static void closeQuietly(final InputStream input) {\n-        closeQuietly((Closeable)input);\n+    public static void closeQuietly(final InputStream inputStream) {\n+        closeQuietly((Closeable)inputStream);\n     }\n     \n-    public static void closeQuietly(final OutputStream output) {\n-        closeQuietly((Closeable)output);\n+    public static void closeQuietly(final OutputStream outputStream) {\n+        closeQuietly((Closeable)outputStream);\n     }\n     \n     public static void closeQuietly(final Reader reader) {\n         closeQuietly((Closeable)reader);\n     }\n     \n     public static void closeQuietly(final Selector selector) {\n@@ -197,268 +197,267 @@\n         closeQuietly((Closeable)socket);\n     }\n     \n     public static void closeQuietly(final Writer writer) {\n         closeQuietly((Closeable)writer);\n     }\n     \n-    public static long consume(final InputStream input) throws IOException {\n-        return copyLarge(input, (OutputStream)NullOutputStream.NULL_OUTPUT_STREAM, getByteArray());\n+    public static long consume(final InputStream inputStream) throws IOException {\n+        return copyLarge(inputStream, (OutputStream)NullOutputStream.NULL_OUTPUT_STREAM, getByteArray());\n     }\n     \n-    public static boolean contentEquals(final InputStream input1, final InputStream input2) throws IOException {\n-        if (input1 == input2) {\n+    public static boolean contentEquals(final InputStream inputStream, final InputStream inputStream2) throws IOException {\n+        if (inputStream == inputStream2) {\n             return true;\n         }\n-        if (input1 == null || input2 == null) {\n+        if (inputStream == null || inputStream2 == null) {\n             return false;\n         }\n-        final byte[] array1 = getByteArray();\n-        final byte[] array2 = byteArray();\n+        final byte[] byteArray = getByteArray();\n+        final byte[] byteArray2 = byteArray();\n         while (true) {\n-            int pos1 = 0;\n-            int pos2 = 0;\n-            for (int index = 0; index < 8192; ++index) {\n-                if (pos1 == index) {\n-                    int count1;\n+            int off = 0;\n+            int off2 = 0;\n+            for (int i = 0; i < 8192; ++i) {\n+                if (off == i) {\n+                    int j;\n                     do {\n-                        count1 = input1.read(array1, pos1, 8192 - pos1);\n-                    } while (count1 == 0);\n-                    if (count1 == -1) {\n-                        return pos2 == index && input2.read() == -1;\n+                        j = inputStream.read(byteArray, off, 8192 - off);\n+                    } while (j == 0);\n+                    if (j == -1) {\n+                        return off2 == i && inputStream2.read() == -1;\n                     }\n-                    pos1 += count1;\n+                    off += j;\n                 }\n-                if (pos2 == index) {\n-                    int count2;\n+                if (off2 == i) {\n+                    int k;\n                     do {\n-                        count2 = input2.read(array2, pos2, 8192 - pos2);\n-                    } while (count2 == 0);\n-                    if (count2 == -1) {\n-                        return pos1 == index && input1.read() == -1;\n+                        k = inputStream2.read(byteArray2, off2, 8192 - off2);\n+                    } while (k == 0);\n+                    if (k == -1) {\n+                        return off == i && inputStream.read() == -1;\n                     }\n-                    pos2 += count2;\n+                    off2 += k;\n                 }\n-                if (array1[index] != array2[index]) {\n+                if (byteArray[i] != byteArray2[i]) {\n                     return false;\n                 }\n             }\n         }\n     }\n     \n-    public static boolean contentEquals(final Reader input1, final Reader input2) throws IOException {\n-        if (input1 == input2) {\n+    public static boolean contentEquals(final Reader reader, final Reader reader2) throws IOException {\n+        if (reader == reader2) {\n             return true;\n         }\n-        if (input1 == null || input2 == null) {\n+        if (reader == null || reader2 == null) {\n             return false;\n         }\n-        final char[] array1 = getCharArray();\n-        final char[] array2 = charArray();\n+        final char[] charArray = getCharArray();\n+        final char[] charArray2 = charArray();\n         while (true) {\n-            int pos1 = 0;\n-            int pos2 = 0;\n-            for (int index = 0; index < 8192; ++index) {\n-                if (pos1 == index) {\n-                    int count1;\n+            int n = 0;\n+            int n2 = 0;\n+            for (int i = 0; i < 8192; ++i) {\n+                if (n == i) {\n+                    int j;\n                     do {\n-                        count1 = input1.read(array1, pos1, 8192 - pos1);\n-                    } while (count1 == 0);\n-                    if (count1 == -1) {\n-                        return pos2 == index && input2.read() == -1;\n+                        j = reader.read(charArray, n, 8192 - n);\n+                    } while (j == 0);\n+                    if (j == -1) {\n+                        return n2 == i && reader2.read() == -1;\n                     }\n-                    pos1 += count1;\n+                    n += j;\n                 }\n-                if (pos2 == index) {\n-                    int count2;\n+                if (n2 == i) {\n+                    int k;\n                     do {\n-                        count2 = input2.read(array2, pos2, 8192 - pos2);\n-                    } while (count2 == 0);\n-                    if (count2 == -1) {\n-                        return pos1 == index && input1.read() == -1;\n+                        k = reader2.read(charArray2, n2, 8192 - n2);\n+                    } while (k == 0);\n+                    if (k == -1) {\n+                        return n == i && reader.read() == -1;\n                     }\n-                    pos2 += count2;\n+                    n2 += k;\n                 }\n-                if (array1[index] != array2[index]) {\n+                if (charArray[i] != charArray2[i]) {\n                     return false;\n                 }\n             }\n         }\n     }\n     \n-    public static boolean contentEqualsIgnoreEOL(final Reader reader1, final Reader reader2) throws IOException {\n-        if (reader1 == reader2) {\n+    public static boolean contentEqualsIgnoreEOL(final Reader reader, final Reader reader2) throws IOException {\n+        if (reader == reader2) {\n             return true;\n         }\n-        if (reader1 == null ^ reader2 == null) {\n+        if (reader == null ^ reader2 == null) {\n             return false;\n         }\n-        BufferedReader br1;\n-        BufferedReader br2;\n-        String line1;\n-        String line2;\n-        for (br1 = toBufferedReader(reader1), br2 = toBufferedReader(reader2), line1 = br1.readLine(), line2 = br2.readLine(); line1 != null && line1.equals(line2); line1 = br1.readLine(), line2 = br2.readLine()) {}\n-        return Objects.equals(line1, line2);\n+        BufferedReader bufferedReader;\n+        BufferedReader bufferedReader2;\n+        String a;\n+        String s;\n+        for (bufferedReader = toBufferedReader(reader), bufferedReader2 = toBufferedReader(reader2), a = bufferedReader.readLine(), s = bufferedReader2.readLine(); a != null && a.equals(s); a = bufferedReader.readLine(), s = bufferedReader2.readLine()) {}\n+        return Objects.equals(a, s);\n     }\n     \n     public static int copy(final InputStream inputStream, final OutputStream outputStream) throws IOException {\n-        final long count = copyLarge(inputStream, outputStream);\n-        if (count > 2147483647L) {\n+        final long copyLarge = copyLarge(inputStream, outputStream);\n+        if (copyLarge > 2147483647L) {\n             return -1;\n         }\n-        return (int)count;\n+        return (int)copyLarge;\n     }\n     \n-    public static long copy(final InputStream inputStream, final OutputStream outputStream, final int bufferSize) throws IOException {\n-        return copyLarge(inputStream, outputStream, byteArray(bufferSize));\n+    public static long copy(final InputStream inputStream, final OutputStream outputStream, final int n) throws IOException {\n+        return copyLarge(inputStream, outputStream, byteArray(n));\n     }\n     \n     @Deprecated\n-    public static void copy(final InputStream input, final Writer writer) throws IOException {\n-        copy(input, writer, Charset.defaultCharset());\n+    public static void copy(final InputStream inputStream, final Writer writer) throws IOException {\n+        copy(inputStream, writer, Charset.defaultCharset());\n     }\n     \n-    public static void copy(final InputStream input, final Writer writer, final Charset inputCharset) throws IOException {\n-        final InputStreamReader reader = new InputStreamReader(input, Charsets.toCharset(inputCharset));\n-        copy(reader, writer);\n+    public static void copy(final InputStream in, final Writer writer, final Charset charset) throws IOException {\n+        copy(new InputStreamReader(in, Charsets.toCharset(charset)), writer);\n     }\n     \n-    public static void copy(final InputStream input, final Writer writer, final String inputCharsetName) throws IOException {\n-        copy(input, writer, Charsets.toCharset(inputCharsetName));\n+    public static void copy(final InputStream inputStream, final Writer writer, final String s) throws IOException {\n+        copy(inputStream, writer, Charsets.toCharset(s));\n     }\n     \n-    public static long copy(final Reader reader, final Appendable output) throws IOException {\n-        return copy(reader, output, CharBuffer.allocate(8192));\n+    public static long copy(final Reader reader, final Appendable appendable) throws IOException {\n+        return copy(reader, appendable, CharBuffer.allocate(8192));\n     }\n     \n-    public static long copy(final Reader reader, final Appendable output, final CharBuffer buffer) throws IOException {\n-        long count = 0L;\n-        int n;\n-        while (-1 != (n = reader.read(buffer))) {\n-            buffer.flip();\n-            output.append(buffer, 0, n);\n-            count += n;\n+    public static long copy(final Reader reader, final Appendable appendable, final CharBuffer target) throws IOException {\n+        long n = 0L;\n+        int read;\n+        while (-1 != (read = reader.read(target))) {\n+            target.flip();\n+            appendable.append(target, 0, read);\n+            n += read;\n         }\n-        return count;\n+        return n;\n     }\n     \n     @Deprecated\n-    public static void copy(final Reader reader, final OutputStream output) throws IOException {\n-        copy(reader, output, Charset.defaultCharset());\n+    public static void copy(final Reader reader, final OutputStream outputStream) throws IOException {\n+        copy(reader, outputStream, Charset.defaultCharset());\n     }\n     \n-    public static void copy(final Reader reader, final OutputStream output, final Charset outputCharset) throws IOException {\n-        final OutputStreamWriter writer = new OutputStreamWriter(output, Charsets.toCharset(outputCharset));\n-        copy(reader, writer);\n-        writer.flush();\n+    public static void copy(final Reader reader, final OutputStream out, final Charset charset) throws IOException {\n+        final OutputStreamWriter outputStreamWriter = new OutputStreamWriter(out, Charsets.toCharset(charset));\n+        copy(reader, outputStreamWriter);\n+        outputStreamWriter.flush();\n     }\n     \n-    public static void copy(final Reader reader, final OutputStream output, final String outputCharsetName) throws IOException {\n-        copy(reader, output, Charsets.toCharset(outputCharsetName));\n+    public static void copy(final Reader reader, final OutputStream outputStream, final String s) throws IOException {\n+        copy(reader, outputStream, Charsets.toCharset(s));\n     }\n     \n     public static int copy(final Reader reader, final Writer writer) throws IOException {\n-        final long count = copyLarge(reader, writer);\n-        if (count > 2147483647L) {\n+        final long copyLarge = copyLarge(reader, writer);\n+        if (copyLarge > 2147483647L) {\n             return -1;\n         }\n-        return (int)count;\n+        return (int)copyLarge;\n     }\n     \n-    public static long copy(final URL url, final File file) throws IOException {\n-        try (final OutputStream outputStream = Files.newOutputStream(((File)Objects.requireNonNull(file, \"file\")).toPath(), new OpenOption[0])) {\n+    public static long copy(final URL url, final File obj) throws IOException {\n+        try (final OutputStream outputStream = Files.newOutputStream(((File)Objects.requireNonNull(obj, \"file\")).toPath(), new OpenOption[0])) {\n             return copy(url, outputStream);\n         }\n     }\n     \n-    public static long copy(final URL url, final OutputStream outputStream) throws IOException {\n-        try (final InputStream inputStream = ((URL)Objects.requireNonNull(url, \"url\")).openStream()) {\n-            return copyLarge(inputStream, outputStream);\n+    public static long copy(final URL obj, final OutputStream outputStream) throws IOException {\n+        try (final InputStream openStream = ((URL)Objects.requireNonNull(obj, \"url\")).openStream()) {\n+            return copyLarge(openStream, outputStream);\n         }\n     }\n     \n     public static long copyLarge(final InputStream inputStream, final OutputStream outputStream) throws IOException {\n         return copy(inputStream, outputStream, 8192);\n     }\n     \n-    public static long copyLarge(final InputStream inputStream, final OutputStream outputStream, final byte[] buffer) throws IOException {\n-        Objects.requireNonNull(inputStream, \"inputStream\");\n-        Objects.requireNonNull(outputStream, \"outputStream\");\n-        long count = 0L;\n-        int n;\n-        while (-1 != (n = inputStream.read(buffer))) {\n-            outputStream.write(buffer, 0, n);\n-            count += n;\n+    public static long copyLarge(final InputStream obj, final OutputStream obj2, final byte[] array) throws IOException {\n+        Objects.requireNonNull(obj, \"inputStream\");\n+        Objects.requireNonNull(obj2, \"outputStream\");\n+        long n = 0L;\n+        int read;\n+        while (-1 != (read = obj.read(array))) {\n+            obj2.write(array, 0, read);\n+            n += read;\n         }\n-        return count;\n+        return n;\n     }\n     \n-    public static long copyLarge(final InputStream input, final OutputStream output, final long inputOffset, final long length) throws IOException {\n-        return copyLarge(input, output, inputOffset, length, getByteArray());\n+    public static long copyLarge(final InputStream inputStream, final OutputStream outputStream, final long n, final long n2) throws IOException {\n+        return copyLarge(inputStream, outputStream, n, n2, getByteArray());\n     }\n     \n-    public static long copyLarge(final InputStream input, final OutputStream output, final long inputOffset, final long length, final byte[] buffer) throws IOException {\n-        if (inputOffset > 0L) {\n-            skipFully(input, inputOffset);\n+    public static long copyLarge(final InputStream inputStream, final OutputStream outputStream, final long n, final long n2, final byte[] array) throws IOException {\n+        if (n > 0L) {\n+            skipFully(inputStream, n);\n         }\n-        if (length == 0L) {\n+        if (n2 == 0L) {\n             return 0L;\n         }\n-        int bytesToRead;\n-        final int bufferLength = bytesToRead = buffer.length;\n-        if (length > 0L && length < bufferLength) {\n-            bytesToRead = (int)length;\n+        int length;\n+        final int n3 = length = array.length;\n+        if (n2 > 0L && n2 < n3) {\n+            length = (int)n2;\n         }\n-        long totalRead;\n+        long n4;\n         int read;\n-        for (totalRead = 0L; bytesToRead > 0 && -1 != (read = input.read(buffer, 0, bytesToRead)); bytesToRead = (int)Math.min(length - totalRead, bufferLength)) {\n-            output.write(buffer, 0, read);\n-            totalRead += read;\n-            if (length > 0L) {}\n+        for (n4 = 0L; length > 0 && -1 != (read = inputStream.read(array, 0, length)); length = (int)Math.min(n2 - n4, n3)) {\n+            outputStream.write(array, 0, read);\n+            n4 += read;\n+            if (n2 > 0L) {}\n         }\n-        return totalRead;\n+        return n4;\n     }\n     \n     public static long copyLarge(final Reader reader, final Writer writer) throws IOException {\n         return copyLarge(reader, writer, getCharArray());\n     }\n     \n-    public static long copyLarge(final Reader reader, final Writer writer, final char[] buffer) throws IOException {\n-        long count = 0L;\n-        int n;\n-        while (-1 != (n = reader.read(buffer))) {\n-            writer.write(buffer, 0, n);\n-            count += n;\n+    public static long copyLarge(final Reader reader, final Writer writer, final char[] cbuf) throws IOException {\n+        long n = 0L;\n+        int read;\n+        while (-1 != (read = reader.read(cbuf))) {\n+            writer.write(cbuf, 0, read);\n+            n += read;\n         }\n-        return count;\n+        return n;\n     }\n     \n-    public static long copyLarge(final Reader reader, final Writer writer, final long inputOffset, final long length) throws IOException {\n-        return copyLarge(reader, writer, inputOffset, length, getCharArray());\n+    public static long copyLarge(final Reader reader, final Writer writer, final long n, final long n2) throws IOException {\n+        return copyLarge(reader, writer, n, n2, getCharArray());\n     }\n     \n-    public static long copyLarge(final Reader reader, final Writer writer, final long inputOffset, final long length, final char[] buffer) throws IOException {\n-        if (inputOffset > 0L) {\n-            skipFully(reader, inputOffset);\n+    public static long copyLarge(final Reader reader, final Writer writer, final long n, final long n2, final char[] array) throws IOException {\n+        if (n > 0L) {\n+            skipFully(reader, n);\n         }\n-        if (length == 0L) {\n+        if (n2 == 0L) {\n             return 0L;\n         }\n-        int bytesToRead = buffer.length;\n-        if (length > 0L && length < buffer.length) {\n-            bytesToRead = (int)length;\n+        int length = array.length;\n+        if (n2 > 0L && n2 < array.length) {\n+            length = (int)n2;\n         }\n-        long totalRead;\n+        long n3;\n         int read;\n-        for (totalRead = 0L; bytesToRead > 0 && -1 != (read = reader.read(buffer, 0, bytesToRead)); bytesToRead = (int)Math.min(length - totalRead, buffer.length)) {\n-            writer.write(buffer, 0, read);\n-            totalRead += read;\n-            if (length > 0L) {}\n+        for (n3 = 0L; length > 0 && -1 != (read = reader.read(array, 0, length)); length = (int)Math.min(n2 - n3, array.length)) {\n+            writer.write(array, 0, read);\n+            n3 += read;\n+            if (n2 > 0L) {}\n         }\n-        return totalRead;\n+        return n3;\n     }\n     \n     static byte[] getByteArray() {\n         return IOUtils.SKIP_BYTE_BUFFER.get();\n     }\n     \n     static char[] getCharArray() {\n@@ -469,621 +468,612 @@\n         return (array == null) ? 0 : array.length;\n     }\n     \n     public static int length(final char[] array) {\n         return (array == null) ? 0 : array.length;\n     }\n     \n-    public static int length(final CharSequence csq) {\n-        return (csq == null) ? 0 : csq.length();\n+    public static int length(final CharSequence charSequence) {\n+        return (charSequence == null) ? 0 : charSequence.length();\n     }\n     \n     public static int length(final Object[] array) {\n         return (array == null) ? 0 : array.length;\n     }\n     \n-    public static LineIterator lineIterator(final InputStream input, final Charset charset) {\n-        return new LineIterator((Reader)new InputStreamReader(input, Charsets.toCharset(charset)));\n+    public static LineIterator lineIterator(final InputStream in, final Charset charset) {\n+        return new LineIterator((Reader)new InputStreamReader(in, Charsets.toCharset(charset)));\n     }\n     \n-    public static LineIterator lineIterator(final InputStream input, final String charsetName) {\n-        return lineIterator(input, Charsets.toCharset(charsetName));\n+    public static LineIterator lineIterator(final InputStream inputStream, final String s) {\n+        return lineIterator(inputStream, Charsets.toCharset(s));\n     }\n     \n     public static LineIterator lineIterator(final Reader reader) {\n         return new LineIterator(reader);\n     }\n     \n-    public static int read(final InputStream input, final byte[] buffer) throws IOException {\n-        return read(input, buffer, 0, buffer.length);\n+    public static int read(final InputStream inputStream, final byte[] array) throws IOException {\n+        return read(inputStream, array, 0, array.length);\n     }\n     \n-    public static int read(final InputStream input, final byte[] buffer, final int offset, final int length) throws IOException {\n-        if (length < 0) {\n-            throw new IllegalArgumentException(\"Length must not be negative: \" + length);\n-        }\n-        int remaining;\n-        int count;\n-        for (remaining = length; remaining > 0; remaining -= count) {\n-            final int location = length - remaining;\n-            count = input.read(buffer, offset + location, remaining);\n-            if (-1 == count) {\n+    public static int read(final InputStream inputStream, final byte[] b, final int n, final int i) throws IOException {\n+        if (i < 0) {\n+            throw new IllegalArgumentException(\"Length must not be negative: \" + i);\n+        }\n+        int j;\n+        int read;\n+        for (j = i; j > 0; j -= read) {\n+            read = inputStream.read(b, n + (i - j), j);\n+            if (-1 == read) {\n                 break;\n             }\n         }\n-        return length - remaining;\n+        return i - j;\n     }\n     \n-    public static int read(final ReadableByteChannel input, final ByteBuffer buffer) throws IOException {\n-        final int length = buffer.remaining();\n-        while (buffer.remaining() > 0) {\n-            final int count = input.read(buffer);\n-            if (-1 == count) {\n-                break;\n-            }\n-        }\n-        return length - buffer.remaining();\n+    public static int read(final ReadableByteChannel readableByteChannel, final ByteBuffer byteBuffer) throws IOException {\n+        final int remaining = byteBuffer.remaining();\n+        while (byteBuffer.remaining() > 0 && -1 != readableByteChannel.read(byteBuffer)) {}\n+        return remaining - byteBuffer.remaining();\n     }\n     \n-    public static int read(final Reader reader, final char[] buffer) throws IOException {\n-        return read(reader, buffer, 0, buffer.length);\n+    public static int read(final Reader reader, final char[] array) throws IOException {\n+        return read(reader, array, 0, array.length);\n     }\n     \n-    public static int read(final Reader reader, final char[] buffer, final int offset, final int length) throws IOException {\n-        if (length < 0) {\n-            throw new IllegalArgumentException(\"Length must not be negative: \" + length);\n+    public static int read(final Reader reader, final char[] array, final int n, final int i) throws IOException {\n+        if (i < 0) {\n+            throw new IllegalArgumentException(\"Length must not be negative: \" + i);\n         }\n-        int remaining;\n-        int count;\n-        for (remaining = length; remaining > 0; remaining -= count) {\n-            final int location = length - remaining;\n-            count = reader.read(buffer, offset + location, remaining);\n-            if (-1 == count) {\n+        int j;\n+        int read;\n+        for (j = i; j > 0; j -= read) {\n+            read = reader.read(array, n + (i - j), j);\n+            if (-1 == read) {\n                 break;\n             }\n         }\n-        return length - remaining;\n+        return i - j;\n     }\n     \n-    public static void readFully(final InputStream input, final byte[] buffer) throws IOException {\n-        readFully(input, buffer, 0, buffer.length);\n+    public static void readFully(final InputStream inputStream, final byte[] array) throws IOException {\n+        readFully(inputStream, array, 0, array.length);\n     }\n     \n-    public static void readFully(final InputStream input, final byte[] buffer, final int offset, final int length) throws IOException {\n-        final int actual = read(input, buffer, offset, length);\n-        if (actual != length) {\n-            throw new EOFException(\"Length to read: \" + length + \" actual: \" + actual);\n+    public static void readFully(final InputStream inputStream, final byte[] array, final int n, final int i) throws IOException {\n+        final int read = read(inputStream, array, n, i);\n+        if (read != i) {\n+            throw new EOFException(\"Length to read: \" + i + \" actual: \" + read);\n         }\n     }\n     \n-    public static byte[] readFully(final InputStream input, final int length) throws IOException {\n-        final byte[] buffer = byteArray(length);\n-        readFully(input, buffer, 0, buffer.length);\n-        return buffer;\n+    public static byte[] readFully(final InputStream inputStream, final int n) throws IOException {\n+        final byte[] byteArray = byteArray(n);\n+        readFully(inputStream, byteArray, 0, byteArray.length);\n+        return byteArray;\n     }\n     \n-    public static void readFully(final ReadableByteChannel input, final ByteBuffer buffer) throws IOException {\n-        final int expected = buffer.remaining();\n-        final int actual = read(input, buffer);\n-        if (actual != expected) {\n-            throw new EOFException(\"Length to read: \" + expected + \" actual: \" + actual);\n+    public static void readFully(final ReadableByteChannel readableByteChannel, final ByteBuffer byteBuffer) throws IOException {\n+        final int remaining = byteBuffer.remaining();\n+        final int read = read(readableByteChannel, byteBuffer);\n+        if (read != remaining) {\n+            throw new EOFException(\"Length to read: \" + remaining + \" actual: \" + read);\n         }\n     }\n     \n-    public static void readFully(final Reader reader, final char[] buffer) throws IOException {\n-        readFully(reader, buffer, 0, buffer.length);\n+    public static void readFully(final Reader reader, final char[] array) throws IOException {\n+        readFully(reader, array, 0, array.length);\n     }\n     \n-    public static void readFully(final Reader reader, final char[] buffer, final int offset, final int length) throws IOException {\n-        final int actual = read(reader, buffer, offset, length);\n-        if (actual != length) {\n-            throw new EOFException(\"Length to read: \" + length + \" actual: \" + actual);\n+    public static void readFully(final Reader reader, final char[] array, final int n, final int i) throws IOException {\n+        final int read = read(reader, array, n, i);\n+        if (read != i) {\n+            throw new EOFException(\"Length to read: \" + i + \" actual: \" + read);\n         }\n     }\n     \n     @Deprecated\n-    public static List<String> readLines(final InputStream input) throws IOException {\n-        return readLines(input, Charset.defaultCharset());\n+    public static List<String> readLines(final InputStream inputStream) throws IOException {\n+        return readLines(inputStream, Charset.defaultCharset());\n     }\n     \n-    public static List<String> readLines(final InputStream input, final Charset charset) throws IOException {\n-        final InputStreamReader reader = new InputStreamReader(input, Charsets.toCharset(charset));\n-        return readLines(reader);\n+    public static List<String> readLines(final InputStream in, final Charset charset) throws IOException {\n+        return readLines(new InputStreamReader(in, Charsets.toCharset(charset)));\n     }\n     \n-    public static List<String> readLines(final InputStream input, final String charsetName) throws IOException {\n-        return readLines(input, Charsets.toCharset(charsetName));\n+    public static List<String> readLines(final InputStream inputStream, final String s) throws IOException {\n+        return readLines(inputStream, Charsets.toCharset(s));\n     }\n     \n     public static List<String> readLines(final Reader reader) throws IOException {\n-        final BufferedReader bufReader = toBufferedReader(reader);\n-        final List<String> list = new ArrayList<String>();\n+        final BufferedReader bufferedReader = toBufferedReader(reader);\n+        final ArrayList list = new ArrayList();\n         String line;\n-        while ((line = bufReader.readLine()) != null) {\n+        while ((line = bufferedReader.readLine()) != null) {\n             list.add(line);\n         }\n         return list;\n     }\n     \n-    public static byte[] resourceToByteArray(final String name) throws IOException {\n-        return resourceToByteArray(name, null);\n+    public static byte[] resourceToByteArray(final String s) throws IOException {\n+        return resourceToByteArray(s, null);\n     }\n     \n-    public static byte[] resourceToByteArray(final String name, final ClassLoader classLoader) throws IOException {\n-        return toByteArray(resourceToURL(name, classLoader));\n+    public static byte[] resourceToByteArray(final String s, final ClassLoader classLoader) throws IOException {\n+        return toByteArray(resourceToURL(s, classLoader));\n     }\n     \n-    public static String resourceToString(final String name, final Charset charset) throws IOException {\n-        return resourceToString(name, charset, null);\n+    public static String resourceToString(final String s, final Charset charset) throws IOException {\n+        return resourceToString(s, charset, null);\n     }\n     \n-    public static String resourceToString(final String name, final Charset charset, final ClassLoader classLoader) throws IOException {\n-        return toString(resourceToURL(name, classLoader), charset);\n+    public static String resourceToString(final String s, final Charset charset, final ClassLoader classLoader) throws IOException {\n+        return toString(resourceToURL(s, classLoader), charset);\n     }\n     \n-    public static URL resourceToURL(final String name) throws IOException {\n-        return resourceToURL(name, null);\n+    public static URL resourceToURL(final String s) throws IOException {\n+        return resourceToURL(s, null);\n     }\n     \n-    public static URL resourceToURL(final String name, final ClassLoader classLoader) throws IOException {\n-        final URL resource = (classLoader == null) ? IOUtils.class.getResource(name) : classLoader.getResource(name);\n-        if (resource == null) {\n-            throw new IOException(\"Resource not found: \" + name);\n+    public static URL resourceToURL(final String str, final ClassLoader classLoader) throws IOException {\n+        final URL url = (classLoader == null) ? IOUtils.class.getResource(str) : classLoader.getResource(str);\n+        if (url == null) {\n+            throw new IOException(\"Resource not found: \" + str);\n         }\n-        return resource;\n+        return url;\n     }\n     \n-    public static long skip(final InputStream input, final long toSkip) throws IOException {\n-        if (toSkip < 0L) {\n-            throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);\n+    public static long skip(final InputStream inputStream, final long lng) throws IOException {\n+        if (lng < 0L) {\n+            throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + lng);\n         }\n-        long remain;\n+        long a;\n         long n;\n-        for (remain = toSkip; remain > 0L; remain -= n) {\n+        for (a = lng; a > 0L; a -= n) {\n             final byte[] byteArray = getByteArray();\n-            n = input.read(byteArray, 0, (int)Math.min(remain, byteArray.length));\n+            n = inputStream.read(byteArray, 0, (int)Math.min(a, byteArray.length));\n             if (n < 0L) {\n                 break;\n             }\n         }\n-        return toSkip - remain;\n+        return lng - a;\n     }\n     \n-    public static long skip(final ReadableByteChannel input, final long toSkip) throws IOException {\n-        if (toSkip < 0L) {\n-            throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);\n-        }\n-        final ByteBuffer skipByteBuffer = ByteBuffer.allocate((int)Math.min(toSkip, 8192L));\n-        long remain;\n-        int n;\n-        for (remain = toSkip; remain > 0L; remain -= n) {\n-            skipByteBuffer.position(0);\n-            skipByteBuffer.limit((int)Math.min(remain, 8192L));\n-            n = input.read(skipByteBuffer);\n-            if (n == -1) {\n+    public static long skip(final ReadableByteChannel readableByteChannel, final long n) throws IOException {\n+        if (n < 0L) {\n+            throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + n);\n+        }\n+        final ByteBuffer allocate = ByteBuffer.allocate((int)Math.min(n, 8192L));\n+        long a;\n+        int read;\n+        for (a = n; a > 0L; a -= read) {\n+            allocate.position(0);\n+            allocate.limit((int)Math.min(a, 8192L));\n+            read = readableByteChannel.read(allocate);\n+            if (read == -1) {\n                 break;\n             }\n         }\n-        return toSkip - remain;\n+        return n - a;\n     }\n     \n-    public static long skip(final Reader reader, final long toSkip) throws IOException {\n-        if (toSkip < 0L) {\n-            throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);\n+    public static long skip(final Reader reader, final long lng) throws IOException {\n+        if (lng < 0L) {\n+            throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + lng);\n         }\n-        long remain;\n+        long a;\n         long n;\n-        for (remain = toSkip; remain > 0L; remain -= n) {\n+        for (a = lng; a > 0L; a -= n) {\n             final char[] charArray = getCharArray();\n-            n = reader.read(charArray, 0, (int)Math.min(remain, charArray.length));\n+            n = reader.read(charArray, 0, (int)Math.min(a, charArray.length));\n             if (n < 0L) {\n                 break;\n             }\n         }\n-        return toSkip - remain;\n+        return lng - a;\n     }\n     \n-    public static void skipFully(final InputStream input, final long toSkip) throws IOException {\n-        if (toSkip < 0L) {\n-            throw new IllegalArgumentException(\"Bytes to skip must not be negative: \" + toSkip);\n+    public static void skipFully(final InputStream inputStream, final long n) throws IOException {\n+        if (n < 0L) {\n+            throw new IllegalArgumentException(\"Bytes to skip must not be negative: \" + n);\n         }\n-        final long skipped = skip(input, toSkip);\n-        if (skipped != toSkip) {\n-            throw new EOFException(\"Bytes to skip: \" + toSkip + \" actual: \" + skipped);\n+        final long skip = skip(inputStream, n);\n+        if (skip != n) {\n+            throw new EOFException(\"Bytes to skip: \" + n + \" actual: \" + skip);\n         }\n     }\n     \n-    public static void skipFully(final ReadableByteChannel input, final long toSkip) throws IOException {\n-        if (toSkip < 0L) {\n-            throw new IllegalArgumentException(\"Bytes to skip must not be negative: \" + toSkip);\n+    public static void skipFully(final ReadableByteChannel readableByteChannel, final long n) throws IOException {\n+        if (n < 0L) {\n+            throw new IllegalArgumentException(\"Bytes to skip must not be negative: \" + n);\n         }\n-        final long skipped = skip(input, toSkip);\n-        if (skipped != toSkip) {\n-            throw new EOFException(\"Bytes to skip: \" + toSkip + \" actual: \" + skipped);\n+        final long skip = skip(readableByteChannel, n);\n+        if (skip != n) {\n+            throw new EOFException(\"Bytes to skip: \" + n + \" actual: \" + skip);\n         }\n     }\n     \n-    public static void skipFully(final Reader reader, final long toSkip) throws IOException {\n-        final long skipped = skip(reader, toSkip);\n-        if (skipped != toSkip) {\n-            throw new EOFException(\"Chars to skip: \" + toSkip + \" actual: \" + skipped);\n+    public static void skipFully(final Reader reader, final long lng) throws IOException {\n+        final long skip = skip(reader, lng);\n+        if (skip != lng) {\n+            throw new EOFException(\"Chars to skip: \" + lng + \" actual: \" + skip);\n         }\n     }\n     \n-    public static InputStream toBufferedInputStream(final InputStream input) throws IOException {\n-        return ByteArrayOutputStream.toBufferedInputStream(input);\n+    public static InputStream toBufferedInputStream(final InputStream inputStream) throws IOException {\n+        return ByteArrayOutputStream.toBufferedInputStream(inputStream);\n     }\n     \n-    public static InputStream toBufferedInputStream(final InputStream input, final int size) throws IOException {\n-        return ByteArrayOutputStream.toBufferedInputStream(input, size);\n+    public static InputStream toBufferedInputStream(final InputStream inputStream, final int n) throws IOException {\n+        return ByteArrayOutputStream.toBufferedInputStream(inputStream, n);\n     }\n     \n-    public static BufferedReader toBufferedReader(final Reader reader) {\n-        return (reader instanceof BufferedReader) ? ((BufferedReader)reader) : new BufferedReader(reader);\n+    public static BufferedReader toBufferedReader(final Reader in) {\n+        return (in instanceof BufferedReader) ? ((BufferedReader)in) : new BufferedReader(in);\n     }\n     \n-    public static BufferedReader toBufferedReader(final Reader reader, final int size) {\n-        return (reader instanceof BufferedReader) ? ((BufferedReader)reader) : new BufferedReader(reader, size);\n+    public static BufferedReader toBufferedReader(final Reader in, final int sz) {\n+        return (in instanceof BufferedReader) ? ((BufferedReader)in) : new BufferedReader(in, sz);\n     }\n     \n     public static byte[] toByteArray(final InputStream inputStream) throws IOException {\n-        try (final UnsynchronizedByteArrayOutputStream ubaOutput = new UnsynchronizedByteArrayOutputStream();\n-             final ThresholdingOutputStream thresholdOuput = new ThresholdingOutputStream(Integer.MAX_VALUE, os -> {\n+        try (final UnsynchronizedByteArrayOutputStream unsynchronizedByteArrayOutputStream = new UnsynchronizedByteArrayOutputStream();\n+             final ThresholdingOutputStream thresholdingOutputStream = new ThresholdingOutputStream(Integer.MAX_VALUE, thresholdingOutputStream -> {\n             throw new IllegalArgumentException(String.format(\"Cannot read more than %,d into a byte array\", Integer.valueOf(Integer.MAX_VALUE)));\n-        }, os -> ubaOutput)) {\n-            copy(inputStream, (OutputStream)thresholdOuput);\n-            return ubaOutput.toByteArray();\n+        }, thresholdingOutputStream -> unsynchronizedByteArrayOutputStream)) {\n+            copy(inputStream, (OutputStream)thresholdingOutputStream);\n+            return unsynchronizedByteArrayOutputStream.toByteArray();\n         }\n     }\n     \n-    public static byte[] toByteArray(final InputStream input, final int size) throws IOException {\n-        if (size < 0) {\n-            throw new IllegalArgumentException(\"Size must be equal or greater than zero: \" + size);\n+    public static byte[] toByteArray(final InputStream inputStream, final int n) throws IOException {\n+        if (n < 0) {\n+            throw new IllegalArgumentException(\"Size must be equal or greater than zero: \" + n);\n         }\n-        if (size == 0) {\n+        if (n == 0) {\n             return IOUtils.EMPTY_BYTE_ARRAY;\n         }\n-        byte[] data;\n-        int offset;\n+        byte[] byteArray;\n+        int n2;\n         int read;\n-        for (data = byteArray(size), offset = 0; offset < size && (read = input.read(data, offset, size - offset)) != -1; offset += read) {}\n-        if (offset != size) {\n-            throw new IOException(\"Unexpected read size, current: \" + offset + \", expected: \" + size);\n+        for (byteArray = byteArray(n), n2 = 0; n2 < n && (read = inputStream.read(byteArray, n2, n - n2)) != -1; n2 += read) {}\n+        if (n2 != n) {\n+            throw new IOException(\"Unexpected read size, current: \" + n2 + \", expected: \" + n);\n         }\n-        return data;\n+        return byteArray;\n     }\n     \n-    public static byte[] toByteArray(final InputStream input, final long size) throws IOException {\n-        if (size > 2147483647L) {\n-            throw new IllegalArgumentException(\"Size cannot be greater than Integer max value: \" + size);\n+    public static byte[] toByteArray(final InputStream inputStream, final long lng) throws IOException {\n+        if (lng > 2147483647L) {\n+            throw new IllegalArgumentException(\"Size cannot be greater than Integer max value: \" + lng);\n         }\n-        return toByteArray(input, (int)size);\n+        return toByteArray(inputStream, (int)lng);\n     }\n     \n     @Deprecated\n     public static byte[] toByteArray(final Reader reader) throws IOException {\n         return toByteArray(reader, Charset.defaultCharset());\n     }\n     \n     public static byte[] toByteArray(final Reader reader, final Charset charset) throws IOException {\n-        try (final ByteArrayOutputStream output = new ByteArrayOutputStream()) {\n-            copy(reader, (OutputStream)output, charset);\n-            return output.toByteArray();\n+        try (final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) {\n+            copy(reader, (OutputStream)byteArrayOutputStream, charset);\n+            return byteArrayOutputStream.toByteArray();\n         }\n     }\n     \n-    public static byte[] toByteArray(final Reader reader, final String charsetName) throws IOException {\n-        return toByteArray(reader, Charsets.toCharset(charsetName));\n+    public static byte[] toByteArray(final Reader reader, final String s) throws IOException {\n+        return toByteArray(reader, Charsets.toCharset(s));\n     }\n     \n     @Deprecated\n-    public static byte[] toByteArray(final String input) {\n-        return input.getBytes(Charset.defaultCharset());\n+    public static byte[] toByteArray(final String s) {\n+        return s.getBytes(Charset.defaultCharset());\n     }\n     \n     public static byte[] toByteArray(final URI uri) throws IOException {\n         return toByteArray(uri.toURL());\n     }\n     \n     public static byte[] toByteArray(final URL url) throws IOException {\n-        final URLConnection conn = url.openConnection();\n+        final URLConnection openConnection = url.openConnection();\n         try {\n-            return toByteArray(conn);\n+            return toByteArray(openConnection);\n         }\n         finally {\n-            close(conn);\n+            close(openConnection);\n         }\n     }\n     \n-    public static byte[] toByteArray(final URLConnection urlConn) throws IOException {\n-        try (final InputStream inputStream = urlConn.getInputStream()) {\n+    public static byte[] toByteArray(final URLConnection urlConnection) throws IOException {\n+        try (final InputStream inputStream = urlConnection.getInputStream()) {\n             return toByteArray(inputStream);\n         }\n     }\n     \n     @Deprecated\n     public static char[] toCharArray(final InputStream inputStream) throws IOException {\n         return toCharArray(inputStream, Charset.defaultCharset());\n     }\n     \n     public static char[] toCharArray(final InputStream inputStream, final Charset charset) throws IOException {\n-        final CharArrayWriter writer = new CharArrayWriter();\n-        copy(inputStream, writer, charset);\n-        return writer.toCharArray();\n+        final CharArrayWriter charArrayWriter = new CharArrayWriter();\n+        copy(inputStream, charArrayWriter, charset);\n+        return charArrayWriter.toCharArray();\n     }\n     \n-    public static char[] toCharArray(final InputStream inputStream, final String charsetName) throws IOException {\n-        return toCharArray(inputStream, Charsets.toCharset(charsetName));\n+    public static char[] toCharArray(final InputStream inputStream, final String s) throws IOException {\n+        return toCharArray(inputStream, Charsets.toCharset(s));\n     }\n     \n     public static char[] toCharArray(final Reader reader) throws IOException {\n-        final CharArrayWriter sw = new CharArrayWriter();\n-        copy(reader, sw);\n-        return sw.toCharArray();\n+        final CharArrayWriter charArrayWriter = new CharArrayWriter();\n+        copy(reader, charArrayWriter);\n+        return charArrayWriter.toCharArray();\n     }\n     \n     @Deprecated\n-    public static InputStream toInputStream(final CharSequence input) {\n-        return toInputStream(input, Charset.defaultCharset());\n+    public static InputStream toInputStream(final CharSequence charSequence) {\n+        return toInputStream(charSequence, Charset.defaultCharset());\n     }\n     \n-    public static InputStream toInputStream(final CharSequence input, final Charset charset) {\n-        return toInputStream(input.toString(), charset);\n+    public static InputStream toInputStream(final CharSequence charSequence, final Charset charset) {\n+        return toInputStream(charSequence.toString(), charset);\n     }\n     \n-    public static InputStream toInputStream(final CharSequence input, final String charsetName) {\n-        return toInputStream(input, Charsets.toCharset(charsetName));\n+    public static InputStream toInputStream(final CharSequence charSequence, final String s) {\n+        return toInputStream(charSequence, Charsets.toCharset(s));\n     }\n     \n     @Deprecated\n-    public static InputStream toInputStream(final String input) {\n-        return toInputStream(input, Charset.defaultCharset());\n+    public static InputStream toInputStream(final String s) {\n+        return toInputStream(s, Charset.defaultCharset());\n     }\n     \n-    public static InputStream toInputStream(final String input, final Charset charset) {\n-        return new ByteArrayInputStream(input.getBytes(Charsets.toCharset(charset)));\n+    public static InputStream toInputStream(final String s, final Charset charset) {\n+        return new ByteArrayInputStream(s.getBytes(Charsets.toCharset(charset)));\n     }\n     \n-    public static InputStream toInputStream(final String input, final String charsetName) {\n-        final byte[] bytes = input.getBytes(Charsets.toCharset(charsetName));\n-        return new ByteArrayInputStream(bytes);\n+    public static InputStream toInputStream(final String s, final String s2) {\n+        return new ByteArrayInputStream(s.getBytes(Charsets.toCharset(s2)));\n     }\n     \n     @Deprecated\n-    public static String toString(final byte[] input) {\n-        return new String(input, Charset.defaultCharset());\n+    public static String toString(final byte[] bytes) {\n+        return new String(bytes, Charset.defaultCharset());\n     }\n     \n-    public static String toString(final byte[] input, final String charsetName) {\n-        return new String(input, Charsets.toCharset(charsetName));\n+    public static String toString(final byte[] bytes, final String s) {\n+        return new String(bytes, Charsets.toCharset(s));\n     }\n     \n     @Deprecated\n-    public static String toString(final InputStream input) throws IOException {\n-        return toString(input, Charset.defaultCharset());\n+    public static String toString(final InputStream inputStream) throws IOException {\n+        return toString(inputStream, Charset.defaultCharset());\n     }\n     \n-    public static String toString(final InputStream input, final Charset charset) throws IOException {\n-        try (final StringBuilderWriter sw = new StringBuilderWriter()) {\n-            copy(input, (Writer)sw, charset);\n-            return sw.toString();\n+    public static String toString(final InputStream inputStream, final Charset charset) throws IOException {\n+        try (final StringBuilderWriter stringBuilderWriter = new StringBuilderWriter()) {\n+            copy(inputStream, (Writer)stringBuilderWriter, charset);\n+            return stringBuilderWriter.toString();\n         }\n     }\n     \n-    public static String toString(final InputStream input, final String charsetName) throws IOException {\n-        return toString(input, Charsets.toCharset(charsetName));\n+    public static String toString(final InputStream inputStream, final String s) throws IOException {\n+        return toString(inputStream, Charsets.toCharset(s));\n     }\n     \n     public static String toString(final Reader reader) throws IOException {\n-        try (final StringBuilderWriter sw = new StringBuilderWriter()) {\n-            copy(reader, (Writer)sw);\n-            return sw.toString();\n+        try (final StringBuilderWriter stringBuilderWriter = new StringBuilderWriter()) {\n+            copy(reader, (Writer)stringBuilderWriter);\n+            return stringBuilderWriter.toString();\n         }\n     }\n     \n     @Deprecated\n     public static String toString(final URI uri) throws IOException {\n         return toString(uri, Charset.defaultCharset());\n     }\n     \n-    public static String toString(final URI uri, final Charset encoding) throws IOException {\n-        return toString(uri.toURL(), Charsets.toCharset(encoding));\n+    public static String toString(final URI uri, final Charset charset) throws IOException {\n+        return toString(uri.toURL(), Charsets.toCharset(charset));\n     }\n     \n-    public static String toString(final URI uri, final String charsetName) throws IOException {\n-        return toString(uri, Charsets.toCharset(charsetName));\n+    public static String toString(final URI uri, final String s) throws IOException {\n+        return toString(uri, Charsets.toCharset(s));\n     }\n     \n     @Deprecated\n     public static String toString(final URL url) throws IOException {\n         return toString(url, Charset.defaultCharset());\n     }\n     \n-    public static String toString(final URL url, final Charset encoding) throws IOException {\n-        try (final InputStream inputStream = url.openStream()) {\n-            return toString(inputStream, encoding);\n+    public static String toString(final URL url, final Charset charset) throws IOException {\n+        try (final InputStream openStream = url.openStream()) {\n+            return toString(openStream, charset);\n         }\n     }\n     \n-    public static String toString(final URL url, final String charsetName) throws IOException {\n-        return toString(url, Charsets.toCharset(charsetName));\n+    public static String toString(final URL url, final String s) throws IOException {\n+        return toString(url, Charsets.toCharset(s));\n     }\n     \n-    public static void write(final byte[] data, final OutputStream output) throws IOException {\n-        if (data != null) {\n-            output.write(data);\n+    public static void write(final byte[] b, final OutputStream outputStream) throws IOException {\n+        if (b != null) {\n+            outputStream.write(b);\n         }\n     }\n     \n     @Deprecated\n-    public static void write(final byte[] data, final Writer writer) throws IOException {\n-        write(data, writer, Charset.defaultCharset());\n+    public static void write(final byte[] array, final Writer writer) throws IOException {\n+        write(array, writer, Charset.defaultCharset());\n     }\n     \n-    public static void write(final byte[] data, final Writer writer, final Charset charset) throws IOException {\n-        if (data != null) {\n-            writer.write(new String(data, Charsets.toCharset(charset)));\n+    public static void write(final byte[] bytes, final Writer writer, final Charset charset) throws IOException {\n+        if (bytes != null) {\n+            writer.write(new String(bytes, Charsets.toCharset(charset)));\n         }\n     }\n     \n-    public static void write(final byte[] data, final Writer writer, final String charsetName) throws IOException {\n-        write(data, writer, Charsets.toCharset(charsetName));\n+    public static void write(final byte[] array, final Writer writer, final String s) throws IOException {\n+        write(array, writer, Charsets.toCharset(s));\n     }\n     \n     @Deprecated\n-    public static void write(final char[] data, final OutputStream output) throws IOException {\n-        write(data, output, Charset.defaultCharset());\n+    public static void write(final char[] array, final OutputStream outputStream) throws IOException {\n+        write(array, outputStream, Charset.defaultCharset());\n     }\n     \n-    public static void write(final char[] data, final OutputStream output, final Charset charset) throws IOException {\n-        if (data != null) {\n-            output.write(new String(data).getBytes(Charsets.toCharset(charset)));\n+    public static void write(final char[] value, final OutputStream outputStream, final Charset charset) throws IOException {\n+        if (value != null) {\n+            outputStream.write(new String(value).getBytes(Charsets.toCharset(charset)));\n         }\n     }\n     \n-    public static void write(final char[] data, final OutputStream output, final String charsetName) throws IOException {\n-        write(data, output, Charsets.toCharset(charsetName));\n+    public static void write(final char[] array, final OutputStream outputStream, final String s) throws IOException {\n+        write(array, outputStream, Charsets.toCharset(s));\n     }\n     \n-    public static void write(final char[] data, final Writer writer) throws IOException {\n-        if (data != null) {\n-            writer.write(data);\n+    public static void write(final char[] cbuf, final Writer writer) throws IOException {\n+        if (cbuf != null) {\n+            writer.write(cbuf);\n         }\n     }\n     \n     @Deprecated\n-    public static void write(final CharSequence data, final OutputStream output) throws IOException {\n-        write(data, output, Charset.defaultCharset());\n+    public static void write(final CharSequence charSequence, final OutputStream outputStream) throws IOException {\n+        write(charSequence, outputStream, Charset.defaultCharset());\n     }\n     \n-    public static void write(final CharSequence data, final OutputStream output, final Charset charset) throws IOException {\n-        if (data != null) {\n-            write(data.toString(), output, charset);\n+    public static void write(final CharSequence charSequence, final OutputStream outputStream, final Charset charset) throws IOException {\n+        if (charSequence != null) {\n+            write(charSequence.toString(), outputStream, charset);\n         }\n     }\n     \n-    public static void write(final CharSequence data, final OutputStream output, final String charsetName) throws IOException {\n-        write(data, output, Charsets.toCharset(charsetName));\n+    public static void write(final CharSequence charSequence, final OutputStream outputStream, final String s) throws IOException {\n+        write(charSequence, outputStream, Charsets.toCharset(s));\n     }\n     \n-    public static void write(final CharSequence data, final Writer writer) throws IOException {\n-        if (data != null) {\n-            write(data.toString(), writer);\n+    public static void write(final CharSequence charSequence, final Writer writer) throws IOException {\n+        if (charSequence != null) {\n+            write(charSequence.toString(), writer);\n         }\n     }\n     \n     @Deprecated\n-    public static void write(final String data, final OutputStream output) throws IOException {\n-        write(data, output, Charset.defaultCharset());\n+    public static void write(final String s, final OutputStream outputStream) throws IOException {\n+        write(s, outputStream, Charset.defaultCharset());\n     }\n     \n-    public static void write(final String data, final OutputStream output, final Charset charset) throws IOException {\n-        if (data != null) {\n-            output.write(data.getBytes(Charsets.toCharset(charset)));\n+    public static void write(final String s, final OutputStream outputStream, final Charset charset) throws IOException {\n+        if (s != null) {\n+            outputStream.write(s.getBytes(Charsets.toCharset(charset)));\n         }\n     }\n     \n-    public static void write(final String data, final OutputStream output, final String charsetName) throws IOException {\n-        write(data, output, Charsets.toCharset(charsetName));\n+    public static void write(final String s, final OutputStream outputStream, final String s2) throws IOException {\n+        write(s, outputStream, Charsets.toCharset(s2));\n     }\n     \n-    public static void write(final String data, final Writer writer) throws IOException {\n-        if (data != null) {\n-            writer.write(data);\n+    public static void write(final String str, final Writer writer) throws IOException {\n+        if (str != null) {\n+            writer.write(str);\n         }\n     }\n     \n     @Deprecated\n-    public static void write(final StringBuffer data, final OutputStream output) throws IOException {\n-        write(data, output, null);\n+    public static void write(final StringBuffer sb, final OutputStream outputStream) throws IOException {\n+        write(sb, outputStream, null);\n     }\n     \n     @Deprecated\n-    public static void write(final StringBuffer data, final OutputStream output, final String charsetName) throws IOException {\n-        if (data != null) {\n-            output.write(data.toString().getBytes(Charsets.toCharset(charsetName)));\n+    public static void write(final StringBuffer sb, final OutputStream outputStream, final String s) throws IOException {\n+        if (sb != null) {\n+            outputStream.write(sb.toString().getBytes(Charsets.toCharset(s)));\n         }\n     }\n     \n     @Deprecated\n-    public static void write(final StringBuffer data, final Writer writer) throws IOException {\n-        if (data != null) {\n-            writer.write(data.toString());\n+    public static void write(final StringBuffer sb, final Writer writer) throws IOException {\n+        if (sb != null) {\n+            writer.write(sb.toString());\n         }\n     }\n     \n-    public static void writeChunked(final byte[] data, final OutputStream output) throws IOException {\n-        if (data != null) {\n-            int chunk;\n-            for (int bytes = data.length, offset = 0; bytes > 0; bytes -= chunk, offset += chunk) {\n-                chunk = Math.min(bytes, 8192);\n-                output.write(data, offset, chunk);\n+    public static void writeChunked(final byte[] b, final OutputStream outputStream) throws IOException {\n+        if (b != null) {\n+            int min;\n+            for (int i = b.length, off = 0; i > 0; i -= min, off += min) {\n+                min = Math.min(i, 8192);\n+                outputStream.write(b, off, min);\n             }\n         }\n     }\n     \n-    public static void writeChunked(final char[] data, final Writer writer) throws IOException {\n-        if (data != null) {\n-            int chunk;\n-            for (int bytes = data.length, offset = 0; bytes > 0; bytes -= chunk, offset += chunk) {\n-                chunk = Math.min(bytes, 8192);\n-                writer.write(data, offset, chunk);\n+    public static void writeChunked(final char[] array, final Writer writer) throws IOException {\n+        if (array != null) {\n+            int min;\n+            for (int i = array.length, n = 0; i > 0; i -= min, n += min) {\n+                min = Math.min(i, 8192);\n+                writer.write(array, n, min);\n             }\n         }\n     }\n     \n     @Deprecated\n-    public static void writeLines(final Collection<?> lines, final String lineEnding, final OutputStream output) throws IOException {\n-        writeLines(lines, lineEnding, output, Charset.defaultCharset());\n+    public static void writeLines(final Collection<?> collection, final String s, final OutputStream outputStream) throws IOException {\n+        writeLines(collection, s, outputStream, Charset.defaultCharset());\n     }\n     \n-    public static void writeLines(final Collection<?> lines, String lineEnding, final OutputStream output, final Charset charset) throws IOException {\n-        if (lines == null) {\n+    public static void writeLines(final Collection<?> collection, String lineSeparator, final OutputStream outputStream, final Charset charset) throws IOException {\n+        if (collection == null) {\n             return;\n         }\n-        if (lineEnding == null) {\n-            lineEnding = System.lineSeparator();\n+        if (lineSeparator == null) {\n+            lineSeparator = System.lineSeparator();\n         }\n-        final Charset cs = Charsets.toCharset(charset);\n-        for (final Object line : lines) {\n-            if (line != null) {\n-                output.write(line.toString().getBytes(cs));\n+        final Charset charset2 = Charsets.toCharset(charset);\n+        for (final Object next : collection) {\n+            if (next != null) {\n+                outputStream.write(next.toString().getBytes(charset2));\n             }\n-            output.write(lineEnding.getBytes(cs));\n+            outputStream.write(lineSeparator.getBytes(charset2));\n         }\n     }\n     \n-    public static void writeLines(final Collection<?> lines, final String lineEnding, final OutputStream output, final String charsetName) throws IOException {\n-        writeLines(lines, lineEnding, output, Charsets.toCharset(charsetName));\n+    public static void writeLines(final Collection<?> collection, final String s, final OutputStream outputStream, final String s2) throws IOException {\n+        writeLines(collection, s, outputStream, Charsets.toCharset(s2));\n     }\n     \n-    public static void writeLines(final Collection<?> lines, String lineEnding, final Writer writer) throws IOException {\n-        if (lines == null) {\n+    public static void writeLines(final Collection<?> collection, String lineSeparator, final Writer writer) throws IOException {\n+        if (collection == null) {\n             return;\n         }\n-        if (lineEnding == null) {\n-            lineEnding = System.lineSeparator();\n+        if (lineSeparator == null) {\n+            lineSeparator = System.lineSeparator();\n         }\n-        for (final Object line : lines) {\n-            if (line != null) {\n-                writer.write(line.toString());\n+        for (final Object next : collection) {\n+            if (next != null) {\n+                writer.write(next.toString());\n             }\n-            writer.write(lineEnding);\n+            writer.write(lineSeparator);\n         }\n     }\n     \n-    public static Writer writer(final Appendable appendable) {\n-        Objects.requireNonNull(appendable, \"appendable\");\n-        if (appendable instanceof Writer) {\n-            return (Writer)appendable;\n+    public static Writer writer(final Appendable obj) {\n+        Objects.requireNonNull(obj, \"appendable\");\n+        if (obj instanceof Writer) {\n+            return (Writer)obj;\n         }\n-        if (appendable instanceof StringBuilder) {\n-            return (Writer)new StringBuilderWriter((StringBuilder)appendable);\n+        if (obj instanceof StringBuilder) {\n+            return (Writer)new StringBuilderWriter((StringBuilder)obj);\n         }\n-        return (Writer)new AppendableWriter(appendable);\n+        return (Writer)new AppendableWriter(obj);\n     }\n     \n     static {\n         DIR_SEPARATOR = File.separatorChar;\n         EMPTY_BYTE_ARRAY = new byte[0];\n         LINE_SEPARATOR = System.lineSeparator();\n         LINE_SEPARATOR_UNIX = StandardLineSeparator.LF.getString();\n"}]}
