{"diffoscope-json-version": 1, "source1": "first/ArArchiveInputStream.class", "source2": "second/ArArchiveInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -33,200 +33,196 @@\n     private final byte[] metaData;\n     static final String BSD_LONGNAME_PREFIX = \"#1/\";\n     private static final int BSD_LONGNAME_PREFIX_LEN;\n     private static final String BSD_LONGNAME_PATTERN = \"^#1/\\\\d+\";\n     private static final String GNU_STRING_TABLE_NAME = \"//\";\n     private static final String GNU_LONGNAME_PATTERN = \"^/\\\\d+\";\n     \n-    public ArArchiveInputStream(final InputStream pInput) {\n+    public ArArchiveInputStream(final InputStream input) {\n         this.entryOffset = -1L;\n         this.metaData = new byte[58];\n-        this.input = pInput;\n+        this.input = input;\n         this.closed = false;\n     }\n     \n     public ArArchiveEntry getNextArEntry() throws IOException {\n         if (this.currentEntry != null) {\n-            final long entryEnd = this.entryOffset + this.currentEntry.getLength();\n-            final long skipped = IOUtils.skip(this.input, entryEnd - this.offset);\n-            this.trackReadBytes(skipped);\n+            this.trackReadBytes(IOUtils.skip(this.input, this.entryOffset + this.currentEntry.getLength() - this.offset));\n             this.currentEntry = null;\n         }\n         if (this.offset == 0L) {\n-            final byte[] expected = ArchiveUtils.toAsciiBytes(\"!<arch>\\n\");\n-            final byte[] realized = IOUtils.readRange(this.input, expected.length);\n-            final int read = realized.length;\n-            this.trackReadBytes(read);\n-            if (read != expected.length) {\n+            final byte[] asciiBytes = ArchiveUtils.toAsciiBytes(\"!<arch>\\n\");\n+            final byte[] range = IOUtils.readRange(this.input, asciiBytes.length);\n+            final int length = range.length;\n+            this.trackReadBytes(length);\n+            if (length != asciiBytes.length) {\n                 throw new IOException(\"Failed to read header. Occurred at byte: \" + this.getBytesRead());\n             }\n-            if (!Arrays.equals(expected, realized)) {\n-                throw new IOException(\"Invalid header \" + ArchiveUtils.toAsciiString(realized));\n+            if (!Arrays.equals(asciiBytes, range)) {\n+                throw new IOException(\"Invalid header \" + ArchiveUtils.toAsciiString(range));\n             }\n         }\n         if (this.offset % 2L != 0L) {\n             if (this.input.read() < 0) {\n                 return null;\n             }\n             this.trackReadBytes(1L);\n         }\n-        final int read2 = IOUtils.readFully(this.input, this.metaData);\n-        this.trackReadBytes(read2);\n-        if (read2 == 0) {\n+        final int fully = IOUtils.readFully(this.input, this.metaData);\n+        this.trackReadBytes(fully);\n+        if (fully == 0) {\n             return null;\n         }\n-        if (read2 < this.metaData.length) {\n+        if (fully < this.metaData.length) {\n             throw new IOException(\"Truncated ar archive\");\n         }\n-        final byte[] expected = ArchiveUtils.toAsciiBytes(\"`\\n\");\n-        final byte[] realized = IOUtils.readRange(this.input, expected.length);\n-        final int read = realized.length;\n-        this.trackReadBytes(read);\n-        if (read != expected.length) {\n+        final byte[] asciiBytes2 = ArchiveUtils.toAsciiBytes(\"`\\n\");\n+        final byte[] range2 = IOUtils.readRange(this.input, asciiBytes2.length);\n+        final int length2 = range2.length;\n+        this.trackReadBytes(length2);\n+        if (length2 != asciiBytes2.length) {\n             throw new IOException(\"Failed to read entry trailer. Occurred at byte: \" + this.getBytesRead());\n         }\n-        if (!Arrays.equals(expected, realized)) {\n+        if (!Arrays.equals(asciiBytes2, range2)) {\n             throw new IOException(\"Invalid entry trailer. not read the content? Occurred at byte: \" + this.getBytesRead());\n         }\n         this.entryOffset = this.offset;\n-        String temp = ArchiveUtils.toAsciiString(this.metaData, 0, 16).trim();\n-        if (isGNUStringTable(temp)) {\n+        String s = ArchiveUtils.toAsciiString(this.metaData, 0, 16).trim();\n+        if (isGNUStringTable(s)) {\n             this.currentEntry = this.readGNUStringTable(this.metaData, 48, 10);\n             return this.getNextArEntry();\n         }\n-        long len = this.asLong(this.metaData, 48, 10);\n-        if (temp.endsWith(\"/\")) {\n-            temp = temp.substring(0, temp.length() - 1);\n-        }\n-        else if (this.isGNULongName(temp)) {\n-            final int off = Integer.parseInt(temp.substring(1));\n-            temp = this.getExtendedName(off);\n-        }\n-        else if (isBSDLongName(temp)) {\n-            temp = this.getBSDLongName(temp);\n-            final int nameLen = temp.length();\n-            len -= nameLen;\n-            this.entryOffset += nameLen;\n+        long long1 = this.asLong(this.metaData, 48, 10);\n+        if (s.endsWith(\"/\")) {\n+            s = s.substring(0, s.length() - 1);\n+        }\n+        else if (this.isGNULongName(s)) {\n+            s = this.getExtendedName(Integer.parseInt(s.substring(1)));\n+        }\n+        else if (isBSDLongName(s)) {\n+            s = this.getBSDLongName(s);\n+            final int length3 = s.length();\n+            long1 -= length3;\n+            this.entryOffset += length3;\n         }\n-        if (len < 0L) {\n+        if (long1 < 0L) {\n             throw new IOException(\"broken archive, entry with negative size\");\n         }\n-        return this.currentEntry = new ArArchiveEntry(temp, len, this.asInt(this.metaData, 28, 6, true), this.asInt(this.metaData, 34, 6, true), this.asInt(this.metaData, 40, 8, 8), this.asLong(this.metaData, 16, 12));\n+        return this.currentEntry = new ArArchiveEntry(s, long1, this.asInt(this.metaData, 28, 6, true), this.asInt(this.metaData, 34, 6, true), this.asInt(this.metaData, 40, 8, 8), this.asLong(this.metaData, 16, 12));\n     }\n     \n-    private String getExtendedName(final int offset) throws IOException {\n+    private String getExtendedName(final int i) throws IOException {\n         if (this.namebuffer == null) {\n             throw new IOException(\"Cannot process GNU long filename as no // record was found\");\n         }\n-        for (int i = offset; i < this.namebuffer.length; ++i) {\n-            if (this.namebuffer[i] == 10 || this.namebuffer[i] == 0) {\n-                if (this.namebuffer[i - 1] == 47) {\n-                    --i;\n+        for (int j = i; j < this.namebuffer.length; ++j) {\n+            if (this.namebuffer[j] == 10 || this.namebuffer[j] == 0) {\n+                if (this.namebuffer[j - 1] == 47) {\n+                    --j;\n                 }\n-                return ArchiveUtils.toAsciiString(this.namebuffer, offset, i - offset);\n+                return ArchiveUtils.toAsciiString(this.namebuffer, i, j - i);\n             }\n         }\n-        throw new IOException(\"Failed to read entry: \" + offset);\n+        throw new IOException(\"Failed to read entry: \" + i);\n     }\n     \n-    private long asLong(final byte[] byteArray, final int offset, final int len) {\n-        return Long.parseLong(ArchiveUtils.toAsciiString(byteArray, offset, len).trim());\n+    private long asLong(final byte[] array, final int n, final int n2) {\n+        return Long.parseLong(ArchiveUtils.toAsciiString(array, n, n2).trim());\n     }\n     \n-    private int asInt(final byte[] byteArray, final int offset, final int len) {\n-        return this.asInt(byteArray, offset, len, 10, false);\n+    private int asInt(final byte[] array, final int n, final int n2) {\n+        return this.asInt(array, n, n2, 10, false);\n     }\n     \n-    private int asInt(final byte[] byteArray, final int offset, final int len, final boolean treatBlankAsZero) {\n-        return this.asInt(byteArray, offset, len, 10, treatBlankAsZero);\n+    private int asInt(final byte[] array, final int n, final int n2, final boolean b) {\n+        return this.asInt(array, n, n2, 10, b);\n     }\n     \n-    private int asInt(final byte[] byteArray, final int offset, final int len, final int base) {\n-        return this.asInt(byteArray, offset, len, base, false);\n+    private int asInt(final byte[] array, final int n, final int n2, final int n3) {\n+        return this.asInt(array, n, n2, n3, false);\n     }\n     \n-    private int asInt(final byte[] byteArray, final int offset, final int len, final int base, final boolean treatBlankAsZero) {\n-        final String string = ArchiveUtils.toAsciiString(byteArray, offset, len).trim();\n-        if (string.isEmpty() && treatBlankAsZero) {\n+    private int asInt(final byte[] array, final int n, final int n2, final int radix, final boolean b) {\n+        final String trim = ArchiveUtils.toAsciiString(array, n, n2).trim();\n+        if (trim.isEmpty() && b) {\n             return 0;\n         }\n-        return Integer.parseInt(string, base);\n+        return Integer.parseInt(trim, radix);\n     }\n     \n     public ArchiveEntry getNextEntry() throws IOException {\n         return (ArchiveEntry)this.getNextArEntry();\n     }\n     \n     public void close() throws IOException {\n         if (!this.closed) {\n             this.closed = true;\n             this.input.close();\n         }\n         this.currentEntry = null;\n     }\n     \n-    public int read(final byte[] b, final int off, final int len) throws IOException {\n-        if (len == 0) {\n+    public int read(final byte[] b, final int off, final int n) throws IOException {\n+        if (n == 0) {\n             return 0;\n         }\n         if (this.currentEntry == null) {\n             throw new IllegalStateException(\"No current ar entry\");\n         }\n-        final long entryEnd = this.entryOffset + this.currentEntry.getLength();\n-        if (len < 0 || this.offset >= entryEnd) {\n+        final long n2 = this.entryOffset + this.currentEntry.getLength();\n+        if (n < 0 || this.offset >= n2) {\n             return -1;\n         }\n-        final int toRead = (int)Math.min(len, entryEnd - this.offset);\n-        final int ret = this.input.read(b, off, toRead);\n-        this.trackReadBytes(ret);\n-        return ret;\n+        final int read = this.input.read(b, off, (int)Math.min(n, n2 - this.offset));\n+        this.trackReadBytes(read);\n+        return read;\n     }\n     \n-    public static boolean matches(final byte[] signature, final int length) {\n-        return length >= 8 && signature[0] == 33 && signature[1] == 60 && signature[2] == 97 && signature[3] == 114 && signature[4] == 99 && signature[5] == 104 && signature[6] == 62 && signature[7] == 10;\n+    public static boolean matches(final byte[] array, final int n) {\n+        return n >= 8 && array[0] == 33 && array[1] == 60 && array[2] == 97 && array[3] == 114 && array[4] == 99 && array[5] == 104 && array[6] == 62 && array[7] == 10;\n     }\n     \n-    private static boolean isBSDLongName(final String name) {\n-        return name != null && name.matches(\"^#1/\\\\d+\");\n+    private static boolean isBSDLongName(final String s) {\n+        return s != null && s.matches(\"^#1/\\\\d+\");\n     }\n     \n-    private String getBSDLongName(final String bsdLongName) throws IOException {\n-        final int nameLen = Integer.parseInt(bsdLongName.substring(ArArchiveInputStream.BSD_LONGNAME_PREFIX_LEN));\n-        final byte[] name = IOUtils.readRange(this.input, nameLen);\n-        final int read = name.length;\n-        this.trackReadBytes(read);\n-        if (read != nameLen) {\n+    private String getBSDLongName(final String s) throws IOException {\n+        final int int1 = Integer.parseInt(s.substring(ArArchiveInputStream.BSD_LONGNAME_PREFIX_LEN));\n+        final byte[] range = IOUtils.readRange(this.input, int1);\n+        final int length = range.length;\n+        this.trackReadBytes(length);\n+        if (length != int1) {\n             throw new EOFException();\n         }\n-        return ArchiveUtils.toAsciiString(name);\n+        return ArchiveUtils.toAsciiString(range);\n     }\n     \n-    private static boolean isGNUStringTable(final String name) {\n-        return \"//\".equals(name);\n+    private static boolean isGNUStringTable(final String anObject) {\n+        return \"//\".equals(anObject);\n     }\n     \n-    private void trackReadBytes(final long read) {\n-        this.count(read);\n-        if (read > 0L) {\n-            this.offset += read;\n+    private void trackReadBytes(final long n) {\n+        this.count(n);\n+        if (n > 0L) {\n+            this.offset += n;\n         }\n     }\n     \n-    private ArArchiveEntry readGNUStringTable(final byte[] length, final int offset, final int len) throws IOException {\n-        final int bufflen = this.asInt(length, offset, len);\n-        this.namebuffer = IOUtils.readRange(this.input, bufflen);\n-        final int read = this.namebuffer.length;\n-        this.trackReadBytes(read);\n-        if (read != bufflen) {\n-            throw new IOException(\"Failed to read complete // record: expected=\" + bufflen + \" read=\" + read);\n+    private ArArchiveEntry readGNUStringTable(final byte[] array, final int n, final int n2) throws IOException {\n+        final int int1 = this.asInt(array, n, n2);\n+        this.namebuffer = IOUtils.readRange(this.input, int1);\n+        final int length = this.namebuffer.length;\n+        this.trackReadBytes(length);\n+        if (length != int1) {\n+            throw new IOException(\"Failed to read complete // record: expected=\" + int1 + \" read=\" + length);\n         }\n-        return new ArArchiveEntry(\"//\", (long)bufflen);\n+        return new ArArchiveEntry(\"//\", (long)int1);\n     }\n     \n-    private boolean isGNULongName(final String name) {\n-        return name != null && name.matches(\"^/\\\\d+\");\n+    private boolean isGNULongName(final String s) {\n+        return s != null && s.matches(\"^/\\\\d+\");\n     }\n     \n     static {\n         BSD_LONGNAME_PREFIX_LEN = \"#1/\".length();\n     }\n }\n"}]}
