{"diffoscope-json-version": 1, "source1": "first/ByteUtils.class", "source2": "second/ByteUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -8,94 +8,93 @@\n import java.io.InputStream;\n \n public final class ByteUtils\n {\n     private ByteUtils() {\n     }\n     \n-    public static long fromLittleEndian(final byte[] bytes) {\n-        return fromLittleEndian(bytes, 0, bytes.length);\n+    public static long fromLittleEndian(final byte[] array) {\n+        return fromLittleEndian(array, 0, array.length);\n     }\n     \n-    public static long fromLittleEndian(final byte[] bytes, final int off, final int length) {\n-        checkReadLength(length);\n-        long l = 0L;\n-        for (int i = 0; i < length; ++i) {\n-            l |= ((long)bytes[off + i] & 0xFFL) << 8 * i;\n+    public static long fromLittleEndian(final byte[] array, final int n, final int n2) {\n+        checkReadLength(n2);\n+        long n3 = 0L;\n+        for (int i = 0; i < n2; ++i) {\n+            n3 |= ((long)array[n + i] & 0xFFL) << 8 * i;\n         }\n-        return l;\n+        return n3;\n     }\n     \n-    public static long fromLittleEndian(final InputStream in, final int length) throws IOException {\n-        checkReadLength(length);\n-        long l = 0L;\n-        for (int i = 0; i < length; ++i) {\n-            final long b = (long)in.read();\n-            if (b == -1L) {\n+    public static long fromLittleEndian(final InputStream inputStream, final int n) throws IOException {\n+        checkReadLength(n);\n+        long n2 = 0L;\n+        for (int i = 0; i < n; ++i) {\n+            final long n3 = (long)inputStream.read();\n+            if (n3 == -1L) {\n                 throw new IOException(\"Premature end of data\");\n             }\n-            l |= b << i * 8;\n+            n2 |= n3 << i * 8;\n         }\n-        return l;\n+        return n2;\n     }\n     \n-    public static long fromLittleEndian(final ByteUtils.ByteSupplier supplier, final int length) throws IOException {\n-        checkReadLength(length);\n-        long l = 0L;\n-        for (int i = 0; i < length; ++i) {\n-            final long b = (long)supplier.getAsByte();\n-            if (b == -1L) {\n+    public static long fromLittleEndian(final ByteUtils.ByteSupplier byteSupplier, final int n) throws IOException {\n+        checkReadLength(n);\n+        long n2 = 0L;\n+        for (int i = 0; i < n; ++i) {\n+            final long n3 = (long)byteSupplier.getAsByte();\n+            if (n3 == -1L) {\n                 throw new IOException(\"Premature end of data\");\n             }\n-            l |= b << i * 8;\n+            n2 |= n3 << i * 8;\n         }\n-        return l;\n+        return n2;\n     }\n     \n-    public static long fromLittleEndian(final DataInput in, final int length) throws IOException {\n-        checkReadLength(length);\n-        long l = 0L;\n-        for (int i = 0; i < length; ++i) {\n-            final long b = (long)in.readUnsignedByte();\n-            l |= b << i * 8;\n+    public static long fromLittleEndian(final DataInput dataInput, final int n) throws IOException {\n+        checkReadLength(n);\n+        long n2 = 0L;\n+        for (int i = 0; i < n; ++i) {\n+            n2 |= (long)dataInput.readUnsignedByte() << i * 8;\n         }\n-        return l;\n+        return n2;\n     }\n     \n-    public static void toLittleEndian(final byte[] b, final long value, final int off, final int length) {\n-        long num = value;\n-        for (int i = 0; i < length; ++i) {\n-            b[off + i] = (byte)(num & 0xFFL);\n-            num >>= 8;\n+    public static void toLittleEndian(final byte[] array, final long n, final int n2, final int n3) {\n+        long n4 = n;\n+        for (int i = 0; i < n3; ++i) {\n+            array[n2 + i] = (byte)(n4 & 0xFFL);\n+            n4 >>= 8;\n         }\n     }\n     \n-    public static void toLittleEndian(final OutputStream out, final long value, final int length) throws IOException {\n-        long num = value;\n-        for (int i = 0; i < length; ++i) {\n-            out.write((int)(num & 0xFFL));\n-            num >>= 8;\n+    public static void toLittleEndian(final OutputStream outputStream, final long n, final int n2) throws IOException {\n+        long n3 = n;\n+        for (int i = 0; i < n2; ++i) {\n+            outputStream.write((int)(n3 & 0xFFL));\n+            n3 >>= 8;\n         }\n     }\n     \n-    public static void toLittleEndian(final ByteUtils.ByteConsumer consumer, final long value, final int length) throws IOException {\n-        long num = value;\n-        for (int i = 0; i < length; ++i) {\n-            consumer.accept((int)(num & 0xFFL));\n-            num >>= 8;\n+    public static void toLittleEndian(final ByteUtils.ByteConsumer byteConsumer, final long n, final int n2) throws IOException {\n+        long n3 = n;\n+        for (int i = 0; i < n2; ++i) {\n+            byteConsumer.accept((int)(n3 & 0xFFL));\n+            n3 >>= 8;\n         }\n     }\n     \n-    public static void toLittleEndian(final DataOutput out, final long value, final int length) throws IOException {\n-        long num = value;\n-        for (int i = 0; i < length; ++i) {\n-            out.write((int)(num & 0xFFL));\n-            num >>= 8;\n+    public static void toLittleEndian(final DataOutput dataOutput, final long n, final int n2) throws IOException {\n+        long n3 = n;\n+        for (int i = 0; i < n2; ++i) {\n+            dataOutput.write((int)(n3 & 0xFFL));\n+            n3 >>= 8;\n         }\n     }\n     \n-    private static final void checkReadLength(final int length) {\n-        if (length > 8) {\n+    private static final void checkReadLength(final int n) {\n+        if (n > 8) {\n             throw new IllegalArgumentException(\"Can't read more than eight bytes into a long value\");\n         }\n     }\n }\n"}]}
