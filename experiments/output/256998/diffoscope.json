{"diffoscope-json-version": 1, "source1": "first/TapeInputStream.class", "source2": "second/TapeInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -48,101 +48,98 @@\n     }\n     \n     public byte[] peek() throws IOException {\n         if (this.readOffset == this.blockSize) {\n             try {\n                 this.readBlock(true);\n             }\n-            catch (final ShortFileException sfe) {\n+            catch (final ShortFileException ex) {\n                 return null;\n             }\n         }\n-        final byte[] b = new byte[1024];\n-        System.arraycopy(this.blockBuffer, this.readOffset, b, 0, b.length);\n-        return b;\n+        final byte[] array = new byte[1024];\n+        System.arraycopy(this.blockBuffer, this.readOffset, array, 0, array.length);\n+        return array;\n     }\n     \n     @Override\n     public int read() throws IOException {\n         throw new IllegalArgumentException(\"All reads must be multiple of record size (1024 bytes.\");\n     }\n     \n     @Override\n-    public int read(final byte[] b, int off, final int len) throws IOException {\n-        if (len == 0) {\n+    public int read(final byte[] array, int n, final int n2) throws IOException {\n+        if (n2 == 0) {\n             return 0;\n         }\n-        if (len % 1024 != 0) {\n+        if (n2 % 1024 != 0) {\n             throw new IllegalArgumentException(\"All reads must be multiple of record size (1024 bytes.\");\n         }\n-        int bytes;\n-        int n;\n-        for (bytes = 0; bytes < len; bytes += n, off += n) {\n+        int i;\n+        int n3;\n+        for (i = 0; i < n2; i += n3, n += n3) {\n             if (this.readOffset == this.blockSize) {\n                 try {\n                     this.readBlock(true);\n                 }\n-                catch (final ShortFileException sfe) {\n+                catch (final ShortFileException ex) {\n                     return -1;\n                 }\n             }\n-            n = 0;\n-            if (this.readOffset + (len - bytes) <= this.blockSize) {\n-                n = len - bytes;\n+            if (this.readOffset + (n2 - i) <= this.blockSize) {\n+                n3 = n2 - i;\n             }\n             else {\n-                n = this.blockSize - this.readOffset;\n+                n3 = this.blockSize - this.readOffset;\n             }\n-            System.arraycopy(this.blockBuffer, this.readOffset, b, off, n);\n-            this.readOffset += n;\n+            System.arraycopy(this.blockBuffer, this.readOffset, array, n, n3);\n+            this.readOffset += n3;\n         }\n-        return bytes;\n+        return i;\n     }\n     \n-    private void readBlock(final boolean decompress) throws IOException {\n+    private void readBlock(final boolean b) throws IOException {\n         if (this.in == null) {\n             throw new IOException(\"Input buffer is closed\");\n         }\n         if (!this.isCompressed || this.currBlkIdx == -1) {\n             this.readFully(this.blockBuffer, 0, this.blockSize);\n             this.bytesRead += this.blockSize;\n         }\n         else {\n             this.readFully(this.blockBuffer, 0, 4);\n             this.bytesRead += 4L;\n-            final int h = DumpArchiveUtil.convert32(this.blockBuffer, 0);\n-            final boolean compressed = (h & 0x1) == 0x1;\n-            if (!compressed) {\n+            final int convert32 = DumpArchiveUtil.convert32(this.blockBuffer, 0);\n+            if ((convert32 & 0x1) != 0x1) {\n                 this.readFully(this.blockBuffer, 0, this.blockSize);\n                 this.bytesRead += this.blockSize;\n             }\n             else {\n-                final int flags = h >> 1 & 0x7;\n-                int length = h >> 4 & 0xFFFFFFF;\n-                final byte[] compBuffer = this.readRange(length);\n-                this.bytesRead += length;\n-                if (!decompress) {\n+                final int n = convert32 >> 1 & 0x7;\n+                final int n2 = convert32 >> 4 & 0xFFFFFFF;\n+                final byte[] range = this.readRange(n2);\n+                this.bytesRead += n2;\n+                if (!b) {\n                     Arrays.fill(this.blockBuffer, (byte)0);\n                 }\n                 else {\n-                    switch (TapeInputStream.TapeInputStream$1.$SwitchMap$org$apache$commons$compress$archivers$dump$DumpArchiveConstants$COMPRESSION_TYPE[DumpArchiveConstants.COMPRESSION_TYPE.find(flags & 0x3).ordinal()]) {\n+                    switch (TapeInputStream.TapeInputStream$1.$SwitchMap$org$apache$commons$compress$archivers$dump$DumpArchiveConstants$COMPRESSION_TYPE[DumpArchiveConstants.COMPRESSION_TYPE.find(n & 0x3).ordinal()]) {\n                         case 1: {\n-                            final Inflater inflator = new Inflater();\n+                            final Inflater inflater = new Inflater();\n                             try {\n-                                inflator.setInput(compBuffer, 0, compBuffer.length);\n-                                length = inflator.inflate(this.blockBuffer);\n-                                if (length != this.blockSize) {\n+                                inflater.setInput(range, 0, range.length);\n+                                if (inflater.inflate(this.blockBuffer) != this.blockSize) {\n                                     throw new ShortFileException();\n                                 }\n                             }\n-                            catch (final DataFormatException e) {\n-                                throw new DumpArchiveException(\"Bad data\", (Throwable)e);\n+                            catch (final DataFormatException ex) {\n+                                throw new DumpArchiveException(\"Bad data\", (Throwable)ex);\n                             }\n                             finally {\n-                                inflator.end();\n+                                inflater.end();\n                             }\n                             break;\n                         }\n                         case 2: {\n                             throw new UnsupportedCompressionAlgorithmException(\"BZLIB2\");\n                         }\n                         case 3: {\n@@ -155,71 +152,68 @@\n                 }\n             }\n         }\n         ++this.currBlkIdx;\n         this.readOffset = 0;\n     }\n     \n-    private void readFully(final byte[] b, final int off, final int len) throws IOException {\n-        final int count = IOUtils.readFully(this.in, b, off, len);\n-        if (count < len) {\n+    private void readFully(final byte[] array, final int n, final int n2) throws IOException {\n+        if (IOUtils.readFully(this.in, array, n, n2) < n2) {\n             throw new ShortFileException();\n         }\n     }\n     \n-    private byte[] readRange(final int len) throws IOException {\n-        final byte[] ret = IOUtils.readRange(this.in, len);\n-        if (ret.length < len) {\n+    private byte[] readRange(final int n) throws IOException {\n+        final byte[] range = IOUtils.readRange(this.in, n);\n+        if (range.length < n) {\n             throw new ShortFileException();\n         }\n-        return ret;\n+        return range;\n     }\n     \n     public byte[] readRecord() throws IOException {\n-        final byte[] result = new byte[1024];\n-        if (-1 == this.read(result, 0, result.length)) {\n+        final byte[] array = new byte[1024];\n+        if (-1 == this.read(array, 0, array.length)) {\n             throw new ShortFileException();\n         }\n-        return result;\n+        return array;\n     }\n     \n-    public void resetBlockSize(final int recsPerBlock, final boolean isCompressed) throws IOException {\n+    public void resetBlockSize(final int i, final boolean isCompressed) throws IOException {\n         this.isCompressed = isCompressed;\n-        if (recsPerBlock < 1) {\n-            throw new IOException(\"Block with \" + recsPerBlock + \" records found, must be at least 1\");\n+        if (i < 1) {\n+            throw new IOException(\"Block with \" + i + \" records found, must be at least 1\");\n         }\n-        this.blockSize = 1024 * recsPerBlock;\n-        final byte[] oldBuffer = this.blockBuffer;\n-        System.arraycopy(oldBuffer, 0, this.blockBuffer = new byte[this.blockSize], 0, 1024);\n+        this.blockSize = 1024 * i;\n+        System.arraycopy(this.blockBuffer, 0, this.blockBuffer = new byte[this.blockSize], 0, 1024);\n         this.readFully(this.blockBuffer, 1024, this.blockSize - 1024);\n         this.currBlkIdx = 0;\n         this.readOffset = 1024;\n     }\n     \n     @Override\n-    public long skip(final long len) throws IOException {\n-        if (len % 1024L != 0L) {\n+    public long skip(final long n) throws IOException {\n+        if (n % 1024L != 0L) {\n             throw new IllegalArgumentException(\"All reads must be multiple of record size (1024 bytes.\");\n         }\n-        long bytes;\n-        long n;\n-        for (bytes = 0L; bytes < len; bytes += n) {\n+        long n2;\n+        long n3;\n+        for (n2 = 0L; n2 < n; n2 += n3) {\n             if (this.readOffset == this.blockSize) {\n                 try {\n-                    this.readBlock(len - bytes < (long)this.blockSize);\n+                    this.readBlock(n - n2 < (long)this.blockSize);\n                 }\n-                catch (final ShortFileException sfe) {\n+                catch (final ShortFileException ex) {\n                     return -1L;\n                 }\n             }\n-            n = 0L;\n-            if (this.readOffset + (len - bytes) <= this.blockSize) {\n-                n = len - bytes;\n+            if (this.readOffset + (n - n2) <= this.blockSize) {\n+                n3 = n - n2;\n             }\n             else {\n-                n = this.blockSize - (long)this.readOffset;\n+                n3 = this.blockSize - (long)this.readOffset;\n             }\n-            this.readOffset = ExactMath.add(this.readOffset, n);\n+            this.readOffset = ExactMath.add(this.readOffset, n3);\n         }\n-        return bytes;\n+        return n2;\n     }\n }\n"}]}
