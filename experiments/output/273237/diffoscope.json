{"diffoscope-json-version": 1, "source1": "first/CheckUtil.class", "source2": "second/CheckUtil.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -30,306 +30,287 @@\n     private static final Pattern GETTER_PATTERN;\n     private static final Pattern ALL_NEW_LINES;\n     private static final char PACKAGE_SEPARATOR = '.';\n     \n     private CheckUtil() {\n     }\n     \n-    public static boolean isEqualsMethod(final DetailAST ast) {\n-        boolean equalsMethod = false;\n-        if (ast.getType() == 9) {\n-            final DetailAST modifiers = ast.findFirstToken(5);\n-            final boolean staticOrAbstract = modifiers.findFirstToken(64) != null || modifiers.findFirstToken(40) != null;\n-            if (!staticOrAbstract) {\n-                final DetailAST nameNode = ast.findFirstToken(58);\n-                final String name = nameNode.getText();\n-                if (\"equals\".equals(name)) {\n-                    final DetailAST paramsNode = ast.findFirstToken(20);\n-                    equalsMethod = (paramsNode.getChildCount() == 1);\n-                }\n+    public static boolean isEqualsMethod(final DetailAST detailAST) {\n+        boolean b = false;\n+        if (detailAST.getType() == 9) {\n+            final DetailAST firstToken = detailAST.findFirstToken(5);\n+            if (firstToken.findFirstToken(64) == null && firstToken.findFirstToken(40) == null && \"equals\".equals(detailAST.findFirstToken(58).getText())) {\n+                b = (detailAST.findFirstToken(20).getChildCount() == 1);\n             }\n         }\n-        return equalsMethod;\n+        return b;\n     }\n     \n-    public static double parseDouble(final String text, final int type) {\n-        String txt = CheckUtil.UNDERSCORE_PATTERN.matcher(text).replaceAll(\"\");\n-        double result = 0.0;\n-        switch (type) {\n+    public static double parseDouble(final String input, final int n) {\n+        String s = CheckUtil.UNDERSCORE_PATTERN.matcher(input).replaceAll(\"\");\n+        double n2 = 0.0;\n+        switch (n) {\n             case 140:\n             case 142: {\n-                result = Double.parseDouble(txt);\n+                n2 = Double.parseDouble(s);\n                 break;\n             }\n             case 137:\n             case 141: {\n-                int radix = 10;\n-                if (txt.startsWith(\"0x\") || txt.startsWith(\"0X\")) {\n-                    radix = 16;\n-                    txt = txt.substring(2);\n+                int n3 = 10;\n+                if (s.startsWith(\"0x\") || s.startsWith(\"0X\")) {\n+                    n3 = 16;\n+                    s = s.substring(2);\n                 }\n-                else if (txt.startsWith(\"0b\") || txt.startsWith(\"0B\")) {\n-                    radix = 2;\n-                    txt = txt.substring(2);\n+                else if (s.startsWith(\"0b\") || s.startsWith(\"0B\")) {\n+                    n3 = 2;\n+                    s = s.substring(2);\n                 }\n-                else if (txt.startsWith(\"0\")) {\n-                    radix = 8;\n+                else if (s.startsWith(\"0\")) {\n+                    n3 = 8;\n                 }\n-                result = parseNumber(txt, radix, type);\n+                n2 = parseNumber(s, n3, n);\n                 break;\n             }\n             default: {\n-                result = Double.NaN;\n+                n2 = Double.NaN;\n                 break;\n             }\n         }\n-        return result;\n+        return n2;\n     }\n     \n-    private static double parseNumber(final String text, final int radix, final int type) {\n-        String txt = text;\n-        if (txt.endsWith(\"L\") || txt.endsWith(\"l\")) {\n-            txt = txt.substring(0, txt.length() - 1);\n-        }\n-        final boolean negative = txt.charAt(0) == '-';\n-        double result;\n-        if (type == 137) {\n-            if (negative) {\n-                result = Integer.parseInt(txt, radix);\n+    private static double parseNumber(final String s, final int n, final int n2) {\n+        String substring = s;\n+        if (substring.endsWith(\"L\") || substring.endsWith(\"l\")) {\n+            substring = substring.substring(0, substring.length() - 1);\n+        }\n+        final boolean b = substring.charAt(0) == '-';\n+        double n3;\n+        if (n2 == 137) {\n+            if (b) {\n+                n3 = Integer.parseInt(substring, n);\n             }\n             else {\n-                result = Integer.parseUnsignedInt(txt, radix);\n+                n3 = Integer.parseUnsignedInt(substring, n);\n             }\n         }\n-        else if (negative) {\n-            result = (double)Long.parseLong(txt, radix);\n+        else if (b) {\n+            n3 = (double)Long.parseLong(substring, n);\n         }\n         else {\n-            result = (double)Long.parseUnsignedLong(txt, radix);\n+            n3 = (double)Long.parseUnsignedLong(substring, n);\n         }\n-        return result;\n+        return n3;\n     }\n     \n-    public static DetailAST getFirstNode(final DetailAST node) {\n-        DetailAST currentNode = node;\n-        for (DetailAST child = node.getFirstChild(); child != null; child = child.getNextSibling()) {\n-            final DetailAST newNode = getFirstNode(child);\n-            if (isBeforeInSource(newNode, currentNode)) {\n-                currentNode = newNode;\n+    public static DetailAST getFirstNode(final DetailAST detailAST) {\n+        DetailAST detailAST2 = detailAST;\n+        for (DetailAST detailAST3 = detailAST.getFirstChild(); detailAST3 != null; detailAST3 = detailAST3.getNextSibling()) {\n+            final DetailAST firstNode = getFirstNode(detailAST3);\n+            if (isBeforeInSource(firstNode, detailAST2)) {\n+                detailAST2 = firstNode;\n             }\n         }\n-        return currentNode;\n+        return detailAST2;\n     }\n     \n-    public static boolean isBeforeInSource(final DetailAST ast1, final DetailAST ast2) {\n-        return ast1.getLineNo() < ast2.getLineNo() || (TokenUtil.areOnSameLine(ast1, ast2) && ast1.getColumnNo() < ast2.getColumnNo());\n+    public static boolean isBeforeInSource(final DetailAST detailAST, final DetailAST detailAST2) {\n+        return detailAST.getLineNo() < detailAST2.getLineNo() || (TokenUtil.areOnSameLine(detailAST, detailAST2) && detailAST.getColumnNo() < detailAST2.getColumnNo());\n     }\n     \n-    public static List<String> getTypeParameterNames(final DetailAST node) {\n-        final DetailAST typeParameters = node.findFirstToken(165);\n-        final List<String> typeParameterNames = new ArrayList<String>();\n-        if (typeParameters != null) {\n-            final DetailAST typeParam = typeParameters.findFirstToken(166);\n-            typeParameterNames.add(typeParam.findFirstToken(58).getText());\n-            for (DetailAST sibling = typeParam.getNextSibling(); sibling != null; sibling = sibling.getNextSibling()) {\n-                if (sibling.getType() == 166) {\n-                    typeParameterNames.add(sibling.findFirstToken(58).getText());\n+    public static List<String> getTypeParameterNames(final DetailAST detailAST) {\n+        final DetailAST firstToken = detailAST.findFirstToken(165);\n+        final ArrayList list = new ArrayList();\n+        if (firstToken != null) {\n+            final DetailAST firstToken2 = firstToken.findFirstToken(166);\n+            list.add(firstToken2.findFirstToken(58).getText());\n+            for (DetailAST detailAST2 = firstToken2.getNextSibling(); detailAST2 != null; detailAST2 = detailAST2.getNextSibling()) {\n+                if (detailAST2.getType() == 166) {\n+                    list.add(detailAST2.findFirstToken(58).getText());\n                 }\n             }\n         }\n-        return typeParameterNames;\n+        return list;\n     }\n     \n-    public static List<DetailAST> getTypeParameters(final DetailAST node) {\n-        final DetailAST typeParameters = node.findFirstToken(165);\n-        final List<DetailAST> typeParams = new ArrayList<DetailAST>();\n-        if (typeParameters != null) {\n-            final DetailAST typeParam = typeParameters.findFirstToken(166);\n-            typeParams.add(typeParam);\n-            for (DetailAST sibling = typeParam.getNextSibling(); sibling != null; sibling = sibling.getNextSibling()) {\n-                if (sibling.getType() == 166) {\n-                    typeParams.add(sibling);\n+    public static List<DetailAST> getTypeParameters(final DetailAST detailAST) {\n+        final DetailAST firstToken = detailAST.findFirstToken(165);\n+        final ArrayList list = new ArrayList();\n+        if (firstToken != null) {\n+            final DetailAST firstToken2 = firstToken.findFirstToken(166);\n+            list.add(firstToken2);\n+            for (DetailAST detailAST2 = firstToken2.getNextSibling(); detailAST2 != null; detailAST2 = detailAST2.getNextSibling()) {\n+                if (detailAST2.getType() == 166) {\n+                    list.add(detailAST2);\n                 }\n             }\n         }\n-        return typeParams;\n+        return list;\n     }\n     \n-    public static boolean isSetterMethod(final DetailAST ast) {\n-        boolean setterMethod = false;\n-        if (ast.getType() == 9 && ast.getChildCount() == 7) {\n-            final DetailAST type = ast.findFirstToken(13);\n-            final String name = type.getNextSibling().getText();\n-            final boolean matchesSetterFormat = CheckUtil.SETTER_PATTERN.matcher(name).matches();\n-            final DetailAST params = ast.findFirstToken(20);\n-            final boolean singleParam = params.getChildCount(21) == 1;\n-            if (matchesSetterFormat && singleParam) {\n-                final DetailAST slist = ast.findFirstToken(7);\n-                if (slist != null && slist.getChildCount() == 3) {\n-                    final DetailAST expr = slist.getFirstChild();\n-                    setterMethod = (expr.getFirstChild().getType() == 80);\n+    public static boolean isSetterMethod(final DetailAST detailAST) {\n+        boolean b = false;\n+        if (detailAST.getType() == 9 && detailAST.getChildCount() == 7) {\n+            final boolean matches = CheckUtil.SETTER_PATTERN.matcher(detailAST.findFirstToken(13).getNextSibling().getText()).matches();\n+            final boolean b2 = detailAST.findFirstToken(20).getChildCount(21) == 1;\n+            if (matches && b2) {\n+                final DetailAST firstToken = detailAST.findFirstToken(7);\n+                if (firstToken != null && firstToken.getChildCount() == 3) {\n+                    b = (firstToken.getFirstChild().getFirstChild().getType() == 80);\n                 }\n             }\n         }\n-        return setterMethod;\n+        return b;\n     }\n     \n-    public static boolean isGetterMethod(final DetailAST ast) {\n-        boolean getterMethod = false;\n-        if (ast.getType() == 9 && ast.getChildCount() == 7) {\n-            final DetailAST type = ast.findFirstToken(13);\n-            final String name = type.getNextSibling().getText();\n-            final boolean matchesGetterFormat = CheckUtil.GETTER_PATTERN.matcher(name).matches();\n-            final DetailAST params = ast.findFirstToken(20);\n-            final boolean noParams = params.getChildCount(21) == 0;\n-            if (matchesGetterFormat && noParams) {\n-                final DetailAST slist = ast.findFirstToken(7);\n-                if (slist != null) {\n-                    final DetailAST expr = slist.getFirstChild();\n-                    getterMethod = (expr.getType() == 88);\n+    public static boolean isGetterMethod(final DetailAST detailAST) {\n+        boolean b = false;\n+        if (detailAST.getType() == 9 && detailAST.getChildCount() == 7) {\n+            final boolean matches = CheckUtil.GETTER_PATTERN.matcher(detailAST.findFirstToken(13).getNextSibling().getText()).matches();\n+            final boolean b2 = detailAST.findFirstToken(20).getChildCount(21) == 0;\n+            if (matches && b2) {\n+                final DetailAST firstToken = detailAST.findFirstToken(7);\n+                if (firstToken != null) {\n+                    b = (firstToken.getFirstChild().getType() == 88);\n                 }\n             }\n         }\n-        return getterMethod;\n+        return b;\n     }\n     \n-    public static boolean isNonVoidMethod(final DetailAST methodDefAst) {\n-        boolean returnValue = false;\n-        if (methodDefAst.getType() == 9) {\n-            final DetailAST typeAST = methodDefAst.findFirstToken(13);\n-            if (typeAST.findFirstToken(49) == null) {\n-                returnValue = true;\n-            }\n+    public static boolean isNonVoidMethod(final DetailAST detailAST) {\n+        boolean b = false;\n+        if (detailAST.getType() == 9 && detailAST.findFirstToken(13).findFirstToken(49) == null) {\n+            b = true;\n         }\n-        return returnValue;\n+        return b;\n     }\n     \n-    public static boolean isReceiverParameter(final DetailAST parameterDefAst) {\n-        return parameterDefAst.findFirstToken(58) == null;\n+    public static boolean isReceiverParameter(final DetailAST detailAST) {\n+        return detailAST.findFirstToken(58) == null;\n     }\n     \n-    public static AccessModifierOption getAccessModifierFromModifiersToken(final DetailAST ast) {\n-        final DetailAST modsToken = ast.findFirstToken(5);\n-        AccessModifierOption accessModifier = getAccessModifierFromModifiersTokenDirectly(modsToken);\n-        if (accessModifier == AccessModifierOption.PACKAGE) {\n-            if (ScopeUtil.isInEnumBlock(ast) && ast.getType() == 8) {\n-                accessModifier = AccessModifierOption.PRIVATE;\n+    public static AccessModifierOption getAccessModifierFromModifiersToken(final DetailAST detailAST) {\n+        AccessModifierOption accessModifierOption = getAccessModifierFromModifiersTokenDirectly(detailAST.findFirstToken(5));\n+        if (accessModifierOption == AccessModifierOption.PACKAGE) {\n+            if (ScopeUtil.isInEnumBlock(detailAST) && detailAST.getType() == 8) {\n+                accessModifierOption = AccessModifierOption.PRIVATE;\n             }\n-            else if (ScopeUtil.isInInterfaceOrAnnotationBlock(ast)) {\n-                accessModifier = AccessModifierOption.PUBLIC;\n+            else if (ScopeUtil.isInInterfaceOrAnnotationBlock(detailAST)) {\n+                accessModifierOption = AccessModifierOption.PUBLIC;\n             }\n         }\n-        return accessModifier;\n+        return accessModifierOption;\n     }\n     \n-    private static AccessModifierOption getAccessModifierFromModifiersTokenDirectly(final DetailAST modifiersToken) {\n-        if (modifiersToken == null) {\n+    private static AccessModifierOption getAccessModifierFromModifiersTokenDirectly(final DetailAST detailAST) {\n+        if (detailAST == null) {\n             throw new IllegalArgumentException(\"expected non-null AST-token with type 'MODIFIERS'\");\n         }\n-        AccessModifierOption accessModifier = AccessModifierOption.PACKAGE;\n-        for (DetailAST token = modifiersToken.getFirstChild(); token != null; token = token.getNextSibling()) {\n-            final int tokenType = token.getType();\n-            if (tokenType == 62) {\n-                accessModifier = AccessModifierOption.PUBLIC;\n+        AccessModifierOption accessModifierOption = AccessModifierOption.PACKAGE;\n+        for (DetailAST detailAST2 = detailAST.getFirstChild(); detailAST2 != null; detailAST2 = detailAST2.getNextSibling()) {\n+            final int type = detailAST2.getType();\n+            if (type == 62) {\n+                accessModifierOption = AccessModifierOption.PUBLIC;\n             }\n-            else if (tokenType == 63) {\n-                accessModifier = AccessModifierOption.PROTECTED;\n+            else if (type == 63) {\n+                accessModifierOption = AccessModifierOption.PROTECTED;\n             }\n-            else if (tokenType == 61) {\n-                accessModifier = AccessModifierOption.PRIVATE;\n+            else if (type == 61) {\n+                accessModifierOption = AccessModifierOption.PRIVATE;\n             }\n         }\n-        return accessModifier;\n+        return accessModifierOption;\n     }\n     \n-    public static AccessModifierOption getSurroundingAccessModifier(final DetailAST node) {\n-        AccessModifierOption returnValue = null;\n-        for (DetailAST token = node; returnValue == null && !TokenUtil.isRootNode(token); token = token.getParent()) {\n-            final int type = token.getType();\n+    public static AccessModifierOption getSurroundingAccessModifier(final DetailAST detailAST) {\n+        AccessModifierOption accessModifierFromModifiersToken = null;\n+        for (DetailAST parent = detailAST; accessModifierFromModifiersToken == null && !TokenUtil.isRootNode(parent); parent = parent.getParent()) {\n+            final int type = parent.getType();\n             if (type == 14 || type == 15 || type == 157 || type == 154) {\n-                returnValue = getAccessModifierFromModifiersToken(token);\n+                accessModifierFromModifiersToken = getAccessModifierFromModifiersToken(parent);\n             }\n             else if (type == 136) {\n                 break;\n             }\n         }\n-        return returnValue;\n+        return accessModifierFromModifiersToken;\n     }\n     \n-    public static Set<String> parseClassNames(final String... classNames) {\n-        return Arrays.stream(classNames).flatMap(className -> Stream.of(new String[] { className, CommonUtil.baseClassName(className) })).filter(Predicate.not(String::isEmpty)).collect((Collector<? super Object, ?, Set<String>>)Collectors.toUnmodifiableSet());\n+    public static Set<String> parseClassNames(final String... array) {\n+        return Arrays.stream(array).flatMap(s -> Stream.of(new String[] { s, CommonUtil.baseClassName(s) })).filter(Predicate.not(String::isEmpty)).collect((Collector<? super Object, ?, Set<String>>)Collectors.toUnmodifiableSet());\n     }\n     \n-    public static String stripIndentAndInitialNewLineFromTextBlock(final String textBlockContent) {\n-        final String contentWithInitialNewLineRemoved = CheckUtil.ALL_NEW_LINES.matcher(textBlockContent).replaceFirst(\"\");\n-        final List<String> lines = Arrays.asList(CheckUtil.ALL_NEW_LINES.split((CharSequence)contentWithInitialNewLineRemoved));\n-        final int indent = getSmallestIndent(lines);\n-        final String suffix = \"\";\n-        return lines.stream().map(line -> stripIndentAndTrailingWhitespaceFromLine(line, indent)).collect((Collector<? super Object, ?, String>)Collectors.joining(System.lineSeparator(), \"\", \"\"));\n+    public static String stripIndentAndInitialNewLineFromTextBlock(final String input) {\n+        return Arrays.asList(CheckUtil.ALL_NEW_LINES.split((CharSequence)CheckUtil.ALL_NEW_LINES.matcher(input).replaceFirst(\"\"))).stream().map(s -> {\n+            final List list;\n+            getSmallestIndent(list);\n+            return stripIndentAndTrailingWhitespaceFromLine(s, n);\n+        }).collect((Collector<? super Object, ?, String>)Collectors.joining(System.lineSeparator(), \"\", \"\"));\n     }\n     \n-    private static String stripIndentAndTrailingWhitespaceFromLine(final String line, final int indent) {\n-        final int lastNonWhitespace = lastIndexOfNonWhitespace(line);\n-        String returnString = \"\";\n-        if (lastNonWhitespace > 0) {\n-            returnString = line.substring(indent, lastNonWhitespace);\n+    private static String stripIndentAndTrailingWhitespaceFromLine(final String s, final int beginIndex) {\n+        final int lastIndexOfNonWhitespace = lastIndexOfNonWhitespace(s);\n+        String substring = \"\";\n+        if (lastIndexOfNonWhitespace > 0) {\n+            substring = s.substring(beginIndex, lastIndexOfNonWhitespace);\n         }\n-        return returnString;\n+        return substring;\n     }\n     \n-    private static int getSmallestIndent(final Collection<String> lines) {\n-        return lines.stream().mapToInt(CommonUtil::indexOfNonWhitespace).min().orElse(0);\n+    private static int getSmallestIndent(final Collection<String> collection) {\n+        return collection.stream().mapToInt(CommonUtil::indexOfNonWhitespace).min().orElse(0);\n     }\n     \n-    private static int lastIndexOfNonWhitespace(final String line) {\n+    private static int lastIndexOfNonWhitespace(final String s) {\n         int length;\n-        for (length = line.length(); length > 0 && Character.isWhitespace(line.charAt(length - 1)); --length) {}\n+        for (length = s.length(); length > 0 && Character.isWhitespace(s.charAt(length - 1)); --length) {}\n         return length;\n     }\n     \n-    public static int typeDeclarationNameMatchingCount(final String patternClass, final String classToBeMatched) {\n-        final int length = Math.min(classToBeMatched.length(), patternClass.length());\n-        int result = 0;\n-        for (int i = 0; i < length && patternClass.charAt(i) == classToBeMatched.charAt(i); ++i) {\n-            if (patternClass.charAt(i) == '.') {\n-                result = i;\n-            }\n-        }\n-        return result;\n-    }\n-    \n-    public static String getQualifiedTypeDeclarationName(final String packageName, final String outerClassQualifiedName, final String className) {\n-        String qualifiedClassName;\n-        if (outerClassQualifiedName == null) {\n-            if (packageName == null) {\n-                qualifiedClassName = className;\n+    public static int typeDeclarationNameMatchingCount(final String s, final String s2) {\n+        final int min = Math.min(s2.length(), s.length());\n+        int n = 0;\n+        for (int index = 0; index < min && s.charAt(index) == s2.charAt(index); ++index) {\n+            if (s.charAt(index) == '.') {\n+                n = index;\n+            }\n+        }\n+        return n;\n+    }\n+    \n+    public static String getQualifiedTypeDeclarationName(final String s, final String s2, final String s3) {\n+        String s4;\n+        if (s2 == null) {\n+            if (s == null) {\n+                s4 = s3;\n             }\n             else {\n-                qualifiedClassName = packageName + \".\" + className;\n+                s4 = s + \".\" + s3;\n             }\n         }\n         else {\n-            qualifiedClassName = outerClassQualifiedName + \".\" + className;\n+            s4 = s2 + \".\" + s3;\n         }\n-        return qualifiedClassName;\n+        return s4;\n     }\n     \n-    public static String extractQualifiedName(final DetailAST ast) {\n-        return FullIdent.createFullIdent(ast).getText();\n+    public static String extractQualifiedName(final DetailAST detailAST) {\n+        return FullIdent.createFullIdent(detailAST).getText();\n     }\n     \n-    public static String getShortNameOfAnonInnerClass(final DetailAST literalNewAst) {\n-        DetailAST parentAst;\n-        for (parentAst = literalNewAst; TokenUtil.isOfType(parentAst, new int[] { 136, 59 }); parentAst = parentAst.getParent()) {}\n-        final DetailAST firstChild = parentAst.getFirstChild();\n-        return extractQualifiedName(firstChild);\n+    public static String getShortNameOfAnonInnerClass(final DetailAST detailAST) {\n+        DetailAST parent;\n+        for (parent = detailAST; TokenUtil.isOfType(parent, new int[] { 136, 59 }); parent = parent.getParent()) {}\n+        return extractQualifiedName(parent.getFirstChild());\n     }\n     \n-    public static boolean isPackageInfo(final String filePath) {\n-        return \"package-info.java\".equals(new File(filePath).getName());\n+    public static boolean isPackageInfo(final String pathname) {\n+        return \"package-info.java\".equals(new File(pathname).getName());\n     }\n     \n     static {\n         UNDERSCORE_PATTERN = Pattern.compile(\"_\");\n         SETTER_PATTERN = Pattern.compile(\"^set[A-Z].*\");\n         GETTER_PATTERN = Pattern.compile(\"^(is|get)[A-Z].*\");\n         ALL_NEW_LINES = Pattern.compile(\"\\\\R\");\n"}]}
