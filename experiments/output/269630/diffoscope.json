{"diffoscope-json-version": 1, "source1": "first/TokenUtil.class", "source2": "second/TokenUtil.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -25,132 +25,130 @@\n     private static final int[] TOKEN_IDS;\n     private static final String TOKEN_ID_EXCEPTION_FORMAT = \"unknown TokenTypes id '%s'\";\n     private static final String TOKEN_NAME_EXCEPTION_FORMAT = \"unknown TokenTypes value '%s'\";\n     \n     private TokenUtil() {\n     }\n     \n-    public static int getIntFromField(final Field field, final Object object) {\n+    public static int getIntFromField(final Field field, final Object obj) {\n         try {\n-            return field.getInt(object);\n+            return field.getInt(obj);\n         }\n-        catch (final IllegalAccessException exception) {\n-            throw new IllegalStateException(exception);\n+        catch (final IllegalAccessException cause) {\n+            throw new IllegalStateException(cause);\n         }\n     }\n     \n-    public static Map<String, Integer> nameToValueMapFromPublicIntFields(final Class<?> cls) {\n-        return Arrays.stream(cls.getDeclaredFields()).filter(fld -> Modifier.isPublic(fld.getModifiers()) && fld.getType() == Integer.TYPE).collect(Collectors.toUnmodifiableMap((Function<? super Field, ? extends String>)Field::getName, fld -> Integer.valueOf(getIntFromField(fld, (Object)fld.getName()))));\n+    public static Map<String, Integer> nameToValueMapFromPublicIntFields(final Class<?> clazz) {\n+        return Arrays.stream(clazz.getDeclaredFields()).filter(field -> Modifier.isPublic(field.getModifiers()) && field.getType() == Integer.TYPE).collect(Collectors.toUnmodifiableMap((Function<? super Field, ? extends String>)Field::getName, field2 -> Integer.valueOf(getIntFromField(field2, (Object)field2.getName()))));\n     }\n     \n     public static Map<Integer, String> invertMap(final Map<String, Integer> map) {\n         return map.entrySet().stream().collect(Collectors.toMap((Function<? super Object, ? extends Integer>)Map.Entry::getValue, (Function<? super Object, ? extends String>)Map.Entry::getKey));\n     }\n     \n     public static int getTokenTypesTotalNumber() {\n         return TokenUtil.TOKEN_IDS.length;\n     }\n     \n     public static int[] getAllTokenIds() {\n-        final int[] safeCopy = new int[TokenUtil.TOKEN_IDS.length];\n-        System.arraycopy(TokenUtil.TOKEN_IDS, 0, safeCopy, 0, TokenUtil.TOKEN_IDS.length);\n-        return safeCopy;\n+        final int[] array = new int[TokenUtil.TOKEN_IDS.length];\n+        System.arraycopy(TokenUtil.TOKEN_IDS, 0, array, 0, TokenUtil.TOKEN_IDS.length);\n+        return array;\n     }\n     \n-    public static String getTokenName(final int id) {\n-        final String name = (String)TokenUtil.TOKEN_VALUE_TO_NAME.get(Integer.valueOf(id));\n-        if (name == null) {\n-            throw new IllegalArgumentException(String.format(Locale.ROOT, \"unknown TokenTypes id '%s'\", Integer.valueOf(id)));\n+    public static String getTokenName(final int n) {\n+        final String s = (String)TokenUtil.TOKEN_VALUE_TO_NAME.get(Integer.valueOf(n));\n+        if (s == null) {\n+            throw new IllegalArgumentException(String.format(Locale.ROOT, \"unknown TokenTypes id '%s'\", Integer.valueOf(n)));\n         }\n-        return name;\n+        return s;\n     }\n     \n-    public static int getTokenId(final String name) {\n-        final Integer id = Integer.valueOf(TokenUtil.TOKEN_NAME_TO_VALUE.get((Object)name));\n-        if (id == null) {\n-            throw new IllegalArgumentException(String.format(Locale.ROOT, \"unknown TokenTypes value '%s'\", name));\n+    public static int getTokenId(final String s) {\n+        final Integer n = Integer.valueOf(TokenUtil.TOKEN_NAME_TO_VALUE.get((Object)s));\n+        if (n == null) {\n+            throw new IllegalArgumentException(String.format(Locale.ROOT, \"unknown TokenTypes value '%s'\", s));\n         }\n-        return id;\n+        return n;\n     }\n     \n-    public static String getShortDescription(final String name) {\n-        if (!TokenUtil.TOKEN_NAME_TO_VALUE.containsKey(name)) {\n-            throw new IllegalArgumentException(String.format(Locale.ROOT, \"unknown TokenTypes value '%s'\", name));\n+    public static String getShortDescription(final String key) {\n+        if (!TokenUtil.TOKEN_NAME_TO_VALUE.containsKey(key)) {\n+            throw new IllegalArgumentException(String.format(Locale.ROOT, \"unknown TokenTypes value '%s'\", key));\n         }\n-        final String tokenTypes = \"com.puppycrawl.tools.checkstyle.api.tokentypes\";\n-        final ResourceBundle bundle = ResourceBundle.getBundle(\"com.puppycrawl.tools.checkstyle.api.tokentypes\", Locale.ROOT);\n-        return bundle.getString(name);\n+        return ResourceBundle.getBundle(\"com.puppycrawl.tools.checkstyle.api.tokentypes\", Locale.ROOT).getString(key);\n     }\n     \n-    public static boolean isCommentType(final int type) {\n-        return type == 144 || type == 145 || type == 182 || type == 183;\n+    public static boolean isCommentType(final int n) {\n+        return n == 144 || n == 145 || n == 182 || n == 183;\n     }\n     \n-    public static boolean isCommentType(final String type) {\n-        return isCommentType(getTokenId(type));\n+    public static boolean isCommentType(final String s) {\n+        return isCommentType(getTokenId(s));\n     }\n     \n-    public static Optional<DetailAST> findFirstTokenByPredicate(final DetailAST root, final Predicate<DetailAST> predicate) {\n-        Optional<DetailAST> result = Optional.empty();\n-        for (DetailAST ast = root.getFirstChild(); ast != null; ast = ast.getNextSibling()) {\n-            if (predicate.test(ast)) {\n-                result = Optional.of(ast);\n+    public static Optional<DetailAST> findFirstTokenByPredicate(final DetailAST detailAST, final Predicate<DetailAST> predicate) {\n+        Object o = Optional.empty();\n+        for (DetailAST value = detailAST.getFirstChild(); value != null; value = value.getNextSibling()) {\n+            if (predicate.test(value)) {\n+                o = Optional.of(value);\n                 break;\n             }\n         }\n-        return result;\n+        return (Optional<DetailAST>)o;\n     }\n     \n-    public static void forEachChild(final DetailAST root, final int type, final Consumer<DetailAST> action) {\n-        for (DetailAST ast = root.getFirstChild(); ast != null; ast = ast.getNextSibling()) {\n-            if (ast.getType() == type) {\n-                action.accept(ast);\n+    public static void forEachChild(final DetailAST detailAST, final int n, final Consumer<DetailAST> consumer) {\n+        for (DetailAST detailAST2 = detailAST.getFirstChild(); detailAST2 != null; detailAST2 = detailAST2.getNextSibling()) {\n+            if (detailAST2.getType() == n) {\n+                consumer.accept(detailAST2);\n             }\n         }\n     }\n     \n-    public static boolean areOnSameLine(final DetailAST ast1, final DetailAST ast2) {\n-        return ast1.getLineNo() == ast2.getLineNo();\n+    public static boolean areOnSameLine(final DetailAST detailAST, final DetailAST detailAST2) {\n+        return detailAST.getLineNo() == detailAST2.getLineNo();\n     }\n     \n-    public static boolean isTypeDeclaration(final int type) {\n-        return type == 14 || type == 15 || type == 157 || type == 154 || type == 199;\n+    public static boolean isTypeDeclaration(final int n) {\n+        return n == 14 || n == 15 || n == 157 || n == 154 || n == 199;\n     }\n     \n-    public static boolean isOfType(final int type, final int... types) {\n-        boolean matching = false;\n-        for (final int tokenType : types) {\n-            if (tokenType == type) {\n-                matching = true;\n+    public static boolean isOfType(final int n, final int... array) {\n+        boolean b = false;\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            if (array[i] == n) {\n+                b = true;\n                 break;\n             }\n         }\n-        return matching;\n+        return b;\n     }\n     \n-    public static boolean isOfType(final DetailAST ast, final int... types) {\n-        return ast != null && isOfType(ast.getType(), types);\n+    public static boolean isOfType(final DetailAST detailAST, final int... array) {\n+        return detailAST != null && isOfType(detailAST.getType(), array);\n     }\n     \n-    public static boolean isRootNode(final DetailAST ast) {\n-        return ast.getType() == 1;\n+    public static boolean isRootNode(final DetailAST detailAST) {\n+        return detailAST.getType() == 1;\n     }\n     \n-    public static boolean isBooleanLiteralType(final int tokenType) {\n-        final boolean isTrue = tokenType == 133;\n-        final boolean isFalse = tokenType == 134;\n-        return isTrue || isFalse;\n+    public static boolean isBooleanLiteralType(final int n) {\n+        final boolean b = n == 133;\n+        final boolean b2 = n == 134;\n+        return b || b2;\n     }\n     \n-    public static BitSet asBitSet(final int... tokens) {\n-        return IntStream.of(tokens).collect(BitSet::new, BitSet::set, BitSet::or);\n+    public static BitSet asBitSet(final int... values) {\n+        return IntStream.of(values).collect(BitSet::new, BitSet::set, BitSet::or);\n     }\n     \n-    public static BitSet asBitSet(final String... tokens) {\n-        return Arrays.stream(tokens).map((Function<? super String, ?>)String::trim).filter(Predicate.not(String::isEmpty)).mapToInt((ToIntFunction<? super Object>)TokenUtil::getTokenId).collect(BitSet::new, BitSet::set, BitSet::or);\n+    public static BitSet asBitSet(final String... array) {\n+        return Arrays.stream(array).map((Function<? super String, ?>)String::trim).filter(Predicate.not(String::isEmpty)).mapToInt((ToIntFunction<? super Object>)TokenUtil::getTokenId).collect(BitSet::new, BitSet::set, BitSet::or);\n     }\n     \n     static {\n         TOKEN_NAME_TO_VALUE = nameToValueMapFromPublicIntFields(TokenTypes.class);\n         TOKEN_VALUE_TO_NAME = invertMap(TokenUtil.TOKEN_NAME_TO_VALUE);\n         TOKEN_IDS = TokenUtil.TOKEN_NAME_TO_VALUE.values().stream().mapToInt(Integer::intValue).toArray();\n     }\n"}]}
