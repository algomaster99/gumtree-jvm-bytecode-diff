{"diffoscope-json-version": 1, "source1": "first/DaitchMokotoffSoundex.class", "source2": "second/DaitchMokotoffSoundex.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,15 +1,14 @@\n \n package org.apache.commons.codec.language;\n \n import java.util.Comparator;\n import org.apache.commons.codec.Resources;\n import java.util.HashMap;\n import java.util.Iterator;\n-import java.util.Set;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.LinkedHashSet;\n import org.apache.commons.codec.EncoderException;\n import java.util.ArrayList;\n import java.util.Scanner;\n import java.util.List;\n@@ -24,196 +23,192 @@\n     private static final String MULTILINE_COMMENT_START = \"/*\";\n     private static final String RESOURCE_FILE = \"org/apache/commons/codec/language/dmrules.txt\";\n     private static final int MAX_LENGTH = 6;\n     private static final Map<Character, List<DaitchMokotoffSoundex.Rule>> RULES;\n     private static final Map<Character, Character> FOLDINGS;\n     private final boolean folding;\n     \n-    private static void parseRules(final Scanner scanner, final String location, final Map<Character, List<DaitchMokotoffSoundex.Rule>> ruleMapping, final Map<Character, Character> asciiFoldings) {\n-        int currentLine = 0;\n-        boolean inMultilineComment = false;\n+    private static void parseRules(final Scanner scanner, final String s, final Map<Character, List<DaitchMokotoffSoundex.Rule>> map, final Map<Character, Character> map2) {\n+        int i = 0;\n+        int n = 0;\n         while (scanner.hasNextLine()) {\n-            ++currentLine;\n-            String line;\n-            final String rawLine = line = scanner.nextLine();\n-            if (inMultilineComment) {\n-                if (!line.endsWith(\"*/\")) {\n+            ++i;\n+            String s2;\n+            final String str = s2 = scanner.nextLine();\n+            if (n != 0) {\n+                if (!s2.endsWith(\"*/\")) {\n                     continue;\n                 }\n-                inMultilineComment = false;\n+                n = 0;\n             }\n-            else if (line.startsWith(\"/*\")) {\n-                inMultilineComment = true;\n+            else if (s2.startsWith(\"/*\")) {\n+                n = 1;\n             }\n             else {\n-                final int cmtI = line.indexOf(\"//\");\n-                if (cmtI >= 0) {\n-                    line = line.substring(0, cmtI);\n+                final int index = s2.indexOf(\"//\");\n+                if (index >= 0) {\n+                    s2 = s2.substring(0, index);\n                 }\n-                line = line.trim();\n-                if (line.length() == 0) {\n+                final String trim = s2.trim();\n+                if (trim.length() == 0) {\n                     continue;\n                 }\n-                if (line.contains(\"=\")) {\n-                    final String[] parts = line.split(\"=\");\n-                    if (parts.length != 2) {\n-                        throw new IllegalArgumentException(\"Malformed folding statement split into \" + parts.length + \" parts: \" + rawLine + \" in \" + location);\n-                    }\n-                    final String leftCharacter = parts[0];\n-                    final String rightCharacter = parts[1];\n-                    if (leftCharacter.length() != 1 || rightCharacter.length() != 1) {\n-                        throw new IllegalArgumentException(\"Malformed folding statement - patterns are not single characters: \" + rawLine + \" in \" + location);\n+                if (trim.contains(\"=\")) {\n+                    final String[] split = trim.split(\"=\");\n+                    if (split.length != 2) {\n+                        throw new IllegalArgumentException(\"Malformed folding statement split into \" + split.length + \" parts: \" + str + \" in \" + s);\n+                    }\n+                    final String s3 = split[0];\n+                    final String s4 = split[1];\n+                    if (s3.length() != 1 || s4.length() != 1) {\n+                        throw new IllegalArgumentException(\"Malformed folding statement - patterns are not single characters: \" + str + \" in \" + s);\n                     }\n-                    asciiFoldings.put(Character.valueOf(leftCharacter.charAt(0)), Character.valueOf(rightCharacter.charAt(0)));\n+                    map2.put(Character.valueOf(s3.charAt(0)), Character.valueOf(s4.charAt(0)));\n                 }\n                 else {\n-                    final String[] parts = line.split(\"\\\\s+\");\n-                    if (parts.length != 4) {\n-                        throw new IllegalArgumentException(\"Malformed rule statement split into \" + parts.length + \" parts: \" + rawLine + \" in \" + location);\n+                    final String[] split2 = trim.split(\"\\\\s+\");\n+                    if (split2.length != 4) {\n+                        throw new IllegalArgumentException(\"Malformed rule statement split into \" + split2.length + \" parts: \" + str + \" in \" + s);\n                     }\n                     try {\n-                        final String pattern = stripQuotes(parts[0]);\n-                        final String replacement1 = stripQuotes(parts[1]);\n-                        final String replacement2 = stripQuotes(parts[2]);\n-                        final String replacement3 = stripQuotes(parts[3]);\n-                        final DaitchMokotoffSoundex.Rule r = new DaitchMokotoffSoundex.Rule(pattern, replacement1, replacement2, replacement3);\n-                        final char patternKey = DaitchMokotoffSoundex.Rule.access$000(r).charAt(0);\n-                        List<DaitchMokotoffSoundex.Rule> rules = (List<DaitchMokotoffSoundex.Rule>)ruleMapping.get(Character.valueOf(patternKey));\n-                        if (rules == null) {\n-                            rules = new ArrayList<DaitchMokotoffSoundex.Rule>();\n-                            ruleMapping.put(Character.valueOf(patternKey), rules);\n+                        final DaitchMokotoffSoundex.Rule rule = new DaitchMokotoffSoundex.Rule(stripQuotes(split2[0]), stripQuotes(split2[1]), stripQuotes(split2[2]), stripQuotes(split2[3]));\n+                        final char char1 = DaitchMokotoffSoundex.Rule.access$000(rule).charAt(0);\n+                        List list = (List)map.get(Character.valueOf(char1));\n+                        if (list == null) {\n+                            list = new ArrayList();\n+                            map.put(Character.valueOf(char1), list);\n                         }\n-                        rules.add(r);\n+                        list.add(rule);\n                     }\n-                    catch (final IllegalArgumentException e) {\n-                        throw new IllegalStateException(\"Problem parsing line '\" + currentLine + \"' in \" + location, e);\n+                    catch (final IllegalArgumentException cause) {\n+                        throw new IllegalStateException(\"Problem parsing line '\" + i + \"' in \" + s, cause);\n                     }\n                 }\n             }\n         }\n     }\n     \n-    private static String stripQuotes(String str) {\n-        if (str.startsWith(\"\\\"\")) {\n-            str = str.substring(1);\n+    private static String stripQuotes(String s) {\n+        if (s.startsWith(\"\\\"\")) {\n+            s = s.substring(1);\n         }\n-        if (str.endsWith(\"\\\"\")) {\n-            str = str.substring(0, str.length() - 1);\n+        if (s.endsWith(\"\\\"\")) {\n+            s = s.substring(0, s.length() - 1);\n         }\n-        return str;\n+        return s;\n     }\n     \n     public DaitchMokotoffSoundex() {\n         this(true);\n     }\n     \n     public DaitchMokotoffSoundex(final boolean folding) {\n         this.folding = folding;\n     }\n     \n-    private String cleanup(final String input) {\n+    private String cleanup(final String s) {\n         final StringBuilder sb = new StringBuilder();\n-        for (char ch : input.toCharArray()) {\n-            if (!Character.isWhitespace(ch)) {\n-                ch = Character.toLowerCase(ch);\n-                if (this.folding && DaitchMokotoffSoundex.FOLDINGS.containsKey(Character.valueOf(ch))) {\n-                    ch = Character.valueOf(DaitchMokotoffSoundex.FOLDINGS.get((Object)Character.valueOf(ch)));\n+        for (final char c : s.toCharArray()) {\n+            if (!Character.isWhitespace(c)) {\n+                char c2 = Character.toLowerCase(c);\n+                if (this.folding && DaitchMokotoffSoundex.FOLDINGS.containsKey(Character.valueOf(c2))) {\n+                    c2 = Character.valueOf(DaitchMokotoffSoundex.FOLDINGS.get((Object)Character.valueOf(c2)));\n                 }\n-                sb.append(ch);\n+                sb.append(c2);\n             }\n         }\n         return sb.toString();\n     }\n     \n-    public Object encode(final Object obj) throws EncoderException {\n-        if (!(obj instanceof String)) {\n+    public Object encode(final Object o) throws EncoderException {\n+        if (!(o instanceof String)) {\n             throw new EncoderException(\"Parameter supplied to DaitchMokotoffSoundex encode is not of type java.lang.String\");\n         }\n-        return this.encode((String)obj);\n+        return this.encode((String)o);\n     }\n     \n-    public String encode(final String source) {\n-        if (source == null) {\n+    public String encode(final String s) {\n+        if (s == null) {\n             return null;\n         }\n-        return this.soundex(source, false)[0];\n+        return this.soundex(s, false)[0];\n     }\n     \n-    public String soundex(final String source) {\n-        final String[] branches = this.soundex(source, true);\n+    public String soundex(final String s) {\n+        final String[] soundex = this.soundex(s, true);\n         final StringBuilder sb = new StringBuilder();\n-        int index = 0;\n-        for (final String branch : branches) {\n-            sb.append(branch);\n-            if (++index < branches.length) {\n+        int n = 0;\n+        final String[] array = soundex;\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            sb.append(array[i]);\n+            if (++n < soundex.length) {\n                 sb.append('|');\n             }\n         }\n         return sb.toString();\n     }\n     \n-    private String[] soundex(final String source, final boolean branching) {\n-        if (source == null) {\n+    private String[] soundex(final String s, final boolean b) {\n+        if (s == null) {\n             return null;\n         }\n-        final String input = this.cleanup(source);\n-        final Set<DaitchMokotoffSoundex.Branch> currentBranches = new LinkedHashSet<DaitchMokotoffSoundex.Branch>();\n-        currentBranches.add(new DaitchMokotoffSoundex.Branch((DaitchMokotoffSoundex.DaitchMokotoffSoundex$1)null));\n-        char lastChar = '\\0';\n-        for (int index = 0; index < input.length(); ++index) {\n-            final char ch = input.charAt(index);\n-            if (!Character.isWhitespace(ch)) {\n-                final String inputContext = input.substring(index);\n-                final List<DaitchMokotoffSoundex.Rule> rules = (List<DaitchMokotoffSoundex.Rule>)DaitchMokotoffSoundex.RULES.get(Character.valueOf(ch));\n-                if (rules != null) {\n-                    final List<DaitchMokotoffSoundex.Branch> nextBranches = branching ? new ArrayList<DaitchMokotoffSoundex.Branch>() : Collections.emptyList();\n-                    for (final DaitchMokotoffSoundex.Rule rule : rules) {\n-                        if (rule.matches(inputContext)) {\n-                            if (branching) {\n-                                nextBranches.clear();\n+        final String cleanup = this.cleanup(s);\n+        final LinkedHashSet set = new LinkedHashSet();\n+        set.add(new DaitchMokotoffSoundex.Branch((DaitchMokotoffSoundex.DaitchMokotoffSoundex$1)null));\n+        char c = '\\0';\n+        for (int i = 0; i < cleanup.length(); ++i) {\n+            final char char1 = cleanup.charAt(i);\n+            if (!Character.isWhitespace(char1)) {\n+                final String substring = cleanup.substring(i);\n+                final List list = (List)DaitchMokotoffSoundex.RULES.get(Character.valueOf(char1));\n+                if (list != null) {\n+                    final List<DaitchMokotoffSoundex.Branch> list2 = b ? new ArrayList<DaitchMokotoffSoundex.Branch>() : Collections.emptyList();\n+                    for (final DaitchMokotoffSoundex.Rule rule : list) {\n+                        if (rule.matches(substring)) {\n+                            if (b) {\n+                                list2.clear();\n                             }\n-                            final String[] replacements = rule.getReplacements(inputContext, lastChar == '\\0');\n-                            final boolean branchingRequired = replacements.length > 1 && branching;\n-                            for (final DaitchMokotoffSoundex.Branch branch : currentBranches) {\n-                                for (final String nextReplacement : replacements) {\n-                                    final DaitchMokotoffSoundex.Branch nextBranch = branchingRequired ? branch.createBranch() : branch;\n-                                    final boolean force = (lastChar == 'm' && ch == 'n') || (lastChar == 'n' && ch == 'm');\n-                                    nextBranch.processNextReplacement(nextReplacement, force);\n-                                    if (!branching) {\n+                            final String[] replacements = rule.getReplacements(substring, c == '\\0');\n+                            final boolean b2 = replacements.length > 1 && b;\n+                            for (final DaitchMokotoffSoundex.Branch branch : set) {\n+                                for (final String s2 : replacements) {\n+                                    final DaitchMokotoffSoundex.Branch branch2 = b2 ? branch.createBranch() : branch;\n+                                    branch2.processNextReplacement(s2, (c == 'm' && char1 == 'n') || (c == 'n' && char1 == 'm'));\n+                                    if (!b) {\n                                         break;\n                                     }\n-                                    nextBranches.add(nextBranch);\n+                                    list2.add(branch2);\n                                 }\n                             }\n-                            if (branching) {\n-                                currentBranches.clear();\n-                                currentBranches.addAll(nextBranches);\n+                            if (b) {\n+                                set.clear();\n+                                set.addAll(list2);\n                             }\n-                            index += rule.getPatternLength() - 1;\n+                            i += rule.getPatternLength() - 1;\n                             break;\n                         }\n                     }\n-                    lastChar = ch;\n+                    c = char1;\n                 }\n             }\n         }\n-        final String[] result = new String[currentBranches.size()];\n-        int index2 = 0;\n-        for (final DaitchMokotoffSoundex.Branch branch2 : currentBranches) {\n-            branch2.finish();\n-            result[index2++] = branch2.toString();\n+        final String[] array2 = new String[set.size()];\n+        int n = 0;\n+        for (final DaitchMokotoffSoundex.Branch branch3 : set) {\n+            branch3.finish();\n+            array2[n++] = branch3.toString();\n         }\n-        return result;\n+        return array2;\n     }\n     \n     static {\n         RULES = new HashMap<Character, List<DaitchMokotoffSoundex.Rule>>();\n         FOLDINGS = new HashMap<Character, Character>();\n         try (final Scanner scanner = new Scanner(Resources.getInputStream(\"org/apache/commons/codec/language/dmrules.txt\"), \"UTF-8\")) {\n             parseRules(scanner, \"org/apache/commons/codec/language/dmrules.txt\", DaitchMokotoffSoundex.RULES, DaitchMokotoffSoundex.FOLDINGS);\n         }\n-        for (final Map.Entry<Character, List<DaitchMokotoffSoundex.Rule>> rule : DaitchMokotoffSoundex.RULES.entrySet()) {\n-            final List<DaitchMokotoffSoundex.Rule> ruleList = (List<DaitchMokotoffSoundex.Rule>)rule.getValue();\n-            Collections.sort(ruleList, (Comparator<? super DaitchMokotoffSoundex.Rule>)new DaitchMokotoffSoundex.DaitchMokotoffSoundex$1());\n+        final Iterator<Map.Entry<Character, List<DaitchMokotoffSoundex.Rule>>> iterator = DaitchMokotoffSoundex.RULES.entrySet().iterator();\n+        while (iterator.hasNext()) {\n+            Collections.sort((List<Object>)(List<T>)((Map.Entry<K, List<T>>)iterator.next()).getValue(), (Comparator<? super Object>)new DaitchMokotoffSoundex.DaitchMokotoffSoundex$1());\n         }\n     }\n }\n"}]}
