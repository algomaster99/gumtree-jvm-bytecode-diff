{"diffoscope-json-version": 1, "source1": "first/TypeUtils.class", "source2": "second/TypeUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,17 +1,15 @@\n \n package org.apache.commons.lang3.reflect;\n \n-import java.lang.reflect.GenericDeclaration;\n import org.apache.commons.lang3.ObjectUtils;\n import java.util.Objects;\n import org.apache.commons.lang3.ArrayUtils;\n import java.util.Collections;\n import java.lang.reflect.Array;\n-import java.util.Set;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Arrays;\n import org.apache.commons.lang3.Validate;\n import java.util.HashMap;\n import java.util.Iterator;\n import org.apache.commons.lang3.ClassUtils;\n@@ -22,661 +20,669 @@\n import java.lang.reflect.Type;\n import java.lang.reflect.WildcardType;\n \n public class TypeUtils\n {\n     public static final WildcardType WILDCARD_ALL;\n     \n-    public static boolean isAssignable(final Type type, final Type toType) {\n-        return isAssignable(type, toType, null);\n+    public static boolean isAssignable(final Type type, final Type type2) {\n+        return isAssignable(type, type2, null);\n     }\n     \n-    private static boolean isAssignable(final Type type, final Type toType, final Map<TypeVariable<?>, Type> typeVarAssigns) {\n-        if (toType == null || toType instanceof Class) {\n-            return isAssignable(type, (Class<?>)toType);\n+    private static boolean isAssignable(final Type type, final Type obj, final Map<TypeVariable<?>, Type> map) {\n+        if (obj == null || obj instanceof Class) {\n+            return isAssignable(type, (Class<?>)obj);\n         }\n-        if (toType instanceof ParameterizedType) {\n-            return isAssignable(type, (ParameterizedType)toType, typeVarAssigns);\n+        if (obj instanceof ParameterizedType) {\n+            return isAssignable(type, (ParameterizedType)obj, map);\n         }\n-        if (toType instanceof GenericArrayType) {\n-            return isAssignable(type, (GenericArrayType)toType, typeVarAssigns);\n+        if (obj instanceof GenericArrayType) {\n+            return isAssignable(type, (GenericArrayType)obj, map);\n         }\n-        if (toType instanceof WildcardType) {\n-            return isAssignable(type, (WildcardType)toType, typeVarAssigns);\n+        if (obj instanceof WildcardType) {\n+            return isAssignable(type, (WildcardType)obj, map);\n         }\n-        if (toType instanceof TypeVariable) {\n-            return isAssignable(type, (TypeVariable<?>)toType, typeVarAssigns);\n+        if (obj instanceof TypeVariable) {\n+            return isAssignable(type, (TypeVariable<?>)obj, map);\n         }\n-        throw new IllegalStateException(\"found an unhandled type: \" + toType);\n+        throw new IllegalStateException(\"found an unhandled type: \" + obj);\n     }\n     \n-    private static boolean isAssignable(final Type type, final Class<?> toClass) {\n+    private static boolean isAssignable(final Type type, final Class<?> clazz) {\n         if (type == null) {\n-            return toClass == null || !toClass.isPrimitive();\n+            return clazz == null || !clazz.isPrimitive();\n         }\n-        if (toClass == null) {\n+        if (clazz == null) {\n             return false;\n         }\n-        if (toClass.equals(type)) {\n+        if (clazz.equals(type)) {\n             return true;\n         }\n         if (type instanceof Class) {\n-            return ClassUtils.isAssignable((Class)type, (Class)toClass);\n+            return ClassUtils.isAssignable((Class)type, (Class)clazz);\n         }\n         if (type instanceof ParameterizedType) {\n-            return isAssignable(getRawType((ParameterizedType)type), toClass);\n+            return isAssignable(getRawType((ParameterizedType)type), clazz);\n         }\n         if (type instanceof TypeVariable) {\n-            for (final Type bound : ((TypeVariable)type).getBounds()) {\n-                if (isAssignable(bound, toClass)) {\n+            final Type[] bounds = ((TypeVariable)type).getBounds();\n+            for (int length = bounds.length, i = 0; i < length; ++i) {\n+                if (isAssignable(bounds[i], clazz)) {\n                     return true;\n                 }\n             }\n             return false;\n         }\n         if (type instanceof GenericArrayType) {\n-            return toClass.equals(Object.class) || (toClass.isArray() && isAssignable(((GenericArrayType)type).getGenericComponentType(), toClass.getComponentType()));\n+            return clazz.equals(Object.class) || (clazz.isArray() && isAssignable(((GenericArrayType)type).getGenericComponentType(), clazz.getComponentType()));\n         }\n         if (type instanceof WildcardType) {\n             return false;\n         }\n         throw new IllegalStateException(\"found an unhandled type: \" + type);\n     }\n     \n-    private static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) {\n-        if (type == null) {\n+    private static boolean isAssignable(final Type obj, final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> map) {\n+        if (obj == null) {\n             return true;\n         }\n-        if (toParameterizedType == null) {\n+        if (parameterizedType == null) {\n             return false;\n         }\n-        if (toParameterizedType.equals(type)) {\n+        if (parameterizedType.equals(obj)) {\n             return true;\n         }\n-        final Class<?> toClass = getRawType(toParameterizedType);\n-        final Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null);\n-        if (fromTypeVarAssigns == null) {\n+        final Class<?> rawType = getRawType(parameterizedType);\n+        final Map<TypeVariable<?>, Type> typeArguments = getTypeArguments(obj, rawType, null);\n+        if (typeArguments == null) {\n             return false;\n         }\n-        if (fromTypeVarAssigns.isEmpty()) {\n+        if (typeArguments.isEmpty()) {\n             return true;\n         }\n-        final Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType, toClass, typeVarAssigns);\n-        for (final TypeVariable<?> var : toTypeVarAssigns.keySet()) {\n-            final Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns);\n-            final Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns);\n-            if (toTypeArg == null && fromTypeArg instanceof Class) {\n+        final Map<TypeVariable<?>, Type> typeArguments2 = getTypeArguments(parameterizedType, rawType, map);\n+        for (final TypeVariable typeVariable : typeArguments2.keySet()) {\n+            final Type unrollVariableAssignments = unrollVariableAssignments(typeVariable, typeArguments2);\n+            final Type unrollVariableAssignments2 = unrollVariableAssignments(typeVariable, typeArguments);\n+            if (unrollVariableAssignments == null && unrollVariableAssignments2 instanceof Class) {\n                 continue;\n             }\n-            if (fromTypeArg != null && !toTypeArg.equals(fromTypeArg) && (!(toTypeArg instanceof WildcardType) || !isAssignable(fromTypeArg, toTypeArg, typeVarAssigns))) {\n+            if (unrollVariableAssignments2 != null && !unrollVariableAssignments.equals(unrollVariableAssignments2) && (!(unrollVariableAssignments instanceof WildcardType) || !isAssignable(unrollVariableAssignments2, unrollVariableAssignments, map))) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    private static Type unrollVariableAssignments(TypeVariable<?> var, final Map<TypeVariable<?>, Type> typeVarAssigns) {\n-        Type result;\n+    private static Type unrollVariableAssignments(TypeVariable<?> obj, final Map<TypeVariable<?>, Type> map) {\n+        Type type;\n         while (true) {\n-            result = typeVarAssigns.get(var);\n-            if (!(result instanceof TypeVariable) || result.equals(var)) {\n+            type = map.get(obj);\n+            if (!(type instanceof TypeVariable) || type.equals(obj)) {\n                 break;\n             }\n-            var = (TypeVariable)result;\n+            obj = (TypeVariable<?>)type;\n         }\n-        return result;\n+        return type;\n     }\n     \n-    private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns) {\n+    private static boolean isAssignable(final Type type, final GenericArrayType genericArrayType, final Map<TypeVariable<?>, Type> map) {\n         if (type == null) {\n             return true;\n         }\n-        if (toGenericArrayType == null) {\n+        if (genericArrayType == null) {\n             return false;\n         }\n-        if (toGenericArrayType.equals(type)) {\n+        if (genericArrayType.equals(type)) {\n             return true;\n         }\n-        final Type toComponentType = toGenericArrayType.getGenericComponentType();\n+        final Type genericComponentType = genericArrayType.getGenericComponentType();\n         if (type instanceof Class) {\n-            final Class<?> cls = (Class)type;\n-            return cls.isArray() && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns);\n+            final Class clazz = (Class)type;\n+            return clazz.isArray() && isAssignable(clazz.getComponentType(), genericComponentType, map);\n         }\n         if (type instanceof GenericArrayType) {\n-            return isAssignable(((GenericArrayType)type).getGenericComponentType(), toComponentType, typeVarAssigns);\n+            return isAssignable(((GenericArrayType)type).getGenericComponentType(), genericComponentType, map);\n         }\n         if (type instanceof WildcardType) {\n-            for (final Type bound : getImplicitUpperBounds((WildcardType)type)) {\n-                if (isAssignable(bound, toGenericArrayType)) {\n+            final Type[] implicitUpperBounds = getImplicitUpperBounds((WildcardType)type);\n+            for (int length = implicitUpperBounds.length, i = 0; i < length; ++i) {\n+                if (isAssignable(implicitUpperBounds[i], genericArrayType)) {\n                     return true;\n                 }\n             }\n             return false;\n         }\n         if (type instanceof TypeVariable) {\n-            for (final Type bound : getImplicitBounds((TypeVariable<?>)type)) {\n-                if (isAssignable(bound, toGenericArrayType)) {\n+            final Type[] implicitBounds = getImplicitBounds((TypeVariable<?>)type);\n+            for (int length2 = implicitBounds.length, j = 0; j < length2; ++j) {\n+                if (isAssignable(implicitBounds[j], genericArrayType)) {\n                     return true;\n                 }\n             }\n             return false;\n         }\n         if (type instanceof ParameterizedType) {\n             return false;\n         }\n         throw new IllegalStateException(\"found an unhandled type: \" + type);\n     }\n     \n-    private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) {\n-        if (type == null) {\n+    private static boolean isAssignable(final Type obj, final WildcardType wildcardType, final Map<TypeVariable<?>, Type> map) {\n+        if (obj == null) {\n             return true;\n         }\n-        if (toWildcardType == null) {\n+        if (wildcardType == null) {\n             return false;\n         }\n-        if (toWildcardType.equals(type)) {\n+        if (wildcardType.equals(obj)) {\n             return true;\n         }\n-        final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType);\n-        final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType);\n-        if (type instanceof WildcardType) {\n-            final WildcardType wildcardType = (WildcardType)type;\n-            final Type[] upperBounds = getImplicitUpperBounds(wildcardType);\n-            final Type[] lowerBounds = getImplicitLowerBounds(wildcardType);\n-            for (Type toBound : toUpperBounds) {\n-                toBound = substituteTypeVariables(toBound, typeVarAssigns);\n-                for (final Type bound : upperBounds) {\n-                    if (!isAssignable(bound, toBound, typeVarAssigns)) {\n+        final Type[] implicitUpperBounds = getImplicitUpperBounds(wildcardType);\n+        final Type[] implicitLowerBounds = getImplicitLowerBounds(wildcardType);\n+        if (obj instanceof WildcardType) {\n+            final WildcardType wildcardType2 = (WildcardType)obj;\n+            final Type[] implicitUpperBounds2 = getImplicitUpperBounds(wildcardType2);\n+            final Type[] implicitLowerBounds2 = getImplicitLowerBounds(wildcardType2);\n+            final Type[] array = implicitUpperBounds;\n+            for (int length = array.length, i = 0; i < length; ++i) {\n+                final Type substituteTypeVariables = substituteTypeVariables(array[i], map);\n+                final Type[] array2 = implicitUpperBounds2;\n+                for (int length2 = array2.length, j = 0; j < length2; ++j) {\n+                    if (!isAssignable(array2[j], substituteTypeVariables, map)) {\n                         return false;\n                     }\n                 }\n             }\n-            for (Type toBound : toLowerBounds) {\n-                toBound = substituteTypeVariables(toBound, typeVarAssigns);\n-                for (final Type bound : lowerBounds) {\n-                    if (!isAssignable(toBound, bound, typeVarAssigns)) {\n+            final Type[] array3 = implicitLowerBounds;\n+            for (int length3 = array3.length, k = 0; k < length3; ++k) {\n+                final Type substituteTypeVariables2 = substituteTypeVariables(array3[k], map);\n+                final Type[] array4 = implicitLowerBounds2;\n+                for (int length4 = array4.length, l = 0; l < length4; ++l) {\n+                    if (!isAssignable(substituteTypeVariables2, array4[l], map)) {\n                         return false;\n                     }\n                 }\n             }\n             return true;\n         }\n-        for (final Type toBound2 : toUpperBounds) {\n-            if (!isAssignable(type, substituteTypeVariables(toBound2, typeVarAssigns), typeVarAssigns)) {\n+        final Type[] array5 = implicitUpperBounds;\n+        for (int length5 = array5.length, n = 0; n < length5; ++n) {\n+            if (!isAssignable(obj, substituteTypeVariables(array5[n], map), map)) {\n                 return false;\n             }\n         }\n-        for (final Type toBound2 : toLowerBounds) {\n-            if (!isAssignable(substituteTypeVariables(toBound2, typeVarAssigns), type, typeVarAssigns)) {\n+        final Type[] array6 = implicitLowerBounds;\n+        for (int length6 = array6.length, n2 = 0; n2 < length6; ++n2) {\n+            if (!isAssignable(substituteTypeVariables(array6[n2], map), obj, map)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    private static boolean isAssignable(final Type type, final TypeVariable<?> toTypeVariable, final Map<TypeVariable<?>, Type> typeVarAssigns) {\n+    private static boolean isAssignable(final Type type, final TypeVariable<?> typeVariable, final Map<TypeVariable<?>, Type> map) {\n         if (type == null) {\n             return true;\n         }\n-        if (toTypeVariable == null) {\n+        if (typeVariable == null) {\n             return false;\n         }\n-        if (toTypeVariable.equals(type)) {\n+        if (typeVariable.equals(type)) {\n             return true;\n         }\n         if (type instanceof TypeVariable) {\n-            final Type[] implicitBounds;\n-            final Type[] bounds = implicitBounds = getImplicitBounds((TypeVariable<?>)type);\n-            for (final Type bound : implicitBounds) {\n-                if (isAssignable(bound, toTypeVariable, typeVarAssigns)) {\n+            final Type[] implicitBounds = getImplicitBounds((TypeVariable<?>)type);\n+            for (int length = implicitBounds.length, i = 0; i < length; ++i) {\n+                if (isAssignable(implicitBounds[i], typeVariable, map)) {\n                     return true;\n                 }\n             }\n         }\n         if (type instanceof Class || type instanceof ParameterizedType || type instanceof GenericArrayType || type instanceof WildcardType) {\n             return false;\n         }\n         throw new IllegalStateException(\"found an unhandled type: \" + type);\n     }\n     \n-    private static Type substituteTypeVariables(final Type type, final Map<TypeVariable<?>, Type> typeVarAssigns) {\n-        if (!(type instanceof TypeVariable) || typeVarAssigns == null) {\n-            return type;\n+    private static Type substituteTypeVariables(final Type obj, final Map<TypeVariable<?>, Type> map) {\n+        if (!(obj instanceof TypeVariable) || map == null) {\n+            return obj;\n         }\n-        final Type replacementType = (Type)typeVarAssigns.get(type);\n-        if (replacementType == null) {\n-            throw new IllegalArgumentException(\"missing assignment type for type variable \" + type);\n+        final Type type = (Type)map.get(obj);\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"missing assignment type for type variable \" + obj);\n         }\n-        return replacementType;\n+        return type;\n     }\n     \n-    public static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType type) {\n-        return getTypeArguments(type, getRawType(type), null);\n+    public static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType parameterizedType) {\n+        return getTypeArguments(parameterizedType, getRawType(parameterizedType), null);\n     }\n     \n-    public static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass) {\n-        return getTypeArguments(type, toClass, null);\n+    public static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> clazz) {\n+        return getTypeArguments(type, clazz, null);\n     }\n     \n-    private static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) {\n-        if (type instanceof Class) {\n-            return getTypeArguments((Class<?>)type, toClass, subtypeVarAssigns);\n+    private static Map<TypeVariable<?>, Type> getTypeArguments(final Type obj, final Class<?> clazz, final Map<TypeVariable<?>, Type> map) {\n+        if (obj instanceof Class) {\n+            return getTypeArguments((Class<?>)obj, clazz, map);\n         }\n-        if (type instanceof ParameterizedType) {\n-            return getTypeArguments((ParameterizedType)type, toClass, subtypeVarAssigns);\n+        if (obj instanceof ParameterizedType) {\n+            return getTypeArguments((ParameterizedType)obj, clazz, map);\n         }\n-        if (type instanceof GenericArrayType) {\n-            return getTypeArguments(((GenericArrayType)type).getGenericComponentType(), toClass.isArray() ? toClass.getComponentType() : toClass, subtypeVarAssigns);\n+        if (obj instanceof GenericArrayType) {\n+            return getTypeArguments(((GenericArrayType)obj).getGenericComponentType(), clazz.isArray() ? clazz.getComponentType() : clazz, map);\n         }\n-        if (type instanceof WildcardType) {\n-            for (final Type bound : getImplicitUpperBounds((WildcardType)type)) {\n-                if (isAssignable(bound, toClass)) {\n-                    return getTypeArguments(bound, toClass, subtypeVarAssigns);\n+        if (obj instanceof WildcardType) {\n+            for (final Type type : getImplicitUpperBounds((WildcardType)obj)) {\n+                if (isAssignable(type, clazz)) {\n+                    return getTypeArguments(type, clazz, map);\n                 }\n             }\n             return null;\n         }\n-        if (type instanceof TypeVariable) {\n-            for (final Type bound : getImplicitBounds((TypeVariable<?>)type)) {\n-                if (isAssignable(bound, toClass)) {\n-                    return getTypeArguments(bound, toClass, subtypeVarAssigns);\n+        if (obj instanceof TypeVariable) {\n+            for (final Type type2 : getImplicitBounds((TypeVariable<?>)obj)) {\n+                if (isAssignable(type2, clazz)) {\n+                    return getTypeArguments(type2, clazz, map);\n                 }\n             }\n             return null;\n         }\n-        throw new IllegalStateException(\"found an unhandled type: \" + type);\n+        throw new IllegalStateException(\"found an unhandled type: \" + obj);\n     }\n     \n-    private static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType parameterizedType, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) {\n-        final Class<?> cls = getRawType(parameterizedType);\n-        if (!isAssignable(cls, toClass)) {\n+    private static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType parameterizedType, final Class<?> clazz, final Map<TypeVariable<?>, Type> m) {\n+        final Class<?> rawType = getRawType(parameterizedType);\n+        if (!isAssignable(rawType, clazz)) {\n             return null;\n         }\n         final Type ownerType = parameterizedType.getOwnerType();\n-        Map<TypeVariable<?>, Type> typeVarAssigns;\n+        Map<TypeVariable<?>, Type> typeArguments;\n         if (ownerType instanceof ParameterizedType) {\n-            final ParameterizedType parameterizedOwnerType = (ParameterizedType)ownerType;\n-            typeVarAssigns = getTypeArguments(parameterizedOwnerType, getRawType(parameterizedOwnerType), subtypeVarAssigns);\n+            final ParameterizedType parameterizedType2 = (ParameterizedType)ownerType;\n+            typeArguments = getTypeArguments(parameterizedType2, getRawType(parameterizedType2), m);\n         }\n         else {\n-            typeVarAssigns = ((subtypeVarAssigns == null) ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns));\n+            typeArguments = ((m == null) ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(m));\n         }\n-        final Type[] typeArgs = parameterizedType.getActualTypeArguments();\n-        final TypeVariable<?>[] typeParams = cls.getTypeParameters();\n-        for (int i = 0; i < typeParams.length; ++i) {\n-            final Type typeArg = typeArgs[i];\n-            typeVarAssigns.put(typeParams[i], typeVarAssigns.containsKey(typeArg) ? ((Type)typeVarAssigns.get(typeArg)) : typeArg);\n+        final Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n+        final TypeVariable<Class<?>>[] typeParameters = rawType.getTypeParameters();\n+        for (int i = 0; i < typeParameters.length; ++i) {\n+            final Type type = actualTypeArguments[i];\n+            typeArguments.put(typeParameters[i], typeArguments.containsKey(type) ? ((Type)typeArguments.get(type)) : type);\n         }\n-        if (toClass.equals(cls)) {\n-            return typeVarAssigns;\n+        if (clazz.equals(rawType)) {\n+            return typeArguments;\n         }\n-        return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);\n+        return getTypeArguments(getClosestParentType(rawType, clazz), clazz, typeArguments);\n     }\n     \n-    private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) {\n-        if (!isAssignable(cls, toClass)) {\n+    private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> primitiveToWrapper, final Class<?> clazz, final Map<TypeVariable<?>, Type> m) {\n+        if (!isAssignable(primitiveToWrapper, clazz)) {\n             return null;\n         }\n-        if (cls.isPrimitive()) {\n-            if (toClass.isPrimitive()) {\n+        if (primitiveToWrapper.isPrimitive()) {\n+            if (clazz.isPrimitive()) {\n                 return new HashMap<TypeVariable<?>, Type>();\n             }\n-            cls = ClassUtils.primitiveToWrapper((Class)cls);\n+            primitiveToWrapper = ClassUtils.primitiveToWrapper(primitiveToWrapper);\n         }\n-        final HashMap<TypeVariable<?>, Type> typeVarAssigns = (subtypeVarAssigns == null) ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n-        if (toClass.equals(cls)) {\n-            return typeVarAssigns;\n+        final HashMap<TypeVariable<?>, Type> hashMap = (m == null) ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(m);\n+        if (clazz.equals(primitiveToWrapper)) {\n+            return hashMap;\n         }\n-        return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);\n+        return getTypeArguments(getClosestParentType(primitiveToWrapper, clazz), clazz, hashMap);\n     }\n     \n-    public static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType) {\n-        Validate.notNull((Object)cls, \"cls is null\", new Object[0]);\n-        Validate.notNull((Object)superType, \"superType is null\", new Object[0]);\n-        final Class<?> superClass = getRawType(superType);\n-        if (!isAssignable(cls, superClass)) {\n+    public static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> clazz, final ParameterizedType parameterizedType) {\n+        Validate.notNull((Object)clazz, \"cls is null\", new Object[0]);\n+        Validate.notNull((Object)parameterizedType, \"superType is null\", new Object[0]);\n+        final Class<?> rawType = getRawType(parameterizedType);\n+        if (!isAssignable(clazz, rawType)) {\n             return null;\n         }\n-        if (cls.equals(superClass)) {\n-            return getTypeArguments(superType, superClass, null);\n+        if (clazz.equals(rawType)) {\n+            return getTypeArguments(parameterizedType, rawType, null);\n         }\n-        final Type midType = getClosestParentType(cls, superClass);\n-        if (midType instanceof Class) {\n-            return determineTypeArguments((Class<?>)midType, superType);\n+        final Type closestParentType = getClosestParentType(clazz, rawType);\n+        if (closestParentType instanceof Class) {\n+            return determineTypeArguments((Class<?>)closestParentType, parameterizedType);\n         }\n-        final ParameterizedType midParameterizedType = (ParameterizedType)midType;\n-        final Class<?> midClass = getRawType(midParameterizedType);\n-        final Map<TypeVariable<?>, Type> typeVarAssigns = determineTypeArguments(midClass, superType);\n-        mapTypeVariablesToArguments(cls, midParameterizedType, typeVarAssigns);\n-        return typeVarAssigns;\n+        final ParameterizedType parameterizedType2 = (ParameterizedType)closestParentType;\n+        final Map<TypeVariable<?>, Type> determineTypeArguments = determineTypeArguments(getRawType(parameterizedType2), parameterizedType);\n+        mapTypeVariablesToArguments(clazz, parameterizedType2, determineTypeArguments);\n+        return determineTypeArguments;\n     }\n     \n-    private static <T> void mapTypeVariablesToArguments(final Class<T> cls, final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) {\n+    private static <T> void mapTypeVariablesToArguments(final Class<T> clazz, final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> map) {\n         final Type ownerType = parameterizedType.getOwnerType();\n         if (ownerType instanceof ParameterizedType) {\n-            mapTypeVariablesToArguments((Class<Object>)cls, (ParameterizedType)ownerType, typeVarAssigns);\n+            mapTypeVariablesToArguments((Class<Object>)clazz, (ParameterizedType)ownerType, map);\n         }\n-        final Type[] typeArgs = parameterizedType.getActualTypeArguments();\n-        final TypeVariable<?>[] typeVars = getRawType(parameterizedType).getTypeParameters();\n-        final List<TypeVariable<Class<T>>> typeVarList = Arrays.asList(cls.getTypeParameters());\n-        for (int i = 0; i < typeArgs.length; ++i) {\n-            final TypeVariable<?> typeVar = typeVars[i];\n-            final Type typeArg = typeArgs[i];\n-            if (typeVarList.contains(typeArg) && typeVarAssigns.containsKey(typeVar)) {\n-                typeVarAssigns.put((TypeVariable)typeArg, typeVarAssigns.get((Object)typeVar));\n+        final Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n+        final TypeVariable<Class<?>>[] typeParameters = getRawType(parameterizedType).getTypeParameters();\n+        final List<TypeVariable<Class<Object>>> list = Arrays.asList((TypeVariable<Class<Object>>[])clazz.getTypeParameters());\n+        for (int i = 0; i < actualTypeArguments.length; ++i) {\n+            final TypeVariable<Class<?>> typeVariable = typeParameters[i];\n+            final Type type = actualTypeArguments[i];\n+            if (list.contains(type) && map.containsKey(typeVariable)) {\n+                map.put((TypeVariable<?>)type, map.get((Object)typeVariable));\n             }\n         }\n     }\n     \n-    private static Type getClosestParentType(final Class<?> cls, final Class<?> superClass) {\n-        if (superClass.isInterface()) {\n-            final Type[] interfaceTypes = cls.getGenericInterfaces();\n-            Type genericInterface = null;\n-            for (final Type midType : interfaceTypes) {\n-                Class<?> midClass = null;\n-                if (midType instanceof ParameterizedType) {\n-                    midClass = getRawType((ParameterizedType)midType);\n+    private static Type getClosestParentType(final Class<?> clazz, final Class<?> clazz2) {\n+        if (clazz2.isInterface()) {\n+            final Type[] genericInterfaces = clazz.getGenericInterfaces();\n+            Type type = null;\n+            for (final Type obj : genericInterfaces) {\n+                Class<?> rawType;\n+                if (obj instanceof ParameterizedType) {\n+                    rawType = getRawType((ParameterizedType)obj);\n                 }\n                 else {\n-                    if (!(midType instanceof Class)) {\n-                        throw new IllegalStateException(\"Unexpected generic interface type found: \" + midType);\n+                    if (!(obj instanceof Class)) {\n+                        throw new IllegalStateException(\"Unexpected generic interface type found: \" + obj);\n                     }\n-                    midClass = (Class)midType;\n+                    rawType = (Class<?>)obj;\n                 }\n-                if (isAssignable(midClass, superClass) && isAssignable(genericInterface, (Type)midClass)) {\n-                    genericInterface = midType;\n+                if (isAssignable(rawType, clazz2) && isAssignable(type, (Type)rawType)) {\n+                    type = obj;\n                 }\n             }\n-            if (genericInterface != null) {\n-                return genericInterface;\n+            if (type != null) {\n+                return type;\n             }\n         }\n-        return cls.getGenericSuperclass();\n+        return clazz.getGenericSuperclass();\n     }\n     \n-    public static boolean isInstance(final Object value, final Type type) {\n-        return type != null && ((value == null) ? (!(type instanceof Class) || !((Class)type).isPrimitive()) : isAssignable(value.getClass(), type, null));\n+    public static boolean isInstance(final Object o, final Type type) {\n+        return type != null && ((o == null) ? (!(type instanceof Class) || !((Class)type).isPrimitive()) : isAssignable(o.getClass(), type, null));\n     }\n     \n-    public static Type[] normalizeUpperBounds(final Type[] bounds) {\n-        Validate.notNull((Object)bounds, \"null value specified for bounds array\", new Object[0]);\n-        if (bounds.length < 2) {\n-            return bounds;\n+    public static Type[] normalizeUpperBounds(final Type[] array) {\n+        Validate.notNull((Object)array, \"null value specified for bounds array\", new Object[0]);\n+        if (array.length < 2) {\n+            return array;\n         }\n-        final Set<Type> types = new HashSet<Type>(bounds.length);\n-        for (final Type type1 : bounds) {\n-            boolean subtypeFound = false;\n-            for (final Type type2 : bounds) {\n-                if (type1 != type2 && isAssignable(type2, type1, null)) {\n-                    subtypeFound = true;\n+        final HashSet set = new HashSet(array.length);\n+        for (final Type type : array) {\n+            boolean b = false;\n+            for (final Type type2 : array) {\n+                if (type != type2 && isAssignable(type2, type, null)) {\n+                    b = true;\n                     break;\n                 }\n             }\n-            if (!subtypeFound) {\n-                types.add(type1);\n+            if (!b) {\n+                set.add(type);\n             }\n         }\n-        return types.toArray(new Type[types.size()]);\n+        return (Type[])set.toArray(new Type[set.size()]);\n     }\n     \n     public static Type[] getImplicitBounds(final TypeVariable<?> typeVariable) {\n         Validate.notNull((Object)typeVariable, \"typeVariable is null\", new Object[0]);\n         final Type[] bounds = typeVariable.getBounds();\n         return (bounds.length == 0) ? new Type[] { Object.class } : normalizeUpperBounds(bounds);\n     }\n     \n     public static Type[] getImplicitUpperBounds(final WildcardType wildcardType) {\n         Validate.notNull((Object)wildcardType, \"wildcardType is null\", new Object[0]);\n-        final Type[] bounds = wildcardType.getUpperBounds();\n-        return (bounds.length == 0) ? new Type[] { Object.class } : normalizeUpperBounds(bounds);\n+        final Type[] upperBounds = wildcardType.getUpperBounds();\n+        return (upperBounds.length == 0) ? new Type[] { Object.class } : normalizeUpperBounds(upperBounds);\n     }\n     \n     public static Type[] getImplicitLowerBounds(final WildcardType wildcardType) {\n         Validate.notNull((Object)wildcardType, \"wildcardType is null\", new Object[0]);\n-        final Type[] bounds = wildcardType.getLowerBounds();\n-        return (bounds.length == 0) ? new Type[] { null } : bounds;\n+        final Type[] lowerBounds = wildcardType.getLowerBounds();\n+        return (lowerBounds.length == 0) ? new Type[] { null } : lowerBounds;\n     }\n     \n-    public static boolean typesSatisfyVariables(final Map<TypeVariable<?>, Type> typeVarAssigns) {\n-        Validate.notNull((Object)typeVarAssigns, \"typeVarAssigns is null\", new Object[0]);\n-        for (final Map.Entry<TypeVariable<?>, Type> entry : typeVarAssigns.entrySet()) {\n-            final TypeVariable<?> typeVar = (TypeVariable<?>)entry.getKey();\n+    public static boolean typesSatisfyVariables(final Map<TypeVariable<?>, Type> map) {\n+        Validate.notNull((Object)map, \"typeVarAssigns is null\", new Object[0]);\n+        for (final Map.Entry entry : map.entrySet()) {\n+            final TypeVariable typeVariable = (TypeVariable)entry.getKey();\n             final Type type = (Type)entry.getValue();\n-            for (final Type bound : getImplicitBounds(typeVar)) {\n-                if (!isAssignable(type, substituteTypeVariables(bound, typeVarAssigns), typeVarAssigns)) {\n+            final Type[] implicitBounds = getImplicitBounds(typeVariable);\n+            for (int length = implicitBounds.length, i = 0; i < length; ++i) {\n+                if (!isAssignable(type, substituteTypeVariables(implicitBounds[i], map), map)) {\n                     return false;\n                 }\n             }\n         }\n         return true;\n     }\n     \n     private static Class<?> getRawType(final ParameterizedType parameterizedType) {\n         final Type rawType = parameterizedType.getRawType();\n         if (!(rawType instanceof Class)) {\n             throw new IllegalStateException(\"Wait... What!? Type of rawType: \" + rawType);\n         }\n-        return (Class)rawType;\n+        return (Class<?>)rawType;\n     }\n     \n-    public static Class<?> getRawType(final Type type, final Type assigningType) {\n-        if (type instanceof Class) {\n-            return (Class)type;\n+    public static Class<?> getRawType(final Type obj, final Type type) {\n+        if (obj instanceof Class) {\n+            return (Class)obj;\n         }\n-        if (type instanceof ParameterizedType) {\n-            return getRawType((ParameterizedType)type);\n+        if (obj instanceof ParameterizedType) {\n+            return getRawType((ParameterizedType)obj);\n         }\n-        if (type instanceof TypeVariable) {\n-            if (assigningType == null) {\n+        if (obj instanceof TypeVariable) {\n+            if (type == null) {\n                 return null;\n             }\n-            final Object genericDeclaration = ((TypeVariable)type).getGenericDeclaration();\n+            final Class<?> genericDeclaration = ((TypeVariable)obj).getGenericDeclaration();\n             if (!(genericDeclaration instanceof Class)) {\n                 return null;\n             }\n-            final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>)genericDeclaration);\n-            if (typeVarAssigns == null) {\n+            final Map<TypeVariable<?>, Type> typeArguments = getTypeArguments(type, genericDeclaration);\n+            if (typeArguments == null) {\n                 return null;\n             }\n-            final Type typeArgument = (Type)typeVarAssigns.get(type);\n-            if (typeArgument == null) {\n+            final Type type2 = (Type)typeArguments.get(obj);\n+            if (type2 == null) {\n                 return null;\n             }\n-            return getRawType(typeArgument, assigningType);\n+            return getRawType(type2, type);\n         }\n         else {\n-            if (type instanceof GenericArrayType) {\n-                final Class<?> rawComponentType = getRawType(((GenericArrayType)type).getGenericComponentType(), assigningType);\n-                return Array.newInstance(rawComponentType, 0).getClass();\n+            if (obj instanceof GenericArrayType) {\n+                return Array.newInstance(getRawType(((GenericArrayType)obj).getGenericComponentType(), type), 0).getClass();\n             }\n-            if (type instanceof WildcardType) {\n+            if (obj instanceof WildcardType) {\n                 return null;\n             }\n-            throw new IllegalArgumentException(\"unknown type: \" + type);\n+            throw new IllegalArgumentException(\"unknown type: \" + obj);\n         }\n     }\n     \n     public static boolean isArrayType(final Type type) {\n         return type instanceof GenericArrayType || (type instanceof Class && ((Class)type).isArray());\n     }\n     \n     public static Type getArrayComponentType(final Type type) {\n         if (type instanceof Class) {\n-            final Class<?> clazz = (Class)type;\n+            final Class clazz = (Class)type;\n             return clazz.isArray() ? clazz.getComponentType() : null;\n         }\n         if (type instanceof GenericArrayType) {\n             return ((GenericArrayType)type).getGenericComponentType();\n         }\n         return null;\n     }\n     \n-    public static Type unrollVariables(Map<TypeVariable<?>, Type> typeArguments, final Type type) {\n-        if (typeArguments == null) {\n-            typeArguments = Collections.emptyMap();\n+    public static Type unrollVariables(Map<TypeVariable<?>, Type> emptyMap, final Type type) {\n+        if (emptyMap == null) {\n+            emptyMap = Collections.emptyMap();\n         }\n         if (containsTypeVariables(type)) {\n             if (type instanceof TypeVariable) {\n-                return unrollVariables(typeArguments, typeArguments.get(type));\n+                return unrollVariables(emptyMap, emptyMap.get(type));\n             }\n             if (type instanceof ParameterizedType) {\n-                final ParameterizedType p = (ParameterizedType)type;\n-                Map<TypeVariable<?>, Type> parameterizedTypeArguments;\n-                if (p.getOwnerType() == null) {\n-                    parameterizedTypeArguments = typeArguments;\n+                final ParameterizedType parameterizedType = (ParameterizedType)type;\n+                Map<TypeVariable<?>, Type> map;\n+                if (parameterizedType.getOwnerType() == null) {\n+                    map = emptyMap;\n                 }\n                 else {\n-                    parameterizedTypeArguments = new HashMap<TypeVariable<?>, Type>(typeArguments);\n-                    parameterizedTypeArguments.putAll(getTypeArguments(p));\n+                    map = new HashMap<TypeVariable<?>, Type>(emptyMap);\n+                    map.putAll(getTypeArguments(parameterizedType));\n                 }\n-                final Type[] args = p.getActualTypeArguments();\n-                for (int i = 0; i < args.length; ++i) {\n-                    final Type unrolled = unrollVariables(parameterizedTypeArguments, args[i]);\n-                    if (unrolled != null) {\n-                        args[i] = unrolled;\n+                final Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n+                for (int i = 0; i < actualTypeArguments.length; ++i) {\n+                    final Type unrollVariables = unrollVariables(map, actualTypeArguments[i]);\n+                    if (unrollVariables != null) {\n+                        actualTypeArguments[i] = unrollVariables;\n                     }\n                 }\n-                return parameterizeWithOwner(p.getOwnerType(), (Class<?>)p.getRawType(), args);\n+                return parameterizeWithOwner(parameterizedType.getOwnerType(), (Class<?>)parameterizedType.getRawType(), actualTypeArguments);\n             }\n             if (type instanceof WildcardType) {\n-                final WildcardType wild = (WildcardType)type;\n-                return wildcardType().withUpperBounds(unrollBounds(typeArguments, wild.getUpperBounds())).withLowerBounds(unrollBounds(typeArguments, wild.getLowerBounds())).build();\n+                final WildcardType wildcardType = (WildcardType)type;\n+                return wildcardType().withUpperBounds(unrollBounds(emptyMap, wildcardType.getUpperBounds())).withLowerBounds(unrollBounds(emptyMap, wildcardType.getLowerBounds())).build();\n             }\n         }\n         return type;\n     }\n     \n-    private static Type[] unrollBounds(final Map<TypeVariable<?>, Type> typeArguments, final Type[] bounds) {\n-        Type[] result = bounds;\n-        for (int i = 0; i < result.length; ++i) {\n-            final Type unrolled = unrollVariables(typeArguments, result[i]);\n-            if (unrolled == null) {\n-                result = (Type[])ArrayUtils.remove((Object[])result, i--);\n+    private static Type[] unrollBounds(final Map<TypeVariable<?>, Type> map, final Type[] array) {\n+        Type[] array2 = array;\n+        for (int i = 0; i < array2.length; ++i) {\n+            final Type unrollVariables = unrollVariables(map, array2[i]);\n+            if (unrollVariables == null) {\n+                array2 = (Type[])ArrayUtils.remove((Object[])array2, i--);\n             }\n             else {\n-                result[i] = unrolled;\n+                array2[i] = unrollVariables;\n             }\n         }\n-        return result;\n+        return array2;\n     }\n     \n     public static boolean containsTypeVariables(final Type type) {\n         if (type instanceof TypeVariable) {\n             return true;\n         }\n         if (type instanceof Class) {\n             return ((Class)type).getTypeParameters().length > 0;\n         }\n         if (type instanceof ParameterizedType) {\n-            for (final Type arg : ((ParameterizedType)type).getActualTypeArguments()) {\n-                if (containsTypeVariables(arg)) {\n+            final Type[] actualTypeArguments = ((ParameterizedType)type).getActualTypeArguments();\n+            for (int length = actualTypeArguments.length, i = 0; i < length; ++i) {\n+                if (containsTypeVariables(actualTypeArguments[i])) {\n                     return true;\n                 }\n             }\n             return false;\n         }\n         if (type instanceof WildcardType) {\n-            final WildcardType wild = (WildcardType)type;\n-            return containsTypeVariables(getImplicitLowerBounds(wild)[0]) || containsTypeVariables(getImplicitUpperBounds(wild)[0]);\n+            final WildcardType wildcardType = (WildcardType)type;\n+            return containsTypeVariables(getImplicitLowerBounds(wildcardType)[0]) || containsTypeVariables(getImplicitUpperBounds(wildcardType)[0]);\n         }\n         return false;\n     }\n     \n-    public static final ParameterizedType parameterize(final Class<?> raw, final Type... typeArguments) {\n-        return parameterizeWithOwner(null, raw, typeArguments);\n+    public static final ParameterizedType parameterize(final Class<?> clazz, final Type... array) {\n+        return parameterizeWithOwner(null, clazz, array);\n     }\n     \n-    public static final ParameterizedType parameterize(final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings) {\n-        Validate.notNull((Object)raw, \"raw class is null\", new Object[0]);\n-        Validate.notNull((Object)typeArgMappings, \"typeArgMappings is null\", new Object[0]);\n-        return parameterizeWithOwner(null, raw, extractTypeArgumentsFrom(typeArgMappings, (TypeVariable<?>[])raw.getTypeParameters()));\n+    public static final ParameterizedType parameterize(final Class<?> clazz, final Map<TypeVariable<?>, Type> map) {\n+        Validate.notNull((Object)clazz, \"raw class is null\", new Object[0]);\n+        Validate.notNull((Object)map, \"typeArgMappings is null\", new Object[0]);\n+        return parameterizeWithOwner(null, clazz, extractTypeArgumentsFrom(map, (TypeVariable<?>[])clazz.getTypeParameters()));\n     }\n     \n-    public static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Type... typeArguments) {\n-        Validate.notNull((Object)raw, \"raw class is null\", new Object[0]);\n-        Type useOwner;\n-        if (raw.getEnclosingClass() == null) {\n-            Validate.isTrue(owner == null, \"no owner allowed for top-level %s\", new Object[] { raw });\n-            useOwner = null;\n+    public static final ParameterizedType parameterizeWithOwner(final Type type, final Class<?> clazz, final Type... array) {\n+        Validate.notNull((Object)clazz, \"raw class is null\", new Object[0]);\n+        Type enclosingClass;\n+        if (clazz.getEnclosingClass() == null) {\n+            Validate.isTrue(type == null, \"no owner allowed for top-level %s\", new Object[] { clazz });\n+            enclosingClass = null;\n         }\n-        else if (owner == null) {\n-            useOwner = raw.getEnclosingClass();\n+        else if (type == null) {\n+            enclosingClass = clazz.getEnclosingClass();\n         }\n         else {\n-            Validate.isTrue(isAssignable(owner, raw.getEnclosingClass()), \"%s is invalid owner type for parameterized %s\", new Object[] { owner, raw });\n-            useOwner = owner;\n+            Validate.isTrue(isAssignable(type, (Class<?>)clazz.getEnclosingClass()), \"%s is invalid owner type for parameterized %s\", new Object[] { type, clazz });\n+            enclosingClass = type;\n         }\n-        Validate.noNullElements((Object[])typeArguments, \"null type argument at index %s\", new Object[0]);\n-        Validate.isTrue(raw.getTypeParameters().length == typeArguments.length, \"invalid number of type parameters specified: expected %d, got %d\", new Object[] { Integer.valueOf(raw.getTypeParameters().length), Integer.valueOf(typeArguments.length) });\n-        return (ParameterizedType)new TypeUtils.ParameterizedTypeImpl((Class)raw, useOwner, typeArguments, (TypeUtils.TypeUtils$1)null);\n+        Validate.noNullElements((Object[])array, \"null type argument at index %s\", new Object[0]);\n+        Validate.isTrue(clazz.getTypeParameters().length == array.length, \"invalid number of type parameters specified: expected %d, got %d\", new Object[] { Integer.valueOf(clazz.getTypeParameters().length), Integer.valueOf(array.length) });\n+        return (ParameterizedType)new TypeUtils.ParameterizedTypeImpl((Class)clazz, enclosingClass, array, (TypeUtils.TypeUtils$1)null);\n     }\n     \n-    public static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings) {\n-        Validate.notNull((Object)raw, \"raw class is null\", new Object[0]);\n-        Validate.notNull((Object)typeArgMappings, \"typeArgMappings is null\", new Object[0]);\n-        return parameterizeWithOwner(owner, raw, extractTypeArgumentsFrom(typeArgMappings, (TypeVariable<?>[])raw.getTypeParameters()));\n+    public static final ParameterizedType parameterizeWithOwner(final Type type, final Class<?> clazz, final Map<TypeVariable<?>, Type> map) {\n+        Validate.notNull((Object)clazz, \"raw class is null\", new Object[0]);\n+        Validate.notNull((Object)map, \"typeArgMappings is null\", new Object[0]);\n+        return parameterizeWithOwner(type, clazz, extractTypeArgumentsFrom(map, (TypeVariable<?>[])clazz.getTypeParameters()));\n     }\n     \n-    private static Type[] extractTypeArgumentsFrom(final Map<TypeVariable<?>, Type> mappings, final TypeVariable<?>[] variables) {\n-        final Type[] result = new Type[variables.length];\n-        int index = 0;\n-        for (final TypeVariable<?> var : variables) {\n-            Validate.isTrue(mappings.containsKey((Object)var), \"missing argument mapping for %s\", new Object[] { toString((Type)var) });\n-            result[index++] = mappings.get(var);\n+    private static Type[] extractTypeArgumentsFrom(final Map<TypeVariable<?>, Type> map, final TypeVariable<?>[] array) {\n+        final Type[] array2 = new Type[array.length];\n+        int n = 0;\n+        for (final TypeVariable<?> typeVariable : array) {\n+            Validate.isTrue(map.containsKey((Object)typeVariable), \"missing argument mapping for %s\", new Object[] { toString((Type)typeVariable) });\n+            array2[n++] = map.get(typeVariable);\n         }\n-        return result;\n+        return array2;\n     }\n     \n     public static TypeUtils.WildcardTypeBuilder wildcardType() {\n         return new TypeUtils.WildcardTypeBuilder((TypeUtils.TypeUtils$1)null);\n     }\n     \n-    public static GenericArrayType genericArrayType(final Type componentType) {\n-        return (GenericArrayType)new TypeUtils.GenericArrayTypeImpl((Type)Validate.notNull((Object)componentType, \"componentType is null\", new Object[0]), (TypeUtils.TypeUtils$1)null);\n+    public static GenericArrayType genericArrayType(final Type type) {\n+        return (GenericArrayType)new TypeUtils.GenericArrayTypeImpl((Type)Validate.notNull((Object)type, \"componentType is null\", new Object[0]), (TypeUtils.TypeUtils$1)null);\n     }\n     \n-    public static boolean equals(final Type t1, final Type t2) {\n-        if (Objects.equals(t1, t2)) {\n+    public static boolean equals(final Type a, final Type b) {\n+        if (Objects.equals(a, b)) {\n             return true;\n         }\n-        if (t1 instanceof ParameterizedType) {\n-            return equals((ParameterizedType)t1, t2);\n+        if (a instanceof ParameterizedType) {\n+            return equals((ParameterizedType)a, b);\n         }\n-        if (t1 instanceof GenericArrayType) {\n-            return equals((GenericArrayType)t1, t2);\n+        if (a instanceof GenericArrayType) {\n+            return equals((GenericArrayType)a, b);\n         }\n-        return t1 instanceof WildcardType && equals((WildcardType)t1, t2);\n+        return a instanceof WildcardType && equals((WildcardType)a, b);\n     }\n     \n-    private static boolean equals(final ParameterizedType p, final Type t) {\n-        if (t instanceof ParameterizedType) {\n-            final ParameterizedType other = (ParameterizedType)t;\n-            if (equals(p.getRawType(), other.getRawType()) && equals(p.getOwnerType(), other.getOwnerType())) {\n-                return equals(p.getActualTypeArguments(), other.getActualTypeArguments());\n+    private static boolean equals(final ParameterizedType parameterizedType, final Type type) {\n+        if (type instanceof ParameterizedType) {\n+            final ParameterizedType parameterizedType2 = (ParameterizedType)type;\n+            if (equals(parameterizedType.getRawType(), parameterizedType2.getRawType()) && equals(parameterizedType.getOwnerType(), parameterizedType2.getOwnerType())) {\n+                return equals(parameterizedType.getActualTypeArguments(), parameterizedType2.getActualTypeArguments());\n             }\n         }\n         return false;\n     }\n     \n-    private static boolean equals(final GenericArrayType a, final Type t) {\n-        return t instanceof GenericArrayType && equals(a.getGenericComponentType(), ((GenericArrayType)t).getGenericComponentType());\n+    private static boolean equals(final GenericArrayType genericArrayType, final Type type) {\n+        return type instanceof GenericArrayType && equals(genericArrayType.getGenericComponentType(), ((GenericArrayType)type).getGenericComponentType());\n     }\n     \n-    private static boolean equals(final WildcardType w, final Type t) {\n-        if (t instanceof WildcardType) {\n-            final WildcardType other = (WildcardType)t;\n-            return equals(getImplicitLowerBounds(w), getImplicitLowerBounds(other)) && equals(getImplicitUpperBounds(w), getImplicitUpperBounds(other));\n+    private static boolean equals(final WildcardType wildcardType, final Type type) {\n+        if (type instanceof WildcardType) {\n+            final WildcardType wildcardType2 = (WildcardType)type;\n+            return equals(getImplicitLowerBounds(wildcardType), getImplicitLowerBounds(wildcardType2)) && equals(getImplicitUpperBounds(wildcardType), getImplicitUpperBounds(wildcardType2));\n         }\n         return false;\n     }\n     \n-    private static boolean equals(final Type[] t1, final Type[] t2) {\n-        if (t1.length == t2.length) {\n-            for (int i = 0; i < t1.length; ++i) {\n-                if (!equals(t1[i], t2[i])) {\n+    private static boolean equals(final Type[] array, final Type[] array2) {\n+        if (array.length == array2.length) {\n+            for (int i = 0; i < array.length; ++i) {\n+                if (!equals(array[i], array2[i])) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n         return false;\n     }\n@@ -697,151 +703,151 @@\n         }\n         if (type instanceof GenericArrayType) {\n             return genericArrayTypeToString((GenericArrayType)type);\n         }\n         throw new IllegalArgumentException(ObjectUtils.identityToString((Object)type));\n     }\n     \n-    public static String toLongString(final TypeVariable<?> var) {\n-        Validate.notNull((Object)var, \"var is null\", new Object[0]);\n-        final StringBuilder buf = new StringBuilder();\n-        final GenericDeclaration d = (GenericDeclaration)var.getGenericDeclaration();\n-        if (d instanceof Class) {\n-            Class<?> c;\n-            for (c = (Class)d; c.getEnclosingClass() != null; c = c.getEnclosingClass()) {\n-                buf.insert(0, c.getSimpleName()).insert(0, '.');\n+    public static String toLongString(final TypeVariable<?> typeVariable) {\n+        Validate.notNull((Object)typeVariable, \"var is null\", new Object[0]);\n+        final StringBuilder sb = new StringBuilder();\n+        final Object genericDeclaration = typeVariable.getGenericDeclaration();\n+        if (genericDeclaration instanceof Class) {\n+            Class enclosingClass;\n+            for (enclosingClass = (Class)genericDeclaration; enclosingClass.getEnclosingClass() != null; enclosingClass = enclosingClass.getEnclosingClass()) {\n+                sb.insert(0, enclosingClass.getSimpleName()).insert(0, '.');\n             }\n-            buf.insert(0, c.getName());\n+            sb.insert(0, enclosingClass.getName());\n         }\n-        else if (d instanceof Type) {\n-            buf.append(toString((Type)d));\n+        else if (genericDeclaration instanceof Type) {\n+            sb.append(toString((Type)genericDeclaration));\n         }\n         else {\n-            buf.append(d);\n+            sb.append(genericDeclaration);\n         }\n-        return buf.append(':').append(typeVariableToString(var)).toString();\n+        return sb.append(':').append(typeVariableToString(typeVariable)).toString();\n     }\n     \n     public static <T> Typed<T> wrap(final Type type) {\n         return (Typed<T>)new TypeUtils.TypeUtils$1(type);\n     }\n     \n-    public static <T> Typed<T> wrap(final Class<T> type) {\n-        return wrap((Type)type);\n+    public static <T> Typed<T> wrap(final Class<T> clazz) {\n+        return wrap((Type)clazz);\n     }\n     \n-    private static String classToString(final Class<?> c) {\n-        if (c.isArray()) {\n-            return toString((Type)c.getComponentType()) + \"[]\";\n+    private static String classToString(final Class<?> clazz) {\n+        if (clazz.isArray()) {\n+            return toString((Type)clazz.getComponentType()) + \"[]\";\n         }\n-        final StringBuilder buf = new StringBuilder();\n-        if (c.getEnclosingClass() != null) {\n-            buf.append(classToString(c.getEnclosingClass())).append('.').append(c.getSimpleName());\n+        final StringBuilder sb = new StringBuilder();\n+        if (clazz.getEnclosingClass() != null) {\n+            sb.append(classToString((Class<?>)clazz.getEnclosingClass())).append('.').append(clazz.getSimpleName());\n         }\n         else {\n-            buf.append(c.getName());\n+            sb.append(clazz.getName());\n         }\n-        if (c.getTypeParameters().length > 0) {\n-            buf.append('<');\n-            appendAllTo(buf, \", \", c.getTypeParameters());\n-            buf.append('>');\n+        if (clazz.getTypeParameters().length > 0) {\n+            sb.append('<');\n+            appendAllTo(sb, \", \", clazz.getTypeParameters());\n+            sb.append('>');\n         }\n-        return buf.toString();\n+        return sb.toString();\n     }\n     \n-    private static String typeVariableToString(final TypeVariable<?> v) {\n-        final StringBuilder buf = new StringBuilder(v.getName());\n-        final Type[] bounds = v.getBounds();\n+    private static String typeVariableToString(final TypeVariable<?> typeVariable) {\n+        final StringBuilder sb = new StringBuilder(typeVariable.getName());\n+        final Type[] bounds = typeVariable.getBounds();\n         if (bounds.length > 0 && (bounds.length != 1 || !Object.class.equals(bounds[0]))) {\n-            buf.append(\" extends \");\n-            appendAllTo(buf, \" & \", v.getBounds());\n+            sb.append(\" extends \");\n+            appendAllTo(sb, \" & \", typeVariable.getBounds());\n         }\n-        return buf.toString();\n+        return sb.toString();\n     }\n     \n-    private static String parameterizedTypeToString(final ParameterizedType p) {\n-        final StringBuilder buf = new StringBuilder();\n-        final Type useOwner = p.getOwnerType();\n-        final Class<?> raw = (Class)p.getRawType();\n-        if (useOwner == null) {\n-            buf.append(raw.getName());\n+    private static String parameterizedTypeToString(final ParameterizedType parameterizedType) {\n+        final StringBuilder sb = new StringBuilder();\n+        final Type ownerType = parameterizedType.getOwnerType();\n+        final Class clazz = (Class)parameterizedType.getRawType();\n+        if (ownerType == null) {\n+            sb.append(clazz.getName());\n         }\n         else {\n-            if (useOwner instanceof Class) {\n-                buf.append(((Class)useOwner).getName());\n+            if (ownerType instanceof Class) {\n+                sb.append(((Class)ownerType).getName());\n             }\n             else {\n-                buf.append(useOwner.toString());\n+                sb.append(ownerType.toString());\n             }\n-            buf.append('.').append(raw.getSimpleName());\n+            sb.append('.').append(clazz.getSimpleName());\n         }\n-        final int[] recursiveTypeIndexes = findRecursiveTypes(p);\n-        if (recursiveTypeIndexes.length > 0) {\n-            appendRecursiveTypes(buf, recursiveTypeIndexes, p.getActualTypeArguments());\n+        final int[] recursiveTypes = findRecursiveTypes(parameterizedType);\n+        if (recursiveTypes.length > 0) {\n+            appendRecursiveTypes(sb, recursiveTypes, parameterizedType.getActualTypeArguments());\n         }\n         else {\n-            appendAllTo(buf.append('<'), \", \", p.getActualTypeArguments()).append('>');\n+            appendAllTo(sb.append('<'), \", \", parameterizedType.getActualTypeArguments()).append('>');\n         }\n-        return buf.toString();\n+        return sb.toString();\n     }\n     \n-    private static void appendRecursiveTypes(final StringBuilder buf, final int[] recursiveTypeIndexes, final Type[] argumentTypes) {\n-        for (int i = 0; i < recursiveTypeIndexes.length; ++i) {\n-            appendAllTo(buf.append('<'), \", \", argumentTypes[i].toString()).append('>');\n+    private static void appendRecursiveTypes(final StringBuilder sb, final int[] array, final Type[] array2) {\n+        for (int i = 0; i < array.length; ++i) {\n+            appendAllTo(sb.append('<'), \", \", array2[i].toString()).append('>');\n         }\n-        final Type[] argumentsFiltered = (Type[])ArrayUtils.removeAll((Object[])argumentTypes, recursiveTypeIndexes);\n-        if (argumentsFiltered.length > 0) {\n-            appendAllTo(buf.append('<'), \", \", argumentsFiltered).append('>');\n+        final Type[] array3 = (Type[])ArrayUtils.removeAll((Object[])array2, array);\n+        if (array3.length > 0) {\n+            appendAllTo(sb.append('<'), \", \", array3).append('>');\n         }\n     }\n     \n-    private static int[] findRecursiveTypes(final ParameterizedType p) {\n-        final Type[] filteredArgumentTypes = (Type[])Arrays.copyOf(p.getActualTypeArguments(), p.getActualTypeArguments().length);\n-        int[] indexesToRemove = new int[0];\n-        for (int i = 0; i < filteredArgumentTypes.length; ++i) {\n-            if (filteredArgumentTypes[i] instanceof TypeVariable && containsVariableTypeSameParametrizedTypeBound((TypeVariable<?>)filteredArgumentTypes[i], p)) {\n-                indexesToRemove = ArrayUtils.add(indexesToRemove, i);\n+    private static int[] findRecursiveTypes(final ParameterizedType parameterizedType) {\n+        final Type[] array = (Type[])Arrays.copyOf(parameterizedType.getActualTypeArguments(), parameterizedType.getActualTypeArguments().length);\n+        int[] add = new int[0];\n+        for (int i = 0; i < array.length; ++i) {\n+            if (array[i] instanceof TypeVariable && containsVariableTypeSameParametrizedTypeBound((TypeVariable<?>)array[i], parameterizedType)) {\n+                add = ArrayUtils.add(add, i);\n             }\n         }\n-        return indexesToRemove;\n+        return add;\n     }\n     \n-    private static boolean containsVariableTypeSameParametrizedTypeBound(final TypeVariable<?> typeVariable, final ParameterizedType p) {\n-        return ArrayUtils.contains((Object[])typeVariable.getBounds(), (Object)p);\n+    private static boolean containsVariableTypeSameParametrizedTypeBound(final TypeVariable<?> typeVariable, final ParameterizedType parameterizedType) {\n+        return ArrayUtils.contains((Object[])typeVariable.getBounds(), (Object)parameterizedType);\n     }\n     \n-    private static String wildcardTypeToString(final WildcardType w) {\n-        final StringBuilder buf = new StringBuilder().append('?');\n-        final Type[] lowerBounds = w.getLowerBounds();\n-        final Type[] upperBounds = w.getUpperBounds();\n+    private static String wildcardTypeToString(final WildcardType wildcardType) {\n+        final StringBuilder append = new StringBuilder().append('?');\n+        final Type[] lowerBounds = wildcardType.getLowerBounds();\n+        final Type[] upperBounds = wildcardType.getUpperBounds();\n         if (lowerBounds.length > 1 || (lowerBounds.length == 1 && lowerBounds[0] != null)) {\n-            appendAllTo(buf.append(\" super \"), \" & \", lowerBounds);\n+            appendAllTo(append.append(\" super \"), \" & \", lowerBounds);\n         }\n         else if (upperBounds.length > 1 || (upperBounds.length == 1 && !Object.class.equals(upperBounds[0]))) {\n-            appendAllTo(buf.append(\" extends \"), \" & \", upperBounds);\n+            appendAllTo(append.append(\" extends \"), \" & \", upperBounds);\n         }\n-        return buf.toString();\n+        return append.toString();\n     }\n     \n-    private static String genericArrayTypeToString(final GenericArrayType g) {\n-        return String.format(\"%s[]\", toString(g.getGenericComponentType()));\n+    private static String genericArrayTypeToString(final GenericArrayType genericArrayType) {\n+        return String.format(\"%s[]\", toString(genericArrayType.getGenericComponentType()));\n     }\n     \n-    private static <T> StringBuilder appendAllTo(final StringBuilder buf, final String sep, final T... types) {\n-        Validate.notEmpty(Validate.noNullElements((Object[])types));\n-        if (types.length > 0) {\n-            buf.append(toString(types[0]));\n-            for (int i = 1; i < types.length; ++i) {\n-                buf.append(sep).append(toString(types[i]));\n+    private static <T> StringBuilder appendAllTo(final StringBuilder sb, final String str, final T... array) {\n+        Validate.notEmpty(Validate.noNullElements((Object[])array));\n+        if (array.length > 0) {\n+            sb.append(toString(array[0]));\n+            for (int i = 1; i < array.length; ++i) {\n+                sb.append(str).append(toString(array[i]));\n             }\n         }\n-        return buf;\n+        return sb;\n     }\n     \n-    private static <T> String toString(final T object) {\n-        return (object instanceof Type) ? toString((Type)object) : object.toString();\n+    private static <T> String toString(final T t) {\n+        return (t instanceof Type) ? toString((Type)t) : t.toString();\n     }\n     \n     static {\n         WILDCARD_ALL = wildcardType().withUpperBounds(new Type[] { Object.class }).build();\n     }\n }\n"}]}
