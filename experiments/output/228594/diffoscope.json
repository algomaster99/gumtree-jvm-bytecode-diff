{"diffoscope-json-version": 1, "source1": "first/Base32.class", "source2": "second/Base32.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -23,261 +23,260 @@\n     private final byte[] encodeTable;\n     private final byte[] lineSeparator;\n     \n     public Base32() {\n         this(false);\n     }\n     \n-    public Base32(final boolean useHex) {\n-        this(0, null, useHex, (byte)61);\n+    public Base32(final boolean b) {\n+        this(0, null, b, (byte)61);\n     }\n     \n-    public Base32(final boolean useHex, final byte padding) {\n-        this(0, null, useHex, padding);\n+    public Base32(final boolean b, final byte b2) {\n+        this(0, null, b, b2);\n     }\n     \n-    public Base32(final byte pad) {\n-        this(false, pad);\n+    public Base32(final byte b) {\n+        this(false, b);\n     }\n     \n-    public Base32(final int lineLength) {\n-        this(lineLength, Base32.CHUNK_SEPARATOR);\n+    public Base32(final int n) {\n+        this(n, Base32.CHUNK_SEPARATOR);\n     }\n     \n-    public Base32(final int lineLength, final byte[] lineSeparator) {\n-        this(lineLength, lineSeparator, false, (byte)61);\n+    public Base32(final int n, final byte[] array) {\n+        this(n, array, false, (byte)61);\n     }\n     \n-    public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex) {\n-        this(lineLength, lineSeparator, useHex, (byte)61);\n+    public Base32(final int n, final byte[] array, final boolean b) {\n+        this(n, array, b, (byte)61);\n     }\n     \n-    public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte padding) {\n-        this(lineLength, lineSeparator, useHex, padding, Base32.DECODING_POLICY_DEFAULT);\n+    public Base32(final int n, final byte[] array, final boolean b, final byte b2) {\n+        this(n, array, b, b2, Base32.DECODING_POLICY_DEFAULT);\n     }\n     \n-    public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte padding, final CodecPolicy decodingPolicy) {\n-        super(5, 8, lineLength, (lineSeparator == null) ? 0 : lineSeparator.length, padding, decodingPolicy);\n-        if (useHex) {\n+    public Base32(final int i, final byte[] array, final boolean b, final byte b2, final CodecPolicy codecPolicy) {\n+        super(5, 8, i, (array == null) ? 0 : array.length, b2, codecPolicy);\n+        if (b) {\n             this.encodeTable = Base32.HEX_ENCODE_TABLE;\n             this.decodeTable = Base32.HEX_DECODE_TABLE;\n         }\n         else {\n             this.encodeTable = Base32.ENCODE_TABLE;\n             this.decodeTable = Base32.DECODE_TABLE;\n         }\n-        if (lineLength > 0) {\n-            if (lineSeparator == null) {\n-                throw new IllegalArgumentException(\"lineLength \" + lineLength + \" > 0, but lineSeparator is null\");\n+        if (i > 0) {\n+            if (array == null) {\n+                throw new IllegalArgumentException(\"lineLength \" + i + \" > 0, but lineSeparator is null\");\n             }\n-            if (this.containsAlphabetOrPad(lineSeparator)) {\n-                final String sep = StringUtils.newStringUtf8(lineSeparator);\n-                throw new IllegalArgumentException(\"lineSeparator must not contain Base32 characters: [\" + sep + \"]\");\n+            if (this.containsAlphabetOrPad(array)) {\n+                throw new IllegalArgumentException(\"lineSeparator must not contain Base32 characters: [\" + StringUtils.newStringUtf8(array) + \"]\");\n             }\n-            this.encodeSize = 8 + lineSeparator.length;\n-            System.arraycopy(lineSeparator, 0, this.lineSeparator = new byte[lineSeparator.length], 0, lineSeparator.length);\n+            this.encodeSize = 8 + array.length;\n+            System.arraycopy(array, 0, this.lineSeparator = new byte[array.length], 0, array.length);\n         }\n         else {\n             this.encodeSize = 8;\n             this.lineSeparator = null;\n         }\n         this.decodeSize = this.encodeSize - 1;\n-        if (this.isInAlphabet(padding) || isWhiteSpace(padding)) {\n+        if (this.isInAlphabet(b2) || isWhiteSpace(b2)) {\n             throw new IllegalArgumentException(\"pad must not be in alphabet or whitespace\");\n         }\n     }\n     \n-    void decode(final byte[] input, int inPos, final int inAvail, final BaseNCodec.Context context) {\n+    void decode(final byte[] array, int n, final int n2, final BaseNCodec.Context context) {\n         if (context.eof) {\n             return;\n         }\n-        if (inAvail < 0) {\n+        if (n2 < 0) {\n             context.eof = true;\n         }\n-        for (int i = 0; i < inAvail; ++i) {\n-            final byte b = input[inPos++];\n+        for (int i = 0; i < n2; ++i) {\n+            final byte b = array[n++];\n             if (b == this.pad) {\n                 context.eof = true;\n                 break;\n             }\n-            final byte[] buffer = this.ensureBufferSize(this.decodeSize, context);\n+            final byte[] ensureBufferSize = this.ensureBufferSize(this.decodeSize, context);\n             if (b >= 0 && b < this.decodeTable.length) {\n-                final int result = this.decodeTable[b];\n-                if (result >= 0) {\n+                final byte b2 = this.decodeTable[b];\n+                if (b2 >= 0) {\n                     context.modulus = (context.modulus + 1) % 8;\n-                    context.lbitWorkArea = (context.lbitWorkArea << 5) + result;\n+                    context.lbitWorkArea = (context.lbitWorkArea << 5) + b2;\n                     if (context.modulus == 0) {\n-                        buffer[context.pos++] = (byte)(context.lbitWorkArea >> 32 & 0xFFL);\n-                        buffer[context.pos++] = (byte)(context.lbitWorkArea >> 24 & 0xFFL);\n-                        buffer[context.pos++] = (byte)(context.lbitWorkArea >> 16 & 0xFFL);\n-                        buffer[context.pos++] = (byte)(context.lbitWorkArea >> 8 & 0xFFL);\n-                        buffer[context.pos++] = (byte)(context.lbitWorkArea & 0xFFL);\n+                        ensureBufferSize[context.pos++] = (byte)(context.lbitWorkArea >> 32 & 0xFFL);\n+                        ensureBufferSize[context.pos++] = (byte)(context.lbitWorkArea >> 24 & 0xFFL);\n+                        ensureBufferSize[context.pos++] = (byte)(context.lbitWorkArea >> 16 & 0xFFL);\n+                        ensureBufferSize[context.pos++] = (byte)(context.lbitWorkArea >> 8 & 0xFFL);\n+                        ensureBufferSize[context.pos++] = (byte)(context.lbitWorkArea & 0xFFL);\n                     }\n                 }\n             }\n         }\n         if (context.eof && context.modulus > 0) {\n-            final byte[] buffer2 = this.ensureBufferSize(this.decodeSize, context);\n+            final byte[] ensureBufferSize2 = this.ensureBufferSize(this.decodeSize, context);\n             switch (context.modulus) {\n                 case 1: {\n                     this.validateTrailingCharacters();\n                 }\n                 case 2: {\n                     this.validateCharacter(3L, context);\n-                    buffer2[context.pos++] = (byte)(context.lbitWorkArea >> 2 & 0xFFL);\n+                    ensureBufferSize2[context.pos++] = (byte)(context.lbitWorkArea >> 2 & 0xFFL);\n                     break;\n                 }\n                 case 3: {\n                     this.validateTrailingCharacters();\n-                    buffer2[context.pos++] = (byte)(context.lbitWorkArea >> 7 & 0xFFL);\n+                    ensureBufferSize2[context.pos++] = (byte)(context.lbitWorkArea >> 7 & 0xFFL);\n                     break;\n                 }\n                 case 4: {\n                     this.validateCharacter(15L, context);\n                     context.lbitWorkArea >>= 4;\n-                    buffer2[context.pos++] = (byte)(context.lbitWorkArea >> 8 & 0xFFL);\n-                    buffer2[context.pos++] = (byte)(context.lbitWorkArea & 0xFFL);\n+                    ensureBufferSize2[context.pos++] = (byte)(context.lbitWorkArea >> 8 & 0xFFL);\n+                    ensureBufferSize2[context.pos++] = (byte)(context.lbitWorkArea & 0xFFL);\n                     break;\n                 }\n                 case 5: {\n                     this.validateCharacter(1L, context);\n                     context.lbitWorkArea >>= 1;\n-                    buffer2[context.pos++] = (byte)(context.lbitWorkArea >> 16 & 0xFFL);\n-                    buffer2[context.pos++] = (byte)(context.lbitWorkArea >> 8 & 0xFFL);\n-                    buffer2[context.pos++] = (byte)(context.lbitWorkArea & 0xFFL);\n+                    ensureBufferSize2[context.pos++] = (byte)(context.lbitWorkArea >> 16 & 0xFFL);\n+                    ensureBufferSize2[context.pos++] = (byte)(context.lbitWorkArea >> 8 & 0xFFL);\n+                    ensureBufferSize2[context.pos++] = (byte)(context.lbitWorkArea & 0xFFL);\n                     break;\n                 }\n                 case 6: {\n                     this.validateTrailingCharacters();\n                     context.lbitWorkArea >>= 6;\n-                    buffer2[context.pos++] = (byte)(context.lbitWorkArea >> 16 & 0xFFL);\n-                    buffer2[context.pos++] = (byte)(context.lbitWorkArea >> 8 & 0xFFL);\n-                    buffer2[context.pos++] = (byte)(context.lbitWorkArea & 0xFFL);\n+                    ensureBufferSize2[context.pos++] = (byte)(context.lbitWorkArea >> 16 & 0xFFL);\n+                    ensureBufferSize2[context.pos++] = (byte)(context.lbitWorkArea >> 8 & 0xFFL);\n+                    ensureBufferSize2[context.pos++] = (byte)(context.lbitWorkArea & 0xFFL);\n                     break;\n                 }\n                 case 7: {\n                     this.validateCharacter(7L, context);\n                     context.lbitWorkArea >>= 3;\n-                    buffer2[context.pos++] = (byte)(context.lbitWorkArea >> 24 & 0xFFL);\n-                    buffer2[context.pos++] = (byte)(context.lbitWorkArea >> 16 & 0xFFL);\n-                    buffer2[context.pos++] = (byte)(context.lbitWorkArea >> 8 & 0xFFL);\n-                    buffer2[context.pos++] = (byte)(context.lbitWorkArea & 0xFFL);\n+                    ensureBufferSize2[context.pos++] = (byte)(context.lbitWorkArea >> 24 & 0xFFL);\n+                    ensureBufferSize2[context.pos++] = (byte)(context.lbitWorkArea >> 16 & 0xFFL);\n+                    ensureBufferSize2[context.pos++] = (byte)(context.lbitWorkArea >> 8 & 0xFFL);\n+                    ensureBufferSize2[context.pos++] = (byte)(context.lbitWorkArea & 0xFFL);\n                     break;\n                 }\n                 default: {\n                     throw new IllegalStateException(\"Impossible modulus \" + context.modulus);\n                 }\n             }\n         }\n     }\n     \n-    void encode(final byte[] input, int inPos, final int inAvail, final BaseNCodec.Context context) {\n+    void encode(final byte[] array, int n, final int n2, final BaseNCodec.Context context) {\n         if (context.eof) {\n             return;\n         }\n-        if (inAvail < 0) {\n+        if (n2 < 0) {\n             context.eof = true;\n             if (0 == context.modulus && this.lineLength == 0) {\n                 return;\n             }\n-            final byte[] buffer = this.ensureBufferSize(this.encodeSize, context);\n-            final int savedPos = context.pos;\n+            final byte[] ensureBufferSize = this.ensureBufferSize(this.encodeSize, context);\n+            final int pos = context.pos;\n             switch (context.modulus) {\n                 case 0: {\n                     break;\n                 }\n                 case 1: {\n-                    buffer[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 3) & 0x1F];\n-                    buffer[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea << 2) & 0x1F];\n-                    buffer[context.pos++] = this.pad;\n-                    buffer[context.pos++] = this.pad;\n-                    buffer[context.pos++] = this.pad;\n-                    buffer[context.pos++] = this.pad;\n-                    buffer[context.pos++] = this.pad;\n-                    buffer[context.pos++] = this.pad;\n+                    ensureBufferSize[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 3) & 0x1F];\n+                    ensureBufferSize[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea << 2) & 0x1F];\n+                    ensureBufferSize[context.pos++] = this.pad;\n+                    ensureBufferSize[context.pos++] = this.pad;\n+                    ensureBufferSize[context.pos++] = this.pad;\n+                    ensureBufferSize[context.pos++] = this.pad;\n+                    ensureBufferSize[context.pos++] = this.pad;\n+                    ensureBufferSize[context.pos++] = this.pad;\n                     break;\n                 }\n                 case 2: {\n-                    buffer[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 11) & 0x1F];\n-                    buffer[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 6) & 0x1F];\n-                    buffer[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 1) & 0x1F];\n-                    buffer[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea << 4) & 0x1F];\n-                    buffer[context.pos++] = this.pad;\n-                    buffer[context.pos++] = this.pad;\n-                    buffer[context.pos++] = this.pad;\n-                    buffer[context.pos++] = this.pad;\n+                    ensureBufferSize[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 11) & 0x1F];\n+                    ensureBufferSize[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 6) & 0x1F];\n+                    ensureBufferSize[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 1) & 0x1F];\n+                    ensureBufferSize[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea << 4) & 0x1F];\n+                    ensureBufferSize[context.pos++] = this.pad;\n+                    ensureBufferSize[context.pos++] = this.pad;\n+                    ensureBufferSize[context.pos++] = this.pad;\n+                    ensureBufferSize[context.pos++] = this.pad;\n                     break;\n                 }\n                 case 3: {\n-                    buffer[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 19) & 0x1F];\n-                    buffer[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 14) & 0x1F];\n-                    buffer[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 9) & 0x1F];\n-                    buffer[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 4) & 0x1F];\n-                    buffer[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea << 1) & 0x1F];\n-                    buffer[context.pos++] = this.pad;\n-                    buffer[context.pos++] = this.pad;\n-                    buffer[context.pos++] = this.pad;\n+                    ensureBufferSize[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 19) & 0x1F];\n+                    ensureBufferSize[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 14) & 0x1F];\n+                    ensureBufferSize[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 9) & 0x1F];\n+                    ensureBufferSize[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 4) & 0x1F];\n+                    ensureBufferSize[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea << 1) & 0x1F];\n+                    ensureBufferSize[context.pos++] = this.pad;\n+                    ensureBufferSize[context.pos++] = this.pad;\n+                    ensureBufferSize[context.pos++] = this.pad;\n                     break;\n                 }\n                 case 4: {\n-                    buffer[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 27) & 0x1F];\n-                    buffer[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 22) & 0x1F];\n-                    buffer[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 17) & 0x1F];\n-                    buffer[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 12) & 0x1F];\n-                    buffer[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 7) & 0x1F];\n-                    buffer[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 2) & 0x1F];\n-                    buffer[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea << 3) & 0x1F];\n-                    buffer[context.pos++] = this.pad;\n+                    ensureBufferSize[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 27) & 0x1F];\n+                    ensureBufferSize[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 22) & 0x1F];\n+                    ensureBufferSize[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 17) & 0x1F];\n+                    ensureBufferSize[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 12) & 0x1F];\n+                    ensureBufferSize[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 7) & 0x1F];\n+                    ensureBufferSize[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 2) & 0x1F];\n+                    ensureBufferSize[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea << 3) & 0x1F];\n+                    ensureBufferSize[context.pos++] = this.pad;\n                     break;\n                 }\n                 default: {\n                     throw new IllegalStateException(\"Impossible modulus \" + context.modulus);\n                 }\n             }\n-            context.currentLinePos += context.pos - savedPos;\n+            context.currentLinePos += context.pos - pos;\n             if (this.lineLength > 0 && context.currentLinePos > 0) {\n-                System.arraycopy(this.lineSeparator, 0, buffer, context.pos, this.lineSeparator.length);\n+                System.arraycopy(this.lineSeparator, 0, ensureBufferSize, context.pos, this.lineSeparator.length);\n                 context.pos += this.lineSeparator.length;\n             }\n         }\n         else {\n-            for (int i = 0; i < inAvail; ++i) {\n-                final byte[] buffer2 = this.ensureBufferSize(this.encodeSize, context);\n+            for (int i = 0; i < n2; ++i) {\n+                final byte[] ensureBufferSize2 = this.ensureBufferSize(this.encodeSize, context);\n                 context.modulus = (context.modulus + 1) % 5;\n-                int b = input[inPos++];\n-                if (b < 0) {\n-                    b += 256;\n+                int n3 = array[n++];\n+                if (n3 < 0) {\n+                    n3 += 256;\n                 }\n-                context.lbitWorkArea = (context.lbitWorkArea << 8) + b;\n+                context.lbitWorkArea = (context.lbitWorkArea << 8) + n3;\n                 if (0 == context.modulus) {\n-                    buffer2[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 35) & 0x1F];\n-                    buffer2[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 30) & 0x1F];\n-                    buffer2[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 25) & 0x1F];\n-                    buffer2[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 20) & 0x1F];\n-                    buffer2[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 15) & 0x1F];\n-                    buffer2[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 10) & 0x1F];\n-                    buffer2[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 5) & 0x1F];\n-                    buffer2[context.pos++] = this.encodeTable[(int)context.lbitWorkArea & 0x1F];\n+                    ensureBufferSize2[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 35) & 0x1F];\n+                    ensureBufferSize2[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 30) & 0x1F];\n+                    ensureBufferSize2[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 25) & 0x1F];\n+                    ensureBufferSize2[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 20) & 0x1F];\n+                    ensureBufferSize2[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 15) & 0x1F];\n+                    ensureBufferSize2[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 10) & 0x1F];\n+                    ensureBufferSize2[context.pos++] = this.encodeTable[(int)(context.lbitWorkArea >> 5) & 0x1F];\n+                    ensureBufferSize2[context.pos++] = this.encodeTable[(int)context.lbitWorkArea & 0x1F];\n                     context.currentLinePos += 8;\n                     if (this.lineLength > 0 && this.lineLength <= context.currentLinePos) {\n-                        System.arraycopy(this.lineSeparator, 0, buffer2, context.pos, this.lineSeparator.length);\n+                        System.arraycopy(this.lineSeparator, 0, ensureBufferSize2, context.pos, this.lineSeparator.length);\n                         context.pos += this.lineSeparator.length;\n                         context.currentLinePos = 0;\n                     }\n                 }\n             }\n         }\n     }\n     \n-    public boolean isInAlphabet(final byte octet) {\n-        return octet >= 0 && octet < this.decodeTable.length && this.decodeTable[octet] != -1;\n+    public boolean isInAlphabet(final byte b) {\n+        return b >= 0 && b < this.decodeTable.length && this.decodeTable[b] != -1;\n     }\n     \n-    private void validateCharacter(final long emptyBitsMask, final BaseNCodec.Context context) {\n-        if (this.isStrictDecoding() && (context.lbitWorkArea & emptyBitsMask) != 0x0L) {\n+    private void validateCharacter(final long n, final BaseNCodec.Context context) {\n+        if (this.isStrictDecoding() && (context.lbitWorkArea & n) != 0x0L) {\n             throw new IllegalArgumentException(\"Strict decoding: Last encoded character (before the paddings if any) is a valid base 32 alphabet but not a possible encoding. Expected the discarded bits from the character to be zero.\");\n         }\n     }\n     \n     private void validateTrailingCharacters() {\n         if (this.isStrictDecoding()) {\n             throw new IllegalArgumentException(\"Strict decoding: Last encoded character(s) (before the paddings if any) are valid base 32 alphabet but not a possible encoding. Decoding requires either 2, 4, 5, or 7 trailing 5-bit characters to create bytes.\");\n"}]}
