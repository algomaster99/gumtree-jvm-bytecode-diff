{"diffoscope-json-version": 1, "source1": "first/ExtraFieldUtils.class", "source2": "second/ExtraFieldUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,168 +1,165 @@\n \n package org.apache.commons.compress.archivers.zip;\n \n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.List;\n import java.util.Objects;\n import java.util.ArrayList;\n import java.util.zip.ZipException;\n import java.util.Map;\n \n public class ExtraFieldUtils\n {\n     private static final int WORD = 4;\n     private static final Map<ZipShort, Class<?>> implementations;\n     static final ZipExtraField[] EMPTY_ZIP_EXTRA_FIELD_ARRAY;\n     \n-    public static void register(final Class<?> c) {\n+    public static void register(final Class<?> obj) {\n         try {\n-            final ZipExtraField ze = (ZipExtraField)c.newInstance();\n-            ExtraFieldUtils.implementations.put(ze.getHeaderId(), c);\n+            ExtraFieldUtils.implementations.put(((ZipExtraField)obj.newInstance()).getHeaderId(), obj);\n         }\n-        catch (final ClassCastException cc) {\n-            throw new RuntimeException(c + \" doesn't implement ZipExtraField\");\n+        catch (final ClassCastException ex) {\n+            throw new RuntimeException(obj + \" doesn't implement ZipExtraField\");\n         }\n-        catch (final InstantiationException ie) {\n-            throw new RuntimeException(c + \" is not a concrete class\");\n+        catch (final InstantiationException ex2) {\n+            throw new RuntimeException(obj + \" is not a concrete class\");\n         }\n-        catch (final IllegalAccessException ie2) {\n-            throw new RuntimeException(c + \"'s no-arg constructor is not public\");\n+        catch (final IllegalAccessException ex3) {\n+            throw new RuntimeException(obj + \"'s no-arg constructor is not public\");\n         }\n     }\n     \n     public static ZipExtraField createExtraField(final ZipShort headerId) throws InstantiationException, IllegalAccessException {\n-        final ZipExtraField field = createExtraFieldNoDefault(headerId);\n-        if (field != null) {\n-            return field;\n-        }\n-        final UnrecognizedExtraField u = new UnrecognizedExtraField();\n-        u.setHeaderId(headerId);\n-        return (ZipExtraField)u;\n+        final ZipExtraField extraFieldNoDefault = createExtraFieldNoDefault(headerId);\n+        if (extraFieldNoDefault != null) {\n+            return extraFieldNoDefault;\n+        }\n+        final UnrecognizedExtraField unrecognizedExtraField = new UnrecognizedExtraField();\n+        unrecognizedExtraField.setHeaderId(headerId);\n+        return (ZipExtraField)unrecognizedExtraField;\n     }\n     \n-    public static ZipExtraField createExtraFieldNoDefault(final ZipShort headerId) throws InstantiationException, IllegalAccessException {\n-        final Class<?> c = (Class<?>)ExtraFieldUtils.implementations.get(headerId);\n-        if (c != null) {\n-            return (ZipExtraField)c.newInstance();\n+    public static ZipExtraField createExtraFieldNoDefault(final ZipShort zipShort) throws InstantiationException, IllegalAccessException {\n+        final Class clazz = (Class)ExtraFieldUtils.implementations.get(zipShort);\n+        if (clazz != null) {\n+            return (ZipExtraField)clazz.newInstance();\n         }\n         return null;\n     }\n     \n-    public static ZipExtraField[] parse(final byte[] data) throws ZipException {\n-        return parse(data, true, ExtraFieldUtils.UnparseableExtraField.THROW);\n+    public static ZipExtraField[] parse(final byte[] array) throws ZipException {\n+        return parse(array, true, ExtraFieldUtils.UnparseableExtraField.THROW);\n     }\n     \n-    public static ZipExtraField[] parse(final byte[] data, final boolean local) throws ZipException {\n-        return parse(data, local, ExtraFieldUtils.UnparseableExtraField.THROW);\n+    public static ZipExtraField[] parse(final byte[] array, final boolean b) throws ZipException {\n+        return parse(array, b, ExtraFieldUtils.UnparseableExtraField.THROW);\n     }\n     \n-    public static ZipExtraField[] parse(final byte[] data, final boolean local, final ExtraFieldUtils.UnparseableExtraField onUnparseableData) throws ZipException {\n-        return parse(data, local, (ExtraFieldParsingBehavior)new ExtraFieldUtils.ExtraFieldUtils$1(onUnparseableData));\n+    public static ZipExtraField[] parse(final byte[] array, final boolean b, final ExtraFieldUtils.UnparseableExtraField unparseableExtraField) throws ZipException {\n+        return parse(array, b, (ExtraFieldParsingBehavior)new ExtraFieldUtils.ExtraFieldUtils$1(unparseableExtraField));\n     }\n     \n-    public static ZipExtraField[] parse(final byte[] data, final boolean local, final ExtraFieldParsingBehavior parsingBehavior) throws ZipException {\n-        final List<ZipExtraField> v = new ArrayList<ZipExtraField>();\n-        int start = 0;\n-        final int dataLength = data.length;\n-        while (start <= dataLength - 4) {\n-            final ZipShort headerId = new ZipShort(data, start);\n-            final int length = new ZipShort(data, start + 2).getValue();\n-            if (start + 4 + length > dataLength) {\n-                final ZipExtraField field = parsingBehavior.onUnparseableExtraField(data, start, dataLength - start, local, length);\n-                if (field != null) {\n-                    v.add(field);\n+    public static ZipExtraField[] parse(final byte[] array, final boolean b, final ExtraFieldParsingBehavior extraFieldParsingBehavior) throws ZipException {\n+        final ArrayList list = new ArrayList();\n+        int i = 0;\n+        final int length = array.length;\n+        while (i <= length - 4) {\n+            final ZipShort zipShort = new ZipShort(array, i);\n+            final int value = new ZipShort(array, i + 2).getValue();\n+            if (i + 4 + value > length) {\n+                final ZipExtraField onUnparseableExtraField = extraFieldParsingBehavior.onUnparseableExtraField(array, i, length - i, b, value);\n+                if (onUnparseableExtraField != null) {\n+                    list.add(onUnparseableExtraField);\n                     break;\n                 }\n                 break;\n             }\n             else {\n                 try {\n-                    final ZipExtraField ze = (ZipExtraField)Objects.requireNonNull(parsingBehavior.createExtraField(headerId), \"createExtraField must not return null\");\n-                    v.add(Objects.requireNonNull(parsingBehavior.fill(ze, data, start + 4, length, local), \"fill must not return null\"));\n-                    start += length + 4;\n+                    list.add(Objects.requireNonNull(extraFieldParsingBehavior.fill((ZipExtraField)Objects.requireNonNull(extraFieldParsingBehavior.createExtraField(zipShort), \"createExtraField must not return null\"), array, i + 4, value, b), \"fill must not return null\"));\n+                    i += value + 4;\n                 }\n-                catch (final InstantiationException | IllegalAccessException ie) {\n-                    throw (ZipException)new ZipException(ie.getMessage()).initCause(ie);\n+                catch (final InstantiationException | IllegalAccessException cause) {\n+                    throw (ZipException)new ZipException(((Throwable)cause).getMessage()).initCause((Throwable)cause);\n                 }\n             }\n         }\n-        return v.toArray(ExtraFieldUtils.EMPTY_ZIP_EXTRA_FIELD_ARRAY);\n+        return (ZipExtraField[])list.toArray(ExtraFieldUtils.EMPTY_ZIP_EXTRA_FIELD_ARRAY);\n     }\n     \n-    public static byte[] mergeLocalFileDataData(final ZipExtraField[] data) {\n-        final int dataLength = data.length;\n-        final boolean lastIsUnparseableHolder = dataLength > 0 && data[dataLength - 1] instanceof UnparseableExtraFieldData;\n-        final int regularExtraFieldCount = lastIsUnparseableHolder ? (dataLength - 1) : dataLength;\n-        int sum = 4 * regularExtraFieldCount;\n-        for (final ZipExtraField element : data) {\n-            sum += element.getLocalFileDataLength().getValue();\n+    public static byte[] mergeLocalFileDataData(final ZipExtraField[] array) {\n+        final int length = array.length;\n+        final boolean b = length > 0 && array[length - 1] instanceof UnparseableExtraFieldData;\n+        final int n = b ? (length - 1) : length;\n+        int n2 = 4 * n;\n+        for (int length2 = array.length, i = 0; i < length2; ++i) {\n+            n2 += array[i].getLocalFileDataLength().getValue();\n         }\n-        final byte[] result = new byte[sum];\n-        int start = 0;\n-        for (int i = 0; i < regularExtraFieldCount; ++i) {\n-            System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n-            System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2);\n-            start += 4;\n-            final byte[] local = data[i].getLocalFileDataData();\n-            if (local != null) {\n-                System.arraycopy(local, 0, result, start, local.length);\n-                start += local.length;\n+        final byte[] array2 = new byte[n2];\n+        int n3 = 0;\n+        for (int j = 0; j < n; ++j) {\n+            System.arraycopy(array[j].getHeaderId().getBytes(), 0, array2, n3, 2);\n+            System.arraycopy(array[j].getLocalFileDataLength().getBytes(), 0, array2, n3 + 2, 2);\n+            n3 += 4;\n+            final byte[] localFileDataData = array[j].getLocalFileDataData();\n+            if (localFileDataData != null) {\n+                System.arraycopy(localFileDataData, 0, array2, n3, localFileDataData.length);\n+                n3 += localFileDataData.length;\n             }\n         }\n-        if (lastIsUnparseableHolder) {\n-            final byte[] local2 = data[dataLength - 1].getLocalFileDataData();\n-            if (local2 != null) {\n-                System.arraycopy(local2, 0, result, start, local2.length);\n+        if (b) {\n+            final byte[] localFileDataData2 = array[length - 1].getLocalFileDataData();\n+            if (localFileDataData2 != null) {\n+                System.arraycopy(localFileDataData2, 0, array2, n3, localFileDataData2.length);\n             }\n         }\n-        return result;\n+        return array2;\n     }\n     \n-    public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data) {\n-        final int dataLength = data.length;\n-        final boolean lastIsUnparseableHolder = dataLength > 0 && data[dataLength - 1] instanceof UnparseableExtraFieldData;\n-        final int regularExtraFieldCount = lastIsUnparseableHolder ? (dataLength - 1) : dataLength;\n-        int sum = 4 * regularExtraFieldCount;\n-        for (final ZipExtraField element : data) {\n-            sum += element.getCentralDirectoryLength().getValue();\n+    public static byte[] mergeCentralDirectoryData(final ZipExtraField[] array) {\n+        final int length = array.length;\n+        final boolean b = length > 0 && array[length - 1] instanceof UnparseableExtraFieldData;\n+        final int n = b ? (length - 1) : length;\n+        int n2 = 4 * n;\n+        for (int length2 = array.length, i = 0; i < length2; ++i) {\n+            n2 += array[i].getCentralDirectoryLength().getValue();\n         }\n-        final byte[] result = new byte[sum];\n-        int start = 0;\n-        for (int i = 0; i < regularExtraFieldCount; ++i) {\n-            System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n-            System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2);\n-            start += 4;\n-            final byte[] central = data[i].getCentralDirectoryData();\n-            if (central != null) {\n-                System.arraycopy(central, 0, result, start, central.length);\n-                start += central.length;\n+        final byte[] array2 = new byte[n2];\n+        int n3 = 0;\n+        for (int j = 0; j < n; ++j) {\n+            System.arraycopy(array[j].getHeaderId().getBytes(), 0, array2, n3, 2);\n+            System.arraycopy(array[j].getCentralDirectoryLength().getBytes(), 0, array2, n3 + 2, 2);\n+            n3 += 4;\n+            final byte[] centralDirectoryData = array[j].getCentralDirectoryData();\n+            if (centralDirectoryData != null) {\n+                System.arraycopy(centralDirectoryData, 0, array2, n3, centralDirectoryData.length);\n+                n3 += centralDirectoryData.length;\n             }\n         }\n-        if (lastIsUnparseableHolder) {\n-            final byte[] central2 = data[dataLength - 1].getCentralDirectoryData();\n-            if (central2 != null) {\n-                System.arraycopy(central2, 0, result, start, central2.length);\n+        if (b) {\n+            final byte[] centralDirectoryData2 = array[length - 1].getCentralDirectoryData();\n+            if (centralDirectoryData2 != null) {\n+                System.arraycopy(centralDirectoryData2, 0, array2, n3, centralDirectoryData2.length);\n             }\n         }\n-        return result;\n+        return array2;\n     }\n     \n-    public static ZipExtraField fillExtraField(final ZipExtraField ze, final byte[] data, final int off, final int len, final boolean local) throws ZipException {\n+    public static ZipExtraField fillExtraField(final ZipExtraField zipExtraField, final byte[] array, final int n, final int n2, final boolean b) throws ZipException {\n         try {\n-            if (local) {\n-                ze.parseFromLocalFileData(data, off, len);\n+            if (b) {\n+                zipExtraField.parseFromLocalFileData(array, n, n2);\n             }\n             else {\n-                ze.parseFromCentralDirectoryData(data, off, len);\n+                zipExtraField.parseFromCentralDirectoryData(array, n, n2);\n             }\n-            return ze;\n+            return zipExtraField;\n         }\n-        catch (final ArrayIndexOutOfBoundsException aiobe) {\n-            throw (ZipException)new ZipException(\"Failed to parse corrupt ZIP extra field of type \" + Integer.toHexString(ze.getHeaderId().getValue())).initCause(aiobe);\n+        catch (final ArrayIndexOutOfBoundsException cause) {\n+            throw (ZipException)new ZipException(\"Failed to parse corrupt ZIP extra field of type \" + Integer.toHexString(zipExtraField.getHeaderId().getValue())).initCause(cause);\n         }\n     }\n     \n     static {\n         implementations = new ConcurrentHashMap<ZipShort, Class<?>>();\n         register(AsiExtraField.class);\n         register(X5455_ExtendedTimestamp.class);\n"}]}
