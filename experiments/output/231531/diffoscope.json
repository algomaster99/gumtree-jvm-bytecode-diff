{"diffoscope-json-version": 1, "source1": "first/ZipUtil.class", "source2": "second/ZipUtil.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -12,178 +12,173 @@\n import java.math.BigInteger;\n \n public abstract class ZipUtil\n {\n     private static final long DOSTIME_BEFORE_1980 = 2162688L;\n     private static final long UPPER_DOSTIME_BOUND = 4036608000000L;\n     \n-    public static long adjustToLong(final int i) {\n-        if (i < 0) {\n-            return 4294967296L + i;\n+    public static long adjustToLong(final int n) {\n+        if (n < 0) {\n+            return 4294967296L + n;\n         }\n-        return i;\n+        return n;\n     }\n     \n-    static long bigToLong(final BigInteger big) {\n-        if (big.bitLength() <= 63) {\n-            return big.longValue();\n+    static long bigToLong(final BigInteger obj) {\n+        if (obj.bitLength() <= 63) {\n+            return obj.longValue();\n         }\n-        throw new NumberFormatException(\"The BigInteger cannot fit inside a 64 bit java long: [\" + big + \"]\");\n+        throw new NumberFormatException(\"The BigInteger cannot fit inside a 64 bit java long: [\" + obj + \"]\");\n     }\n     \n-    static boolean canHandleEntryData(final ZipArchiveEntry entry) {\n-        return supportsEncryptionOf(entry) && supportsMethodOf(entry);\n+    static boolean canHandleEntryData(final ZipArchiveEntry zipArchiveEntry) {\n+        return supportsEncryptionOf(zipArchiveEntry) && supportsMethodOf(zipArchiveEntry);\n     }\n     \n-    static void checkRequestedFeatures(final ZipArchiveEntry ze) throws UnsupportedZipFeatureException {\n-        if (!supportsEncryptionOf(ze)) {\n-            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.ENCRYPTION, ze);\n+    static void checkRequestedFeatures(final ZipArchiveEntry zipArchiveEntry) throws UnsupportedZipFeatureException {\n+        if (!supportsEncryptionOf(zipArchiveEntry)) {\n+            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.ENCRYPTION, zipArchiveEntry);\n         }\n-        if (supportsMethodOf(ze)) {\n+        if (supportsMethodOf(zipArchiveEntry)) {\n             return;\n         }\n-        final ZipMethod m = ZipMethod.getMethodByCode(ze.getMethod());\n-        if (m == null) {\n-            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.METHOD, ze);\n+        final ZipMethod methodByCode = ZipMethod.getMethodByCode(zipArchiveEntry.getMethod());\n+        if (methodByCode == null) {\n+            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.METHOD, zipArchiveEntry);\n         }\n-        throw new UnsupportedZipFeatureException(m, ze);\n+        throw new UnsupportedZipFeatureException(methodByCode, zipArchiveEntry);\n     }\n     \n-    static byte[] copy(final byte[] from) {\n-        if (from != null) {\n-            return Arrays.copyOf(from, from.length);\n+    static byte[] copy(final byte[] original) {\n+        if (original != null) {\n+            return Arrays.copyOf(original, original.length);\n         }\n         return null;\n     }\n     \n-    static void copy(final byte[] from, final byte[] to, final int offset) {\n-        if (from != null) {\n-            System.arraycopy(from, 0, to, offset, from.length);\n+    static void copy(final byte[] array, final byte[] array2, final int n) {\n+        if (array != null) {\n+            System.arraycopy(array, 0, array2, n, array.length);\n         }\n     }\n     \n-    private static Date dosToJavaDate(final long dosTime) {\n-        final Calendar cal = Calendar.getInstance();\n-        cal.set(1, (int)(dosTime >> 25 & 0x7FL) + 1980);\n-        cal.set(2, (int)(dosTime >> 21 & 0xFL) - 1);\n-        cal.set(5, (int)(dosTime >> 16) & 0x1F);\n-        cal.set(11, (int)(dosTime >> 11) & 0x1F);\n-        cal.set(12, (int)(dosTime >> 5) & 0x3F);\n-        cal.set(13, (int)(dosTime << 1) & 0x3E);\n-        cal.set(14, 0);\n-        return cal.getTime();\n+    private static Date dosToJavaDate(final long n) {\n+        final Calendar instance = Calendar.getInstance();\n+        instance.set(1, (int)(n >> 25 & 0x7FL) + 1980);\n+        instance.set(2, (int)(n >> 21 & 0xFL) - 1);\n+        instance.set(5, (int)(n >> 16) & 0x1F);\n+        instance.set(11, (int)(n >> 11) & 0x1F);\n+        instance.set(12, (int)(n >> 5) & 0x3F);\n+        instance.set(13, (int)(n << 1) & 0x3E);\n+        instance.set(14, 0);\n+        return instance.getTime();\n     }\n     \n-    public static long dosToJavaTime(final long dosTime) {\n-        return dosToJavaDate(dosTime).getTime();\n+    public static long dosToJavaTime(final long n) {\n+        return dosToJavaDate(n).getTime();\n     }\n     \n-    public static Date fromDosTime(final ZipLong zipDosTime) {\n-        final long dosTime = zipDosTime.getValue();\n-        return dosToJavaDate(dosTime);\n+    public static Date fromDosTime(final ZipLong zipLong) {\n+        return dosToJavaDate(zipLong.getValue());\n     }\n     \n-    private static String getUnicodeStringIfOriginalMatches(final AbstractUnicodeExtraField f, final byte[] orig) {\n-        if (f != null) {\n+    private static String getUnicodeStringIfOriginalMatches(final AbstractUnicodeExtraField abstractUnicodeExtraField, final byte[] b) {\n+        if (abstractUnicodeExtraField != null) {\n             final CRC32 crc32 = new CRC32();\n-            crc32.update(orig);\n-            final long origCRC32 = crc32.getValue();\n-            if (origCRC32 == f.getNameCRC32()) {\n+            crc32.update(b);\n+            if (crc32.getValue() == abstractUnicodeExtraField.getNameCRC32()) {\n                 try {\n-                    return ZipEncodingHelper.UTF8_ZIP_ENCODING.decode(f.getUnicodeName());\n+                    return ZipEncodingHelper.UTF8_ZIP_ENCODING.decode(abstractUnicodeExtraField.getUnicodeName());\n                 }\n                 catch (final IOException ex) {}\n             }\n         }\n         return null;\n     }\n     \n-    public static boolean isDosTime(final long time) {\n-        return time <= 4036608000000L && javaToDosTime(time) != 2162688L;\n+    public static boolean isDosTime(final long n) {\n+        return n <= 4036608000000L && javaToDosTime(n) != 2162688L;\n     }\n     \n-    private static LocalDateTime javaEpochToLocalDateTime(final long time) {\n-        final Instant instant = Instant.ofEpochMilli(time);\n-        return LocalDateTime.ofInstant(instant, ZoneId.systemDefault());\n+    private static LocalDateTime javaEpochToLocalDateTime(final long epochMilli) {\n+        return LocalDateTime.ofInstant(Instant.ofEpochMilli(epochMilli), ZoneId.systemDefault());\n     }\n     \n-    private static long javaToDosTime(final long t) {\n-        final LocalDateTime ldt = javaEpochToLocalDateTime(t);\n-        if (ldt.getYear() < 1980) {\n+    private static long javaToDosTime(final long n) {\n+        final LocalDateTime javaEpochToLocalDateTime = javaEpochToLocalDateTime(n);\n+        if (javaEpochToLocalDateTime.getYear() < 1980) {\n             return 2162688L;\n         }\n-        return (long)(ldt.getYear() - 1980 << 25 | ldt.getMonthValue() << 21 | ldt.getDayOfMonth() << 16 | ldt.getHour() << 11 | ldt.getMinute() << 5 | ldt.getSecond() >> 1) & 0xFFFFFFFFL;\n+        return (long)(javaEpochToLocalDateTime.getYear() - 1980 << 25 | javaEpochToLocalDateTime.getMonthValue() << 21 | javaEpochToLocalDateTime.getDayOfMonth() << 16 | javaEpochToLocalDateTime.getHour() << 11 | javaEpochToLocalDateTime.getMinute() << 5 | javaEpochToLocalDateTime.getSecond() >> 1) & 0xFFFFFFFFL;\n     }\n     \n-    static BigInteger longToBig(long l) {\n-        if (l < -2147483648L) {\n-            throw new IllegalArgumentException(\"Negative longs < -2^31 not permitted: [\" + l + \"]\");\n+    static BigInteger longToBig(long adjustToLong) {\n+        if (adjustToLong < -2147483648L) {\n+            throw new IllegalArgumentException(\"Negative longs < -2^31 not permitted: [\" + adjustToLong + \"]\");\n         }\n-        if (l < 0L && l >= -2147483648L) {\n-            l = adjustToLong((int)l);\n+        if (adjustToLong < 0L && adjustToLong >= -2147483648L) {\n+            adjustToLong = adjustToLong((int)adjustToLong);\n         }\n-        return BigInteger.valueOf(l);\n+        return BigInteger.valueOf(adjustToLong);\n     }\n     \n     public static byte[] reverse(final byte[] array) {\n-        final int z = array.length - 1;\n+        final int n = array.length - 1;\n         for (int i = 0; i < array.length / 2; ++i) {\n-            final byte x = array[i];\n-            array[i] = array[z - i];\n-            array[z - i] = x;\n+            final byte b = array[i];\n+            array[i] = array[n - i];\n+            array[n - i] = b;\n         }\n         return array;\n     }\n     \n-    static void setNameAndCommentFromExtraFields(final ZipArchiveEntry ze, final byte[] originalNameBytes, final byte[] commentBytes) {\n-        final ZipExtraField nameCandidate = ze.getExtraField(UnicodePathExtraField.UPATH_ID);\n-        final UnicodePathExtraField name = (nameCandidate instanceof UnicodePathExtraField) ? ((UnicodePathExtraField)nameCandidate) : null;\n-        final String newName = getUnicodeStringIfOriginalMatches((AbstractUnicodeExtraField)name, originalNameBytes);\n-        if (newName != null) {\n-            ze.setName(newName);\n-            ze.setNameSource(ZipArchiveEntry.NameSource.UNICODE_EXTRA_FIELD);\n-        }\n-        if (commentBytes != null && commentBytes.length > 0) {\n-            final ZipExtraField cmtCandidate = ze.getExtraField(UnicodeCommentExtraField.UCOM_ID);\n-            final UnicodeCommentExtraField cmt = (cmtCandidate instanceof UnicodeCommentExtraField) ? ((UnicodeCommentExtraField)cmtCandidate) : null;\n-            final String newComment = getUnicodeStringIfOriginalMatches((AbstractUnicodeExtraField)cmt, commentBytes);\n-            if (newComment != null) {\n-                ze.setComment(newComment);\n-                ze.setCommentSource(ZipArchiveEntry.CommentSource.UNICODE_EXTRA_FIELD);\n+    static void setNameAndCommentFromExtraFields(final ZipArchiveEntry zipArchiveEntry, final byte[] array, final byte[] array2) {\n+        final ZipExtraField extraField = zipArchiveEntry.getExtraField(UnicodePathExtraField.UPATH_ID);\n+        final String unicodeStringIfOriginalMatches = getUnicodeStringIfOriginalMatches((extraField instanceof UnicodePathExtraField) ? ((UnicodePathExtraField)extraField) : null, array);\n+        if (unicodeStringIfOriginalMatches != null) {\n+            zipArchiveEntry.setName(unicodeStringIfOriginalMatches);\n+            zipArchiveEntry.setNameSource(ZipArchiveEntry.NameSource.UNICODE_EXTRA_FIELD);\n+        }\n+        if (array2 != null && array2.length > 0) {\n+            final ZipExtraField extraField2 = zipArchiveEntry.getExtraField(UnicodeCommentExtraField.UCOM_ID);\n+            final String unicodeStringIfOriginalMatches2 = getUnicodeStringIfOriginalMatches((extraField2 instanceof UnicodeCommentExtraField) ? ((UnicodeCommentExtraField)extraField2) : null, array2);\n+            if (unicodeStringIfOriginalMatches2 != null) {\n+                zipArchiveEntry.setComment(unicodeStringIfOriginalMatches2);\n+                zipArchiveEntry.setCommentSource(ZipArchiveEntry.CommentSource.UNICODE_EXTRA_FIELD);\n             }\n         }\n     }\n     \n     public static int signedByteToUnsignedInt(final byte b) {\n         if (b >= 0) {\n             return b;\n         }\n         return 256 + b;\n     }\n     \n-    private static boolean supportsEncryptionOf(final ZipArchiveEntry entry) {\n-        return !entry.getGeneralPurposeBit().usesEncryption();\n+    private static boolean supportsEncryptionOf(final ZipArchiveEntry zipArchiveEntry) {\n+        return !zipArchiveEntry.getGeneralPurposeBit().usesEncryption();\n     }\n     \n-    private static boolean supportsMethodOf(final ZipArchiveEntry entry) {\n-        return entry.getMethod() == 0 || entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || entry.getMethod() == ZipMethod.IMPLODING.getCode() || entry.getMethod() == 8 || entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || entry.getMethod() == ZipMethod.BZIP2.getCode();\n+    private static boolean supportsMethodOf(final ZipArchiveEntry zipArchiveEntry) {\n+        return zipArchiveEntry.getMethod() == 0 || zipArchiveEntry.getMethod() == ZipMethod.UNSHRINKING.getCode() || zipArchiveEntry.getMethod() == ZipMethod.IMPLODING.getCode() || zipArchiveEntry.getMethod() == 8 || zipArchiveEntry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || zipArchiveEntry.getMethod() == ZipMethod.BZIP2.getCode();\n     }\n     \n-    public static ZipLong toDosTime(final Date time) {\n-        return new ZipLong(toDosTime(time.getTime()));\n+    public static ZipLong toDosTime(final Date date) {\n+        return new ZipLong(toDosTime(date.getTime()));\n     }\n     \n-    public static byte[] toDosTime(final long t) {\n-        final byte[] result = new byte[4];\n-        toDosTime(t, result, 0);\n-        return result;\n+    public static byte[] toDosTime(final long n) {\n+        final byte[] array = new byte[4];\n+        toDosTime(n, array, 0);\n+        return array;\n     }\n     \n-    public static void toDosTime(final long t, final byte[] buf, final int offset) {\n-        ZipLong.putLong(javaToDosTime(t), buf, offset);\n+    public static void toDosTime(final long n, final byte[] array, final int n2) {\n+        ZipLong.putLong(javaToDosTime(n), array, n2);\n     }\n     \n     public static byte unsignedIntToSignedByte(final int i) {\n         if (i > 255 || i < 0) {\n             throw new IllegalArgumentException(\"Can only convert non-negative integers between [0,255] to byte: [\" + i + \"]\");\n         }\n         if (i < 128) {\n"}]}
