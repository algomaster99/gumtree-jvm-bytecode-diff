{"diffoscope-json-version": 1, "source1": "first/AbstractClassCouplingCheck.class", "source2": "second/AbstractClassCouplingCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -36,153 +36,147 @@\n     private final Map<String, String> importedClassPackages;\n     private final Deque<AbstractClassCouplingCheck.ClassContext> classesContexts;\n     private Set<String> excludedClasses;\n     private Set<String> excludedPackages;\n     private int max;\n     private String packageName;\n     \n-    protected AbstractClassCouplingCheck(final int defaultMax) {\n+    protected AbstractClassCouplingCheck(final int max) {\n         this.excludeClassesRegexps = new ArrayList<Pattern>();\n         this.importedClassPackages = new HashMap<String, String>();\n         this.classesContexts = new ArrayDeque<AbstractClassCouplingCheck.ClassContext>();\n         this.excludedClasses = AbstractClassCouplingCheck.DEFAULT_EXCLUDED_CLASSES;\n         this.excludedPackages = AbstractClassCouplingCheck.DEFAULT_EXCLUDED_PACKAGES;\n-        this.max = defaultMax;\n+        this.max = max;\n         this.excludeClassesRegexps.add(CommonUtil.createPattern(\"^$\"));\n     }\n     \n     protected abstract String getLogMessageId();\n     \n     public final int[] getDefaultTokens() {\n         return this.getRequiredTokens();\n     }\n     \n     public final void setMax(final int max) {\n         this.max = max;\n     }\n     \n-    public final void setExcludedClasses(final String... excludedClasses) {\n-        this.excludedClasses = Set.of(excludedClasses);\n+    public final void setExcludedClasses(final String... elements) {\n+        this.excludedClasses = Set.of(elements);\n     }\n     \n-    public void setExcludeClassesRegexps(final String... from) {\n-        final Stream<Object> map = Arrays.stream(from).map((Function<? super String, ?>)CommonUtil::createPattern);\n+    public void setExcludeClassesRegexps(final String... array) {\n+        final Stream<Object> map = Arrays.stream(array).map((Function<? super String, ?>)CommonUtil::createPattern);\n         final List<Pattern> excludeClassesRegexps = this.excludeClassesRegexps;\n         Objects.requireNonNull(excludeClassesRegexps);\n         map.forEach(excludeClassesRegexps::add);\n     }\n     \n-    public final void setExcludedPackages(final String... excludedPackages) {\n-        final List<String> invalidIdentifiers = (List<String>)Arrays.stream(excludedPackages).filter(Predicate.not((Predicate<? super String>)CommonUtil::isName)).collect((Collector<? super String, ?, List<String>>)Collectors.toList());\n-        if (!invalidIdentifiers.isEmpty()) {\n-            throw new IllegalArgumentException(\"the following values are not valid identifiers: \" + invalidIdentifiers);\n+    public final void setExcludedPackages(final String... array) {\n+        final List<? super String> list = (List<? super String>)Arrays.stream(array).filter(Predicate.not((Predicate<? super String>)CommonUtil::isName)).collect((Collector<? super String, ?, List<? super String>>)Collectors.toList());\n+        if (!list.isEmpty()) {\n+            throw new IllegalArgumentException(\"the following values are not valid identifiers: \" + list);\n         }\n-        this.excludedPackages = Set.of(excludedPackages);\n+        this.excludedPackages = Set.of(array);\n     }\n     \n-    public final void beginTree(final DetailAST ast) {\n+    public final void beginTree(final DetailAST detailAST) {\n         this.importedClassPackages.clear();\n         this.classesContexts.clear();\n         this.classesContexts.push(new AbstractClassCouplingCheck.ClassContext(this, \"\", (DetailAST)null));\n         this.packageName = \"\";\n     }\n     \n-    public void visitToken(final DetailAST ast) {\n-        switch (ast.getType()) {\n+    public void visitToken(final DetailAST detailAST) {\n+        switch (detailAST.getType()) {\n             case 16: {\n-                this.visitPackageDef(ast);\n+                this.visitPackageDef(detailAST);\n                 break;\n             }\n             case 30: {\n-                this.registerImport(ast);\n+                this.registerImport(detailAST);\n                 break;\n             }\n             case 14:\n             case 15:\n             case 154:\n             case 157:\n             case 199: {\n-                this.visitClassDef(ast);\n+                this.visitClassDef(detailAST);\n                 break;\n             }\n             case 13:\n             case 18:\n             case 19: {\n-                this.visitType(ast);\n+                this.visitType(detailAST);\n                 break;\n             }\n             case 136: {\n-                this.visitLiteralNew(ast);\n+                this.visitLiteralNew(detailAST);\n                 break;\n             }\n             case 81: {\n-                this.visitLiteralThrows(ast);\n+                this.visitLiteralThrows(detailAST);\n                 break;\n             }\n             case 159: {\n-                this.visitAnnotationType(ast);\n+                this.visitAnnotationType(detailAST);\n                 break;\n             }\n             default: {\n-                throw new IllegalArgumentException(\"Unknown type: \" + ast);\n+                throw new IllegalArgumentException(\"Unknown type: \" + detailAST);\n             }\n         }\n     }\n     \n-    public void leaveToken(final DetailAST ast) {\n-        if (TokenUtil.isTypeDeclaration(ast.getType())) {\n+    public void leaveToken(final DetailAST detailAST) {\n+        if (TokenUtil.isTypeDeclaration(detailAST.getType())) {\n             this.leaveClassDef();\n         }\n     }\n     \n-    private void visitPackageDef(final DetailAST pkg) {\n-        final FullIdent ident = FullIdent.createFullIdent(pkg.getLastChild().getPreviousSibling());\n-        this.packageName = ident.getText();\n+    private void visitPackageDef(final DetailAST detailAST) {\n+        this.packageName = FullIdent.createFullIdent(detailAST.getLastChild().getPreviousSibling()).getText();\n     }\n     \n-    private void visitClassDef(final DetailAST classDef) {\n-        final String className = classDef.findFirstToken(58).getText();\n-        this.createNewClassContext(className, classDef);\n+    private void visitClassDef(final DetailAST detailAST) {\n+        this.createNewClassContext(detailAST.findFirstToken(58).getText(), detailAST);\n     }\n     \n     private void leaveClassDef() {\n         this.checkCurrentClassAndRestorePrevious();\n     }\n     \n-    private void registerImport(final DetailAST imp) {\n-        final FullIdent ident = FullIdent.createFullIdent(imp.getLastChild().getPreviousSibling());\n-        final String fullName = ident.getText();\n-        final int lastDot = fullName.lastIndexOf(46);\n-        this.importedClassPackages.put(fullName.substring(lastDot + 1), fullName);\n+    private void registerImport(final DetailAST detailAST) {\n+        final String text = FullIdent.createFullIdent(detailAST.getLastChild().getPreviousSibling()).getText();\n+        this.importedClassPackages.put(text.substring(text.lastIndexOf(46) + 1), text);\n     }\n     \n-    private void createNewClassContext(final String className, final DetailAST ast) {\n-        this.classesContexts.push(new AbstractClassCouplingCheck.ClassContext(this, className, ast));\n+    private void createNewClassContext(final String s, final DetailAST detailAST) {\n+        this.classesContexts.push(new AbstractClassCouplingCheck.ClassContext(this, s, detailAST));\n     }\n     \n     private void checkCurrentClassAndRestorePrevious() {\n         ((AbstractClassCouplingCheck.ClassContext)this.classesContexts.pop()).checkCoupling();\n     }\n     \n-    private void visitType(final DetailAST ast) {\n-        ((AbstractClassCouplingCheck.ClassContext)this.classesContexts.peek()).visitType(ast);\n+    private void visitType(final DetailAST detailAST) {\n+        ((AbstractClassCouplingCheck.ClassContext)this.classesContexts.peek()).visitType(detailAST);\n     }\n     \n-    private void visitLiteralNew(final DetailAST ast) {\n-        ((AbstractClassCouplingCheck.ClassContext)this.classesContexts.peek()).visitLiteralNew(ast);\n+    private void visitLiteralNew(final DetailAST detailAST) {\n+        ((AbstractClassCouplingCheck.ClassContext)this.classesContexts.peek()).visitLiteralNew(detailAST);\n     }\n     \n-    private void visitLiteralThrows(final DetailAST ast) {\n-        ((AbstractClassCouplingCheck.ClassContext)this.classesContexts.peek()).visitLiteralThrows(ast);\n+    private void visitLiteralThrows(final DetailAST detailAST) {\n+        ((AbstractClassCouplingCheck.ClassContext)this.classesContexts.peek()).visitLiteralThrows(detailAST);\n     }\n     \n-    private void visitAnnotationType(final DetailAST annotationAST) {\n-        final DetailAST children = annotationAST.getFirstChild();\n-        final DetailAST type = children.getNextSibling();\n-        ((AbstractClassCouplingCheck.ClassContext)this.classesContexts.peek()).addReferencedClassName(type.getText());\n+    private void visitAnnotationType(final DetailAST detailAST) {\n+        ((AbstractClassCouplingCheck.ClassContext)this.classesContexts.peek()).addReferencedClassName(detailAST.getFirstChild().getNextSibling().getText());\n     }\n     \n     static {\n         DEFAULT_EXCLUDED_CLASSES = Set.of(new String[] { \"var\", \"boolean\", \"byte\", \"char\", \"double\", \"float\", \"int\", \"long\", \"short\", \"void\", \"Boolean\", \"Byte\", \"Character\", \"Double\", \"Float\", \"Integer\", \"Long\", \"Short\", \"Void\", \"Object\", \"Class\", \"String\", \"StringBuffer\", \"StringBuilder\", \"ArrayIndexOutOfBoundsException\", \"Exception\", \"RuntimeException\", \"IllegalArgumentException\", \"IllegalStateException\", \"IndexOutOfBoundsException\", \"NullPointerException\", \"Throwable\", \"SecurityException\", \"UnsupportedOperationException\", \"List\", \"ArrayList\", \"Deque\", \"Queue\", \"LinkedList\", \"Set\", \"HashSet\", \"SortedSet\", \"TreeSet\", \"Map\", \"HashMap\", \"SortedMap\", \"TreeMap\", \"Override\", \"Deprecated\", \"SafeVarargs\", \"SuppressWarnings\", \"FunctionalInterface\", \"Collection\", \"EnumSet\", \"LinkedHashMap\", \"LinkedHashSet\", \"Optional\", \"OptionalDouble\", \"OptionalInt\", \"OptionalLong\", \"DoubleStream\", \"IntStream\", \"LongStream\", \"Stream\" });\n         DEFAULT_EXCLUDED_PACKAGES = Collections.emptySet();\n         BRACKET_PATTERN = Pattern.compile(\"\\\\[[^]]*]\");\n     }\n"}]}
