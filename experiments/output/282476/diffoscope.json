{"diffoscope-json-version": 1, "source1": "first/ReaderInputStream.class", "source2": "second/ReaderInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -18,96 +18,96 @@\n     private final Reader reader;\n     private final CharsetEncoder encoder;\n     private final CharBuffer encoderIn;\n     private final ByteBuffer encoderOut;\n     private CoderResult lastCoderResult;\n     private boolean endOfInput;\n     \n-    public ReaderInputStream(final Reader reader, final CharsetEncoder encoder) {\n-        this(reader, encoder, 1024);\n+    public ReaderInputStream(final Reader reader, final CharsetEncoder charsetEncoder) {\n+        this(reader, charsetEncoder, 1024);\n     }\n     \n-    public ReaderInputStream(final Reader reader, final CharsetEncoder encoder, final int bufferSize) {\n+    public ReaderInputStream(final Reader reader, final CharsetEncoder encoder, final int capacity) {\n         this.reader = reader;\n         this.encoder = encoder;\n-        (this.encoderIn = CharBuffer.allocate(bufferSize)).flip();\n+        (this.encoderIn = CharBuffer.allocate(capacity)).flip();\n         (this.encoderOut = ByteBuffer.allocate(128)).flip();\n     }\n     \n-    public ReaderInputStream(final Reader reader, final Charset charset, final int bufferSize) {\n-        this(reader, charset.newEncoder().onMalformedInput(CodingErrorAction.REPLACE).onUnmappableCharacter(CodingErrorAction.REPLACE), bufferSize);\n+    public ReaderInputStream(final Reader reader, final Charset charset, final int n) {\n+        this(reader, charset.newEncoder().onMalformedInput(CodingErrorAction.REPLACE).onUnmappableCharacter(CodingErrorAction.REPLACE), n);\n     }\n     \n     public ReaderInputStream(final Reader reader, final Charset charset) {\n         this(reader, charset, 1024);\n     }\n     \n-    public ReaderInputStream(final Reader reader, final String charsetName, final int bufferSize) {\n-        this(reader, Charset.forName(charsetName), bufferSize);\n+    public ReaderInputStream(final Reader reader, final String charsetName, final int n) {\n+        this(reader, Charset.forName(charsetName), n);\n     }\n     \n-    public ReaderInputStream(final Reader reader, final String charsetName) {\n-        this(reader, charsetName, 1024);\n+    public ReaderInputStream(final Reader reader, final String s) {\n+        this(reader, s, 1024);\n     }\n     \n     @Deprecated\n     public ReaderInputStream(final Reader reader) {\n         this(reader, Charset.defaultCharset());\n     }\n     \n     private void fillBuffer() throws IOException {\n         if (!this.endOfInput && (this.lastCoderResult == null || this.lastCoderResult.isUnderflow())) {\n             this.encoderIn.compact();\n             final int position = this.encoderIn.position();\n-            final int c = this.reader.read(this.encoderIn.array(), position, this.encoderIn.remaining());\n-            if (c == -1) {\n+            final int read = this.reader.read(this.encoderIn.array(), position, this.encoderIn.remaining());\n+            if (read == -1) {\n                 this.endOfInput = true;\n             }\n             else {\n-                this.encoderIn.position(position + c);\n+                this.encoderIn.position(position + read);\n             }\n             this.encoderIn.flip();\n         }\n         this.encoderOut.compact();\n         this.lastCoderResult = this.encoder.encode(this.encoderIn, this.encoderOut, this.endOfInput);\n         this.encoderOut.flip();\n     }\n     \n     @Override\n-    public int read(final byte[] array, int off, int len) throws IOException {\n+    public int read(final byte[] array, int n, int i) throws IOException {\n         Objects.requireNonNull(array, \"array\");\n-        if (len < 0 || off < 0 || off + len > array.length) {\n-            throw new IndexOutOfBoundsException(\"Array Size=\" + array.length + \", offset=\" + off + \", length=\" + len);\n+        if (i < 0 || n < 0 || n + i > array.length) {\n+            throw new IndexOutOfBoundsException(\"Array Size=\" + array.length + \", offset=\" + n + \", length=\" + i);\n         }\n-        int read = 0;\n-        if (len == 0) {\n+        int n2 = 0;\n+        if (i == 0) {\n             return 0;\n         }\n-        while (len > 0) {\n+        while (i > 0) {\n             if (this.encoderOut.hasRemaining()) {\n-                final int c = Math.min(this.encoderOut.remaining(), len);\n-                this.encoderOut.get(array, off, c);\n-                off += c;\n-                len -= c;\n-                read += c;\n+                final int min = Math.min(this.encoderOut.remaining(), i);\n+                this.encoderOut.get(array, n, min);\n+                n += min;\n+                i -= min;\n+                n2 += min;\n             }\n             else {\n                 this.fillBuffer();\n                 if (this.endOfInput && !this.encoderOut.hasRemaining()) {\n                     break;\n                 }\n                 continue;\n             }\n         }\n-        return (read == 0 && this.endOfInput) ? -1 : read;\n+        return (n2 == 0 && this.endOfInput) ? -1 : n2;\n     }\n     \n     @Override\n-    public int read(final byte[] b) throws IOException {\n-        return this.read(b, 0, b.length);\n+    public int read(final byte[] array) throws IOException {\n+        return this.read(array, 0, array.length);\n     }\n     \n     @Override\n     public int read() throws IOException {\n         while (!this.encoderOut.hasRemaining()) {\n             this.fillBuffer();\n             if (this.endOfInput && !this.encoderOut.hasRemaining()) {\n"}]}
