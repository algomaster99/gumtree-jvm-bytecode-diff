{"diffoscope-json-version": 1, "source1": "first/JNDIConfiguration.class", "source2": "second/JNDIConfiguration.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -25,189 +25,185 @@\n     private Context baseContext;\n     private final Set<String> clearedProperties;\n     \n     public JNDIConfiguration() throws NamingException {\n         this((String)null);\n     }\n     \n-    public JNDIConfiguration(final String prefix) throws NamingException {\n-        this(new InitialContext(), prefix);\n+    public JNDIConfiguration(final String s) throws NamingException {\n+        this(new InitialContext(), s);\n     }\n     \n     public JNDIConfiguration(final Context context) {\n         this(context, null);\n     }\n     \n     public JNDIConfiguration(final Context context, final String prefix) {\n         this.clearedProperties = new HashSet<String>();\n         this.context = context;\n         this.prefix = prefix;\n         this.initLogger(new ConfigurationLogger((Class)JNDIConfiguration.class));\n         this.addErrorLogListener();\n     }\n     \n-    private void recursiveGetKeys(final Set<String> keys, final Context context, final String prefix, final Set<Context> processedCtx) throws NamingException {\n-        processedCtx.add(context);\n-        NamingEnumeration<NameClassPair> elements = null;\n-        try {\n-            elements = context.list(\"\");\n-            while (elements.hasMore()) {\n-                final NameClassPair nameClassPair = (NameClassPair)elements.next();\n-                final String name = nameClassPair.getName();\n-                final Object object = context.lookup(name);\n-                final StringBuilder keyBuilder = new StringBuilder();\n-                keyBuilder.append(prefix);\n-                if (keyBuilder.length() > 0) {\n-                    keyBuilder.append(\".\");\n+    private void recursiveGetKeys(final Set<String> set, final Context context, final String str, final Set<Context> set2) throws NamingException {\n+        set2.add(context);\n+        NamingEnumeration<NameClassPair> list = null;\n+        try {\n+            list = context.list(\"\");\n+            while (list.hasMore()) {\n+                final String name = ((NameClassPair)list.next()).getName();\n+                final Object lookup = context.lookup(name);\n+                final StringBuilder sb = new StringBuilder();\n+                sb.append(str);\n+                if (sb.length() > 0) {\n+                    sb.append(\".\");\n                 }\n-                keyBuilder.append(name);\n-                if (object instanceof Context) {\n-                    final Context subcontext = (Context)object;\n-                    if (processedCtx.contains(subcontext)) {\n+                sb.append(name);\n+                if (lookup instanceof Context) {\n+                    final Context context2 = (Context)lookup;\n+                    if (set2.contains(context2)) {\n                         continue;\n                     }\n-                    this.recursiveGetKeys(keys, subcontext, keyBuilder.toString(), processedCtx);\n+                    this.recursiveGetKeys(set, context2, sb.toString(), set2);\n                 }\n                 else {\n-                    keys.add(keyBuilder.toString());\n+                    set.add(sb.toString());\n                 }\n             }\n         }\n         finally {\n-            if (elements != null) {\n-                elements.close();\n+            if (list != null) {\n+                list.close();\n             }\n         }\n     }\n     \n     protected Iterator<String> getKeysInternal() {\n         return this.getKeysInternal(\"\");\n     }\n     \n-    protected Iterator<String> getKeysInternal(final String prefix) {\n-        final String[] splitPath = StringUtils.split(prefix, \".\");\n-        final List<String> path = Arrays.asList(splitPath);\n+    protected Iterator<String> getKeysInternal(final String s) {\n+        final List<String> list = Arrays.asList(StringUtils.split(s, \".\"));\n         try {\n-            final Context context = this.getContext(path, this.getBaseContext());\n-            final Set<String> keys = new HashSet<String>();\n+            final Context context = this.getContext(list, this.getBaseContext());\n+            final HashSet set = new HashSet();\n             if (context != null) {\n-                this.recursiveGetKeys(keys, context, prefix, new HashSet<Context>());\n+                this.recursiveGetKeys(set, context, s, new HashSet<Context>());\n             }\n-            else if (this.containsKey(prefix)) {\n-                keys.add(prefix);\n+            else if (this.containsKey(s)) {\n+                set.add(s);\n             }\n-            return keys.iterator();\n+            return set.iterator();\n         }\n-        catch (final NameNotFoundException e) {\n+        catch (final NameNotFoundException ex) {\n             return new ArrayList<String>().iterator();\n         }\n-        catch (final NamingException e2) {\n-            this.fireError(ConfigurationErrorEvent.READ, ConfigurationErrorEvent.READ, (String)null, (Object)null, (Throwable)e2);\n+        catch (final NamingException ex2) {\n+            this.fireError(ConfigurationErrorEvent.READ, ConfigurationErrorEvent.READ, (String)null, (Object)null, (Throwable)ex2);\n             return new ArrayList<String>().iterator();\n         }\n     }\n     \n-    private Context getContext(final List<String> path, final Context context) throws NamingException {\n-        if (path == null || path.isEmpty()) {\n+    private Context getContext(final List<String> list, final Context context) throws NamingException {\n+        if (list == null || list.isEmpty()) {\n             return context;\n         }\n-        final String key = (String)path.get(0);\n-        NamingEnumeration<NameClassPair> elements = null;\n+        final String anObject = (String)list.get(0);\n+        NamingEnumeration<NameClassPair> list2 = null;\n         try {\n-            elements = context.list(\"\");\n-            while (elements.hasMore()) {\n-                final NameClassPair nameClassPair = (NameClassPair)elements.next();\n-                final String name = nameClassPair.getName();\n-                final Object object = context.lookup(name);\n-                if (object instanceof Context && name.equals(key)) {\n-                    final Context subcontext = (Context)object;\n-                    return this.getContext(path.subList(1, path.size()), subcontext);\n+            list2 = context.list(\"\");\n+            while (list2.hasMore()) {\n+                final String name = ((NameClassPair)list2.next()).getName();\n+                final Object lookup = context.lookup(name);\n+                if (lookup instanceof Context && name.equals(anObject)) {\n+                    return this.getContext(list.subList(1, list.size()), (Context)lookup);\n                 }\n             }\n         }\n         finally {\n-            if (elements != null) {\n-                elements.close();\n+            if (list2 != null) {\n+                list2.close();\n             }\n         }\n         return null;\n     }\n     \n     protected boolean isEmptyInternal() {\n         try {\n-            NamingEnumeration<NameClassPair> enumeration = null;\n+            NamingEnumeration<NameClassPair> list = null;\n             try {\n-                enumeration = this.getBaseContext().list(\"\");\n-                return !enumeration.hasMore();\n+                list = this.getBaseContext().list(\"\");\n+                return !list.hasMore();\n             }\n             finally {\n-                if (enumeration != null) {\n-                    enumeration.close();\n+                if (list != null) {\n+                    list.close();\n                 }\n             }\n         }\n-        catch (final NamingException e) {\n-            this.fireError(ConfigurationErrorEvent.READ, ConfigurationErrorEvent.READ, (String)null, (Object)null, (Throwable)e);\n+        catch (final NamingException ex) {\n+            this.fireError(ConfigurationErrorEvent.READ, ConfigurationErrorEvent.READ, (String)null, (Object)null, (Throwable)ex);\n             return true;\n         }\n     }\n     \n-    protected void setPropertyInternal(final String key, final Object value) {\n+    protected void setPropertyInternal(final String s, final Object o) {\n         throw new UnsupportedOperationException(\"This operation is not supported\");\n     }\n     \n-    protected void clearPropertyDirect(final String key) {\n-        this.clearedProperties.add(key);\n+    protected void clearPropertyDirect(final String s) {\n+        this.clearedProperties.add(s);\n     }\n     \n-    protected boolean containsKeyInternal(String key) {\n-        if (this.clearedProperties.contains(key)) {\n+    protected boolean containsKeyInternal(String replace) {\n+        if (this.clearedProperties.contains(replace)) {\n             return false;\n         }\n-        key = key.replace('.', '/');\n+        replace = replace.replace('.', '/');\n         try {\n-            this.getBaseContext().lookup(key);\n+            this.getBaseContext().lookup(replace);\n             return true;\n         }\n-        catch (final NameNotFoundException e) {\n+        catch (final NameNotFoundException ex) {\n             return false;\n         }\n-        catch (final NamingException e2) {\n-            this.fireError(ConfigurationErrorEvent.READ, ConfigurationErrorEvent.READ, key, (Object)null, (Throwable)e2);\n+        catch (final NamingException ex2) {\n+            this.fireError(ConfigurationErrorEvent.READ, ConfigurationErrorEvent.READ, replace, (Object)null, (Throwable)ex2);\n             return false;\n         }\n     }\n     \n     public String getPrefix() {\n         return this.prefix;\n     }\n     \n     public void setPrefix(final String prefix) {\n         this.prefix = prefix;\n         this.baseContext = null;\n     }\n     \n-    protected Object getPropertyInternal(String key) {\n-        if (this.clearedProperties.contains(key)) {\n+    protected Object getPropertyInternal(String replace) {\n+        if (this.clearedProperties.contains(replace)) {\n             return null;\n         }\n         try {\n-            key = key.replace('.', '/');\n-            return this.getBaseContext().lookup(key);\n+            replace = replace.replace('.', '/');\n+            return this.getBaseContext().lookup(replace);\n         }\n-        catch (final NameNotFoundException | NotContextException nctxex) {\n+        catch (final NameNotFoundException | NotContextException ex) {\n             return null;\n         }\n-        catch (final NamingException e) {\n-            this.fireError(ConfigurationErrorEvent.READ, ConfigurationErrorEvent.READ, key, (Object)null, (Throwable)e);\n+        catch (final NamingException ex2) {\n+            this.fireError(ConfigurationErrorEvent.READ, ConfigurationErrorEvent.READ, replace, (Object)null, (Throwable)ex2);\n             return null;\n         }\n     }\n     \n-    protected void addPropertyDirect(final String key, final Object obj) {\n+    protected void addPropertyDirect(final String s, final Object o) {\n         throw new UnsupportedOperationException(\"This operation is not supported\");\n     }\n     \n     public Context getBaseContext() throws NamingException {\n         if (this.baseContext == null) {\n             this.baseContext = (Context)this.getContext().lookup((this.prefix == null) ? \"\" : this.prefix);\n         }\n"}]}
