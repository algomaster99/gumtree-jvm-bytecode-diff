{"diffoscope-json-version": 1, "source1": "first/ZipSplitReadOnlySeekableByteChannel.class", "source2": "second/ZipSplitReadOnlySeekableByteChannel.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -25,105 +25,104 @@\n \n public class ZipSplitReadOnlySeekableByteChannel extends MultiReadOnlySeekableByteChannel\n {\n     private static final Path[] EMPTY_PATH_ARRAY;\n     private static final int ZIP_SPLIT_SIGNATURE_LENGTH = 4;\n     private final ByteBuffer zipSplitSignatureByteBuffer;\n     \n-    public ZipSplitReadOnlySeekableByteChannel(final List<SeekableByteChannel> channels) throws IOException {\n-        super((List)channels);\n+    public ZipSplitReadOnlySeekableByteChannel(final List<SeekableByteChannel> list) throws IOException {\n+        super((List)list);\n         this.zipSplitSignatureByteBuffer = ByteBuffer.allocate(4);\n-        this.assertSplitSignature(channels);\n+        this.assertSplitSignature(list);\n     }\n     \n-    private void assertSplitSignature(final List<SeekableByteChannel> channels) throws IOException {\n-        final SeekableByteChannel channel = (SeekableByteChannel)channels.get(0);\n-        channel.position(0L);\n+    private void assertSplitSignature(final List<SeekableByteChannel> list) throws IOException {\n+        final SeekableByteChannel seekableByteChannel = (SeekableByteChannel)list.get(0);\n+        seekableByteChannel.position(0L);\n         this.zipSplitSignatureByteBuffer.rewind();\n-        channel.read(this.zipSplitSignatureByteBuffer);\n-        final ZipLong signature = new ZipLong(this.zipSplitSignatureByteBuffer.array());\n-        if (!signature.equals((Object)ZipLong.DD_SIG)) {\n-            channel.position(0L);\n+        seekableByteChannel.read(this.zipSplitSignatureByteBuffer);\n+        if (!new ZipLong(this.zipSplitSignatureByteBuffer.array()).equals((Object)ZipLong.DD_SIG)) {\n+            seekableByteChannel.position(0L);\n             throw new IOException(\"The first zip split segment does not begin with split zip file signature\");\n         }\n-        channel.position(0L);\n+        seekableByteChannel.position(0L);\n     }\n     \n-    public static SeekableByteChannel forOrderedSeekableByteChannels(final SeekableByteChannel... channels) throws IOException {\n-        if (((SeekableByteChannel[])Objects.requireNonNull(channels, \"channels must not be null\")).length == 1) {\n-            return channels[0];\n+    public static SeekableByteChannel forOrderedSeekableByteChannels(final SeekableByteChannel... array) throws IOException {\n+        if (((SeekableByteChannel[])Objects.requireNonNull(array, \"channels must not be null\")).length == 1) {\n+            return array[0];\n         }\n-        return (SeekableByteChannel)new ZipSplitReadOnlySeekableByteChannel(Arrays.asList(channels));\n+        return (SeekableByteChannel)new ZipSplitReadOnlySeekableByteChannel(Arrays.asList(array));\n     }\n     \n-    public static SeekableByteChannel forOrderedSeekableByteChannels(final SeekableByteChannel lastSegmentChannel, final Iterable<SeekableByteChannel> channels) throws IOException {\n-        Objects.requireNonNull(channels, \"channels\");\n-        Objects.requireNonNull(lastSegmentChannel, \"lastSegmentChannel\");\n-        final ArrayList obj;\n-        final List<SeekableByteChannel> channelsList = obj = new ArrayList();\n-        Objects.requireNonNull(obj);\n-        channels.forEach(obj::add);\n-        channelsList.add(lastSegmentChannel);\n-        return forOrderedSeekableByteChannels((SeekableByteChannel[])channelsList.toArray(new SeekableByteChannel[0]));\n+    public static SeekableByteChannel forOrderedSeekableByteChannels(final SeekableByteChannel obj, final Iterable<SeekableByteChannel> obj2) throws IOException {\n+        Objects.requireNonNull(obj2, \"channels\");\n+        Objects.requireNonNull(obj, \"lastSegmentChannel\");\n+        final ArrayList obj3;\n+        final ArrayList list = obj3 = new ArrayList();\n+        Objects.requireNonNull(obj3);\n+        obj2.forEach(obj3::add);\n+        list.add(obj);\n+        return forOrderedSeekableByteChannels((SeekableByteChannel[])list.toArray(new SeekableByteChannel[0]));\n     }\n     \n-    public static SeekableByteChannel buildFromLastSplitSegment(final File lastSegmentFile) throws IOException {\n-        return buildFromLastSplitSegment(lastSegmentFile.toPath());\n+    public static SeekableByteChannel buildFromLastSplitSegment(final File file) throws IOException {\n+        return buildFromLastSplitSegment(file.toPath());\n     }\n     \n-    public static SeekableByteChannel buildFromLastSplitSegment(final Path lastSegmentPath) throws IOException {\n-        final String extension = FileNameUtils.getExtension(lastSegmentPath);\n-        if (!extension.equalsIgnoreCase(\"zip\")) {\n+    public static SeekableByteChannel buildFromLastSplitSegment(final Path path) throws IOException {\n+        if (!FileNameUtils.getExtension(path).equalsIgnoreCase(\"zip\")) {\n             throw new IllegalArgumentException(\"The extension of last zip split segment should be .zip\");\n         }\n-        final Path parent = Objects.nonNull(lastSegmentPath.getParent()) ? lastSegmentPath.getParent() : lastSegmentPath.getFileSystem().getPath(\".\", new String[0]);\n-        final String fileBaseName = FileNameUtils.getBaseName(lastSegmentPath);\n-        final Pattern pattern = Pattern.compile(Pattern.quote(fileBaseName) + \".[zZ][0-9]+\");\n-        ArrayList<Path> splitZipSegments;\n-        try (final Stream<Path> walk = Files.walk(parent, 1, new FileVisitOption[0])) {\n-            splitZipSegments = walk.filter(x$0 -> Files.isRegularFile(x$0, new LinkOption[0])).filter(path -> pattern.matcher(path.getFileName().toString()).matches()).sorted((Comparator<? super Path>)new ZipSplitReadOnlySeekableByteChannel.ZipSplitSegmentComparator((ZipSplitReadOnlySeekableByteChannel.ZipSplitReadOnlySeekableByteChannel$1)null)).collect(Collectors.toCollection(ArrayList::new));\n+        final Path start = Objects.nonNull(path.getParent()) ? path.getParent() : path.getFileSystem().getPath(\".\", new String[0]);\n+        Pattern.compile(Pattern.quote(FileNameUtils.getBaseName(path)) + \".[zZ][0-9]+\");\n+        ArrayList list;\n+        try (final Stream<Path> walk = Files.walk(start, 1, new FileVisitOption[0])) {\n+            list = walk.filter(path2 -> Files.isRegularFile(path2, new LinkOption[0])).filter(path3 -> pattern.matcher(path3.getFileName().toString()).matches()).sorted((Comparator<? super Path>)new ZipSplitReadOnlySeekableByteChannel.ZipSplitSegmentComparator((ZipSplitReadOnlySeekableByteChannel.ZipSplitReadOnlySeekableByteChannel$1)null)).collect(Collectors.toCollection(ArrayList::new));\n         }\n-        return forPaths(lastSegmentPath, splitZipSegments);\n+        return forPaths(path, list);\n     }\n     \n-    public static SeekableByteChannel forFiles(final File... files) throws IOException {\n-        final List<Path> paths = new ArrayList<Path>();\n-        for (final File f : (File[])Objects.requireNonNull(files, \"files must not be null\")) {\n-            paths.add(f.toPath());\n+    public static SeekableByteChannel forFiles(final File... obj) throws IOException {\n+        final ArrayList list = new ArrayList();\n+        final File[] array = (File[])Objects.requireNonNull(obj, \"files must not be null\");\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            list.add(array[i].toPath());\n         }\n-        return forPaths((Path[])paths.toArray(ZipSplitReadOnlySeekableByteChannel.EMPTY_PATH_ARRAY));\n+        return forPaths((Path[])list.toArray(ZipSplitReadOnlySeekableByteChannel.EMPTY_PATH_ARRAY));\n     }\n     \n-    public static SeekableByteChannel forPaths(final Path... paths) throws IOException {\n-        final List<SeekableByteChannel> channels = new ArrayList<SeekableByteChannel>();\n-        for (final Path path : (Path[])Objects.requireNonNull(paths, \"paths must not be null\")) {\n-            channels.add(Files.newByteChannel(path, StandardOpenOption.READ));\n+    public static SeekableByteChannel forPaths(final Path... obj) throws IOException {\n+        final ArrayList list = new ArrayList();\n+        final Path[] array = (Path[])Objects.requireNonNull(obj, \"paths must not be null\");\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            list.add(Files.newByteChannel(array[i], StandardOpenOption.READ));\n         }\n-        if (channels.size() == 1) {\n-            return channels.get(0);\n+        if (list.size() == 1) {\n+            return (SeekableByteChannel)list.get(0);\n         }\n-        return (SeekableByteChannel)new ZipSplitReadOnlySeekableByteChannel(channels);\n+        return (SeekableByteChannel)new ZipSplitReadOnlySeekableByteChannel(list);\n     }\n     \n-    public static SeekableByteChannel forFiles(final File lastSegmentFile, final Iterable<File> files) throws IOException {\n-        Objects.requireNonNull(files, \"files\");\n-        Objects.requireNonNull(lastSegmentFile, \"lastSegmentFile\");\n-        final List<Path> filesList = new ArrayList<Path>();\n-        files.forEach(f -> filesList.add(f.toPath()));\n-        return forPaths(lastSegmentFile.toPath(), filesList);\n+    public static SeekableByteChannel forFiles(final File obj, final Iterable<File> obj2) throws IOException {\n+        Objects.requireNonNull(obj2, \"files\");\n+        Objects.requireNonNull(obj, \"lastSegmentFile\");\n+        final ArrayList list = new ArrayList();\n+        obj2.forEach(file -> list2.add(file.toPath()));\n+        return forPaths(obj.toPath(), list);\n     }\n     \n-    public static SeekableByteChannel forPaths(final Path lastSegmentPath, final Iterable<Path> paths) throws IOException {\n-        Objects.requireNonNull(paths, \"paths\");\n-        Objects.requireNonNull(lastSegmentPath, \"lastSegmentPath\");\n-        final ArrayList obj;\n-        final List<Path> filesList = obj = new ArrayList();\n-        Objects.requireNonNull(obj);\n-        paths.forEach(obj::add);\n-        filesList.add(lastSegmentPath);\n-        return forPaths((Path[])filesList.toArray(ZipSplitReadOnlySeekableByteChannel.EMPTY_PATH_ARRAY));\n+    public static SeekableByteChannel forPaths(final Path obj, final Iterable<Path> obj2) throws IOException {\n+        Objects.requireNonNull(obj2, \"paths\");\n+        Objects.requireNonNull(obj, \"lastSegmentPath\");\n+        final ArrayList obj3;\n+        final ArrayList list = obj3 = new ArrayList();\n+        Objects.requireNonNull(obj3);\n+        obj2.forEach(obj3::add);\n+        list.add(obj);\n+        return forPaths((Path[])list.toArray(ZipSplitReadOnlySeekableByteChannel.EMPTY_PATH_ARRAY));\n     }\n     \n     static {\n         EMPTY_PATH_ARRAY = new Path[0];\n     }\n }\n"}]}
