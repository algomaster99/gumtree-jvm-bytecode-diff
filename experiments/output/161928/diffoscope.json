{"diffoscope-json-version": 1, "source1": "first/ZipArchiveInputStream.class", "source2": "second/ZipArchiveInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -99,15 +99,15 @@\n         this.twoDwordBuf = new byte[16];\n         this.encoding = encoding;\n         this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n         this.useUnicodeExtraFields = useUnicodeExtraFields;\n         this.inputStream = new PushbackInputStream(inputStream, this.buf.capacity());\n         this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n         this.skipSplitSig = skipSplitSig;\n-        this.buf.limit(0);\n+        this.buf.limit();\n     }\n     \n     private boolean bufferContainsSignature(final ByteArrayOutputStream bos, final int offset, final int lastRead, final int expectedDDLen) throws IOException {\n         boolean done = false;\n         for (int i = 0; !done && i < offset + lastRead - 4; ++i) {\n             if (this.buf.array()[i] == ZipArchiveInputStream.LFH[0] && this.buf.array()[i + 1] == ZipArchiveInputStream.LFH[1]) {\n                 int expectDDPos = i;\n@@ -211,15 +211,15 @@\n     \n     private int fill() throws IOException {\n         if (this.closed) {\n             throw new IOException(\"The stream is closed\");\n         }\n         final int length = this.inputStream.read(this.buf.array());\n         if (length > 0) {\n-            this.buf.limit(length);\n+            this.buf.limit();\n             this.count(this.buf.limit());\n             this.inf.setInput(this.buf.array(), 0, this.buf.limit());\n         }\n         return length;\n     }\n     \n     private boolean findEocdRecord() throws IOException {\n@@ -660,21 +660,21 @@\n             return this.lastStoredEntry.read(buffer, offset, length);\n         }\n         final long csize = ZipArchiveInputStream.CurrentEntry.access$2(this.current).getSize();\n         if (ZipArchiveInputStream.CurrentEntry.access$3(this.current) >= csize) {\n             return -1;\n         }\n         if (this.buf.position() >= this.buf.limit()) {\n-            this.buf.position(0);\n+            this.buf.position();\n             final int l = this.inputStream.read(this.buf.array());\n             if (l == -1) {\n-                this.buf.limit(0);\n+                this.buf.limit();\n                 throw new IOException(\"Truncated ZIP file\");\n             }\n-            this.buf.limit(l);\n+            this.buf.limit();\n             this.count(l);\n             final ZipArchiveInputStream.CurrentEntry current = this.current;\n             ZipArchiveInputStream.CurrentEntry.access$1(current, ZipArchiveInputStream.CurrentEntry.access$0(current) + (long)l);\n         }\n         int toRead = Math.min(this.buf.remaining(), length);\n         if (csize - ZipArchiveInputStream.CurrentEntry.access$3(this.current) < toRead) {\n             toRead = (int)(csize - ZipArchiveInputStream.CurrentEntry.access$3(this.current));\n"}]}
