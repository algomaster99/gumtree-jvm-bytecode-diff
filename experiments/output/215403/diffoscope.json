{"diffoscope-json-version": 1, "source1": "first/JavaClass.class", "source2": "second/JavaClass.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,14 +1,12 @@\n \n package org.apache.bcel.classfile;\n \n-import java.util.Set;\n import java.util.TreeSet;\n import org.apache.bcel.util.ClassQueue;\n-import java.util.List;\n import java.util.ArrayList;\n import java.util.StringTokenizer;\n import org.apache.bcel.generic.Type;\n import java.io.ByteArrayOutputStream;\n import java.io.OutputStream;\n import java.io.DataOutputStream;\n import java.io.FileOutputStream;\n@@ -43,16 +41,16 @@\n     public static final byte HEAP = 1;\n     public static final byte FILE = 2;\n     public static final byte ZIP = 3;\n     private static final boolean debug;\n     private static BCELComparator bcelComparator;\n     private transient Repository repository;\n     \n-    public JavaClass(final int classNameIndex, final int superclassNameIndex, final String fileName, final int major, final int minor, final int access_flags, final ConstantPool constantPool, int[] interfaces, Field[] fields, Method[] methods, Attribute[] attributes, final byte source) {\n-        super(access_flags);\n+    public JavaClass(final int classNameIndex, final int superclassNameIndex, final String fileName, final int major, final int minor, final int n, final ConstantPool constantPool, int[] interfaces, Field[] fields, Method[] methods, Attribute[] attributes, final byte source) {\n+        super(n);\n         this.sourceFileName = \"<Unknown>\";\n         this.source = 1;\n         this.isAnonymous = false;\n         this.isNested = false;\n         this.computedNestedTypeStatus = false;\n         this.repository = (Repository)SyntheticRepository.getInstance();\n         if (interfaces == null) {\n@@ -82,126 +80,129 @@\n             if (attribute instanceof SourceFile) {\n                 this.sourceFileName = ((SourceFile)attribute).getSourceFileName();\n                 break;\n             }\n         }\n         this.className = constantPool.getConstantString(classNameIndex, (byte)7);\n         this.className = Utility.compactClassName(this.className, false);\n-        final int index = this.className.lastIndexOf(46);\n-        if (index < 0) {\n+        final int lastIndex = this.className.lastIndexOf(46);\n+        if (lastIndex < 0) {\n             this.packageName = \"\";\n         }\n         else {\n-            this.packageName = this.className.substring(0, index);\n+            this.packageName = this.className.substring(0, lastIndex);\n         }\n         if (superclassNameIndex > 0) {\n             this.superclassName = constantPool.getConstantString(superclassNameIndex, (byte)7);\n             this.superclassName = Utility.compactClassName(this.superclassName, false);\n         }\n         else {\n             this.superclassName = \"java.lang.Object\";\n         }\n         this.interfaceNames = new String[interfaces.length];\n-        for (int i = 0; i < interfaces.length; ++i) {\n-            final String str = constantPool.getConstantString(interfaces[i], (byte)7);\n-            this.interfaceNames[i] = Utility.compactClassName(str, false);\n+        for (int j = 0; j < interfaces.length; ++j) {\n+            this.interfaceNames[j] = Utility.compactClassName(constantPool.getConstantString(interfaces[j], (byte)7), false);\n         }\n     }\n     \n-    public JavaClass(final int classNameIndex, final int superclassNameIndex, final String fileName, final int major, final int minor, final int access_flags, final ConstantPool constantPool, final int[] interfaces, final Field[] fields, final Method[] methods, final Attribute[] attributes) {\n-        this(classNameIndex, superclassNameIndex, fileName, major, minor, access_flags, constantPool, interfaces, fields, methods, attributes, (byte)1);\n+    public JavaClass(final int n, final int n2, final String s, final int n3, final int n4, final int n5, final ConstantPool constantPool, final int[] array, final Field[] array2, final Method[] array3, final Attribute[] array4) {\n+        this(n, n2, s, n3, n4, n5, constantPool, array, array2, array3, array4, (byte)1);\n     }\n     \n-    public void accept(final Visitor v) {\n-        v.visitJavaClass(this);\n+    public void accept(final Visitor visitor) {\n+        visitor.visitJavaClass(this);\n     }\n     \n-    static void Debug(final String str) {\n+    static void Debug(final String x) {\n         if (JavaClass.debug) {\n-            System.out.println(str);\n+            System.out.println(x);\n         }\n     }\n     \n     public void dump(final File file) throws IOException {\n         final String parent = file.getParent();\n         if (parent != null) {\n-            final File dir = new File(parent);\n-            if (!dir.mkdirs() && !dir.isDirectory()) {\n-                throw new IOException(\"Could not create the directory \" + dir);\n+            final File obj = new File(parent);\n+            if (!obj.mkdirs() && !obj.isDirectory()) {\n+                throw new IOException(\"Could not create the directory \" + obj);\n             }\n         }\n-        try (final DataOutputStream dos = new DataOutputStream(new FileOutputStream(file))) {\n-            this.dump(dos);\n+        try (final DataOutputStream dataOutputStream = new DataOutputStream(new FileOutputStream(file))) {\n+            this.dump(dataOutputStream);\n         }\n     }\n     \n-    public void dump(final String _file_name) throws IOException {\n-        this.dump(new File(_file_name));\n+    public void dump(final String pathname) throws IOException {\n+        this.dump(new File(pathname));\n     }\n     \n     public byte[] getBytes() {\n-        final ByteArrayOutputStream s = new ByteArrayOutputStream();\n-        final DataOutputStream ds = new DataOutputStream(s);\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final DataOutputStream dataOutputStream = new DataOutputStream(out);\n         try {\n-            this.dump(ds);\n+            this.dump(dataOutputStream);\n         }\n-        catch (final IOException e) {\n-            e.printStackTrace();\n+        catch (final IOException ex) {\n+            ex.printStackTrace();\n             try {\n-                ds.close();\n+                dataOutputStream.close();\n             }\n-            catch (final IOException e2) {\n-                e2.printStackTrace();\n+            catch (final IOException ex2) {\n+                ex2.printStackTrace();\n             }\n         }\n         finally {\n             try {\n-                ds.close();\n+                dataOutputStream.close();\n             }\n-            catch (final IOException e3) {\n-                e3.printStackTrace();\n+            catch (final IOException ex3) {\n+                ex3.printStackTrace();\n             }\n         }\n-        return s.toByteArray();\n+        return out.toByteArray();\n     }\n     \n-    public void dump(final OutputStream file) throws IOException {\n-        this.dump(new DataOutputStream(file));\n+    public void dump(final OutputStream out) throws IOException {\n+        this.dump(new DataOutputStream(out));\n     }\n     \n-    public void dump(final DataOutputStream file) throws IOException {\n-        file.writeInt(-889275714);\n-        file.writeShort(this.minor);\n-        file.writeShort(this.major);\n-        this.constantPool.dump(file);\n-        file.writeShort(super.getAccessFlags());\n-        file.writeShort(this.classNameIndex);\n-        file.writeShort(this.superclassNameIndex);\n-        file.writeShort(this.interfaces.length);\n-        for (final int interface1 : this.interfaces) {\n-            file.writeShort(interface1);\n+    public void dump(final DataOutputStream dataOutputStream) throws IOException {\n+        dataOutputStream.writeInt(-889275714);\n+        dataOutputStream.writeShort(this.minor);\n+        dataOutputStream.writeShort(this.major);\n+        this.constantPool.dump(dataOutputStream);\n+        dataOutputStream.writeShort(super.getAccessFlags());\n+        dataOutputStream.writeShort(this.classNameIndex);\n+        dataOutputStream.writeShort(this.superclassNameIndex);\n+        dataOutputStream.writeShort(this.interfaces.length);\n+        final int[] interfaces = this.interfaces;\n+        for (int length = interfaces.length, i = 0; i < length; ++i) {\n+            dataOutputStream.writeShort(interfaces[i]);\n         }\n-        file.writeShort(this.fields.length);\n-        for (final Field field : this.fields) {\n-            field.dump(file);\n+        dataOutputStream.writeShort(this.fields.length);\n+        final Field[] fields = this.fields;\n+        for (int length2 = fields.length, j = 0; j < length2; ++j) {\n+            fields[j].dump(dataOutputStream);\n         }\n-        file.writeShort(this.methods.length);\n-        for (final Method method : this.methods) {\n-            method.dump(file);\n+        dataOutputStream.writeShort(this.methods.length);\n+        final Method[] methods = this.methods;\n+        for (int length3 = methods.length, k = 0; k < length3; ++k) {\n+            methods[k].dump(dataOutputStream);\n         }\n         if (this.attributes != null) {\n-            file.writeShort(this.attributes.length);\n-            for (final Attribute attribute : this.attributes) {\n-                attribute.dump(file);\n+            dataOutputStream.writeShort(this.attributes.length);\n+            final Attribute[] attributes = this.attributes;\n+            for (int length4 = attributes.length, l = 0; l < length4; ++l) {\n+                attributes[l].dump(dataOutputStream);\n             }\n         }\n         else {\n-            file.writeShort(0);\n+            dataOutputStream.writeShort(0);\n         }\n-        file.flush();\n+        dataOutputStream.flush();\n     }\n     \n     public Attribute[] getAttributes() {\n         return this.attributes;\n     }\n     \n     public AnnotationEntry[] getAnnotationEntries() {\n@@ -247,18 +248,18 @@\n         return this.major;\n     }\n     \n     public Method[] getMethods() {\n         return this.methods;\n     }\n     \n-    public Method getMethod(final java.lang.reflect.Method m) {\n-        for (final Method method : this.methods) {\n-            if (m.getName().equals(method.getName()) && m.getModifiers() == method.getModifiers() && Type.getSignature(m).equals(method.getSignature())) {\n-                return method;\n+    public Method getMethod(final java.lang.reflect.Method method) {\n+        for (final Method method2 : this.methods) {\n+            if (method.getName().equals(method2.getName()) && method.getModifiers() == method2.getModifiers() && Type.getSignature(method).equals(method2.getSignature())) {\n+                return method2;\n             }\n         }\n         return null;\n     }\n     \n     public int getMinor() {\n         return this.minor;\n@@ -329,94 +330,98 @@\n     }\n     \n     public void setSuperclassNameIndex(final int superclassNameIndex) {\n         this.superclassNameIndex = superclassNameIndex;\n     }\n     \n     public String toString() {\n-        String access = Utility.accessToString(super.getAccessFlags(), true);\n-        access = (access.isEmpty() ? \"\" : (access + \" \"));\n-        final StringBuilder buf = new StringBuilder(128);\n-        buf.append(access).append(Utility.classOrInterface(super.getAccessFlags())).append(\" \").append(this.className).append(\" extends \").append(Utility.compactClassName(this.superclassName, false)).append('\\n');\n-        final int size = this.interfaces.length;\n-        if (size > 0) {\n-            buf.append(\"implements\\t\\t\");\n-            for (int i = 0; i < size; ++i) {\n-                buf.append(this.interfaceNames[i]);\n-                if (i < size - 1) {\n-                    buf.append(\", \");\n+        final String accessToString = Utility.accessToString(super.getAccessFlags(), true);\n+        final String str = accessToString.isEmpty() ? \"\" : (accessToString + \" \");\n+        final StringBuilder sb = new StringBuilder(128);\n+        sb.append(str).append(Utility.classOrInterface(super.getAccessFlags())).append(\" \").append(this.className).append(\" extends \").append(Utility.compactClassName(this.superclassName, false)).append('\\n');\n+        final int length = this.interfaces.length;\n+        if (length > 0) {\n+            sb.append(\"implements\\t\\t\");\n+            for (int i = 0; i < length; ++i) {\n+                sb.append(this.interfaceNames[i]);\n+                if (i < length - 1) {\n+                    sb.append(\", \");\n                 }\n             }\n-            buf.append('\\n');\n+            sb.append('\\n');\n         }\n-        buf.append(\"file name\\t\\t\").append(this.fileName).append('\\n');\n-        buf.append(\"compiled from\\t\\t\").append(this.sourceFileName).append('\\n');\n-        buf.append(\"compiler version\\t\").append(this.major).append(\".\").append(this.minor).append('\\n');\n-        buf.append(\"access flags\\t\\t\").append(super.getAccessFlags()).append('\\n');\n-        buf.append(\"constant pool\\t\\t\").append(this.constantPool.getLength()).append(\" entries\\n\");\n-        buf.append(\"ACC_SUPER flag\\t\\t\").append(this.isSuper()).append(\"\\n\");\n+        sb.append(\"file name\\t\\t\").append(this.fileName).append('\\n');\n+        sb.append(\"compiled from\\t\\t\").append(this.sourceFileName).append('\\n');\n+        sb.append(\"compiler version\\t\").append(this.major).append(\".\").append(this.minor).append('\\n');\n+        sb.append(\"access flags\\t\\t\").append(super.getAccessFlags()).append('\\n');\n+        sb.append(\"constant pool\\t\\t\").append(this.constantPool.getLength()).append(\" entries\\n\");\n+        sb.append(\"ACC_SUPER flag\\t\\t\").append(this.isSuper()).append(\"\\n\");\n         if (this.attributes.length > 0) {\n-            buf.append(\"\\nAttribute(s):\\n\");\n-            for (final Attribute attribute : this.attributes) {\n-                buf.append(indent((Object)attribute));\n+            sb.append(\"\\nAttribute(s):\\n\");\n+            final Attribute[] attributes = this.attributes;\n+            for (int length2 = attributes.length, j = 0; j < length2; ++j) {\n+                sb.append(indent((Object)attributes[j]));\n             }\n         }\n-        final AnnotationEntry[] annotations = this.getAnnotationEntries();\n-        if (annotations != null && annotations.length > 0) {\n-            buf.append(\"\\nAnnotation(s):\\n\");\n-            for (final AnnotationEntry annotation : annotations) {\n-                buf.append(indent((Object)annotation));\n+        final AnnotationEntry[] annotationEntries = this.getAnnotationEntries();\n+        if (annotationEntries != null && annotationEntries.length > 0) {\n+            sb.append(\"\\nAnnotation(s):\\n\");\n+            final AnnotationEntry[] array = annotationEntries;\n+            for (int length3 = array.length, k = 0; k < length3; ++k) {\n+                sb.append(indent((Object)array[k]));\n             }\n         }\n         if (this.fields.length > 0) {\n-            buf.append(\"\\n\").append(this.fields.length).append(\" fields:\\n\");\n-            for (final Field field : this.fields) {\n-                buf.append(\"\\t\").append(field).append('\\n');\n+            sb.append(\"\\n\").append(this.fields.length).append(\" fields:\\n\");\n+            final Field[] fields = this.fields;\n+            for (int length4 = fields.length, l = 0; l < length4; ++l) {\n+                sb.append(\"\\t\").append(fields[l]).append('\\n');\n             }\n         }\n         if (this.methods.length > 0) {\n-            buf.append(\"\\n\").append(this.methods.length).append(\" methods:\\n\");\n-            for (final Method method : this.methods) {\n-                buf.append(\"\\t\").append(method).append('\\n');\n+            sb.append(\"\\n\").append(this.methods.length).append(\" methods:\\n\");\n+            final Method[] methods = this.methods;\n+            for (int length5 = methods.length, n = 0; n < length5; ++n) {\n+                sb.append(\"\\t\").append(methods[n]).append('\\n');\n             }\n         }\n-        return buf.toString();\n+        return sb.toString();\n     }\n     \n-    private static String indent(final Object obj) {\n-        final StringTokenizer tok = new StringTokenizer(obj.toString(), \"\\n\");\n-        final StringBuilder buf = new StringBuilder();\n-        while (tok.hasMoreTokens()) {\n-            buf.append(\"\\t\").append(tok.nextToken()).append(\"\\n\");\n+    private static String indent(final Object o) {\n+        final StringTokenizer stringTokenizer = new StringTokenizer(o.toString(), \"\\n\");\n+        final StringBuilder sb = new StringBuilder();\n+        while (stringTokenizer.hasMoreTokens()) {\n+            sb.append(\"\\t\").append(stringTokenizer.nextToken()).append(\"\\n\");\n         }\n-        return buf.toString();\n+        return sb.toString();\n     }\n     \n     public JavaClass copy() {\n-        JavaClass c = null;\n+        JavaClass javaClass = null;\n         try {\n-            c = (JavaClass)this.clone();\n-            c.constantPool = this.constantPool.copy();\n-            c.interfaces = this.interfaces.clone();\n-            c.interfaceNames = this.interfaceNames.clone();\n-            c.fields = new Field[this.fields.length];\n+            javaClass = (JavaClass)this.clone();\n+            javaClass.constantPool = this.constantPool.copy();\n+            javaClass.interfaces = this.interfaces.clone();\n+            javaClass.interfaceNames = this.interfaceNames.clone();\n+            javaClass.fields = new Field[this.fields.length];\n             for (int i = 0; i < this.fields.length; ++i) {\n-                c.fields[i] = this.fields[i].copy(c.constantPool);\n+                javaClass.fields[i] = this.fields[i].copy(javaClass.constantPool);\n             }\n-            c.methods = new Method[this.methods.length];\n-            for (int i = 0; i < this.methods.length; ++i) {\n-                c.methods[i] = this.methods[i].copy(c.constantPool);\n-            }\n-            c.attributes = new Attribute[this.attributes.length];\n-            for (int i = 0; i < this.attributes.length; ++i) {\n-                c.attributes[i] = this.attributes[i].copy(c.constantPool);\n+            javaClass.methods = new Method[this.methods.length];\n+            for (int j = 0; j < this.methods.length; ++j) {\n+                javaClass.methods[j] = this.methods[j].copy(javaClass.constantPool);\n+            }\n+            javaClass.attributes = new Attribute[this.attributes.length];\n+            for (int k = 0; k < this.attributes.length; ++k) {\n+                javaClass.attributes[k] = this.attributes[k].copy(javaClass.constantPool);\n             }\n         }\n         catch (final CloneNotSupportedException ex) {}\n-        return c;\n+        return javaClass;\n     }\n     \n     public final boolean isSuper() {\n         return (super.getAccessFlags() & 0x20) != 0x0;\n     }\n     \n     public final boolean isClass() {\n@@ -435,26 +440,22 @@\n     \n     private void computeNestedTypeStatus() {\n         if (this.computedNestedTypeStatus) {\n             return;\n         }\n         for (final Attribute attribute : this.attributes) {\n             if (attribute instanceof InnerClasses) {\n-                final InnerClass[] innerClasses2;\n-                final InnerClass[] innerClasses = innerClasses2 = ((InnerClasses)attribute).getInnerClasses();\n-                for (final InnerClass innerClasse : innerClasses2) {\n-                    boolean innerClassAttributeRefersToMe = false;\n-                    String inner_class_name = this.constantPool.getConstantString(innerClasse.getInnerClassIndex(), (byte)7);\n-                    inner_class_name = Utility.compactClassName(inner_class_name, false);\n-                    if (inner_class_name.equals(this.getClassName())) {\n-                        innerClassAttributeRefersToMe = true;\n+                for (final InnerClass innerClass : ((InnerClasses)attribute).getInnerClasses()) {\n+                    boolean b = false;\n+                    if (Utility.compactClassName(this.constantPool.getConstantString(innerClass.getInnerClassIndex(), (byte)7), false).equals(this.getClassName())) {\n+                        b = true;\n                     }\n-                    if (innerClassAttributeRefersToMe) {\n+                    if (b) {\n                         this.isNested = true;\n-                        if (innerClasse.getInnerNameIndex() == 0) {\n+                        if (innerClass.getInnerNameIndex() == 0) {\n                             this.isAnonymous = true;\n                         }\n                     }\n                 }\n             }\n         }\n         this.computedNestedTypeStatus = true;\n@@ -468,105 +469,103 @@\n         return this.repository;\n     }\n     \n     public void setRepository(final Repository repository) {\n         this.repository = repository;\n     }\n     \n-    public final boolean instanceOf(final JavaClass super_class) throws ClassNotFoundException {\n-        if (this.equals(super_class)) {\n+    public final boolean instanceOf(final JavaClass javaClass) throws ClassNotFoundException {\n+        if (this.equals(javaClass)) {\n             return true;\n         }\n-        final JavaClass[] superClasses;\n-        final JavaClass[] super_classes = superClasses = this.getSuperClasses();\n-        for (final JavaClass super_classe : superClasses) {\n-            if (super_classe.equals(super_class)) {\n+        final JavaClass[] superClasses = this.getSuperClasses();\n+        for (int length = superClasses.length, i = 0; i < length; ++i) {\n+            if (superClasses[i].equals(javaClass)) {\n                 return true;\n             }\n         }\n-        return super_class.isInterface() && this.implementationOf(super_class);\n+        return javaClass.isInterface() && this.implementationOf(javaClass);\n     }\n     \n-    public boolean implementationOf(final JavaClass inter) throws ClassNotFoundException {\n-        if (!inter.isInterface()) {\n-            throw new IllegalArgumentException(inter.getClassName() + \" is no interface\");\n+    public boolean implementationOf(final JavaClass javaClass) throws ClassNotFoundException {\n+        if (!javaClass.isInterface()) {\n+            throw new IllegalArgumentException(javaClass.getClassName() + \" is no interface\");\n         }\n-        if (this.equals(inter)) {\n+        if (this.equals(javaClass)) {\n             return true;\n         }\n-        final JavaClass[] allInterfaces;\n-        final JavaClass[] super_interfaces = allInterfaces = this.getAllInterfaces();\n-        for (final JavaClass super_interface : allInterfaces) {\n-            if (super_interface.equals(inter)) {\n+        final JavaClass[] allInterfaces = this.getAllInterfaces();\n+        for (int length = allInterfaces.length, i = 0; i < length; ++i) {\n+            if (allInterfaces[i].equals(javaClass)) {\n                 return true;\n             }\n         }\n         return false;\n     }\n     \n     public JavaClass getSuperClass() throws ClassNotFoundException {\n         if (\"java.lang.Object\".equals(this.getClassName())) {\n             return null;\n         }\n         return this.repository.loadClass(this.getSuperclassName());\n     }\n     \n     public JavaClass[] getSuperClasses() throws ClassNotFoundException {\n-        JavaClass clazz = this;\n-        final List<JavaClass> allSuperClasses = new ArrayList<JavaClass>();\n-        for (clazz = clazz.getSuperClass(); clazz != null; clazz = clazz.getSuperClass()) {\n-            allSuperClasses.add(clazz);\n+        final ArrayList list = new ArrayList();\n+        for (JavaClass javaClass = this.getSuperClass(); javaClass != null; javaClass = javaClass.getSuperClass()) {\n+            list.add(javaClass);\n         }\n-        return allSuperClasses.toArray(new JavaClass[allSuperClasses.size()]);\n+        return (JavaClass[])list.toArray(new JavaClass[list.size()]);\n     }\n     \n     public JavaClass[] getInterfaces() throws ClassNotFoundException {\n-        final String[] _interfaces = this.getInterfaceNames();\n-        final JavaClass[] classes = new JavaClass[_interfaces.length];\n-        for (int i = 0; i < _interfaces.length; ++i) {\n-            classes[i] = this.repository.loadClass(_interfaces[i]);\n+        final String[] interfaceNames = this.getInterfaceNames();\n+        final JavaClass[] array = new JavaClass[interfaceNames.length];\n+        for (int i = 0; i < interfaceNames.length; ++i) {\n+            array[i] = this.repository.loadClass(interfaceNames[i]);\n         }\n-        return classes;\n+        return array;\n     }\n     \n     public JavaClass[] getAllInterfaces() throws ClassNotFoundException {\n-        final ClassQueue queue = new ClassQueue();\n-        final Set<JavaClass> allInterfaces = new TreeSet<JavaClass>();\n-        queue.enqueue(this);\n-        while (!queue.empty()) {\n-            final JavaClass clazz = queue.dequeue();\n-            final JavaClass souper = clazz.getSuperClass();\n-            final JavaClass[] _interfaces = clazz.getInterfaces();\n-            if (clazz.isInterface()) {\n-                allInterfaces.add(clazz);\n-            }\n-            else if (souper != null) {\n-                queue.enqueue(souper);\n-            }\n-            for (final JavaClass _interface : _interfaces) {\n-                queue.enqueue(_interface);\n+        final ClassQueue classQueue = new ClassQueue();\n+        final TreeSet set = new TreeSet();\n+        classQueue.enqueue(this);\n+        while (!classQueue.empty()) {\n+            final JavaClass dequeue = classQueue.dequeue();\n+            final JavaClass superClass = dequeue.getSuperClass();\n+            final JavaClass[] interfaces = dequeue.getInterfaces();\n+            if (dequeue.isInterface()) {\n+                set.add(dequeue);\n+            }\n+            else if (superClass != null) {\n+                classQueue.enqueue(superClass);\n+            }\n+            final JavaClass[] array = interfaces;\n+            for (int length = array.length, i = 0; i < length; ++i) {\n+                classQueue.enqueue(array[i]);\n             }\n         }\n-        return allInterfaces.toArray(new JavaClass[allInterfaces.size()]);\n+        return (JavaClass[])set.toArray(new JavaClass[set.size()]);\n     }\n     \n     public static BCELComparator getComparator() {\n         return JavaClass.bcelComparator;\n     }\n     \n-    public static void setComparator(final BCELComparator comparator) {\n-        JavaClass.bcelComparator = comparator;\n+    public static void setComparator(final BCELComparator bcelComparator) {\n+        JavaClass.bcelComparator = bcelComparator;\n     }\n     \n-    public boolean equals(final Object obj) {\n-        return JavaClass.bcelComparator.equals((Object)this, obj);\n+    public boolean equals(final Object o) {\n+        return JavaClass.bcelComparator.equals((Object)this, o);\n     }\n     \n-    public int compareTo(final JavaClass obj) {\n-        return this.getClassName().compareTo(obj.getClassName());\n+    public int compareTo(final JavaClass javaClass) {\n+        return this.getClassName().compareTo(javaClass.getClassName());\n     }\n     \n     public int hashCode() {\n         return JavaClass.bcelComparator.hashCode((Object)this);\n     }\n     \n     static {\n"}]}
