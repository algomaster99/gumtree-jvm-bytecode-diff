{"diffoscope-json-version": 1, "source1": "first/AbstractConfiguration.class", "source2": "second/AbstractConfiguration.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -190,36 +190,36 @@\n     }\n     \n     public final void setSynchronizer(final Synchronizer synchronizer) {\n         this.synchronizer = synchronizer;\n     }\n     \n     public final void lock(final LockMode mode) {\n-        switch (AbstractConfiguration.AbstractConfiguration$1.$SwitchMap$org$apache$commons$configuration2$sync$LockMode[mode.ordinal()]) {\n-            case 1: {\n+        switch (mode) {\n+            case READ: {\n                 this.beginRead(false);\n                 break;\n             }\n-            case 2: {\n+            case WRITE: {\n                 this.beginWrite(false);\n                 break;\n             }\n             default: {\n                 throw new IllegalArgumentException(\"Unsupported LockMode: \" + mode);\n             }\n         }\n     }\n     \n     public final void unlock(final LockMode mode) {\n-        switch (AbstractConfiguration.AbstractConfiguration$1.$SwitchMap$org$apache$commons$configuration2$sync$LockMode[mode.ordinal()]) {\n-            case 1: {\n+        switch (mode) {\n+            case READ: {\n                 this.endRead();\n                 break;\n             }\n-            case 2: {\n+            case WRITE: {\n                 this.endWrite();\n                 break;\n             }\n             default: {\n                 throw new IllegalArgumentException(\"Unsupported LockMode: \" + mode);\n             }\n         }\n@@ -247,18 +247,19 @@\n             this.fireEvent(ConfigurationEvent.ADD_PROPERTY, key, value, true);\n             this.addPropertyInternal(key, value);\n             this.fireEvent(ConfigurationEvent.ADD_PROPERTY, key, value, false);\n         }\n         finally {\n             this.endWrite();\n         }\n+        this.endWrite();\n     }\n     \n     protected void addPropertyInternal(final String key, final Object value) {\n-        this.getListDelimiterHandler().parse(value).forEach(obj -> this.addPropertyDirect(key, obj));\n+        this.getListDelimiterHandler().parse(value).forEach(obj -> this.addPropertyDirect(s, obj));\n     }\n     \n     protected abstract void addPropertyDirect(final String p0, final Object p1);\n     \n     protected String interpolate(final String base) {\n         final Object result = this.interpolate((Object)base);\n         return (result == null) ? null : result.toString();\n@@ -283,79 +284,84 @@\n             this.fireEvent(ConfigurationEvent.SET_PROPERTY, key, value, true);\n             this.setPropertyInternal(key, value);\n             this.fireEvent(ConfigurationEvent.SET_PROPERTY, key, value, false);\n         }\n         finally {\n             this.endWrite();\n         }\n+        this.endWrite();\n     }\n     \n     protected void setPropertyInternal(final String key, final Object value) {\n         this.setDetailEvents(false);\n         try {\n             this.clearProperty(key);\n             this.addProperty(key, value);\n         }\n         finally {\n             this.setDetailEvents(true);\n         }\n+        this.setDetailEvents(true);\n     }\n     \n     public final void clearProperty(final String key) {\n         this.beginWrite(false);\n         try {\n             this.fireEvent(ConfigurationEvent.CLEAR_PROPERTY, key, (Object)null, true);\n             this.clearPropertyDirect(key);\n             this.fireEvent(ConfigurationEvent.CLEAR_PROPERTY, key, (Object)null, false);\n         }\n         finally {\n             this.endWrite();\n         }\n+        this.endWrite();\n     }\n     \n     protected abstract void clearPropertyDirect(final String p0);\n     \n     public final void clear() {\n         this.beginWrite(false);\n         try {\n             this.fireEvent(ConfigurationEvent.CLEAR, (String)null, (Object)null, true);\n             this.clearInternal();\n             this.fireEvent(ConfigurationEvent.CLEAR, (String)null, (Object)null, false);\n         }\n         finally {\n             this.endWrite();\n         }\n+        this.endWrite();\n     }\n     \n     protected void clearInternal() {\n         this.setDetailEvents(false);\n         boolean useIterator = true;\n         try {\n             final Iterator<String> it = this.getKeys();\n             while (it.hasNext()) {\n                 final String key = (String)it.next();\n                 if (useIterator) {\n                     try {\n                         it.remove();\n                     }\n-                    catch (final UnsupportedOperationException usoex) {\n+                    catch (final UnsupportedOperationException ex) {\n                         useIterator = false;\n                     }\n                 }\n                 if (useIterator && this.containsKey(key)) {\n                     useIterator = false;\n                 }\n                 if (!useIterator) {\n                     this.clearProperty(key);\n                 }\n             }\n         }\n         finally {\n             this.setDetailEvents(true);\n         }\n+        this.setDetailEvents(true);\n     }\n     \n     public final Iterator<String> getKeys() {\n         this.beginRead(false);\n         try {\n             return this.getKeysInternal();\n         }\n@@ -439,31 +445,31 @@\n     public Properties getProperties(final String key) {\n         return this.getProperties(key, null);\n     }\n     \n     public Properties getProperties(final String key, final Properties defaults) {\n         final String[] tokens = this.getStringArray(key);\n         final Properties props = (defaults == null) ? new Properties() : new Properties(defaults);\n-        final String[] array = tokens;\n-        final int length = array.length;\n+        final String[] array;\n+        final int length = (array = tokens).length;\n         int i = 0;\n         while (i < length) {\n             final String token = array[i];\n             final int equalSign = token.indexOf(61);\n             if (equalSign > 0) {\n                 final String pkey = token.substring(0, equalSign).trim();\n                 final String pvalue = token.substring(equalSign + 1).trim();\n                 props.put(pkey, pvalue);\n                 ++i;\n             }\n             else {\n                 if (tokens.length == 1 && StringUtils.isEmpty((CharSequence)key)) {\n                     break;\n                 }\n-                throw new IllegalArgumentException('\\'' + token + \"' does not contain an equals sign\");\n+                throw new IllegalArgumentException(String.valueOf('\\'') + token + \"' does not contain an equals sign\");\n             }\n         }\n         return props;\n     }\n     \n     public boolean getBoolean(final String key) {\n         final Boolean b = Boolean.valueOf(this.convert(Boolean.class, key, (Boolean)null, true));\n@@ -501,15 +507,15 @@\n     }\n     \n     public Double getDouble(final String key, final Double defaultValue) {\n         return Double.valueOf(this.convert(Double.class, key, defaultValue, false));\n     }\n     \n     public Duration getDuration(final String key) {\n-        return checkNonNullValue(key, (Duration)this.convert((Class<T>)Duration.class, key, (T)null, true));\n+        return checkNonNullValue(key, (Duration)(T)this.convert((Class<T>)Duration.class, key, (T)null, true));\n     }\n     \n     public Duration getDuration(final String key, final Duration defaultValue) {\n         return this.convert(Duration.class, key, defaultValue, false);\n     }\n     \n     public float getFloat(final String key) {\n@@ -620,27 +626,27 @@\n         if (value instanceof String) {\n             list = new ArrayList<Object>(1);\n             list.add(this.interpolate((String)value));\n         }\n         else if (value instanceof List) {\n             list = new ArrayList<Object>();\n             final List<?> l = (List)value;\n-            l.forEach(elem -> list.add(this.interpolate(elem)));\n+            l.forEach(elem -> list2.add(this.interpolate(elem)));\n         }\n         else if (value == null) {\n             final List<Object> resultList = list = (List<Object>)defaultValue;\n         }\n         else {\n             if (value.getClass().isArray()) {\n-                return Arrays.asList((Object[])(Object[])value);\n+                return Arrays.asList((Object[])value);\n             }\n             if (this.isScalarValue(value)) {\n                 return (List<Object>)Collections.singletonList(value.toString());\n             }\n-            throw new ConversionException('\\'' + key + \"' doesn't map to a List object: \" + value + \", a \" + value.getClass().getName());\n+            throw new ConversionException(String.valueOf('\\'') + key + \"' doesn't map to a List object: \" + value + \", a \" + value.getClass().getName());\n         }\n         return list;\n     }\n     \n     public <T> T get(final Class<T> cls, final String key) {\n         return this.convert(cls, key, (T)null, true);\n     }\n@@ -687,38 +693,40 @@\n         return ClassUtils.wrapperToPrimitive((Class)value.getClass()) != null;\n     }\n     \n     public void copy(final Configuration c) {\n         if (c != null) {\n             c.lock(LockMode.READ);\n             try {\n-                c.getKeys().forEachRemaining(key -> this.setProperty(key, this.encodeForCopy(c.getProperty(key))));\n+                c.getKeys().forEachRemaining(key -> this.setProperty(key, this.encodeForCopy(configuration.getProperty(key))));\n             }\n             finally {\n                 c.unlock(LockMode.READ);\n             }\n+            c.unlock(LockMode.READ);\n         }\n     }\n     \n     public void append(final Configuration c) {\n         if (c != null) {\n             c.lock(LockMode.READ);\n             try {\n-                c.getKeys().forEachRemaining(key -> this.addProperty(key, this.encodeForCopy(c.getProperty(key))));\n+                c.getKeys().forEachRemaining(key -> this.addProperty(key, this.encodeForCopy(configuration.getProperty(key))));\n             }\n             finally {\n                 c.unlock(LockMode.READ);\n             }\n+            c.unlock(LockMode.READ);\n         }\n     }\n     \n     public Configuration interpolatedConfiguration() {\n         final AbstractConfiguration c = (AbstractConfiguration)ConfigurationUtils.cloneConfiguration((Configuration)this);\n         c.setListDelimiterHandler((ListDelimiterHandler)new DisabledListDelimiterHandler());\n-        this.getKeys().forEachRemaining(key -> c.setProperty(key, this.getList(key)));\n+        this.getKeys().forEachRemaining(key -> abstractConfiguration.setProperty(key, this.getList(key)));\n         c.setListDelimiterHandler(this.getListDelimiterHandler());\n         return (Configuration)c;\n     }\n     \n     protected final void initLogger(final ConfigurationLogger log) {\n         this.log = ((log != null) ? log : ConfigurationLogger.newDummyLogger());\n     }\n@@ -761,15 +769,15 @@\n     private Object convertToArray(final Class<?> cls, final String key, final Object defaultValue) {\n         checkDefaultValueArray(cls, defaultValue);\n         return ObjectUtils.defaultIfNull(this.getConversionHandler().toArray(this.getProperty(key), (Class)cls, this.getInterpolator()), defaultValue);\n     }\n     \n     private static void checkDefaultValueArray(final Class<?> cls, final Object defaultValue) {\n         if (defaultValue != null && (!defaultValue.getClass().isArray() || !cls.isAssignableFrom(defaultValue.getClass().getComponentType()))) {\n-            throw new IllegalArgumentException(\"The type of the default value (\" + defaultValue.getClass() + \") is not an array of the specified class (\" + cls + \")\");\n+            throw new IllegalArgumentException(\"The type of the default value (\" + defaultValue.getClass() + \")\" + \" is not an array of the specified class (\" + cls + \")\");\n         }\n     }\n     \n     private static <T> Collection<T> handleDefaultCollection(final Collection<T> target, final Collection<T> defaultValue) {\n         if (defaultValue == null) {\n             return null;\n         }\n"}]}
