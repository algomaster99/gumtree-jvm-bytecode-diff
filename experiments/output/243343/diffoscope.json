{"diffoscope-json-version": 1, "source1": "first/Type.class", "source2": "second/Type.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,15 +1,14 @@\n \n package org.apache.bcel.generic;\n \n import java.util.Arrays;\n import org.apache.bcel.classfile.Utility;\n import java.util.Objects;\n import java.lang.reflect.Method;\n-import java.util.List;\n import org.apache.bcel.classfile.ClassFormatException;\n import java.util.ArrayList;\n \n public abstract class Type\n {\n     public static final BasicType VOID;\n     public static final BasicType BOOLEAN;\n@@ -39,85 +38,82 @@\n     }\n     \n     static int encode(final int size, final int consumed) {\n         return consumed << 2 | size;\n     }\n     \n     public static Type[] getArgumentTypes(final String signature) {\n-        final List<Type> vec = new ArrayList<Type>();\n+        final ArrayList list = new ArrayList();\n         try {\n-            int index = signature.indexOf(40) + 1;\n-            if (index <= 0) {\n+            int n = signature.indexOf(40) + 1;\n+            if (n <= 0) {\n                 throw new ClassFormatException(\"Invalid method signature: \" + signature);\n             }\n-            while (signature.charAt(index) != ')') {\n-                vec.add(getType(signature.substring(index)));\n-                index += unwrap(Type.CONSUMED_CHARS);\n+            while (signature.charAt(n) != ')') {\n+                list.add(getType(signature.substring(n)));\n+                n += unwrap(Type.CONSUMED_CHARS);\n             }\n         }\n-        catch (final StringIndexOutOfBoundsException e) {\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)e);\n+        catch (final StringIndexOutOfBoundsException ex) {\n+            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)ex);\n         }\n-        final Type[] types = new Type[vec.size()];\n-        vec.toArray(types);\n-        return types;\n+        final Type[] array = new Type[list.size()];\n+        list.toArray(array);\n+        return array;\n     }\n     \n     static int getArgumentTypesSize(final String signature) {\n-        int res = 0;\n+        int n = 0;\n         try {\n-            int index = signature.indexOf(40) + 1;\n-            if (index <= 0) {\n+            int n2 = signature.indexOf(40) + 1;\n+            if (n2 <= 0) {\n                 throw new ClassFormatException(\"Invalid method signature: \" + signature);\n             }\n-            while (signature.charAt(index) != ')') {\n-                final int coded = getTypeSize(signature.substring(index));\n-                res += size(coded);\n-                index += consumed(coded);\n+            while (signature.charAt(n2) != ')') {\n+                final int typeSize = getTypeSize(signature.substring(n2));\n+                n += size(typeSize);\n+                n2 += consumed(typeSize);\n             }\n         }\n-        catch (final StringIndexOutOfBoundsException e) {\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)e);\n+        catch (final StringIndexOutOfBoundsException ex) {\n+            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)ex);\n         }\n-        return res;\n+        return n;\n     }\n     \n     public static String getMethodSignature(final Type returnType, final Type[] argTypes) {\n-        final StringBuilder buf = new StringBuilder(\"(\");\n+        final StringBuilder sb = new StringBuilder(\"(\");\n         if (argTypes != null) {\n-            for (final Type argType : argTypes) {\n-                buf.append(argType.getSignature());\n+            for (int length = argTypes.length, i = 0; i < length; ++i) {\n+                sb.append(argTypes[i].getSignature());\n             }\n         }\n-        buf.append(')');\n-        buf.append(returnType.getSignature());\n-        return buf.toString();\n+        sb.append(')');\n+        sb.append(returnType.getSignature());\n+        return sb.toString();\n     }\n     \n     public static Type getReturnType(final String signature) {\n         try {\n-            final int index = signature.lastIndexOf(41) + 1;\n-            return getType(signature.substring(index));\n+            return getType(signature.substring(signature.lastIndexOf(41) + 1));\n         }\n-        catch (final StringIndexOutOfBoundsException e) {\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)e);\n+        catch (final StringIndexOutOfBoundsException ex) {\n+            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)ex);\n         }\n     }\n     \n     static int getReturnTypeSize(final String signature) {\n-        final int index = signature.lastIndexOf(41) + 1;\n-        return size(getTypeSize(signature.substring(index)));\n+        return size(getTypeSize(signature.substring(signature.lastIndexOf(41) + 1)));\n     }\n     \n     public static String getSignature(final Method meth) {\n         final StringBuilder sb = new StringBuilder(\"(\");\n-        final Class<?>[] parameterTypes;\n-        final Class<?>[] params = parameterTypes = meth.getParameterTypes();\n-        for (final Class<?> param : parameterTypes) {\n-            sb.append(getType(param).getSignature());\n+        final Class<?>[] parameterTypes = meth.getParameterTypes();\n+        for (int length = parameterTypes.length, i = 0; i < length; ++i) {\n+            sb.append(getType(parameterTypes[i]).getSignature());\n         }\n         sb.append(\")\");\n         sb.append(getType(meth.getReturnType()).getSignature());\n         return sb.toString();\n     }\n     \n     public static Type getType(final Class<?> cls) {\n@@ -155,52 +151,50 @@\n         if (cls == Character.TYPE) {\n             return (Type)Type.CHAR;\n         }\n         throw new IllegalStateException(\"Unknown primitive type \" + cls);\n     }\n     \n     public static Type getType(final String signature) throws StringIndexOutOfBoundsException {\n-        final byte type = Utility.typeOfSignature(signature);\n-        if (type <= 12) {\n+        final byte typeOfSignature = Utility.typeOfSignature(signature);\n+        if (typeOfSignature <= 12) {\n             wrap(Type.CONSUMED_CHARS, 1);\n-            return (Type)BasicType.getType(type);\n+            return (Type)BasicType.getType(typeOfSignature);\n         }\n-        if (type != 13) {\n-            final String parsedSignature = Utility.typeSignatureToString(signature, false);\n-            wrap(Type.CONSUMED_CHARS, parsedSignature.length() + 2);\n-            return (Type)ObjectType.getInstance(Utility.pathToPackage(parsedSignature));\n+        if (typeOfSignature != 13) {\n+            final String typeSignatureToString = Utility.typeSignatureToString(signature, false);\n+            wrap(Type.CONSUMED_CHARS, typeSignatureToString.length() + 2);\n+            return (Type)ObjectType.getInstance(Utility.pathToPackage(typeSignatureToString));\n         }\n-        int dim = 0;\n+        int n = 0;\n         do {\n-            ++dim;\n-        } while (signature.charAt(dim) == '[');\n-        final Type t = getType(signature.substring(dim));\n-        final int temp = unwrap(Type.CONSUMED_CHARS) + dim;\n-        wrap(Type.CONSUMED_CHARS, temp);\n-        return (Type)new ArrayType(t, dim);\n+            ++n;\n+        } while (signature.charAt(n) == '[');\n+        final Type type = getType(signature.substring(n));\n+        wrap(Type.CONSUMED_CHARS, unwrap(Type.CONSUMED_CHARS) + n);\n+        return (Type)new ArrayType(type, n);\n     }\n     \n     public static Type[] getTypes(final Class<?>[] classes) {\n-        final Type[] ret = new Type[classes.length];\n-        Arrays.setAll(ret, i -> getType(classes[i]));\n-        return ret;\n+        final Type[] array = new Type[classes.length];\n+        Arrays.setAll(array, n2 -> getType(array2[n2]));\n+        return array;\n     }\n     \n     static int getTypeSize(final String signature) throws StringIndexOutOfBoundsException {\n-        final byte type = Utility.typeOfSignature(signature);\n-        if (type <= 12) {\n-            return encode(BasicType.getType(type).getSize(), 1);\n+        final byte typeOfSignature = Utility.typeOfSignature(signature);\n+        if (typeOfSignature <= 12) {\n+            return encode(BasicType.getType(typeOfSignature).getSize(), 1);\n         }\n-        if (type == 13) {\n-            int dim = 0;\n+        if (typeOfSignature == 13) {\n+            int n = 0;\n             do {\n-                ++dim;\n-            } while (signature.charAt(dim) == '[');\n-            final int consumed = consumed(getTypeSize(signature.substring(dim)));\n-            return encode(1, dim + consumed);\n+                ++n;\n+            } while (signature.charAt(n) == '[');\n+            return encode(1, n + consumed(getTypeSize(signature.substring(n))));\n         }\n         final int index = signature.indexOf(59);\n         if (index < 0) {\n             throw new ClassFormatException(\"Invalid signature: \" + signature);\n         }\n         return encode(1, index + 1);\n     }\n@@ -221,16 +215,16 @@\n         this.type = type;\n         this.signature = signature;\n     }\n     \n     @Override\n     public boolean equals(final Object o) {\n         if (o instanceof Type) {\n-            final Type t = (Type)o;\n-            return this.type == t.type && this.signature.equals(t.signature);\n+            final Type type = (Type)o;\n+            return this.type == type.type && this.signature.equals(type.signature);\n         }\n         return false;\n     }\n     \n     public String getClassName() {\n         return this.toString();\n     }\n"}]}
