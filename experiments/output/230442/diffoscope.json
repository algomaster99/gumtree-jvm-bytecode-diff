{"diffoscope-json-version": 1, "source1": "first/FixedLengthBlockOutputStream.class", "source2": "second/FixedLengthBlockOutputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -13,102 +13,100 @@\n public class FixedLengthBlockOutputStream extends OutputStream implements WritableByteChannel\n {\n     private final WritableByteChannel out;\n     private final int blockSize;\n     private final ByteBuffer buffer;\n     private final AtomicBoolean closed;\n     \n-    public FixedLengthBlockOutputStream(final OutputStream os, final int blockSize) {\n+    public FixedLengthBlockOutputStream(final OutputStream outputStream, final int blockSize) {\n         this.closed = new AtomicBoolean(false);\n-        if (os instanceof FileOutputStream) {\n-            final FileOutputStream fileOutputStream = (FileOutputStream)os;\n-            this.out = fileOutputStream.getChannel();\n+        if (outputStream instanceof FileOutputStream) {\n+            this.out = ((FileOutputStream)outputStream).getChannel();\n             this.buffer = ByteBuffer.allocateDirect(blockSize);\n         }\n         else {\n-            this.out = (WritableByteChannel)new FixedLengthBlockOutputStream.BufferAtATimeOutputChannel(os, (FixedLengthBlockOutputStream.FixedLengthBlockOutputStream$1)null);\n+            this.out = (WritableByteChannel)new FixedLengthBlockOutputStream.BufferAtATimeOutputChannel(outputStream, (FixedLengthBlockOutputStream.FixedLengthBlockOutputStream$1)null);\n             this.buffer = ByteBuffer.allocate(blockSize);\n         }\n         this.blockSize = blockSize;\n     }\n     \n-    public FixedLengthBlockOutputStream(final WritableByteChannel out, final int blockSize) {\n+    public FixedLengthBlockOutputStream(final WritableByteChannel out, final int n) {\n         this.closed = new AtomicBoolean(false);\n         this.out = out;\n-        this.blockSize = blockSize;\n-        this.buffer = ByteBuffer.allocateDirect(blockSize);\n+        this.blockSize = n;\n+        this.buffer = ByteBuffer.allocateDirect(n);\n     }\n     \n     private void maybeFlush() throws IOException {\n         if (!this.buffer.hasRemaining()) {\n             this.writeBlock();\n         }\n     }\n     \n     private void writeBlock() throws IOException {\n         this.buffer.flip();\n-        final int i = this.out.write(this.buffer);\n+        final int write = this.out.write(this.buffer);\n         final boolean hasRemaining = this.buffer.hasRemaining();\n-        if (i != this.blockSize || hasRemaining) {\n-            final String msg = String.format(\"Failed to write %,d bytes atomically. Only wrote  %,d\", Integer.valueOf(this.blockSize), Integer.valueOf(i));\n-            throw new IOException(msg);\n+        if (write != this.blockSize || hasRemaining) {\n+            throw new IOException(String.format(\"Failed to write %,d bytes atomically. Only wrote  %,d\", Integer.valueOf(this.blockSize), Integer.valueOf(write)));\n         }\n         this.buffer.clear();\n     }\n     \n     @Override\n-    public void write(final int b) throws IOException {\n+    public void write(final int n) throws IOException {\n         if (!this.isOpen()) {\n             throw new ClosedChannelException();\n         }\n-        this.buffer.put((byte)b);\n+        this.buffer.put((byte)n);\n         this.maybeFlush();\n     }\n     \n     @Override\n-    public void write(final byte[] b, final int offset, final int length) throws IOException {\n+    public void write(final byte[] src, final int n, final int n2) throws IOException {\n         if (!this.isOpen()) {\n             throw new ClosedChannelException();\n         }\n-        int n;\n-        for (int off = offset, len = length; len > 0; len -= n, off += n) {\n-            n = Math.min(len, this.buffer.remaining());\n-            this.buffer.put(b, off, n);\n+        int min;\n+        for (int offset = n, i = n2; i > 0; i -= min, offset += min) {\n+            min = Math.min(i, this.buffer.remaining());\n+            this.buffer.put(src, offset, min);\n             this.maybeFlush();\n         }\n     }\n     \n     @Override\n     public int write(final ByteBuffer src) throws IOException {\n         if (!this.isOpen()) {\n             throw new ClosedChannelException();\n         }\n-        final int srcRemaining = src.remaining();\n-        if (srcRemaining < this.buffer.remaining()) {\n+        final int remaining = src.remaining();\n+        if (remaining < this.buffer.remaining()) {\n             this.buffer.put(src);\n         }\n         else {\n-            int srcLeft = srcRemaining;\n-            final int savedLimit = src.limit();\n+            int i = remaining;\n+            final int limit = src.limit();\n             if (this.buffer.position() != 0) {\n-                final int n = this.buffer.remaining();\n-                src.limit(src.position() + n);\n+                final int remaining2 = this.buffer.remaining();\n+                src.limit(src.position() + remaining2);\n                 this.buffer.put(src);\n                 this.writeBlock();\n-                srcLeft -= n;\n+                i -= remaining2;\n             }\n-            while (srcLeft >= this.blockSize) {\n+            while (i >= this.blockSize) {\n                 src.limit(src.position() + this.blockSize);\n                 this.out.write(src);\n-                srcLeft -= this.blockSize;\n+                i -= this.blockSize;\n             }\n-            src.limit(savedLimit);\n+            src.limit(limit);\n             this.buffer.put(src);\n         }\n-        return srcRemaining;\n+        return remaining;\n     }\n     \n     @Override\n     public boolean isOpen() {\n         if (!this.out.isOpen()) {\n             this.closed.set(true);\n         }\n@@ -132,27 +130,27 @@\n                 this.out.close();\n             }\n         }\n     }\n     \n     private void padBlock() {\n         this.buffer.order(ByteOrder.nativeOrder());\n-        int bytesToWrite = this.buffer.remaining();\n-        if (bytesToWrite > 8) {\n-            final int align = this.buffer.position() & 0x7;\n-            if (align != 0) {\n-                final int limit = 8 - align;\n-                for (int i = 0; i < limit; ++i) {\n+        int i = this.buffer.remaining();\n+        if (i > 8) {\n+            final int n = this.buffer.position() & 0x7;\n+            if (n != 0) {\n+                final int n2 = 8 - n;\n+                for (int j = 0; j < n2; ++j) {\n                     this.buffer.put((byte)0);\n                 }\n-                bytesToWrite -= limit;\n+                i -= n2;\n             }\n-            while (bytesToWrite >= 8) {\n+            while (i >= 8) {\n                 this.buffer.putLong(0L);\n-                bytesToWrite -= 8;\n+                i -= 8;\n             }\n         }\n         while (this.buffer.hasRemaining()) {\n             this.buffer.put((byte)0);\n         }\n     }\n }\n"}]}
