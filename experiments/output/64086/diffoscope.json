{"diffoscope-json-version": 1, "source1": "first/Lang.class", "source2": "second/Lang.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,88 +1,99 @@\n \n package org.apache.commons.codec.language.bm;\n \n-import java.util.EnumMap;\n import java.util.Locale;\n import java.util.Collections;\n import java.util.Set;\n import java.util.Collection;\n import java.util.HashSet;\n import java.util.Arrays;\n import java.util.regex.Pattern;\n import java.util.Scanner;\n import org.apache.commons.codec.Resources;\n import java.util.ArrayList;\n+import java.util.EnumMap;\n import java.util.List;\n import java.util.Map;\n \n public class Lang\n {\n     private static final Map<NameType, Lang> LANGS;\n     private static final String LANGUAGE_RULES_RN = \"org/apache/commons/codec/language/bm/%s_lang.txt\";\n     private final Languages languages;\n     private final List<Lang.LangRule> rules;\n     \n+    static {\n+        LANGS = new EnumMap<NameType, Lang>(NameType.class);\n+        NameType[] values;\n+        for (int length = (values = NameType.values()).length, i = 0; i < length; ++i) {\n+            final NameType s = values[i];\n+            Lang.LANGS.put(s, loadFromResource(String.format(\"org/apache/commons/codec/language/bm/%s_lang.txt\", s.getName()), Languages.getInstance(s)));\n+        }\n+    }\n+    \n     public static Lang instance(final NameType nameType) {\n         return Lang.LANGS.get(nameType);\n     }\n     \n     public static Lang loadFromResource(final String languageRulesResourceName, final Languages languages) {\n         final List<Lang.LangRule> rules = new ArrayList<Lang.LangRule>();\n-        final Scanner scanner = new Scanner(Resources.getInputStream(languageRulesResourceName), \"UTF-8\");\n         Throwable t = null;\n         try {\n-            boolean inExtendedComment = false;\n-            while (scanner.hasNextLine()) {\n-                String line;\n-                final String rawLine = line = scanner.nextLine();\n-                if (inExtendedComment) {\n-                    if (!line.endsWith(\"*/\")) {\n-                        continue;\n+            final Scanner scanner = new Scanner(Resources.getInputStream(languageRulesResourceName), \"UTF-8\");\n+            try {\n+                boolean inExtendedComment = false;\n+                while (scanner.hasNextLine()) {\n+                    String line;\n+                    final String rawLine = line = scanner.nextLine();\n+                    if (inExtendedComment) {\n+                        if (!line.endsWith(\"*/\")) {\n+                            continue;\n+                        }\n+                        inExtendedComment = false;\n                     }\n-                    inExtendedComment = false;\n-                }\n-                else if (line.startsWith(\"/*\")) {\n-                    inExtendedComment = true;\n-                }\n-                else {\n-                    final int cmtI = line.indexOf(\"//\");\n-                    if (cmtI >= 0) {\n-                        line = line.substring(0, cmtI);\n+                    else if (line.startsWith(\"/*\")) {\n+                        inExtendedComment = true;\n                     }\n-                    line = line.trim();\n-                    if (line.isEmpty()) {\n-                        continue;\n+                    else {\n+                        final int cmtI = line.indexOf(\"//\");\n+                        if (cmtI >= 0) {\n+                            line = line.substring(0, cmtI);\n+                        }\n+                        line = line.trim();\n+                        if (line.isEmpty()) {\n+                            continue;\n+                        }\n+                        final String[] parts = line.split(\"\\\\s+\");\n+                        if (parts.length != 3) {\n+                            throw new IllegalArgumentException(\"Malformed line '\" + rawLine + \"' in language resource '\" + languageRulesResourceName + \"'\");\n+                        }\n+                        final Pattern pattern = Pattern.compile(parts[0]);\n+                        final String[] langs = parts[1].split(\"\\\\+\");\n+                        final boolean accept = parts[2].equals(\"true\");\n+                        rules.add(new Lang.LangRule(pattern, (Set)new HashSet(Arrays.asList(langs)), accept, (Lang.LangRule)null));\n                     }\n-                    final String[] parts = line.split(\"\\\\s+\");\n-                    if (parts.length != 3) {\n-                        throw new IllegalArgumentException(\"Malformed line '\" + rawLine + \"' in language resource '\" + languageRulesResourceName + \"'\");\n-                    }\n-                    final Pattern pattern = Pattern.compile(parts[0]);\n-                    final String[] langs = parts[1].split(\"\\\\+\");\n-                    final boolean accept = parts[2].equals(\"true\");\n-                    rules.add(new Lang.LangRule(pattern, (Set)new HashSet(Arrays.asList(langs)), accept, (Lang.Lang$1)null));\n                 }\n             }\n-        }\n-        catch (final Throwable t2) {\n-            t = t2;\n-            throw t2;\n-        }\n-        finally {\n-            if (t != null) {\n-                try {\n+            finally {\n+                if (scanner != null) {\n                     scanner.close();\n                 }\n-                catch (final Throwable exception) {\n-                    t.addSuppressed(exception);\n-                }\n+            }\n+        }\n+        finally {\n+            if (t == null) {\n+                final Throwable exception;\n+                t = exception;\n             }\n             else {\n-                scanner.close();\n+                final Throwable exception;\n+                if (t != exception) {\n+                    t.addSuppressed(exception);\n+                }\n             }\n         }\n         return new Lang(rules, languages);\n     }\n     \n     private Lang(final List<Lang.LangRule> rules, final Languages languages) {\n         this.rules = Collections.unmodifiableList((List<? extends Lang.LangRule>)rules);\n@@ -94,28 +105,21 @@\n         return ls.isSingleton() ? ls.getAny() : \"any\";\n     }\n     \n     public Languages.LanguageSet guessLanguages(final String input) {\n         final String text = input.toLowerCase(Locale.ENGLISH);\n         final Set<String> langs = new HashSet<String>(this.languages.getLanguages());\n         this.rules.forEach(rule -> {\n-            if (rule.matches(text)) {\n-                if (Lang.LangRule.access$100(rule)) {\n-                    langs.retainAll(Lang.LangRule.access$200(rule));\n+            if (rule.matches(s)) {\n+                if (Lang.LangRule.access$1(rule)) {\n+                    set.retainAll(Lang.LangRule.access$2(rule));\n                 }\n                 else {\n-                    langs.removeAll(Lang.LangRule.access$200(rule));\n+                    set.removeAll(Lang.LangRule.access$2(rule));\n                 }\n             }\n             return;\n         });\n         final Languages.LanguageSet ls = Languages.LanguageSet.from((Set)langs);\n         return ls.equals(Languages.NO_LANGUAGES) ? Languages.ANY_LANGUAGE : ls;\n     }\n-    \n-    static {\n-        LANGS = new EnumMap<NameType, Lang>(NameType.class);\n-        for (final NameType s : NameType.values()) {\n-            Lang.LANGS.put(s, loadFromResource(String.format(\"org/apache/commons/codec/language/bm/%s_lang.txt\", s.getName()), Languages.getInstance(s)));\n-        }\n-    }\n }\n"}]}
