{"diffoscope-json-version": 1, "source1": "first/LZ77Compressor.class", "source2": "second/LZ77Compressor.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -37,216 +37,213 @@\n             throw new NullPointerException(\"params must not be null\");\n         }\n         if (callback == null) {\n             throw new NullPointerException(\"callback must not be null\");\n         }\n         this.params = params;\n         this.callback = callback;\n-        final int wSize = params.getWindowSize();\n-        this.window = new byte[wSize * 2];\n-        this.wMask = wSize - 1;\n+        final int windowSize = params.getWindowSize();\n+        this.window = new byte[windowSize * 2];\n+        this.wMask = windowSize - 1;\n         Arrays.fill(this.head = new int[32768], -1);\n-        this.prev = new int[wSize];\n+        this.prev = new int[windowSize];\n     }\n     \n-    public void compress(final byte[] data) throws IOException {\n-        this.compress(data, 0, data.length);\n+    public void compress(final byte[] array) throws IOException {\n+        this.compress(array, 0, array.length);\n     }\n     \n-    public void compress(final byte[] data, int off, int len) throws IOException {\n-        for (int wSize = this.params.getWindowSize(); len > wSize; len -= wSize) {\n-            this.doCompress(data, off, wSize);\n-            off += wSize;\n+    public void compress(final byte[] array, int n, int i) throws IOException {\n+        for (int windowSize = this.params.getWindowSize(); i > windowSize; i -= windowSize) {\n+            this.doCompress(array, n, windowSize);\n+            n += windowSize;\n         }\n-        if (len > 0) {\n-            this.doCompress(data, off, len);\n+        if (i > 0) {\n+            this.doCompress(array, n, i);\n         }\n     }\n     \n     public void finish() throws IOException {\n         if (this.blockStart != this.currentPosition || this.lookahead > 0) {\n             this.currentPosition += this.lookahead;\n             this.flushLiteralBlock();\n         }\n         this.callback.accept(LZ77Compressor.THE_EOD);\n     }\n     \n-    public void prefill(final byte[] data) {\n+    public void prefill(final byte[] array) {\n         if (this.currentPosition != 0 || this.lookahead != 0) {\n             throw new IllegalStateException(\"the compressor has already started to accept data, can't prefill anymore\");\n         }\n-        final int len = Math.min(this.params.getWindowSize(), data.length);\n-        System.arraycopy(data, data.length - len, this.window, 0, len);\n-        if (len >= 3) {\n+        final int min = Math.min(this.params.getWindowSize(), array.length);\n+        System.arraycopy(array, array.length - min, this.window, 0, min);\n+        if (min >= 3) {\n             this.initialize();\n-            for (int stop = len - 3 + 1, i = 0; i < stop; ++i) {\n+            for (int n = min - 3 + 1, i = 0; i < n; ++i) {\n                 this.insertString(i);\n             }\n             this.missedInserts = 2;\n         }\n         else {\n-            this.missedInserts = len;\n+            this.missedInserts = min;\n         }\n-        final int n = len;\n-        this.currentPosition = n;\n-        this.blockStart = n;\n+        final int n2 = min;\n+        this.currentPosition = n2;\n+        this.blockStart = n2;\n     }\n     \n-    private int nextHash(final int oldHash, final byte nextByte) {\n-        final int nextVal = nextByte & 0xFF;\n-        return (oldHash << 5 ^ nextVal) & 0x7FFF;\n+    private int nextHash(final int n, final byte b) {\n+        return (n << 5 ^ (b & 0xFF)) & 0x7FFF;\n     }\n     \n-    private void doCompress(final byte[] data, final int off, final int len) throws IOException {\n-        final int spaceLeft = this.window.length - this.currentPosition - this.lookahead;\n-        if (len > spaceLeft) {\n+    private void doCompress(final byte[] array, final int n, final int n2) throws IOException {\n+        if (n2 > this.window.length - this.currentPosition - this.lookahead) {\n             this.slide();\n         }\n-        System.arraycopy(data, off, this.window, this.currentPosition + this.lookahead, len);\n-        this.lookahead += len;\n+        System.arraycopy(array, n, this.window, this.currentPosition + this.lookahead, n2);\n+        this.lookahead += n2;\n         if (!this.initialized && this.lookahead >= this.params.getMinBackReferenceLength()) {\n             this.initialize();\n         }\n         if (this.initialized) {\n             this.compress();\n         }\n     }\n     \n     private void slide() throws IOException {\n-        final int wSize = this.params.getWindowSize();\n-        if (this.blockStart != this.currentPosition && this.blockStart < wSize) {\n+        final int windowSize = this.params.getWindowSize();\n+        if (this.blockStart != this.currentPosition && this.blockStart < windowSize) {\n             this.flushLiteralBlock();\n             this.blockStart = this.currentPosition;\n         }\n-        System.arraycopy(this.window, wSize, this.window, 0, wSize);\n-        this.currentPosition -= wSize;\n-        this.matchStart -= wSize;\n-        this.blockStart -= wSize;\n+        System.arraycopy(this.window, windowSize, this.window, 0, windowSize);\n+        this.currentPosition -= windowSize;\n+        this.matchStart -= windowSize;\n+        this.blockStart -= windowSize;\n         for (int i = 0; i < 32768; ++i) {\n-            final int h = this.head[i];\n-            this.head[i] = ((h >= wSize) ? (h - wSize) : -1);\n+            final int n = this.head[i];\n+            this.head[i] = ((n >= windowSize) ? (n - windowSize) : -1);\n         }\n-        for (int i = 0; i < wSize; ++i) {\n-            final int p = this.prev[i];\n-            this.prev[i] = ((p >= wSize) ? (p - wSize) : -1);\n+        for (int j = 0; j < windowSize; ++j) {\n+            final int n2 = this.prev[j];\n+            this.prev[j] = ((n2 >= windowSize) ? (n2 - windowSize) : -1);\n         }\n     }\n     \n     private void initialize() {\n         for (int i = 0; i < 2; ++i) {\n             this.insertHash = this.nextHash(this.insertHash, this.window[i]);\n         }\n         this.initialized = true;\n     }\n     \n     private void compress() throws IOException {\n-        final int minMatch = this.params.getMinBackReferenceLength();\n-        final boolean lazy = this.params.getLazyMatching();\n-        final int lazyThreshold = this.params.getLazyMatchingThreshold();\n-        while (this.lookahead >= minMatch) {\n+        final int minBackReferenceLength = this.params.getMinBackReferenceLength();\n+        final boolean lazyMatching = this.params.getLazyMatching();\n+        final int lazyMatchingThreshold = this.params.getLazyMatchingThreshold();\n+        while (this.lookahead >= minBackReferenceLength) {\n             this.catchUpMissedInserts();\n-            int matchLength = 0;\n-            final int hashHead = this.insertString(this.currentPosition);\n-            if (hashHead != -1 && hashHead - this.currentPosition <= this.params.getMaxOffset()) {\n-                matchLength = this.longestMatch(hashHead);\n-                if (lazy && matchLength <= lazyThreshold && this.lookahead > minMatch) {\n-                    matchLength = this.longestMatchForNextPosition(matchLength);\n+            int n = 0;\n+            final int insertString = this.insertString(this.currentPosition);\n+            if (insertString != -1 && insertString - this.currentPosition <= this.params.getMaxOffset()) {\n+                n = this.longestMatch(insertString);\n+                if (lazyMatching && n <= lazyMatchingThreshold && this.lookahead > minBackReferenceLength) {\n+                    n = this.longestMatchForNextPosition(n);\n                 }\n             }\n-            if (matchLength >= minMatch) {\n+            if (n >= minBackReferenceLength) {\n                 if (this.blockStart != this.currentPosition) {\n                     this.flushLiteralBlock();\n                     this.blockStart = -1;\n                 }\n-                this.flushBackReference(matchLength);\n-                this.insertStringsInMatch(matchLength);\n-                this.lookahead -= matchLength;\n-                this.currentPosition += matchLength;\n+                this.flushBackReference(n);\n+                this.insertStringsInMatch(n);\n+                this.lookahead -= n;\n+                this.currentPosition += n;\n                 this.blockStart = this.currentPosition;\n             }\n             else {\n                 --this.lookahead;\n                 ++this.currentPosition;\n                 if (this.currentPosition - this.blockStart < this.params.getMaxLiteralLength()) {\n                     continue;\n                 }\n                 this.flushLiteralBlock();\n                 this.blockStart = this.currentPosition;\n             }\n         }\n     }\n     \n-    private int insertString(final int pos) {\n-        this.insertHash = this.nextHash(this.insertHash, this.window[pos - 1 + 3]);\n-        final int hashHead = this.head[this.insertHash];\n-        this.prev[pos & this.wMask] = hashHead;\n-        this.head[this.insertHash] = pos;\n-        return hashHead;\n+    private int insertString(final int n) {\n+        this.insertHash = this.nextHash(this.insertHash, this.window[n - 1 + 3]);\n+        final int n2 = this.head[this.insertHash];\n+        this.prev[n & this.wMask] = n2;\n+        this.head[this.insertHash] = n;\n+        return n2;\n     }\n     \n-    private int longestMatchForNextPosition(final int prevMatchLength) {\n-        final int prevMatchStart = this.matchStart;\n-        final int prevInsertHash = this.insertHash;\n+    private int longestMatchForNextPosition(final int n) {\n+        final int matchStart = this.matchStart;\n+        final int insertHash = this.insertHash;\n         --this.lookahead;\n         ++this.currentPosition;\n-        final int hashHead = this.insertString(this.currentPosition);\n-        final int prevHashHead = this.prev[this.currentPosition & this.wMask];\n-        int matchLength = this.longestMatch(hashHead);\n-        if (matchLength <= prevMatchLength) {\n-            matchLength = prevMatchLength;\n-            this.matchStart = prevMatchStart;\n-            this.head[this.insertHash] = prevHashHead;\n-            this.insertHash = prevInsertHash;\n+        final int insertString = this.insertString(this.currentPosition);\n+        final int n2 = this.prev[this.currentPosition & this.wMask];\n+        int longestMatch = this.longestMatch(insertString);\n+        if (longestMatch <= n) {\n+            longestMatch = n;\n+            this.matchStart = matchStart;\n+            this.head[this.insertHash] = n2;\n+            this.insertHash = insertHash;\n             --this.currentPosition;\n             ++this.lookahead;\n         }\n-        return matchLength;\n+        return longestMatch;\n     }\n     \n-    private void insertStringsInMatch(final int matchLength) {\n-        final int stop = Math.min(matchLength - 1, this.lookahead - 3);\n-        for (int i = 1; i <= stop; ++i) {\n+    private void insertStringsInMatch(final int n) {\n+        final int min = Math.min(n - 1, this.lookahead - 3);\n+        for (int i = 1; i <= min; ++i) {\n             this.insertString(this.currentPosition + i);\n         }\n-        this.missedInserts = matchLength - stop - 1;\n+        this.missedInserts = n - min - 1;\n     }\n     \n     private void catchUpMissedInserts() {\n         while (this.missedInserts > 0) {\n             this.insertString(this.currentPosition - this.missedInserts--);\n         }\n     }\n     \n-    private void flushBackReference(final int matchLength) throws IOException {\n-        this.callback.accept((LZ77Compressor.Block)new LZ77Compressor.BackReference(this.currentPosition - this.matchStart, matchLength));\n+    private void flushBackReference(final int n) throws IOException {\n+        this.callback.accept((LZ77Compressor.Block)new LZ77Compressor.BackReference(this.currentPosition - this.matchStart, n));\n     }\n     \n     private void flushLiteralBlock() throws IOException {\n         this.callback.accept((LZ77Compressor.Block)new LZ77Compressor.LiteralBlock(this.window, this.blockStart, this.currentPosition - this.blockStart));\n     }\n     \n-    private int longestMatch(int matchHead) {\n-        final int minLength = this.params.getMinBackReferenceLength();\n-        int longestMatchLength = minLength - 1;\n-        final int maxPossibleLength = Math.min(this.params.getMaxBackReferenceLength(), this.lookahead);\n-        final int minIndex = Math.max(0, this.currentPosition - this.params.getMaxOffset());\n-        final int niceBackReferenceLength = Math.min(maxPossibleLength, this.params.getNiceBackReferenceLength());\n-        for (int maxCandidates = this.params.getMaxCandidates(), candidates = 0; candidates < maxCandidates && matchHead >= minIndex; matchHead = this.prev[matchHead & this.wMask], ++candidates) {\n-            int currentLength = 0;\n-            for (int i = 0; i < maxPossibleLength && this.window[matchHead + i] == this.window[this.currentPosition + i]; ++i) {\n-                ++currentLength;\n-            }\n-            if (currentLength > longestMatchLength) {\n-                longestMatchLength = currentLength;\n-                this.matchStart = matchHead;\n-                if (currentLength >= niceBackReferenceLength) {\n+    private int longestMatch(int matchStart) {\n+        int n = this.params.getMinBackReferenceLength() - 1;\n+        final int min = Math.min(this.params.getMaxBackReferenceLength(), this.lookahead);\n+        final int max = Math.max(0, this.currentPosition - this.params.getMaxOffset());\n+        final int min2 = Math.min(min, this.params.getNiceBackReferenceLength());\n+        for (int maxCandidates = this.params.getMaxCandidates(), n2 = 0; n2 < maxCandidates && matchStart >= max; matchStart = this.prev[matchStart & this.wMask], ++n2) {\n+            int n3 = 0;\n+            for (int n4 = 0; n4 < min && this.window[matchStart + n4] == this.window[this.currentPosition + n4]; ++n4) {\n+                ++n3;\n+            }\n+            if (n3 > n) {\n+                n = n3;\n+                this.matchStart = matchStart;\n+                if (n3 >= min2) {\n                     break;\n                 }\n             }\n         }\n-        return longestMatchLength;\n+        return n;\n     }\n     \n     static {\n         THE_EOD = (LZ77Compressor.Block)new LZ77Compressor.EOD();\n     }\n }\n"}]}
