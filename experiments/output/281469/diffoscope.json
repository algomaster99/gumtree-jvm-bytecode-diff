{"diffoscope-json-version": 1, "source1": "first/PathUtils.class", "source2": "second/PathUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,15 +1,14 @@\n \n package org.apache.commons.io.file;\n \n import java.net.URI;\n import java.nio.file.FileVisitor;\n import java.util.EnumSet;\n import java.util.Set;\n-import java.nio.file.attribute.PosixFileAttributes;\n import java.util.Arrays;\n import org.apache.commons.io.IOExceptionList;\n import java.nio.file.attribute.PosixFilePermission;\n import java.nio.file.attribute.PosixFileAttributeView;\n import java.nio.file.attribute.DosFileAttributeView;\n import java.util.ArrayList;\n import java.util.function.Function;\n@@ -48,51 +47,51 @@\n     public static final DeleteOption[] EMPTY_DELETE_OPTION_ARRAY;\n     public static final FileVisitOption[] EMPTY_FILE_VISIT_OPTION_ARRAY;\n     public static final LinkOption[] EMPTY_LINK_OPTION_ARRAY;\n     public static final LinkOption[] NOFOLLOW_LINK_OPTION_ARRAY;\n     public static final OpenOption[] EMPTY_OPEN_OPTION_ARRAY;\n     public static final Path[] EMPTY_PATH_ARRAY;\n     \n-    private static AccumulatorPathVisitor accumulate(final Path directory, final int maxDepth, final FileVisitOption[] fileVisitOptions) throws IOException {\n-        return visitFileTree(AccumulatorPathVisitor.withLongCounters(), directory, toFileVisitOptionSet(fileVisitOptions), maxDepth);\n+    private static AccumulatorPathVisitor accumulate(final Path path, final int n, final FileVisitOption[] array) throws IOException {\n+        return visitFileTree(AccumulatorPathVisitor.withLongCounters(), path, toFileVisitOptionSet(array), n);\n     }\n     \n-    public static Counters.PathCounters cleanDirectory(final Path directory) throws IOException {\n-        return cleanDirectory(directory, PathUtils.EMPTY_DELETE_OPTION_ARRAY);\n+    public static Counters.PathCounters cleanDirectory(final Path path) throws IOException {\n+        return cleanDirectory(path, PathUtils.EMPTY_DELETE_OPTION_ARRAY);\n     }\n     \n-    public static Counters.PathCounters cleanDirectory(final Path directory, final DeleteOption... deleteOptions) throws IOException {\n-        return ((CleaningPathVisitor)visitFileTree(new CleaningPathVisitor(Counters.longPathCounters(), deleteOptions, new String[0]), directory)).getPathCounters();\n+    public static Counters.PathCounters cleanDirectory(final Path path, final DeleteOption... array) throws IOException {\n+        return ((CleaningPathVisitor)visitFileTree(new CleaningPathVisitor(Counters.longPathCounters(), array, new String[0]), path)).getPathCounters();\n     }\n     \n-    public static Counters.PathCounters copyDirectory(final Path sourceDirectory, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n-        final Path absoluteSource = sourceDirectory.toAbsolutePath();\n-        return ((CopyDirectoryVisitor)visitFileTree(new CopyDirectoryVisitor(Counters.longPathCounters(), absoluteSource, targetDirectory, copyOptions), absoluteSource)).getPathCounters();\n+    public static Counters.PathCounters copyDirectory(final Path path, final Path path2, final CopyOption... array) throws IOException {\n+        final Path absolutePath = path.toAbsolutePath();\n+        return ((CopyDirectoryVisitor)visitFileTree(new CopyDirectoryVisitor(Counters.longPathCounters(), absolutePath, path2, array), absolutePath)).getPathCounters();\n     }\n     \n-    public static Path copyFile(final URL sourceFile, final Path targetFile, final CopyOption... copyOptions) throws IOException {\n-        try (final InputStream inputStream = sourceFile.openStream()) {\n-            Files.copy(inputStream, targetFile, copyOptions);\n-            return targetFile;\n+    public static Path copyFile(final URL url, final Path target, final CopyOption... options) throws IOException {\n+        try (final InputStream openStream = url.openStream()) {\n+            Files.copy(openStream, target, options);\n+            return target;\n         }\n     }\n     \n-    public static Path copyFileToDirectory(final Path sourceFile, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n-        return Files.copy(sourceFile, targetDirectory.resolve(sourceFile.getFileName()), copyOptions);\n+    public static Path copyFileToDirectory(final Path source, final Path path, final CopyOption... options) throws IOException {\n+        return Files.copy(source, path.resolve(source.getFileName()), options);\n     }\n     \n-    public static Path copyFileToDirectory(final URL sourceFile, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n-        try (final InputStream inputStream = sourceFile.openStream()) {\n-            Files.copy(inputStream, targetDirectory.resolve(sourceFile.getFile()), copyOptions);\n-            return targetDirectory;\n+    public static Path copyFileToDirectory(final URL url, final Path path, final CopyOption... options) throws IOException {\n+        try (final InputStream openStream = url.openStream()) {\n+            Files.copy(openStream, path.resolve(url.getFile()), options);\n+            return path;\n         }\n     }\n     \n-    public static Counters.PathCounters countDirectory(final Path directory) throws IOException {\n-        return ((CountingPathVisitor)visitFileTree(new CountingPathVisitor(Counters.longPathCounters()), directory)).getPathCounters();\n+    public static Counters.PathCounters countDirectory(final Path path) throws IOException {\n+        return ((CountingPathVisitor)visitFileTree(new CountingPathVisitor(Counters.longPathCounters()), path)).getPathCounters();\n     }\n     \n     public static Path createParentDirectories(final Path path, final FileAttribute<?>... attrs) throws IOException {\n         final Path parent = path.getParent();\n         if (parent == null) {\n             return null;\n         }\n@@ -103,280 +102,278 @@\n         return Paths.get(\"\", new String[0]);\n     }\n     \n     public static Counters.PathCounters delete(final Path path) throws IOException {\n         return delete(path, PathUtils.EMPTY_DELETE_OPTION_ARRAY);\n     }\n     \n-    public static Counters.PathCounters delete(final Path path, final DeleteOption... deleteOptions) throws IOException {\n-        return Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS) ? deleteDirectory(path, deleteOptions) : deleteFile(path, deleteOptions);\n+    public static Counters.PathCounters delete(final Path path, final DeleteOption... array) throws IOException {\n+        return Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS) ? deleteDirectory(path, array) : deleteFile(path, array);\n     }\n     \n-    public static Counters.PathCounters delete(final Path path, final LinkOption[] linkOptions, final DeleteOption... deleteOptions) throws IOException {\n-        return Files.isDirectory(path, linkOptions) ? deleteDirectory(path, linkOptions, deleteOptions) : deleteFile(path, linkOptions, deleteOptions);\n+    public static Counters.PathCounters delete(final Path path, final LinkOption[] options, final DeleteOption... array) throws IOException {\n+        return Files.isDirectory(path, options) ? deleteDirectory(path, options, array) : deleteFile(path, options, array);\n     }\n     \n-    public static Counters.PathCounters deleteDirectory(final Path directory) throws IOException {\n-        return deleteDirectory(directory, PathUtils.EMPTY_DELETE_OPTION_ARRAY);\n+    public static Counters.PathCounters deleteDirectory(final Path path) throws IOException {\n+        return deleteDirectory(path, PathUtils.EMPTY_DELETE_OPTION_ARRAY);\n     }\n     \n-    public static Counters.PathCounters deleteDirectory(final Path directory, final DeleteOption... deleteOptions) throws IOException {\n-        return ((DeletingPathVisitor)visitFileTree(new DeletingPathVisitor(Counters.longPathCounters(), PathUtils.NOFOLLOW_LINK_OPTION_ARRAY, deleteOptions, new String[0]), directory)).getPathCounters();\n+    public static Counters.PathCounters deleteDirectory(final Path path, final DeleteOption... array) throws IOException {\n+        return ((DeletingPathVisitor)visitFileTree(new DeletingPathVisitor(Counters.longPathCounters(), PathUtils.NOFOLLOW_LINK_OPTION_ARRAY, array, new String[0]), path)).getPathCounters();\n     }\n     \n-    public static Counters.PathCounters deleteDirectory(final Path directory, final LinkOption[] linkOptions, final DeleteOption... deleteOptions) throws IOException {\n-        return ((DeletingPathVisitor)visitFileTree(new DeletingPathVisitor(Counters.longPathCounters(), linkOptions, deleteOptions, new String[0]), directory)).getPathCounters();\n+    public static Counters.PathCounters deleteDirectory(final Path path, final LinkOption[] array, final DeleteOption... array2) throws IOException {\n+        return ((DeletingPathVisitor)visitFileTree(new DeletingPathVisitor(Counters.longPathCounters(), array, array2, new String[0]), path)).getPathCounters();\n     }\n     \n-    public static Counters.PathCounters deleteFile(final Path file) throws IOException {\n-        return deleteFile(file, PathUtils.EMPTY_DELETE_OPTION_ARRAY);\n+    public static Counters.PathCounters deleteFile(final Path path) throws IOException {\n+        return deleteFile(path, PathUtils.EMPTY_DELETE_OPTION_ARRAY);\n     }\n     \n-    public static Counters.PathCounters deleteFile(final Path file, final DeleteOption... deleteOptions) throws IOException {\n-        return deleteFile(file, PathUtils.NOFOLLOW_LINK_OPTION_ARRAY, deleteOptions);\n+    public static Counters.PathCounters deleteFile(final Path path, final DeleteOption... array) throws IOException {\n+        return deleteFile(path, PathUtils.NOFOLLOW_LINK_OPTION_ARRAY, array);\n     }\n     \n-    public static Counters.PathCounters deleteFile(final Path file, final LinkOption[] linkOptions, final DeleteOption... deleteOptions) throws NoSuchFileException, IOException {\n-        if (Files.isDirectory(file, linkOptions)) {\n-            throw new NoSuchFileException(file.toString());\n+    public static Counters.PathCounters deleteFile(final Path path, final LinkOption[] array, final DeleteOption... array2) throws NoSuchFileException, IOException {\n+        if (Files.isDirectory(path, array)) {\n+            throw new NoSuchFileException(path.toString());\n         }\n-        final Counters.PathCounters pathCounts = Counters.longPathCounters();\n-        final boolean exists = Files.exists(file, linkOptions);\n-        final long size = (exists && !Files.isSymbolicLink(file)) ? Files.size(file) : 0L;\n-        if (overrideReadOnly(deleteOptions) && exists) {\n-            setReadOnly(file, false, linkOptions);\n+        final Counters.PathCounters longPathCounters = Counters.longPathCounters();\n+        final boolean exists = Files.exists(path, array);\n+        final long n = (exists && !Files.isSymbolicLink(path)) ? Files.size(path) : 0L;\n+        if (overrideReadOnly(array2) && exists) {\n+            setReadOnly(path, false, array);\n         }\n-        if (Files.deleteIfExists(file)) {\n-            pathCounts.getFileCounter().increment();\n-            pathCounts.getByteCounter().add(size);\n+        if (Files.deleteIfExists(path)) {\n+            longPathCounters.getFileCounter().increment();\n+            longPathCounters.getByteCounter().add(n);\n         }\n-        return pathCounts;\n+        return longPathCounters;\n     }\n     \n-    public static boolean directoryAndFileContentEquals(final Path path1, final Path path2) throws IOException {\n-        return directoryAndFileContentEquals(path1, path2, PathUtils.EMPTY_LINK_OPTION_ARRAY, PathUtils.EMPTY_OPEN_OPTION_ARRAY, PathUtils.EMPTY_FILE_VISIT_OPTION_ARRAY);\n+    public static boolean directoryAndFileContentEquals(final Path path, final Path path2) throws IOException {\n+        return directoryAndFileContentEquals(path, path2, PathUtils.EMPTY_LINK_OPTION_ARRAY, PathUtils.EMPTY_OPEN_OPTION_ARRAY, PathUtils.EMPTY_FILE_VISIT_OPTION_ARRAY);\n     }\n     \n-    public static boolean directoryAndFileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions, final FileVisitOption[] fileVisitOption) throws IOException {\n-        if (path1 == null && path2 == null) {\n+    public static boolean directoryAndFileContentEquals(final Path path, final Path path2, final LinkOption[] array, final OpenOption[] array2, final FileVisitOption[] array3) throws IOException {\n+        if (path == null && path2 == null) {\n             return true;\n         }\n-        if (path1 == null || path2 == null) {\n+        if (path == null || path2 == null) {\n             return false;\n         }\n-        if (Files.notExists(path1, new LinkOption[0]) && Files.notExists(path2, new LinkOption[0])) {\n+        if (Files.notExists(path, new LinkOption[0]) && Files.notExists(path2, new LinkOption[0])) {\n             return true;\n         }\n-        final PathUtils.RelativeSortedPaths relativeSortedPaths = new PathUtils.RelativeSortedPaths(path1, path2, Integer.MAX_VALUE, linkOptions, fileVisitOption, (PathUtils.PathUtils$1)null);\n+        final PathUtils.RelativeSortedPaths relativeSortedPaths = new PathUtils.RelativeSortedPaths(path, path2, Integer.MAX_VALUE, array, array3, (PathUtils.PathUtils$1)null);\n         if (!relativeSortedPaths.equals) {\n             return false;\n         }\n-        final List<Path> fileList1 = relativeSortedPaths.relativeFileList1;\n-        final List<Path> fileList2 = relativeSortedPaths.relativeFileList2;\n-        for (final Path path3 : fileList1) {\n-            final int binarySearch = Collections.binarySearch(fileList2, path3);\n-            if (binarySearch <= -1) {\n+        final List relativeFileList1 = relativeSortedPaths.relativeFileList1;\n+        final List relativeFileList2 = relativeSortedPaths.relativeFileList2;\n+        for (final Path key : relativeFileList1) {\n+            if (Collections.binarySearch(relativeFileList2, key) <= -1) {\n                 throw new IllegalStateException(\"Unexpected mismatch.\");\n             }\n-            if (!fileContentEquals(path1.resolve(path3), path2.resolve(path3), linkOptions, openOptions)) {\n+            if (!fileContentEquals(path.resolve(key), path2.resolve(key), array, array2)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    public static boolean directoryContentEquals(final Path path1, final Path path2) throws IOException {\n-        return directoryContentEquals(path1, path2, Integer.MAX_VALUE, PathUtils.EMPTY_LINK_OPTION_ARRAY, PathUtils.EMPTY_FILE_VISIT_OPTION_ARRAY);\n+    public static boolean directoryContentEquals(final Path path, final Path path2) throws IOException {\n+        return directoryContentEquals(path, path2, Integer.MAX_VALUE, PathUtils.EMPTY_LINK_OPTION_ARRAY, PathUtils.EMPTY_FILE_VISIT_OPTION_ARRAY);\n     }\n     \n-    public static boolean directoryContentEquals(final Path path1, final Path path2, final int maxDepth, final LinkOption[] linkOptions, final FileVisitOption[] fileVisitOptions) throws IOException {\n-        return new PathUtils.RelativeSortedPaths(path1, path2, maxDepth, linkOptions, fileVisitOptions, (PathUtils.PathUtils$1)null).equals;\n+    public static boolean directoryContentEquals(final Path path, final Path path2, final int n, final LinkOption[] array, final FileVisitOption[] array2) throws IOException {\n+        return new PathUtils.RelativeSortedPaths(path, path2, n, array, array2, (PathUtils.PathUtils$1)null).equals;\n     }\n     \n-    public static boolean fileContentEquals(final Path path1, final Path path2) throws IOException {\n-        return fileContentEquals(path1, path2, PathUtils.EMPTY_LINK_OPTION_ARRAY, PathUtils.EMPTY_OPEN_OPTION_ARRAY);\n+    public static boolean fileContentEquals(final Path path, final Path path2) throws IOException {\n+        return fileContentEquals(path, path2, PathUtils.EMPTY_LINK_OPTION_ARRAY, PathUtils.EMPTY_OPEN_OPTION_ARRAY);\n     }\n     \n-    public static boolean fileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions) throws IOException {\n-        if (path1 == null && path2 == null) {\n+    public static boolean fileContentEquals(final Path path, final Path path2, final LinkOption[] array, final OpenOption[] array2) throws IOException {\n+        if (path == null && path2 == null) {\n             return true;\n         }\n-        if (path1 == null || path2 == null) {\n+        if (path == null || path2 == null) {\n             return false;\n         }\n-        final Path nPath1 = path1.normalize();\n-        final Path nPath2 = path2.normalize();\n-        final boolean path1Exists = Files.exists(nPath1, linkOptions);\n-        if (path1Exists != Files.exists(nPath2, linkOptions)) {\n+        final Path normalize = path.normalize();\n+        final Path normalize2 = path2.normalize();\n+        final boolean exists = Files.exists(normalize, array);\n+        if (exists != Files.exists(normalize2, array)) {\n             return false;\n         }\n-        if (!path1Exists) {\n+        if (!exists) {\n             return true;\n         }\n-        if (Files.isDirectory(nPath1, linkOptions)) {\n-            throw new IOException(\"Can't compare directories, only files: \" + nPath1);\n+        if (Files.isDirectory(normalize, array)) {\n+            throw new IOException(\"Can't compare directories, only files: \" + normalize);\n         }\n-        if (Files.isDirectory(nPath2, linkOptions)) {\n-            throw new IOException(\"Can't compare directories, only files: \" + nPath2);\n+        if (Files.isDirectory(normalize2, array)) {\n+            throw new IOException(\"Can't compare directories, only files: \" + normalize2);\n         }\n-        if (Files.size(nPath1) != Files.size(nPath2)) {\n+        if (Files.size(normalize) != Files.size(normalize2)) {\n             return false;\n         }\n-        if (path1.equals(path2)) {\n+        if (path.equals(path2)) {\n             return true;\n         }\n-        try (final InputStream inputStream1 = Files.newInputStream(nPath1, openOptions);\n-             final InputStream inputStream2 = Files.newInputStream(nPath2, openOptions)) {\n-            return IOUtils.contentEquals(inputStream1, inputStream2);\n+        try (final InputStream inputStream = Files.newInputStream(normalize, array2);\n+             final InputStream inputStream2 = Files.newInputStream(normalize2, array2)) {\n+            return IOUtils.contentEquals(inputStream, inputStream2);\n         }\n     }\n     \n-    public static Path[] filter(final PathFilter filter, final Path... paths) {\n-        Objects.requireNonNull(filter, \"filter\");\n-        if (paths == null) {\n+    public static Path[] filter(final PathFilter obj, final Path... values) {\n+        Objects.requireNonNull(obj, \"filter\");\n+        if (values == null) {\n             return PathUtils.EMPTY_PATH_ARRAY;\n         }\n-        return ((List<? super Path>)filterPaths(filter, Stream.of(paths), Collectors.toList())).toArray(PathUtils.EMPTY_PATH_ARRAY);\n+        return ((List<? super Path>)filterPaths(obj, Stream.of(values), Collectors.toList())).toArray(PathUtils.EMPTY_PATH_ARRAY);\n     }\n     \n-    private static <R, A> R filterPaths(final PathFilter filter, final Stream<Path> stream, final Collector<? super Path, A, R> collector) {\n-        Objects.requireNonNull(filter, \"filter\");\n-        Objects.requireNonNull(collector, \"collector\");\n+    private static <R, A> R filterPaths(final PathFilter obj, final Stream<Path> stream, final Collector<? super Path, A, R> obj2) {\n+        Objects.requireNonNull(obj, \"filter\");\n+        Objects.requireNonNull(obj2, \"collector\");\n         if (stream == null) {\n-            return Stream.empty().collect((Collector<? super Object, A, R>)collector);\n+            return Stream.empty().collect((Collector<? super Object, Object, R>)obj2);\n         }\n-        return stream.filter(p -> {\n+        return stream.filter(path -> {\n             try {\n-                return p != null && filter.accept(p, readBasicFileAttributes(p)) == FileVisitResult.CONTINUE;\n+                return path != null && pathFilter.accept(path, readBasicFileAttributes(path)) == FileVisitResult.CONTINUE;\n             }\n-            catch (final IOException e) {\n+            catch (final IOException ex) {\n                 return false;\n             }\n-        }).collect(collector);\n+        }).collect(obj2);\n     }\n     \n-    public static List<AclEntry> getAclEntryList(final Path sourcePath) throws IOException {\n-        final AclFileAttributeView fileAttributeView = (AclFileAttributeView)Files.getFileAttributeView(sourcePath, AclFileAttributeView.class, new LinkOption[0]);\n-        return (fileAttributeView == null) ? null : fileAttributeView.getAcl();\n+    public static List<AclEntry> getAclEntryList(final Path path) throws IOException {\n+        final AclFileAttributeView aclFileAttributeView = (AclFileAttributeView)Files.getFileAttributeView(path, AclFileAttributeView.class, new LinkOption[0]);\n+        return (aclFileAttributeView == null) ? null : aclFileAttributeView.getAcl();\n     }\n     \n     public static boolean isDirectory(final Path path, final LinkOption... options) {\n         return path != null && Files.isDirectory(path, options);\n     }\n     \n     public static boolean isEmpty(final Path path) throws IOException {\n         return Files.isDirectory(path, new LinkOption[0]) ? isEmptyDirectory(path) : isEmptyFile(path);\n     }\n     \n-    public static boolean isEmptyDirectory(final Path directory) throws IOException {\n-        try (final DirectoryStream<Path> directoryStream = Files.newDirectoryStream(directory)) {\n+    public static boolean isEmptyDirectory(final Path dir) throws IOException {\n+        try (final DirectoryStream<Path> directoryStream = Files.newDirectoryStream(dir)) {\n             return !directoryStream.iterator().hasNext();\n         }\n     }\n     \n-    public static boolean isEmptyFile(final Path file) throws IOException {\n-        return Files.size(file) <= 0L;\n+    public static boolean isEmptyFile(final Path path) throws IOException {\n+        return Files.size(path) <= 0L;\n     }\n     \n-    public static boolean isNewer(final Path file, final long timeMillis, final LinkOption... options) throws IOException {\n-        Objects.requireNonNull(file, \"file\");\n-        return !Files.notExists(file, new LinkOption[0]) && Files.getLastModifiedTime(file, options).toMillis() > timeMillis;\n+    public static boolean isNewer(final Path path, final long n, final LinkOption... options) throws IOException {\n+        Objects.requireNonNull(path, \"file\");\n+        return !Files.notExists(path, new LinkOption[0]) && Files.getLastModifiedTime(path, options).toMillis() > n;\n     }\n     \n     public static boolean isRegularFile(final Path path, final LinkOption... options) {\n         return path != null && Files.isRegularFile(path, options);\n     }\n     \n     public static DirectoryStream<Path> newDirectoryStream(final Path dir, final PathFilter pathFilter) throws IOException {\n         return Files.newDirectoryStream(dir, (DirectoryStream.Filter<? super Path>)new DirectoryStreamFilter(pathFilter));\n     }\n     \n-    private static boolean overrideReadOnly(final DeleteOption... deleteOptions) {\n-        return deleteOptions != null && Stream.of(deleteOptions).anyMatch(e -> e == StandardDeleteOption.OVERRIDE_READ_ONLY);\n+    private static boolean overrideReadOnly(final DeleteOption... values) {\n+        return values != null && Stream.of(values).anyMatch(deleteOption -> deleteOption == StandardDeleteOption.OVERRIDE_READ_ONLY);\n     }\n     \n     public static BasicFileAttributes readBasicFileAttributes(final Path path) throws IOException {\n         return Files.readAttributes(path, BasicFileAttributes.class, new LinkOption[0]);\n     }\n     \n     public static BasicFileAttributes readBasicFileAttributesUnchecked(final Path path) {\n         try {\n             return readBasicFileAttributes(path);\n         }\n-        catch (final IOException e) {\n-            throw new UncheckedIOException(e);\n+        catch (final IOException cause) {\n+            throw new UncheckedIOException(cause);\n         }\n     }\n     \n-    static List<Path> relativize(final Collection<Path> collection, final Path parent, final boolean sort, final Comparator<? super Path> comparator) {\n-        final Stream<Path> stream2 = collection.stream();\n-        Objects.requireNonNull(parent);\n-        Stream<Path> stream = (Stream<Path>)stream2.map((Function<? super Path, ?>)parent::relativize);\n-        if (sort) {\n-            stream = ((comparator == null) ? stream.sorted() : stream.sorted(comparator));\n+    static List<Path> relativize(final Collection<Path> collection, final Path obj, final boolean b, final Comparator<? super Path> comparator) {\n+        final Stream<Path> stream = collection.stream();\n+        Objects.requireNonNull(obj);\n+        Stream<Object> map = stream.map((Function<? super Path, ?>)obj::relativize);\n+        if (b) {\n+            map = ((comparator == null) ? map.sorted() : map.sorted((Comparator<? super Object>)comparator));\n         }\n-        return stream.collect((Collector<? super Path, ?, List<Path>>)Collectors.toList());\n+        return map.collect((Collector<? super Object, ?, List<Path>>)Collectors.toList());\n     }\n     \n-    public static Path setReadOnly(final Path path, final boolean readOnly, final LinkOption... linkOptions) throws IOException {\n-        final List<Exception> causeList = new ArrayList<Exception>(2);\n-        final DosFileAttributeView fileAttributeView = (DosFileAttributeView)Files.getFileAttributeView(path, DosFileAttributeView.class, linkOptions);\n-        if (fileAttributeView != null) {\n+    public static Path setReadOnly(final Path path, final boolean readOnly, final LinkOption... a) throws IOException {\n+        final ArrayList list = new ArrayList(2);\n+        final DosFileAttributeView dosFileAttributeView = (DosFileAttributeView)Files.getFileAttributeView(path, DosFileAttributeView.class, a);\n+        if (dosFileAttributeView != null) {\n             try {\n-                fileAttributeView.setReadOnly(readOnly);\n+                dosFileAttributeView.setReadOnly(readOnly);\n                 return path;\n             }\n-            catch (final IOException e) {\n-                causeList.add(e);\n+            catch (final IOException ex) {\n+                list.add(ex);\n             }\n         }\n-        final PosixFileAttributeView posixFileAttributeView = (PosixFileAttributeView)Files.getFileAttributeView(path, PosixFileAttributeView.class, linkOptions);\n+        final PosixFileAttributeView posixFileAttributeView = (PosixFileAttributeView)Files.getFileAttributeView(path, PosixFileAttributeView.class, a);\n         if (posixFileAttributeView != null) {\n-            final PosixFileAttributes readAttributes = posixFileAttributeView.readAttributes();\n-            final Set<PosixFilePermission> permissions = readAttributes.permissions();\n+            final Set<PosixFilePermission> permissions = posixFileAttributeView.readAttributes().permissions();\n             permissions.remove(PosixFilePermission.OWNER_WRITE);\n             permissions.remove(PosixFilePermission.GROUP_WRITE);\n             permissions.remove(PosixFilePermission.OTHERS_WRITE);\n             try {\n                 return Files.setPosixFilePermissions(path, permissions);\n             }\n-            catch (final IOException e2) {\n-                causeList.add(e2);\n+            catch (final IOException ex2) {\n+                list.add(ex2);\n             }\n         }\n-        if (!causeList.isEmpty()) {\n-            throw new IOExceptionList(path.toString(), (List)causeList);\n+        if (!list.isEmpty()) {\n+            throw new IOExceptionList(path.toString(), (List)list);\n         }\n-        throw new IOException(String.format(\"No DosFileAttributeView or PosixFileAttributeView for '%s' (linkOptions=%s)\", path, Arrays.toString(linkOptions)));\n+        throw new IOException(String.format(\"No DosFileAttributeView or PosixFileAttributeView for '%s' (linkOptions=%s)\", path, Arrays.toString(a)));\n     }\n     \n-    static Set<FileVisitOption> toFileVisitOptionSet(final FileVisitOption... fileVisitOptions) {\n-        return (Set<FileVisitOption>)((fileVisitOptions == null) ? EnumSet.noneOf(FileVisitOption.class) : ((Set<? super FileVisitOption>)Stream.of(fileVisitOptions).collect((Collector<? super FileVisitOption, ?, Set<? super FileVisitOption>>)Collectors.toSet())));\n+    static Set<FileVisitOption> toFileVisitOptionSet(final FileVisitOption... values) {\n+        return (Set<FileVisitOption>)((values == null) ? EnumSet.noneOf(FileVisitOption.class) : ((Set<? super FileVisitOption>)Stream.of(values).collect((Collector<? super FileVisitOption, ?, Set<? super FileVisitOption>>)Collectors.toSet())));\n     }\n     \n-    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final Path directory) throws IOException {\n-        Files.walkFileTree(directory, visitor);\n+    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final Path start) throws IOException {\n+        Files.walkFileTree(start, visitor);\n         return visitor;\n     }\n     \n     public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final Path start, final Set<FileVisitOption> options, final int maxDepth) throws IOException {\n         Files.walkFileTree(start, options, maxDepth, visitor);\n         return visitor;\n     }\n     \n-    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final String first, final String... more) throws IOException {\n-        return visitFileTree(visitor, Paths.get(first, more));\n+    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T t, final String first, final String... more) throws IOException {\n+        return visitFileTree(t, Paths.get(first, more));\n     }\n     \n-    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final URI uri) throws IOException {\n-        return visitFileTree(visitor, Paths.get(uri));\n+    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T t, final URI uri) throws IOException {\n+        return visitFileTree(t, Paths.get(uri));\n     }\n     \n-    public static Stream<Path> walk(final Path start, final PathFilter pathFilter, final int maxDepth, final boolean readAttributes, final FileVisitOption... options) throws IOException {\n-        return Files.walk(start, maxDepth, options).filter(path -> pathFilter.accept(path, readAttributes ? readBasicFileAttributesUnchecked(path) : null) == FileVisitResult.CONTINUE);\n+    public static Stream<Path> walk(final Path start, final PathFilter pathFilter, final int maxDepth, final boolean b, final FileVisitOption... options) throws IOException {\n+        return Files.walk(start, maxDepth, options).filter(path -> pathFilter2.accept(path, b2 ? readBasicFileAttributesUnchecked(path) : null) == FileVisitResult.CONTINUE);\n     }\n     \n     private PathUtils() {\n     }\n     \n     static {\n         EMPTY_COPY_OPTIONS = new CopyOption[0];\n"}]}
