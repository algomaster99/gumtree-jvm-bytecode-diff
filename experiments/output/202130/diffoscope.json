{"diffoscope-json-version": 1, "source1": "first/ChangeSetPerformer.class", "source2": "second/ChangeSetPerformer.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -14,98 +14,98 @@\n import org.apache.commons.compress.archivers.ArchiveInputStream;\n import java.util.Set;\n \n public class ChangeSetPerformer\n {\n     private final Set<Change> changes;\n     \n-    public ChangeSetPerformer(final ChangeSet changeSet) {\n-        this.changes = changeSet.getChanges();\n+    public ChangeSetPerformer(final ChangeSet set) {\n+        this.changes = set.getChanges();\n     }\n     \n-    public ChangeSetResults perform(final ArchiveInputStream in, final ArchiveOutputStream out) throws IOException {\n-        return this.perform((ChangeSetPerformer.ArchiveEntryIterator)new ChangeSetPerformer.ArchiveInputStreamIterator(in), out);\n+    public ChangeSetResults perform(final ArchiveInputStream archiveInputStream, final ArchiveOutputStream archiveOutputStream) throws IOException {\n+        return this.perform((ChangeSetPerformer.ArchiveEntryIterator)new ChangeSetPerformer.ArchiveInputStreamIterator(archiveInputStream), archiveOutputStream);\n     }\n     \n-    public ChangeSetResults perform(final ZipFile in, final ArchiveOutputStream out) throws IOException {\n-        return this.perform((ChangeSetPerformer.ArchiveEntryIterator)new ChangeSetPerformer.ZipFileIterator(in), out);\n+    public ChangeSetResults perform(final ZipFile zipFile, final ArchiveOutputStream archiveOutputStream) throws IOException {\n+        return this.perform((ChangeSetPerformer.ArchiveEntryIterator)new ChangeSetPerformer.ZipFileIterator(zipFile), archiveOutputStream);\n     }\n     \n-    private ChangeSetResults perform(final ChangeSetPerformer.ArchiveEntryIterator entryIterator, final ArchiveOutputStream out) throws IOException {\n-        final ChangeSetResults results = new ChangeSetResults();\n-        final Set<Change> workingSet = new LinkedHashSet<Change>(this.changes);\n-        Iterator<Change> it = workingSet.iterator();\n-        while (it.hasNext()) {\n-            final Change change = (Change)it.next();\n+    private ChangeSetResults perform(final ChangeSetPerformer.ArchiveEntryIterator archiveEntryIterator, final ArchiveOutputStream archiveOutputStream) throws IOException {\n+        final ChangeSetResults changeSetResults = new ChangeSetResults();\n+        final LinkedHashSet set = new LinkedHashSet((Collection<? extends E>)this.changes);\n+        final Iterator iterator = set.iterator();\n+        while (iterator.hasNext()) {\n+            final Change change = (Change)iterator.next();\n             if (change.type() == 2 && change.isReplaceMode()) {\n-                this.copyStream(change.getInput(), out, change.getEntry());\n-                it.remove();\n-                results.addedFromChangeSet(change.getEntry().getName());\n+                this.copyStream(change.getInput(), archiveOutputStream, change.getEntry());\n+                iterator.remove();\n+                changeSetResults.addedFromChangeSet(change.getEntry().getName());\n             }\n         }\n-        while (entryIterator.hasNext()) {\n-            final ArchiveEntry entry = entryIterator.next();\n-            boolean copy = true;\n-            final Iterator<Change> it2 = workingSet.iterator();\n-            while (it2.hasNext()) {\n-                final Change change2 = (Change)it2.next();\n+        while (archiveEntryIterator.hasNext()) {\n+            final ArchiveEntry next = archiveEntryIterator.next();\n+            boolean b = true;\n+            final Iterator iterator2 = set.iterator();\n+            while (iterator2.hasNext()) {\n+                final Change change2 = (Change)iterator2.next();\n                 final int type = change2.type();\n-                final String name = entry.getName();\n+                final String name = next.getName();\n                 if (type == 1 && name != null) {\n                     if (name.equals(change2.targetFile())) {\n-                        copy = false;\n-                        it2.remove();\n-                        results.deleted(name);\n+                        b = false;\n+                        iterator2.remove();\n+                        changeSetResults.deleted(name);\n                         break;\n                     }\n                     continue;\n                 }\n                 else {\n                     if (type == 4 && name != null && name.startsWith(change2.targetFile() + \"/\")) {\n-                        copy = false;\n-                        results.deleted(name);\n+                        b = false;\n+                        changeSetResults.deleted(name);\n                         break;\n                     }\n                     continue;\n                 }\n             }\n-            if (copy && !this.isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\n-                this.copyStream(entryIterator.getInputStream(), out, entry);\n-                results.addedFromStream(entry.getName());\n+            if (b && !this.isDeletedLater(set, next) && !changeSetResults.hasBeenAdded(next.getName())) {\n+                this.copyStream(archiveEntryIterator.getInputStream(), archiveOutputStream, next);\n+                changeSetResults.addedFromStream(next.getName());\n             }\n         }\n-        it = workingSet.iterator();\n-        while (it.hasNext()) {\n-            final Change change = (Change)it.next();\n-            if (change.type() == 2 && !change.isReplaceMode() && !results.hasBeenAdded(change.getEntry().getName())) {\n-                this.copyStream(change.getInput(), out, change.getEntry());\n-                it.remove();\n-                results.addedFromChangeSet(change.getEntry().getName());\n+        final Iterator iterator3 = set.iterator();\n+        while (iterator3.hasNext()) {\n+            final Change change3 = (Change)iterator3.next();\n+            if (change3.type() == 2 && !change3.isReplaceMode() && !changeSetResults.hasBeenAdded(change3.getEntry().getName())) {\n+                this.copyStream(change3.getInput(), archiveOutputStream, change3.getEntry());\n+                iterator3.remove();\n+                changeSetResults.addedFromChangeSet(change3.getEntry().getName());\n             }\n         }\n-        out.finish();\n-        return results;\n+        archiveOutputStream.finish();\n+        return changeSetResults;\n     }\n     \n-    private boolean isDeletedLater(final Set<Change> workingSet, final ArchiveEntry entry) {\n-        final String source = entry.getName();\n-        if (!workingSet.isEmpty()) {\n-            for (final Change change : workingSet) {\n+    private boolean isDeletedLater(final Set<Change> set, final ArchiveEntry archiveEntry) {\n+        final String name = archiveEntry.getName();\n+        if (!set.isEmpty()) {\n+            for (final Change change : set) {\n                 final int type = change.type();\n-                final String target = change.targetFile();\n-                if (type == 1 && source.equals(target)) {\n+                final String targetFile = change.targetFile();\n+                if (type == 1 && name.equals(targetFile)) {\n                     return true;\n                 }\n-                if (type == 4 && source.startsWith(target + \"/\")) {\n+                if (type == 4 && name.startsWith(targetFile + \"/\")) {\n                     return true;\n                 }\n             }\n         }\n         return false;\n     }\n     \n-    private void copyStream(final InputStream in, final ArchiveOutputStream out, final ArchiveEntry entry) throws IOException {\n-        out.putArchiveEntry(entry);\n-        IOUtils.copy(in, (OutputStream)out);\n-        out.closeArchiveEntry();\n+    private void copyStream(final InputStream inputStream, final ArchiveOutputStream archiveOutputStream, final ArchiveEntry archiveEntry) throws IOException {\n+        archiveOutputStream.putArchiveEntry(archiveEntry);\n+        IOUtils.copy(inputStream, (OutputStream)archiveOutputStream);\n+        archiveOutputStream.closeArchiveEntry();\n     }\n }\n"}]}
