{"diffoscope-json-version": 1, "source1": "first/PhoneticEngine.class", "source2": "second/PhoneticEngine.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -22,143 +22,138 @@\n     private static final int DEFAULT_MAX_PHONEMES = 20;\n     private final Lang lang;\n     private final NameType nameType;\n     private final RuleType ruleType;\n     private final boolean concat;\n     private final int maxPhonemes;\n     \n-    private static String join(final Iterable<String> strings, final String sep) {\n+    private static String join(final Iterable<String> iterable, final String str) {\n         final StringBuilder sb = new StringBuilder();\n-        final Iterator<String> si = strings.iterator();\n-        if (si.hasNext()) {\n-            sb.append(si.next());\n+        final Iterator<String> iterator = iterable.iterator();\n+        if (iterator.hasNext()) {\n+            sb.append(iterator.next());\n         }\n-        while (si.hasNext()) {\n-            sb.append(sep).append(si.next());\n+        while (iterator.hasNext()) {\n+            sb.append(str).append(iterator.next());\n         }\n         return sb.toString();\n     }\n     \n-    public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat) {\n-        this(nameType, ruleType, concat, 20);\n+    public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean b) {\n+        this(nameType, ruleType, b, 20);\n     }\n     \n     public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat, final int maxPhonemes) {\n         if (ruleType == RuleType.RULES) {\n             throw new IllegalArgumentException(\"ruleType must not be \" + RuleType.RULES);\n         }\n         this.nameType = nameType;\n         this.ruleType = ruleType;\n         this.concat = concat;\n         this.lang = Lang.instance(nameType);\n         this.maxPhonemes = maxPhonemes;\n     }\n     \n-    private PhoneticEngine.PhonemeBuilder applyFinalRules(final PhoneticEngine.PhonemeBuilder phonemeBuilder, final Map<String, List<Rule>> finalRules) {\n-        Objects.requireNonNull(finalRules, \"finalRules\");\n-        if (finalRules.isEmpty()) {\n+    private PhoneticEngine.PhonemeBuilder applyFinalRules(final PhoneticEngine.PhonemeBuilder phonemeBuilder, final Map<String, List<Rule>> obj) {\n+        Objects.requireNonNull(obj, \"finalRules\");\n+        if (obj.isEmpty()) {\n             return phonemeBuilder;\n         }\n-        final Map<Rule.Phoneme, Rule.Phoneme> phonemes = new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);\n+        final TreeMap treeMap = new TreeMap(Rule.Phoneme.COMPARATOR);\n         for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {\n-            PhoneticEngine.PhonemeBuilder subBuilder = PhoneticEngine.PhonemeBuilder.empty(phoneme.getLanguages());\n-            final String phonemeText = phoneme.getPhonemeText().toString();\n-            PhoneticEngine.RulesApplication rulesApplication;\n-            for (int i = 0; i < phonemeText.length(); i = rulesApplication.getI()) {\n-                rulesApplication = new PhoneticEngine.RulesApplication((Map)finalRules, (CharSequence)phonemeText, subBuilder, i, this.maxPhonemes).invoke();\n-                final boolean found = rulesApplication.isFound();\n-                subBuilder = rulesApplication.getPhonemeBuilder();\n+            PhoneticEngine.PhonemeBuilder phonemeBuilder2 = PhoneticEngine.PhonemeBuilder.empty(phoneme.getLanguages());\n+            final String string = phoneme.getPhonemeText().toString();\n+            PhoneticEngine.RulesApplication invoke;\n+            for (int i = 0; i < string.length(); i = invoke.getI()) {\n+                invoke = new PhoneticEngine.RulesApplication((Map)obj, (CharSequence)string, phonemeBuilder2, i, this.maxPhonemes).invoke();\n+                final boolean found = invoke.isFound();\n+                phonemeBuilder2 = invoke.getPhonemeBuilder();\n                 if (!found) {\n-                    subBuilder.append(phonemeText.subSequence(i, i + 1));\n+                    phonemeBuilder2.append(string.subSequence(i, i + 1));\n                 }\n             }\n-            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {\n-                if (phonemes.containsKey(newPhoneme)) {\n-                    final Rule.Phoneme oldPhoneme = (Rule.Phoneme)phonemes.remove(newPhoneme);\n-                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());\n-                    phonemes.put(mergedPhoneme, mergedPhoneme);\n+            for (final Rule.Phoneme phoneme2 : phonemeBuilder2.getPhonemes()) {\n+                if (treeMap.containsKey(phoneme2)) {\n+                    final Rule.Phoneme mergeWithLanguage = ((Rule.Phoneme)treeMap.remove(phoneme2)).mergeWithLanguage(phoneme2.getLanguages());\n+                    treeMap.put(mergeWithLanguage, mergeWithLanguage);\n                 }\n                 else {\n-                    phonemes.put(newPhoneme, newPhoneme);\n+                    treeMap.put(phoneme2, phoneme2);\n                 }\n             }\n         }\n-        return new PhoneticEngine.PhonemeBuilder((Set)phonemes.keySet(), (PhoneticEngine.PhoneticEngine$1)null);\n+        return new PhoneticEngine.PhonemeBuilder((Set)treeMap.keySet(), (PhoneticEngine.PhoneticEngine$1)null);\n     }\n     \n-    public String encode(final String input) {\n-        final Languages.LanguageSet languageSet = this.lang.guessLanguages(input);\n-        return this.encode(input, languageSet);\n+    public String encode(final String s) {\n+        return this.encode(s, this.lang.guessLanguages(s));\n     }\n     \n-    public String encode(String input, final Languages.LanguageSet languageSet) {\n-        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);\n-        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, \"common\");\n-        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);\n-        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();\n+    public String encode(String s, final Languages.LanguageSet set) {\n+        final Map instanceMap = Rule.getInstanceMap(this.nameType, RuleType.RULES, set);\n+        final Map instanceMap2 = Rule.getInstanceMap(this.nameType, this.ruleType, \"common\");\n+        final Map instanceMap3 = Rule.getInstanceMap(this.nameType, this.ruleType, set);\n+        s = s.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();\n         if (this.nameType == NameType.GENERIC) {\n-            if (input.length() >= 2 && input.substring(0, 2).equals(\"d'\")) {\n-                final String remainder = input.substring(2);\n-                final String combined = \"d\" + remainder;\n-                return \"(\" + this.encode(remainder) + \")-(\" + this.encode(combined) + \")\";\n+            if (s.length() >= 2 && s.substring(0, 2).equals(\"d'\")) {\n+                final String substring = s.substring(2);\n+                return \"(\" + this.encode(substring) + \")-(\" + this.encode(\"d\" + substring) + \")\";\n             }\n-            for (final String l : (Set)PhoneticEngine.NAME_PREFIXES.get(this.nameType)) {\n-                if (input.startsWith(l + \" \")) {\n-                    final String remainder2 = input.substring(l.length() + 1);\n-                    final String combined2 = l + remainder2;\n-                    return \"(\" + this.encode(remainder2) + \")-(\" + this.encode(combined2) + \")\";\n+            for (final String s2 : (Set)PhoneticEngine.NAME_PREFIXES.get(this.nameType)) {\n+                if (s.startsWith(s2 + \" \")) {\n+                    final String substring2 = s.substring(s2.length() + 1);\n+                    return \"(\" + this.encode(substring2) + \")-(\" + this.encode(s2 + substring2) + \")\";\n                 }\n             }\n         }\n-        final List<String> words = Arrays.asList(input.split(\"\\\\s+\"));\n-        final List<String> words2 = new ArrayList<String>();\n+        final List<String> list = Arrays.asList(s.split(\"\\\\s+\"));\n+        final ArrayList list2 = new ArrayList();\n         switch (PhoneticEngine.PhoneticEngine$1.$SwitchMap$org$apache$commons$codec$language$bm$NameType[this.nameType.ordinal()]) {\n             case 1: {\n-                for (final String aWord : words) {\n-                    final String[] parts = aWord.split(\"'\");\n-                    final String lastPart = parts[parts.length - 1];\n-                    words2.add(lastPart);\n+                final Iterator<String> iterator2 = list.iterator();\n+                while (iterator2.hasNext()) {\n+                    final String[] split = ((String)iterator2.next()).split(\"'\");\n+                    list2.add(split[split.length - 1]);\n                 }\n-                words2.removeAll(PhoneticEngine.NAME_PREFIXES.get(this.nameType));\n+                list2.removeAll(PhoneticEngine.NAME_PREFIXES.get(this.nameType));\n                 break;\n             }\n             case 2: {\n-                words2.addAll(words);\n-                words2.removeAll(PhoneticEngine.NAME_PREFIXES.get(this.nameType));\n+                list2.addAll(list);\n+                list2.removeAll(PhoneticEngine.NAME_PREFIXES.get(this.nameType));\n                 break;\n             }\n             case 3: {\n-                words2.addAll(words);\n+                list2.addAll(list);\n                 break;\n             }\n             default: {\n                 throw new IllegalStateException(\"Unreachable case: \" + this.nameType);\n             }\n         }\n         if (this.concat) {\n-            input = join(words2, \" \");\n+            s = join(list2, \" \");\n         }\n         else {\n-            if (words2.size() != 1) {\n-                final StringBuilder result = new StringBuilder();\n-                for (final String word : words2) {\n-                    result.append(\"-\").append(this.encode(word));\n-                }\n-                return result.substring();\n-            }\n-            input = words.iterator().next();\n-        }\n-        PhoneticEngine.PhonemeBuilder phonemeBuilder = PhoneticEngine.PhonemeBuilder.empty(languageSet);\n-        PhoneticEngine.RulesApplication rulesApplication;\n-        for (int i = 0; i < input.length(); i = rulesApplication.getI(), phonemeBuilder = rulesApplication.getPhonemeBuilder()) {\n-            rulesApplication = new PhoneticEngine.RulesApplication((Map)rules, (CharSequence)input, phonemeBuilder, i, this.maxPhonemes).invoke();\n-        }\n-        phonemeBuilder = this.applyFinalRules(phonemeBuilder, finalRules1);\n-        phonemeBuilder = this.applyFinalRules(phonemeBuilder, finalRules2);\n-        return phonemeBuilder.makeString();\n+            if (list2.size() != 1) {\n+                final StringBuilder sb = new StringBuilder();\n+                final Iterator iterator3 = list2.iterator();\n+                while (iterator3.hasNext()) {\n+                    sb.append(\"-\").append(this.encode((String)iterator3.next()));\n+                }\n+                return sb.substring();\n+            }\n+            s = list.iterator().next();\n+        }\n+        PhoneticEngine.PhonemeBuilder phonemeBuilder = PhoneticEngine.PhonemeBuilder.empty(set);\n+        PhoneticEngine.RulesApplication invoke;\n+        for (int i = 0; i < s.length(); i = invoke.getI(), phonemeBuilder = invoke.getPhonemeBuilder()) {\n+            invoke = new PhoneticEngine.RulesApplication(instanceMap, (CharSequence)s, phonemeBuilder, i, this.maxPhonemes).invoke();\n+        }\n+        return this.applyFinalRules(this.applyFinalRules(phonemeBuilder, instanceMap2), instanceMap3).makeString();\n     }\n     \n     public Lang getLang() {\n         return this.lang;\n     }\n     \n     public NameType getNameType() {\n"}]}
