{"diffoscope-json-version": 1, "source1": "first/Select.class", "source2": "second/Select.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -24,47 +24,49 @@\n     }\n     \n     Select(final short opcode, final int[] match, final InstructionHandle[] targets, final InstructionHandle defaultTarget) {\n         super(opcode, (InstructionHandle)null);\n         this.match = match;\n         this.targets = targets;\n         this.setTarget(defaultTarget);\n-        for (final InstructionHandle target2 : targets) {\n-            notifyTarget((InstructionHandle)null, target2, (InstructionTargeter)this);\n+        for (int length = targets.length, i = 0; i < length; ++i) {\n+            notifyTarget((InstructionHandle)null, targets[i], (InstructionTargeter)this);\n         }\n         if ((this.match_length = match.length) != targets.length) {\n             throw new ClassGenException(\"Match and target array have not the same length: Match length: \" + match.length + \" Target length: \" + targets.length);\n         }\n         this.indices = new int[this.match_length];\n     }\n     \n     protected Object clone() throws CloneNotSupportedException {\n-        final Select copy = (Select)super.clone();\n-        copy.match = this.match.clone();\n-        copy.indices = this.indices.clone();\n-        copy.targets = this.targets.clone();\n-        return copy;\n+        final Select select = (Select)super.clone();\n+        select.match = this.match.clone();\n+        select.indices = this.indices.clone();\n+        select.targets = this.targets.clone();\n+        return select;\n     }\n     \n     public boolean containsTarget(final InstructionHandle ih) {\n         if (super.getTarget() == ih) {\n             return true;\n         }\n-        for (final InstructionHandle target2 : this.targets) {\n-            if (target2 == ih) {\n+        final InstructionHandle[] targets = this.targets;\n+        for (int length = targets.length, i = 0; i < length; ++i) {\n+            if (targets[i] == ih) {\n                 return true;\n             }\n         }\n         return false;\n     }\n     \n     void dispose() {\n         super.dispose();\n-        for (final InstructionHandle target2 : this.targets) {\n-            target2.removeTargeter((InstructionTargeter)this);\n+        final InstructionHandle[] targets = this.targets;\n+        for (int length = targets.length, i = 0; i < length; ++i) {\n+            targets[i].removeTargeter((InstructionTargeter)this);\n         }\n     }\n     \n     public void dump(final DataOutputStream out) throws IOException {\n         out.writeByte(super.getOpcode());\n         for (int i = 0; i < this.padding; ++i) {\n             out.writeByte(0);\n@@ -147,48 +149,48 @@\n     }\n     \n     final void setTargets(final InstructionHandle[] array) {\n         this.targets = array;\n     }\n     \n     public String toString(final boolean verbose) {\n-        final StringBuilder buf = new StringBuilder(super.toString(verbose));\n+        final StringBuilder sb = new StringBuilder(super.toString(verbose));\n         if (verbose) {\n             for (int i = 0; i < this.match_length; ++i) {\n-                String s = \"null\";\n+                String string = \"null\";\n                 if (this.targets[i] != null) {\n-                    s = this.targets[i].getInstruction().toString();\n+                    string = this.targets[i].getInstruction().toString();\n                 }\n-                buf.append(\"(\").append(this.match[i]).append(\", \").append(s).append(\" = {\").append(this.indices[i]).append(\"})\");\n+                sb.append(\"(\").append(this.match[i]).append(\", \").append(string).append(\" = {\").append(this.indices[i]).append(\"})\");\n             }\n         }\n         else {\n-            buf.append(\" ...\");\n+            sb.append(\" ...\");\n         }\n-        return buf.toString();\n+        return sb.toString();\n     }\n     \n     protected int updatePosition(final int offset, final int maxOffset) {\n         this.setPosition(this.getPosition() + offset);\n-        final short oldLength = (short)super.getLength();\n+        final short n = (short)super.getLength();\n         this.padding = (4 - (this.getPosition() + 1) % 4) % 4;\n         super.setLength((int)(short)(this.fixed_length + this.padding));\n-        return super.getLength() - oldLength;\n+        return super.getLength() - n;\n     }\n     \n     public void updateTarget(final InstructionHandle oldIh, final InstructionHandle newIh) {\n-        boolean targeted = false;\n+        boolean b = false;\n         if (super.getTarget() == oldIh) {\n-            targeted = true;\n+            b = true;\n             this.setTarget(newIh);\n         }\n         for (int i = 0; i < this.targets.length; ++i) {\n             if (this.targets[i] == oldIh) {\n-                targeted = true;\n+                b = true;\n                 this.setTarget(i, newIh);\n             }\n         }\n-        if (!targeted) {\n+        if (!b) {\n             throw new ClassGenException(\"Not targeting \" + oldIh);\n         }\n     }\n }\n"}]}
