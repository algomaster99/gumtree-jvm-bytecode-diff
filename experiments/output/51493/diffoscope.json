{"diffoscope-json-version": 1, "source1": "first/ZipArchiveOutputStream.class", "source2": "second/ZipArchiveOutputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -95,14 +95,27 @@\n     static final byte[] LFH_SIG;\n     static final byte[] DD_SIG;\n     static final byte[] CFH_SIG;\n     static final byte[] EOCD_SIG;\n     static final byte[] ZIP64_EOCD_SIG;\n     static final byte[] ZIP64_EOCD_LOC_SIG;\n     \n+    static {\n+        EMPTY = new byte[0];\n+        ZERO = new byte[2];\n+        LZERO = new byte[4];\n+        ONE = ZipLong.getBytes(1L);\n+        LFH_SIG = ZipLong.LFH_SIG.getBytes();\n+        DD_SIG = ZipLong.DD_SIG.getBytes();\n+        CFH_SIG = ZipLong.CFH_SIG.getBytes();\n+        EOCD_SIG = ZipLong.getBytes(101010256L);\n+        ZIP64_EOCD_SIG = ZipLong.getBytes(101075792L);\n+        ZIP64_EOCD_LOC_SIG = ZipLong.getBytes(117853008L);\n+    }\n+    \n     public ZipArchiveOutputStream(final OutputStream out) {\n         this.finished = false;\n         this.comment = \"\";\n         this.level = -1;\n         this.hasCompressionLevelChanged = false;\n         this.method = 8;\n         this.entries = new LinkedList<ZipArchiveEntry>();\n@@ -147,15 +160,15 @@\n         OutputStream o = null;\n         SeekableByteChannel _channel = null;\n         StreamCompressor _streamCompressor = null;\n         try {\n             _channel = Files.newByteChannel(file.toPath(), EnumSet.of(StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.TRUNCATE_EXISTING), (FileAttribute<?>[])new FileAttribute[0]);\n             _streamCompressor = StreamCompressor.create(_channel, this.def);\n         }\n-        catch (final IOException e) {\n+        catch (final IOException ex) {\n             IOUtils.closeQuietly((Closeable)_channel);\n             _channel = null;\n             o = new FileOutputStream(file);\n             _streamCompressor = StreamCompressor.create(o, this.def);\n         }\n         this.out = o;\n         this.channel = _channel;\n@@ -234,15 +247,14 @@\n         this.metaData.clear();\n         this.entries.clear();\n         this.streamCompressor.close();\n         this.finished = true;\n     }\n     \n     private void writeCentralDirectoryInChunks() throws IOException {\n-        final int NUM_PER_WRITE = 1000;\n         final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(70000);\n         int count = 0;\n         for (final ZipArchiveEntry ze : this.entries) {\n             byteArrayOutputStream.write(this.createCentralFileHeader(ze));\n             if (++count > 1000) {\n                 this.writeCounted(byteArrayOutputStream.toByteArray());\n                 byteArrayOutputStream.reset();\n@@ -251,49 +263,49 @@\n         }\n         this.writeCounted(byteArrayOutputStream.toByteArray());\n     }\n     \n     public void closeArchiveEntry() throws IOException {\n         this.preClose();\n         this.flushDeflater();\n-        final long bytesWritten = this.streamCompressor.getTotalBytesWritten() - ZipArchiveOutputStream.CurrentEntry.access$000(this.entry);\n+        final long bytesWritten = this.streamCompressor.getTotalBytesWritten() - ZipArchiveOutputStream.CurrentEntry.access$0(this.entry);\n         final long realCrc = this.streamCompressor.getCrc32();\n-        ZipArchiveOutputStream.CurrentEntry.access$102(this.entry, this.streamCompressor.getBytesRead());\n-        final Zip64Mode effectiveMode = this.getEffectiveZip64Mode(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n+        ZipArchiveOutputStream.CurrentEntry.access$1(this.entry, this.streamCompressor.getBytesRead());\n+        final Zip64Mode effectiveMode = this.getEffectiveZip64Mode(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry));\n         final boolean actuallyNeedsZip64 = this.handleSizesAndCrc(bytesWritten, realCrc, effectiveMode);\n         this.closeEntry(actuallyNeedsZip64, false);\n         this.streamCompressor.reset();\n     }\n     \n     private void closeCopiedEntry(final boolean phased) throws IOException {\n         this.preClose();\n-        ZipArchiveOutputStream.CurrentEntry.access$102(this.entry, ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize());\n-        final Zip64Mode effectiveMode = this.getEffectiveZip64Mode(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n+        ZipArchiveOutputStream.CurrentEntry.access$1(this.entry, ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getSize());\n+        final Zip64Mode effectiveMode = this.getEffectiveZip64Mode(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry));\n         final boolean actuallyNeedsZip64 = this.checkIfNeedsZip64(effectiveMode);\n         this.closeEntry(actuallyNeedsZip64, phased);\n     }\n     \n     private void closeEntry(final boolean actuallyNeedsZip64, final boolean phased) throws IOException {\n         if (!phased && this.channel != null) {\n             this.rewriteSizesAndCrc(actuallyNeedsZip64);\n         }\n         if (!phased) {\n-            this.writeDataDescriptor(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n+            this.writeDataDescriptor(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry));\n         }\n         this.entry = null;\n     }\n     \n     private void preClose() throws IOException {\n         if (this.finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n         if (this.entry == null) {\n             throw new IOException(\"No current entry to close\");\n         }\n-        if (!ZipArchiveOutputStream.CurrentEntry.access$300(this.entry)) {\n+        if (!ZipArchiveOutputStream.CurrentEntry.access$3(this.entry)) {\n             this.write(ZipArchiveOutputStream.EMPTY, 0, 0);\n         }\n     }\n     \n     public void addRawArchiveEntry(final ZipArchiveEntry entry, final InputStream rawStream) throws IOException {\n         final ZipArchiveEntry ae = new ZipArchiveEntry(entry);\n         if (this.hasZip64Extra(ae)) {\n@@ -302,81 +314,81 @@\n         final boolean is2PhaseSource = ae.getCrc() != -1L && ae.getSize() != -1L && ae.getCompressedSize() != -1L;\n         this.putArchiveEntry((ArchiveEntry)ae, is2PhaseSource);\n         this.copyFromZipInputStream(rawStream);\n         this.closeCopiedEntry(is2PhaseSource);\n     }\n     \n     private void flushDeflater() throws IOException {\n-        if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getMethod() == 8) {\n+        if (ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getMethod() == 8) {\n             this.streamCompressor.flushDeflater();\n         }\n     }\n     \n     private boolean handleSizesAndCrc(final long bytesWritten, final long crc, final Zip64Mode effectiveMode) throws ZipException {\n-        if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getMethod() == 8) {\n-            ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setSize(ZipArchiveOutputStream.CurrentEntry.access$100(this.entry));\n-            ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setCompressedSize(bytesWritten);\n-            ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setCrc(crc);\n+        if (ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getMethod() == 8) {\n+            ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).setSize(ZipArchiveOutputStream.CurrentEntry.access$4(this.entry));\n+            ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).setCompressedSize(bytesWritten);\n+            ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).setCrc(crc);\n         }\n         else if (this.channel == null) {\n-            if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getCrc() != crc) {\n-                throw new ZipException(\"bad CRC checksum for entry \" + ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getName() + \": \" + Long.toHexString(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getCrc()) + \" instead of \" + Long.toHexString(crc));\n+            if (ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getCrc() != crc) {\n+                throw new ZipException(\"bad CRC checksum for entry \" + ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getName() + \": \" + Long.toHexString(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getCrc()) + \" instead of \" + Long.toHexString(crc));\n             }\n-            if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize() != bytesWritten) {\n-                throw new ZipException(\"bad size for entry \" + ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getName() + \": \" + ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize() + \" instead of \" + bytesWritten);\n+            if (ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getSize() != bytesWritten) {\n+                throw new ZipException(\"bad size for entry \" + ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getName() + \": \" + ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getSize() + \" instead of \" + bytesWritten);\n             }\n         }\n         else {\n-            ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setSize(bytesWritten);\n-            ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setCompressedSize(bytesWritten);\n-            ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setCrc(crc);\n+            ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).setSize(bytesWritten);\n+            ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).setCompressedSize(bytesWritten);\n+            ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).setCrc(crc);\n         }\n         return this.checkIfNeedsZip64(effectiveMode);\n     }\n     \n     private boolean checkIfNeedsZip64(final Zip64Mode effectiveMode) throws ZipException {\n-        final boolean actuallyNeedsZip64 = this.isZip64Required(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry), effectiveMode);\n+        final boolean actuallyNeedsZip64 = this.isZip64Required(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry), effectiveMode);\n         if (actuallyNeedsZip64 && effectiveMode == Zip64Mode.Never) {\n-            throw new Zip64RequiredException(Zip64RequiredException.getEntryTooBigMessage(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry)));\n+            throw new Zip64RequiredException(Zip64RequiredException.getEntryTooBigMessage(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry)));\n         }\n         return actuallyNeedsZip64;\n     }\n     \n     private boolean isZip64Required(final ZipArchiveEntry entry1, final Zip64Mode requestedMode) {\n         return requestedMode == Zip64Mode.Always || this.isTooLageForZip32(entry1);\n     }\n     \n     private boolean isTooLageForZip32(final ZipArchiveEntry zipArchiveEntry) {\n         return zipArchiveEntry.getSize() >= 4294967295L || zipArchiveEntry.getCompressedSize() >= 4294967295L;\n     }\n     \n     private void rewriteSizesAndCrc(final boolean actuallyNeedsZip64) throws IOException {\n         final long save = this.channel.position();\n-        this.channel.position(ZipArchiveOutputStream.CurrentEntry.access$400(this.entry));\n-        this.writeOut(ZipLong.getBytes(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getCrc()));\n-        if (!this.hasZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry)) || !actuallyNeedsZip64) {\n-            this.writeOut(ZipLong.getBytes(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getCompressedSize()));\n-            this.writeOut(ZipLong.getBytes(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize()));\n+        this.channel.position(ZipArchiveOutputStream.CurrentEntry.access$5(this.entry));\n+        this.writeOut(ZipLong.getBytes(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getCrc()));\n+        if (!this.hasZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry)) || !actuallyNeedsZip64) {\n+            this.writeOut(ZipLong.getBytes(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getCompressedSize()));\n+            this.writeOut(ZipLong.getBytes(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getSize()));\n         }\n         else {\n             this.writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n             this.writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n         }\n-        if (this.hasZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry))) {\n-            final ByteBuffer name = this.getName(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n+        if (this.hasZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry))) {\n+            final ByteBuffer name = this.getName(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry));\n             final int nameLen = name.limit() - name.position();\n-            this.channel.position(ZipArchiveOutputStream.CurrentEntry.access$400(this.entry) + 12L + 4L + nameLen + 4L);\n-            this.writeOut(ZipEightByteInteger.getBytes(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize()));\n-            this.writeOut(ZipEightByteInteger.getBytes(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getCompressedSize()));\n+            this.channel.position(ZipArchiveOutputStream.CurrentEntry.access$5(this.entry) + 12L + 4L + nameLen + 4L);\n+            this.writeOut(ZipEightByteInteger.getBytes(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getSize()));\n+            this.writeOut(ZipEightByteInteger.getBytes(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getCompressedSize()));\n             if (!actuallyNeedsZip64) {\n-                this.channel.position(ZipArchiveOutputStream.CurrentEntry.access$400(this.entry) - 10L);\n-                this.writeOut(ZipShort.getBytes(this.versionNeededToExtract(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getMethod(), false, false)));\n-                ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).removeExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n-                ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setExtra();\n-                if (ZipArchiveOutputStream.CurrentEntry.access$500(this.entry)) {\n+                this.channel.position(ZipArchiveOutputStream.CurrentEntry.access$5(this.entry) - 10L);\n+                this.writeOut(ZipShort.getBytes(this.versionNeededToExtract(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getMethod(), false, false)));\n+                ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).removeExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n+                ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).setExtra();\n+                if (ZipArchiveOutputStream.CurrentEntry.access$6(this.entry)) {\n                     this.hasUsedZip64 = false;\n                 }\n             }\n         }\n         this.channel.position(save);\n     }\n     \n@@ -387,38 +399,38 @@\n     private void putArchiveEntry(final ArchiveEntry archiveEntry, final boolean phased) throws IOException {\n         if (this.finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n         if (this.entry != null) {\n             this.closeArchiveEntry();\n         }\n-        this.entry = new ZipArchiveOutputStream.CurrentEntry((ZipArchiveEntry)archiveEntry, (ZipArchiveOutputStream.ZipArchiveOutputStream$1)null);\n-        this.entries.add(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n-        this.setDefaults(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n-        final Zip64Mode effectiveMode = this.getEffectiveZip64Mode(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n+        this.entry = new ZipArchiveOutputStream.CurrentEntry((ZipArchiveEntry)archiveEntry, (ZipArchiveOutputStream.CurrentEntry)null);\n+        this.entries.add(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry));\n+        this.setDefaults(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry));\n+        final Zip64Mode effectiveMode = this.getEffectiveZip64Mode(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry));\n         this.validateSizeInformation(effectiveMode);\n-        if (this.shouldAddZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry), effectiveMode)) {\n-            final Zip64ExtendedInformationExtraField z64 = this.getZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n+        if (this.shouldAddZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry), effectiveMode)) {\n+            final Zip64ExtendedInformationExtraField z64 = this.getZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry));\n             ZipEightByteInteger size;\n             ZipEightByteInteger compressedSize;\n             if (phased) {\n-                size = new ZipEightByteInteger(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize());\n-                compressedSize = new ZipEightByteInteger(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getCompressedSize());\n+                size = new ZipEightByteInteger(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getSize());\n+                compressedSize = new ZipEightByteInteger(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getCompressedSize());\n             }\n-            else if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getMethod() == 0 && ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize() != -1L) {\n-                size = (compressedSize = new ZipEightByteInteger(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize()));\n+            else if (ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getMethod() == 0 && ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getSize() != -1L) {\n+                size = (compressedSize = new ZipEightByteInteger(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getSize()));\n             }\n             else {\n                 size = (compressedSize = ZipEightByteInteger.ZERO);\n             }\n             z64.setSize(size);\n             z64.setCompressedSize(compressedSize);\n-            ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setExtra();\n+            ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).setExtra();\n         }\n-        if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getMethod() == 8 && this.hasCompressionLevelChanged) {\n+        if (ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getMethod() == 8 && this.hasCompressionLevelChanged) {\n             this.def.setLevel(this.level);\n             this.hasCompressionLevelChanged = false;\n         }\n         this.writeLocalFileHeader((ZipArchiveEntry)archiveEntry, phased);\n     }\n     \n     private void setDefaults(final ZipArchiveEntry entry) {\n@@ -427,25 +439,25 @@\n         }\n         if (entry.getTime() == -1L) {\n             entry.setTime(System.currentTimeMillis());\n         }\n     }\n     \n     private void validateSizeInformation(final Zip64Mode effectiveMode) throws ZipException {\n-        if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getMethod() == 0 && this.channel == null) {\n-            if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize() == -1L) {\n+        if (ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getMethod() == 0 && this.channel == null) {\n+            if (ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getSize() == -1L) {\n                 throw new ZipException(\"uncompressed size is required for STORED method when not writing to a file\");\n             }\n-            if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getCrc() == -1L) {\n+            if (ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getCrc() == -1L) {\n                 throw new ZipException(\"crc checksum is required for STORED method when not writing to a file\");\n             }\n-            ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setCompressedSize(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize());\n+            ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).setCompressedSize(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getSize());\n         }\n-        if ((ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize() >= 4294967295L || ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getCompressedSize() >= 4294967295L) && effectiveMode == Zip64Mode.Never) {\n-            throw new Zip64RequiredException(Zip64RequiredException.getEntryTooBigMessage(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry)));\n+        if ((ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getSize() >= 4294967295L || ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getCompressedSize() >= 4294967295L) && effectiveMode == Zip64Mode.Never) {\n+            throw new Zip64RequiredException(Zip64RequiredException.getEntryTooBigMessage(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry)));\n         }\n     }\n     \n     private boolean shouldAddZip64Extra(final ZipArchiveEntry entry, final Zip64Mode mode) {\n         return mode == Zip64Mode.Always || entry.getSize() >= 4294967295L || entry.getCompressedSize() >= 4294967295L || (entry.getSize() == -1L && this.channel != null && mode != Zip64Mode.Never);\n     }\n     \n@@ -473,29 +485,29 @@\n         return false;\n     }\n     \n     public void write(final byte[] b, final int offset, final int length) throws IOException {\n         if (this.entry == null) {\n             throw new IllegalStateException(\"No current entry\");\n         }\n-        ZipUtil.checkRequestedFeatures(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n-        final long writtenThisTime = this.streamCompressor.write(b, offset, length, ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getMethod());\n+        ZipUtil.checkRequestedFeatures(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry));\n+        final long writtenThisTime = this.streamCompressor.write(b, offset, length, ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getMethod());\n         this.count(writtenThisTime);\n     }\n     \n     private void writeCounted(final byte[] data) throws IOException {\n         this.streamCompressor.writeCounted(data);\n     }\n     \n     private void copyFromZipInputStream(final InputStream src) throws IOException {\n         if (this.entry == null) {\n             throw new IllegalStateException(\"No current entry\");\n         }\n-        ZipUtil.checkRequestedFeatures(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n-        ZipArchiveOutputStream.CurrentEntry.access$302(this.entry, true);\n+        ZipUtil.checkRequestedFeatures(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry));\n+        ZipArchiveOutputStream.CurrentEntry.access$8(this.entry, true);\n         int length;\n         while ((length = src.read(this.copyBuffer)) >= 0) {\n             this.streamCompressor.writeCounted(this.copyBuffer, 0, length);\n             this.count(length);\n         }\n     }\n     \n@@ -524,18 +536,18 @@\n         final boolean encodable = this.zipEncoding.canEncode(ze.getName());\n         final ByteBuffer name = this.getName(ze);\n         if (this.createUnicodeExtraFields != ZipArchiveOutputStream.UnicodeExtraFieldPolicy.NEVER) {\n             this.addUnicodeExtraFields(ze, encodable, name);\n         }\n         final long localHeaderStart = this.streamCompressor.getTotalBytesWritten();\n         final byte[] localHeader = this.createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n-        this.metaData.put(ze, new ZipArchiveOutputStream.EntryMetaData(localHeaderStart, this.usesDataDescriptor(ze.getMethod(), phased), (ZipArchiveOutputStream.ZipArchiveOutputStream$1)null));\n-        ZipArchiveOutputStream.CurrentEntry.access$402(this.entry, localHeaderStart + 14L);\n+        this.metaData.put(ze, new ZipArchiveOutputStream.EntryMetaData(localHeaderStart, this.usesDataDescriptor(ze.getMethod(), phased), (ZipArchiveOutputStream.EntryMetaData)null));\n+        ZipArchiveOutputStream.CurrentEntry.access$9(this.entry, localHeaderStart + 14L);\n         this.writeCounted(localHeader);\n-        ZipArchiveOutputStream.CurrentEntry.access$002(this.entry, this.streamCompressor.getTotalBytesWritten());\n+        ZipArchiveOutputStream.CurrentEntry.access$10(this.entry, this.streamCompressor.getTotalBytesWritten());\n     }\n     \n     private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, final long archiveOffset) {\n         final ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField)ze.getExtraField(ResourceAlignmentExtraField.ID);\n         if (oldAlignmentEx != null) {\n             ze.removeExtraField(ResourceAlignmentExtraField.ID);\n         }\n@@ -565,15 +577,15 @@\n         }\n         else if (zipMethod == 8 || this.channel != null) {\n             System.arraycopy(ZipArchiveOutputStream.LZERO, 0, buf, 14, 4);\n         }\n         else {\n             ZipLong.putLong(ze.getCrc(), buf, 14);\n         }\n-        if (this.hasZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry))) {\n+        if (this.hasZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry))) {\n             ZipLong.ZIP64_MAGIC.putLong(buf, 18);\n             ZipLong.ZIP64_MAGIC.putLong(buf, 22);\n         }\n         else if (phased) {\n             ZipLong.putLong(ze.getCompressedSize(), buf, 18);\n             ZipLong.putLong(ze.getSize(), buf, 22);\n         }\n@@ -625,19 +637,19 @@\n     protected void writeCentralFileHeader(final ZipArchiveEntry ze) throws IOException {\n         final byte[] centralFileHeader = this.createCentralFileHeader(ze);\n         this.writeCounted(centralFileHeader);\n     }\n     \n     private byte[] createCentralFileHeader(final ZipArchiveEntry ze) throws IOException {\n         final ZipArchiveOutputStream.EntryMetaData entryMetaData = (ZipArchiveOutputStream.EntryMetaData)this.metaData.get(ze);\n-        final boolean needsZip64Extra = this.hasZip64Extra(ze) || ze.getCompressedSize() >= 4294967295L || ze.getSize() >= 4294967295L || ZipArchiveOutputStream.EntryMetaData.access$800(entryMetaData) >= 4294967295L || this.zip64Mode == Zip64Mode.Always;\n+        final boolean needsZip64Extra = this.hasZip64Extra(ze) || ze.getCompressedSize() >= 4294967295L || ze.getSize() >= 4294967295L || ZipArchiveOutputStream.EntryMetaData.access$1(entryMetaData) >= 4294967295L || this.zip64Mode == Zip64Mode.Always;\n         if (needsZip64Extra && this.zip64Mode == Zip64Mode.Never) {\n             throw new Zip64RequiredException(\"archive's size exceeds the limit of 4GByte.\");\n         }\n-        this.handleZip64Extra(ze, ZipArchiveOutputStream.EntryMetaData.access$800(entryMetaData), needsZip64Extra);\n+        this.handleZip64Extra(ze, ZipArchiveOutputStream.EntryMetaData.access$1(entryMetaData), needsZip64Extra);\n         return this.createCentralFileHeader(ze, this.getName(ze), entryMetaData, needsZip64Extra);\n     }\n     \n     private byte[] createCentralFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final ZipArchiveOutputStream.EntryMetaData entryMetaData, final boolean needsZip64Extra) throws IOException {\n         final byte[] extra = ze.getCentralDirectoryExtra();\n         String comm = ze.getComment();\n         if (comm == null) {\n@@ -648,16 +660,16 @@\n         final int commentLen = commentB.limit() - commentB.position();\n         final int len = 46 + nameLen + extra.length + commentLen;\n         final byte[] buf = new byte[len];\n         System.arraycopy(ZipArchiveOutputStream.CFH_SIG, 0, buf, 0, 4);\n         ZipShort.putShort(ze.getPlatform() << 8 | (this.hasUsedZip64 ? 45 : 20), buf, 4);\n         final int zipMethod = ze.getMethod();\n         final boolean encodable = this.zipEncoding.canEncode(ze.getName());\n-        ZipShort.putShort(this.versionNeededToExtract(zipMethod, needsZip64Extra, ZipArchiveOutputStream.EntryMetaData.access$900(entryMetaData)), buf, 6);\n-        this.getGeneralPurposeBits(!encodable && this.fallbackToUTF8, ZipArchiveOutputStream.EntryMetaData.access$900(entryMetaData)).encode(buf, 8);\n+        ZipShort.putShort(this.versionNeededToExtract(zipMethod, needsZip64Extra, ZipArchiveOutputStream.EntryMetaData.access$2(entryMetaData)), buf, 6);\n+        this.getGeneralPurposeBits(!encodable && this.fallbackToUTF8, ZipArchiveOutputStream.EntryMetaData.access$2(entryMetaData)).encode(buf, 8);\n         ZipShort.putShort(zipMethod, buf, 10);\n         ZipUtil.toDosTime(this.calendarInstance, ze.getTime(), buf, 12);\n         ZipLong.putLong(ze.getCrc(), buf, 16);\n         if (ze.getCompressedSize() >= 4294967295L || ze.getSize() >= 4294967295L || this.zip64Mode == Zip64Mode.Always) {\n             ZipLong.ZIP64_MAGIC.putLong(buf, 20);\n             ZipLong.ZIP64_MAGIC.putLong(buf, 24);\n         }\n@@ -667,19 +679,19 @@\n         }\n         ZipShort.putShort(nameLen, buf, 28);\n         ZipShort.putShort(extra.length, buf, 30);\n         ZipShort.putShort(commentLen, buf, 32);\n         System.arraycopy(ZipArchiveOutputStream.ZERO, 0, buf, 34, 2);\n         ZipShort.putShort(ze.getInternalAttributes(), buf, 36);\n         ZipLong.putLong(ze.getExternalAttributes(), buf, 38);\n-        if (ZipArchiveOutputStream.EntryMetaData.access$800(entryMetaData) >= 4294967295L || this.zip64Mode == Zip64Mode.Always) {\n+        if (ZipArchiveOutputStream.EntryMetaData.access$1(entryMetaData) >= 4294967295L || this.zip64Mode == Zip64Mode.Always) {\n             ZipLong.putLong(4294967295L, buf, 42);\n         }\n         else {\n-            ZipLong.putLong(Math.min(ZipArchiveOutputStream.EntryMetaData.access$800(entryMetaData), 4294967295L), buf, 42);\n+            ZipLong.putLong(Math.min(ZipArchiveOutputStream.EntryMetaData.access$1(entryMetaData), 4294967295L), buf, 42);\n         }\n         System.arraycopy(name.array(), name.arrayOffset(), buf, 46, nameLen);\n         final int extraStart = 46 + nameLen;\n         System.arraycopy(extra, 0, buf, extraStart, extra.length);\n         final int commentStart = extraStart + extra.length;\n         System.arraycopy(commentB.array(), commentB.arrayOffset(), buf, commentStart, commentLen);\n         return buf;\n@@ -793,15 +805,15 @@\n             throw new IOException(\"Stream has already been finished\");\n         }\n         return (ArchiveEntry)new ZipArchiveEntry(inputFile, entryName);\n     }\n     \n     private Zip64ExtendedInformationExtraField getZip64Extra(final ZipArchiveEntry ze) {\n         if (this.entry != null) {\n-            ZipArchiveOutputStream.CurrentEntry.access$502(this.entry, !this.hasUsedZip64);\n+            ZipArchiveOutputStream.CurrentEntry.access$11(this.entry, !this.hasUsedZip64);\n         }\n         this.hasUsedZip64 = true;\n         Zip64ExtendedInformationExtraField z64 = (Zip64ExtendedInformationExtraField)ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n         if (z64 == null) {\n             z64 = new Zip64ExtendedInformationExtraField();\n         }\n         ze.addAsFirstExtraField((ZipExtraField)z64);\n@@ -832,21 +844,8 @@\n         if (this.channel != null) {\n             this.channel.close();\n         }\n         if (this.out != null) {\n             this.out.close();\n         }\n     }\n-    \n-    static {\n-        EMPTY = new byte[0];\n-        ZERO = new byte[] { 0, 0 };\n-        LZERO = new byte[] { 0, 0, 0, 0 };\n-        ONE = ZipLong.getBytes(1L);\n-        LFH_SIG = ZipLong.LFH_SIG.getBytes();\n-        DD_SIG = ZipLong.DD_SIG.getBytes();\n-        CFH_SIG = ZipLong.CFH_SIG.getBytes();\n-        EOCD_SIG = ZipLong.getBytes(101010256L);\n-        ZIP64_EOCD_SIG = ZipLong.getBytes(101075792L);\n-        ZIP64_EOCD_LOC_SIG = ZipLong.getBytes(117853008L);\n-    }\n }\n"}]}
