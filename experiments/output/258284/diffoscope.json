{"diffoscope-json-version": 1, "source1": "first/BasicBuilderParameters.class", "source2": "second/BasicBuilderParameters.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -31,201 +31,232 @@\n     private Map<String, Object> properties;\n     \n     public BasicBuilderParameters() {\n         this.properties = new HashMap<String, Object>();\n     }\n     \n     public Map<String, Object> getParameters() {\n-        final HashMap<String, Object> result = new HashMap<String, Object>(this.properties);\n-        if (result.containsKey(\"interpolator\")) {\n-            result.remove(\"prefixLookups\");\n-            result.remove(\"defaultLookups\");\n-            result.remove(\"parentInterpolator\");\n+        final HashMap hashMap = new HashMap((Map<? extends K, ? extends V>)this.properties);\n+        if (hashMap.containsKey(\"interpolator\")) {\n+            hashMap.remove(\"prefixLookups\");\n+            hashMap.remove(\"defaultLookups\");\n+            hashMap.remove(\"parentInterpolator\");\n         }\n-        createDefensiveCopies(result);\n-        return result;\n+        createDefensiveCopies(hashMap);\n+        return hashMap;\n     }\n     \n-    public BasicBuilderParameters setLogger(final ConfigurationLogger log) {\n-        return this.setProperty(\"logger\", log);\n+    public BasicBuilderParameters setLogger(final ConfigurationLogger configurationLogger) {\n+        return this.setProperty(\"logger\", configurationLogger);\n     }\n     \n     public BasicBuilderParameters setThrowExceptionOnMissing(final boolean b) {\n         return this.setProperty(\"throwExceptionOnMissing\", Boolean.valueOf(b));\n     }\n     \n-    public BasicBuilderParameters setListDelimiterHandler(final ListDelimiterHandler handler) {\n-        return this.setProperty(\"listDelimiterHandler\", handler);\n+    public BasicBuilderParameters setListDelimiterHandler(final ListDelimiterHandler listDelimiterHandler) {\n+        return this.setProperty(\"listDelimiterHandler\", listDelimiterHandler);\n     }\n     \n-    public BasicBuilderParameters setInterpolator(final ConfigurationInterpolator ci) {\n-        return this.setProperty(\"interpolator\", ci);\n+    public BasicBuilderParameters setInterpolator(final ConfigurationInterpolator configurationInterpolator) {\n+        return this.setProperty(\"interpolator\", configurationInterpolator);\n     }\n     \n-    public BasicBuilderParameters setPrefixLookups(final Map<String, ? extends Lookup> lookups) {\n-        if (lookups == null) {\n+    public BasicBuilderParameters setPrefixLookups(final Map<String, ? extends Lookup> m) {\n+        if (m == null) {\n             this.properties.remove(\"prefixLookups\");\n             return this;\n         }\n-        return this.setProperty(\"prefixLookups\", new HashMap(lookups));\n+        return this.setProperty(\"prefixLookups\", new HashMap(m));\n     }\n     \n-    public BasicBuilderParameters setDefaultLookups(final Collection<? extends Lookup> lookups) {\n-        if (lookups == null) {\n+    public BasicBuilderParameters setDefaultLookups(final Collection<? extends Lookup> c) {\n+        if (c == null) {\n             this.properties.remove(\"defaultLookups\");\n             return this;\n         }\n-        return this.setProperty(\"defaultLookups\", new ArrayList(lookups));\n+        return this.setProperty(\"defaultLookups\", new ArrayList(c));\n     }\n     \n-    public BasicBuilderParameters setParentInterpolator(final ConfigurationInterpolator parent) {\n-        return this.setProperty(\"parentInterpolator\", parent);\n+    public BasicBuilderParameters setParentInterpolator(final ConfigurationInterpolator configurationInterpolator) {\n+        return this.setProperty(\"parentInterpolator\", configurationInterpolator);\n     }\n     \n-    public BasicBuilderParameters setSynchronizer(final Synchronizer sync) {\n-        return this.setProperty(\"synchronizer\", sync);\n+    public BasicBuilderParameters setSynchronizer(final Synchronizer synchronizer) {\n+        return this.setProperty(\"synchronizer\", synchronizer);\n     }\n     \n-    public BasicBuilderParameters setConversionHandler(final ConversionHandler handler) {\n-        return this.setProperty(\"conversionHandler\", handler);\n+    public BasicBuilderParameters setConversionHandler(final ConversionHandler conversionHandler) {\n+        return this.setProperty(\"conversionHandler\", conversionHandler);\n     }\n     \n     public BasicBuilderParameters setBeanHelper(final BeanHelper beanHelper) {\n         return this.setProperty(\"config-BeanHelper\", beanHelper);\n     }\n     \n-    public BasicBuilderParameters setConfigurationDecoder(final ConfigurationDecoder decoder) {\n-        return this.setProperty(\"configurationDecoder\", decoder);\n+    public BasicBuilderParameters setConfigurationDecoder(final ConfigurationDecoder configurationDecoder) {\n+        return this.setProperty(\"configurationDecoder\", configurationDecoder);\n     }\n     \n-    public void merge(final BuilderParameters p) {\n-        if (p == null) {\n+    public void merge(final BuilderParameters builderParameters) {\n+        if (builderParameters == null) {\n             throw new IllegalArgumentException(\"Parameters to merge must not be null!\");\n         }\n-        p.getParameters().forEach((k, v) -> {\n-            if (!this.properties.containsKey(k) && !k.startsWith(\"config-\")) {\n-                this.storeProperty(k, v);\n+        builderParameters.getParameters().forEach((s, o) -> {\n+            if (!this.properties.containsKey(s) && !s.startsWith(\"config-\")) {\n+                this.storeProperty(s, o);\n             }\n         });\n     }\n     \n-    public void inheritFrom(final Map<String, ?> source) {\n-        if (source == null) {\n+    public void inheritFrom(final Map<String, ?> map) {\n+        if (map == null) {\n             throw new IllegalArgumentException(\"Source properties must not be null!\");\n         }\n-        this.copyPropertiesFrom(source, \"config-BeanHelper\", \"configurationDecoder\", \"conversionHandler\", \"listDelimiterHandler\", \"logger\", \"synchronizer\", \"throwExceptionOnMissing\");\n+        this.copyPropertiesFrom(map, \"config-BeanHelper\", \"configurationDecoder\", \"conversionHandler\", \"listDelimiterHandler\", \"logger\", \"synchronizer\", \"throwExceptionOnMissing\");\n     }\n     \n-    public static InterpolatorSpecification fetchInterpolatorSpecification(final Map<String, Object> params) {\n-        checkParameters(params);\n-        return new InterpolatorSpecification.Builder().withInterpolator((ConfigurationInterpolator)fetchParameter(params, \"interpolator\", ConfigurationInterpolator.class)).withParentInterpolator((ConfigurationInterpolator)fetchParameter(params, \"parentInterpolator\", ConfigurationInterpolator.class)).withPrefixLookups((Map)fetchAndCheckPrefixLookups(params)).withDefaultLookups((Collection)fetchAndCheckDefaultLookups(params)).create();\n+    public static InterpolatorSpecification fetchInterpolatorSpecification(final Map<String, Object> map) {\n+        checkParameters(map);\n+        return new InterpolatorSpecification.Builder().withInterpolator((ConfigurationInterpolator)fetchParameter(map, \"interpolator\", ConfigurationInterpolator.class)).withParentInterpolator((ConfigurationInterpolator)fetchParameter(map, \"parentInterpolator\", ConfigurationInterpolator.class)).withPrefixLookups((Map)fetchAndCheckPrefixLookups(map)).withDefaultLookups((Collection)fetchAndCheckDefaultLookups(map)).create();\n     }\n     \n-    public static BeanHelper fetchBeanHelper(final Map<String, Object> params) {\n-        checkParameters(params);\n-        return params.get(\"config-BeanHelper\");\n+    public static BeanHelper fetchBeanHelper(final Map<String, Object> map) {\n+        checkParameters(map);\n+        return map.get(\"config-BeanHelper\");\n     }\n     \n     public BasicBuilderParameters clone() {\n         try {\n-            final BasicBuilderParameters copy = (BasicBuilderParameters)super.clone();\n-            copy.properties = this.getParameters();\n-            return copy;\n+            final BasicBuilderParameters basicBuilderParameters = (BasicBuilderParameters)super.clone();\n+            basicBuilderParameters.properties = this.getParameters();\n+            return basicBuilderParameters;\n         }\n-        catch (final CloneNotSupportedException cnex) {\n-            throw new AssertionError((Object)cnex);\n+        catch (final CloneNotSupportedException detailMessage) {\n+            throw new AssertionError((Object)detailMessage);\n         }\n     }\n     \n-    protected void storeProperty(final String key, final Object value) {\n-        if (value == null) {\n-            this.properties.remove(key);\n+    protected void storeProperty(final String s, final Object o) {\n+        if (o == null) {\n+            this.properties.remove(s);\n         }\n         else {\n-            this.properties.put(key, value);\n+            this.properties.put(s, o);\n         }\n     }\n     \n-    protected Object fetchProperty(final String key) {\n-        return this.properties.get(key);\n+    protected Object fetchProperty(final String s) {\n+        return this.properties.get(s);\n     }\n     \n-    protected void copyPropertiesFrom(final Map<String, ?> source, final String... keys) {\n-        for (final String key : keys) {\n-            final Object value = source.get(key);\n+    protected void copyPropertiesFrom(final Map<String, ?> map, final String... array) {\n+        for (final String s : array) {\n+            final Object value = map.get(s);\n             if (value != null) {\n-                this.storeProperty(key, value);\n+                this.storeProperty(s, value);\n             }\n         }\n     }\n     \n-    private BasicBuilderParameters setProperty(final String key, final Object value) {\n-        this.storeProperty(key, value);\n+    private BasicBuilderParameters setProperty(final String s, final Object o) {\n+        this.storeProperty(s, o);\n         return this;\n     }\n     \n-    private static void createDefensiveCopies(final HashMap<String, Object> params) {\n-        final Map<String, ? extends Lookup> prefixLookups = fetchPrefixLookups(params);\n-        if (prefixLookups != null) {\n-            params.put(\"prefixLookups\", new HashMap<String, HashMap>((Map<? extends String, ? extends HashMap>)prefixLookups));\n-        }\n-        final Collection<? extends Lookup> defLookups = fetchDefaultLookups(params);\n-        if (defLookups != null) {\n-            params.put(\"defaultLookups\", new ArrayList((Collection<?>)defLookups));\n-        }\n-    }\n-    \n-    private static Map<String, ? extends Lookup> fetchPrefixLookups(final Map<String, Object> params) {\n-        final Map<String, ? extends Lookup> prefixLookups = (Map<String, ? extends Lookup>)params.get(\"prefixLookups\");\n-        return prefixLookups;\n-    }\n-    \n-    private static Map<String, ? extends Lookup> fetchAndCheckPrefixLookups(final Map<String, Object> params) {\n-        final Map<?, ?> prefixes = (Map)fetchParameter(params, \"prefixLookups\", Map.class);\n-        if (prefixes == null) {\n-            return null;\n-        }\n-        prefixes.forEach((k, v) -> {\n-            if (!(k instanceof String) || !(v instanceof Lookup)) {\n-                new IllegalArgumentException(\"Map with prefix lookups contains invalid data: \" + prefixes);\n-                throw;\n-            }\n-            else {\n-                return;\n-            }\n-        });\n-        return fetchPrefixLookups(params);\n-    }\n-    \n-    private static Collection<? extends Lookup> fetchDefaultLookups(final Map<String, Object> params) {\n-        final Collection<? extends Lookup> defLookups = (Collection<? extends Lookup>)params.get(\"defaultLookups\");\n-        return defLookups;\n-    }\n-    \n-    private static Collection<? extends Lookup> fetchAndCheckDefaultLookups(final Map<String, Object> params) {\n-        final Collection<?> col = (Collection)fetchParameter(params, \"defaultLookups\", Collection.class);\n-        if (col == null) {\n+    private static void createDefensiveCopies(final HashMap<String, Object> hashMap) {\n+        final Map<String, ? extends Lookup> fetchPrefixLookups = fetchPrefixLookups(hashMap);\n+        if (fetchPrefixLookups != null) {\n+            hashMap.put(\"prefixLookups\", new HashMap(fetchPrefixLookups));\n+        }\n+        final Collection<? extends Lookup> fetchDefaultLookups = fetchDefaultLookups(hashMap);\n+        if (fetchDefaultLookups != null) {\n+            hashMap.put(\"defaultLookups\", new ArrayList(fetchDefaultLookups));\n+        }\n+    }\n+    \n+    private static Map<String, ? extends Lookup> fetchPrefixLookups(final Map<String, Object> map) {\n+        return map.get(\"prefixLookups\");\n+    }\n+    \n+    private static Map<String, ? extends Lookup> fetchAndCheckPrefixLookups(final Map<String, Object> p0) {\n+        // \n+        // This method could not be decompiled.\n+        // \n+        // Original Bytecode:\n+        // \n+        //     1: ldc             \"prefixLookups\"\n+        //     3: ldc             Ljava/util/Map;.class\n+        //     5: invokestatic    org/apache/commons/configuration2/builder/BasicBuilderParameters.fetchParameter:(Ljava/util/Map;Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/Object;\n+        //     8: checkcast       Ljava/util/Map;\n+        //    11: astore_1       \n+        //    12: aload_1        \n+        //    13: ifnonnull       18\n+        //    16: aconst_null    \n+        //    17: areturn        \n+        //    18: aload_1        \n+        //    19: aload_1        \n+        //    20: invokedynamic   BootstrapMethod #1, accept:(Ljava/util/Map;)Ljava/util/function/BiConsumer;\n+        //    25: invokeinterface java/util/Map.forEach:(Ljava/util/function/BiConsumer;)V\n+        //    30: aload_0        \n+        //    31: invokestatic    org/apache/commons/configuration2/builder/BasicBuilderParameters.fetchPrefixLookups:(Ljava/util/Map;)Ljava/util/Map;\n+        //    34: areturn        \n+        //    Signature:\n+        //  (Ljava/util/Map<Ljava/lang/String;Ljava/lang/Object;>;)Ljava/util/Map<Ljava/lang/String;+Lorg/apache/commons/configuration2/interpol/Lookup;>;\n+        //    StackMapTable: 00 01 FC 00 12 07 00 3A\n+        // \n+        // The error that occurred was:\n+        // \n+        // java.lang.IllegalStateException: Could not infer any expression.\n+        //     at com.strobel.decompiler.ast.TypeAnalysis.runInference(TypeAnalysis.java:382)\n+        //     at com.strobel.decompiler.ast.TypeAnalysis.run(TypeAnalysis.java:95)\n+        //     at com.strobel.decompiler.ast.AstOptimizer.optimize(AstOptimizer.java:344)\n+        //     at com.strobel.decompiler.ast.AstOptimizer.optimize(AstOptimizer.java:42)\n+        //     at com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.createMethodBody(AstMethodBodyBuilder.java:206)\n+        //     at com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.createMethodBody(AstMethodBodyBuilder.java:93)\n+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createMethodBody(AstBuilder.java:868)\n+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createMethod(AstBuilder.java:761)\n+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.addTypeMembers(AstBuilder.java:638)\n+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createTypeCore(AstBuilder.java:605)\n+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createTypeNoCache(AstBuilder.java:195)\n+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createType(AstBuilder.java:162)\n+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.addType(AstBuilder.java:137)\n+        //     at com.strobel.decompiler.languages.java.JavaLanguage.buildAst(JavaLanguage.java:71)\n+        //     at com.strobel.decompiler.languages.java.JavaLanguage.decompileType(JavaLanguage.java:59)\n+        //     at com.strobel.decompiler.DecompilerDriver.decompileType(DecompilerDriver.java:333)\n+        //     at com.strobel.decompiler.DecompilerDriver.main(DecompilerDriver.java:147)\n+        // \n+        throw new IllegalStateException(\"An error occurred while decompiling this method.\");\n+    }\n+    \n+    private static Collection<? extends Lookup> fetchDefaultLookups(final Map<String, Object> map) {\n+        return map.get(\"defaultLookups\");\n+    }\n+    \n+    private static Collection<? extends Lookup> fetchAndCheckDefaultLookups(final Map<String, Object> map) {\n+        final Collection obj = (Collection)fetchParameter(map, \"defaultLookups\", Collection.class);\n+        if (obj == null) {\n             return null;\n         }\n-        if (col.stream().noneMatch(o -> o instanceof Lookup)) {\n-            throw new IllegalArgumentException(\"Collection with default lookups contains invalid data: \" + col);\n+        if (obj.stream().noneMatch(o -> o instanceof Lookup)) {\n+            throw new IllegalArgumentException(\"Collection with default lookups contains invalid data: \" + obj);\n         }\n-        return fetchDefaultLookups(params);\n+        return fetchDefaultLookups(map);\n     }\n     \n-    private static <T> T fetchParameter(final Map<String, Object> params, final String key, final Class<T> expClass) {\n-        final Object value = params.get(key);\n+    private static <T> T fetchParameter(final Map<String, Object> map, final String s, final Class<T> clazz) {\n+        final Object value = map.get(s);\n         if (value == null) {\n             return null;\n         }\n-        if (!expClass.isInstance(value)) {\n-            throw new IllegalArgumentException(String.format(\"Parameter %s is not of type %s!\", key, expClass.getSimpleName()));\n+        if (!clazz.isInstance(value)) {\n+            throw new IllegalArgumentException(String.format(\"Parameter %s is not of type %s!\", s, clazz.getSimpleName()));\n         }\n-        return expClass.cast(value);\n+        return (T)clazz.cast(value);\n     }\n     \n-    private static void checkParameters(final Map<String, Object> params) {\n-        if (params == null) {\n+    private static void checkParameters(final Map<String, Object> map) {\n+        if (map == null) {\n             throw new IllegalArgumentException(\"Parameters map must not be null!\");\n         }\n     }\n }\n"}]}
