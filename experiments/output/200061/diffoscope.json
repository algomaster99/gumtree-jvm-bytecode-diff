{"diffoscope-json-version": 1, "source1": "first/ClassGen.class", "source2": "second/ClassGen.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,15 +1,14 @@\n \n package org.apache.bcel.generic;\n \n import org.apache.bcel.classfile.AnnotationEntry;\n import org.apache.bcel.classfile.RuntimeInvisibleAnnotations;\n import org.apache.bcel.classfile.RuntimeVisibleAnnotations;\n import org.apache.bcel.classfile.Utility;\n-import org.apache.bcel.classfile.ConstantPool;\n import java.util.Arrays;\n import org.apache.commons.lang3.ArrayUtils;\n import java.util.Iterator;\n import org.apache.bcel.classfile.SourceFile;\n import org.apache.bcel.classfile.Annotations;\n import java.util.Collection;\n import java.util.Collections;\n@@ -40,56 +39,56 @@\n     private final List<AnnotationEntryGen> annotationList;\n     private List<ClassObserver> observers;\n     \n     public static BCELComparator getComparator() {\n         return ClassGen.bcelComparator;\n     }\n     \n-    public static void setComparator(final BCELComparator comparator) {\n-        ClassGen.bcelComparator = comparator;\n+    public static void setComparator(final BCELComparator bcelComparator) {\n+        ClassGen.bcelComparator = bcelComparator;\n     }\n     \n-    public ClassGen(final JavaClass clazz) {\n-        super(clazz.getAccessFlags());\n+    public ClassGen(final JavaClass javaClass) {\n+        super(javaClass.getAccessFlags());\n         this.classNameIndex = -1;\n         this.superclassNameIndex = -1;\n         this.major = 45;\n         this.minor = 3;\n         this.fieldList = new ArrayList<Field>();\n         this.methodList = new ArrayList<Method>();\n         this.attributeList = new ArrayList<Attribute>();\n         this.interfaceList = new ArrayList<String>();\n         this.annotationList = new ArrayList<AnnotationEntryGen>();\n-        this.classNameIndex = clazz.getClassNameIndex();\n-        this.superclassNameIndex = clazz.getSuperclassNameIndex();\n-        this.className = clazz.getClassName();\n-        this.superClassName = clazz.getSuperclassName();\n-        this.fileName = clazz.getSourceFileName();\n-        this.cp = new ConstantPoolGen(clazz.getConstantPool());\n-        this.major = clazz.getMajor();\n-        this.minor = clazz.getMinor();\n-        final Attribute[] attributes = clazz.getAttributes();\n-        final AnnotationEntryGen[] annotations = this.unpackAnnotations(attributes);\n-        Collections.addAll(this.interfaceList, clazz.getInterfaceNames());\n+        this.classNameIndex = javaClass.getClassNameIndex();\n+        this.superclassNameIndex = javaClass.getSuperclassNameIndex();\n+        this.className = javaClass.getClassName();\n+        this.superClassName = javaClass.getSuperclassName();\n+        this.fileName = javaClass.getSourceFileName();\n+        this.cp = new ConstantPoolGen(javaClass.getConstantPool());\n+        this.major = javaClass.getMajor();\n+        this.minor = javaClass.getMinor();\n+        final Attribute[] attributes = javaClass.getAttributes();\n+        final AnnotationEntryGen[] unpackAnnotations = this.unpackAnnotations(attributes);\n+        Collections.addAll(this.interfaceList, javaClass.getInterfaceNames());\n         for (final Attribute attribute : attributes) {\n             if (!(attribute instanceof Annotations)) {\n                 this.addAttribute(attribute);\n             }\n         }\n-        Collections.addAll(this.annotationList, annotations);\n-        Collections.addAll(this.methodList, clazz.getMethods());\n-        Collections.addAll(this.fieldList, clazz.getFields());\n+        Collections.addAll(this.annotationList, unpackAnnotations);\n+        Collections.addAll(this.methodList, javaClass.getMethods());\n+        Collections.addAll(this.fieldList, javaClass.getFields());\n     }\n     \n-    public ClassGen(final String className, final String superClassName, final String fileName, final int accessFlags, final String[] interfaces) {\n-        this(className, superClassName, fileName, accessFlags, interfaces, new ConstantPoolGen());\n+    public ClassGen(final String s, final String s2, final String s3, final int n, final String[] array) {\n+        this(s, s2, s3, n, array, new ConstantPoolGen());\n     }\n     \n-    public ClassGen(final String className, final String superClassName, final String fileName, final int accessFlags, final String[] interfaces, final ConstantPoolGen cp) {\n-        super(accessFlags);\n+    public ClassGen(final String className, final String superClassName, final String fileName, final int n, final String[] elements, final ConstantPoolGen cp) {\n+        super(n);\n         this.classNameIndex = -1;\n         this.superclassNameIndex = -1;\n         this.major = 45;\n         this.minor = 3;\n         this.fieldList = new ArrayList<Field>();\n         this.methodList = new ArrayList<Method>();\n         this.attributeList = new ArrayList<Attribute>();\n@@ -100,89 +99,89 @@\n         this.fileName = fileName;\n         this.cp = cp;\n         if (fileName != null) {\n             this.addAttribute((Attribute)new SourceFile(cp.addUtf8(\"SourceFile\"), 2, cp.addUtf8(fileName), cp.getConstantPool()));\n         }\n         this.classNameIndex = cp.addClass(className);\n         this.superclassNameIndex = cp.addClass(superClassName);\n-        if (interfaces != null) {\n-            Collections.addAll(this.interfaceList, interfaces);\n+        if (elements != null) {\n+            Collections.addAll(this.interfaceList, elements);\n         }\n     }\n     \n-    public void addAnnotationEntry(final AnnotationEntryGen a) {\n-        this.annotationList.add(a);\n+    public void addAnnotationEntry(final AnnotationEntryGen annotationEntryGen) {\n+        this.annotationList.add(annotationEntryGen);\n     }\n     \n-    public void addAttribute(final Attribute a) {\n-        this.attributeList.add(a);\n+    public void addAttribute(final Attribute attribute) {\n+        this.attributeList.add(attribute);\n     }\n     \n-    public void addEmptyConstructor(final int accessFlags) {\n-        final InstructionList il = new InstructionList();\n-        il.append((Instruction)InstructionConst.THIS);\n-        il.append((Instruction)new INVOKESPECIAL(this.cp.addMethodref(this.superClassName, \"<init>\", \"()V\")));\n-        il.append((Instruction)InstructionConst.RETURN);\n-        final MethodGen mg = new MethodGen(accessFlags, (Type)Type.VOID, Type.NO_ARGS, (String[])null, \"<init>\", this.className, il, this.cp);\n-        mg.setMaxStack(1);\n-        this.addMethod(mg.getMethod());\n+    public void addEmptyConstructor(final int n) {\n+        final InstructionList list = new InstructionList();\n+        list.append((Instruction)InstructionConst.THIS);\n+        list.append((Instruction)new INVOKESPECIAL(this.cp.addMethodref(this.superClassName, \"<init>\", \"()V\")));\n+        list.append((Instruction)InstructionConst.RETURN);\n+        final MethodGen methodGen = new MethodGen(n, (Type)Type.VOID, Type.NO_ARGS, (String[])null, \"<init>\", this.className, list, this.cp);\n+        methodGen.setMaxStack(1);\n+        this.addMethod(methodGen.getMethod());\n     }\n     \n-    public void addField(final Field f) {\n-        this.fieldList.add(f);\n+    public void addField(final Field field) {\n+        this.fieldList.add(field);\n     }\n     \n-    public void addInterface(final String name) {\n-        this.interfaceList.add(name);\n+    public void addInterface(final String s) {\n+        this.interfaceList.add(s);\n     }\n     \n-    public void addMethod(final Method m) {\n-        this.methodList.add(m);\n+    public void addMethod(final Method method) {\n+        this.methodList.add(method);\n     }\n     \n-    public void addObserver(final ClassObserver o) {\n+    public void addObserver(final ClassObserver classObserver) {\n         if (this.observers == null) {\n             this.observers = new ArrayList<ClassObserver>();\n         }\n-        this.observers.add(o);\n+        this.observers.add(classObserver);\n     }\n     \n     public Object clone() {\n         try {\n             return super.clone();\n         }\n-        catch (final CloneNotSupportedException e) {\n+        catch (final CloneNotSupportedException ex) {\n             throw new Error(\"Clone Not Supported\");\n         }\n     }\n     \n-    public boolean containsField(final Field f) {\n-        return this.fieldList.contains(f);\n+    public boolean containsField(final Field field) {\n+        return this.fieldList.contains(field);\n     }\n     \n-    public Field containsField(final String name) {\n-        for (final Field f : this.fieldList) {\n-            if (f.getName().equals(name)) {\n-                return f;\n+    public Field containsField(final String anObject) {\n+        for (final Field field : this.fieldList) {\n+            if (field.getName().equals(anObject)) {\n+                return field;\n             }\n         }\n         return null;\n     }\n     \n-    public Method containsMethod(final String name, final String signature) {\n-        for (final Method m : this.methodList) {\n-            if (m.getName().equals(name) && m.getSignature().equals(signature)) {\n-                return m;\n+    public Method containsMethod(final String anObject, final String anObject2) {\n+        for (final Method method : this.methodList) {\n+            if (method.getName().equals(anObject) && method.getSignature().equals(anObject2)) {\n+                return method;\n             }\n         }\n         return null;\n     }\n     \n-    public boolean equals(final Object obj) {\n-        return ClassGen.bcelComparator.equals((Object)this, obj);\n+    public boolean equals(final Object o) {\n+        return ClassGen.bcelComparator.equals((Object)this, o);\n     }\n     \n     public AnnotationEntryGen[] getAnnotationEntries() {\n         return this.annotationList.toArray(AnnotationEntryGen.EMPTY_ARRAY);\n     }\n     \n     public Attribute[] getAttributes() {\n@@ -210,44 +209,42 @@\n     }\n     \n     public String[] getInterfaceNames() {\n         return this.interfaceList.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n     }\n     \n     public int[] getInterfaces() {\n-        final int size = this.interfaceList.size();\n-        final int[] interfaces = new int[size];\n-        Arrays.setAll(interfaces, i -> this.cp.addClass((String)this.interfaceList.get(i)));\n-        return interfaces;\n+        final int[] array = new int[this.interfaceList.size()];\n+        Arrays.setAll(array, n2 -> this.cp.addClass((String)this.interfaceList.get(n2)));\n+        return array;\n     }\n     \n     public JavaClass getJavaClass() {\n         final int[] interfaces = this.getInterfaces();\n         final Field[] fields = this.getFields();\n         final Method[] methods = this.getMethods();\n-        Attribute[] attributes = null;\n+        Attribute[] attributes;\n         if (this.annotationList.isEmpty()) {\n             attributes = this.getAttributes();\n         }\n         else {\n-            final Attribute[] annAttributes = AnnotationEntryGen.getAnnotationAttributes(this.cp, this.getAnnotationEntries());\n-            attributes = new Attribute[this.attributeList.size() + annAttributes.length];\n+            final Attribute[] annotationAttributes = AnnotationEntryGen.getAnnotationAttributes(this.cp, this.getAnnotationEntries());\n+            attributes = new Attribute[this.attributeList.size() + annotationAttributes.length];\n             this.attributeList.toArray(attributes);\n-            System.arraycopy(annAttributes, 0, attributes, this.attributeList.size(), annAttributes.length);\n+            System.arraycopy(annotationAttributes, 0, attributes, this.attributeList.size(), annotationAttributes.length);\n         }\n-        final ConstantPool cp = this.cp.getFinalConstantPool();\n-        return new JavaClass(this.classNameIndex, this.superclassNameIndex, this.fileName, this.major, this.minor, super.getAccessFlags(), cp, interfaces, fields, methods, attributes);\n+        return new JavaClass(this.classNameIndex, this.superclassNameIndex, this.fileName, this.major, this.minor, super.getAccessFlags(), this.cp.getFinalConstantPool(), interfaces, fields, methods, attributes);\n     }\n     \n     public int getMajor() {\n         return this.major;\n     }\n     \n-    public Method getMethodAt(final int pos) {\n-        return this.methodList.get(pos);\n+    public Method getMethodAt(final int n) {\n+        return this.methodList.get(n);\n     }\n     \n     public Method[] getMethods() {\n         return this.methodList.toArray(Method.EMPTY_ARRAY);\n     }\n     \n     public int getMinor() {\n@@ -262,122 +259,121 @@\n         return this.superclassNameIndex;\n     }\n     \n     public int hashCode() {\n         return ClassGen.bcelComparator.hashCode((Object)this);\n     }\n     \n-    public void removeAttribute(final Attribute a) {\n-        this.attributeList.remove(a);\n+    public void removeAttribute(final Attribute attribute) {\n+        this.attributeList.remove(attribute);\n     }\n     \n-    public void removeField(final Field f) {\n-        this.fieldList.remove(f);\n+    public void removeField(final Field field) {\n+        this.fieldList.remove(field);\n     }\n     \n-    public void removeInterface(final String name) {\n-        this.interfaceList.remove(name);\n+    public void removeInterface(final String s) {\n+        this.interfaceList.remove(s);\n     }\n     \n-    public void removeMethod(final Method m) {\n-        this.methodList.remove(m);\n+    public void removeMethod(final Method method) {\n+        this.methodList.remove(method);\n     }\n     \n-    public void removeObserver(final ClassObserver o) {\n+    public void removeObserver(final ClassObserver classObserver) {\n         if (this.observers != null) {\n-            this.observers.remove(o);\n+            this.observers.remove(classObserver);\n         }\n     }\n     \n-    public void replaceField(final Field old, final Field newField) {\n-        if (newField == null) {\n+    public void replaceField(final Field field, final Field field2) {\n+        if (field2 == null) {\n             throw new ClassGenException(\"Replacement method must not be null\");\n         }\n-        final int i = this.fieldList.indexOf(old);\n-        if (i < 0) {\n-            this.fieldList.add(newField);\n+        final int index = this.fieldList.indexOf(field);\n+        if (index < 0) {\n+            this.fieldList.add(field2);\n         }\n         else {\n-            this.fieldList.set(i, newField);\n+            this.fieldList.set(index, field2);\n         }\n     }\n     \n-    public void replaceMethod(final Method old, final Method newMethod) {\n-        if (newMethod == null) {\n+    public void replaceMethod(final Method method, final Method method2) {\n+        if (method2 == null) {\n             throw new ClassGenException(\"Replacement method must not be null\");\n         }\n-        final int i = this.methodList.indexOf(old);\n-        if (i < 0) {\n-            this.methodList.add(newMethod);\n+        final int index = this.methodList.indexOf(method);\n+        if (index < 0) {\n+            this.methodList.add(method2);\n         }\n         else {\n-            this.methodList.set(i, newMethod);\n+            this.methodList.set(index, method2);\n         }\n     }\n     \n-    public void setClassName(final String name) {\n-        this.className = Utility.pathToPackage(name);\n-        this.classNameIndex = this.cp.addClass(name);\n+    public void setClassName(final String s) {\n+        this.className = Utility.pathToPackage(s);\n+        this.classNameIndex = this.cp.addClass(s);\n     }\n     \n     public void setClassNameIndex(final int classNameIndex) {\n         this.classNameIndex = classNameIndex;\n         this.className = Utility.pathToPackage(this.cp.getConstantPool().getConstantString(classNameIndex, (byte)7));\n     }\n     \n-    public void setConstantPool(final ConstantPoolGen constantPool) {\n-        this.cp = constantPool;\n+    public void setConstantPool(final ConstantPoolGen cp) {\n+        this.cp = cp;\n     }\n     \n     public void setMajor(final int major) {\n         this.major = major;\n     }\n     \n-    public void setMethodAt(final Method method, final int pos) {\n-        this.methodList.set(pos, method);\n+    public void setMethodAt(final Method method, final int n) {\n+        this.methodList.set(n, method);\n     }\n     \n-    public void setMethods(final Method[] methods) {\n+    public void setMethods(final Method[] elements) {\n         this.methodList.clear();\n-        Collections.addAll(this.methodList, methods);\n+        Collections.addAll(this.methodList, elements);\n     }\n     \n     public void setMinor(final int minor) {\n         this.minor = minor;\n     }\n     \n-    public void setSuperclassName(final String name) {\n-        this.superClassName = Utility.pathToPackage(name);\n-        this.superclassNameIndex = this.cp.addClass(name);\n+    public void setSuperclassName(final String s) {\n+        this.superClassName = Utility.pathToPackage(s);\n+        this.superclassNameIndex = this.cp.addClass(s);\n     }\n     \n     public void setSuperclassNameIndex(final int superclassNameIndex) {\n         this.superclassNameIndex = superclassNameIndex;\n         this.superClassName = Utility.pathToPackage(this.cp.getConstantPool().getConstantString(superclassNameIndex, (byte)7));\n     }\n     \n-    private AnnotationEntryGen[] unpackAnnotations(final Attribute[] attrs) {\n-        final List<AnnotationEntryGen> annotationGenObjs = new ArrayList<AnnotationEntryGen>();\n-        for (final Attribute attr : attrs) {\n-            if (attr instanceof RuntimeVisibleAnnotations) {\n-                final RuntimeVisibleAnnotations rva = (RuntimeVisibleAnnotations)attr;\n-                rva.forEach(a -> annotationGenObjs.add(new AnnotationEntryGen(a, this.getConstantPool(), false)));\n+    private AnnotationEntryGen[] unpackAnnotations(final Attribute[] array) {\n+        final ArrayList list = new ArrayList();\n+        for (final Attribute attribute : array) {\n+            if (attribute instanceof RuntimeVisibleAnnotations) {\n+                ((RuntimeVisibleAnnotations)attribute).forEach(annotationEntry -> list2.add(new AnnotationEntryGen(annotationEntry, this.getConstantPool(), (boolean)(0 != 0))));\n             }\n-            else if (attr instanceof RuntimeInvisibleAnnotations) {\n-                final RuntimeInvisibleAnnotations ria = (RuntimeInvisibleAnnotations)attr;\n-                ria.forEach(a -> annotationGenObjs.add(new AnnotationEntryGen(a, this.getConstantPool(), false)));\n+            else if (attribute instanceof RuntimeInvisibleAnnotations) {\n+                ((RuntimeInvisibleAnnotations)attribute).forEach(annotationEntry2 -> list3.add(new AnnotationEntryGen(annotationEntry2, this.getConstantPool(), (boolean)(0 != 0))));\n             }\n         }\n-        return annotationGenObjs.toArray(AnnotationEntryGen.EMPTY_ARRAY);\n+        return (AnnotationEntryGen[])list.toArray(AnnotationEntryGen.EMPTY_ARRAY);\n     }\n     \n     public void update() {\n         if (this.observers != null) {\n-            for (final ClassObserver observer : this.observers) {\n-                observer.notify(this);\n+            final Iterator<ClassObserver> iterator = this.observers.iterator();\n+            while (iterator.hasNext()) {\n+                ((ClassObserver)iterator.next()).notify(this);\n             }\n         }\n     }\n     \n     static {\n         ClassGen.bcelComparator = (BCELComparator)new ClassGen.ClassGen$1();\n     }\n"}]}
