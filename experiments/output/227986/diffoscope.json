{"diffoscope-json-version": 1, "source1": "first/AbstractElementNode.class", "source2": "second/AbstractElementNode.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -36,157 +36,154 @@\n         this.root = root;\n         this.depth = depth;\n         this.indexAmongSiblings = indexAmongSiblings;\n     }\n     \n     protected abstract AttributeNode createAttributeNode();\n     \n-    public int compareOrder(final NodeInfo other) {\n-        int result = 0;\n-        if (other instanceof AbstractNode) {\n-            result = Integer.compare(this.depth, ((AbstractNode)other).getDepth());\n-            if (result == 0) {\n-                result = compareCommonAncestorChildrenOrder((NodeInfo)this, other);\n-            }\n-        }\n-        return result;\n-    }\n-    \n-    private static int compareCommonAncestorChildrenOrder(final NodeInfo first, final NodeInfo second) {\n-        NodeInfo child1;\n-        NodeInfo child2;\n-        for (child1 = first, child2 = second; !child1.getParent().equals((Object)child2.getParent()); child1 = child1.getParent(), child2 = child2.getParent()) {}\n-        final int index1 = ((AbstractElementNode)child1).indexAmongSiblings;\n-        final int index2 = ((AbstractElementNode)child2).indexAmongSiblings;\n-        return Integer.compare(index1, index2);\n+    public int compareOrder(final NodeInfo nodeInfo) {\n+        int n = 0;\n+        if (nodeInfo instanceof AbstractNode) {\n+            n = Integer.compare(this.depth, ((AbstractNode)nodeInfo).getDepth());\n+            if (n == 0) {\n+                n = compareCommonAncestorChildrenOrder((NodeInfo)this, nodeInfo);\n+            }\n+        }\n+        return n;\n+    }\n+    \n+    private static int compareCommonAncestorChildrenOrder(final NodeInfo nodeInfo, final NodeInfo nodeInfo2) {\n+        NodeInfo parent;\n+        NodeInfo parent2;\n+        for (parent = nodeInfo, parent2 = nodeInfo2; !parent.getParent().equals((Object)parent2.getParent()); parent = parent.getParent(), parent2 = parent2.getParent()) {}\n+        return Integer.compare(((AbstractElementNode)parent).indexAmongSiblings, ((AbstractElementNode)parent2).indexAmongSiblings);\n     }\n     \n     public int getDepth() {\n         return this.depth;\n     }\n     \n-    public String getAttributeValue(final NamespaceUri namespace, final String localPart) {\n-        String result;\n-        if (\"text\".equals(localPart)) {\n-            result = Optional.ofNullable(this.getAttributeNode()).map((Function<? super AttributeNode, ? extends String>)AttributeNode::getStringValue).orElse(null);\n+    public String getAttributeValue(final NamespaceUri namespaceUri, final String anObject) {\n+        String s;\n+        if (\"text\".equals(anObject)) {\n+            s = Optional.ofNullable(this.getAttributeNode()).map((Function<? super AttributeNode, ? extends String>)AttributeNode::getStringValue).orElse(null);\n         }\n         else {\n-            result = null;\n+            s = null;\n         }\n-        return result;\n+        return s;\n     }\n     \n     public int getNodeKind() {\n         return 1;\n     }\n     \n     public NodeInfo getParent() {\n         return (NodeInfo)this.parent;\n     }\n     \n     public AbstractNode getRoot() {\n         return this.root;\n     }\n     \n-    public AxisIterator iterateAxis(final int axisNumber) {\n-        AxisIterator result = null;\n-        switch (axisNumber) {\n+    public AxisIterator iterateAxis(final int n) {\n+        Object o = null;\n+        switch (n) {\n             case 0: {\n-                result = (AxisIterator)new Navigator.AncestorEnumeration((NodeInfo)this, false);\n+                o = new Navigator.AncestorEnumeration((NodeInfo)this, false);\n                 break;\n             }\n             case 1: {\n-                result = (AxisIterator)new Navigator.AncestorEnumeration((NodeInfo)this, true);\n+                o = new Navigator.AncestorEnumeration((NodeInfo)this, true);\n                 break;\n             }\n             case 2: {\n-                result = SingleNodeIterator.makeIterator((NodeInfo)this.getAttributeNode());\n+                o = SingleNodeIterator.makeIterator((NodeInfo)this.getAttributeNode());\n                 break;\n             }\n             case 3: {\n                 if (this.hasChildNodes()) {\n-                    result = (AxisIterator)new ArrayIterator.OfNodes((NodeInfo[])this.getChildren().toArray(AbstractElementNode.EMPTY_ABSTRACT_NODE_ARRAY));\n+                    o = new ArrayIterator.OfNodes((NodeInfo[])this.getChildren().toArray(AbstractElementNode.EMPTY_ABSTRACT_NODE_ARRAY));\n                     break;\n                 }\n-                result = EmptyIterator.ofNodes();\n+                o = EmptyIterator.ofNodes();\n                 break;\n             }\n             case 4: {\n                 if (this.hasChildNodes()) {\n-                    result = (AxisIterator)new DescendantIterator((NodeInfo)this, DescendantIterator.StartWith.CHILDREN);\n+                    o = new DescendantIterator((NodeInfo)this, DescendantIterator.StartWith.CHILDREN);\n                     break;\n                 }\n-                result = EmptyIterator.ofNodes();\n+                o = EmptyIterator.ofNodes();\n                 break;\n             }\n             case 5: {\n-                result = (AxisIterator)new DescendantIterator((NodeInfo)this, DescendantIterator.StartWith.CURRENT_NODE);\n+                o = new DescendantIterator((NodeInfo)this, DescendantIterator.StartWith.CURRENT_NODE);\n                 break;\n             }\n             case 9: {\n-                result = SingleNodeIterator.makeIterator((NodeInfo)this.parent);\n+                o = SingleNodeIterator.makeIterator((NodeInfo)this.parent);\n                 break;\n             }\n             case 12: {\n-                result = SingleNodeIterator.makeIterator((NodeInfo)this);\n+                o = SingleNodeIterator.makeIterator((NodeInfo)this);\n                 break;\n             }\n             case 7: {\n-                result = this.getFollowingSiblingsIterator();\n+                o = this.getFollowingSiblingsIterator();\n                 break;\n             }\n             case 11: {\n-                result = this.getPrecedingSiblingsIterator();\n+                o = this.getPrecedingSiblingsIterator();\n                 break;\n             }\n             case 6: {\n-                result = (AxisIterator)new FollowingIterator((NodeInfo)this);\n+                o = new FollowingIterator((NodeInfo)this);\n                 break;\n             }\n             case 10: {\n-                result = (AxisIterator)new PrecedingIterator((NodeInfo)this);\n+                o = new PrecedingIterator((NodeInfo)this);\n                 break;\n             }\n             default: {\n                 throw throwUnsupportedOperationException();\n             }\n         }\n-        return result;\n+        return (AxisIterator)o;\n     }\n     \n     private AxisIterator getPrecedingSiblingsIterator() {\n-        AxisIterator result;\n+        Object ofNodes;\n         if (this.indexAmongSiblings == 0) {\n-            result = EmptyIterator.ofNodes();\n+            ofNodes = EmptyIterator.ofNodes();\n         }\n         else {\n-            result = (AxisIterator)new ReverseListIterator((Collection)this.getPrecedingSiblings());\n+            ofNodes = new ReverseListIterator((Collection)this.getPrecedingSiblings());\n         }\n-        return result;\n+        return (AxisIterator)ofNodes;\n     }\n     \n     private AxisIterator getFollowingSiblingsIterator() {\n-        AxisIterator result;\n+        Object ofNodes;\n         if (this.indexAmongSiblings == this.parent.getChildren().size() - 1) {\n-            result = EmptyIterator.ofNodes();\n+            ofNodes = EmptyIterator.ofNodes();\n         }\n         else {\n-            result = (AxisIterator)new ArrayIterator.OfNodes((NodeInfo[])this.getFollowingSiblings().toArray((NodeInfo[])AbstractElementNode.EMPTY_ABSTRACT_NODE_ARRAY));\n+            ofNodes = new ArrayIterator.OfNodes((NodeInfo[])this.getFollowingSiblings().toArray((NodeInfo[])AbstractElementNode.EMPTY_ABSTRACT_NODE_ARRAY));\n         }\n-        return result;\n+        return (AxisIterator)ofNodes;\n     }\n     \n     private List<AbstractNode> getFollowingSiblings() {\n-        final List<AbstractNode> siblings = this.parent.getChildren();\n-        return siblings.subList(this.indexAmongSiblings + 1, siblings.size());\n+        final List children = this.parent.getChildren();\n+        return children.subList(this.indexAmongSiblings + 1, children.size());\n     }\n     \n     private List<AbstractNode> getPrecedingSiblings() {\n-        final List<AbstractNode> siblings = this.parent.getChildren();\n-        return UnmodifiableCollectionUtil.unmodifiableList((List)siblings.subList(0, this.indexAmongSiblings));\n+        return UnmodifiableCollectionUtil.unmodifiableList((List)this.parent.getChildren().subList(0, this.indexAmongSiblings));\n     }\n     \n     private AttributeNode getAttributeNode() {\n         if (this.attributeNode == AbstractElementNode.ATTRIBUTE_NODE_UNINITIALIZED) {\n             this.attributeNode = this.createAttributeNode();\n         }\n         return this.attributeNode;\n"}]}
