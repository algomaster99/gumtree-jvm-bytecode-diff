{"diffoscope-json-version": 1, "source1": "first/ZipSplitReadOnlySeekableByteChannel.class", "source2": "second/ZipSplitReadOnlySeekableByteChannel.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -25,85 +25,110 @@\n \n public class ZipSplitReadOnlySeekableByteChannel extends MultiReadOnlySeekableByteChannel\n {\n     private static final Path[] EMPTY_PATH_ARRAY;\n     private static final int ZIP_SPLIT_SIGNATURE_LENGTH = 4;\n     private final ByteBuffer zipSplitSignatureByteBuffer;\n     \n+    static {\n+        EMPTY_PATH_ARRAY = new Path[0];\n+    }\n+    \n     public static SeekableByteChannel buildFromLastSplitSegment(final File lastSegmentFile) throws IOException {\n         return buildFromLastSplitSegment(lastSegmentFile.toPath());\n     }\n     \n     public static SeekableByteChannel buildFromLastSplitSegment(final Path lastSegmentPath) throws IOException {\n         final String extension = FileNameUtils.getExtension(lastSegmentPath);\n         if (!extension.equalsIgnoreCase(\"zip\")) {\n             throw new IllegalArgumentException(\"The extension of last ZIP split segment should be .zip\");\n         }\n         final Path parent = Objects.nonNull(lastSegmentPath.getParent()) ? lastSegmentPath.getParent() : lastSegmentPath.getFileSystem().getPath(\".\", new String[0]);\n         final String fileBaseName = FileNameUtils.getBaseName(lastSegmentPath);\n-        final Pattern pattern = Pattern.compile(Pattern.quote(fileBaseName) + \".[zZ][0-9]+\");\n+        final Pattern pattern = Pattern.compile(String.valueOf(Pattern.quote(fileBaseName)) + \".[zZ][0-9]+\");\n+        Throwable t = null;\n         ArrayList<Path> splitZipSegments;\n-        try (final Stream<Path> walk = Files.walk(parent, 1, new FileVisitOption[0])) {\n-            splitZipSegments = walk.filter(x$0 -> Files.isRegularFile(x$0, new LinkOption[0])).filter(path -> pattern.matcher(path.getFileName().toString()).matches()).sorted((Comparator<? super Path>)new ZipSplitReadOnlySeekableByteChannel.ZipSplitSegmentComparator((ZipSplitReadOnlySeekableByteChannel.ZipSplitReadOnlySeekableByteChannel$1)null)).collect(Collectors.toCollection(ArrayList::new));\n+        try {\n+            final Stream<Path> walk = Files.walk(parent, 1, new FileVisitOption[0]);\n+            try {\n+                splitZipSegments = walk.filter( arg0 -> Files.isRegularFile( arg0, new LinkOption[0])).filter(path -> pattern2.matcher(path.getFileName().toString()).matches()).sorted((Comparator<? super Path>)new ZipSplitReadOnlySeekableByteChannel.ZipSplitSegmentComparator((ZipSplitReadOnlySeekableByteChannel.ZipSplitSegmentComparator)null)).collect(Collectors.toCollection(ArrayList::new));\n+            }\n+            finally {\n+                if (walk != null) {\n+                    walk.close();\n+                }\n+            }\n+        }\n+        finally {\n+            if (t == null) {\n+                final Throwable exception;\n+                t = exception;\n+            }\n+            else {\n+                final Throwable exception;\n+                if (t != exception) {\n+                    t.addSuppressed(exception);\n+                }\n+            }\n         }\n         return forPaths(lastSegmentPath, splitZipSegments);\n     }\n     \n     public static SeekableByteChannel forFiles(final File... files) throws IOException {\n         final List<Path> paths = new ArrayList<Path>();\n-        for (final File f : (File[])Objects.requireNonNull(files, \"files must not be null\")) {\n+        File[] array;\n+        for (int length = (array = Objects.requireNonNull(files, \"files must not be null\")).length, i = 0; i < length; ++i) {\n+            final File f = array[i];\n             paths.add(f.toPath());\n         }\n         return forPaths((Path[])paths.toArray(ZipSplitReadOnlySeekableByteChannel.EMPTY_PATH_ARRAY));\n     }\n     \n     public static SeekableByteChannel forFiles(final File lastSegmentFile, final Iterable<File> files) throws IOException {\n         Objects.requireNonNull(files, \"files\");\n         Objects.requireNonNull(lastSegmentFile, \"lastSegmentFile\");\n         final List<Path> filesList = new ArrayList<Path>();\n-        files.forEach(f -> filesList.add(f.toPath()));\n+        files.forEach(f -> list.add(f.toPath()));\n         return forPaths(lastSegmentFile.toPath(), filesList);\n     }\n     \n     public static SeekableByteChannel forOrderedSeekableByteChannels(final SeekableByteChannel... channels) throws IOException {\n         if (((SeekableByteChannel[])Objects.requireNonNull(channels, \"channels must not be null\")).length == 1) {\n             return channels[0];\n         }\n         return (SeekableByteChannel)new ZipSplitReadOnlySeekableByteChannel(Arrays.asList(channels));\n     }\n     \n     public static SeekableByteChannel forOrderedSeekableByteChannels(final SeekableByteChannel lastSegmentChannel, final Iterable<SeekableByteChannel> channels) throws IOException {\n         Objects.requireNonNull(channels, \"channels\");\n         Objects.requireNonNull(lastSegmentChannel, \"lastSegmentChannel\");\n-        final ArrayList obj;\n-        final List<SeekableByteChannel> channelsList = obj = new ArrayList();\n-        Objects.requireNonNull(obj);\n-        channels.forEach(obj::add);\n+        final List<SeekableByteChannel> channelsList = new ArrayList<SeekableByteChannel>();\n+        channels.forEach(channelsList::add);\n         channelsList.add(lastSegmentChannel);\n         return forOrderedSeekableByteChannels((SeekableByteChannel[])channelsList.toArray(new SeekableByteChannel[0]));\n     }\n     \n     public static SeekableByteChannel forPaths(final Path... paths) throws IOException {\n         final List<SeekableByteChannel> channels = new ArrayList<SeekableByteChannel>();\n-        for (final Path path : (Path[])Objects.requireNonNull(paths, \"paths must not be null\")) {\n+        Path[] array;\n+        for (int length = (array = Objects.requireNonNull(paths, \"paths must not be null\")).length, i = 0; i < length; ++i) {\n+            final Path path = array[i];\n             channels.add(Files.newByteChannel(path, StandardOpenOption.READ));\n         }\n         if (channels.size() == 1) {\n             return channels.get(0);\n         }\n         return (SeekableByteChannel)new ZipSplitReadOnlySeekableByteChannel(channels);\n     }\n     \n     public static SeekableByteChannel forPaths(final Path lastSegmentPath, final Iterable<Path> paths) throws IOException {\n         Objects.requireNonNull(paths, \"paths\");\n         Objects.requireNonNull(lastSegmentPath, \"lastSegmentPath\");\n-        final ArrayList obj;\n-        final List<Path> filesList = obj = new ArrayList();\n-        Objects.requireNonNull(obj);\n-        paths.forEach(obj::add);\n+        final List<Path> filesList = new ArrayList<Path>();\n+        paths.forEach(filesList::add);\n         filesList.add(lastSegmentPath);\n         return forPaths((Path[])filesList.toArray(ZipSplitReadOnlySeekableByteChannel.EMPTY_PATH_ARRAY));\n     }\n     \n     public ZipSplitReadOnlySeekableByteChannel(final List<SeekableByteChannel> channels) throws IOException {\n         super((List)channels);\n         this.zipSplitSignatureByteBuffer = ByteBuffer.allocate(4);\n@@ -118,12 +143,8 @@\n         final ZipLong signature = new ZipLong(this.zipSplitSignatureByteBuffer.array());\n         if (!signature.equals((Object)ZipLong.DD_SIG)) {\n             channel.position(0L);\n             throw new IOException(\"The first ZIP split segment does not begin with split ZIP file signature\");\n         }\n         channel.position(0L);\n     }\n-    \n-    static {\n-        EMPTY_PATH_ARRAY = new Path[0];\n-    }\n }\n"}]}
