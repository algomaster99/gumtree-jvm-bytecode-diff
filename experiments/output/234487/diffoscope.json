{"diffoscope-json-version": 1, "source1": "first/ReadAheadInputStream.class", "source2": "second/ReadAheadInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -33,40 +33,40 @@\n     private final boolean shutdownExecutorService;\n     private final Condition asyncReadComplete;\n     \n     private static ExecutorService newExecutorService() {\n         return Executors.newSingleThreadExecutor(ReadAheadInputStream::newThread);\n     }\n     \n-    private static Thread newThread(final Runnable r) {\n-        final Thread thread = new Thread(r, \"commons-io-read-ahead\");\n+    private static Thread newThread(final Runnable task) {\n+        final Thread thread = new Thread(task, \"commons-io-read-ahead\");\n         thread.setDaemon(true);\n         return thread;\n     }\n     \n-    public ReadAheadInputStream(final InputStream inputStream, final int bufferSizeInBytes) {\n-        this(inputStream, bufferSizeInBytes, newExecutorService(), true);\n+    public ReadAheadInputStream(final InputStream inputStream, final int n) {\n+        this(inputStream, n, newExecutorService(), true);\n     }\n     \n-    public ReadAheadInputStream(final InputStream inputStream, final int bufferSizeInBytes, final ExecutorService executorService) {\n-        this(inputStream, bufferSizeInBytes, executorService, false);\n+    public ReadAheadInputStream(final InputStream inputStream, final int n, final ExecutorService executorService) {\n+        this(inputStream, n, executorService, false);\n     }\n     \n-    private ReadAheadInputStream(final InputStream inputStream, final int bufferSizeInBytes, final ExecutorService executorService, final boolean shutdownExecutorService) {\n+    private ReadAheadInputStream(final InputStream obj, final int capacity, final ExecutorService obj2, final boolean shutdownExecutorService) {\n         this.stateChangeLock = new ReentrantLock();\n         this.isWaiting = new AtomicBoolean(false);\n         this.asyncReadComplete = this.stateChangeLock.newCondition();\n-        if (bufferSizeInBytes <= 0) {\n-            throw new IllegalArgumentException(\"bufferSizeInBytes should be greater than 0, but the value is \" + bufferSizeInBytes);\n+        if (capacity <= 0) {\n+            throw new IllegalArgumentException(\"bufferSizeInBytes should be greater than 0, but the value is \" + capacity);\n         }\n-        this.executorService = Objects.requireNonNull(executorService, \"executorService\");\n-        this.underlyingInputStream = Objects.requireNonNull(inputStream, \"inputStream\");\n+        this.executorService = Objects.requireNonNull(obj2, \"executorService\");\n+        this.underlyingInputStream = Objects.requireNonNull(obj, \"inputStream\");\n         this.shutdownExecutorService = shutdownExecutorService;\n-        this.activeBuffer = ByteBuffer.allocate(bufferSizeInBytes);\n-        this.readAheadBuffer = ByteBuffer.allocate(bufferSizeInBytes);\n+        this.activeBuffer = ByteBuffer.allocate(capacity);\n+        this.readAheadBuffer = ByteBuffer.allocate(capacity);\n         this.activeBuffer.flip();\n         this.readAheadBuffer.flip();\n     }\n     \n     @Override\n     public int available() throws IOException {\n         this.stateChangeLock.lock();\n@@ -86,60 +86,60 @@\n             throw (IOException)this.readException;\n         }\n         throw new IOException(this.readException);\n     }\n     \n     @Override\n     public void close() throws IOException {\n-        boolean isSafeToCloseUnderlyingInputStream = false;\n+        boolean b = false;\n         this.stateChangeLock.lock();\n         try {\n             if (this.isClosed) {\n                 return;\n             }\n             this.isClosed = true;\n             if (!this.isReading) {\n-                isSafeToCloseUnderlyingInputStream = true;\n+                b = true;\n                 this.isUnderlyingInputStreamBeingClosed = true;\n             }\n         }\n         finally {\n             this.stateChangeLock.unlock();\n         }\n         if (this.shutdownExecutorService) {\n             try {\n                 this.executorService.shutdownNow();\n                 this.executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);\n             }\n-            catch (final InterruptedException e) {\n-                final InterruptedIOException iio = new InterruptedIOException(e.getMessage());\n-                iio.initCause(e);\n-                throw iio;\n+            catch (final InterruptedException cause) {\n+                final InterruptedIOException ex = new InterruptedIOException(cause.getMessage());\n+                ex.initCause(cause);\n+                throw ex;\n             }\n             finally {\n-                if (isSafeToCloseUnderlyingInputStream) {\n+                if (b) {\n                     this.underlyingInputStream.close();\n                 }\n             }\n         }\n     }\n     \n     private void closeUnderlyingInputStreamIfNecessary() {\n-        boolean needToCloseUnderlyingInputStream = false;\n+        boolean b = false;\n         this.stateChangeLock.lock();\n         try {\n             this.isReading = false;\n             if (this.isClosed && !this.isUnderlyingInputStreamBeingClosed) {\n-                needToCloseUnderlyingInputStream = true;\n+                b = true;\n             }\n         }\n         finally {\n             this.stateChangeLock.unlock();\n         }\n-        if (needToCloseUnderlyingInputStream) {\n+        if (b) {\n             try {\n                 this.underlyingInputStream.close();\n             }\n             catch (final IOException ex) {}\n         }\n     }\n     \n@@ -148,24 +148,24 @@\n     }\n     \n     @Override\n     public int read() throws IOException {\n         if (this.activeBuffer.hasRemaining()) {\n             return this.activeBuffer.get() & 0xFF;\n         }\n-        final byte[] oneByteArray = (byte[])ReadAheadInputStream.oneByte.get();\n-        return (this.read(oneByteArray, 0, 1) == -1) ? -1 : (oneByteArray[0] & 0xFF);\n+        final byte[] array = (byte[])ReadAheadInputStream.oneByte.get();\n+        return (this.read(array, 0, 1) == -1) ? -1 : (array[0] & 0xFF);\n     }\n     \n     @Override\n-    public int read(final byte[] b, final int offset, int len) throws IOException {\n-        if (offset < 0 || len < 0 || len > b.length - offset) {\n+    public int read(final byte[] dst, final int offset, int min) throws IOException {\n+        if (offset < 0 || min < 0 || min > dst.length - offset) {\n             throw new IndexOutOfBoundsException();\n         }\n-        if (len == 0) {\n+        if (min == 0) {\n             return 0;\n         }\n         if (!this.activeBuffer.hasRemaining()) {\n             this.stateChangeLock.lock();\n             try {\n                 this.waitForAsyncReadComplete();\n                 if (!this.readAheadBuffer.hasRemaining()) {\n@@ -178,24 +178,23 @@\n                 this.swapBuffers();\n                 this.readAsync();\n             }\n             finally {\n                 this.stateChangeLock.unlock();\n             }\n         }\n-        len = Math.min(len, this.activeBuffer.remaining());\n-        this.activeBuffer.get(b, offset, len);\n-        return len;\n+        min = Math.min(min, this.activeBuffer.remaining());\n+        this.activeBuffer.get(dst, offset, min);\n+        return min;\n     }\n     \n     private void readAsync() throws IOException {\n         this.stateChangeLock.lock();\n-        byte[] arr;\n         try {\n-            arr = this.readAheadBuffer.array();\n+            this.readAheadBuffer.array();\n             if (this.endOfStream || this.readInProgress) {\n                 return;\n             }\n             this.checkReadException();\n             this.readAheadBuffer.position(0);\n             this.readAheadBuffer.flip();\n             this.readInProgress = true;\n@@ -213,46 +212,46 @@\n                 else {\n                     this.isReading = true;\n                 }\n             }\n             finally {\n                 this.stateChangeLock.unlock();\n             }\n-            int read = 0;\n-            int off = 0;\n-            int len = arr.length;\n-            Throwable exception = null;\n+            int length = b.length;\n             try {\n                 do {\n-                    read = this.underlyingInputStream.read(arr, off, len);\n-                    if (read <= 0) {\n+                    final int n;\n+                    this.underlyingInputStream.read(b, n, length);\n+                    final int n2;\n+                    if (n2 <= 0) {\n                         break;\n                     }\n                     else {\n-                        off += read;\n-                        len -= read;\n+                        length -= n2;\n                     }\n-                } while (len > 0 && !this.isWaiting.get());\n+                } while (length > 0 && !this.isWaiting.get());\n             }\n-            catch (final Throwable ex) {\n-                exception = ex;\n-                if (ex instanceof Error) {\n-                    throw (Error)ex;\n+            catch (final Throwable t) {\n+                if (t instanceof Error) {\n+                    throw (Error)t;\n                 }\n             }\n             finally {\n                 this.stateChangeLock.lock();\n                 try {\n-                    this.readAheadBuffer.limit(off);\n-                    if (read < 0 || exception instanceof EOFException) {\n+                    final int n;\n+                    this.readAheadBuffer.limit(n);\n+                    final int n2;\n+                    final Throwable readException;\n+                    if (n2 < 0 || readException instanceof EOFException) {\n                         this.endOfStream = true;\n                     }\n-                    else if (exception != null) {\n+                    else if (readException != null) {\n                         this.readAborted = true;\n-                        this.readException = exception;\n+                        this.readException = readException;\n                     }\n                     this.readInProgress = false;\n                     this.signalAsyncReadComplete();\n                 }\n                 finally {\n                     this.stateChangeLock.unlock();\n                 }\n@@ -277,70 +276,69 @@\n             return 0L;\n         }\n         if (n <= this.activeBuffer.remaining()) {\n             this.activeBuffer.position((int)n + this.activeBuffer.position());\n             return n;\n         }\n         this.stateChangeLock.lock();\n-        long skipped;\n+        long skipInternal;\n         try {\n-            skipped = this.skipInternal(n);\n+            skipInternal = this.skipInternal(n);\n         }\n         finally {\n             this.stateChangeLock.unlock();\n         }\n-        return skipped;\n+        return skipInternal;\n     }\n     \n     private long skipInternal(final long n) throws IOException {\n         assert this.stateChangeLock.isLocked();\n         this.waitForAsyncReadComplete();\n         if (this.isEndOfStream()) {\n             return 0L;\n         }\n         if (this.available() < n) {\n-            final int skippedBytes = this.available();\n-            final long toSkip = n - skippedBytes;\n+            final int available = this.available();\n+            final long n2 = n - available;\n             this.activeBuffer.position(0);\n             this.activeBuffer.flip();\n             this.readAheadBuffer.position(0);\n             this.readAheadBuffer.flip();\n-            final long skippedFromInputStream = this.underlyingInputStream.skip(toSkip);\n+            final long skip = this.underlyingInputStream.skip(n2);\n             this.readAsync();\n-            return skippedBytes + skippedFromInputStream;\n+            return available + skip;\n         }\n-        int toSkip2 = (int)n;\n-        toSkip2 -= this.activeBuffer.remaining();\n-        assert toSkip2 > 0;\n+        final int n3 = (int)n - this.activeBuffer.remaining();\n+        assert n3 > 0;\n         this.activeBuffer.position(0);\n         this.activeBuffer.flip();\n-        this.readAheadBuffer.position(toSkip2 + this.readAheadBuffer.position());\n+        this.readAheadBuffer.position(n3 + this.readAheadBuffer.position());\n         this.swapBuffers();\n         this.readAsync();\n         return n;\n     }\n     \n     private void swapBuffers() {\n-        final ByteBuffer temp = this.activeBuffer;\n+        final ByteBuffer activeBuffer = this.activeBuffer;\n         this.activeBuffer = this.readAheadBuffer;\n-        this.readAheadBuffer = temp;\n+        this.readAheadBuffer = activeBuffer;\n     }\n     \n     private void waitForAsyncReadComplete() throws IOException {\n         this.stateChangeLock.lock();\n         try {\n             this.isWaiting.set(true);\n             while (this.readInProgress) {\n                 this.asyncReadComplete.await();\n             }\n         }\n-        catch (final InterruptedException e) {\n-            final InterruptedIOException iio = new InterruptedIOException(e.getMessage());\n-            iio.initCause(e);\n-            throw iio;\n+        catch (final InterruptedException cause) {\n+            final InterruptedIOException ex = new InterruptedIOException(cause.getMessage());\n+            ex.initCause(cause);\n+            throw ex;\n         }\n         finally {\n             this.isWaiting.set(false);\n             this.stateChangeLock.unlock();\n         }\n         this.checkReadException();\n     }\n"}]}
