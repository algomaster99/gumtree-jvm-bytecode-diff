{"diffoscope-json-version": 1, "source1": "first/UnusedLocalVariableCheck.class", "source2": "second/UnusedLocalVariableCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -3,15 +3,14 @@\n \n import java.util.Iterator;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.stream.Collector;\n import java.util.stream.Collectors;\n import java.util.function.Consumer;\n-import java.util.Objects;\n import java.util.List;\n import java.util.Optional;\n import com.puppycrawl.tools.checkstyle.checks.naming.AccessModifierOption;\n import com.puppycrawl.tools.checkstyle.utils.CheckUtil;\n import com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n import java.util.HashSet;\n import java.util.HashMap;\n@@ -38,14 +37,22 @@\n     private final Deque<UnusedLocalVariableCheck.TypeDeclDesc> typeDeclarations;\n     private final Map<DetailAST, UnusedLocalVariableCheck.TypeDeclDesc> typeDeclAstToTypeDeclDesc;\n     private final Map<DetailAST, UnusedLocalVariableCheck.TypeDeclDesc> anonInnerAstToTypeDeclDesc;\n     private final Set<DetailAST> anonInnerClassHolders;\n     private String packageName;\n     private int depth;\n     \n+    static {\n+        INCREMENT_AND_DECREMENT_TOKENS = new int[] { 25, 26, 129, 130 };\n+        SCOPES = new int[] { 7, 91, 6 };\n+        UNACCEPTABLE_CHILD_OF_DOT = new int[] { 59, 27, 136, 79, 69, 78 };\n+        UNACCEPTABLE_PARENT_OF_IDENT = new int[] { 10, 59, 136, 198, 27, 13 };\n+        CONTAINERS_FOR_ANON_INNERS = new int[] { 9, 8, 12, 11, 203 };\n+    }\n+    \n     public UnusedLocalVariableCheck() {\n         this.variables = new ArrayDeque<UnusedLocalVariableCheck.VariableDesc>();\n         this.typeDeclarations = new ArrayDeque<UnusedLocalVariableCheck.TypeDeclDesc>();\n         this.typeDeclAstToTypeDeclDesc = new LinkedHashMap<DetailAST, UnusedLocalVariableCheck.TypeDeclDesc>();\n         this.anonInnerAstToTypeDeclDesc = new HashMap<DetailAST, UnusedLocalVariableCheck.TypeDeclDesc>();\n         this.anonInnerClassHolders = new HashSet<DetailAST>();\n     }\n@@ -216,15 +223,15 @@\n         return varAccessModifier == AccessModifierOption.PRIVATE;\n     }\n     \n     private UnusedLocalVariableCheck.TypeDeclDesc getSuperClassOfAnonInnerClass(final DetailAST literalNewAst) {\n         UnusedLocalVariableCheck.TypeDeclDesc obtainedClass = null;\n         final String shortNameOfClass = CheckUtil.getShortNameOfAnonInnerClass(literalNewAst);\n         if (this.packageName != null && shortNameOfClass.startsWith(this.packageName)) {\n-            final Optional<UnusedLocalVariableCheck.TypeDeclDesc> classWithCompletePackageName = this.typeDeclAstToTypeDeclDesc.values().stream().filter(typeDeclDesc -> typeDeclDesc.getQualifiedName().equals(shortNameOfClass)).findFirst();\n+            final Optional<UnusedLocalVariableCheck.TypeDeclDesc> classWithCompletePackageName = this.typeDeclAstToTypeDeclDesc.values().stream().filter(typeDeclDesc -> typeDeclDesc.getQualifiedName().equals(anObject)).findFirst();\n             if (classWithCompletePackageName.isPresent()) {\n                 obtainedClass = classWithCompletePackageName.get();\n             }\n         }\n         else {\n             final List<UnusedLocalVariableCheck.TypeDeclDesc> typeDeclWithSameName = this.typeDeclWithSameName(shortNameOfClass);\n             if (!typeDeclWithSameName.isEmpty()) {\n@@ -232,38 +239,36 @@\n             }\n         }\n         return obtainedClass;\n     }\n     \n     private void modifyVariablesStack(final UnusedLocalVariableCheck.TypeDeclDesc obtainedClass, final Deque<UnusedLocalVariableCheck.VariableDesc> variablesStack, final DetailAST literalNewAst) {\n         if (obtainedClass != null) {\n-            final Deque updatedCopyOfVarStack;\n-            final Deque<UnusedLocalVariableCheck.VariableDesc> instAndClassVarDeque = updatedCopyOfVarStack = ((UnusedLocalVariableCheck.TypeDeclDesc)this.typeDeclAstToTypeDeclDesc.get(obtainedClass.getTypeDeclAst())).getUpdatedCopyOfVarStack(literalNewAst);\n-            Objects.requireNonNull(variablesStack);\n-            updatedCopyOfVarStack.forEach(variablesStack::push);\n+            final Deque<UnusedLocalVariableCheck.VariableDesc> instAndClassVarDeque = ((UnusedLocalVariableCheck.TypeDeclDesc)this.typeDeclAstToTypeDeclDesc.get(obtainedClass.getTypeDeclAst())).getUpdatedCopyOfVarStack(literalNewAst);\n+            instAndClassVarDeque.forEach(variablesStack::push);\n         }\n     }\n     \n     private List<UnusedLocalVariableCheck.TypeDeclDesc> typeDeclWithSameName(final String superClassName) {\n-        return this.typeDeclAstToTypeDeclDesc.values().stream().filter(typeDeclDesc -> this.hasSameNameAsSuperClass(superClassName, typeDeclDesc)).collect((Collector<? super UnusedLocalVariableCheck.TypeDeclDesc, ?, List<UnusedLocalVariableCheck.TypeDeclDesc>>)Collectors.toList());\n+        return this.typeDeclAstToTypeDeclDesc.values().stream().filter(typeDeclDesc -> this.hasSameNameAsSuperClass(superClassName2, typeDeclDesc)).collect((Collector<? super UnusedLocalVariableCheck.TypeDeclDesc, ?, List<UnusedLocalVariableCheck.TypeDeclDesc>>)Collectors.toList());\n     }\n     \n     private boolean hasSameNameAsSuperClass(final String superClassName, final UnusedLocalVariableCheck.TypeDeclDesc typeDeclDesc) {\n         boolean result;\n         if (this.packageName == null && typeDeclDesc.getDepth() == 0) {\n             result = typeDeclDesc.getQualifiedName().equals(superClassName);\n         }\n         else {\n             result = typeDeclDesc.getQualifiedName().endsWith(\".\" + superClassName);\n         }\n         return result;\n     }\n     \n     private static UnusedLocalVariableCheck.TypeDeclDesc getTheNearestClass(final String outerTypeDeclName, final List<UnusedLocalVariableCheck.TypeDeclDesc> typeDeclWithSameName) {\n-        return Collections.min((Collection<? extends UnusedLocalVariableCheck.TypeDeclDesc>)typeDeclWithSameName, (first, second) -> getTypeDeclarationNameMatchingCountDiff(outerTypeDeclName, first, second));\n+        return Collections.min((Collection<? extends UnusedLocalVariableCheck.TypeDeclDesc>)typeDeclWithSameName, (first, second) -> getTypeDeclarationNameMatchingCountDiff(outerTypeDeclName2, first, second));\n     }\n     \n     private static int getTypeDeclarationNameMatchingCountDiff(final String outerTypeDeclName, final UnusedLocalVariableCheck.TypeDeclDesc firstTypeDecl, final UnusedLocalVariableCheck.TypeDeclDesc secondTypeDecl) {\n         int diff = Integer.compare(CheckUtil.typeDeclarationNameMatchingCount(outerTypeDeclName, secondTypeDecl.getQualifiedName()), CheckUtil.typeDeclarationNameMatchingCount(outerTypeDeclName, firstTypeDecl.getQualifiedName()));\n         if (diff == 0) {\n             diff = Integer.compare(firstTypeDecl.getDepth(), secondTypeDecl.getDepth());\n         }\n@@ -345,16 +350,8 @@\n         final DetailAST grandParent = parent.getParent();\n         return TokenUtil.isOfType(parent, UnusedLocalVariableCheck.INCREMENT_AND_DECREMENT_TOKENS) && TokenUtil.isOfType(grandParent, new int[] { 28 }) && !isIncrementOrDecrementVariableUsed(grandParent);\n     }\n     \n     private static boolean isIncrementOrDecrementVariableUsed(final DetailAST exprAst) {\n         return TokenUtil.isOfType(exprAst.getParent(), new int[] { 34, 24, 80 }) && exprAst.getParent().getParent().getType() != 37;\n     }\n-    \n-    static {\n-        INCREMENT_AND_DECREMENT_TOKENS = new int[] { 25, 26, 129, 130 };\n-        SCOPES = new int[] { 7, 91, 6 };\n-        UNACCEPTABLE_CHILD_OF_DOT = new int[] { 59, 27, 136, 79, 69, 78 };\n-        UNACCEPTABLE_PARENT_OF_IDENT = new int[] { 10, 59, 136, 198, 27, 13 };\n-        CONTAINERS_FOR_ANON_INNERS = new int[] { 9, 8, 12, 11, 203 };\n-    }\n }\n"}]}
