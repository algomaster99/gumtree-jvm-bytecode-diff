{"diffoscope-json-version": 1, "source1": "first/Streams$FailableStream.class", "source2": "second/Streams$FailableStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -16,63 +16,63 @@\n     private Stream<O> stream;\n     private boolean terminated;\n     \n     public FailableStream(final Stream<O> stream) {\n         this.stream = stream;\n     }\n     \n-    public boolean allMatch(final FailablePredicate<O, ?> predicate) {\n+    public boolean allMatch(final FailablePredicate<O, ?> failablePredicate) {\n         this.assertNotTerminated();\n-        return this.stream().allMatch(Failable.asPredicate((FailablePredicate)predicate));\n+        return this.stream().allMatch(Failable.asPredicate((FailablePredicate)failablePredicate));\n     }\n     \n-    public boolean anyMatch(final FailablePredicate<O, ?> predicate) {\n+    public boolean anyMatch(final FailablePredicate<O, ?> failablePredicate) {\n         this.assertNotTerminated();\n-        return this.stream().anyMatch(Failable.asPredicate((FailablePredicate)predicate));\n+        return this.stream().anyMatch(Failable.asPredicate((FailablePredicate)failablePredicate));\n     }\n     \n     protected void assertNotTerminated() {\n         if (this.terminated) {\n             throw new IllegalStateException(\"This stream is already terminated.\");\n         }\n     }\n     \n     public <A, R> R collect(final Collector<? super O, A, R> collector) {\n         this.makeTerminated();\n         return this.stream().collect(collector);\n     }\n     \n-    public <A, R> R collect(final Supplier<R> pupplier, final BiConsumer<R, ? super O> accumulator, final BiConsumer<R, R> combiner) {\n+    public <A, R> R collect(final Supplier<R> supplier, final BiConsumer<R, ? super O> biConsumer, final BiConsumer<R, R> biConsumer2) {\n         this.makeTerminated();\n-        return this.stream().collect(pupplier, accumulator, combiner);\n+        return this.stream().collect(supplier, biConsumer, biConsumer2);\n     }\n     \n-    public FailableStream<O> filter(final FailablePredicate<O, ?> predicate) {\n+    public FailableStream<O> filter(final FailablePredicate<O, ?> failablePredicate) {\n         this.assertNotTerminated();\n-        this.stream = this.stream.filter(Failable.asPredicate((FailablePredicate)predicate));\n+        this.stream = this.stream.filter(Failable.asPredicate((FailablePredicate)failablePredicate));\n         return this;\n     }\n     \n-    public void forEach(final FailableConsumer<O, ?> action) {\n+    public void forEach(final FailableConsumer<O, ?> failableConsumer) {\n         this.makeTerminated();\n-        this.stream().forEach(Failable.asConsumer((FailableConsumer)action));\n+        this.stream().forEach(Failable.asConsumer((FailableConsumer)failableConsumer));\n     }\n     \n     protected void makeTerminated() {\n         this.assertNotTerminated();\n         this.terminated = true;\n     }\n     \n-    public <R> Streams.FailableStream<R> map(final FailableFunction<O, R, ?> mapper) {\n+    public <R> Streams.FailableStream<R> map(final FailableFunction<O, R, ?> failableFunction) {\n         this.assertNotTerminated();\n-        return (Streams.FailableStream<R>)new Streams.FailableStream((Stream)this.stream.map(Failable.asFunction((FailableFunction)mapper)));\n+        return (Streams.FailableStream<R>)new Streams.FailableStream((Stream)this.stream.map(Failable.asFunction((FailableFunction)failableFunction)));\n     }\n     \n-    public O reduce(final O identity, final BinaryOperator<O> accumulator) {\n+    public O reduce(final O o, final BinaryOperator<O> binaryOperator) {\n         this.makeTerminated();\n-        return this.stream().reduce(identity, accumulator);\n+        return this.stream().reduce(o, binaryOperator);\n     }\n     \n     public Stream<O> stream() {\n         return this.stream;\n     }\n }\n"}]}
