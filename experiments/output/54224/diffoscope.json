{"diffoscope-json-version": 1, "source1": "first/ZipFile.class", "source2": "second/ZipFile.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -80,14 +80,20 @@\n     private final ByteBuffer cfhBbuf;\n     private final ByteBuffer shortBbuf;\n     private long centralDirectoryStartDiskNumber;\n     private long centralDirectoryStartRelativeOffset;\n     private long centralDirectoryStartOffset;\n     private long firstLocalFileHeaderOffset;\n     \n+    static {\n+        ONE_ZERO_BYTE = new byte[1];\n+        CFH_SIG = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n+        offsetComparator = Comparator.comparingLong(ZipArchiveEntry::getDiskNumberStart).thenComparingLong(ZipArchiveEntry::getLocalHeaderOffset);\n+    }\n+    \n     public static void closeQuietly(final ZipFile zipFile) {\n         IOUtils.closeQuietly((Closeable)zipFile);\n     }\n     \n     public ZipFile(final File f) throws IOException {\n         this(f, \"UTF8\");\n     }\n@@ -168,14 +174,18 @@\n         }\n         finally {\n             this.closed = !success;\n             if (!success && closeOnError) {\n                 IOUtils.closeQuietly((Closeable)this.archive);\n             }\n         }\n+        this.closed = !success;\n+        if (!success && closeOnError) {\n+            IOUtils.closeQuietly((Closeable)this.archive);\n+        }\n     }\n     \n     public ZipFile(final String name) throws IOException {\n         this(new File(name).toPath(), \"UTF8\");\n     }\n     \n     public ZipFile(final String name, final String encoding) throws IOException {\n@@ -223,14 +233,15 @@\n             if (!this.closed) {\n                 this.close();\n             }\n         }\n         finally {\n             super.finalize();\n         }\n+        super.finalize();\n     }\n     \n     public InputStream getContentBeforeFirstLocalFileHeader() {\n         return (InputStream)((this.firstLocalFileHeaderOffset == 0L) ? null : this.createBoundedInputStream(0L, this.firstLocalFileHeaderOffset));\n     }\n     \n     private long getDataOffset(final ZipArchiveEntry ze) throws IOException {\n@@ -282,37 +293,37 @@\n     \n     public InputStream getInputStream(final ZipArchiveEntry zipEntry) throws IOException {\n         if (!(zipEntry instanceof ZipFile.Entry)) {\n             return null;\n         }\n         ZipUtil.checkRequestedFeatures(zipEntry);\n         final InputStream is = new BufferedInputStream(this.getRawInputStream(zipEntry));\n-        switch (ZipFile.ZipFile$2.$SwitchMap$org$apache$commons$compress$archivers$zip$ZipMethod[ZipMethod.getMethodByCode(zipEntry.getMethod()).ordinal()]) {\n-            case 1: {\n+        switch (ZipMethod.getMethodByCode(zipEntry.getMethod())) {\n+            case STORED: {\n                 return (InputStream)new ZipFile.StoredStatisticsStream(is);\n             }\n-            case 2: {\n+            case UNSHRINKING: {\n                 return (InputStream)new UnshrinkingInputStream(is);\n             }\n-            case 3: {\n+            case IMPLODING: {\n                 try {\n                     return (InputStream)new ExplodingInputStream(zipEntry.getGeneralPurposeBit().getSlidingDictionarySize(), zipEntry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(), is);\n                 }\n                 catch (final IllegalArgumentException ex) {\n                     throw new IOException(\"bad IMPLODE data\", ex);\n                 }\n             }\n-            case 4: {\n+            case DEFLATED: {\n                 final Inflater inflater = new Inflater(true);\n                 return (InputStream)new ZipFile.ZipFile$1(this, (InputStream)new SequenceInputStream(is, new ByteArrayInputStream(ZipFile.ONE_ZERO_BYTE)), inflater, inflater);\n             }\n-            case 5: {\n+            case BZIP2: {\n                 return (InputStream)new BZip2CompressorInputStream(is);\n             }\n-            case 6: {\n+            case ENHANCED_DEFLATED: {\n                 return (InputStream)new Deflate64CompressorInputStream(is);\n             }\n             default: {\n                 throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(zipEntry.getMethod()), zipEntry);\n             }\n         }\n     }\n@@ -326,16 +337,37 @@\n             return null;\n         }\n         return (InputStream)this.createBoundedInputStream(start, ze.getCompressedSize());\n     }\n     \n     public String getUnixSymlink(final ZipArchiveEntry entry) throws IOException {\n         if (entry != null && entry.isUnixSymlink()) {\n-            try (final InputStream in = this.getInputStream(entry)) {\n-                return this.zipEncoding.decode(IOUtils.toByteArray(in));\n+            Throwable t = null;\n+            try {\n+                final InputStream in = this.getInputStream(entry);\n+                try {\n+                    return this.zipEncoding.decode(IOUtils.toByteArray(in));\n+                }\n+                finally {\n+                    if (in != null) {\n+                        in.close();\n+                    }\n+                }\n+            }\n+            finally {\n+                if (t == null) {\n+                    final Throwable exception;\n+                    t = exception;\n+                }\n+                else {\n+                    final Throwable exception;\n+                    if (t != exception) {\n+                        t.addSuppressed(exception);\n+                    }\n+                }\n             }\n         }\n         return null;\n     }\n     \n     private Map<ZipArchiveEntry, ZipFile.NameAndComment> populateFromCentralDirectory() throws IOException {\n         final HashMap<ZipArchiveEntry, ZipFile.NameAndComment> noUTF8Flag = new HashMap<ZipArchiveEntry, ZipFile.NameAndComment>();\n@@ -536,15 +568,15 @@\n         this.sanityCheckLFHOffset((ZipArchiveEntry)ze);\n         final byte[] comment = IOUtils.readRange((ReadableByteChannel)this.archive, commentLen);\n         if (comment.length < commentLen) {\n             throw new EOFException();\n         }\n         ze.setComment(entryEncoding.decode(comment));\n         if (!hasUTF8Flag && this.useUnicodeExtraFields) {\n-            noUTF8Flag.put((ZipArchiveEntry)ze, new ZipFile.NameAndComment(fileName, comment, (ZipFile.ZipFile$1)null));\n+            noUTF8Flag.put((ZipArchiveEntry)ze, new ZipFile.NameAndComment(fileName, comment, (ZipFile.NameAndComment)null));\n         }\n         ze.setStreamContiguous(true);\n     }\n     \n     private void resolveLocalFileHeaderData(final Map<ZipArchiveEntry, ZipFile.NameAndComment> entriesWithoutUTF8Flag) throws IOException {\n         for (final ZipArchiveEntry zipArchiveEntry : this.entries) {\n             final ZipFile.Entry ze = (ZipFile.Entry)zipArchiveEntry;\n@@ -564,15 +596,15 @@\n                 z.initCause(ex);\n                 throw z;\n             }\n             if (!entriesWithoutUTF8Flag.containsKey(ze)) {\n                 continue;\n             }\n             final ZipFile.NameAndComment nc = (ZipFile.NameAndComment)entriesWithoutUTF8Flag.get(ze);\n-            ZipUtil.setNameAndCommentFromExtraFields((ZipArchiveEntry)ze, ZipFile.NameAndComment.access$200(nc), ZipFile.NameAndComment.access$300(nc));\n+            ZipUtil.setNameAndCommentFromExtraFields((ZipArchiveEntry)ze, ZipFile.NameAndComment.access$1(nc), ZipFile.NameAndComment.access$2(nc));\n         }\n     }\n     \n     private void sanityCheckLFHOffset(final ZipArchiveEntry ze) throws IOException {\n         if (ze.getDiskNumberStart() < 0L) {\n             throw new IOException(\"broken archive, entry with negative disk number\");\n         }\n@@ -705,14 +737,8 @@\n             }\n         }\n         if (found) {\n             this.archive.position(off);\n         }\n         return found;\n     }\n-    \n-    static {\n-        ONE_ZERO_BYTE = new byte[1];\n-        CFH_SIG = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n-        offsetComparator = Comparator.comparingLong(ZipArchiveEntry::getDiskNumberStart).thenComparingLong(ZipArchiveEntry::getLocalHeaderOffset);\n-    }\n }\n"}]}
