{"diffoscope-json-version": 1, "source1": "first/AbstractHierarchicalConfiguration.class", "source2": "second/AbstractHierarchicalConfiguration.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -14,47 +14,47 @@\n import org.apache.commons.configuration2.tree.NodeAddData;\n import java.util.function.Supplier;\n import java.util.LinkedList;\n import java.util.function.Function;\n import org.apache.commons.configuration2.event.ConfigurationEvent;\n import java.util.Collection;\n import java.util.Collections;\n+import org.apache.commons.configuration2.tree.QueryResult;\n import java.util.stream.Collector;\n import java.util.stream.Collectors;\n import java.util.function.Predicate;\n import java.util.Objects;\n-import org.apache.commons.configuration2.tree.QueryResult;\n import java.util.List;\n import org.apache.commons.configuration2.tree.DefaultExpressionEngine;\n import org.apache.commons.configuration2.tree.NodeHandler;\n import org.apache.commons.configuration2.tree.ExpressionEngine;\n import org.apache.commons.configuration2.tree.NodeModel;\n import org.apache.commons.configuration2.tree.NodeKeyResolver;\n \n public abstract class AbstractHierarchicalConfiguration<T> extends AbstractConfiguration implements Cloneable, NodeKeyResolver<T>, HierarchicalConfiguration<T>\n {\n     private NodeModel<T> model;\n     private ExpressionEngine expressionEngine;\n     \n-    protected AbstractHierarchicalConfiguration(final NodeModel<T> nodeModel) {\n-        this.model = nodeModel;\n+    protected AbstractHierarchicalConfiguration(final NodeModel<T> model) {\n+        this.model = model;\n     }\n     \n     public final String getRootElementName() {\n         this.beginRead(false);\n         try {\n             return this.getRootElementNameInternal();\n         }\n         finally {\n             this.endRead();\n         }\n     }\n     \n     protected String getRootElementNameInternal() {\n-        final NodeHandler<T> nodeHandler = (NodeHandler<T>)this.getModel().getNodeHandler();\n+        final NodeHandler nodeHandler = this.getModel().getNodeHandler();\n         return nodeHandler.nodeName(nodeHandler.getRootNode());\n     }\n     \n     public NodeModel<T> getNodeModel() {\n         this.beginRead(false);\n         try {\n             return this.getModel();\n@@ -68,228 +68,229 @@\n         return (ExpressionEngine)((this.expressionEngine != null) ? this.expressionEngine : DefaultExpressionEngine.INSTANCE);\n     }\n     \n     public void setExpressionEngine(final ExpressionEngine expressionEngine) {\n         this.expressionEngine = expressionEngine;\n     }\n     \n-    protected Object getPropertyInternal(final String key) {\n-        final List<QueryResult<T>> results = this.fetchNodeList(key);\n-        if (results.isEmpty()) {\n+    protected Object getPropertyInternal(final String s) {\n+        final List<org.apache.commons.configuration2.tree.QueryResult<T>> fetchNodeList = this.fetchNodeList(s);\n+        if (fetchNodeList.isEmpty()) {\n             return null;\n         }\n-        final NodeHandler<T> handler = (NodeHandler<T>)this.getModel().getNodeHandler();\n-        final List<Object> list = (List<Object>)results.stream().map(r -> this.valueFromResult((QueryResult<T>)r, (NodeHandler<T>)handler)).filter(Objects::nonNull).collect((Collector<? super Object, ?, List<Object>>)Collectors.toList());\n+        final List<? super Object> list = (List<? super Object>)fetchNodeList.stream().map(queryResult -> {\n+            this.getModel().getNodeHandler();\n+            return this.valueFromResult(queryResult, nodeHandler);\n+        }).filter(Objects::nonNull).collect((Collector<? super Object, ?, List<? super Object>>)Collectors.toList());\n         if (list.size() < 1) {\n             return null;\n         }\n         return (list.size() == 1) ? list.get(0) : list;\n     }\n     \n-    protected void addPropertyInternal(final String key, final Object obj) {\n-        this.addPropertyToModel(key, this.getListDelimiterHandler().parse(obj));\n+    protected void addPropertyInternal(final String s, final Object o) {\n+        this.addPropertyToModel(s, this.getListDelimiterHandler().parse(o));\n     }\n     \n-    protected void addPropertyDirect(final String key, final Object value) {\n-        this.addPropertyToModel(key, Collections.singleton(value));\n+    protected void addPropertyDirect(final String s, final Object o) {\n+        this.addPropertyToModel(s, Collections.singleton(o));\n     }\n     \n-    private void addPropertyToModel(final String key, final Iterable<?> values) {\n-        this.getModel().addProperty(key, (Iterable)values, (NodeKeyResolver)this);\n+    private void addPropertyToModel(final String s, final Iterable<?> iterable) {\n+        this.getModel().addProperty(s, (Iterable)iterable, (NodeKeyResolver)this);\n     }\n     \n-    public final void addNodes(final String key, final Collection<? extends T> nodes) {\n-        if (nodes == null || nodes.isEmpty()) {\n+    public final void addNodes(final String s, final Collection<? extends T> collection) {\n+        if (collection == null || collection.isEmpty()) {\n             return;\n         }\n         this.beginWrite(false);\n         try {\n-            this.fireEvent(ConfigurationEvent.ADD_NODES, key, (Object)nodes, true);\n-            this.addNodesInternal(key, nodes);\n-            this.fireEvent(ConfigurationEvent.ADD_NODES, key, (Object)nodes, false);\n+            this.fireEvent(ConfigurationEvent.ADD_NODES, s, (Object)collection, true);\n+            this.addNodesInternal(s, collection);\n+            this.fireEvent(ConfigurationEvent.ADD_NODES, s, (Object)collection, false);\n         }\n         finally {\n             this.endWrite();\n         }\n     }\n     \n-    protected void addNodesInternal(final String key, final Collection<? extends T> nodes) {\n-        this.getModel().addNodes(key, (Collection)nodes, (NodeKeyResolver)this);\n+    protected void addNodesInternal(final String s, final Collection<? extends T> collection) {\n+        this.getModel().addNodes(s, (Collection)collection, (NodeKeyResolver)this);\n     }\n     \n     protected boolean isEmptyInternal() {\n         return !this.nodeDefined(this.getModel().getNodeHandler().getRootNode());\n     }\n     \n-    protected boolean containsKeyInternal(final String key) {\n-        return this.getPropertyInternal(key) != null;\n+    protected boolean containsKeyInternal(final String s) {\n+        return this.getPropertyInternal(s) != null;\n     }\n     \n-    protected void setPropertyInternal(final String key, final Object value) {\n-        this.getModel().setProperty(key, value, (NodeKeyResolver)this);\n+    protected void setPropertyInternal(final String s, final Object o) {\n+        this.getModel().setProperty(s, o, (NodeKeyResolver)this);\n     }\n     \n-    public List<QueryResult<T>> resolveKey(final T root, final String key, final NodeHandler<T> handler) {\n-        return this.getExpressionEngine().query((Object)root, key, (NodeHandler)handler);\n+    public List<QueryResult<T>> resolveKey(final T t, final String s, final NodeHandler<T> nodeHandler) {\n+        return this.getExpressionEngine().query((Object)t, s, (NodeHandler)nodeHandler);\n     }\n     \n-    public List<T> resolveNodeKey(final T root, final String key, final NodeHandler<T> handler) {\n-        return this.resolveKey(root, key, handler).stream().filter(r -> !r.isAttributeResult()).map((Function<? super Object, ?>)QueryResult::getNode).collect((Collector<? super Object, ?, List<T>>)Collectors.toCollection((Supplier<R>)LinkedList::new));\n+    public List<T> resolveNodeKey(final T t, final String s, final NodeHandler<T> nodeHandler) {\n+        return this.resolveKey(t, s, nodeHandler).stream().filter(queryResult -> !queryResult.isAttributeResult()).map((Function<? super Object, ?>)QueryResult::getNode).collect((Collector<? super Object, ?, List<T>>)Collectors.toCollection((Supplier<R>)LinkedList::new));\n     }\n     \n-    public NodeAddData<T> resolveAddKey(final T root, final String key, final NodeHandler<T> handler) {\n-        return (NodeAddData<T>)this.getExpressionEngine().prepareAdd((Object)root, key, (NodeHandler)handler);\n+    public NodeAddData<T> resolveAddKey(final T t, final String s, final NodeHandler<T> nodeHandler) {\n+        return (NodeAddData<T>)this.getExpressionEngine().prepareAdd((Object)t, s, (NodeHandler)nodeHandler);\n     }\n     \n-    public NodeUpdateData<T> resolveUpdateKey(final T root, final String key, final Object newValue, final NodeHandler<T> handler) {\n-        final Iterator<QueryResult<T>> itNodes = this.fetchNodeList(key).iterator();\n-        final Iterator<?> itValues = this.getListDelimiterHandler().parse(newValue).iterator();\n-        final Map<QueryResult<T>, Object> changedValues = new HashMap<QueryResult<T>, Object>();\n-        Collection<Object> additionalValues = null;\n-        Collection<QueryResult<T>> removedItems = null;\n-        while (itNodes.hasNext() && itValues.hasNext()) {\n-            changedValues.put(itNodes.next(), itValues.next());\n+    public NodeUpdateData<T> resolveUpdateKey(final T t, final String s, final Object o, final NodeHandler<T> nodeHandler) {\n+        final Iterator<org.apache.commons.configuration2.tree.QueryResult<T>> iterator = this.fetchNodeList(s).iterator();\n+        final Iterator iterator2 = this.getListDelimiterHandler().parse(o).iterator();\n+        final HashMap hashMap = new HashMap();\n+        Collection collection = null;\n+        Collection collection2 = null;\n+        while (iterator.hasNext() && iterator2.hasNext()) {\n+            hashMap.put(iterator.next(), iterator2.next());\n         }\n-        if (itValues.hasNext()) {\n-            additionalValues = new LinkedList<Object>();\n-            final Iterator<?> iterator = itValues;\n-            final Collection<Object> obj = additionalValues;\n-            Objects.requireNonNull((LinkedList)obj);\n-            iterator.forEachRemaining(obj::add);\n+        if (iterator2.hasNext()) {\n+            collection = new LinkedList();\n+            final Iterator iterator3 = iterator2;\n+            final Collection obj = collection;\n+            Objects.requireNonNull(obj);\n+            iterator3.forEachRemaining(obj::add);\n         }\n-        if (itNodes.hasNext()) {\n-            removedItems = new LinkedList<QueryResult<T>>();\n-            final Iterator<QueryResult<T>> iterator2 = itNodes;\n-            final Collection<QueryResult<T>> obj2 = removedItems;\n+        if (iterator.hasNext()) {\n+            collection2 = new LinkedList();\n+            final Iterator iterator4 = iterator;\n+            final Collection obj2 = collection2;\n             Objects.requireNonNull(obj2);\n-            iterator2.forEachRemaining(obj2::add);\n+            iterator4.forEachRemaining(obj2::add);\n         }\n-        return (NodeUpdateData<T>)new NodeUpdateData((Map)changedValues, (Collection)additionalValues, (Collection)removedItems, key);\n+        return (NodeUpdateData<T>)new NodeUpdateData((Map)hashMap, collection, collection2, s);\n     }\n     \n-    public String nodeKey(final T node, final Map<T, String> cache, final NodeHandler<T> handler) {\n-        final List<T> paths = new LinkedList<T>();\n-        T currentNode;\n-        String key;\n-        for (currentNode = node, key = cache.get(node); key == null && currentNode != null; currentNode = (T)handler.getParent((Object)currentNode), key = cache.get(currentNode)) {\n-            paths.add(0, currentNode);\n+    public String nodeKey(final T t, final Map<T, String> map, final NodeHandler<T> nodeHandler) {\n+        final LinkedList list = new LinkedList();\n+        Object parent;\n+        String s;\n+        for (parent = t, s = map.get(t); s == null && parent != null; parent = nodeHandler.getParent(parent), s = map.get(parent)) {\n+            list.add(0, parent);\n         }\n-        for (final T n : paths) {\n-            final String currentKey = this.getExpressionEngine().canonicalKey((Object)n, key, (NodeHandler)handler);\n-            cache.put(n, currentKey);\n-            key = currentKey;\n+        for (final Object next : list) {\n+            final String canonicalKey = this.getExpressionEngine().canonicalKey(next, s, (NodeHandler)nodeHandler);\n+            map.put((T)next, canonicalKey);\n+            s = canonicalKey;\n         }\n-        return key;\n+        return s;\n     }\n     \n     protected void clearInternal() {\n         this.getModel().clear((NodeKeyResolver)this);\n     }\n     \n-    public final void clearTree(final String key) {\n+    public final void clearTree(final String s) {\n         this.beginWrite(false);\n         try {\n-            this.fireEvent(ConfigurationEvent.CLEAR_TREE, key, (Object)null, true);\n-            this.fireEvent(ConfigurationEvent.CLEAR_TREE, key, this.clearTreeInternal(key), false);\n+            this.fireEvent(ConfigurationEvent.CLEAR_TREE, s, (Object)null, true);\n+            this.fireEvent(ConfigurationEvent.CLEAR_TREE, s, this.clearTreeInternal(s), false);\n         }\n         finally {\n             this.endWrite();\n         }\n     }\n     \n-    protected Object clearTreeInternal(final String key) {\n-        return this.getModel().clearTree(key, (NodeKeyResolver)this);\n+    protected Object clearTreeInternal(final String s) {\n+        return this.getModel().clearTree(s, (NodeKeyResolver)this);\n     }\n     \n-    protected void clearPropertyDirect(final String key) {\n-        this.getModel().clearProperty(key, (NodeKeyResolver)this);\n+    protected void clearPropertyDirect(final String s) {\n+        this.getModel().clearProperty(s, (NodeKeyResolver)this);\n     }\n     \n     protected int sizeInternal() {\n         return this.visitDefinedKeys().getKeyList().size();\n     }\n     \n     protected Iterator<String> getKeysInternal() {\n         return this.visitDefinedKeys().getKeyList().iterator();\n     }\n     \n     private AbstractHierarchicalConfiguration.DefinedKeysVisitor visitDefinedKeys() {\n-        final AbstractHierarchicalConfiguration.DefinedKeysVisitor visitor = new AbstractHierarchicalConfiguration.DefinedKeysVisitor(this);\n-        final NodeHandler<T> nodeHandler = (NodeHandler<T>)this.getModel().getNodeHandler();\n-        NodeTreeWalker.INSTANCE.walkDFS(nodeHandler.getRootNode(), (ConfigurationNodeVisitor)visitor, (NodeHandler)nodeHandler);\n-        return visitor;\n-    }\n-    \n-    protected Iterator<String> getKeysInternal(final String prefix) {\n-        final AbstractHierarchicalConfiguration.DefinedKeysVisitor visitor = new AbstractHierarchicalConfiguration.DefinedKeysVisitor(this, prefix);\n-        if (this.containsKey(prefix)) {\n-            visitor.getKeyList().add(prefix);\n-        }\n-        final List<QueryResult<T>> results = this.fetchNodeList(prefix);\n-        final NodeHandler<T> handler = (NodeHandler<T>)this.getModel().getNodeHandler();\n-        results.forEach(result -> {\n-            if (!result.isAttributeResult()) {\n-                handler.getChildren(result.getNode()).forEach(c -> NodeTreeWalker.INSTANCE.walkDFS(c, (ConfigurationNodeVisitor)visitor, handler));\n-                visitor.handleAttributeKeys(prefix, result.getNode(), handler);\n+        final AbstractHierarchicalConfiguration.DefinedKeysVisitor definedKeysVisitor = new AbstractHierarchicalConfiguration.DefinedKeysVisitor(this);\n+        final NodeHandler nodeHandler = this.getModel().getNodeHandler();\n+        NodeTreeWalker.INSTANCE.walkDFS(nodeHandler.getRootNode(), (ConfigurationNodeVisitor)definedKeysVisitor, nodeHandler);\n+        return definedKeysVisitor;\n+    }\n+    \n+    protected Iterator<String> getKeysInternal(final String s) {\n+        final AbstractHierarchicalConfiguration.DefinedKeysVisitor definedKeysVisitor = new AbstractHierarchicalConfiguration.DefinedKeysVisitor(this, s);\n+        if (this.containsKey(s)) {\n+            definedKeysVisitor.getKeyList().add(s);\n+        }\n+        this.fetchNodeList(s).forEach(queryResult -> {\n+            this.getModel().getNodeHandler();\n+            if (!queryResult.isAttributeResult()) {\n+                nodeHandler.getChildren(queryResult.getNode()).forEach(o -> NodeTreeWalker.INSTANCE.walkDFS(o, (ConfigurationNodeVisitor)definedKeysVisitor3, nodeHandler2));\n+                definedKeysVisitor2.handleAttributeKeys(s2, queryResult.getNode(), nodeHandler);\n             }\n             return;\n         });\n-        return visitor.getKeyList().iterator();\n+        return definedKeysVisitor.getKeyList().iterator();\n     }\n     \n-    public final int getMaxIndex(final String key) {\n+    public final int getMaxIndex(final String s) {\n         this.beginRead(false);\n         try {\n-            return this.getMaxIndexInternal(key);\n+            return this.getMaxIndexInternal(s);\n         }\n         finally {\n             this.endRead();\n         }\n     }\n     \n-    protected int getMaxIndexInternal(final String key) {\n-        return this.fetchNodeList(key).size() - 1;\n+    protected int getMaxIndexInternal(final String s) {\n+        return this.fetchNodeList(s).size() - 1;\n     }\n     \n     public Object clone() {\n         this.beginRead(false);\n         try {\n-            final AbstractHierarchicalConfiguration<T> copy = (AbstractHierarchicalConfiguration)super.clone();\n-            copy.setSynchronizer((Synchronizer)NoOpSynchronizer.INSTANCE);\n-            copy.cloneInterpolator((AbstractConfiguration)this);\n-            copy.setSynchronizer(ConfigurationUtils.cloneSynchronizer(this.getSynchronizer()));\n-            copy.model = this.cloneNodeModel();\n-            return copy;\n+            final AbstractHierarchicalConfiguration abstractHierarchicalConfiguration = (AbstractHierarchicalConfiguration)super.clone();\n+            abstractHierarchicalConfiguration.setSynchronizer((Synchronizer)NoOpSynchronizer.INSTANCE);\n+            abstractHierarchicalConfiguration.cloneInterpolator((AbstractConfiguration)this);\n+            abstractHierarchicalConfiguration.setSynchronizer(ConfigurationUtils.cloneSynchronizer(this.getSynchronizer()));\n+            abstractHierarchicalConfiguration.model = this.cloneNodeModel();\n+            return abstractHierarchicalConfiguration;\n         }\n-        catch (final CloneNotSupportedException cex) {\n-            throw new ConfigurationRuntimeException((Throwable)cex);\n+        catch (final CloneNotSupportedException ex) {\n+            throw new ConfigurationRuntimeException((Throwable)ex);\n         }\n         finally {\n             this.endRead();\n         }\n     }\n     \n     protected abstract NodeModel<T> cloneNodeModel();\n     \n-    protected List<QueryResult<T>> fetchNodeList(final String key) {\n-        final NodeHandler<T> nodeHandler = (NodeHandler<T>)this.getModel().getNodeHandler();\n-        return (List<QueryResult<T>>)this.resolveKey(nodeHandler.getRootNode(), key, (org.apache.commons.configuration2.tree.NodeHandler<Object>)nodeHandler);\n+    protected List<QueryResult<T>> fetchNodeList(final String s) {\n+        final NodeHandler nodeHandler = this.getModel().getNodeHandler();\n+        return (List<QueryResult<T>>)this.resolveKey(nodeHandler.getRootNode(), s, (org.apache.commons.configuration2.tree.NodeHandler<Object>)nodeHandler);\n     }\n     \n-    protected boolean nodeDefined(final T node) {\n-        final AbstractHierarchicalConfiguration.DefinedVisitor<T> visitor = (AbstractHierarchicalConfiguration.DefinedVisitor<T>)new AbstractHierarchicalConfiguration.DefinedVisitor((AbstractHierarchicalConfiguration.AbstractHierarchicalConfiguration$1)null);\n-        NodeTreeWalker.INSTANCE.walkBFS((Object)node, (ConfigurationNodeVisitor)visitor, this.getModel().getNodeHandler());\n-        return visitor.isDefined();\n+    protected boolean nodeDefined(final T t) {\n+        final AbstractHierarchicalConfiguration.DefinedVisitor definedVisitor = new AbstractHierarchicalConfiguration.DefinedVisitor((AbstractHierarchicalConfiguration.AbstractHierarchicalConfiguration$1)null);\n+        NodeTreeWalker.INSTANCE.walkBFS((Object)t, (ConfigurationNodeVisitor)definedVisitor, this.getModel().getNodeHandler());\n+        return definedVisitor.isDefined();\n     }\n     \n     protected NodeModel<T> getModel() {\n         return this.model;\n     }\n     \n-    private Object valueFromResult(final QueryResult<T> result, final NodeHandler<T> handler) {\n-        return result.isAttributeResult() ? result.getAttributeValue((NodeHandler)handler) : handler.getValue(result.getNode());\n+    private Object valueFromResult(final QueryResult<T> queryResult, final NodeHandler<T> nodeHandler) {\n+        return queryResult.isAttributeResult() ? queryResult.getAttributeValue((NodeHandler)nodeHandler) : nodeHandler.getValue(queryResult.getNode());\n     }\n     \n     public String toString() {\n         return super.toString() + \"(\" + this.getRootElementNameInternal() + \")\";\n     }\n }\n"}]}
