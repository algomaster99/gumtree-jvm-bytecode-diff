{"diffoscope-json-version": 1, "source1": "first/TarArchiveInputStream.class", "source2": "second/TarArchiveInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -35,60 +35,61 @@\n     private TarArchiveEntry currEntry;\n     private final ZipEncoding zipEncoding;\n     final String encoding;\n     private Map<String, String> globalPaxHeaders;\n     private final List<TarArchiveStructSparse> globalSparseHeaders;\n     private final boolean lenient;\n     \n-    public TarArchiveInputStream(final InputStream is) {\n-        this(is, 10240, 512);\n+    public TarArchiveInputStream(final InputStream inputStream) {\n+        this(inputStream, 10240, 512);\n     }\n     \n-    public TarArchiveInputStream(final InputStream is, final boolean lenient) {\n-        this(is, 10240, 512, null, lenient);\n+    public TarArchiveInputStream(final InputStream inputStream, final boolean b) {\n+        this(inputStream, 10240, 512, null, b);\n     }\n     \n-    public TarArchiveInputStream(final InputStream is, final String encoding) {\n-        this(is, 10240, 512, encoding);\n+    public TarArchiveInputStream(final InputStream inputStream, final String s) {\n+        this(inputStream, 10240, 512, s);\n     }\n     \n-    public TarArchiveInputStream(final InputStream is, final int blockSize) {\n-        this(is, blockSize, 512);\n+    public TarArchiveInputStream(final InputStream inputStream, final int n) {\n+        this(inputStream, n, 512);\n     }\n     \n-    public TarArchiveInputStream(final InputStream is, final int blockSize, final String encoding) {\n-        this(is, blockSize, 512, encoding);\n+    public TarArchiveInputStream(final InputStream inputStream, final int n, final String s) {\n+        this(inputStream, n, 512, s);\n     }\n     \n-    public TarArchiveInputStream(final InputStream is, final int blockSize, final int recordSize) {\n-        this(is, blockSize, recordSize, null);\n+    public TarArchiveInputStream(final InputStream inputStream, final int n, final int n2) {\n+        this(inputStream, n, n2, null);\n     }\n     \n-    public TarArchiveInputStream(final InputStream is, final int blockSize, final int recordSize, final String encoding) {\n-        this(is, blockSize, recordSize, encoding, false);\n+    public TarArchiveInputStream(final InputStream inputStream, final int n, final int n2, final String s) {\n+        this(inputStream, n, n2, s, false);\n     }\n     \n-    public TarArchiveInputStream(final InputStream is, final int blockSize, final int recordSize, final String encoding, final boolean lenient) {\n+    public TarArchiveInputStream(final InputStream inputStream, final int blockSize, final int recordSize, final String encoding, final boolean lenient) {\n         this.smallBuf = new byte[256];\n         this.globalPaxHeaders = new HashMap<String, String>();\n         this.globalSparseHeaders = new ArrayList<TarArchiveStructSparse>();\n-        this.inputStream = is;\n+        this.inputStream = inputStream;\n         this.hasHitEOF = false;\n         this.encoding = encoding;\n         this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n         this.recordSize = recordSize;\n         this.recordBuffer = new byte[recordSize];\n         this.blockSize = blockSize;\n         this.lenient = lenient;\n     }\n     \n     public void close() throws IOException {\n         if (this.sparseInputStreams != null) {\n-            for (final InputStream inputStream : this.sparseInputStreams) {\n-                inputStream.close();\n+            final Iterator<InputStream> iterator = this.sparseInputStreams.iterator();\n+            while (iterator.hasNext()) {\n+                ((InputStream)iterator.next()).close();\n             }\n         }\n         this.inputStream.close();\n     }\n     \n     public int getRecordSize() {\n         return this.recordSize;\n@@ -100,365 +101,357 @@\n         }\n         if (this.currEntry.getRealSize() - this.entryOffset > 2147483647L) {\n             return Integer.MAX_VALUE;\n         }\n         return (int)(this.currEntry.getRealSize() - this.entryOffset);\n     }\n     \n-    public long skip(final long n) throws IOException {\n-        if (n <= 0L || this.isDirectory()) {\n+    public long skip(final long a) throws IOException {\n+        if (a <= 0L || this.isDirectory()) {\n             return 0L;\n         }\n-        final long availableOfInputStream = (long)this.inputStream.available();\n-        final long available = this.currEntry.getRealSize() - this.entryOffset;\n-        final long numToSkip = Math.min(n, available);\n-        long skipped;\n+        final long n = (long)this.inputStream.available();\n+        final long min = Math.min(a, this.currEntry.getRealSize() - this.entryOffset);\n+        long n2;\n         if (!this.currEntry.isSparse()) {\n-            skipped = IOUtils.skip(this.inputStream, numToSkip);\n-            skipped = this.getActuallySkipped(availableOfInputStream, skipped, numToSkip);\n+            n2 = this.getActuallySkipped(n, IOUtils.skip(this.inputStream, min), min);\n         }\n         else {\n-            skipped = this.skipSparse(numToSkip);\n+            n2 = this.skipSparse(min);\n         }\n-        this.count(skipped);\n-        this.entryOffset += skipped;\n-        return skipped;\n+        this.count(n2);\n+        this.entryOffset += n2;\n+        return n2;\n     }\n     \n     private long skipSparse(final long n) throws IOException {\n         if (this.sparseInputStreams == null || this.sparseInputStreams.isEmpty()) {\n             return this.inputStream.skip(n);\n         }\n-        long bytesSkipped = 0L;\n-        while (bytesSkipped < n && this.currentSparseInputStreamIndex < this.sparseInputStreams.size()) {\n-            final InputStream currentInputStream = (InputStream)this.sparseInputStreams.get(this.currentSparseInputStreamIndex);\n-            bytesSkipped += currentInputStream.skip(n - bytesSkipped);\n-            if (bytesSkipped < n) {\n+        long n2 = 0L;\n+        while (n2 < n && this.currentSparseInputStreamIndex < this.sparseInputStreams.size()) {\n+            n2 += ((InputStream)this.sparseInputStreams.get(this.currentSparseInputStreamIndex)).skip(n - n2);\n+            if (n2 < n) {\n                 ++this.currentSparseInputStreamIndex;\n             }\n         }\n-        return bytesSkipped;\n+        return n2;\n     }\n     \n     public boolean markSupported() {\n         return false;\n     }\n     \n-    public synchronized void mark(final int markLimit) {\n+    public synchronized void mark(final int n) {\n     }\n     \n     public synchronized void reset() {\n     }\n     \n     public TarArchiveEntry getNextTarEntry() throws IOException {\n         if (this.isAtEOF()) {\n             return null;\n         }\n         if (this.currEntry != null) {\n             IOUtils.skip((InputStream)this, Long.MAX_VALUE);\n             this.skipRecordPadding();\n         }\n-        final byte[] headerBuf = this.getRecord();\n-        if (headerBuf == null) {\n+        final byte[] record = this.getRecord();\n+        if (record == null) {\n             return this.currEntry = null;\n         }\n         try {\n-            this.currEntry = new TarArchiveEntry(headerBuf, this.zipEncoding, this.lenient);\n+            this.currEntry = new TarArchiveEntry(record, this.zipEncoding, this.lenient);\n         }\n-        catch (final IllegalArgumentException e) {\n-            throw new IOException(\"Error detected parsing the header\", e);\n+        catch (final IllegalArgumentException cause) {\n+            throw new IOException(\"Error detected parsing the header\", cause);\n         }\n         this.entryOffset = 0L;\n         this.entrySize = this.currEntry.getSize();\n         if (this.currEntry.isGNULongLinkEntry()) {\n-            final byte[] longLinkData = this.getLongNameData();\n-            if (longLinkData == null) {\n+            final byte[] longNameData = this.getLongNameData();\n+            if (longNameData == null) {\n                 return null;\n             }\n-            this.currEntry.setLinkName(this.zipEncoding.decode(longLinkData));\n+            this.currEntry.setLinkName(this.zipEncoding.decode(longNameData));\n         }\n         if (this.currEntry.isGNULongNameEntry()) {\n-            final byte[] longNameData = this.getLongNameData();\n-            if (longNameData == null) {\n+            final byte[] longNameData2 = this.getLongNameData();\n+            if (longNameData2 == null) {\n                 return null;\n             }\n-            final String name = this.zipEncoding.decode(longNameData);\n-            this.currEntry.setName(name);\n-            if (this.currEntry.isDirectory() && !name.endsWith(\"/\")) {\n-                this.currEntry.setName(name + \"/\");\n+            final String decode = this.zipEncoding.decode(longNameData2);\n+            this.currEntry.setName(decode);\n+            if (this.currEntry.isDirectory() && !decode.endsWith(\"/\")) {\n+                this.currEntry.setName(decode + \"/\");\n             }\n         }\n         if (this.currEntry.isGlobalPaxHeader()) {\n             this.readGlobalPaxHeaders();\n         }\n         try {\n             if (this.currEntry.isPaxHeader()) {\n                 this.paxHeaders();\n             }\n             else if (!this.globalPaxHeaders.isEmpty()) {\n                 this.applyPaxHeadersToCurrentEntry(this.globalPaxHeaders, this.globalSparseHeaders);\n             }\n         }\n-        catch (final NumberFormatException e2) {\n-            throw new IOException(\"Error detected parsing the pax header\", e2);\n+        catch (final NumberFormatException cause2) {\n+            throw new IOException(\"Error detected parsing the pax header\", cause2);\n         }\n         if (this.currEntry.isOldGNUSparse()) {\n             this.readOldGNUSparse();\n         }\n         this.entrySize = this.currEntry.getSize();\n         return this.currEntry;\n     }\n     \n     private void skipRecordPadding() throws IOException {\n         if (!this.isDirectory() && this.entrySize > 0L && this.entrySize % this.recordSize != 0L) {\n-            final long available = (long)this.inputStream.available();\n-            final long numRecords = this.entrySize / this.recordSize + 1L;\n-            final long padding = numRecords * this.recordSize - this.entrySize;\n-            long skipped = IOUtils.skip(this.inputStream, padding);\n-            skipped = this.getActuallySkipped(available, skipped, padding);\n-            this.count(skipped);\n+            final long n = (long)this.inputStream.available();\n+            final long n2 = (this.entrySize / this.recordSize + 1L) * this.recordSize - this.entrySize;\n+            this.count(this.getActuallySkipped(n, IOUtils.skip(this.inputStream, n2), n2));\n         }\n     }\n     \n-    private long getActuallySkipped(final long available, final long skipped, final long expected) throws IOException {\n-        long actuallySkipped = skipped;\n+    private long getActuallySkipped(final long b, final long a, final long n) throws IOException {\n+        long min = a;\n         if (this.inputStream instanceof FileInputStream) {\n-            actuallySkipped = Math.min(skipped, available);\n+            min = Math.min(a, b);\n         }\n-        if (actuallySkipped != expected) {\n+        if (min != n) {\n             throw new IOException(\"Truncated TAR archive\");\n         }\n-        return actuallySkipped;\n+        return min;\n     }\n     \n     protected byte[] getLongNameData() throws IOException {\n-        final ByteArrayOutputStream longName = new ByteArrayOutputStream();\n-        int length = 0;\n-        while ((length = this.read(this.smallBuf)) >= 0) {\n-            longName.write(this.smallBuf, 0, length);\n+        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+        int read;\n+        while ((read = this.read(this.smallBuf)) >= 0) {\n+            byteArrayOutputStream.write(this.smallBuf, 0, read);\n         }\n         this.getNextEntry();\n         if (this.currEntry == null) {\n             return null;\n         }\n-        byte[] longNameData;\n-        for (longNameData = longName.toByteArray(), length = longNameData.length; length > 0 && longNameData[length - 1] == 0; --length) {}\n-        if (length != longNameData.length) {\n-            final byte[] l = new byte[length];\n-            System.arraycopy(longNameData, 0, l, 0, length);\n-            longNameData = l;\n+        byte[] byteArray;\n+        int length;\n+        for (byteArray = byteArrayOutputStream.toByteArray(), length = byteArray.length; length > 0 && byteArray[length - 1] == 0; --length) {}\n+        if (length != byteArray.length) {\n+            final byte[] array = new byte[length];\n+            System.arraycopy(byteArray, 0, array, 0, length);\n+            byteArray = array;\n         }\n-        return longNameData;\n+        return byteArray;\n     }\n     \n     private byte[] getRecord() throws IOException {\n-        byte[] headerBuf = this.readRecord();\n-        this.setAtEOF(this.isEOFRecord(headerBuf));\n-        if (this.isAtEOF() && headerBuf != null) {\n+        byte[] record = this.readRecord();\n+        this.setAtEOF(this.isEOFRecord(record));\n+        if (this.isAtEOF() && record != null) {\n             this.tryToConsumeSecondEOFRecord();\n             this.consumeRemainderOfLastBlock();\n-            headerBuf = null;\n+            record = null;\n         }\n-        return headerBuf;\n+        return record;\n     }\n     \n-    protected boolean isEOFRecord(final byte[] record) {\n-        return record == null || ArchiveUtils.isArrayZero(record, this.recordSize);\n+    protected boolean isEOFRecord(final byte[] array) {\n+        return array == null || ArchiveUtils.isArrayZero(array, this.recordSize);\n     }\n     \n     protected byte[] readRecord() throws IOException {\n-        final int readNow = IOUtils.readFully(this.inputStream, this.recordBuffer);\n-        this.count(readNow);\n-        if (readNow != this.recordSize) {\n+        final int fully = IOUtils.readFully(this.inputStream, this.recordBuffer);\n+        this.count(fully);\n+        if (fully != this.recordSize) {\n             return null;\n         }\n         return this.recordBuffer;\n     }\n     \n     private void readGlobalPaxHeaders() throws IOException {\n         this.globalPaxHeaders = TarUtils.parsePaxHeaders((InputStream)this, (List)this.globalSparseHeaders, (Map)this.globalPaxHeaders, this.entrySize);\n         this.getNextEntry();\n         if (this.currEntry == null) {\n             throw new IOException(\"Error detected parsing the pax header\");\n         }\n     }\n     \n     private void paxHeaders() throws IOException {\n-        List<TarArchiveStructSparse> sparseHeaders = new ArrayList<TarArchiveStructSparse>();\n-        final Map<String, String> headers = TarUtils.parsePaxHeaders((InputStream)this, (List)sparseHeaders, (Map)this.globalPaxHeaders, this.entrySize);\n-        if (headers.containsKey(\"GNU.sparse.map\")) {\n-            sparseHeaders = new ArrayList<TarArchiveStructSparse>(TarUtils.parseFromPAX01SparseHeaders((String)headers.get(\"GNU.sparse.map\")));\n+        ArrayList list = new ArrayList();\n+        final Map paxHeaders = TarUtils.parsePaxHeaders((InputStream)this, (List)list, (Map)this.globalPaxHeaders, this.entrySize);\n+        if (paxHeaders.containsKey(\"GNU.sparse.map\")) {\n+            list = new ArrayList(TarUtils.parseFromPAX01SparseHeaders((String)paxHeaders.get(\"GNU.sparse.map\")));\n         }\n         this.getNextEntry();\n         if (this.currEntry == null) {\n             throw new IOException(\"premature end of tar archive. Didn't find any entry after PAX header.\");\n         }\n-        this.applyPaxHeadersToCurrentEntry(headers, sparseHeaders);\n+        this.applyPaxHeadersToCurrentEntry(paxHeaders, list);\n         if (this.currEntry.isPaxGNU1XSparse()) {\n-            sparseHeaders = TarUtils.parsePAX1XSparseHeaders(this.inputStream, this.recordSize);\n-            this.currEntry.setSparseHeaders((List)sparseHeaders);\n+            this.currEntry.setSparseHeaders(TarUtils.parsePAX1XSparseHeaders(this.inputStream, this.recordSize));\n         }\n         this.buildSparseInputStreams();\n     }\n     \n-    private void applyPaxHeadersToCurrentEntry(final Map<String, String> headers, final List<TarArchiveStructSparse> sparseHeaders) throws IOException {\n-        this.currEntry.updateEntryFromPaxHeaders((Map)headers);\n+    private void applyPaxHeadersToCurrentEntry(final Map<String, String> map, final List<TarArchiveStructSparse> sparseHeaders) throws IOException {\n+        this.currEntry.updateEntryFromPaxHeaders((Map)map);\n         this.currEntry.setSparseHeaders((List)sparseHeaders);\n     }\n     \n     private void readOldGNUSparse() throws IOException {\n         if (this.currEntry.isExtended()) {\n-            TarArchiveSparseEntry entry;\n+            TarArchiveSparseEntry tarArchiveSparseEntry;\n             do {\n-                final byte[] headerBuf = this.getRecord();\n-                if (headerBuf == null) {\n+                final byte[] record = this.getRecord();\n+                if (record == null) {\n                     throw new IOException(\"premature end of tar archive. Didn't find extended_header after header with extended flag.\");\n                 }\n-                entry = new TarArchiveSparseEntry(headerBuf);\n-                this.currEntry.getSparseHeaders().addAll(entry.getSparseHeaders());\n-            } while (entry.isExtended());\n+                tarArchiveSparseEntry = new TarArchiveSparseEntry(record);\n+                this.currEntry.getSparseHeaders().addAll(tarArchiveSparseEntry.getSparseHeaders());\n+            } while (tarArchiveSparseEntry.isExtended());\n         }\n         this.buildSparseInputStreams();\n     }\n     \n     private boolean isDirectory() {\n         return this.currEntry != null && this.currEntry.isDirectory();\n     }\n     \n     public ArchiveEntry getNextEntry() throws IOException {\n         return (ArchiveEntry)this.getNextTarEntry();\n     }\n     \n     private void tryToConsumeSecondEOFRecord() throws IOException {\n-        boolean shouldReset = true;\n-        final boolean marked = this.inputStream.markSupported();\n-        if (marked) {\n+        boolean b = true;\n+        final boolean markSupported = this.inputStream.markSupported();\n+        if (markSupported) {\n             this.inputStream.mark(this.recordSize);\n         }\n         try {\n-            shouldReset = !this.isEOFRecord(this.readRecord());\n+            b = !this.isEOFRecord(this.readRecord());\n         }\n         finally {\n-            if (shouldReset && marked) {\n+            if (b && markSupported) {\n                 this.pushedBackBytes((long)this.recordSize);\n                 this.inputStream.reset();\n             }\n         }\n     }\n     \n-    public int read(final byte[] buf, final int offset, int numToRead) throws IOException {\n-        if (numToRead == 0) {\n+    public int read(final byte[] b, final int off, int min) throws IOException {\n+        if (min == 0) {\n             return 0;\n         }\n-        int totalRead = 0;\n         if (this.isAtEOF() || this.isDirectory()) {\n             return -1;\n         }\n         if (this.currEntry == null) {\n             throw new IllegalStateException(\"No current tar entry\");\n         }\n         if (this.entryOffset >= this.currEntry.getRealSize()) {\n             return -1;\n         }\n-        numToRead = Math.min(numToRead, this.available());\n+        min = Math.min(min, this.available());\n+        int n;\n         if (this.currEntry.isSparse()) {\n-            totalRead = this.readSparse(buf, offset, numToRead);\n+            n = this.readSparse(b, off, min);\n         }\n         else {\n-            totalRead = this.inputStream.read(buf, offset, numToRead);\n+            n = this.inputStream.read(b, off, min);\n         }\n-        if (totalRead == -1) {\n-            if (numToRead > 0) {\n+        if (n == -1) {\n+            if (min > 0) {\n                 throw new IOException(\"Truncated TAR archive\");\n             }\n             this.setAtEOF(true);\n         }\n         else {\n-            this.count(totalRead);\n-            this.entryOffset += totalRead;\n+            this.count(n);\n+            this.entryOffset += n;\n         }\n-        return totalRead;\n+        return n;\n     }\n     \n-    private int readSparse(final byte[] buf, final int offset, final int numToRead) throws IOException {\n+    private int readSparse(final byte[] array, final int n, final int n2) throws IOException {\n         if (this.sparseInputStreams == null || this.sparseInputStreams.isEmpty()) {\n-            return this.inputStream.read(buf, offset, numToRead);\n+            return this.inputStream.read(array, n, n2);\n         }\n         if (this.currentSparseInputStreamIndex >= this.sparseInputStreams.size()) {\n             return -1;\n         }\n-        final InputStream currentInputStream = (InputStream)this.sparseInputStreams.get(this.currentSparseInputStreamIndex);\n-        final int readLen = currentInputStream.read(buf, offset, numToRead);\n+        final int read = ((InputStream)this.sparseInputStreams.get(this.currentSparseInputStreamIndex)).read(array, n, n2);\n         if (this.currentSparseInputStreamIndex == this.sparseInputStreams.size() - 1) {\n-            return readLen;\n+            return read;\n         }\n-        if (readLen == -1) {\n+        if (read == -1) {\n             ++this.currentSparseInputStreamIndex;\n-            return this.readSparse(buf, offset, numToRead);\n+            return this.readSparse(array, n, n2);\n         }\n-        if (readLen >= numToRead) {\n-            return readLen;\n+        if (read >= n2) {\n+            return read;\n         }\n         ++this.currentSparseInputStreamIndex;\n-        final int readLenOfNext = this.readSparse(buf, offset + readLen, numToRead - readLen);\n-        if (readLenOfNext == -1) {\n-            return readLen;\n+        final int sparse = this.readSparse(array, n + read, n2 - read);\n+        if (sparse == -1) {\n+            return read;\n         }\n-        return readLen + readLenOfNext;\n+        return read + sparse;\n     }\n     \n-    public boolean canReadEntryData(final ArchiveEntry ae) {\n-        return ae instanceof TarArchiveEntry;\n+    public boolean canReadEntryData(final ArchiveEntry archiveEntry) {\n+        return archiveEntry instanceof TarArchiveEntry;\n     }\n     \n     public TarArchiveEntry getCurrentEntry() {\n         return this.currEntry;\n     }\n     \n-    protected final void setCurrentEntry(final TarArchiveEntry e) {\n-        this.currEntry = e;\n+    protected final void setCurrentEntry(final TarArchiveEntry currEntry) {\n+        this.currEntry = currEntry;\n     }\n     \n     protected final boolean isAtEOF() {\n         return this.hasHitEOF;\n     }\n     \n-    protected final void setAtEOF(final boolean b) {\n-        this.hasHitEOF = b;\n+    protected final void setAtEOF(final boolean hasHitEOF) {\n+        this.hasHitEOF = hasHitEOF;\n     }\n     \n     private void consumeRemainderOfLastBlock() throws IOException {\n-        final long bytesReadOfLastBlock = this.getBytesRead() % this.blockSize;\n-        if (bytesReadOfLastBlock > 0L) {\n-            final long skipped = IOUtils.skip(this.inputStream, (long)this.blockSize - bytesReadOfLastBlock);\n-            this.count(skipped);\n+        final long n = this.getBytesRead() % this.blockSize;\n+        if (n > 0L) {\n+            this.count(IOUtils.skip(this.inputStream, (long)this.blockSize - n));\n         }\n     }\n     \n-    public static boolean matches(final byte[] signature, final int length) {\n-        return length >= 265 && ((ArchiveUtils.matchAsciiBuffer(\"ustar\\u0000\", signature, 257, 6) && ArchiveUtils.matchAsciiBuffer(\"00\", signature, 263, 2)) || (ArchiveUtils.matchAsciiBuffer(\"ustar \", signature, 257, 6) && (ArchiveUtils.matchAsciiBuffer(\" \\u0000\", signature, 263, 2) || ArchiveUtils.matchAsciiBuffer(\"0\\u0000\", signature, 263, 2))) || (ArchiveUtils.matchAsciiBuffer(\"ustar\\u0000\", signature, 257, 6) && ArchiveUtils.matchAsciiBuffer(\"\\u0000\\u0000\", signature, 263, 2)));\n+    public static boolean matches(final byte[] array, final int n) {\n+        return n >= 265 && ((ArchiveUtils.matchAsciiBuffer(\"ustar\\u0000\", array, 257, 6) && ArchiveUtils.matchAsciiBuffer(\"00\", array, 263, 2)) || (ArchiveUtils.matchAsciiBuffer(\"ustar \", array, 257, 6) && (ArchiveUtils.matchAsciiBuffer(\" \\u0000\", array, 263, 2) || ArchiveUtils.matchAsciiBuffer(\"0\\u0000\", array, 263, 2))) || (ArchiveUtils.matchAsciiBuffer(\"ustar\\u0000\", array, 257, 6) && ArchiveUtils.matchAsciiBuffer(\"\\u0000\\u0000\", array, 263, 2)));\n     }\n     \n     private void buildSparseInputStreams() throws IOException {\n         this.currentSparseInputStreamIndex = -1;\n         this.sparseInputStreams = new ArrayList<InputStream>();\n-        final List<TarArchiveStructSparse> sparseHeaders = this.currEntry.getOrderedSparseHeaders();\n-        final InputStream zeroInputStream = (InputStream)new TarArchiveSparseZeroInputStream();\n-        long offset = 0L;\n-        for (final TarArchiveStructSparse sparseHeader : sparseHeaders) {\n-            final long zeroBlockSize = sparseHeader.getOffset() - offset;\n-            if (zeroBlockSize < 0L) {\n+        final List orderedSparseHeaders = this.currEntry.getOrderedSparseHeaders();\n+        final TarArchiveSparseZeroInputStream tarArchiveSparseZeroInputStream = new TarArchiveSparseZeroInputStream();\n+        long n = 0L;\n+        for (final TarArchiveStructSparse tarArchiveStructSparse : orderedSparseHeaders) {\n+            final long n2 = tarArchiveStructSparse.getOffset() - n;\n+            if (n2 < 0L) {\n                 throw new IOException(\"Corrupted struct sparse detected\");\n             }\n-            if (zeroBlockSize > 0L) {\n-                this.sparseInputStreams.add((InputStream)new BoundedInputStream(zeroInputStream, sparseHeader.getOffset() - offset));\n+            if (n2 > 0L) {\n+                this.sparseInputStreams.add((InputStream)new BoundedInputStream((InputStream)tarArchiveSparseZeroInputStream, tarArchiveStructSparse.getOffset() - n));\n             }\n-            if (sparseHeader.getNumbytes() > 0L) {\n-                this.sparseInputStreams.add((InputStream)new BoundedInputStream(this.inputStream, sparseHeader.getNumbytes()));\n+            if (tarArchiveStructSparse.getNumbytes() > 0L) {\n+                this.sparseInputStreams.add((InputStream)new BoundedInputStream(this.inputStream, tarArchiveStructSparse.getNumbytes()));\n             }\n-            offset = sparseHeader.getOffset() + sparseHeader.getNumbytes();\n+            n = tarArchiveStructSparse.getOffset() + tarArchiveStructSparse.getNumbytes();\n         }\n         if (!this.sparseInputStreams.isEmpty()) {\n             this.currentSparseInputStreamIndex = 0;\n         }\n     }\n }\n"}]}
