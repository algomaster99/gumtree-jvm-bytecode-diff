{"diffoscope-json-version": 1, "source1": "first/ByteOrderMark.class", "source2": "second/ByteOrderMark.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,27 +1,35 @@\n \n package org.apache.commons.io;\n \n-import java.nio.charset.StandardCharsets;\n import java.util.Locale;\n import java.util.Objects;\n+import java.nio.charset.StandardCharsets;\n import java.io.Serializable;\n \n public class ByteOrderMark implements Serializable\n {\n     private static final long serialVersionUID = 1L;\n     public static final ByteOrderMark UTF_8;\n     public static final ByteOrderMark UTF_16BE;\n     public static final ByteOrderMark UTF_16LE;\n     public static final ByteOrderMark UTF_32BE;\n     public static final ByteOrderMark UTF_32LE;\n     public static final char UTF_BOM = '\\ufeff';\n     private final String charsetName;\n     private final int[] bytes;\n     \n+    static {\n+        UTF_8 = new ByteOrderMark(StandardCharsets.UTF_8.name(), new int[] { 239, 187, 191 });\n+        UTF_16BE = new ByteOrderMark(StandardCharsets.UTF_16BE.name(), new int[] { 254, 255 });\n+        UTF_16LE = new ByteOrderMark(StandardCharsets.UTF_16LE.name(), new int[] { 255, 254 });\n+        UTF_32BE = new ByteOrderMark(\"UTF-32BE\", new int[] { 0, 0, 254, 255 });\n+        UTF_32LE = new ByteOrderMark(\"UTF-32LE\", new int[] { 255, 254, 0, 0 });\n+    }\n+    \n     public ByteOrderMark(final String charsetName, final int... bytes) {\n         Objects.requireNonNull(charsetName, \"charsetName\");\n         Objects.requireNonNull(bytes, \"bytes\");\n         if (charsetName.isEmpty()) {\n             throw new IllegalArgumentException(\"No charsetName specified\");\n         }\n         if (bytes.length == 0) {\n@@ -63,15 +71,17 @@\n     public String getCharsetName() {\n         return this.charsetName;\n     }\n     \n     @Override\n     public int hashCode() {\n         int hashCode = this.getClass().hashCode();\n-        for (final int b : this.bytes) {\n+        int[] bytes;\n+        for (int length = (bytes = this.bytes).length, i = 0; i < length; ++i) {\n+            final int b = bytes[i];\n             hashCode += b;\n         }\n         return hashCode;\n     }\n     \n     public int length() {\n         return this.bytes.length;\n@@ -90,16 +100,8 @@\n             }\n             builder.append(\"0x\");\n             builder.append(Integer.toHexString(0xFF & this.bytes[i]).toUpperCase(Locale.ROOT));\n         }\n         builder.append(']');\n         return builder.toString();\n     }\n-    \n-    static {\n-        UTF_8 = new ByteOrderMark(StandardCharsets.UTF_8.name(), new int[] { 239, 187, 191 });\n-        UTF_16BE = new ByteOrderMark(StandardCharsets.UTF_16BE.name(), new int[] { 254, 255 });\n-        UTF_16LE = new ByteOrderMark(StandardCharsets.UTF_16LE.name(), new int[] { 255, 254 });\n-        UTF_32BE = new ByteOrderMark(\"UTF-32BE\", new int[] { 0, 0, 254, 255 });\n-        UTF_32LE = new ByteOrderMark(\"UTF-32LE\", new int[] { 255, 254, 0, 0 });\n-    }\n }\n"}]}
