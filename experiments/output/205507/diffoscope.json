{"diffoscope-json-version": 1, "source1": "first/BaseHierarchicalConfiguration.class", "source2": "second/BaseHierarchicalConfiguration.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -25,256 +25,255 @@\n {\n     private final EventListener<ConfigurationEvent> changeListener;\n     \n     public BaseHierarchicalConfiguration() {\n         this((HierarchicalConfiguration<ImmutableNode>)(HierarchicalConfiguration)null);\n     }\n     \n-    public BaseHierarchicalConfiguration(final HierarchicalConfiguration<ImmutableNode> c) {\n-        this(createNodeModel(c));\n+    public BaseHierarchicalConfiguration(final HierarchicalConfiguration<ImmutableNode> hierarchicalConfiguration) {\n+        this(createNodeModel(hierarchicalConfiguration));\n     }\n     \n-    protected BaseHierarchicalConfiguration(final NodeModel<ImmutableNode> model) {\n-        super((NodeModel)model);\n+    protected BaseHierarchicalConfiguration(final NodeModel<ImmutableNode> nodeModel) {\n+        super((NodeModel)nodeModel);\n         this.changeListener = this.createChangeListener();\n     }\n     \n     public InMemoryNodeModel getNodeModel() {\n         return (InMemoryNodeModel)super.getNodeModel();\n     }\n     \n-    public Configuration subset(final String prefix) {\n+    public Configuration subset(final String s) {\n         this.beginRead(false);\n         try {\n-            final List<QueryResult<ImmutableNode>> results = this.fetchNodeList(prefix);\n-            if (results.isEmpty()) {\n+            final List fetchNodeList = this.fetchNodeList(s);\n+            if (fetchNodeList.isEmpty()) {\n                 return (Configuration)new BaseHierarchicalConfiguration();\n             }\n-            final BaseHierarchicalConfiguration parent = this;\n-            final BaseHierarchicalConfiguration result = (BaseHierarchicalConfiguration)new BaseHierarchicalConfiguration.BaseHierarchicalConfiguration$1(this, parent);\n-            result.getModel().setRootNode((Object)this.createSubsetRootNode(results));\n-            if (result.isEmpty()) {\n+            final BaseHierarchicalConfiguration.BaseHierarchicalConfiguration$1 baseHierarchicalConfiguration$1 = new BaseHierarchicalConfiguration.BaseHierarchicalConfiguration$1(this, this);\n+            ((BaseHierarchicalConfiguration)baseHierarchicalConfiguration$1).getModel().setRootNode((Object)this.createSubsetRootNode(fetchNodeList));\n+            if (((BaseHierarchicalConfiguration)baseHierarchicalConfiguration$1).isEmpty()) {\n                 return (Configuration)new BaseHierarchicalConfiguration();\n             }\n-            result.setSynchronizer(this.getSynchronizer());\n-            return (Configuration)result;\n+            ((BaseHierarchicalConfiguration)baseHierarchicalConfiguration$1).setSynchronizer(this.getSynchronizer());\n+            return (Configuration)baseHierarchicalConfiguration$1;\n         }\n         finally {\n             this.endRead();\n         }\n     }\n     \n-    private ImmutableNode createSubsetRootNode(final Collection<QueryResult<ImmutableNode>> results) {\n+    private ImmutableNode createSubsetRootNode(final Collection<QueryResult<ImmutableNode>> collection) {\n         final ImmutableNode.Builder builder = new ImmutableNode.Builder();\n         Object value = null;\n-        int valueCount = 0;\n-        for (final QueryResult<ImmutableNode> result : results) {\n-            if (result.isAttributeResult()) {\n-                builder.addAttribute(result.getAttributeName(), result.getAttributeValue(this.getModel().getNodeHandler()));\n+        int n = 0;\n+        for (final QueryResult queryResult : collection) {\n+            if (queryResult.isAttributeResult()) {\n+                builder.addAttribute(queryResult.getAttributeName(), queryResult.getAttributeValue(this.getModel().getNodeHandler()));\n             }\n             else {\n-                if (((ImmutableNode)result.getNode()).getValue() != null) {\n-                    value = ((ImmutableNode)result.getNode()).getValue();\n-                    ++valueCount;\n+                if (((ImmutableNode)queryResult.getNode()).getValue() != null) {\n+                    value = ((ImmutableNode)queryResult.getNode()).getValue();\n+                    ++n;\n                 }\n-                builder.addChildren((Collection)((ImmutableNode)result.getNode()).getChildren());\n-                builder.addAttributes(((ImmutableNode)result.getNode()).getAttributes());\n+                builder.addChildren((Collection)((ImmutableNode)queryResult.getNode()).getChildren());\n+                builder.addAttributes(((ImmutableNode)queryResult.getNode()).getAttributes());\n             }\n         }\n-        if (valueCount == 1) {\n+        if (n == 1) {\n             builder.value(value);\n         }\n         return builder.create();\n     }\n     \n-    public HierarchicalConfiguration<ImmutableNode> configurationAt(final String key, final boolean supportUpdates) {\n+    public HierarchicalConfiguration<ImmutableNode> configurationAt(final String s, final boolean b) {\n         this.beginRead(false);\n         try {\n-            return (HierarchicalConfiguration<ImmutableNode>)(supportUpdates ? this.createConnectedSubConfiguration(key) : this.createIndependentSubConfiguration(key));\n+            return (HierarchicalConfiguration<ImmutableNode>)(b ? this.createConnectedSubConfiguration(s) : this.createIndependentSubConfiguration(s));\n         }\n         finally {\n             this.endRead();\n         }\n     }\n     \n     protected InMemoryNodeModel getSubConfigurationParentModel() {\n         return (InMemoryNodeModel)this.getModel();\n     }\n     \n-    protected NodeSelector getSubConfigurationNodeSelector(final String key) {\n-        return new NodeSelector(key);\n+    protected NodeSelector getSubConfigurationNodeSelector(final String s) {\n+        return new NodeSelector(s);\n     }\n     \n-    protected SubnodeConfiguration createSubConfigurationForTrackedNode(final NodeSelector selector, final InMemoryNodeModelSupport parentModelSupport) {\n-        final SubnodeConfiguration subConfig = new SubnodeConfiguration(this, new TrackedNodeModel(parentModelSupport, selector, true));\n-        this.initSubConfigurationForThisParent(subConfig);\n-        return subConfig;\n+    protected SubnodeConfiguration createSubConfigurationForTrackedNode(final NodeSelector nodeSelector, final InMemoryNodeModelSupport inMemoryNodeModelSupport) {\n+        final SubnodeConfiguration subnodeConfiguration = new SubnodeConfiguration(this, new TrackedNodeModel(inMemoryNodeModelSupport, nodeSelector, true));\n+        this.initSubConfigurationForThisParent(subnodeConfiguration);\n+        return subnodeConfiguration;\n     }\n     \n-    protected void initSubConfigurationForThisParent(final SubnodeConfiguration subConfig) {\n-        this.initSubConfiguration((BaseHierarchicalConfiguration)subConfig);\n-        subConfig.addEventListener(ConfigurationEvent.ANY, (EventListener)this.changeListener);\n+    protected void initSubConfigurationForThisParent(final SubnodeConfiguration subnodeConfiguration) {\n+        this.initSubConfiguration((BaseHierarchicalConfiguration)subnodeConfiguration);\n+        subnodeConfiguration.addEventListener(ConfigurationEvent.ANY, (EventListener)this.changeListener);\n     }\n     \n-    private BaseHierarchicalConfiguration createConnectedSubConfiguration(final String key) {\n-        final NodeSelector selector = this.getSubConfigurationNodeSelector(key);\n-        this.getSubConfigurationParentModel().trackNode(selector, (NodeKeyResolver)this);\n-        return (BaseHierarchicalConfiguration)this.createSubConfigurationForTrackedNode(selector, (InMemoryNodeModelSupport)this);\n+    private BaseHierarchicalConfiguration createConnectedSubConfiguration(final String s) {\n+        final NodeSelector subConfigurationNodeSelector = this.getSubConfigurationNodeSelector(s);\n+        this.getSubConfigurationParentModel().trackNode(subConfigurationNodeSelector, (NodeKeyResolver)this);\n+        return (BaseHierarchicalConfiguration)this.createSubConfigurationForTrackedNode(subConfigurationNodeSelector, (InMemoryNodeModelSupport)this);\n     }\n     \n-    private List<HierarchicalConfiguration<ImmutableNode>> createConnectedSubConfigurations(final InMemoryNodeModelSupport parentModelSupport, final Collection<NodeSelector> selectors) {\n-        final List<HierarchicalConfiguration<ImmutableNode>> configs = new ArrayList<HierarchicalConfiguration<ImmutableNode>>(selectors.size());\n-        for (final NodeSelector selector : selectors) {\n-            configs.add((HierarchicalConfiguration<ImmutableNode>)this.createSubConfigurationForTrackedNode(selector, parentModelSupport));\n+    private List<HierarchicalConfiguration<ImmutableNode>> createConnectedSubConfigurations(final InMemoryNodeModelSupport inMemoryNodeModelSupport, final Collection<NodeSelector> collection) {\n+        final ArrayList list = new ArrayList(collection.size());\n+        final Iterator iterator = collection.iterator();\n+        while (iterator.hasNext()) {\n+            list.add(this.createSubConfigurationForTrackedNode((NodeSelector)iterator.next(), inMemoryNodeModelSupport));\n         }\n-        return configs;\n+        return list;\n     }\n     \n-    private BaseHierarchicalConfiguration createIndependentSubConfiguration(final String key) {\n-        final List<ImmutableNode> targetNodes = this.fetchFilteredNodeResults(key);\n-        final int size = targetNodes.size();\n+    private BaseHierarchicalConfiguration createIndependentSubConfiguration(final String s) {\n+        final List<ImmutableNode> fetchFilteredNodeResults = this.fetchFilteredNodeResults(s);\n+        final int size = fetchFilteredNodeResults.size();\n         if (size != 1) {\n-            throw new ConfigurationRuntimeException(\"Passed in key must select exactly one node (found %,d): %s\", new Object[] { Integer.valueOf(size), key });\n+            throw new ConfigurationRuntimeException(\"Passed in key must select exactly one node (found %,d): %s\", new Object[] { Integer.valueOf(size), s });\n         }\n-        final BaseHierarchicalConfiguration sub = new BaseHierarchicalConfiguration((NodeModel<ImmutableNode>)new InMemoryNodeModel((ImmutableNode)targetNodes.get(0)));\n-        this.initSubConfiguration(sub);\n-        return sub;\n+        final BaseHierarchicalConfiguration baseHierarchicalConfiguration = new BaseHierarchicalConfiguration((NodeModel<ImmutableNode>)new InMemoryNodeModel((ImmutableNode)fetchFilteredNodeResults.get(0)));\n+        this.initSubConfiguration(baseHierarchicalConfiguration);\n+        return baseHierarchicalConfiguration;\n     }\n     \n-    private BaseHierarchicalConfiguration createIndependentSubConfigurationForNode(final ImmutableNode node) {\n-        final BaseHierarchicalConfiguration sub = new BaseHierarchicalConfiguration((NodeModel<ImmutableNode>)new InMemoryNodeModel(node));\n-        this.initSubConfiguration(sub);\n-        return sub;\n+    private BaseHierarchicalConfiguration createIndependentSubConfigurationForNode(final ImmutableNode immutableNode) {\n+        final BaseHierarchicalConfiguration baseHierarchicalConfiguration = new BaseHierarchicalConfiguration((NodeModel<ImmutableNode>)new InMemoryNodeModel(immutableNode));\n+        this.initSubConfiguration(baseHierarchicalConfiguration);\n+        return baseHierarchicalConfiguration;\n     }\n     \n-    private List<ImmutableNode> fetchFilteredNodeResults(final String key) {\n-        final NodeHandler<ImmutableNode> handler = (NodeHandler<ImmutableNode>)this.getModel().getNodeHandler();\n-        return this.resolveNodeKey(handler.getRootNode(), key, (NodeHandler)handler);\n+    private List<ImmutableNode> fetchFilteredNodeResults(final String s) {\n+        final NodeHandler nodeHandler = this.getModel().getNodeHandler();\n+        return this.resolveNodeKey(nodeHandler.getRootNode(), s, nodeHandler);\n     }\n     \n-    public ImmutableHierarchicalConfiguration immutableConfigurationAt(final String key, final boolean supportUpdates) {\n-        return ConfigurationUtils.unmodifiableConfiguration((HierarchicalConfiguration)this.configurationAt(key, supportUpdates));\n+    public ImmutableHierarchicalConfiguration immutableConfigurationAt(final String s, final boolean b) {\n+        return ConfigurationUtils.unmodifiableConfiguration((HierarchicalConfiguration)this.configurationAt(s, b));\n     }\n     \n-    public HierarchicalConfiguration<ImmutableNode> configurationAt(final String key) {\n-        return this.configurationAt(key, false);\n+    public HierarchicalConfiguration<ImmutableNode> configurationAt(final String s) {\n+        return this.configurationAt(s, false);\n     }\n     \n-    public ImmutableHierarchicalConfiguration immutableConfigurationAt(final String key) {\n-        return ConfigurationUtils.unmodifiableConfiguration((HierarchicalConfiguration)this.configurationAt(key));\n+    public ImmutableHierarchicalConfiguration immutableConfigurationAt(final String s) {\n+        return ConfigurationUtils.unmodifiableConfiguration((HierarchicalConfiguration)this.configurationAt(s));\n     }\n     \n-    public List<HierarchicalConfiguration<ImmutableNode>> configurationsAt(final String key) {\n+    public List<HierarchicalConfiguration<ImmutableNode>> configurationsAt(final String s) {\n         this.beginRead(false);\n-        List<ImmutableNode> nodes;\n+        List<ImmutableNode> fetchFilteredNodeResults;\n         try {\n-            nodes = this.fetchFilteredNodeResults(key);\n+            fetchFilteredNodeResults = this.fetchFilteredNodeResults(s);\n         }\n         finally {\n             this.endRead();\n         }\n-        final List<HierarchicalConfiguration<ImmutableNode>> results = new ArrayList<HierarchicalConfiguration<ImmutableNode>>(nodes.size());\n-        for (final ImmutableNode node : nodes) {\n-            final BaseHierarchicalConfiguration sub = this.createIndependentSubConfigurationForNode(node);\n-            results.add((HierarchicalConfiguration<ImmutableNode>)sub);\n+        final ArrayList list = new ArrayList(fetchFilteredNodeResults.size());\n+        final Iterator iterator = fetchFilteredNodeResults.iterator();\n+        while (iterator.hasNext()) {\n+            list.add((Object)this.createIndependentSubConfigurationForNode((ImmutableNode)iterator.next()));\n         }\n-        return results;\n+        return (List<HierarchicalConfiguration<ImmutableNode>>)list;\n     }\n     \n-    public List<HierarchicalConfiguration<ImmutableNode>> configurationsAt(final String key, final boolean supportUpdates) {\n-        if (!supportUpdates) {\n-            return this.configurationsAt(key);\n+    public List<HierarchicalConfiguration<ImmutableNode>> configurationsAt(final String s, final boolean b) {\n+        if (!b) {\n+            return this.configurationsAt(s);\n         }\n         this.beginRead(false);\n-        InMemoryNodeModel parentModel;\n+        InMemoryNodeModel subConfigurationParentModel;\n         try {\n-            parentModel = this.getSubConfigurationParentModel();\n+            subConfigurationParentModel = this.getSubConfigurationParentModel();\n         }\n         finally {\n             this.endRead();\n         }\n-        final Collection<NodeSelector> selectors = parentModel.selectAndTrackNodes(key, (NodeKeyResolver)this);\n-        return this.createConnectedSubConfigurations((InMemoryNodeModelSupport)this, selectors);\n+        return this.createConnectedSubConfigurations(this, (Collection<NodeSelector>)subConfigurationParentModel.selectAndTrackNodes(s, (NodeKeyResolver)this));\n     }\n     \n-    public List<ImmutableHierarchicalConfiguration> immutableConfigurationsAt(final String key) {\n-        return toImmutable(this.configurationsAt(key));\n+    public List<ImmutableHierarchicalConfiguration> immutableConfigurationsAt(final String s) {\n+        return toImmutable(this.configurationsAt(s));\n     }\n     \n-    public List<HierarchicalConfiguration<ImmutableNode>> childConfigurationsAt(final String key) {\n+    public List<HierarchicalConfiguration<ImmutableNode>> childConfigurationsAt(final String s) {\n         this.beginRead(false);\n-        List<ImmutableNode> nodes;\n+        List<ImmutableNode> fetchFilteredNodeResults;\n         try {\n-            nodes = this.fetchFilteredNodeResults(key);\n+            fetchFilteredNodeResults = this.fetchFilteredNodeResults(s);\n         }\n         finally {\n             this.endRead();\n         }\n-        if (nodes.size() != 1) {\n+        if (fetchFilteredNodeResults.size() != 1) {\n             return Collections.emptyList();\n         }\n-        final ImmutableNode parent = (ImmutableNode)nodes.get(0);\n-        final List<HierarchicalConfiguration<ImmutableNode>> subs = new ArrayList<HierarchicalConfiguration<ImmutableNode>>(parent.getChildren().size());\n-        for (final ImmutableNode node : parent.getChildren()) {\n-            subs.add((HierarchicalConfiguration<ImmutableNode>)this.createIndependentSubConfigurationForNode(node));\n+        final ImmutableNode immutableNode = (ImmutableNode)fetchFilteredNodeResults.get(0);\n+        final ArrayList list = new ArrayList(immutableNode.getChildren().size());\n+        final Iterator iterator = immutableNode.getChildren().iterator();\n+        while (iterator.hasNext()) {\n+            list.add((Object)this.createIndependentSubConfigurationForNode((ImmutableNode)iterator.next()));\n         }\n-        return subs;\n+        return (List<HierarchicalConfiguration<ImmutableNode>>)list;\n     }\n     \n-    public List<HierarchicalConfiguration<ImmutableNode>> childConfigurationsAt(final String key, final boolean supportUpdates) {\n-        if (!supportUpdates) {\n-            return this.childConfigurationsAt(key);\n+    public List<HierarchicalConfiguration<ImmutableNode>> childConfigurationsAt(final String s, final boolean b) {\n+        if (!b) {\n+            return this.childConfigurationsAt(s);\n         }\n-        final InMemoryNodeModel parentModel = this.getSubConfigurationParentModel();\n-        return this.createConnectedSubConfigurations(this, (Collection<NodeSelector>)parentModel.trackChildNodes(key, (NodeKeyResolver)this));\n+        return this.createConnectedSubConfigurations(this, (Collection<NodeSelector>)this.getSubConfigurationParentModel().trackChildNodes(s, (NodeKeyResolver)this));\n     }\n     \n-    public List<ImmutableHierarchicalConfiguration> immutableChildConfigurationsAt(final String key) {\n-        return toImmutable(this.childConfigurationsAt(key));\n+    public List<ImmutableHierarchicalConfiguration> immutableChildConfigurationsAt(final String s) {\n+        return toImmutable(this.childConfigurationsAt(s));\n     }\n     \n-    protected void subnodeConfigurationChanged(final ConfigurationEvent event) {\n-        this.fireEvent(ConfigurationEvent.SUBNODE_CHANGED, (String)null, (Object)event, event.isBeforeUpdate());\n+    protected void subnodeConfigurationChanged(final ConfigurationEvent configurationEvent) {\n+        this.fireEvent(ConfigurationEvent.SUBNODE_CHANGED, (String)null, (Object)configurationEvent, configurationEvent.isBeforeUpdate());\n     }\n     \n-    private void initSubConfiguration(final BaseHierarchicalConfiguration sub) {\n-        sub.setSynchronizer(this.getSynchronizer());\n-        sub.setExpressionEngine(this.getExpressionEngine());\n-        sub.setListDelimiterHandler(this.getListDelimiterHandler());\n-        sub.setThrowExceptionOnMissing(this.isThrowExceptionOnMissing());\n-        sub.getInterpolator().setParentInterpolator(this.getInterpolator());\n+    private void initSubConfiguration(final BaseHierarchicalConfiguration baseHierarchicalConfiguration) {\n+        baseHierarchicalConfiguration.setSynchronizer(this.getSynchronizer());\n+        baseHierarchicalConfiguration.setExpressionEngine(this.getExpressionEngine());\n+        baseHierarchicalConfiguration.setListDelimiterHandler(this.getListDelimiterHandler());\n+        baseHierarchicalConfiguration.setThrowExceptionOnMissing(this.isThrowExceptionOnMissing());\n+        baseHierarchicalConfiguration.getInterpolator().setParentInterpolator(this.getInterpolator());\n     }\n     \n     private EventListener<ConfigurationEvent> createChangeListener() {\n-        return (EventListener<ConfigurationEvent>)(event -> this.subnodeConfigurationChanged(event));\n+        return (EventListener<ConfigurationEvent>)(configurationEvent -> this.subnodeConfigurationChanged(configurationEvent));\n     }\n     \n     public Configuration interpolatedConfiguration() {\n-        final BaseHierarchicalConfiguration.InterpolatedVisitor visitor = new BaseHierarchicalConfiguration.InterpolatedVisitor(this);\n-        final NodeHandler<ImmutableNode> handler = (NodeHandler<ImmutableNode>)this.getModel().getNodeHandler();\n-        NodeTreeWalker.INSTANCE.walkDFS(handler.getRootNode(), (ConfigurationNodeVisitor)visitor, (NodeHandler)handler);\n-        final BaseHierarchicalConfiguration c = (BaseHierarchicalConfiguration)this.clone();\n-        c.getNodeModel().setRootNode(visitor.getInterpolatedRoot());\n-        return (Configuration)c;\n+        final BaseHierarchicalConfiguration.InterpolatedVisitor interpolatedVisitor = new BaseHierarchicalConfiguration.InterpolatedVisitor(this);\n+        final NodeHandler nodeHandler = this.getModel().getNodeHandler();\n+        NodeTreeWalker.INSTANCE.walkDFS(nodeHandler.getRootNode(), (ConfigurationNodeVisitor)interpolatedVisitor, nodeHandler);\n+        final BaseHierarchicalConfiguration baseHierarchicalConfiguration = (BaseHierarchicalConfiguration)this.clone();\n+        baseHierarchicalConfiguration.getNodeModel().setRootNode(interpolatedVisitor.getInterpolatedRoot());\n+        return (Configuration)baseHierarchicalConfiguration;\n     }\n     \n     protected NodeModel<ImmutableNode> cloneNodeModel() {\n         return (NodeModel<ImmutableNode>)new InMemoryNodeModel((ImmutableNode)this.getModel().getNodeHandler().getRootNode());\n     }\n     \n-    private static List<ImmutableHierarchicalConfiguration> toImmutable(final List<? extends HierarchicalConfiguration<?>> subs) {\n-        final List<ImmutableHierarchicalConfiguration> res = new ArrayList<ImmutableHierarchicalConfiguration>(subs.size());\n-        for (final HierarchicalConfiguration<?> sub : subs) {\n-            res.add(ConfigurationUtils.unmodifiableConfiguration((HierarchicalConfiguration)sub));\n+    private static List<ImmutableHierarchicalConfiguration> toImmutable(final List<? extends HierarchicalConfiguration<?>> list) {\n+        final ArrayList list2 = new ArrayList(list.size());\n+        final Iterator iterator = list.iterator();\n+        while (iterator.hasNext()) {\n+            list2.add(ConfigurationUtils.unmodifiableConfiguration((HierarchicalConfiguration)iterator.next()));\n         }\n-        return res;\n+        return list2;\n     }\n     \n-    private static NodeModel<ImmutableNode> createNodeModel(final HierarchicalConfiguration<ImmutableNode> c) {\n-        final ImmutableNode root = (c != null) ? obtainRootNode(c) : null;\n-        return (NodeModel<ImmutableNode>)new InMemoryNodeModel(root);\n+    private static NodeModel<ImmutableNode> createNodeModel(final HierarchicalConfiguration<ImmutableNode> hierarchicalConfiguration) {\n+        return (NodeModel<ImmutableNode>)new InMemoryNodeModel((hierarchicalConfiguration != null) ? obtainRootNode(hierarchicalConfiguration) : null);\n     }\n     \n-    private static ImmutableNode obtainRootNode(final HierarchicalConfiguration<ImmutableNode> c) {\n-        return (ImmutableNode)c.getNodeModel().getNodeHandler().getRootNode();\n+    private static ImmutableNode obtainRootNode(final HierarchicalConfiguration<ImmutableNode> hierarchicalConfiguration) {\n+        return (ImmutableNode)hierarchicalConfiguration.getNodeModel().getNodeHandler().getRootNode();\n     }\n }\n"}]}
