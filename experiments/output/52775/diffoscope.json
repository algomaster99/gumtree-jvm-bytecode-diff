{"diffoscope-json-version": 1, "source1": "first/ZipSplitReadOnlySeekableByteChannel.class", "source2": "second/ZipSplitReadOnlySeekableByteChannel.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -64,30 +64,34 @@\n         final String extension = FileNameUtils.getExtension(lastSegmentFile.getCanonicalPath());\n         if (!extension.equalsIgnoreCase(\"zip\")) {\n             throw new IllegalArgumentException(\"The extension of last zip split segment should be .zip\");\n         }\n         final File parent = lastSegmentFile.getParentFile();\n         final String fileBaseName = FileNameUtils.getBaseName(lastSegmentFile.getCanonicalPath());\n         final ArrayList<File> splitZipSegments = new ArrayList<File>();\n-        final Pattern pattern = Pattern.compile(Pattern.quote(fileBaseName) + \".[zZ][0-9]+\");\n+        final Pattern pattern = Pattern.compile(String.valueOf(Pattern.quote(fileBaseName)) + \".[zZ][0-9]+\");\n         final File[] children = parent.listFiles();\n         if (children != null) {\n-            for (final File file : children) {\n+            File[] array;\n+            for (int length = (array = children).length, i = 0; i < length; ++i) {\n+                final File file = array[i];\n                 if (pattern.matcher(file.getName()).matches()) {\n                     splitZipSegments.add(file);\n                 }\n             }\n         }\n-        splitZipSegments.sort((Comparator<? super File>)new ZipSplitReadOnlySeekableByteChannel.ZipSplitSegmentComparator((ZipSplitReadOnlySeekableByteChannel.ZipSplitReadOnlySeekableByteChannel$1)null));\n+        splitZipSegments.sort((Comparator<? super File>)new ZipSplitReadOnlySeekableByteChannel.ZipSplitSegmentComparator((ZipSplitReadOnlySeekableByteChannel.ZipSplitSegmentComparator)null));\n         return forFiles(lastSegmentFile, splitZipSegments);\n     }\n     \n     public static SeekableByteChannel forFiles(final File... files) throws IOException {\n         final List<SeekableByteChannel> channels = new ArrayList<SeekableByteChannel>();\n-        for (final File f : (File[])Objects.requireNonNull(files, \"files must not be null\")) {\n+        File[] array;\n+        for (int length = (array = Objects.requireNonNull(files, \"files must not be null\")).length, i = 0; i < length; ++i) {\n+            final File f = array[i];\n             channels.add(Files.newByteChannel(f.toPath(), StandardOpenOption.READ));\n         }\n         if (channels.size() == 1) {\n             return channels.get(0);\n         }\n         return (SeekableByteChannel)new ZipSplitReadOnlySeekableByteChannel(channels);\n     }\n"}]}
