{"diffoscope-json-version": 1, "source1": "first/HuffmanDecoder.class", "source2": "second/HuffmanDecoder.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,14 +1,14 @@\n \n package org.apache.commons.compress.compressors.deflate64;\n \n import java.io.EOFException;\n-import java.util.Arrays;\n import java.io.IOException;\n import java.nio.ByteOrder;\n+import java.util.Arrays;\n import java.io.InputStream;\n import org.apache.commons.compress.utils.BitInputStream;\n import java.io.Closeable;\n \n class HuffmanDecoder implements Closeable\n {\n     private static final short[] RUN_LENGTH_TABLE;\n@@ -18,25 +18,36 @@\n     private static final int[] FIXED_DISTANCE;\n     private boolean finalBlock;\n     private HuffmanDecoder.DecoderState state;\n     private BitInputStream reader;\n     private final InputStream in;\n     private final HuffmanDecoder.DecodingMemory memory;\n     \n+    static {\n+        RUN_LENGTH_TABLE = new short[] { 96, 128, 160, 192, 224, 256, 288, 320, 353, 417, 481, 545, 610, 738, 866, 994, 1123, 1379, 1635, 1891, 2148, 2660, 3172, 3684, 4197, 5221, 6245, 7269, 112 };\n+        DISTANCE_TABLE = new int[] { 16, 32, 48, 64, 81, 113, 146, 210, 275, 403, 532, 788, 1045, 1557, 2070, 3094, 4119, 6167, 8216, 12312, 16409, 24601, 32794, 49178, 65563, 98331, 131100, 196636, 262173, 393245, 524318, 786462 };\n+        CODE_LENGTHS_ORDER = new int[] { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };\n+        Arrays.fill(FIXED_LITERALS = new int[288], 0, 144, 8);\n+        Arrays.fill(HuffmanDecoder.FIXED_LITERALS, 144, 256, 9);\n+        Arrays.fill(HuffmanDecoder.FIXED_LITERALS, 256, 280, 7);\n+        Arrays.fill(HuffmanDecoder.FIXED_LITERALS, 280, 288, 8);\n+        Arrays.fill(FIXED_DISTANCE = new int[32], 5);\n+    }\n+    \n     HuffmanDecoder(final InputStream in) {\n         this.finalBlock = false;\n-        this.memory = new HuffmanDecoder.DecodingMemory((HuffmanDecoder.HuffmanDecoder$1)null);\n+        this.memory = new HuffmanDecoder.DecodingMemory((HuffmanDecoder.DecodingMemory)null);\n         this.reader = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN);\n         this.in = in;\n-        this.state = (HuffmanDecoder.DecoderState)new HuffmanDecoder.InitialState(this, (HuffmanDecoder.HuffmanDecoder$1)null);\n+        this.state = (HuffmanDecoder.DecoderState)new HuffmanDecoder.InitialState(this, (HuffmanDecoder.InitialState)null);\n     }\n     \n     @Override\n     public void close() {\n-        this.state = (HuffmanDecoder.DecoderState)new HuffmanDecoder.InitialState(this, (HuffmanDecoder.HuffmanDecoder$1)null);\n+        this.state = (HuffmanDecoder.DecoderState)new HuffmanDecoder.InitialState(this, (HuffmanDecoder.InitialState)null);\n         this.reader = null;\n     }\n     \n     public int decode(final byte[] b) throws IOException {\n         return this.decode(b, 0, b.length);\n     }\n     \n@@ -82,15 +93,15 @@\n     private void switchToUncompressedState() throws IOException {\n         this.reader.alignWithByteBoundary();\n         final long bLen = this.readBits(16);\n         final long bNLen = this.readBits(16);\n         if (((bLen ^ 0xFFFFL) & 0xFFFFL) != bNLen) {\n             throw new IllegalStateException(\"Illegal LEN / NLEN values\");\n         }\n-        this.state = (HuffmanDecoder.DecoderState)new HuffmanDecoder.UncompressedState(this, bLen, (HuffmanDecoder.HuffmanDecoder$1)null);\n+        this.state = (HuffmanDecoder.DecoderState)new HuffmanDecoder.UncompressedState(this, bLen, (HuffmanDecoder.UncompressedState)null);\n     }\n     \n     private int[][] readDynamicTables() throws IOException {\n         final int[][] result = new int[2][];\n         final int literals = (int)(this.readBits(5) + 257L);\n         result[0] = new int[literals];\n         final int distances = (int)(this.readBits(5) + 1L);\n@@ -152,15 +163,15 @@\n         }\n         System.arraycopy(auxBuffer, 0, literals, 0, literals.length);\n         System.arraycopy(auxBuffer, literals.length, distances, 0, distances.length);\n     }\n     \n     private static HuffmanDecoder.BinaryTreeNode buildTree(final int[] litTable) {\n         final int[] literalCodes = getCodes(litTable);\n-        final HuffmanDecoder.BinaryTreeNode root = new HuffmanDecoder.BinaryTreeNode(0, (HuffmanDecoder.HuffmanDecoder$1)null);\n+        final HuffmanDecoder.BinaryTreeNode root = new HuffmanDecoder.BinaryTreeNode(0, (HuffmanDecoder.BinaryTreeNode)null);\n         for (int i = 0; i < litTable.length; ++i) {\n             final int len = litTable[i];\n             if (len != 0) {\n                 HuffmanDecoder.BinaryTreeNode node = root;\n                 final int lit = literalCodes[len - 1];\n                 for (int p = len - 1; p >= 0; --p) {\n                     final int bit = lit & 1 << p;\n@@ -201,19 +212,8 @@\n     private static long readBits(final BitInputStream reader, final int numBits) throws IOException {\n         final long r = reader.readBits(numBits);\n         if (r == -1L) {\n             throw new EOFException(\"Truncated Deflate64 Stream\");\n         }\n         return r;\n     }\n-    \n-    static {\n-        RUN_LENGTH_TABLE = new short[] { 96, 128, 160, 192, 224, 256, 288, 320, 353, 417, 481, 545, 610, 738, 866, 994, 1123, 1379, 1635, 1891, 2148, 2660, 3172, 3684, 4197, 5221, 6245, 7269, 112 };\n-        DISTANCE_TABLE = new int[] { 16, 32, 48, 64, 81, 113, 146, 210, 275, 403, 532, 788, 1045, 1557, 2070, 3094, 4119, 6167, 8216, 12312, 16409, 24601, 32794, 49178, 65563, 98331, 131100, 196636, 262173, 393245, 524318, 786462 };\n-        CODE_LENGTHS_ORDER = new int[] { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };\n-        Arrays.fill(FIXED_LITERALS = new int[288], 0, 144, 8);\n-        Arrays.fill(HuffmanDecoder.FIXED_LITERALS, 144, 256, 9);\n-        Arrays.fill(HuffmanDecoder.FIXED_LITERALS, 256, 280, 7);\n-        Arrays.fill(HuffmanDecoder.FIXED_LITERALS, 280, 288, 8);\n-        Arrays.fill(FIXED_DISTANCE = new int[32], 5);\n-    }\n }\n"}]}
