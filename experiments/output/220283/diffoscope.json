{"diffoscope-json-version": 1, "source1": "first/EmptyLineSeparatorCheck.class", "source2": "second/EmptyLineSeparatorCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -3,16 +3,16 @@\n \n import com.puppycrawl.tools.checkstyle.utils.JavadocUtil;\n import java.util.function.Function;\n import java.util.LinkedList;\n import com.puppycrawl.tools.checkstyle.utils.CheckUtil;\n import com.puppycrawl.tools.checkstyle.api.FileContents;\n import java.util.ArrayList;\n-import java.util.Iterator;\n import java.util.List;\n+import java.util.Iterator;\n import java.util.Optional;\n import com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n import com.puppycrawl.tools.checkstyle.api.DetailAST;\n import com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n import com.puppycrawl.tools.checkstyle.StatelessCheck;\n import com.puppycrawl.tools.checkstyle.api.AbstractCheck;\n \n@@ -28,24 +28,24 @@\n     private boolean allowMultipleEmptyLinesInsideClassMembers;\n     \n     public EmptyLineSeparatorCheck() {\n         this.allowMultipleEmptyLines = true;\n         this.allowMultipleEmptyLinesInsideClassMembers = true;\n     }\n     \n-    public final void setAllowNoEmptyLineBetweenFields(final boolean allow) {\n-        this.allowNoEmptyLineBetweenFields = allow;\n+    public final void setAllowNoEmptyLineBetweenFields(final boolean allowNoEmptyLineBetweenFields) {\n+        this.allowNoEmptyLineBetweenFields = allowNoEmptyLineBetweenFields;\n     }\n     \n-    public void setAllowMultipleEmptyLines(final boolean allow) {\n-        this.allowMultipleEmptyLines = allow;\n+    public void setAllowMultipleEmptyLines(final boolean allowMultipleEmptyLines) {\n+        this.allowMultipleEmptyLines = allowMultipleEmptyLines;\n     }\n     \n-    public void setAllowMultipleEmptyLinesInsideClassMembers(final boolean allow) {\n-        this.allowMultipleEmptyLinesInsideClassMembers = allow;\n+    public void setAllowMultipleEmptyLinesInsideClassMembers(final boolean allowMultipleEmptyLinesInsideClassMembers) {\n+        this.allowMultipleEmptyLinesInsideClassMembers = allowMultipleEmptyLinesInsideClassMembers;\n     }\n     \n     public boolean isCommentNodesRequired() {\n         return true;\n     }\n     \n     public int[] getDefaultTokens() {\n@@ -56,309 +56,300 @@\n         return new int[] { 16, 30, 152, 14, 15, 154, 12, 11, 9, 8, 10, 199, 203 };\n     }\n     \n     public int[] getRequiredTokens() {\n         return CommonUtil.EMPTY_INT_ARRAY;\n     }\n     \n-    public void visitToken(final DetailAST ast) {\n-        this.checkComments(ast);\n-        if (this.hasMultipleLinesBefore(ast)) {\n-            this.log(ast, \"empty.line.separator.multiple.lines\", new Object[] { ast.getText() });\n+    public void visitToken(final DetailAST detailAST) {\n+        this.checkComments(detailAST);\n+        if (this.hasMultipleLinesBefore(detailAST)) {\n+            this.log(detailAST, \"empty.line.separator.multiple.lines\", new Object[] { detailAST.getText() });\n         }\n         if (!this.allowMultipleEmptyLinesInsideClassMembers) {\n-            this.processMultipleLinesInside(ast);\n+            this.processMultipleLinesInside(detailAST);\n         }\n-        if (ast.getType() == 16) {\n-            this.checkCommentInModifiers(ast);\n+        if (detailAST.getType() == 16) {\n+            this.checkCommentInModifiers(detailAST);\n         }\n-        DetailAST nextToken;\n-        for (nextToken = ast.getNextSibling(); nextToken != null && TokenUtil.isCommentType(nextToken.getType()); nextToken = nextToken.getNextSibling()) {}\n-        if (nextToken != null) {\n-            this.checkToken(ast, nextToken);\n+        DetailAST detailAST2;\n+        for (detailAST2 = detailAST.getNextSibling(); detailAST2 != null && TokenUtil.isCommentType(detailAST2.getType()); detailAST2 = detailAST2.getNextSibling()) {}\n+        if (detailAST2 != null) {\n+            this.checkToken(detailAST, detailAST2);\n         }\n     }\n     \n-    private void checkToken(final DetailAST ast, final DetailAST nextToken) {\n-        final int astType = ast.getType();\n-        switch (astType) {\n+    private void checkToken(final DetailAST detailAST, final DetailAST detailAST2) {\n+        switch (detailAST.getType()) {\n             case 10: {\n-                this.processVariableDef(ast, nextToken);\n+                this.processVariableDef(detailAST, detailAST2);\n                 break;\n             }\n             case 30:\n             case 152: {\n-                this.processImport(ast, nextToken);\n+                this.processImport(detailAST, detailAST2);\n                 break;\n             }\n             case 16: {\n-                this.processPackage(ast, nextToken);\n+                this.processPackage(detailAST, detailAST2);\n                 break;\n             }\n             default: {\n-                if (nextToken.getType() == 73) {\n-                    if (this.hasNotAllowedTwoEmptyLinesBefore(nextToken)) {\n-                        final DetailAST result = getLastElementBeforeEmptyLines(ast, nextToken.getLineNo());\n-                        this.log(result, \"empty.line.separator.multiple.lines.after\", new Object[] { result.getText() });\n+                if (detailAST2.getType() == 73) {\n+                    if (this.hasNotAllowedTwoEmptyLinesBefore(detailAST2)) {\n+                        final DetailAST lastElementBeforeEmptyLines = getLastElementBeforeEmptyLines(detailAST, detailAST2.getLineNo());\n+                        this.log(lastElementBeforeEmptyLines, \"empty.line.separator.multiple.lines.after\", new Object[] { lastElementBeforeEmptyLines.getText() });\n                         break;\n                     }\n                     break;\n                 }\n                 else {\n-                    if (!this.hasEmptyLineAfter(ast)) {\n-                        this.log(nextToken, \"empty.line.separator\", new Object[] { nextToken.getText() });\n+                    if (!this.hasEmptyLineAfter(detailAST)) {\n+                        this.log(detailAST2, \"empty.line.separator\", new Object[] { detailAST2.getText() });\n                         break;\n                     }\n                     break;\n                 }\n                 break;\n             }\n         }\n     }\n     \n-    private void checkCommentInModifiers(final DetailAST packageDef) {\n-        final Optional<DetailAST> comment = findCommentUnder(packageDef);\n-        if (comment.isPresent()) {\n-            this.log((DetailAST)comment.get(), \"empty.line.separator\", new Object[] { ((DetailAST)comment.get()).getText() });\n+    private void checkCommentInModifiers(final DetailAST detailAST) {\n+        final Optional<DetailAST> commentUnder = findCommentUnder(detailAST);\n+        if (commentUnder.isPresent()) {\n+            this.log((DetailAST)commentUnder.get(), \"empty.line.separator\", new Object[] { ((DetailAST)commentUnder.get()).getText() });\n         }\n     }\n     \n-    private void processMultipleLinesInside(final DetailAST ast) {\n-        final int astType = ast.getType();\n-        if (isClassMemberBlock(astType)) {\n-            final List<Integer> emptyLines = this.getEmptyLines(ast);\n-            final List<Integer> emptyLinesToLog = getEmptyLinesToLog(emptyLines);\n-            for (final Integer lineNo : emptyLinesToLog) {\n-                this.log(getLastElementBeforeEmptyLines(ast, (int)lineNo), \"empty.line.separator.multiple.lines.inside\", new Object[0]);\n+    private void processMultipleLinesInside(final DetailAST detailAST) {\n+        if (isClassMemberBlock(detailAST.getType())) {\n+            final Iterator<Integer> iterator = getEmptyLinesToLog(this.getEmptyLines(detailAST)).iterator();\n+            while (iterator.hasNext()) {\n+                this.log(getLastElementBeforeEmptyLines(detailAST, (int)Integer.valueOf(iterator.next())), \"empty.line.separator.multiple.lines.inside\", new Object[0]);\n             }\n         }\n     }\n     \n-    private static DetailAST getLastElementBeforeEmptyLines(final DetailAST ast, final int line) {\n-        DetailAST result = ast;\n-        if (ast.getFirstChild().getLineNo() <= line) {\n-            for (result = ast.getFirstChild(); result.getNextSibling() != null && result.getNextSibling().getLineNo() <= line; result = result.getNextSibling()) {}\n-            if (result.hasChildren()) {\n-                result = getLastElementBeforeEmptyLines(result, line);\n+    private static DetailAST getLastElementBeforeEmptyLines(final DetailAST detailAST, final int n) {\n+        DetailAST detailAST2 = detailAST;\n+        if (detailAST.getFirstChild().getLineNo() <= n) {\n+            for (detailAST2 = detailAST.getFirstChild(); detailAST2.getNextSibling() != null && detailAST2.getNextSibling().getLineNo() <= n; detailAST2 = detailAST2.getNextSibling()) {}\n+            if (detailAST2.hasChildren()) {\n+                detailAST2 = getLastElementBeforeEmptyLines(detailAST2, n);\n             }\n         }\n-        if (result.getNextSibling() != null) {\n-            final Optional<DetailAST> postFixNode = getPostFixNode(result.getNextSibling());\n+        if (detailAST2.getNextSibling() != null) {\n+            final Optional<DetailAST> postFixNode = getPostFixNode(detailAST2.getNextSibling());\n             if (postFixNode.isPresent()) {\n-                final DetailAST firstChildAfterPostFix = (DetailAST)postFixNode.get();\n-                result = getLastElementBeforeEmptyLines(firstChildAfterPostFix, line);\n+                detailAST2 = getLastElementBeforeEmptyLines(postFixNode.get(), n);\n             }\n         }\n-        return result;\n+        return detailAST2;\n     }\n     \n-    private static Optional<DetailAST> getPostFixNode(final DetailAST ast) {\n-        Optional<DetailAST> result = Optional.empty();\n-        if (ast.getType() == 28 && ast.getFirstChild().getType() == 27) {\n-            final DetailAST node = ast.getFirstChild().getFirstChild();\n-            if (node.getType() == 59) {\n-                result = Optional.of(node);\n+    private static Optional<DetailAST> getPostFixNode(final DetailAST detailAST) {\n+        Object o = Optional.empty();\n+        if (detailAST.getType() == 28 && detailAST.getFirstChild().getType() == 27) {\n+            final DetailAST firstChild = detailAST.getFirstChild().getFirstChild();\n+            if (firstChild.getType() == 59) {\n+                o = Optional.of(firstChild);\n             }\n         }\n-        return result;\n+        return (Optional<DetailAST>)o;\n     }\n     \n-    private static boolean isClassMemberBlock(final int astType) {\n-        return TokenUtil.isOfType(astType, new int[] { 12, 11, 9, 8, 203 });\n+    private static boolean isClassMemberBlock(final int n) {\n+        return TokenUtil.isOfType(n, new int[] { 12, 11, 9, 8, 203 });\n     }\n     \n-    private List<Integer> getEmptyLines(final DetailAST ast) {\n-        final DetailAST lastToken = ast.getLastChild().getLastChild();\n-        int lastTokenLineNo = 0;\n-        if (lastToken != null) {\n-            lastTokenLineNo = lastToken.getLineNo() - 2;\n+    private List<Integer> getEmptyLines(final DetailAST detailAST) {\n+        final DetailAST lastChild = detailAST.getLastChild().getLastChild();\n+        int n = 0;\n+        if (lastChild != null) {\n+            n = lastChild.getLineNo() - 2;\n         }\n-        final List<Integer> emptyLines = new ArrayList<Integer>();\n+        final ArrayList list = new ArrayList();\n         final FileContents fileContents = this.getFileContents();\n-        for (int lineNo = ast.getLineNo(); lineNo <= lastTokenLineNo; ++lineNo) {\n-            if (fileContents.lineIsBlank(lineNo)) {\n-                emptyLines.add(Integer.valueOf(lineNo));\n+        for (int i = detailAST.getLineNo(); i <= n; ++i) {\n+            if (fileContents.lineIsBlank(i)) {\n+                list.add(Integer.valueOf(i));\n             }\n         }\n-        return emptyLines;\n+        return list;\n     }\n     \n-    private static List<Integer> getEmptyLinesToLog(final Iterable<Integer> emptyLines) {\n-        final List<Integer> emptyLinesToLog = new ArrayList<Integer>();\n-        int previousEmptyLineNo = -1;\n-        final Iterator<Integer> iterator = emptyLines.iterator();\n+    private static List<Integer> getEmptyLinesToLog(final Iterable<Integer> iterable) {\n+        final ArrayList list = new ArrayList();\n+        int i = -1;\n+        final Iterator<Integer> iterator = iterable.iterator();\n         while (iterator.hasNext()) {\n-            final int emptyLineNo = (int)Integer.valueOf(iterator.next());\n-            if (previousEmptyLineNo + 1 == emptyLineNo) {\n-                emptyLinesToLog.add(Integer.valueOf(previousEmptyLineNo));\n+            final int intValue = (int)Integer.valueOf(iterator.next());\n+            if (i + 1 == intValue) {\n+                list.add(Integer.valueOf(i));\n             }\n-            previousEmptyLineNo = emptyLineNo;\n+            i = intValue;\n         }\n-        return emptyLinesToLog;\n+        return list;\n     }\n     \n-    private boolean hasMultipleLinesBefore(final DetailAST ast) {\n-        return (ast.getType() != 10 || isTypeField(ast)) && this.hasNotAllowedTwoEmptyLinesBefore(ast);\n+    private boolean hasMultipleLinesBefore(final DetailAST detailAST) {\n+        return (detailAST.getType() != 10 || isTypeField(detailAST)) && this.hasNotAllowedTwoEmptyLinesBefore(detailAST);\n     }\n     \n-    private void processPackage(final DetailAST ast, final DetailAST nextToken) {\n-        if (ast.getLineNo() > 1 && !this.hasEmptyLineBefore(ast)) {\n+    private void processPackage(final DetailAST detailAST, final DetailAST detailAST2) {\n+        if (detailAST.getLineNo() > 1 && !this.hasEmptyLineBefore(detailAST)) {\n             if (CheckUtil.isPackageInfo(this.getFilePath())) {\n-                if (!ast.getFirstChild().hasChildren() && !isPrecededByJavadoc(ast)) {\n-                    this.log(ast, \"empty.line.separator\", new Object[] { ast.getText() });\n+                if (!detailAST.getFirstChild().hasChildren() && !isPrecededByJavadoc(detailAST)) {\n+                    this.log(detailAST, \"empty.line.separator\", new Object[] { detailAST.getText() });\n                 }\n             }\n             else {\n-                this.log(ast, \"empty.line.separator\", new Object[] { ast.getText() });\n+                this.log(detailAST, \"empty.line.separator\", new Object[] { detailAST.getText() });\n             }\n         }\n-        if (isLineEmptyAfterPackage(ast)) {\n-            final DetailAST elementAst = getViolationAstForPackage(ast);\n-            this.log(elementAst, \"empty.line.separator\", new Object[] { elementAst.getText() });\n+        if (isLineEmptyAfterPackage(detailAST)) {\n+            final DetailAST violationAstForPackage = getViolationAstForPackage(detailAST);\n+            this.log(violationAstForPackage, \"empty.line.separator\", new Object[] { violationAstForPackage.getText() });\n         }\n-        else if (!this.hasEmptyLineAfter(ast)) {\n-            this.log(nextToken, \"empty.line.separator\", new Object[] { nextToken.getText() });\n+        else if (!this.hasEmptyLineAfter(detailAST)) {\n+            this.log(detailAST2, \"empty.line.separator\", new Object[] { detailAST2.getText() });\n         }\n     }\n     \n-    private static boolean isLineEmptyAfterPackage(final DetailAST ast) {\n-        DetailAST nextElement;\n-        int lastChildLineNo;\n-        for (nextElement = ast, lastChildLineNo = ast.getLastChild().getLineNo(); nextElement.getLineNo() < lastChildLineNo + 1 && nextElement.getNextSibling() != null; nextElement = nextElement.getNextSibling()) {}\n-        return nextElement.getLineNo() == lastChildLineNo + 1;\n+    private static boolean isLineEmptyAfterPackage(final DetailAST detailAST) {\n+        DetailAST nextSibling;\n+        int lineNo;\n+        for (nextSibling = detailAST, lineNo = detailAST.getLastChild().getLineNo(); nextSibling.getLineNo() < lineNo + 1 && nextSibling.getNextSibling() != null; nextSibling = nextSibling.getNextSibling()) {}\n+        return nextSibling.getLineNo() == lineNo + 1;\n     }\n     \n-    private static DetailAST getViolationAstForPackage(final DetailAST ast) {\n-        DetailAST nextElement = ast;\n-        for (int lastChildLineNo = ast.getLastChild().getLineNo(); nextElement.getLineNo() < lastChildLineNo + 1; nextElement = nextElement.getNextSibling()) {}\n-        return nextElement;\n+    private static DetailAST getViolationAstForPackage(final DetailAST detailAST) {\n+        DetailAST nextSibling;\n+        for (nextSibling = detailAST; nextSibling.getLineNo() < detailAST.getLastChild().getLineNo() + 1; nextSibling = nextSibling.getNextSibling()) {}\n+        return nextSibling;\n     }\n     \n-    private void processImport(final DetailAST ast, final DetailAST nextToken) {\n-        if (!TokenUtil.isOfType(nextToken, new int[] { 30, 152 }) && !this.hasEmptyLineAfter(ast)) {\n-            this.log(nextToken, \"empty.line.separator\", new Object[] { nextToken.getText() });\n+    private void processImport(final DetailAST detailAST, final DetailAST detailAST2) {\n+        if (!TokenUtil.isOfType(detailAST2, new int[] { 30, 152 }) && !this.hasEmptyLineAfter(detailAST)) {\n+            this.log(detailAST2, \"empty.line.separator\", new Object[] { detailAST2.getText() });\n         }\n     }\n     \n-    private void processVariableDef(final DetailAST ast, final DetailAST nextToken) {\n-        if (isTypeField(ast) && !this.hasEmptyLineAfter(ast) && this.isViolatingEmptyLineBetweenFieldsPolicy(nextToken)) {\n-            this.log(nextToken, \"empty.line.separator\", new Object[] { nextToken.getText() });\n+    private void processVariableDef(final DetailAST detailAST, final DetailAST detailAST2) {\n+        if (isTypeField(detailAST) && !this.hasEmptyLineAfter(detailAST) && this.isViolatingEmptyLineBetweenFieldsPolicy(detailAST2)) {\n+            this.log(detailAST2, \"empty.line.separator\", new Object[] { detailAST2.getText() });\n         }\n     }\n     \n     private boolean isViolatingEmptyLineBetweenFieldsPolicy(final DetailAST detailAST) {\n         return detailAST.getType() != 73 && (!this.allowNoEmptyLineBetweenFields || !TokenUtil.isOfType(detailAST, new int[] { 74, 10 }));\n     }\n     \n-    private boolean hasNotAllowedTwoEmptyLinesBefore(final DetailAST token) {\n-        return !this.allowMultipleEmptyLines && this.hasEmptyLineBefore(token) && this.isPrePreviousLineEmpty(token);\n+    private boolean hasNotAllowedTwoEmptyLinesBefore(final DetailAST detailAST) {\n+        return !this.allowMultipleEmptyLines && this.hasEmptyLineBefore(detailAST) && this.isPrePreviousLineEmpty(detailAST);\n     }\n     \n-    private void checkComments(final DetailAST token) {\n+    private void checkComments(final DetailAST detailAST) {\n         if (!this.allowMultipleEmptyLines) {\n-            if (TokenUtil.isOfType(token, new int[] { 16, 30, 152, 12 })) {\n-                for (DetailAST previousNode = token.getPreviousSibling(); this.isCommentInBeginningOfLine(previousNode); previousNode = previousNode.getPreviousSibling()) {\n-                    if (this.hasEmptyLineBefore(previousNode) && this.isPrePreviousLineEmpty(previousNode)) {\n-                        this.log(previousNode, \"empty.line.separator.multiple.lines\", new Object[] { previousNode.getText() });\n+            if (TokenUtil.isOfType(detailAST, new int[] { 16, 30, 152, 12 })) {\n+                for (DetailAST detailAST2 = detailAST.getPreviousSibling(); this.isCommentInBeginningOfLine(detailAST2); detailAST2 = detailAST2.getPreviousSibling()) {\n+                    if (this.hasEmptyLineBefore(detailAST2) && this.isPrePreviousLineEmpty(detailAST2)) {\n+                        this.log(detailAST2, \"empty.line.separator.multiple.lines\", new Object[] { detailAST2.getText() });\n                     }\n                 }\n             }\n             else {\n-                this.checkCommentsInsideToken(token);\n+                this.checkCommentsInsideToken(detailAST);\n             }\n         }\n     }\n     \n-    private void checkCommentsInsideToken(final DetailAST token) {\n-        final List<DetailAST> childNodes = new LinkedList<DetailAST>();\n-        for (DetailAST childNode = token.getLastChild(); childNode != null; childNode = childNode.getPreviousSibling()) {\n-            if (childNode.getType() == 5) {\n-                for (DetailAST node = token.getFirstChild().getLastChild(); node != null; node = node.getPreviousSibling()) {\n-                    if (this.isCommentInBeginningOfLine(node)) {\n-                        childNodes.add(node);\n+    private void checkCommentsInsideToken(final DetailAST detailAST) {\n+        final LinkedList list = new LinkedList();\n+        for (DetailAST detailAST2 = detailAST.getLastChild(); detailAST2 != null; detailAST2 = detailAST2.getPreviousSibling()) {\n+            if (detailAST2.getType() == 5) {\n+                for (DetailAST detailAST3 = detailAST.getFirstChild().getLastChild(); detailAST3 != null; detailAST3 = detailAST3.getPreviousSibling()) {\n+                    if (this.isCommentInBeginningOfLine(detailAST3)) {\n+                        list.add(detailAST3);\n                     }\n                 }\n             }\n-            else if (this.isCommentInBeginningOfLine(childNode)) {\n-                childNodes.add(childNode);\n+            else if (this.isCommentInBeginningOfLine(detailAST2)) {\n+                list.add(detailAST2);\n             }\n         }\n-        for (final DetailAST node2 : childNodes) {\n-            if (this.hasEmptyLineBefore(node2) && this.isPrePreviousLineEmpty(node2)) {\n-                this.log(node2, \"empty.line.separator.multiple.lines\", new Object[] { node2.getText() });\n+        for (final DetailAST detailAST4 : list) {\n+            if (this.hasEmptyLineBefore(detailAST4) && this.isPrePreviousLineEmpty(detailAST4)) {\n+                this.log(detailAST4, \"empty.line.separator.multiple.lines\", new Object[] { detailAST4.getText() });\n             }\n         }\n     }\n     \n-    private boolean isPrePreviousLineEmpty(final DetailAST token) {\n-        boolean result = false;\n-        final int lineNo = token.getLineNo();\n-        final int number = 3;\n+    private boolean isPrePreviousLineEmpty(final DetailAST detailAST) {\n+        boolean blank = false;\n+        final int lineNo = detailAST.getLineNo();\n         if (lineNo >= 3) {\n-            final String prePreviousLine = this.getLine(lineNo - 3);\n-            result = CommonUtil.isBlank(prePreviousLine);\n+            blank = CommonUtil.isBlank(this.getLine(lineNo - 3));\n         }\n-        return result;\n+        return blank;\n     }\n     \n-    private boolean hasEmptyLineAfter(final DetailAST token) {\n-        DetailAST lastToken = token.getLastChild().getLastChild();\n-        if (lastToken == null) {\n-            lastToken = token.getLastChild();\n+    private boolean hasEmptyLineAfter(final DetailAST detailAST) {\n+        DetailAST detailAST2 = detailAST.getLastChild().getLastChild();\n+        if (detailAST2 == null) {\n+            detailAST2 = detailAST.getLastChild();\n         }\n-        DetailAST nextToken = token.getNextSibling();\n-        if (TokenUtil.isCommentType(nextToken.getType())) {\n-            nextToken = nextToken.getNextSibling();\n+        DetailAST detailAST3 = detailAST.getNextSibling();\n+        if (TokenUtil.isCommentType(detailAST3.getType())) {\n+            detailAST3 = detailAST3.getNextSibling();\n         }\n-        final int nextBegin = nextToken.getLineNo();\n-        final int currentEnd = lastToken.getLineNo();\n-        return this.hasEmptyLine(currentEnd + 1, nextBegin - 1);\n+        return this.hasEmptyLine(detailAST2.getLineNo() + 1, detailAST3.getLineNo() - 1);\n     }\n     \n-    private static Optional<DetailAST> findCommentUnder(final DetailAST packageDef) {\n-        return Optional.ofNullable(packageDef.getNextSibling()).map(sibling -> sibling.findFirstToken(5)).map((Function<? super Object, ? extends DetailAST>)DetailAST::getFirstChild).filter(token -> TokenUtil.isCommentType(token.getType())).filter(comment -> comment.getLineNo() == packageDef.getLineNo() + 1);\n+    private static Optional<DetailAST> findCommentUnder(final DetailAST detailAST) {\n+        return Optional.ofNullable(detailAST.getNextSibling()).map(detailAST2 -> detailAST2.findFirstToken(5)).map((Function<? super Object, ? extends DetailAST>)DetailAST::getFirstChild).filter(detailAST3 -> TokenUtil.isCommentType(detailAST3.getType())).filter(detailAST5 -> detailAST5.getLineNo() == detailAST4.getLineNo() + 1);\n     }\n     \n-    private boolean hasEmptyLine(final int startLine, final int endLine) {\n-        boolean result = false;\n+    private boolean hasEmptyLine(final int n, final int n2) {\n+        boolean b = false;\n         final FileContents fileContents = this.getFileContents();\n-        for (int line = startLine; line <= endLine; ++line) {\n-            if (fileContents.lineIsBlank(line - 1)) {\n-                result = true;\n+        for (int i = n; i <= n2; ++i) {\n+            if (fileContents.lineIsBlank(i - 1)) {\n+                b = true;\n                 break;\n             }\n         }\n-        return result;\n+        return b;\n     }\n     \n-    private boolean hasEmptyLineBefore(final DetailAST token) {\n-        boolean result = false;\n-        final int lineNo = token.getLineNo();\n+    private boolean hasEmptyLineBefore(final DetailAST detailAST) {\n+        boolean blank = false;\n+        final int lineNo = detailAST.getLineNo();\n         if (lineNo != 1) {\n-            final String lineBefore = this.getLine(lineNo - 2);\n-            result = CommonUtil.isBlank(lineBefore);\n+            blank = CommonUtil.isBlank(this.getLine(lineNo - 2));\n         }\n-        return result;\n+        return blank;\n     }\n     \n-    private boolean isCommentInBeginningOfLine(final DetailAST comment) {\n-        boolean result = false;\n-        if (comment != null) {\n-            final String lineWithComment = this.getLine(comment.getLineNo() - 1).trim();\n-            result = (lineWithComment.startsWith(\"//\") || lineWithComment.startsWith(\"/*\"));\n+    private boolean isCommentInBeginningOfLine(final DetailAST detailAST) {\n+        boolean b = false;\n+        if (detailAST != null) {\n+            final String trim = this.getLine(detailAST.getLineNo() - 1).trim();\n+            b = (trim.startsWith(\"//\") || trim.startsWith(\"/*\"));\n         }\n-        return result;\n+        return b;\n     }\n     \n-    private static boolean isPrecededByJavadoc(final DetailAST token) {\n-        boolean result = false;\n-        final DetailAST previous = token.getPreviousSibling();\n-        if (previous.getType() == 145 && JavadocUtil.isJavadocComment(previous.getFirstChild().getText())) {\n-            result = true;\n+    private static boolean isPrecededByJavadoc(final DetailAST detailAST) {\n+        boolean b = false;\n+        final DetailAST previousSibling = detailAST.getPreviousSibling();\n+        if (previousSibling.getType() == 145 && JavadocUtil.isJavadocComment(previousSibling.getFirstChild().getText())) {\n+            b = true;\n         }\n-        return result;\n+        return b;\n     }\n     \n-    private static boolean isTypeField(final DetailAST variableDef) {\n-        return TokenUtil.isTypeDeclaration(variableDef.getParent().getParent().getType());\n+    private static boolean isTypeField(final DetailAST detailAST) {\n+        return TokenUtil.isTypeDeclaration(detailAST.getParent().getParent().getType());\n     }\n }\n"}]}
