{"diffoscope-json-version": 1, "source1": "first/MethodGen.class", "source2": "second/MethodGen.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -57,67 +57,64 @@\n     }\n     \n     public static BCELComparator getComparator() {\n         return MethodGen.bcelComparator;\n     }\n     \n     public static int getMaxStack(final ConstantPoolGen cp, final InstructionList il, final CodeExceptionGen[] et) {\n-        final MethodGen.BranchStack branchTargets = new MethodGen.BranchStack();\n-        for (final CodeExceptionGen element : et) {\n-            final InstructionHandle handlerPc = element.getHandlerPC();\n-            if (handlerPc != null) {\n-                branchTargets.push(handlerPc, 1);\n+        final MethodGen.BranchStack branchStack = new MethodGen.BranchStack();\n+        for (int length = et.length, i = 0; i < length; ++i) {\n+            final InstructionHandle handlerPC = et[i].getHandlerPC();\n+            if (handlerPC != null) {\n+                branchStack.push(handlerPC, 1);\n             }\n         }\n         int stackDepth = 0;\n-        int maxStackDepth = 0;\n-        InstructionHandle ih = il.getStart();\n-        while (ih != null) {\n-            final Instruction instruction = ih.getInstruction();\n+        int n = 0;\n+        InstructionHandle instructionHandle = il.getStart();\n+        while (instructionHandle != null) {\n+            final Instruction instruction = instructionHandle.getInstruction();\n             final short opcode = instruction.getOpcode();\n-            final int delta = instruction.produceStack(cp) - instruction.consumeStack(cp);\n-            stackDepth += delta;\n-            if (stackDepth > maxStackDepth) {\n-                maxStackDepth = stackDepth;\n+            stackDepth += instruction.produceStack(cp) - instruction.consumeStack(cp);\n+            if (stackDepth > n) {\n+                n = stackDepth;\n             }\n             if (instruction instanceof BranchInstruction) {\n-                final BranchInstruction branch = (BranchInstruction)instruction;\n+                final BranchInstruction branchInstruction = (BranchInstruction)instruction;\n                 if (instruction instanceof Select) {\n-                    final Select select = (Select)branch;\n-                    final InstructionHandle[] targets2;\n-                    final InstructionHandle[] targets = targets2 = select.getTargets();\n-                    for (final InstructionHandle target : targets2) {\n-                        branchTargets.push(target, stackDepth);\n+                    final InstructionHandle[] targets = ((Select)branchInstruction).getTargets();\n+                    for (int length2 = targets.length, j = 0; j < length2; ++j) {\n+                        branchStack.push(targets[j], stackDepth);\n                     }\n-                    ih = null;\n+                    instructionHandle = null;\n                 }\n-                else if (!(branch instanceof IfInstruction)) {\n+                else if (!(branchInstruction instanceof IfInstruction)) {\n                     if (opcode == 168 || opcode == 201) {\n-                        branchTargets.push(ih.getNext(), stackDepth - 1);\n+                        branchStack.push(instructionHandle.getNext(), stackDepth - 1);\n                     }\n-                    ih = null;\n+                    instructionHandle = null;\n                 }\n-                branchTargets.push(branch.getTarget(), stackDepth);\n+                branchStack.push(branchInstruction.getTarget(), stackDepth);\n             }\n             else if (opcode == 191 || opcode == 169 || (opcode >= 172 && opcode <= 177)) {\n-                ih = null;\n+                instructionHandle = null;\n             }\n-            if (ih != null) {\n-                ih = ih.getNext();\n+            if (instructionHandle != null) {\n+                instructionHandle = instructionHandle.getNext();\n             }\n-            if (ih == null) {\n-                final MethodGen.BranchTarget bt = branchTargets.pop();\n-                if (bt == null) {\n+            if (instructionHandle == null) {\n+                final MethodGen.BranchTarget pop = branchStack.pop();\n+                if (pop == null) {\n                     continue;\n                 }\n-                ih = bt.target;\n-                stackDepth = bt.stackDepth;\n+                instructionHandle = pop.target;\n+                stackDepth = pop.stackDepth;\n             }\n         }\n-        return maxStackDepth;\n+        return n;\n     }\n     \n     public static void setComparator(final BCELComparator comparator) {\n         MethodGen.bcelComparator = comparator;\n     }\n     \n     public MethodGen(final int accessFlags, final Type returnType, final Type[] argTypes, String[] argNames, final String methodName, final String className, final InstructionList il, final ConstantPoolGen cp) {\n@@ -130,91 +127,83 @@\n         this.setType(returnType);\n         this.setArgumentTypes(argTypes);\n         this.setArgumentNames(argNames);\n         this.setName(methodName);\n         this.setClassName(className);\n         this.setInstructionList(il);\n         this.setConstantPool(cp);\n-        final boolean abstract_ = this.isAbstract() || this.isNative();\n+        final boolean b = this.isAbstract() || this.isNative();\n         InstructionHandle start = null;\n-        final InstructionHandle end = null;\n-        if (!abstract_) {\n+        final InstructionHandle instructionHandle = null;\n+        if (!b) {\n             start = il.getStart();\n             if (!this.isStatic() && className != null) {\n-                this.addLocalVariable(\"this\", (Type)ObjectType.getInstance(className), start, end);\n+                this.addLocalVariable(\"this\", (Type)ObjectType.getInstance(className), start, instructionHandle);\n             }\n         }\n         if (argTypes != null) {\n-            final int size = argTypes.length;\n-            for (final Type argType : argTypes) {\n-                if (Type.VOID == argType) {\n+            final int length = argTypes.length;\n+            for (int length2 = argTypes.length, i = 0; i < length2; ++i) {\n+                if (Type.VOID == argTypes[i]) {\n                     throw new ClassGenException(\"'void' is an illegal argument type for a method\");\n                 }\n             }\n             if (argNames != null) {\n-                if (size != argNames.length) {\n-                    throw new ClassGenException(\"Mismatch in argument array lengths: \" + size + \" vs. \" + argNames.length);\n+                if (length != argNames.length) {\n+                    throw new ClassGenException(\"Mismatch in argument array lengths: \" + length + \" vs. \" + argNames.length);\n                 }\n             }\n             else {\n-                argNames = new String[size];\n-                for (int i = 0; i < size; ++i) {\n-                    argNames[i] = \"arg\" + i;\n+                argNames = new String[length];\n+                for (int j = 0; j < length; ++j) {\n+                    argNames[j] = \"arg\" + j;\n                 }\n                 this.setArgumentNames(argNames);\n             }\n-            if (!abstract_) {\n-                for (int i = 0; i < size; ++i) {\n-                    this.addLocalVariable(argNames[i], argTypes[i], start, end);\n+            if (!b) {\n+                for (int k = 0; k < length; ++k) {\n+                    this.addLocalVariable(argNames[k], argTypes[k], start, instructionHandle);\n                 }\n             }\n         }\n     }\n     \n     public MethodGen(final Method method, final String className, final ConstantPoolGen cp) {\n         this(method.getAccessFlags(), Type.getReturnType(method.getSignature()), Type.getArgumentTypes(method.getSignature()), null, method.getName(), className, ((method.getAccessFlags() & 0x500) == 0x0) ? new InstructionList(getByteCodes(method)) : null, cp);\n-        final Attribute[] attributes2;\n-        final Attribute[] attributes = attributes2 = method.getAttributes();\n-        for (Attribute a : attributes2) {\n-            final Attribute attribute = a;\n-            if (a instanceof Code) {\n-                final Code c = (Code)a;\n-                this.setMaxStack(c.getMaxStack());\n-                this.setMaxLocals(c.getMaxLocals());\n-                final CodeException[] ces = c.getExceptionTable();\n-                if (ces != null) {\n-                    for (final CodeException ce : ces) {\n-                        final int type = ce.getCatchType();\n-                        ObjectType cType = null;\n-                        if (type > 0) {\n-                            final String cen = method.getConstantPool().getConstantString(type, (byte)7);\n-                            cType = ObjectType.getInstance(cen);\n+        for (final Attribute attribute : method.getAttributes()) {\n+            if (attribute instanceof Code) {\n+                final Code code = (Code)attribute;\n+                this.setMaxStack(code.getMaxStack());\n+                this.setMaxLocals(code.getMaxLocals());\n+                final CodeException[] exceptionTable = code.getExceptionTable();\n+                if (exceptionTable != null) {\n+                    for (final CodeException ex : exceptionTable) {\n+                        final int catchType = ex.getCatchType();\n+                        ObjectType instance = null;\n+                        if (catchType > 0) {\n+                            instance = ObjectType.getInstance(method.getConstantPool().getConstantString(catchType, (byte)7));\n                         }\n-                        final int endPc = ce.getEndPC();\n-                        final int length = getByteCodes(method).length;\n-                        InstructionHandle end;\n-                        if (length == endPc) {\n-                            end = this.il.getEnd();\n+                        final int endPC = ex.getEndPC();\n+                        InstructionHandle endPc;\n+                        if (getByteCodes(method).length == endPC) {\n+                            endPc = this.il.getEnd();\n                         }\n                         else {\n-                            end = this.il.findHandle(endPc);\n-                            end = end.getPrev();\n+                            endPc = this.il.findHandle(endPC).getPrev();\n                         }\n-                        this.addExceptionHandler(this.il.findHandle(ce.getStartPC()), end, this.il.findHandle(ce.getHandlerPC()), cType);\n+                        this.addExceptionHandler(this.il.findHandle(ex.getStartPC()), endPc, this.il.findHandle(ex.getHandlerPC()), instance);\n                     }\n                 }\n-                final Attribute[] attributes3;\n-                final Attribute[] cAttributes = attributes3 = c.getAttributes();\n-                for (int length4 = attributes3.length, k = 0; k < length4; ++k) {\n-                    final Attribute cAttribute = a = attributes3[k];\n+                for (final Attribute a : code.getAttributes()) {\n                     if (a instanceof LineNumberTable) {\n-                        ((LineNumberTable)a).forEach(l -> {\n-                            final InstructionHandle ih = this.il.findHandle(l.getStartPC());\n+                        ((LineNumberTable)a).forEach(lineNumber -> {\n+                            this.il.findHandle(lineNumber.getStartPC());\n+                            final InstructionHandle ih;\n                             if (ih != null) {\n-                                this.addLineNumber(ih, l.getLineNumber());\n+                                this.addLineNumber(ih, lineNumber.getLineNumber());\n                             }\n                             return;\n                         });\n                     }\n                     else if (a instanceof LocalVariableTable) {\n                         this.updateLocalVariableTable((LocalVariableTable)a);\n                     }\n@@ -222,23 +211,22 @@\n                         this.localVariableTypeTable = (LocalVariableTypeTable)a.copy(cp.getConstantPool());\n                     }\n                     else {\n                         this.addCodeAttribute(a);\n                     }\n                 }\n             }\n-            else if (a instanceof ExceptionTable) {\n-                Collections.addAll(this.throwsList, ((ExceptionTable)a).getExceptionNames());\n+            else if (attribute instanceof ExceptionTable) {\n+                Collections.addAll(this.throwsList, ((ExceptionTable)attribute).getExceptionNames());\n             }\n-            else if (a instanceof Annotations) {\n-                final Annotations runtimeAnnotations = (Annotations)a;\n-                runtimeAnnotations.forEach(element -> this.addAnnotationEntry(new AnnotationEntryGen(element, cp, false)));\n+            else if (attribute instanceof Annotations) {\n+                ((Annotations)attribute).forEach(annotationEntry -> this.addAnnotationEntry(new AnnotationEntryGen(annotationEntry, constantPoolGen, (boolean)(0 != 0))));\n             }\n             else {\n-                this.addAttribute(a);\n+                this.addAttribute(attribute);\n             }\n         }\n     }\n     \n     public void addAnnotationsAsAttribute(final ConstantPoolGen cp) {\n         this.addAll(AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries()));\n     }\n@@ -251,161 +239,155 @@\n         this.throwsList.add(className);\n     }\n     \n     public CodeExceptionGen addExceptionHandler(final InstructionHandle startPc, final InstructionHandle endPc, final InstructionHandle handlerPc, final ObjectType catchType) {\n         if (startPc == null || endPc == null || handlerPc == null) {\n             throw new ClassGenException(\"Exception handler target is null instruction\");\n         }\n-        final CodeExceptionGen c = new CodeExceptionGen(startPc, endPc, handlerPc, catchType);\n-        this.exceptionList.add(c);\n-        return c;\n+        final CodeExceptionGen codeExceptionGen = new CodeExceptionGen(startPc, endPc, handlerPc, catchType);\n+        this.exceptionList.add(codeExceptionGen);\n+        return codeExceptionGen;\n     }\n     \n     public LineNumberGen addLineNumber(final InstructionHandle ih, final int srcLine) {\n-        final LineNumberGen l = new LineNumberGen(ih, srcLine);\n-        this.lineNumberList.add(l);\n-        return l;\n+        final LineNumberGen lineNumberGen = new LineNumberGen(ih, srcLine);\n+        this.lineNumberList.add(lineNumberGen);\n+        return lineNumberGen;\n     }\n     \n     public LocalVariableGen addLocalVariable(final String name, final Type type, final InstructionHandle start, final InstructionHandle end) {\n         return this.addLocalVariable(name, type, this.maxLocals, start, end);\n     }\n     \n     public LocalVariableGen addLocalVariable(final String name, final Type type, final int slot, final InstructionHandle start, final InstructionHandle end) {\n         return this.addLocalVariable(name, type, slot, start, end, slot);\n     }\n     \n     public LocalVariableGen addLocalVariable(final String name, final Type type, final int slot, final InstructionHandle start, final InstructionHandle end, final int origIndex) {\n-        final byte t = type.getType();\n-        if (t != 16) {\n-            final int add = type.getSize();\n-            if (slot + add > this.maxLocals) {\n-                this.maxLocals = slot + add;\n-            }\n-            final LocalVariableGen l = new LocalVariableGen(slot, name, type, start, end, origIndex);\n-            final int i;\n-            if ((i = this.variableList.indexOf(l)) >= 0) {\n-                this.variableList.set(i, l);\n+        if (type.getType() != 16) {\n+            final int size = type.getSize();\n+            if (slot + size > this.maxLocals) {\n+                this.maxLocals = slot + size;\n+            }\n+            final LocalVariableGen localVariableGen = new LocalVariableGen(slot, name, type, start, end, origIndex);\n+            final int index;\n+            if ((index = this.variableList.indexOf(localVariableGen)) >= 0) {\n+                this.variableList.set(index, localVariableGen);\n             }\n             else {\n-                this.variableList.add(l);\n+                this.variableList.add(localVariableGen);\n             }\n-            return l;\n+            return localVariableGen;\n         }\n         throw new IllegalArgumentException(\"Can not use \" + type + \" as type for local variable\");\n     }\n     \n     public void addObserver(final MethodObserver o) {\n         if (this.observers == null) {\n             this.observers = new ArrayList<MethodObserver>();\n         }\n         this.observers.add(o);\n     }\n     \n     public void addParameterAnnotation(final int parameterIndex, final AnnotationEntryGen annotation) {\n         this.ensureExistingParameterAnnotationsUnpacked();\n         if (!this.hasParameterAnnotations) {\n-            final List<AnnotationEntryGen>[] parmList = new List[this.argTypes.length];\n-            this.paramAnnotations = parmList;\n+            this.paramAnnotations = new List[this.argTypes.length];\n             this.hasParameterAnnotations = true;\n         }\n-        final List<AnnotationEntryGen> existingAnnotations = this.paramAnnotations[parameterIndex];\n-        if (existingAnnotations != null) {\n-            existingAnnotations.add(annotation);\n+        final List<AnnotationEntryGen> list = this.paramAnnotations[parameterIndex];\n+        if (list != null) {\n+            list.add(annotation);\n         }\n         else {\n-            final List<AnnotationEntryGen> l = new ArrayList<AnnotationEntryGen>();\n-            l.add(annotation);\n-            this.paramAnnotations[parameterIndex] = l;\n+            final ArrayList list2 = new ArrayList();\n+            list2.add(annotation);\n+            this.paramAnnotations[parameterIndex] = list2;\n         }\n     }\n     \n     public void addParameterAnnotationsAsAttribute(final ConstantPoolGen cp) {\n         if (!this.hasParameterAnnotations) {\n             return;\n         }\n-        final Attribute[] attrs = AnnotationEntryGen.getParameterAnnotationAttributes(cp, (List[])this.paramAnnotations);\n-        if (attrs != null) {\n-            this.addAll(attrs);\n+        final Attribute[] parameterAnnotationAttributes = AnnotationEntryGen.getParameterAnnotationAttributes(cp, (List[])this.paramAnnotations);\n+        if (parameterAnnotationAttributes != null) {\n+            this.addAll(parameterAnnotationAttributes);\n         }\n     }\n     \n     private Attribute[] addRuntimeAnnotationsAsAttribute(final ConstantPoolGen cp) {\n-        final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());\n-        this.addAll(attrs);\n-        return attrs;\n+        final Attribute[] annotationAttributes = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());\n+        this.addAll(annotationAttributes);\n+        return annotationAttributes;\n     }\n     \n     private Attribute[] addRuntimeParameterAnnotationsAsAttribute(final ConstantPoolGen cp) {\n         if (!this.hasParameterAnnotations) {\n             return Attribute.EMPTY_ARRAY;\n         }\n-        final Attribute[] attrs = AnnotationEntryGen.getParameterAnnotationAttributes(cp, (List[])this.paramAnnotations);\n-        this.addAll(attrs);\n-        return attrs;\n+        final Attribute[] parameterAnnotationAttributes = AnnotationEntryGen.getParameterAnnotationAttributes(cp, (List[])this.paramAnnotations);\n+        this.addAll(parameterAnnotationAttributes);\n+        return parameterAnnotationAttributes;\n     }\n     \n     private void adjustLocalVariableTypeTable(final LocalVariableTable lvt) {\n-        final LocalVariable[] lv = lvt.getLocalVariableTable();\n-        for (final LocalVariable element : this.localVariableTypeTable.getLocalVariableTypeTable()) {\n-            for (final LocalVariable l : lv) {\n-                if (element.getName().equals(l.getName()) && element.getIndex() == l.getOrigIndex()) {\n-                    element.setLength(l.getLength());\n-                    element.setStartPC(l.getStartPC());\n-                    element.setIndex(l.getIndex());\n+        final LocalVariable[] localVariableTable = lvt.getLocalVariableTable();\n+        for (final LocalVariable localVariable : this.localVariableTypeTable.getLocalVariableTypeTable()) {\n+            for (final LocalVariable localVariable2 : localVariableTable) {\n+                if (localVariable.getName().equals(localVariable2.getName()) && localVariable.getIndex() == localVariable2.getOrigIndex()) {\n+                    localVariable.setLength(localVariable2.getLength());\n+                    localVariable.setStartPC(localVariable2.getStartPC());\n+                    localVariable.setIndex(localVariable2.getIndex());\n                     break;\n                 }\n             }\n         }\n     }\n     \n     public MethodGen copy(final String className, final ConstantPoolGen cp) {\n-        final Method m = ((MethodGen)this.clone()).getMethod();\n-        final MethodGen mg = new MethodGen(m, className, super.getConstantPool());\n+        final MethodGen methodGen = new MethodGen(((MethodGen)this.clone()).getMethod(), className, super.getConstantPool());\n         if (super.getConstantPool() != cp) {\n-            mg.setConstantPool(cp);\n-            mg.getInstructionList().replaceConstantPool(super.getConstantPool(), cp);\n+            methodGen.setConstantPool(cp);\n+            methodGen.getInstructionList().replaceConstantPool(super.getConstantPool(), cp);\n         }\n-        return mg;\n+        return methodGen;\n     }\n     \n     private void ensureExistingParameterAnnotationsUnpacked() {\n         if (this.haveUnpackedParameterAnnotations) {\n             return;\n         }\n-        final Attribute[] attrs = this.getAttributes();\n-        ParameterAnnotations paramAnnVisAttr = null;\n-        ParameterAnnotations paramAnnInvisAttr = null;\n-        for (final Attribute attribute : attrs) {\n+        final Attribute[] attributes = this.getAttributes();\n+        Object o = null;\n+        Object o2 = null;\n+        for (final Attribute attribute : attributes) {\n             if (attribute instanceof ParameterAnnotations) {\n                 if (!this.hasParameterAnnotations) {\n-                    final List<AnnotationEntryGen>[] parmList = new List[this.argTypes.length];\n-                    Arrays.setAll(this.paramAnnotations = parmList, i -> new ArrayList());\n+                    Arrays.setAll(this.paramAnnotations = new List[this.argTypes.length], p0 -> new ArrayList());\n                 }\n                 this.hasParameterAnnotations = true;\n-                final ParameterAnnotations rpa = (ParameterAnnotations)attribute;\n-                if (rpa instanceof RuntimeVisibleParameterAnnotations) {\n-                    paramAnnVisAttr = rpa;\n+                final ParameterAnnotations parameterAnnotations = (ParameterAnnotations)attribute;\n+                if (parameterAnnotations instanceof RuntimeVisibleParameterAnnotations) {\n+                    o = parameterAnnotations;\n                 }\n                 else {\n-                    paramAnnInvisAttr = rpa;\n+                    o2 = parameterAnnotations;\n                 }\n-                final ParameterAnnotationEntry[] parameterAnnotationEntries = rpa.getParameterAnnotationEntries();\n+                final ParameterAnnotationEntry[] parameterAnnotationEntries = parameterAnnotations.getParameterAnnotationEntries();\n                 for (int j = 0; j < parameterAnnotationEntries.length; ++j) {\n-                    final ParameterAnnotationEntry immutableArray = rpa.getParameterAnnotationEntries()[j];\n-                    final List<AnnotationEntryGen> mutable = this.makeMutableVersion(immutableArray.getAnnotationEntries());\n-                    this.paramAnnotations[j].addAll(mutable);\n+                    this.paramAnnotations[j].addAll(this.makeMutableVersion(parameterAnnotations.getParameterAnnotationEntries()[j].getAnnotationEntries()));\n                 }\n             }\n         }\n-        if (paramAnnVisAttr != null) {\n-            this.removeAttribute((Attribute)paramAnnVisAttr);\n+        if (o != null) {\n+            this.removeAttribute((Attribute)o);\n         }\n-        if (paramAnnInvisAttr != null) {\n-            this.removeAttribute((Attribute)paramAnnInvisAttr);\n+        if (o2 != null) {\n+            this.removeAttribute((Attribute)o2);\n         }\n         this.haveUnpackedParameterAnnotations = true;\n     }\n     \n     public boolean equals(final Object obj) {\n         return MethodGen.bcelComparator.equals((Object)this, obj);\n     }\n@@ -439,74 +421,70 @@\n     }\n     \n     public Attribute[] getCodeAttributes() {\n         return this.codeAttrsList.toArray(Attribute.EMPTY_ARRAY);\n     }\n     \n     private CodeException[] getCodeExceptions() {\n-        final int size = this.exceptionList.size();\n-        final CodeException[] cExc = new CodeException[size];\n-        Arrays.setAll(cExc, i -> ((CodeExceptionGen)this.exceptionList.get(i)).getCodeException(super.getConstantPool()));\n-        return cExc;\n+        final CodeException[] array = new CodeException[this.exceptionList.size()];\n+        Arrays.setAll(array, n2 -> ((CodeExceptionGen)this.exceptionList.get(n2)).getCodeException(super.getConstantPool()));\n+        return array;\n     }\n     \n     public CodeExceptionGen[] getExceptionHandlers() {\n         return this.exceptionList.toArray(CodeExceptionGen.EMPTY_ARRAY);\n     }\n     \n     public String[] getExceptions() {\n         return this.throwsList.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n     }\n     \n     private ExceptionTable getExceptionTable(final ConstantPoolGen cp) {\n         final int size = this.throwsList.size();\n-        final int[] ex = new int[size];\n-        Arrays.setAll(ex, i -> cp.addClass((String)this.throwsList.get(i)));\n-        return new ExceptionTable(cp.addUtf8(\"Exceptions\"), 2 + 2 * size, ex, cp.getConstantPool());\n+        final int[] array = new int[size];\n+        Arrays.setAll(array, n2 -> constantPoolGen.addClass((String)this.throwsList.get(n2)));\n+        return new ExceptionTable(cp.addUtf8(\"Exceptions\"), 2 + 2 * size, array, cp.getConstantPool());\n     }\n     \n     public InstructionList getInstructionList() {\n         return this.il;\n     }\n     \n     public LineNumberGen[] getLineNumbers() {\n         return this.lineNumberList.toArray(LineNumberGen.EMPTY_ARRAY);\n     }\n     \n     public LineNumberTable getLineNumberTable(final ConstantPoolGen cp) {\n-        final int size = this.lineNumberList.size();\n-        final LineNumber[] ln = new LineNumber[size];\n-        Arrays.setAll(ln, i -> ((LineNumberGen)this.lineNumberList.get(i)).getLineNumber());\n-        return new LineNumberTable(cp.addUtf8(\"LineNumberTable\"), 2 + ln.length * 4, ln, cp.getConstantPool());\n+        final LineNumber[] array = new LineNumber[this.lineNumberList.size()];\n+        Arrays.setAll(array, n2 -> ((LineNumberGen)this.lineNumberList.get(n2)).getLineNumber());\n+        return new LineNumberTable(cp.addUtf8(\"LineNumberTable\"), 2 + array.length * 4, array, cp.getConstantPool());\n     }\n     \n     public LocalVariableGen[] getLocalVariables() {\n         final int size = this.variableList.size();\n-        final LocalVariableGen[] lg = new LocalVariableGen[size];\n-        this.variableList.toArray(lg);\n+        final LocalVariableGen[] a = new LocalVariableGen[size];\n+        this.variableList.toArray(a);\n         for (int i = 0; i < size; ++i) {\n-            if (lg[i].getStart() == null && this.il != null) {\n-                lg[i].setStart(this.il.getStart());\n+            if (a[i].getStart() == null && this.il != null) {\n+                a[i].setStart(this.il.getStart());\n             }\n-            if (lg[i].getEnd() == null && this.il != null) {\n-                lg[i].setEnd(this.il.getEnd());\n+            if (a[i].getEnd() == null && this.il != null) {\n+                a[i].setEnd(this.il.getEnd());\n             }\n         }\n         if (size > 1) {\n-            Arrays.sort(lg, Comparator.comparingInt(LocalVariableGen::getIndex));\n+            Arrays.sort(a, Comparator.comparingInt(LocalVariableGen::getIndex));\n         }\n-        return lg;\n+        return a;\n     }\n     \n     public LocalVariableTable getLocalVariableTable(final ConstantPoolGen cp) {\n-        final LocalVariableGen[] lg = this.getLocalVariables();\n-        final int size = lg.length;\n-        final LocalVariable[] lv = new LocalVariable[size];\n-        Arrays.setAll(lv, i -> lg[i].getLocalVariable(cp));\n-        return new LocalVariableTable(cp.addUtf8(\"LocalVariableTable\"), 2 + lv.length * 10, lv, cp.getConstantPool());\n+        final LocalVariable[] array = new LocalVariable[this.getLocalVariables().length];\n+        Arrays.setAll(array, n2 -> array2[n2].getLocalVariable(constantPoolGen));\n+        return new LocalVariableTable(cp.addUtf8(\"LocalVariableTable\"), 2 + array.length * 10, array, cp.getConstantPool());\n     }\n     \n     public LocalVariableTypeTable getLocalVariableTypeTable() {\n         return this.localVariableTypeTable;\n     }\n     \n     public int getMaxLocals() {\n@@ -515,77 +493,76 @@\n     \n     public int getMaxStack() {\n         return this.maxStack;\n     }\n     \n     public Method getMethod() {\n         final String signature = this.getSignature();\n-        final ConstantPoolGen cp = super.getConstantPool();\n-        final int nameIndex = cp.addUtf8(super.getName());\n-        final int signatureIndex = cp.addUtf8(signature);\n-        final byte[] byteCode = (byte[])((this.il != null) ? this.il.getByteCode() : null);\n-        LineNumberTable lnt = null;\n-        LocalVariableTable lvt = null;\n+        final ConstantPoolGen constantPool = super.getConstantPool();\n+        final int addUtf8 = constantPool.addUtf8(super.getName());\n+        final int addUtf9 = constantPool.addUtf8(signature);\n+        final byte[] array = (byte[])((this.il != null) ? this.il.getByteCode() : null);\n+        Object lineNumberTable = null;\n+        Object localVariableTable = null;\n         if (!this.variableList.isEmpty() && !this.stripAttributes) {\n-            this.updateLocalVariableTable(this.getLocalVariableTable(cp));\n-            this.addCodeAttribute((Attribute)(lvt = this.getLocalVariableTable(cp)));\n+            this.updateLocalVariableTable(this.getLocalVariableTable(constantPool));\n+            this.addCodeAttribute((Attribute)(localVariableTable = this.getLocalVariableTable(constantPool)));\n         }\n         if (this.localVariableTypeTable != null) {\n-            if (lvt != null) {\n-                this.adjustLocalVariableTypeTable(lvt);\n+            if (localVariableTable != null) {\n+                this.adjustLocalVariableTypeTable((LocalVariableTable)localVariableTable);\n             }\n             this.addCodeAttribute((Attribute)this.localVariableTypeTable);\n         }\n         if (!this.lineNumberList.isEmpty() && !this.stripAttributes) {\n-            this.addCodeAttribute((Attribute)(lnt = this.getLineNumberTable(cp)));\n+            this.addCodeAttribute((Attribute)(lineNumberTable = this.getLineNumberTable(constantPool)));\n         }\n-        final Attribute[] codeAttrs = this.getCodeAttributes();\n-        int attrsLen = 0;\n-        for (final Attribute codeAttr : codeAttrs) {\n-            attrsLen += codeAttr.getLength() + 6;\n-        }\n-        final CodeException[] cExc = this.getCodeExceptions();\n-        final int excLen = cExc.length * 8;\n-        Code code = null;\n-        if (byteCode != null && !this.isAbstract() && !this.isNative()) {\n-            final Attribute[] attributes2;\n-            final Attribute[] attributes = attributes2 = this.getAttributes();\n-            for (final Attribute a : attributes2) {\n-                if (a instanceof Code) {\n-                    this.removeAttribute(a);\n-                }\n-            }\n-            code = new Code(cp.addUtf8(\"Code\"), 8 + byteCode.length + 2 + excLen + 2 + attrsLen, this.maxStack, this.maxLocals, byteCode, cExc, codeAttrs, cp.getConstantPool());\n-            this.addAttribute((Attribute)code);\n-        }\n-        final Attribute[] annotations = this.addRuntimeAnnotationsAsAttribute(cp);\n-        final Attribute[] parameterAnnotations = this.addRuntimeParameterAnnotationsAsAttribute(cp);\n-        ExceptionTable et = null;\n+        final Attribute[] codeAttributes = this.getCodeAttributes();\n+        int n = 0;\n+        final Attribute[] array2 = codeAttributes;\n+        for (int length = array2.length, i = 0; i < length; ++i) {\n+            n += array2[i].getLength() + 6;\n+        }\n+        final CodeException[] codeExceptions = this.getCodeExceptions();\n+        final int n2 = codeExceptions.length * 8;\n+        Object o = null;\n+        if (array != null && !this.isAbstract() && !this.isNative()) {\n+            for (final Attribute attribute : this.getAttributes()) {\n+                if (attribute instanceof Code) {\n+                    this.removeAttribute(attribute);\n+                }\n+            }\n+            o = new Code(constantPool.addUtf8(\"Code\"), 8 + array.length + 2 + n2 + 2 + n, this.maxStack, this.maxLocals, array, codeExceptions, codeAttributes, constantPool.getConstantPool());\n+            this.addAttribute((Attribute)o);\n+        }\n+        final Attribute[] addRuntimeAnnotationsAsAttribute = this.addRuntimeAnnotationsAsAttribute(constantPool);\n+        final Attribute[] addRuntimeParameterAnnotationsAsAttribute = this.addRuntimeParameterAnnotationsAsAttribute(constantPool);\n+        Object exceptionTable = null;\n         if (!this.throwsList.isEmpty()) {\n-            this.addAttribute((Attribute)(et = this.getExceptionTable(cp)));\n+            this.addAttribute((Attribute)(exceptionTable = this.getExceptionTable(constantPool)));\n         }\n-        final Method m = new Method(super.getAccessFlags(), nameIndex, signatureIndex, this.getAttributes(), cp.getConstantPool());\n-        if (lvt != null) {\n-            this.removeCodeAttribute((Attribute)lvt);\n+        final Method method = new Method(super.getAccessFlags(), addUtf8, addUtf9, this.getAttributes(), constantPool.getConstantPool());\n+        if (localVariableTable != null) {\n+            this.removeCodeAttribute((Attribute)localVariableTable);\n         }\n         if (this.localVariableTypeTable != null) {\n             this.removeCodeAttribute((Attribute)this.localVariableTypeTable);\n         }\n-        if (lnt != null) {\n-            this.removeCodeAttribute((Attribute)lnt);\n+        if (lineNumberTable != null) {\n+            this.removeCodeAttribute((Attribute)lineNumberTable);\n         }\n-        if (code != null) {\n-            this.removeAttribute((Attribute)code);\n+        if (o != null) {\n+            this.removeAttribute((Attribute)o);\n         }\n-        if (et != null) {\n-            this.removeAttribute((Attribute)et);\n+        if (exceptionTable != null) {\n+            this.removeAttribute((Attribute)exceptionTable);\n         }\n-        this.removeRuntimeAttributes(annotations);\n-        this.removeRuntimeAttributes(parameterAnnotations);\n-        return m;\n+        this.removeRuntimeAttributes(addRuntimeAnnotationsAsAttribute);\n+        this.removeRuntimeAttributes(addRuntimeParameterAnnotationsAsAttribute);\n+        return method;\n     }\n     \n     public Type getReturnType() {\n         return this.getType();\n     }\n     \n     public String getSignature() {\n@@ -593,19 +570,19 @@\n     }\n     \n     public int hashCode() {\n         return MethodGen.bcelComparator.hashCode((Object)this);\n     }\n     \n     private List<AnnotationEntryGen> makeMutableVersion(final AnnotationEntry[] mutableArray) {\n-        final List<AnnotationEntryGen> result = new ArrayList<AnnotationEntryGen>();\n-        for (final AnnotationEntry element : mutableArray) {\n-            result.add(new AnnotationEntryGen(element, this.getConstantPool(), false));\n+        final ArrayList list = new ArrayList();\n+        for (int length = mutableArray.length, i = 0; i < length; ++i) {\n+            list.add(new AnnotationEntryGen(mutableArray[i], this.getConstantPool(), false));\n         }\n-        return result;\n+        return list;\n     }\n     \n     public void removeCodeAttribute(final Attribute a) {\n         this.codeAttrsList.remove(a);\n     }\n     \n     public void removeCodeAttributes() {\n@@ -650,24 +627,25 @@\n     public void removeLocalVariableTypeTable() {\n         this.localVariableTypeTable = null;\n     }\n     \n     public void removeNOPs() {\n         if (this.il != null) {\n             InstructionHandle next;\n-            for (InstructionHandle ih = this.il.getStart(); ih != null; ih = next) {\n-                next = ih.getNext();\n-                if (next != null && ih.getInstruction() instanceof NOP) {\n+            for (InstructionHandle start = this.il.getStart(); start != null; start = next) {\n+                next = start.getNext();\n+                if (next != null && start.getInstruction() instanceof NOP) {\n                     try {\n-                        this.il.delete(ih);\n+                        this.il.delete(start);\n                     }\n-                    catch (final TargetLostException e) {\n-                        for (final InstructionHandle target : e.getTargets()) {\n-                            for (final InstructionTargeter targeter : target.getTargeters()) {\n-                                targeter.updateTarget(target, next);\n+                    catch (final TargetLostException ex) {\n+                        for (final InstructionHandle instructionHandle : ex.getTargets()) {\n+                            final InstructionTargeter[] targeters = instructionHandle.getTargeters();\n+                            for (int length2 = targeters.length, j = 0; j < length2; ++j) {\n+                                targeters[j].updateTarget(instructionHandle, next);\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n     }\n@@ -675,16 +653,16 @@\n     public void removeObserver(final MethodObserver o) {\n         if (this.observers != null) {\n             this.observers.remove(o);\n         }\n     }\n     \n     public void removeRuntimeAttributes(final Attribute[] attrs) {\n-        for (final Attribute attr : attrs) {\n-            this.removeAttribute(attr);\n+        for (int length = attrs.length, i = 0; i < length; ++i) {\n+            this.removeAttribute(attrs[i]);\n         }\n     }\n     \n     public void setArgumentName(final int i, final String name) {\n         this.argNames[i] = name;\n     }\n     \n@@ -706,30 +684,31 @@\n     \n     public void setInstructionList(final InstructionList il) {\n         this.il = il;\n     }\n     \n     public void setMaxLocals() {\n         if (this.il != null) {\n-            int max = this.isStatic() ? 0 : 1;\n+            int maxLocals = this.isStatic() ? 0 : 1;\n             if (this.argTypes != null) {\n-                for (final Type argType : this.argTypes) {\n-                    max += argType.getSize();\n+                final Type[] argTypes = this.argTypes;\n+                for (int length = argTypes.length, i = 0; i < length; ++i) {\n+                    maxLocals += argTypes[i].getSize();\n                 }\n             }\n-            for (InstructionHandle ih = this.il.getStart(); ih != null; ih = ih.getNext()) {\n-                final Instruction ins = ih.getInstruction();\n-                if (ins instanceof LocalVariableInstruction || ins instanceof RET || ins instanceof IINC) {\n-                    final int index = ((IndexedInstruction)ins).getIndex() + ((TypedInstruction)ins).getType(super.getConstantPool()).getSize();\n-                    if (index > max) {\n-                        max = index;\n+            for (InstructionHandle instructionHandle = this.il.getStart(); instructionHandle != null; instructionHandle = instructionHandle.getNext()) {\n+                final Instruction instruction = instructionHandle.getInstruction();\n+                if (instruction instanceof LocalVariableInstruction || instruction instanceof RET || instruction instanceof IINC) {\n+                    final int n = ((IndexedInstruction)instruction).getIndex() + ((TypedInstruction)instruction).getType(super.getConstantPool()).getSize();\n+                    if (n > maxLocals) {\n+                        maxLocals = n;\n                     }\n                 }\n             }\n-            this.maxLocals = max;\n+            this.maxLocals = maxLocals;\n         }\n         else {\n             this.maxLocals = 0;\n         }\n     }\n     \n     public void setMaxLocals(final int m) {\n@@ -754,48 +733,47 @@\n     }\n     \n     public void stripAttributes(final boolean flag) {\n         this.stripAttributes = flag;\n     }\n     \n     public final String toString() {\n-        final String access = Utility.accessToString(super.getAccessFlags());\n-        String signature = Type.getMethodSignature(super.getType(), this.argTypes);\n-        signature = Utility.methodSignatureToString(signature, super.getName(), access, true, this.getLocalVariableTable(super.getConstantPool()));\n-        final StringBuilder buf = new StringBuilder(signature);\n-        for (final Attribute a : this.getAttributes()) {\n-            if (!(a instanceof Code) && !(a instanceof ExceptionTable)) {\n-                buf.append(\" [\").append(a).append(\"]\");\n+        final StringBuilder sb = new StringBuilder(Utility.methodSignatureToString(Type.getMethodSignature(super.getType(), this.argTypes), super.getName(), Utility.accessToString(super.getAccessFlags()), true, this.getLocalVariableTable(super.getConstantPool())));\n+        for (final Attribute obj : this.getAttributes()) {\n+            if (!(obj instanceof Code) && !(obj instanceof ExceptionTable)) {\n+                sb.append(\" [\").append(obj).append(\"]\");\n             }\n         }\n         if (!this.throwsList.isEmpty()) {\n-            for (final String throwsDescriptor : this.throwsList) {\n-                buf.append(\"\\n\\t\\tthrows \").append(throwsDescriptor);\n+            final Iterator<String> iterator = this.throwsList.iterator();\n+            while (iterator.hasNext()) {\n+                sb.append(\"\\n\\t\\tthrows \").append(iterator.next());\n             }\n         }\n-        return buf.toString();\n+        return sb.toString();\n     }\n     \n     public void update() {\n         if (this.observers != null) {\n-            for (final MethodObserver observer : this.observers) {\n-                observer.notify(this);\n+            final Iterator<MethodObserver> iterator = this.observers.iterator();\n+            while (iterator.hasNext()) {\n+                ((MethodObserver)iterator.next()).notify(this);\n             }\n         }\n     }\n     \n     private void updateLocalVariableTable(final LocalVariableTable a) {\n         this.removeLocalVariables();\n-        for (final LocalVariable l : a.getLocalVariableTable()) {\n-            InstructionHandle start = this.il.findHandle(l.getStartPC());\n-            final InstructionHandle end = this.il.findHandle(l.getStartPC() + l.getLength());\n+        for (final LocalVariable localVariable : a.getLocalVariableTable()) {\n+            InstructionHandle start = this.il.findHandle(localVariable.getStartPC());\n+            final InstructionHandle handle = this.il.findHandle(localVariable.getStartPC() + localVariable.getLength());\n             if (null == start) {\n                 start = this.il.getStart();\n             }\n-            this.addLocalVariable(l.getName(), Type.getType(l.getSignature()), l.getIndex(), start, end, l.getOrigIndex());\n+            this.addLocalVariable(localVariable.getName(), Type.getType(localVariable.getSignature()), localVariable.getIndex(), start, handle, localVariable.getOrigIndex());\n         }\n     }\n     \n     static {\n         MethodGen.bcelComparator = (BCELComparator)new MethodGen.MethodGen$1();\n     }\n }\n"}]}
