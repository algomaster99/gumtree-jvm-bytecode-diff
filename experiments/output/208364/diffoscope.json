{"diffoscope-json-version": 1, "source1": "first/Tailer.class", "source2": "second/Tailer.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -30,91 +30,91 @@\n     private volatile boolean run;\n     \n     public static Tailer.Builder builder() {\n         return new Tailer.Builder();\n     }\n     \n     @Deprecated\n-    public static Tailer create(final File file, final Charset charset, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen, final int bufferSize) {\n-        return ((Tailer.Builder)((Tailer.Builder)((Tailer.Builder)builder().setFile(file)).setTailerListener(listener).setCharset(charset)).setDelayDuration(Duration.ofMillis(delayMillis)).setTailFromEnd(end).setReOpen(reOpen).setBufferSize(bufferSize)).get();\n+    public static Tailer create(final File file, final Charset charset, final TailerListener tailerListener, final long millis, final boolean tailFromEnd, final boolean reOpen, final int bufferSize) {\n+        return ((Tailer.Builder)((Tailer.Builder)((Tailer.Builder)builder().setFile(file)).setTailerListener(tailerListener).setCharset(charset)).setDelayDuration(Duration.ofMillis(millis)).setTailFromEnd(tailFromEnd).setReOpen(reOpen).setBufferSize(bufferSize)).get();\n     }\n     \n     @Deprecated\n-    public static Tailer create(final File file, final TailerListener listener) {\n-        return ((Tailer.Builder)builder().setFile(file)).setTailerListener(listener).get();\n+    public static Tailer create(final File file, final TailerListener tailerListener) {\n+        return ((Tailer.Builder)builder().setFile(file)).setTailerListener(tailerListener).get();\n     }\n     \n     @Deprecated\n-    public static Tailer create(final File file, final TailerListener listener, final long delayMillis) {\n-        return ((Tailer.Builder)builder().setFile(file)).setTailerListener(listener).setDelayDuration(Duration.ofMillis(delayMillis)).get();\n+    public static Tailer create(final File file, final TailerListener tailerListener, final long millis) {\n+        return ((Tailer.Builder)builder().setFile(file)).setTailerListener(tailerListener).setDelayDuration(Duration.ofMillis(millis)).get();\n     }\n     \n     @Deprecated\n-    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end) {\n-        return ((Tailer.Builder)builder().setFile(file)).setTailerListener(listener).setDelayDuration(Duration.ofMillis(delayMillis)).setTailFromEnd(end).get();\n+    public static Tailer create(final File file, final TailerListener tailerListener, final long millis, final boolean tailFromEnd) {\n+        return ((Tailer.Builder)builder().setFile(file)).setTailerListener(tailerListener).setDelayDuration(Duration.ofMillis(millis)).setTailFromEnd(tailFromEnd).get();\n     }\n     \n     @Deprecated\n-    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen) {\n-        return ((Tailer.Builder)builder().setFile(file)).setTailerListener(listener).setDelayDuration(Duration.ofMillis(delayMillis)).setTailFromEnd(end).setReOpen(reOpen).get();\n+    public static Tailer create(final File file, final TailerListener tailerListener, final long millis, final boolean tailFromEnd, final boolean reOpen) {\n+        return ((Tailer.Builder)builder().setFile(file)).setTailerListener(tailerListener).setDelayDuration(Duration.ofMillis(millis)).setTailFromEnd(tailFromEnd).setReOpen(reOpen).get();\n     }\n     \n     @Deprecated\n-    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen, final int bufferSize) {\n-        return ((Tailer.Builder)((Tailer.Builder)builder().setFile(file)).setTailerListener(listener).setDelayDuration(Duration.ofMillis(delayMillis)).setTailFromEnd(end).setReOpen(reOpen).setBufferSize(bufferSize)).get();\n+    public static Tailer create(final File file, final TailerListener tailerListener, final long millis, final boolean tailFromEnd, final boolean reOpen, final int bufferSize) {\n+        return ((Tailer.Builder)((Tailer.Builder)builder().setFile(file)).setTailerListener(tailerListener).setDelayDuration(Duration.ofMillis(millis)).setTailFromEnd(tailFromEnd).setReOpen(reOpen).setBufferSize(bufferSize)).get();\n     }\n     \n     @Deprecated\n-    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end, final int bufferSize) {\n-        return ((Tailer.Builder)((Tailer.Builder)builder().setFile(file)).setTailerListener(listener).setDelayDuration(Duration.ofMillis(delayMillis)).setTailFromEnd(end).setBufferSize(bufferSize)).get();\n+    public static Tailer create(final File file, final TailerListener tailerListener, final long millis, final boolean tailFromEnd, final int bufferSize) {\n+        return ((Tailer.Builder)((Tailer.Builder)builder().setFile(file)).setTailerListener(tailerListener).setDelayDuration(Duration.ofMillis(millis)).setTailFromEnd(tailFromEnd).setBufferSize(bufferSize)).get();\n     }\n     \n     @Deprecated\n-    public Tailer(final File file, final Charset charset, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen, final int bufSize) {\n-        this((Tailer.Tailable)new Tailer.TailablePath(file.toPath(), new LinkOption[0], (Tailer.Tailer$1)null), charset, listener, Duration.ofMillis(delayMillis), end, reOpen, bufSize);\n+    public Tailer(final File file, final Charset charset, final TailerListener tailerListener, final long millis, final boolean b, final boolean b2, final int n) {\n+        this((Tailer.Tailable)new Tailer.TailablePath(file.toPath(), new LinkOption[0], (Tailer.Tailer$1)null), charset, tailerListener, Duration.ofMillis(millis), b, b2, n);\n     }\n     \n     @Deprecated\n-    public Tailer(final File file, final TailerListener listener) {\n-        this(file, listener, 1000L);\n+    public Tailer(final File file, final TailerListener tailerListener) {\n+        this(file, tailerListener, 1000L);\n     }\n     \n     @Deprecated\n-    public Tailer(final File file, final TailerListener listener, final long delayMillis) {\n-        this(file, listener, delayMillis, false);\n+    public Tailer(final File file, final TailerListener tailerListener, final long n) {\n+        this(file, tailerListener, n, false);\n     }\n     \n     @Deprecated\n-    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end) {\n-        this(file, listener, delayMillis, end, 8192);\n+    public Tailer(final File file, final TailerListener tailerListener, final long n, final boolean b) {\n+        this(file, tailerListener, n, b, 8192);\n     }\n     \n     @Deprecated\n-    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen) {\n-        this(file, listener, delayMillis, end, reOpen, 8192);\n+    public Tailer(final File file, final TailerListener tailerListener, final long n, final boolean b, final boolean b2) {\n+        this(file, tailerListener, n, b, b2, 8192);\n     }\n     \n     @Deprecated\n-    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen, final int bufferSize) {\n-        this(file, Tailer.DEFAULT_CHARSET, listener, delayMillis, end, reOpen, bufferSize);\n+    public Tailer(final File file, final TailerListener tailerListener, final long n, final boolean b, final boolean b2, final int n2) {\n+        this(file, Tailer.DEFAULT_CHARSET, tailerListener, n, b, b2, n2);\n     }\n     \n     @Deprecated\n-    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end, final int bufferSize) {\n-        this(file, listener, delayMillis, end, false, bufferSize);\n+    public Tailer(final File file, final TailerListener tailerListener, final long n, final boolean b, final int n2) {\n+        this(file, tailerListener, n, b, false, n2);\n     }\n     \n-    private Tailer(final Tailer.Tailable tailable, final Charset charset, final TailerListener listener, final Duration delayDuration, final boolean end, final boolean reOpen, final int bufferSize) {\n+    private Tailer(final Tailer.Tailable obj, final Charset charset, final TailerListener obj2, final Duration delayDuration, final boolean tailAtEnd, final boolean reOpen, final int n) {\n         this.run = true;\n-        this.tailable = Objects.requireNonNull(tailable, \"tailable\");\n-        this.listener = Objects.requireNonNull(listener, \"listener\");\n+        this.tailable = Objects.requireNonNull(obj, \"tailable\");\n+        this.listener = Objects.requireNonNull(obj2, \"listener\");\n         this.delayDuration = delayDuration;\n-        this.tailAtEnd = end;\n-        this.inbuf = IOUtils.byteArray(bufferSize);\n-        listener.init(this);\n+        this.tailAtEnd = tailAtEnd;\n+        this.inbuf = IOUtils.byteArray(n);\n+        obj2.init(this);\n         this.reOpen = reOpen;\n         this.charset = charset;\n     }\n     \n     @Override\n     public void close() {\n         this.run = false;\n@@ -140,138 +140,137 @@\n         return this.run;\n     }\n     \n     public Tailer.Tailable getTailable() {\n         return this.tailable;\n     }\n     \n-    private long readLines(final Tailer.RandomAccessResourceBridge reader) throws IOException {\n-        try (final ByteArrayOutputStream lineBuf = new ByteArrayOutputStream(64)) {\n-            long rePos;\n-            long pos = rePos = reader.getPointer();\n-            boolean seenCR = false;\n-            int num;\n-            while (this.getRun() && (num = reader.read(this.inbuf)) != -1) {\n-                for (int i = 0; i < num; ++i) {\n-                    final byte ch = this.inbuf[i];\n-                    switch (ch) {\n+    private long readLines(final Tailer.RandomAccessResourceBridge randomAccessResourceBridge) throws IOException {\n+        try (final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(64)) {\n+            long pointer2;\n+            long pointer = pointer2 = randomAccessResourceBridge.getPointer();\n+            int n = 0;\n+            int read;\n+            while (this.getRun() && (read = randomAccessResourceBridge.read(this.inbuf)) != -1) {\n+                for (int i = 0; i < read; ++i) {\n+                    final byte b = this.inbuf[i];\n+                    switch (b) {\n                         case 10: {\n-                            seenCR = false;\n-                            this.listener.handle(new String(lineBuf.toByteArray(), this.charset));\n-                            lineBuf.reset();\n-                            rePos = pos + i + 1L;\n+                            n = 0;\n+                            this.listener.handle(new String(byteArrayOutputStream.toByteArray(), this.charset));\n+                            byteArrayOutputStream.reset();\n+                            pointer2 = pointer + i + 1L;\n                             break;\n                         }\n                         case 13: {\n-                            if (seenCR) {\n-                                lineBuf.write(13);\n+                            if (n != 0) {\n+                                byteArrayOutputStream.write(13);\n                             }\n-                            seenCR = true;\n+                            n = 1;\n                             break;\n                         }\n                         default: {\n-                            if (seenCR) {\n-                                seenCR = false;\n-                                this.listener.handle(new String(lineBuf.toByteArray(), this.charset));\n-                                lineBuf.reset();\n-                                rePos = pos + i + 1L;\n+                            if (n != 0) {\n+                                n = 0;\n+                                this.listener.handle(new String(byteArrayOutputStream.toByteArray(), this.charset));\n+                                byteArrayOutputStream.reset();\n+                                pointer2 = pointer + i + 1L;\n                             }\n-                            lineBuf.write(ch);\n+                            byteArrayOutputStream.write(b);\n                             break;\n                         }\n                     }\n                 }\n-                pos = reader.getPointer();\n+                pointer = randomAccessResourceBridge.getPointer();\n             }\n-            reader.seek(rePos);\n+            randomAccessResourceBridge.seek(pointer2);\n             if (this.listener instanceof TailerListenerAdapter) {\n                 ((TailerListenerAdapter)this.listener).endOfFileReached();\n             }\n-            return rePos;\n+            return pointer2;\n         }\n     }\n     \n     @Override\n     public void run() {\n-        Tailer.RandomAccessResourceBridge reader = null;\n+        Tailer.RandomAccessResourceBridge randomAccessResourceBridge = null;\n         try {\n-            FileTime last = FileTimes.EPOCH;\n-            long position = 0L;\n-            while (this.getRun() && reader == null) {\n+            FileTime fileTime = FileTimes.EPOCH;\n+            long n = 0L;\n+            while (this.getRun() && randomAccessResourceBridge == null) {\n                 try {\n-                    reader = this.tailable.getRandomAccess(\"r\");\n+                    randomAccessResourceBridge = this.tailable.getRandomAccess(\"r\");\n                 }\n-                catch (final FileNotFoundException e) {\n+                catch (final FileNotFoundException ex) {\n                     this.listener.fileNotFound();\n                 }\n-                if (reader == null) {\n+                if (randomAccessResourceBridge == null) {\n                     ThreadUtils.sleep(this.delayDuration);\n                 }\n                 else {\n-                    position = (this.tailAtEnd ? this.tailable.size() : 0L);\n-                    last = this.tailable.lastModifiedFileTime();\n-                    reader.seek(position);\n+                    n = (this.tailAtEnd ? this.tailable.size() : 0L);\n+                    fileTime = this.tailable.lastModifiedFileTime();\n+                    randomAccessResourceBridge.seek(n);\n                 }\n             }\n             while (this.getRun()) {\n-                final boolean newer = this.tailable.isNewer(last);\n-                final long length = this.tailable.size();\n-                if (length < position) {\n+                final boolean newer = this.tailable.isNewer(fileTime);\n+                final long size = this.tailable.size();\n+                if (size < n) {\n                     this.listener.fileRotated();\n-                    try (final Tailer.RandomAccessResourceBridge save = reader) {\n-                        reader = this.tailable.getRandomAccess(\"r\");\n+                    try (final Tailer.RandomAccessResourceBridge randomAccessResourceBridge2 = randomAccessResourceBridge) {\n+                        randomAccessResourceBridge = this.tailable.getRandomAccess(\"r\");\n                         try {\n-                            this.readLines(save);\n+                            this.readLines(randomAccessResourceBridge2);\n                         }\n-                        catch (final IOException ioe) {\n-                            this.listener.handle((Exception)ioe);\n+                        catch (final IOException ex2) {\n+                            this.listener.handle((Exception)ex2);\n                         }\n-                        position = 0L;\n+                        n = 0L;\n                     }\n-                    catch (final FileNotFoundException e2) {\n+                    catch (final FileNotFoundException ex3) {\n                         this.listener.fileNotFound();\n                         ThreadUtils.sleep(this.delayDuration);\n                     }\n                 }\n                 else {\n-                    if (length > position) {\n-                        position = this.readLines(reader);\n-                        last = this.tailable.lastModifiedFileTime();\n+                    if (size > n) {\n+                        n = this.readLines(randomAccessResourceBridge);\n+                        fileTime = this.tailable.lastModifiedFileTime();\n                     }\n                     else if (newer) {\n-                        position = 0L;\n-                        reader.seek(position);\n-                        position = this.readLines(reader);\n-                        last = this.tailable.lastModifiedFileTime();\n+                        randomAccessResourceBridge.seek(0L);\n+                        n = this.readLines(randomAccessResourceBridge);\n+                        fileTime = this.tailable.lastModifiedFileTime();\n                     }\n-                    if (this.reOpen && reader != null) {\n-                        reader.close();\n+                    if (this.reOpen && randomAccessResourceBridge != null) {\n+                        randomAccessResourceBridge.close();\n                     }\n                     ThreadUtils.sleep(this.delayDuration);\n                     if (!this.getRun() || !this.reOpen) {\n                         continue;\n                     }\n-                    reader = this.tailable.getRandomAccess(\"r\");\n-                    reader.seek(position);\n+                    randomAccessResourceBridge = this.tailable.getRandomAccess(\"r\");\n+                    randomAccessResourceBridge.seek(n);\n                 }\n             }\n         }\n-        catch (final InterruptedException e3) {\n+        catch (final InterruptedException ex4) {\n             Thread.currentThread().interrupt();\n-            this.listener.handle((Exception)e3);\n+            this.listener.handle((Exception)ex4);\n         }\n-        catch (final Exception e4) {\n-            this.listener.handle(e4);\n+        catch (final Exception ex5) {\n+            this.listener.handle(ex5);\n         }\n         finally {\n             try {\n-                IOUtils.close((Closeable)reader);\n+                IOUtils.close((Closeable)randomAccessResourceBridge);\n             }\n-            catch (final IOException e5) {\n-                this.listener.handle((Exception)e5);\n+            catch (final IOException ex6) {\n+                this.listener.handle((Exception)ex6);\n             }\n             this.close();\n         }\n     }\n     \n     @Deprecated\n     public void stop() {\n"}]}
