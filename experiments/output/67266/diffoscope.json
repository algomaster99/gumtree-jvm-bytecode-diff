{"diffoscope-json-version": 1, "source1": "first/AbstractConfiguration.class", "source2": "second/AbstractConfiguration.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -186,36 +186,36 @@\n     }\n     \n     public final void setSynchronizer(final Synchronizer synchronizer) {\n         this.synchronizer = synchronizer;\n     }\n     \n     public final void lock(final LockMode mode) {\n-        switch (AbstractConfiguration.AbstractConfiguration$1.$SwitchMap$org$apache$commons$configuration2$sync$LockMode[mode.ordinal()]) {\n-            case 1: {\n+        switch (mode) {\n+            case READ: {\n                 this.beginRead(false);\n                 break;\n             }\n-            case 2: {\n+            case WRITE: {\n                 this.beginWrite(false);\n                 break;\n             }\n             default: {\n                 throw new IllegalArgumentException(\"Unsupported LockMode: \" + mode);\n             }\n         }\n     }\n     \n     public final void unlock(final LockMode mode) {\n-        switch (AbstractConfiguration.AbstractConfiguration$1.$SwitchMap$org$apache$commons$configuration2$sync$LockMode[mode.ordinal()]) {\n-            case 1: {\n+        switch (mode) {\n+            case READ: {\n                 this.endRead();\n                 break;\n             }\n-            case 2: {\n+            case WRITE: {\n                 this.endWrite();\n                 break;\n             }\n             default: {\n                 throw new IllegalArgumentException(\"Unsupported LockMode: \" + mode);\n             }\n         }\n@@ -243,14 +243,15 @@\n             this.fireEvent(ConfigurationEvent.ADD_PROPERTY, key, value, true);\n             this.addPropertyInternal(key, value);\n             this.fireEvent(ConfigurationEvent.ADD_PROPERTY, key, value, false);\n         }\n         finally {\n             this.endWrite();\n         }\n+        this.endWrite();\n     }\n     \n     protected void addPropertyInternal(final String key, final Object value) {\n         for (final Object obj : this.getListDelimiterHandler().parse(value)) {\n             this.addPropertyDirect(key, obj);\n         }\n     }\n@@ -281,51 +282,55 @@\n             this.fireEvent(ConfigurationEvent.SET_PROPERTY, key, value, true);\n             this.setPropertyInternal(key, value);\n             this.fireEvent(ConfigurationEvent.SET_PROPERTY, key, value, false);\n         }\n         finally {\n             this.endWrite();\n         }\n+        this.endWrite();\n     }\n     \n     protected void setPropertyInternal(final String key, final Object value) {\n         this.setDetailEvents(false);\n         try {\n             this.clearProperty(key);\n             this.addProperty(key, value);\n         }\n         finally {\n             this.setDetailEvents(true);\n         }\n+        this.setDetailEvents(true);\n     }\n     \n     public final void clearProperty(final String key) {\n         this.beginWrite(false);\n         try {\n             this.fireEvent(ConfigurationEvent.CLEAR_PROPERTY, key, (Object)null, true);\n             this.clearPropertyDirect(key);\n             this.fireEvent(ConfigurationEvent.CLEAR_PROPERTY, key, (Object)null, false);\n         }\n         finally {\n             this.endWrite();\n         }\n+        this.endWrite();\n     }\n     \n     protected abstract void clearPropertyDirect(final String p0);\n     \n     public final void clear() {\n         this.beginWrite(false);\n         try {\n             this.fireEvent(ConfigurationEvent.CLEAR, (String)null, (Object)null, true);\n             this.clearInternal();\n             this.fireEvent(ConfigurationEvent.CLEAR, (String)null, (Object)null, false);\n         }\n         finally {\n             this.endWrite();\n         }\n+        this.endWrite();\n     }\n     \n     protected void clearInternal() {\n         this.setDetailEvents(false);\n         boolean useIterator = true;\n         try {\n             final Iterator<String> it = this.getKeys();\n@@ -346,14 +351,15 @@\n                     this.clearProperty(key);\n                 }\n             }\n         }\n         finally {\n             this.setDetailEvents(true);\n         }\n+        this.setDetailEvents(true);\n     }\n     \n     public final Iterator<String> getKeys() {\n         this.beginRead(false);\n         try {\n             return this.getKeysInternal();\n         }\n@@ -437,31 +443,31 @@\n     public Properties getProperties(final String key) {\n         return this.getProperties(key, null);\n     }\n     \n     public Properties getProperties(final String key, final Properties defaults) {\n         final String[] tokens = this.getStringArray(key);\n         final Properties props = (defaults == null) ? new Properties() : new Properties(defaults);\n-        final String[] array = tokens;\n-        final int length = array.length;\n+        final String[] array;\n+        final int length = (array = tokens).length;\n         int i = 0;\n         while (i < length) {\n             final String token = array[i];\n             final int equalSign = token.indexOf(61);\n             if (equalSign > 0) {\n                 final String pkey = token.substring(0, equalSign).trim();\n                 final String pvalue = token.substring(equalSign + 1).trim();\n                 props.put(pkey, pvalue);\n                 ++i;\n             }\n             else {\n                 if (tokens.length == 1 && \"\".equals(token)) {\n                     break;\n                 }\n-                throw new IllegalArgumentException('\\'' + token + \"' does not contain an equals sign\");\n+                throw new IllegalArgumentException(String.valueOf('\\'') + token + \"' does not contain an equals sign\");\n             }\n         }\n         return props;\n     }\n     \n     public boolean getBoolean(final String key) {\n         final Boolean b = Boolean.valueOf(this.convert(Boolean.class, key, (Boolean)null, true));\n@@ -632,15 +638,15 @@\n         else {\n             if (value.getClass().isArray()) {\n                 return Arrays.asList((Object[])value);\n             }\n             if (this.isScalarValue(value)) {\n                 return (List<Object>)Collections.singletonList(value.toString());\n             }\n-            throw new ConversionException('\\'' + key + \"' doesn't map to a List object: \" + value + \", a \" + value.getClass().getName());\n+            throw new ConversionException(String.valueOf('\\'') + key + \"' doesn't map to a List object: \" + value + \", a \" + value.getClass().getName());\n         }\n         return list;\n     }\n     \n     public <T> T get(final Class<T> cls, final String key) {\n         return this.convert(cls, key, (T)null, true);\n     }\n@@ -697,14 +703,15 @@\n                     final Object value = this.encodeForCopy(c.getProperty(key));\n                     this.setProperty(key, value);\n                 }\n             }\n             finally {\n                 c.unlock(LockMode.READ);\n             }\n+            c.unlock(LockMode.READ);\n         }\n     }\n     \n     public void append(final Configuration c) {\n         if (c != null) {\n             c.lock(LockMode.READ);\n             try {\n@@ -714,14 +721,15 @@\n                     final Object value = this.encodeForCopy(c.getProperty(key));\n                     this.addProperty(key, value);\n                 }\n             }\n             finally {\n                 c.unlock(LockMode.READ);\n             }\n+            c.unlock(LockMode.READ);\n         }\n     }\n     \n     public Configuration interpolatedConfiguration() {\n         final AbstractConfiguration c = (AbstractConfiguration)ConfigurationUtils.cloneConfiguration((Configuration)this);\n         c.setListDelimiterHandler((ListDelimiterHandler)new DisabledListDelimiterHandler());\n         final Iterator<String> it = this.getKeys();\n@@ -779,15 +787,15 @@\n     private Object convertToArray(final Class<?> cls, final String key, final Object defaultValue) {\n         checkDefaultValueArray(cls, defaultValue);\n         return ObjectUtils.defaultIfNull(this.getConversionHandler().toArray(this.getProperty(key), (Class)cls, this.getInterpolator()), defaultValue);\n     }\n     \n     private static void checkDefaultValueArray(final Class<?> cls, final Object defaultValue) {\n         if (defaultValue != null && (!defaultValue.getClass().isArray() || !cls.isAssignableFrom(defaultValue.getClass().getComponentType()))) {\n-            throw new IllegalArgumentException(\"The type of the default value (\" + defaultValue.getClass() + \") is not an array of the specified class (\" + cls + \")\");\n+            throw new IllegalArgumentException(\"The type of the default value (\" + defaultValue.getClass() + \")\" + \" is not an array of the specified class (\" + cls + \")\");\n         }\n     }\n     \n     private static <T> Collection<T> handleDefaultCollection(final Collection<T> target, final Collection<T> defaultValue) {\n         if (defaultValue == null) {\n             return null;\n         }\n"}]}
