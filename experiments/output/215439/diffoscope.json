{"diffoscope-json-version": 1, "source1": "first/Utility.class", "source2": "second/Utility.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -10,143 +10,139 @@\n import java.io.CharArrayWriter;\n import java.io.OutputStream;\n import java.util.zip.GZIPOutputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.PrintWriter;\n import java.io.PrintStream;\n import java.util.Locale;\n-import java.util.List;\n import java.util.ArrayList;\n import java.io.IOException;\n import org.apache.bcel.util.ByteSequence;\n import org.apache.bcel.Const;\n \n public abstract class Utility\n {\n     private static ThreadLocal<Integer> consumed_chars;\n     private static boolean wide;\n     private static final int FREE_CHARS = 48;\n     private static int[] CHAR_MAP;\n     private static int[] MAP_CHAR;\n     private static final char ESCAPE_CHAR = '$';\n     \n-    private static int unwrap(final ThreadLocal<Integer> tl) {\n-        return Integer.valueOf(tl.get());\n+    private static int unwrap(final ThreadLocal<Integer> threadLocal) {\n+        return Integer.valueOf(threadLocal.get());\n     }\n     \n-    private static void wrap(final ThreadLocal<Integer> tl, final int value) {\n-        tl.set(Integer.valueOf(value));\n+    private static void wrap(final ThreadLocal<Integer> threadLocal, final int i) {\n+        threadLocal.set(Integer.valueOf(i));\n     }\n     \n-    public static String accessToString(final int access_flags) {\n-        return accessToString(access_flags, false);\n+    public static String accessToString(final int n) {\n+        return accessToString(n, false);\n     }\n     \n-    public static String accessToString(final int access_flags, final boolean for_class) {\n-        final StringBuilder buf = new StringBuilder();\n-        int p = 0;\n+    public static String accessToString(final int n, final boolean b) {\n+        final StringBuilder sb = new StringBuilder();\n         int i = 0;\n-        while (p < 32768) {\n-            p = pow2(i);\n+        int n2 = 0;\n+        while (i < 32768) {\n+            i = pow2(n2);\n             Label_0066: {\n-                if ((access_flags & p) != 0x0) {\n-                    if (for_class) {\n-                        if (p == 32) {\n+                if ((n & i) != 0x0) {\n+                    if (b) {\n+                        if (i == 32) {\n                             break Label_0066;\n                         }\n-                        if (p == 512) {\n+                        if (i == 512) {\n                             break Label_0066;\n                         }\n                     }\n-                    buf.append(Const.getAccessName(i)).append(\" \");\n+                    sb.append(Const.getAccessName(n2)).append(\" \");\n                 }\n             }\n-            ++i;\n+            ++n2;\n         }\n-        return buf.toString().trim();\n+        return sb.toString().trim();\n     }\n     \n-    public static String classOrInterface(final int access_flags) {\n-        return ((access_flags & 0x200) != 0x0) ? \"interface\" : \"class\";\n+    public static String classOrInterface(final int n) {\n+        return ((n & 0x200) != 0x0) ? \"interface\" : \"class\";\n     }\n     \n-    public static String codeToString(final byte[] code, final ConstantPool constant_pool, final int index, final int length, final boolean verbose) {\n-        final StringBuilder buf = new StringBuilder(code.length * 20);\n-        try (final ByteSequence stream = new ByteSequence(code)) {\n-            for (int i = 0; i < index; ++i) {\n-                codeToString(stream, constant_pool, verbose);\n+    public static String codeToString(final byte[] array, final ConstantPool constantPool, final int n, final int n2, final boolean b) {\n+        final StringBuilder sb = new StringBuilder(array.length * 20);\n+        try (final ByteSequence byteSequence = new ByteSequence(array)) {\n+            for (int i = 0; i < n; ++i) {\n+                codeToString(byteSequence, constantPool, b);\n             }\n-            int i = 0;\n-            while (stream.available() > 0) {\n-                if (length < 0 || i < length) {\n-                    final String indices = fillup(stream.getIndex() + \":\", 6, true, ' ');\n-                    buf.append(indices).append(codeToString(stream, constant_pool, verbose)).append('\\n');\n+            int n3 = 0;\n+            while (byteSequence.available() > 0) {\n+                if (n2 < 0 || n3 < n2) {\n+                    sb.append(fillup(byteSequence.getIndex() + \":\", 6, true, ' ')).append(codeToString(byteSequence, constantPool, b)).append('\\n');\n                 }\n-                ++i;\n+                ++n3;\n             }\n         }\n-        catch (final IOException e) {\n-            throw new ClassFormatException(\"Byte code error: \" + buf.toString(), (Throwable)e);\n+        catch (final IOException ex) {\n+            throw new ClassFormatException(\"Byte code error: \" + sb.toString(), (Throwable)ex);\n         }\n-        return buf.toString();\n+        return sb.toString();\n     }\n     \n-    public static String codeToString(final byte[] code, final ConstantPool constant_pool, final int index, final int length) {\n-        return codeToString(code, constant_pool, index, length, true);\n+    public static String codeToString(final byte[] array, final ConstantPool constantPool, final int n, final int n2) {\n+        return codeToString(array, constantPool, n, n2, true);\n     }\n     \n-    public static String codeToString(final ByteSequence bytes, final ConstantPool constant_pool, final boolean verbose) throws IOException {\n-        final short opcode = (short)bytes.readUnsignedByte();\n-        int default_offset = 0;\n-        int no_pad_bytes = 0;\n-        final StringBuilder buf = new StringBuilder(Const.getOpcodeName((int)opcode));\n-        if (opcode == 170 || opcode == 171) {\n-            final int remainder = bytes.getIndex() % 4;\n-            no_pad_bytes = ((remainder == 0) ? 0 : (4 - remainder));\n-            for (int i = 0; i < no_pad_bytes; ++i) {\n-                final byte b;\n-                if ((b = bytes.readByte()) != 0) {\n-                    System.err.println(\"Warning: Padding byte != 0 in \" + Const.getOpcodeName((int)opcode) + \":\" + b);\n+    public static String codeToString(final ByteSequence byteSequence, final ConstantPool constantPool, final boolean b) throws IOException {\n+        final short n = (short)byteSequence.readUnsignedByte();\n+        int int1 = 0;\n+        int n2 = 0;\n+        final StringBuilder sb = new StringBuilder(Const.getOpcodeName((int)n));\n+        if (n == 170 || n == 171) {\n+            final int n3 = byteSequence.getIndex() % 4;\n+            n2 = ((n3 == 0) ? 0 : (4 - n3));\n+            for (int i = 0; i < n2; ++i) {\n+                final byte byte1;\n+                if ((byte1 = byteSequence.readByte()) != 0) {\n+                    System.err.println(\"Warning: Padding byte != 0 in \" + Const.getOpcodeName((int)n) + \":\" + byte1);\n                 }\n             }\n-            default_offset = bytes.readInt();\n+            int1 = byteSequence.readInt();\n         }\n-        switch (opcode) {\n+        switch (n) {\n             case 170: {\n-                final int low = bytes.readInt();\n-                final int high = bytes.readInt();\n-                final int offset = bytes.getIndex() - 12 - no_pad_bytes - 1;\n-                default_offset += offset;\n-                buf.append(\"\\tdefault = \").append(default_offset).append(\", low = \").append(low).append(\", high = \").append(high).append(\"(\");\n-                final int[] jump_table = new int[high - low + 1];\n-                for (int j = 0; j < jump_table.length; ++j) {\n-                    buf.append(jump_table[j] = offset + bytes.readInt());\n-                    if (j < jump_table.length - 1) {\n-                        buf.append(\", \");\n+                final int int2 = byteSequence.readInt();\n+                final int int3 = byteSequence.readInt();\n+                final int n4 = byteSequence.getIndex() - 12 - n2 - 1;\n+                sb.append(\"\\tdefault = \").append(int1 + n4).append(\", low = \").append(int2).append(\", high = \").append(int3).append(\"(\");\n+                final int[] array = new int[int3 - int2 + 1];\n+                for (int j = 0; j < array.length; ++j) {\n+                    sb.append(array[j] = n4 + byteSequence.readInt());\n+                    if (j < array.length - 1) {\n+                        sb.append(\", \");\n                     }\n                 }\n-                buf.append(\")\");\n+                sb.append(\")\");\n                 break;\n             }\n             case 171: {\n-                final int npairs = bytes.readInt();\n-                final int offset = bytes.getIndex() - 8 - no_pad_bytes - 1;\n-                final int[] match = new int[npairs];\n-                final int[] jump_table = new int[npairs];\n-                default_offset += offset;\n-                buf.append(\"\\tdefault = \").append(default_offset).append(\", npairs = \").append(npairs).append(\" (\");\n-                for (int j = 0; j < npairs; ++j) {\n-                    match[j] = bytes.readInt();\n-                    jump_table[j] = offset + bytes.readInt();\n-                    buf.append(\"(\").append(match[j]).append(\", \").append(jump_table[j]).append(\")\");\n-                    if (j < npairs - 1) {\n-                        buf.append(\", \");\n+                final int int4 = byteSequence.readInt();\n+                final int n5 = byteSequence.getIndex() - 8 - n2 - 1;\n+                final int[] array2 = new int[int4];\n+                final int[] array3 = new int[int4];\n+                sb.append(\"\\tdefault = \").append(int1 + n5).append(\", npairs = \").append(int4).append(\" (\");\n+                for (int k = 0; k < int4; ++k) {\n+                    array2[k] = byteSequence.readInt();\n+                    array3[k] = n5 + byteSequence.readInt();\n+                    sb.append(\"(\").append(array2[k]).append(\", \").append(array3[k]).append(\")\");\n+                    if (k < int4 - 1) {\n+                        sb.append(\", \");\n                     }\n                 }\n-                buf.append(\")\");\n+                sb.append(\")\");\n                 break;\n             }\n             case 153:\n             case 154:\n             case 155:\n             case 156:\n             case 157:\n@@ -159,420 +155,416 @@\n             case 164:\n             case 165:\n             case 166:\n             case 167:\n             case 168:\n             case 198:\n             case 199: {\n-                buf.append(\"\\t\\t#\").append(bytes.getIndex() - 1 + bytes.readShort());\n+                sb.append(\"\\t\\t#\").append(byteSequence.getIndex() - 1 + byteSequence.readShort());\n                 break;\n             }\n             case 200:\n             case 201: {\n-                buf.append(\"\\t\\t#\").append(bytes.getIndex() - 1 + bytes.readInt());\n+                sb.append(\"\\t\\t#\").append(byteSequence.getIndex() - 1 + byteSequence.readInt());\n                 break;\n             }\n             case 21:\n             case 22:\n             case 23:\n             case 24:\n             case 25:\n             case 54:\n             case 55:\n             case 56:\n             case 57:\n             case 58:\n             case 169: {\n-                int vindex;\n+                int l;\n                 if (Utility.wide) {\n-                    vindex = bytes.readUnsignedShort();\n+                    l = byteSequence.readUnsignedShort();\n                     Utility.wide = false;\n                 }\n                 else {\n-                    vindex = bytes.readUnsignedByte();\n+                    l = byteSequence.readUnsignedByte();\n                 }\n-                buf.append(\"\\t\\t%\").append(vindex);\n+                sb.append(\"\\t\\t%\").append(l);\n                 break;\n             }\n             case 196: {\n                 Utility.wide = true;\n-                buf.append(\"\\t(wide)\");\n+                sb.append(\"\\t(wide)\");\n                 break;\n             }\n             case 188: {\n-                buf.append(\"\\t\\t<\").append(Const.getTypeName((int)bytes.readByte())).append(\">\");\n+                sb.append(\"\\t\\t<\").append(Const.getTypeName((int)byteSequence.readByte())).append(\">\");\n                 break;\n             }\n             case 178:\n             case 179:\n             case 180:\n             case 181: {\n-                final int index = bytes.readUnsignedShort();\n-                buf.append(\"\\t\\t\").append(constant_pool.constantToString(index, (byte)9)).append(verbose ? (\" (\" + index + \")\") : \"\");\n+                final int unsignedShort = byteSequence.readUnsignedShort();\n+                sb.append(\"\\t\\t\").append(constantPool.constantToString(unsignedShort, (byte)9)).append(b ? (\" (\" + unsignedShort + \")\") : \"\");\n                 break;\n             }\n             case 187:\n             case 192: {\n-                buf.append(\"\\t\");\n+                sb.append(\"\\t\");\n             }\n             case 193: {\n-                final int index = bytes.readUnsignedShort();\n-                buf.append(\"\\t<\").append(constant_pool.constantToString(index, (byte)7)).append(\">\").append(verbose ? (\" (\" + index + \")\") : \"\");\n+                final int unsignedShort2 = byteSequence.readUnsignedShort();\n+                sb.append(\"\\t<\").append(constantPool.constantToString(unsignedShort2, (byte)7)).append(\">\").append(b ? (\" (\" + unsignedShort2 + \")\") : \"\");\n                 break;\n             }\n             case 183:\n             case 184: {\n-                final int index = bytes.readUnsignedShort();\n-                final Constant c = constant_pool.getConstant(index);\n-                buf.append(\"\\t\").append(constant_pool.constantToString(index, c.getTag())).append(verbose ? (\" (\" + index + \")\") : \"\");\n+                final int unsignedShort3 = byteSequence.readUnsignedShort();\n+                sb.append(\"\\t\").append(constantPool.constantToString(unsignedShort3, constantPool.getConstant(unsignedShort3).getTag())).append(b ? (\" (\" + unsignedShort3 + \")\") : \"\");\n                 break;\n             }\n             case 182: {\n-                final int index = bytes.readUnsignedShort();\n-                buf.append(\"\\t\").append(constant_pool.constantToString(index, (byte)10)).append(verbose ? (\" (\" + index + \")\") : \"\");\n+                final int unsignedShort4 = byteSequence.readUnsignedShort();\n+                sb.append(\"\\t\").append(constantPool.constantToString(unsignedShort4, (byte)10)).append(b ? (\" (\" + unsignedShort4 + \")\") : \"\");\n                 break;\n             }\n             case 185: {\n-                final int index = bytes.readUnsignedShort();\n-                final int nargs = bytes.readUnsignedByte();\n-                buf.append(\"\\t\").append(constant_pool.constantToString(index, (byte)11)).append(verbose ? (\" (\" + index + \")\\t\") : \"\").append(nargs).append(\"\\t\").append(bytes.readUnsignedByte());\n+                final int unsignedShort5 = byteSequence.readUnsignedShort();\n+                sb.append(\"\\t\").append(constantPool.constantToString(unsignedShort5, (byte)11)).append(b ? (\" (\" + unsignedShort5 + \")\\t\") : \"\").append(byteSequence.readUnsignedByte()).append(\"\\t\").append(byteSequence.readUnsignedByte());\n                 break;\n             }\n             case 186: {\n-                final int index = bytes.readUnsignedShort();\n-                buf.append(\"\\t\").append(constant_pool.constantToString(index, (byte)18)).append(verbose ? (\" (\" + index + \")\\t\") : \"\").append(bytes.readUnsignedByte()).append(bytes.readUnsignedByte());\n+                final int unsignedShort6 = byteSequence.readUnsignedShort();\n+                sb.append(\"\\t\").append(constantPool.constantToString(unsignedShort6, (byte)18)).append(b ? (\" (\" + unsignedShort6 + \")\\t\") : \"\").append(byteSequence.readUnsignedByte()).append(byteSequence.readUnsignedByte());\n                 break;\n             }\n             case 19:\n             case 20: {\n-                final int index = bytes.readUnsignedShort();\n-                buf.append(\"\\t\\t\").append(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag())).append(verbose ? (\" (\" + index + \")\") : \"\");\n+                final int unsignedShort7 = byteSequence.readUnsignedShort();\n+                sb.append(\"\\t\\t\").append(constantPool.constantToString(unsignedShort7, constantPool.getConstant(unsignedShort7).getTag())).append(b ? (\" (\" + unsignedShort7 + \")\") : \"\");\n                 break;\n             }\n             case 18: {\n-                final int index = bytes.readUnsignedByte();\n-                buf.append(\"\\t\\t\").append(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag())).append(verbose ? (\" (\" + index + \")\") : \"\");\n+                final int unsignedByte = byteSequence.readUnsignedByte();\n+                sb.append(\"\\t\\t\").append(constantPool.constantToString(unsignedByte, constantPool.getConstant(unsignedByte).getTag())).append(b ? (\" (\" + unsignedByte + \")\") : \"\");\n                 break;\n             }\n             case 189: {\n-                final int index = bytes.readUnsignedShort();\n-                buf.append(\"\\t\\t<\").append(compactClassName(constant_pool.getConstantString(index, (byte)7), false)).append(\">\").append(verbose ? (\" (\" + index + \")\") : \"\");\n+                final int unsignedShort8 = byteSequence.readUnsignedShort();\n+                sb.append(\"\\t\\t<\").append(compactClassName(constantPool.getConstantString(unsignedShort8, (byte)7), false)).append(\">\").append(b ? (\" (\" + unsignedShort8 + \")\") : \"\");\n                 break;\n             }\n             case 197: {\n-                final int index = bytes.readUnsignedShort();\n-                final int dimensions = bytes.readUnsignedByte();\n-                buf.append(\"\\t<\").append(compactClassName(constant_pool.getConstantString(index, (byte)7), false)).append(\">\\t\").append(dimensions).append(verbose ? (\" (\" + index + \")\") : \"\");\n+                final int unsignedShort9 = byteSequence.readUnsignedShort();\n+                sb.append(\"\\t<\").append(compactClassName(constantPool.getConstantString(unsignedShort9, (byte)7), false)).append(\">\\t\").append(byteSequence.readUnsignedByte()).append(b ? (\" (\" + unsignedShort9 + \")\") : \"\");\n                 break;\n             }\n             case 132: {\n-                int vindex;\n-                int constant;\n+                int m;\n+                short i2;\n                 if (Utility.wide) {\n-                    vindex = bytes.readUnsignedShort();\n-                    constant = bytes.readShort();\n+                    m = byteSequence.readUnsignedShort();\n+                    i2 = byteSequence.readShort();\n                     Utility.wide = false;\n                 }\n                 else {\n-                    vindex = bytes.readUnsignedByte();\n-                    constant = bytes.readByte();\n+                    m = byteSequence.readUnsignedByte();\n+                    i2 = byteSequence.readByte();\n                 }\n-                buf.append(\"\\t\\t%\").append(vindex).append(\"\\t\").append(constant);\n+                sb.append(\"\\t\\t%\").append(m).append(\"\\t\").append(i2);\n                 break;\n             }\n             default: {\n-                if (Const.getNoOfOperands((int)opcode) > 0) {\n-                    for (int k = 0; k < Const.getOperandTypeCount((int)opcode); ++k) {\n-                        buf.append(\"\\t\\t\");\n-                        switch (Const.getOperandType((int)opcode, k)) {\n+                if (Const.getNoOfOperands((int)n) > 0) {\n+                    for (int n6 = 0; n6 < Const.getOperandTypeCount((int)n); ++n6) {\n+                        sb.append(\"\\t\\t\");\n+                        switch (Const.getOperandType((int)n, n6)) {\n                             case 8: {\n-                                buf.append(bytes.readByte());\n+                                sb.append(byteSequence.readByte());\n                                 break;\n                             }\n                             case 9: {\n-                                buf.append(bytes.readShort());\n+                                sb.append(byteSequence.readShort());\n                                 break;\n                             }\n                             case 10: {\n-                                buf.append(bytes.readInt());\n+                                sb.append(byteSequence.readInt());\n                                 break;\n                             }\n                             default: {\n                                 throw new IllegalStateException(\"Unreachable default case reached!\");\n                             }\n                         }\n                     }\n                     break;\n                 }\n                 break;\n             }\n         }\n-        return buf.toString();\n+        return sb.toString();\n     }\n     \n-    public static String codeToString(final ByteSequence bytes, final ConstantPool constant_pool) throws IOException {\n-        return codeToString(bytes, constant_pool, true);\n+    public static String codeToString(final ByteSequence byteSequence, final ConstantPool constantPool) throws IOException {\n+        return codeToString(byteSequence, constantPool, true);\n     }\n     \n-    public static String compactClassName(final String str) {\n-        return compactClassName(str, true);\n+    public static String compactClassName(final String s) {\n+        return compactClassName(s, true);\n     }\n     \n-    public static String compactClassName(final String str, final boolean chopit) {\n-        return compactClassName(str, \"java.lang.\", chopit);\n+    public static String compactClassName(final String s, final boolean b) {\n+        return compactClassName(s, \"java.lang.\", b);\n     }\n     \n-    public static String compactClassName(String str, final String prefix, final boolean chopit) {\n-        final int len = prefix.length();\n-        str = str.replace('/', '.');\n-        if (chopit && str.startsWith(prefix) && str.substring(len).indexOf(46) == -1) {\n-            str = str.substring(len);\n+    public static String compactClassName(String s, final String prefix, final boolean b) {\n+        final int length = prefix.length();\n+        s = s.replace('/', '.');\n+        if (b && s.startsWith(prefix) && s.substring(length).indexOf(46) == -1) {\n+            s = s.substring(length);\n         }\n-        return str;\n+        return s;\n     }\n     \n-    public static int setBit(final int flag, final int i) {\n-        return flag | pow2(i);\n+    public static int setBit(final int n, final int n2) {\n+        return n | pow2(n2);\n     }\n     \n-    public static int clearBit(final int flag, final int i) {\n-        final int bit = pow2(i);\n-        return ((flag & bit) == 0x0) ? flag : (flag ^ bit);\n+    public static int clearBit(final int n, final int n2) {\n+        final int pow2 = pow2(n2);\n+        return ((n & pow2) == 0x0) ? n : (n ^ pow2);\n     }\n     \n-    public static boolean isSet(final int flag, final int i) {\n-        return (flag & pow2(i)) != 0x0;\n+    public static boolean isSet(final int n, final int n2) {\n+        return (n & pow2(n2)) != 0x0;\n     }\n     \n-    public static String methodTypeToSignature(final String ret, final String[] argv) throws ClassFormatException {\n-        final StringBuilder buf = new StringBuilder(\"(\");\n-        if (argv != null) {\n-            for (final String element : argv) {\n-                final String str = getSignature(element);\n-                if (str.endsWith(\"V\")) {\n-                    throw new ClassFormatException(\"Invalid type: \" + element);\n+    public static String methodTypeToSignature(final String s, final String[] array) throws ClassFormatException {\n+        final StringBuilder sb = new StringBuilder(\"(\");\n+        if (array != null) {\n+            for (final String str : array) {\n+                final String signature = getSignature(str);\n+                if (signature.endsWith(\"V\")) {\n+                    throw new ClassFormatException(\"Invalid type: \" + str);\n                 }\n-                buf.append(str);\n+                sb.append(signature);\n             }\n         }\n-        final String str = getSignature(ret);\n-        buf.append(\")\").append(str);\n-        return buf.toString();\n+        sb.append(\")\").append(getSignature(s));\n+        return sb.toString();\n     }\n     \n-    public static String[] methodSignatureArgumentTypes(final String signature) throws ClassFormatException {\n-        return methodSignatureArgumentTypes(signature, true);\n+    public static String[] methodSignatureArgumentTypes(final String s) throws ClassFormatException {\n+        return methodSignatureArgumentTypes(s, true);\n     }\n     \n-    public static String[] methodSignatureArgumentTypes(final String signature, final boolean chopit) throws ClassFormatException {\n-        final List<String> vec = new ArrayList<String>();\n+    public static String[] methodSignatureArgumentTypes(final String s, final boolean b) throws ClassFormatException {\n+        final ArrayList list = new ArrayList();\n         try {\n-            int index = signature.indexOf(40) + 1;\n-            if (index <= 0) {\n-                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n+            int n = s.indexOf(40) + 1;\n+            if (n <= 0) {\n+                throw new ClassFormatException(\"Invalid method signature: \" + s);\n             }\n-            while (signature.charAt(index) != ')') {\n-                vec.add(typeSignatureToString(signature.substring(index), chopit));\n-                index += unwrap(Utility.consumed_chars);\n+            while (s.charAt(n) != ')') {\n+                list.add(typeSignatureToString(s.substring(n), b));\n+                n += unwrap(Utility.consumed_chars);\n             }\n         }\n-        catch (final StringIndexOutOfBoundsException e) {\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)e);\n+        catch (final StringIndexOutOfBoundsException ex) {\n+            throw new ClassFormatException(\"Invalid method signature: \" + s, (Throwable)ex);\n         }\n-        return vec.toArray(new String[vec.size()]);\n+        return (String[])list.toArray(new String[list.size()]);\n     }\n     \n-    public static String methodSignatureReturnType(final String signature) throws ClassFormatException {\n-        return methodSignatureReturnType(signature, true);\n+    public static String methodSignatureReturnType(final String s) throws ClassFormatException {\n+        return methodSignatureReturnType(s, true);\n     }\n     \n-    public static String methodSignatureReturnType(final String signature, final boolean chopit) throws ClassFormatException {\n-        String type;\n+    public static String methodSignatureReturnType(final String s, final boolean b) throws ClassFormatException {\n+        String typeSignatureToString;\n         try {\n-            final int index = signature.lastIndexOf(41) + 1;\n-            if (index <= 0) {\n-                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n+            final int beginIndex = s.lastIndexOf(41) + 1;\n+            if (beginIndex <= 0) {\n+                throw new ClassFormatException(\"Invalid method signature: \" + s);\n             }\n-            type = typeSignatureToString(signature.substring(index), chopit);\n+            typeSignatureToString = typeSignatureToString(s.substring(beginIndex), b);\n         }\n-        catch (final StringIndexOutOfBoundsException e) {\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)e);\n+        catch (final StringIndexOutOfBoundsException ex) {\n+            throw new ClassFormatException(\"Invalid method signature: \" + s, (Throwable)ex);\n         }\n-        return type;\n+        return typeSignatureToString;\n     }\n     \n-    public static String methodSignatureToString(final String signature, final String name, final String access) {\n-        return methodSignatureToString(signature, name, access, true);\n+    public static String methodSignatureToString(final String s, final String s2, final String s3) {\n+        return methodSignatureToString(s, s2, s3, true);\n     }\n     \n-    public static String methodSignatureToString(final String signature, final String name, final String access, final boolean chopit) {\n-        return methodSignatureToString(signature, name, access, chopit, null);\n+    public static String methodSignatureToString(final String s, final String s2, final String s3, final boolean b) {\n+        return methodSignatureToString(s, s2, s3, b, null);\n     }\n     \n-    public static String methodSignatureToString(final String signature, final String name, final String access, final boolean chopit, final LocalVariableTable vars) throws ClassFormatException {\n-        final StringBuilder buf = new StringBuilder(\"(\");\n-        int var_index = access.contains(\"static\") ? 0 : 1;\n-        String type;\n+    public static String methodSignatureToString(final String s, final String str, final String str2, final boolean b, final LocalVariableTable localVariableTable) throws ClassFormatException {\n+        final StringBuilder sb = new StringBuilder(\"(\");\n+        int i = str2.contains(\"static\") ? 0 : 1;\n+        String typeSignatureToString2;\n         try {\n-            int index = signature.indexOf(40) + 1;\n-            if (index <= 0) {\n-                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n-            }\n-            while (signature.charAt(index) != ')') {\n-                final String param_type = typeSignatureToString(signature.substring(index), chopit);\n-                buf.append(param_type);\n-                if (vars != null) {\n-                    final LocalVariable l = vars.getLocalVariable(var_index, 0);\n-                    if (l != null) {\n-                        buf.append(\" \").append(l.getName());\n+            int beginIndex = s.indexOf(40) + 1;\n+            if (beginIndex <= 0) {\n+                throw new ClassFormatException(\"Invalid method signature: \" + s);\n+            }\n+            while (s.charAt(beginIndex) != ')') {\n+                final String typeSignatureToString = typeSignatureToString(s.substring(beginIndex), b);\n+                sb.append(typeSignatureToString);\n+                if (localVariableTable != null) {\n+                    final LocalVariable localVariable = localVariableTable.getLocalVariable(i, 0);\n+                    if (localVariable != null) {\n+                        sb.append(\" \").append(localVariable.getName());\n                     }\n                 }\n                 else {\n-                    buf.append(\" arg\").append(var_index);\n+                    sb.append(\" arg\").append(i);\n                 }\n-                if (\"double\".equals(param_type) || \"long\".equals(param_type)) {\n-                    var_index += 2;\n+                if (\"double\".equals(typeSignatureToString) || \"long\".equals(typeSignatureToString)) {\n+                    i += 2;\n                 }\n                 else {\n-                    ++var_index;\n+                    ++i;\n                 }\n-                buf.append(\", \");\n-                index += unwrap(Utility.consumed_chars);\n+                sb.append(\", \");\n+                beginIndex += unwrap(Utility.consumed_chars);\n             }\n-            ++index;\n-            type = typeSignatureToString(signature.substring(index), chopit);\n+            ++beginIndex;\n+            typeSignatureToString2 = typeSignatureToString(s.substring(beginIndex), b);\n         }\n-        catch (final StringIndexOutOfBoundsException e) {\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)e);\n+        catch (final StringIndexOutOfBoundsException ex) {\n+            throw new ClassFormatException(\"Invalid method signature: \" + s, (Throwable)ex);\n         }\n-        if (buf.length() > 1) {\n-            buf.setLength();\n+        if (sb.length() > 1) {\n+            sb.setLength();\n         }\n-        buf.append(\")\");\n-        return access + ((access.length() > 0) ? \" \" : \"\") + type + \" \" + name + buf.toString();\n+        sb.append(\")\");\n+        return str2 + ((str2.length() > 0) ? \" \" : \"\") + typeSignatureToString2 + \" \" + str + sb.toString();\n     }\n     \n     private static int pow2(final int n) {\n         return 1 << n;\n     }\n     \n-    public static String replace(String str, final String old, final String new_) {\n+    public static String replace(String string, final String s, final String str) {\n         try {\n-            if (str.contains(old)) {\n-                final StringBuilder buf = new StringBuilder();\n-                int old_index;\n+            if (string.contains(s)) {\n+                final StringBuilder sb = new StringBuilder();\n+                int beginIndex;\n                 int index;\n-                for (old_index = 0; (index = str.indexOf(old, old_index)) != -1; old_index = index + old.length()) {\n-                    buf.append(str.substring(old_index, index));\n-                    buf.append(new_);\n+                for (beginIndex = 0; (index = string.indexOf(s, beginIndex)) != -1; beginIndex = index + s.length()) {\n+                    sb.append(string.substring(beginIndex, index));\n+                    sb.append(str);\n                 }\n-                buf.append(str.substring(old_index));\n-                str = buf.toString();\n+                sb.append(string.substring(beginIndex));\n+                string = sb.toString();\n             }\n         }\n-        catch (final StringIndexOutOfBoundsException e) {\n-            System.err.println(e);\n+        catch (final StringIndexOutOfBoundsException x) {\n+            System.err.println(x);\n         }\n-        return str;\n+        return string;\n     }\n     \n-    public static String signatureToString(final String signature) {\n-        return signatureToString(signature, true);\n+    public static String signatureToString(final String s) {\n+        return signatureToString(s, true);\n     }\n     \n-    public static String signatureToString(final String signature, final boolean chopit) {\n-        String type = \"\";\n-        String typeParams = \"\";\n-        int index = 0;\n-        if (signature.charAt(0) == '<') {\n-            typeParams = typeParamTypesToString(signature, chopit);\n-            index += unwrap(Utility.consumed_chars);\n+    public static String signatureToString(final String s, final boolean b) {\n+        String typeParamTypesToString = \"\";\n+        int beginIndex = 0;\n+        if (s.charAt(0) == '<') {\n+            typeParamTypesToString = typeParamTypesToString(s, b);\n+            beginIndex += unwrap(Utility.consumed_chars);\n         }\n-        if (signature.charAt(index) == '(') {\n-            type = typeParams + typeSignaturesToString(signature.substring(index), chopit, ')');\n-            index += unwrap(Utility.consumed_chars);\n-            type += typeSignatureToString(signature.substring(index), chopit);\n-            index += unwrap(Utility.consumed_chars);\n-            return type;\n+        if (s.charAt(beginIndex) == '(') {\n+            final String string = typeParamTypesToString + typeSignaturesToString(s.substring(beginIndex), b, ')');\n+            final int beginIndex2 = beginIndex + unwrap(Utility.consumed_chars);\n+            final String string2 = string + typeSignatureToString(s.substring(beginIndex2), b);\n+            final int n = beginIndex2 + unwrap(Utility.consumed_chars);\n+            return string2;\n         }\n-        type = typeSignatureToString(signature.substring(index), chopit);\n-        index += unwrap(Utility.consumed_chars);\n-        if (typeParams.length() == 0 && index == signature.length()) {\n-            return type;\n-        }\n-        final StringBuilder typeClass = new StringBuilder(typeParams);\n-        typeClass.append(\" extends \");\n-        typeClass.append(type);\n-        if (index < signature.length()) {\n-            typeClass.append(\" implements \");\n-            typeClass.append(typeSignatureToString(signature.substring(index), chopit));\n-            index += unwrap(Utility.consumed_chars);\n+        final String typeSignatureToString = typeSignatureToString(s.substring(beginIndex), b);\n+        int i = beginIndex + unwrap(Utility.consumed_chars);\n+        if (typeParamTypesToString.length() == 0 && i == s.length()) {\n+            return typeSignatureToString;\n         }\n-        while (index < signature.length()) {\n-            typeClass.append(\", \");\n-            typeClass.append(typeSignatureToString(signature.substring(index), chopit));\n-            index += unwrap(Utility.consumed_chars);\n+        final StringBuilder sb = new StringBuilder(typeParamTypesToString);\n+        sb.append(\" extends \");\n+        sb.append(typeSignatureToString);\n+        if (i < s.length()) {\n+            sb.append(\" implements \");\n+            sb.append(typeSignatureToString(s.substring(i), b));\n+            i += unwrap(Utility.consumed_chars);\n         }\n-        return typeClass.toString();\n+        while (i < s.length()) {\n+            sb.append(\", \");\n+            sb.append(typeSignatureToString(s.substring(i), b));\n+            i += unwrap(Utility.consumed_chars);\n+        }\n+        return sb.toString();\n     }\n     \n-    private static String typeParamTypesToString(final String signature, final boolean chopit) {\n-        final StringBuilder typeParams = new StringBuilder(\"<\");\n-        int index = 1;\n-        typeParams.append(typeParamTypeToString(signature.substring(index), chopit));\n-        for (index += unwrap(Utility.consumed_chars); signature.charAt(index) != '>'; index += unwrap(Utility.consumed_chars)) {\n-            typeParams.append(\", \");\n-            typeParams.append(typeParamTypeToString(signature.substring(index), chopit));\n+    private static String typeParamTypesToString(final String s, final boolean b) {\n+        final StringBuilder sb = new StringBuilder(\"<\");\n+        final int beginIndex = 1;\n+        sb.append(typeParamTypeToString(s.substring(beginIndex), b));\n+        int n;\n+        for (n = beginIndex + unwrap(Utility.consumed_chars); s.charAt(n) != '>'; n += unwrap(Utility.consumed_chars)) {\n+            sb.append(\", \");\n+            sb.append(typeParamTypeToString(s.substring(n), b));\n         }\n-        wrap(Utility.consumed_chars, index + 1);\n-        return typeParams.append(\">\").toString();\n+        wrap(Utility.consumed_chars, n + 1);\n+        return sb.append(\">\").toString();\n     }\n     \n-    private static String typeParamTypeToString(final String signature, final boolean chopit) {\n-        int index = signature.indexOf(58);\n+    private static String typeParamTypeToString(final String str, final boolean b) {\n+        int index = str.indexOf(58);\n         if (index <= 0) {\n-            throw new ClassFormatException(\"Invalid type parameter signature: \" + signature);\n+            throw new ClassFormatException(\"Invalid type parameter signature: \" + str);\n         }\n-        final StringBuilder typeParam = new StringBuilder(signature.substring(0, index));\n+        final StringBuilder sb = new StringBuilder(str.substring(0, index));\n         ++index;\n-        if (signature.charAt(index) != ':') {\n-            typeParam.append(\" extends \");\n-            typeParam.append(typeSignatureToString(signature.substring(index), chopit));\n+        if (str.charAt(index) != ':') {\n+            sb.append(\" extends \");\n+            sb.append(typeSignatureToString(str.substring(index), b));\n             index += unwrap(Utility.consumed_chars);\n         }\n-        while (signature.charAt(index) == ':') {\n+        while (str.charAt(index) == ':') {\n             ++index;\n-            typeParam.append(\" & \");\n-            typeParam.append(typeSignatureToString(signature.substring(index), chopit));\n+            sb.append(\" & \");\n+            sb.append(typeSignatureToString(str.substring(index), b));\n             index += unwrap(Utility.consumed_chars);\n         }\n         wrap(Utility.consumed_chars, index);\n-        return typeParam.toString();\n+        return sb.toString();\n     }\n     \n-    private static String typeSignaturesToString(final String signature, final boolean chopit, final char term) {\n-        final StringBuilder typeList = new StringBuilder(signature.substring(0, 1));\n-        int index = 1;\n-        if (signature.charAt(index) != term) {\n-            typeList.append(typeSignatureToString(signature.substring(index), chopit));\n-            index += unwrap(Utility.consumed_chars);\n+    private static String typeSignaturesToString(final String s, final boolean b, final char c) {\n+        final StringBuilder sb = new StringBuilder(s.substring(0, 1));\n+        int n = 1;\n+        if (s.charAt(n) != c) {\n+            sb.append(typeSignatureToString(s.substring(n), b));\n+            n += unwrap(Utility.consumed_chars);\n         }\n-        while (signature.charAt(index) != term) {\n-            typeList.append(\", \");\n-            typeList.append(typeSignatureToString(signature.substring(index), chopit));\n-            index += unwrap(Utility.consumed_chars);\n+        while (s.charAt(n) != c) {\n+            sb.append(\", \");\n+            sb.append(typeSignatureToString(s.substring(n), b));\n+            n += unwrap(Utility.consumed_chars);\n         }\n-        wrap(Utility.consumed_chars, index + 1);\n-        return typeList.append(term).toString();\n+        wrap(Utility.consumed_chars, n + 1);\n+        return sb.append(c).toString();\n     }\n     \n-    public static String typeSignatureToString(final String signature, final boolean chopit) throws ClassFormatException {\n+    public static String typeSignatureToString(final String str, final boolean b) throws ClassFormatException {\n         wrap(Utility.consumed_chars, 1);\n         try {\n-            switch (signature.charAt(0)) {\n+            switch (str.charAt(0)) {\n                 case 'B': {\n                     return \"byte\";\n                 }\n                 case 'C': {\n                     return \"char\";\n                 }\n                 case 'D': {\n@@ -584,238 +576,237 @@\n                 case 'I': {\n                     return \"int\";\n                 }\n                 case 'J': {\n                     return \"long\";\n                 }\n                 case 'T': {\n-                    final int index = signature.indexOf(59);\n+                    final int index = str.indexOf(59);\n                     if (index < 0) {\n-                        throw new ClassFormatException(\"Invalid type variable signature: \" + signature);\n+                        throw new ClassFormatException(\"Invalid type variable signature: \" + str);\n                     }\n                     wrap(Utility.consumed_chars, index + 1);\n-                    return compactClassName(signature.substring(1, index), chopit);\n+                    return compactClassName(str.substring(1, index), b);\n                 }\n                 case 'L': {\n-                    int fromIndex = signature.indexOf(60);\n-                    if (fromIndex < 0) {\n-                        fromIndex = 0;\n+                    final int index2 = str.indexOf(60);\n+                    int index3;\n+                    if (index2 < 0) {\n+                        index3 = 0;\n                     }\n                     else {\n-                        fromIndex = signature.indexOf(62, fromIndex);\n-                        if (fromIndex < 0) {\n-                            throw new ClassFormatException(\"Invalid signature: \" + signature);\n+                        index3 = str.indexOf(62, index2);\n+                        if (index3 < 0) {\n+                            throw new ClassFormatException(\"Invalid signature: \" + str);\n                         }\n                     }\n-                    final int index2 = signature.indexOf(59, fromIndex);\n-                    if (index2 < 0) {\n-                        throw new ClassFormatException(\"Invalid signature: \" + signature);\n-                    }\n-                    final int bracketIndex = signature.substring(0, index2).indexOf(60);\n-                    if (bracketIndex < 0) {\n-                        wrap(Utility.consumed_chars, index2 + 1);\n-                        return compactClassName(signature.substring(1, index2), chopit);\n-                    }\n-                    fromIndex = signature.indexOf(59);\n-                    if (fromIndex < 0) {\n-                        throw new ClassFormatException(\"Invalid signature: \" + signature);\n-                    }\n-                    if (fromIndex < bracketIndex) {\n-                        wrap(Utility.consumed_chars, fromIndex + 1);\n-                        return compactClassName(signature.substring(1, fromIndex), chopit);\n-                    }\n-                    final StringBuilder type = new StringBuilder(compactClassName(signature.substring(1, bracketIndex), chopit)).append(\"<\");\n-                    int consumed_chars = bracketIndex + 1;\n-                    if (signature.charAt(consumed_chars) == '+') {\n-                        type.append(\"? extends \");\n-                        ++consumed_chars;\n-                    }\n-                    else if (signature.charAt(consumed_chars) == '-') {\n-                        type.append(\"? super \");\n-                        ++consumed_chars;\n-                    }\n-                    if (signature.charAt(consumed_chars) == '*') {\n-                        type.append(\"?\");\n-                        ++consumed_chars;\n+                    final int index4 = str.indexOf(59, index3);\n+                    if (index4 < 0) {\n+                        throw new ClassFormatException(\"Invalid signature: \" + str);\n+                    }\n+                    final int index5 = str.substring(0, index4).indexOf(60);\n+                    if (index5 < 0) {\n+                        wrap(Utility.consumed_chars, index4 + 1);\n+                        return compactClassName(str.substring(1, index4), b);\n+                    }\n+                    final int index6 = str.indexOf(59);\n+                    if (index6 < 0) {\n+                        throw new ClassFormatException(\"Invalid signature: \" + str);\n+                    }\n+                    if (index6 < index5) {\n+                        wrap(Utility.consumed_chars, index6 + 1);\n+                        return compactClassName(str.substring(1, index6), b);\n+                    }\n+                    final StringBuilder append = new StringBuilder(compactClassName(str.substring(1, index5), b)).append(\"<\");\n+                    int index7 = index5 + 1;\n+                    if (str.charAt(index7) == '+') {\n+                        append.append(\"? extends \");\n+                        ++index7;\n+                    }\n+                    else if (str.charAt(index7) == '-') {\n+                        append.append(\"? super \");\n+                        ++index7;\n+                    }\n+                    if (str.charAt(index7) == '*') {\n+                        append.append(\"?\");\n+                        ++index7;\n                     }\n                     else {\n-                        type.append(typeSignatureToString(signature.substring(consumed_chars), chopit));\n-                        consumed_chars += unwrap(Utility.consumed_chars);\n-                        wrap(Utility.consumed_chars, consumed_chars);\n-                    }\n-                    while (signature.charAt(consumed_chars) != '>') {\n-                        type.append(\", \");\n-                        if (signature.charAt(consumed_chars) == '+') {\n-                            type.append(\"? extends \");\n-                            ++consumed_chars;\n+                        append.append(typeSignatureToString(str.substring(index7), b));\n+                        index7 += unwrap(Utility.consumed_chars);\n+                        wrap(Utility.consumed_chars, index7);\n+                    }\n+                    while (str.charAt(index7) != '>') {\n+                        append.append(\", \");\n+                        if (str.charAt(index7) == '+') {\n+                            append.append(\"? extends \");\n+                            ++index7;\n                         }\n-                        else if (signature.charAt(consumed_chars) == '-') {\n-                            type.append(\"? super \");\n-                            ++consumed_chars;\n+                        else if (str.charAt(index7) == '-') {\n+                            append.append(\"? super \");\n+                            ++index7;\n                         }\n-                        if (signature.charAt(consumed_chars) == '*') {\n-                            type.append(\"?\");\n-                            ++consumed_chars;\n+                        if (str.charAt(index7) == '*') {\n+                            append.append(\"?\");\n+                            ++index7;\n                         }\n                         else {\n-                            type.append(typeSignatureToString(signature.substring(consumed_chars), chopit));\n-                            consumed_chars += unwrap(Utility.consumed_chars);\n-                            wrap(Utility.consumed_chars, consumed_chars);\n+                            append.append(typeSignatureToString(str.substring(index7), b));\n+                            index7 += unwrap(Utility.consumed_chars);\n+                            wrap(Utility.consumed_chars, index7);\n                         }\n                     }\n-                    ++consumed_chars;\n-                    type.append(\">\");\n-                    if (signature.charAt(consumed_chars) == '.') {\n-                        type.append(\".\");\n-                        type.append(typeSignatureToString(\"L\" + signature.substring(consumed_chars + 1), chopit));\n-                        consumed_chars += unwrap(Utility.consumed_chars);\n-                        wrap(Utility.consumed_chars, consumed_chars);\n-                        return type.toString();\n+                    ++index7;\n+                    append.append(\">\");\n+                    if (str.charAt(index7) == '.') {\n+                        append.append(\".\");\n+                        append.append(typeSignatureToString(\"L\" + str.substring(index7 + 1), b));\n+                        wrap(Utility.consumed_chars, unwrap(Utility.consumed_chars) + index7);\n+                        return append.toString();\n                     }\n-                    if (signature.charAt(consumed_chars) != ';') {\n-                        throw new ClassFormatException(\"Invalid signature: \" + signature);\n+                    if (str.charAt(index7) != ';') {\n+                        throw new ClassFormatException(\"Invalid signature: \" + str);\n                     }\n-                    wrap(Utility.consumed_chars, consumed_chars + 1);\n-                    return type.toString();\n+                    wrap(Utility.consumed_chars, index7 + 1);\n+                    return append.toString();\n                 }\n                 case 'S': {\n                     return \"short\";\n                 }\n                 case 'Z': {\n                     return \"boolean\";\n                 }\n                 case '[': {\n-                    final StringBuilder brackets = new StringBuilder();\n+                    final StringBuilder sb = new StringBuilder();\n                     int n;\n-                    for (n = 0; signature.charAt(n) == '['; ++n) {\n-                        brackets.append(\"[]\");\n+                    for (n = 0; str.charAt(n) == '['; ++n) {\n+                        sb.append(\"[]\");\n                     }\n-                    final int consumed_chars2 = n;\n-                    final String type2 = typeSignatureToString(signature.substring(n), chopit);\n-                    final int _temp = unwrap(Utility.consumed_chars) + consumed_chars2;\n-                    wrap(Utility.consumed_chars, _temp);\n-                    return type2 + brackets.toString();\n+                    final int n2 = n;\n+                    final String typeSignatureToString = typeSignatureToString(str.substring(n), b);\n+                    wrap(Utility.consumed_chars, unwrap(Utility.consumed_chars) + n2);\n+                    return typeSignatureToString + sb.toString();\n                 }\n                 case 'V': {\n                     return \"void\";\n                 }\n                 default: {\n-                    throw new ClassFormatException(\"Invalid signature: `\" + signature + \"'\");\n+                    throw new ClassFormatException(\"Invalid signature: `\" + str + \"'\");\n                 }\n             }\n         }\n-        catch (final StringIndexOutOfBoundsException e) {\n-            throw new ClassFormatException(\"Invalid signature: \" + signature, (Throwable)e);\n+        catch (final StringIndexOutOfBoundsException ex) {\n+            throw new ClassFormatException(\"Invalid signature: \" + str, (Throwable)ex);\n         }\n     }\n     \n-    public static String getSignature(String type) {\n-        final StringBuilder buf = new StringBuilder();\n-        final char[] chars = type.toCharArray();\n-        boolean char_found = false;\n-        boolean delim = false;\n-        int index = -1;\n+    public static String getSignature(String string) {\n+        final StringBuilder sb = new StringBuilder();\n+        final char[] charArray = string.toCharArray();\n+        int n = 0;\n+        boolean b = false;\n+        int beginIndex = -1;\n     Label_0162:\n-        for (int i = 0; i < chars.length; ++i) {\n-            switch (chars[i]) {\n+        for (int i = 0; i < charArray.length; ++i) {\n+            switch (charArray[i]) {\n                 case '\\t':\n                 case '\\n':\n                 case '\\f':\n                 case '\\r':\n                 case ' ': {\n-                    if (char_found) {\n-                        delim = true;\n+                    if (n != 0) {\n+                        b = true;\n                         break;\n                     }\n                     break;\n                 }\n                 case '[': {\n-                    if (!char_found) {\n-                        throw new IllegalArgumentException(\"Illegal type: \" + type);\n+                    if (n == 0) {\n+                        throw new IllegalArgumentException(\"Illegal type: \" + string);\n                     }\n-                    index = i;\n+                    beginIndex = i;\n                     break Label_0162;\n                 }\n                 default: {\n-                    char_found = true;\n-                    if (!delim) {\n-                        buf.append(chars[i]);\n+                    n = 1;\n+                    if (!b) {\n+                        sb.append(charArray[i]);\n                         break;\n                     }\n                     break;\n                 }\n             }\n         }\n-        int brackets = 0;\n-        if (index > 0) {\n-            brackets = countBrackets(type.substring(index));\n-        }\n-        type = buf.toString();\n-        buf.setLength();\n-        for (int j = 0; j < brackets; ++j) {\n-            buf.append('[');\n-        }\n-        boolean found = false;\n-        for (int k = 4; k <= 12 && !found; ++k) {\n-            if (Const.getTypeName(k).equals(type)) {\n-                found = true;\n-                buf.append(Const.getShortTypeName(k));\n-            }\n-        }\n-        if (!found) {\n-            buf.append('L').append(type.replace('.', '/')).append(';');\n-        }\n-        return buf.toString();\n-    }\n-    \n-    private static int countBrackets(final String brackets) {\n-        final char[] chars = brackets.toCharArray();\n-        int count = 0;\n-        boolean open = false;\n-        for (final char c : chars) {\n-            switch (c) {\n+        int countBrackets = 0;\n+        if (beginIndex > 0) {\n+            countBrackets = countBrackets(string.substring(beginIndex));\n+        }\n+        string = sb.toString();\n+        sb.setLength();\n+        for (int j = 0; j < countBrackets; ++j) {\n+            sb.append('[');\n+        }\n+        int n2 = 0;\n+        for (int n3 = 4; n3 <= 12 && n2 == 0; ++n3) {\n+            if (Const.getTypeName(n3).equals(string)) {\n+                n2 = 1;\n+                sb.append(Const.getShortTypeName(n3));\n+            }\n+        }\n+        if (n2 == 0) {\n+            sb.append('L').append(string.replace('.', '/')).append(';');\n+        }\n+        return sb.toString();\n+    }\n+    \n+    private static int countBrackets(final String str) {\n+        final char[] charArray = str.toCharArray();\n+        int n = 0;\n+        int n2 = 0;\n+        final char[] array = charArray;\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            switch (array[i]) {\n                 case '[': {\n-                    if (open) {\n-                        throw new IllegalArgumentException(\"Illegally nested brackets:\" + brackets);\n+                    if (n2 != 0) {\n+                        throw new IllegalArgumentException(\"Illegally nested brackets:\" + str);\n                     }\n-                    open = true;\n+                    n2 = 1;\n                     break;\n                 }\n                 case ']': {\n-                    if (!open) {\n-                        throw new IllegalArgumentException(\"Illegally nested brackets:\" + brackets);\n+                    if (n2 == 0) {\n+                        throw new IllegalArgumentException(\"Illegally nested brackets:\" + str);\n                     }\n-                    open = false;\n-                    ++count;\n+                    n2 = 0;\n+                    ++n;\n                     break;\n                 }\n             }\n         }\n-        if (open) {\n-            throw new IllegalArgumentException(\"Illegally nested brackets:\" + brackets);\n+        if (n2 != 0) {\n+            throw new IllegalArgumentException(\"Illegally nested brackets:\" + str);\n         }\n-        return count;\n+        return n;\n     }\n     \n-    public static byte typeOfMethodSignature(final String signature) throws ClassFormatException {\n+    public static byte typeOfMethodSignature(final String s) throws ClassFormatException {\n         try {\n-            if (signature.charAt(0) != '(') {\n-                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n+            if (s.charAt(0) != '(') {\n+                throw new ClassFormatException(\"Invalid method signature: \" + s);\n             }\n-            final int index = signature.lastIndexOf(41) + 1;\n-            return typeOfSignature(signature.substring(index));\n+            return typeOfSignature(s.substring(s.lastIndexOf(41) + 1));\n         }\n-        catch (final StringIndexOutOfBoundsException e) {\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)e);\n+        catch (final StringIndexOutOfBoundsException ex) {\n+            throw new ClassFormatException(\"Invalid method signature: \" + s, (Throwable)ex);\n         }\n     }\n     \n-    public static byte typeOfSignature(final String signature) throws ClassFormatException {\n+    public static byte typeOfSignature(final String s) throws ClassFormatException {\n         try {\n-            switch (signature.charAt(0)) {\n+            switch (s.charAt(0)) {\n                 case 'B': {\n                     return 8;\n                 }\n                 case 'C': {\n                     return 5;\n                 }\n                 case 'D': {\n@@ -845,222 +836,222 @@\n                 }\n                 case 'S': {\n                     return 9;\n                 }\n                 case '!':\n                 case '*':\n                 case '+': {\n-                    return typeOfSignature(signature.substring(1));\n+                    return typeOfSignature(s.substring(1));\n                 }\n                 default: {\n-                    throw new ClassFormatException(\"Invalid method signature: \" + signature);\n+                    throw new ClassFormatException(\"Invalid method signature: \" + s);\n                 }\n             }\n         }\n-        catch (final StringIndexOutOfBoundsException e) {\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)e);\n+        catch (final StringIndexOutOfBoundsException ex) {\n+            throw new ClassFormatException(\"Invalid method signature: \" + s, (Throwable)ex);\n         }\n     }\n     \n-    public static short searchOpcode(String name) {\n-        name = name.toLowerCase(Locale.ENGLISH);\n-        for (short i = 0; i < Const.OPCODE_NAMES_LENGTH; ++i) {\n-            if (Const.getOpcodeName((int)i).equals(name)) {\n-                return i;\n+    public static short searchOpcode(String lowerCase) {\n+        lowerCase = lowerCase.toLowerCase(Locale.ENGLISH);\n+        for (short n = 0; n < Const.OPCODE_NAMES_LENGTH; ++n) {\n+            if (Const.getOpcodeName((int)n).equals(lowerCase)) {\n+                return n;\n             }\n         }\n         return -1;\n     }\n     \n     private static short byteToShort(final byte b) {\n         return (b < 0) ? ((short)(256 + b)) : ((short)b);\n     }\n     \n-    public static String toHexString(final byte[] bytes) {\n-        final StringBuilder buf = new StringBuilder();\n-        for (int i = 0; i < bytes.length; ++i) {\n-            final short b = byteToShort(bytes[i]);\n-            final String hex = Integer.toHexString(b);\n-            if (b < 16) {\n-                buf.append('0');\n+    public static String toHexString(final byte[] array) {\n+        final StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < array.length; ++i) {\n+            final short byteToShort = byteToShort(array[i]);\n+            final String hexString = Integer.toHexString(byteToShort);\n+            if (byteToShort < 16) {\n+                sb.append('0');\n             }\n-            buf.append(hex);\n-            if (i < bytes.length - 1) {\n-                buf.append(' ');\n+            sb.append(hexString);\n+            if (i < array.length - 1) {\n+                sb.append(' ');\n             }\n         }\n-        return buf.toString();\n+        return sb.toString();\n     }\n     \n-    public static String format(final int i, final int length, final boolean left_justify, final char fill) {\n-        return fillup(Integer.toString(i), length, left_justify, fill);\n+    public static String format(final int i, final int n, final boolean b, final char c) {\n+        return fillup(Integer.toString(i), n, b, c);\n     }\n     \n-    public static String fillup(final String str, final int length, final boolean left_justify, final char fill) {\n-        final int len = length - str.length();\n-        final char[] buf = new char[(len < 0) ? 0 : len];\n-        for (int j = 0; j < buf.length; ++j) {\n-            buf[j] = fill;\n+    public static String fillup(final String s, final int n, final boolean b, final char c) {\n+        final int n2 = n - s.length();\n+        final char[] array = new char[(n2 < 0) ? 0 : n2];\n+        for (int i = 0; i < array.length; ++i) {\n+            array[i] = c;\n         }\n-        if (left_justify) {\n-            return str + new String(buf);\n+        if (b) {\n+            return s + new String(array);\n         }\n-        return new String(buf) + str;\n+        return new String(array) + s;\n     }\n     \n-    static boolean equals(final byte[] a, final byte[] b) {\n-        final int size;\n-        if ((size = a.length) != b.length) {\n+    static boolean equals(final byte[] array, final byte[] array2) {\n+        final int length;\n+        if ((length = array.length) != array2.length) {\n             return false;\n         }\n-        for (int i = 0; i < size; ++i) {\n-            if (a[i] != b[i]) {\n+        for (int i = 0; i < length; ++i) {\n+            if (array[i] != array2[i]) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    public static void printArray(final PrintStream out, final Object[] obj) {\n-        out.println(printArray(obj, true));\n+    public static void printArray(final PrintStream printStream, final Object[] array) {\n+        printStream.println(printArray(array, true));\n     }\n     \n-    public static void printArray(final PrintWriter out, final Object[] obj) {\n-        out.println(printArray(obj, true));\n+    public static void printArray(final PrintWriter printWriter, final Object[] array) {\n+        printWriter.println(printArray(array, true));\n     }\n     \n-    public static String printArray(final Object[] obj) {\n-        return printArray(obj, true);\n+    public static String printArray(final Object[] array) {\n+        return printArray(array, true);\n     }\n     \n-    public static String printArray(final Object[] obj, final boolean braces) {\n-        return printArray(obj, braces, false);\n+    public static String printArray(final Object[] array, final boolean b) {\n+        return printArray(array, b, false);\n     }\n     \n-    public static String printArray(final Object[] obj, final boolean braces, final boolean quote) {\n-        if (obj == null) {\n+    public static String printArray(final Object[] array, final boolean b, final boolean b2) {\n+        if (array == null) {\n             return null;\n         }\n-        final StringBuilder buf = new StringBuilder();\n-        if (braces) {\n-            buf.append('{');\n-        }\n-        for (int i = 0; i < obj.length; ++i) {\n-            if (obj[i] != null) {\n-                buf.append(quote ? \"\\\"\" : \"\").append(obj[i]).append(quote ? \"\\\"\" : \"\");\n+        final StringBuilder sb = new StringBuilder();\n+        if (b) {\n+            sb.append('{');\n+        }\n+        for (int i = 0; i < array.length; ++i) {\n+            if (array[i] != null) {\n+                sb.append(b2 ? \"\\\"\" : \"\").append(array[i]).append(b2 ? \"\\\"\" : \"\");\n             }\n             else {\n-                buf.append(\"null\");\n+                sb.append(\"null\");\n             }\n-            if (i < obj.length - 1) {\n-                buf.append(\", \");\n+            if (i < array.length - 1) {\n+                sb.append(\", \");\n             }\n         }\n-        if (braces) {\n-            buf.append('}');\n+        if (b) {\n+            sb.append('}');\n         }\n-        return buf.toString();\n+        return sb.toString();\n     }\n     \n-    public static boolean isJavaIdentifierPart(final char ch) {\n-        return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch == '_';\n+    public static boolean isJavaIdentifierPart(final char c) {\n+        return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '_';\n     }\n     \n-    public static String encode(byte[] bytes, final boolean compress) throws IOException {\n-        if (compress) {\n-            try (final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-                 final GZIPOutputStream gos = new GZIPOutputStream(baos)) {\n-                gos.write(bytes, 0, bytes.length);\n-                bytes = baos.toByteArray();\n+    public static String encode(byte[] byteArray, final boolean b) throws IOException {\n+        if (b) {\n+            try (final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+                 final GZIPOutputStream gzipOutputStream = new GZIPOutputStream(out)) {\n+                gzipOutputStream.write(byteArray, 0, byteArray.length);\n+                byteArray = out.toByteArray();\n             }\n         }\n-        final CharArrayWriter caw = new CharArrayWriter();\n-        try (final Utility.JavaWriter jw = new Utility.JavaWriter((Writer)caw)) {\n-            for (final byte b : bytes) {\n-                final int in = b & 0xFF;\n-                jw.write(in);\n+        final CharArrayWriter charArrayWriter = new CharArrayWriter();\n+        try (final Utility.JavaWriter javaWriter = new Utility.JavaWriter((Writer)charArrayWriter)) {\n+            final byte[] array = byteArray;\n+            for (int length = array.length, i = 0; i < length; ++i) {\n+                javaWriter.write(array[i] & 0xFF);\n             }\n         }\n-        return caw.toString();\n+        return charArrayWriter.toString();\n     }\n     \n-    public static byte[] decode(final String s, final boolean uncompress) throws IOException {\n-        byte[] bytes;\n-        try (final Utility.JavaReader jr = new Utility.JavaReader((Reader)new CharArrayReader(s.toCharArray()));\n-             final ByteArrayOutputStream bos = new ByteArrayOutputStream()) {\n-            int ch;\n-            while ((ch = jr.read()) >= 0) {\n-                bos.write(ch);\n+    public static byte[] decode(final String s, final boolean b) throws IOException {\n+        byte[] byteArray;\n+        try (final Utility.JavaReader javaReader = new Utility.JavaReader((Reader)new CharArrayReader(s.toCharArray()));\n+             final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) {\n+            int read;\n+            while ((read = javaReader.read()) >= 0) {\n+                byteArrayOutputStream.write(read);\n             }\n-            bytes = bos.toByteArray();\n+            byteArray = byteArrayOutputStream.toByteArray();\n         }\n-        if (uncompress) {\n-            final GZIPInputStream gis = new GZIPInputStream(new ByteArrayInputStream(bytes));\n-            final byte[] tmp = new byte[bytes.length * 3];\n-            int count = 0;\n-            int b;\n-            while ((b = gis.read()) >= 0) {\n-                tmp[count++] = (byte)b;\n+        if (b) {\n+            final GZIPInputStream gzipInputStream = new GZIPInputStream(new ByteArrayInputStream(byteArray));\n+            final byte[] array = new byte[byteArray.length * 3];\n+            int n = 0;\n+            int read2;\n+            while ((read2 = gzipInputStream.read()) >= 0) {\n+                array[n++] = (byte)read2;\n             }\n-            bytes = new byte[count];\n-            System.arraycopy(tmp, 0, bytes, 0, count);\n+            byteArray = new byte[n];\n+            System.arraycopy(array, 0, byteArray, 0, n);\n         }\n-        return bytes;\n+        return byteArray;\n     }\n     \n-    public static String convertString(final String label) {\n-        final char[] ch = label.toCharArray();\n-        final StringBuilder buf = new StringBuilder();\n-        for (final char element : ch) {\n-            switch (element) {\n-                case '\\n': {\n-                    buf.append(\"\\\\n\");\n+    public static String convertString(final String s) {\n+        final char[] charArray = s.toCharArray();\n+        final StringBuilder sb = new StringBuilder();\n+        for (final char c : charArray) {\n+            switch (c) {\n+                case 10: {\n+                    sb.append(\"\\\\n\");\n                     break;\n                 }\n-                case '\\r': {\n-                    buf.append(\"\\\\r\");\n+                case 13: {\n+                    sb.append(\"\\\\r\");\n                     break;\n                 }\n-                case '\\\"': {\n-                    buf.append(\"\\\\\\\"\");\n+                case 34: {\n+                    sb.append(\"\\\\\\\"\");\n                     break;\n                 }\n-                case '\\'': {\n-                    buf.append(\"\\\\'\");\n+                case 39: {\n+                    sb.append(\"\\\\'\");\n                     break;\n                 }\n-                case '\\\\': {\n-                    buf.append(\"\\\\\\\\\");\n+                case 92: {\n+                    sb.append(\"\\\\\\\\\");\n                     break;\n                 }\n                 default: {\n-                    buf.append(element);\n+                    sb.append(c);\n                     break;\n                 }\n             }\n         }\n-        return buf.toString();\n+        return sb.toString();\n     }\n     \n     static {\n         Utility.consumed_chars = (ThreadLocal<Integer>)new Utility.Utility$1();\n         Utility.wide = false;\n         Utility.CHAR_MAP = new int[48];\n         Utility.MAP_CHAR = new int[256];\n-        int j = 0;\n+        int n = 0;\n         for (int i = 65; i <= 90; ++i) {\n-            Utility.CHAR_MAP[j] = i;\n-            Utility.MAP_CHAR[i] = j;\n-            ++j;\n-        }\n-        for (int i = 103; i <= 122; ++i) {\n-            Utility.CHAR_MAP[j] = i;\n-            Utility.MAP_CHAR[i] = j;\n-            ++j;\n-        }\n-        Utility.CHAR_MAP[j] = 36;\n-        Utility.MAP_CHAR[36] = j;\n-        ++j;\n-        Utility.CHAR_MAP[j] = 95;\n-        Utility.MAP_CHAR[95] = j;\n+            Utility.CHAR_MAP[n] = i;\n+            Utility.MAP_CHAR[i] = n;\n+            ++n;\n+        }\n+        for (int j = 103; j <= 122; ++j) {\n+            Utility.CHAR_MAP[n] = j;\n+            Utility.MAP_CHAR[j] = n;\n+            ++n;\n+        }\n+        Utility.CHAR_MAP[n] = 36;\n+        Utility.MAP_CHAR[36] = n;\n+        ++n;\n+        Utility.CHAR_MAP[n] = 95;\n+        Utility.MAP_CHAR[95] = n;\n     }\n }\n"}]}
