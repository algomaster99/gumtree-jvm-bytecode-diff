{"diffoscope-json-version": 1, "source1": "first/SevenZOutputFile.class", "source2": "second/SevenZOutputFile.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -45,572 +45,579 @@\n     private long fileBytesWritten;\n     private boolean finished;\n     private CountingOutputStream currentOutputStream;\n     private CountingOutputStream[] additionalCountingStreams;\n     private Iterable<? extends SevenZMethodConfiguration> contentMethods;\n     private final Map<SevenZArchiveEntry, long[]> additionalSizes;\n     \n-    public SevenZOutputFile(final File fileName) throws IOException {\n-        this(Files.newByteChannel(fileName.toPath(), (Set<? extends OpenOption>)EnumSet.of(StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING), (FileAttribute<?>[])new FileAttribute[0]));\n+    public SevenZOutputFile(final File file) throws IOException {\n+        this(Files.newByteChannel(file.toPath(), (Set<? extends OpenOption>)EnumSet.of(StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING), (FileAttribute<?>[])new FileAttribute[0]));\n     }\n     \n     public SevenZOutputFile(final SeekableByteChannel channel) throws IOException {\n         this.files = new ArrayList<SevenZArchiveEntry>();\n         this.crc32 = new CRC32();\n         this.compressedCrc32 = new CRC32();\n         this.contentMethods = Collections.singletonList(new SevenZMethodConfiguration(SevenZMethod.LZMA2));\n         this.additionalSizes = new HashMap<SevenZArchiveEntry, long[]>();\n         (this.channel = channel).position(32L);\n     }\n     \n-    public void setContentCompression(final SevenZMethod method) {\n-        this.setContentMethods(Collections.singletonList(new SevenZMethodConfiguration(method)));\n+    public void setContentCompression(final SevenZMethod sevenZMethod) {\n+        this.setContentMethods(Collections.singletonList(new SevenZMethodConfiguration(sevenZMethod)));\n     }\n     \n-    public void setContentMethods(final Iterable<? extends SevenZMethodConfiguration> methods) {\n-        this.contentMethods = reverse(methods);\n+    public void setContentMethods(final Iterable<? extends SevenZMethodConfiguration> iterable) {\n+        this.contentMethods = reverse(iterable);\n     }\n     \n     @Override\n     public void close() throws IOException {\n         try {\n             if (!this.finished) {\n                 this.finish();\n             }\n         }\n         finally {\n             this.channel.close();\n         }\n     }\n     \n-    public SevenZArchiveEntry createArchiveEntry(final File inputFile, final String entryName) throws IOException {\n-        final SevenZArchiveEntry entry = new SevenZArchiveEntry();\n-        entry.setDirectory(inputFile.isDirectory());\n-        entry.setName(entryName);\n-        entry.setLastModifiedDate(new Date(inputFile.lastModified()));\n-        return entry;\n+    public SevenZArchiveEntry createArchiveEntry(final File file, final String name) throws IOException {\n+        final SevenZArchiveEntry sevenZArchiveEntry = new SevenZArchiveEntry();\n+        sevenZArchiveEntry.setDirectory(file.isDirectory());\n+        sevenZArchiveEntry.setName(name);\n+        sevenZArchiveEntry.setLastModifiedDate(new Date(file.lastModified()));\n+        return sevenZArchiveEntry;\n     }\n     \n-    public SevenZArchiveEntry createArchiveEntry(final Path inputPath, final String entryName, final LinkOption... options) throws IOException {\n-        final SevenZArchiveEntry entry = new SevenZArchiveEntry();\n-        entry.setDirectory(Files.isDirectory(inputPath, options));\n-        entry.setName(entryName);\n-        entry.setLastModifiedDate(new Date(Files.getLastModifiedTime(inputPath, options).toMillis()));\n-        return entry;\n+    public SevenZArchiveEntry createArchiveEntry(final Path path, final String name, final LinkOption... array) throws IOException {\n+        final SevenZArchiveEntry sevenZArchiveEntry = new SevenZArchiveEntry();\n+        sevenZArchiveEntry.setDirectory(Files.isDirectory(path, array));\n+        sevenZArchiveEntry.setName(name);\n+        sevenZArchiveEntry.setLastModifiedDate(new Date(Files.getLastModifiedTime(path, array).toMillis()));\n+        return sevenZArchiveEntry;\n     }\n     \n     public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\n-        final SevenZArchiveEntry entry = (SevenZArchiveEntry)archiveEntry;\n-        this.files.add(entry);\n+        this.files.add((SevenZArchiveEntry)archiveEntry);\n     }\n     \n     public void closeArchiveEntry() throws IOException {\n         if (this.currentOutputStream != null) {\n             this.currentOutputStream.flush();\n             this.currentOutputStream.close();\n         }\n-        final SevenZArchiveEntry entry = (SevenZArchiveEntry)this.files.get(this.files.size() - 1);\n+        final SevenZArchiveEntry sevenZArchiveEntry = (SevenZArchiveEntry)this.files.get(this.files.size() - 1);\n         if (this.fileBytesWritten > 0L) {\n-            entry.setHasStream(true);\n+            sevenZArchiveEntry.setHasStream(true);\n             ++this.numNonEmptyStreams;\n-            entry.setSize(this.currentOutputStream.getBytesWritten());\n-            entry.setCompressedSize(this.fileBytesWritten);\n-            entry.setCrcValue(this.crc32.getValue());\n-            entry.setCompressedCrcValue(this.compressedCrc32.getValue());\n-            entry.setHasCrc(true);\n+            sevenZArchiveEntry.setSize(this.currentOutputStream.getBytesWritten());\n+            sevenZArchiveEntry.setCompressedSize(this.fileBytesWritten);\n+            sevenZArchiveEntry.setCrcValue(this.crc32.getValue());\n+            sevenZArchiveEntry.setCompressedCrcValue(this.compressedCrc32.getValue());\n+            sevenZArchiveEntry.setHasCrc(true);\n             if (this.additionalCountingStreams != null) {\n-                final long[] sizes = new long[this.additionalCountingStreams.length];\n+                final long[] array = new long[this.additionalCountingStreams.length];\n                 for (int i = 0; i < this.additionalCountingStreams.length; ++i) {\n-                    sizes[i] = this.additionalCountingStreams[i].getBytesWritten();\n+                    array[i] = this.additionalCountingStreams[i].getBytesWritten();\n                 }\n-                this.additionalSizes.put(entry, sizes);\n+                this.additionalSizes.put(sevenZArchiveEntry, array);\n             }\n         }\n         else {\n-            entry.setHasStream(false);\n-            entry.setSize(0L);\n-            entry.setCompressedSize(0L);\n-            entry.setHasCrc(false);\n+            sevenZArchiveEntry.setHasStream(false);\n+            sevenZArchiveEntry.setSize(0L);\n+            sevenZArchiveEntry.setCompressedSize(0L);\n+            sevenZArchiveEntry.setHasCrc(false);\n         }\n         this.currentOutputStream = null;\n         this.additionalCountingStreams = null;\n         this.crc32.reset();\n         this.compressedCrc32.reset();\n         this.fileBytesWritten = 0L;\n     }\n     \n-    public void write(final int b) throws IOException {\n-        this.getCurrentOutputStream().write(b);\n+    public void write(final int n) throws IOException {\n+        this.getCurrentOutputStream().write(n);\n     }\n     \n-    public void write(final byte[] b) throws IOException {\n-        this.write(b, 0, b.length);\n+    public void write(final byte[] array) throws IOException {\n+        this.write(array, 0, array.length);\n     }\n     \n     public void write(final byte[] b, final int off, final int len) throws IOException {\n         if (len > 0) {\n             this.getCurrentOutputStream().write(b, off, len);\n         }\n     }\n     \n     public void write(final InputStream inputStream) throws IOException {\n-        final byte[] buffer = new byte[8024];\n-        int n = 0;\n-        while (-1 != (n = inputStream.read(buffer))) {\n-            this.write(buffer, 0, n);\n+        final byte[] b = new byte[8024];\n+        int read;\n+        while (-1 != (read = inputStream.read(b))) {\n+            this.write(b, 0, read);\n         }\n     }\n     \n     public void write(final Path path, final OpenOption... options) throws IOException {\n-        try (final InputStream in = new BufferedInputStream(Files.newInputStream(path, options))) {\n-            this.write(in);\n+        try (final BufferedInputStream bufferedInputStream = new BufferedInputStream(Files.newInputStream(path, options))) {\n+            this.write(bufferedInputStream);\n         }\n     }\n     \n     public void finish() throws IOException {\n         if (this.finished) {\n             throw new IOException(\"This archive has already been finished\");\n         }\n         this.finished = true;\n-        final long headerPosition = this.channel.position();\n-        final ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();\n-        final DataOutputStream header = new DataOutputStream(headerBaos);\n-        this.writeHeader(header);\n-        header.flush();\n-        final byte[] headerBytes = headerBaos.toByteArray();\n-        this.channel.write(ByteBuffer.wrap(headerBytes));\n+        final long position = this.channel.position();\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final DataOutputStream dataOutputStream = new DataOutputStream(out);\n+        this.writeHeader(dataOutputStream);\n+        dataOutputStream.flush();\n+        final byte[] byteArray = out.toByteArray();\n+        this.channel.write(ByteBuffer.wrap(byteArray));\n         final CRC32 crc32 = new CRC32();\n-        crc32.update(headerBytes);\n-        final ByteBuffer bb = ByteBuffer.allocate(SevenZFile.sevenZSignature.length + 2 + 4 + 8 + 8 + 4).order(ByteOrder.LITTLE_ENDIAN);\n+        crc32.update(byteArray);\n+        final ByteBuffer order = ByteBuffer.allocate(SevenZFile.sevenZSignature.length + 2 + 4 + 8 + 8 + 4).order(ByteOrder.LITTLE_ENDIAN);\n         this.channel.position(0L);\n-        bb.put(SevenZFile.sevenZSignature);\n-        bb.put((byte)0).put((byte)2);\n-        bb.putInt(0);\n-        bb.putLong(headerPosition - 32L).putLong(0xFFFFFFFFL & (long)headerBytes.length).putInt((int)crc32.getValue());\n+        order.put(SevenZFile.sevenZSignature);\n+        order.put((byte)0).put((byte)2);\n+        order.putInt(0);\n+        order.putLong(position - 32L).putLong(0xFFFFFFFFL & (long)byteArray.length).putInt((int)crc32.getValue());\n         crc32.reset();\n-        crc32.update(bb.array(), SevenZFile.sevenZSignature.length + 6, 20);\n-        bb.putInt(SevenZFile.sevenZSignature.length + 2, (int)crc32.getValue());\n-        bb.flip();\n-        this.channel.write(bb);\n+        crc32.update(order.array(), SevenZFile.sevenZSignature.length + 6, 20);\n+        order.putInt(SevenZFile.sevenZSignature.length + 2, (int)crc32.getValue());\n+        order.flip();\n+        this.channel.write(order);\n     }\n     \n     private OutputStream getCurrentOutputStream() throws IOException {\n         if (this.currentOutputStream == null) {\n             this.currentOutputStream = this.setupFileOutputStream();\n         }\n         return (OutputStream)this.currentOutputStream;\n     }\n     \n     private CountingOutputStream setupFileOutputStream() throws IOException {\n         if (this.files.isEmpty()) {\n             throw new IllegalStateException(\"No current 7z entry\");\n         }\n-        OutputStream out = (OutputStream)new SevenZOutputFile.OutputStreamWrapper(this, (SevenZOutputFile.SevenZOutputFile$1)null);\n-        final ArrayList<CountingOutputStream> moreStreams = new ArrayList<CountingOutputStream>();\n-        boolean first = true;\n-        for (final SevenZMethodConfiguration m : this.getContentMethods(this.files.get(this.files.size() - 1))) {\n-            if (!first) {\n-                final CountingOutputStream cos = new CountingOutputStream(out);\n-                moreStreams.add(cos);\n-                out = (OutputStream)cos;\n+        Object addEncoder = new SevenZOutputFile.OutputStreamWrapper(this, (SevenZOutputFile.SevenZOutputFile$1)null);\n+        final ArrayList list = new ArrayList();\n+        int n = 1;\n+        for (final SevenZMethodConfiguration sevenZMethodConfiguration : this.getContentMethods(this.files.get(this.files.size() - 1))) {\n+            if (n == 0) {\n+                final CountingOutputStream e = new CountingOutputStream((OutputStream)addEncoder);\n+                list.add(e);\n+                addEncoder = e;\n             }\n-            out = Coders.addEncoder(out, m.getMethod(), m.getOptions());\n-            first = false;\n+            addEncoder = Coders.addEncoder((OutputStream)addEncoder, sevenZMethodConfiguration.getMethod(), sevenZMethodConfiguration.getOptions());\n+            n = 0;\n         }\n-        if (!moreStreams.isEmpty()) {\n-            this.additionalCountingStreams = moreStreams.toArray(new CountingOutputStream[0]);\n+        if (!list.isEmpty()) {\n+            this.additionalCountingStreams = list.toArray(new CountingOutputStream[0]);\n         }\n-        return (CountingOutputStream)new SevenZOutputFile.SevenZOutputFile$1(this, out);\n+        return (CountingOutputStream)new SevenZOutputFile.SevenZOutputFile$1(this, (OutputStream)addEncoder);\n     }\n     \n-    private Iterable<? extends SevenZMethodConfiguration> getContentMethods(final SevenZArchiveEntry entry) {\n-        final Iterable<? extends SevenZMethodConfiguration> ms = entry.getContentMethods();\n-        return (ms == null) ? this.contentMethods : ms;\n+    private Iterable<? extends SevenZMethodConfiguration> getContentMethods(final SevenZArchiveEntry sevenZArchiveEntry) {\n+        final Iterable contentMethods = sevenZArchiveEntry.getContentMethods();\n+        return (contentMethods == null) ? this.contentMethods : contentMethods;\n     }\n     \n-    private void writeHeader(final DataOutput header) throws IOException {\n-        header.write(1);\n-        header.write(4);\n-        this.writeStreamsInfo(header);\n-        this.writeFilesInfo(header);\n-        header.write(0);\n+    private void writeHeader(final DataOutput dataOutput) throws IOException {\n+        dataOutput.write(1);\n+        dataOutput.write(4);\n+        this.writeStreamsInfo(dataOutput);\n+        this.writeFilesInfo(dataOutput);\n+        dataOutput.write(0);\n     }\n     \n-    private void writeStreamsInfo(final DataOutput header) throws IOException {\n+    private void writeStreamsInfo(final DataOutput dataOutput) throws IOException {\n         if (this.numNonEmptyStreams > 0) {\n-            this.writePackInfo(header);\n-            this.writeUnpackInfo(header);\n+            this.writePackInfo(dataOutput);\n+            this.writeUnpackInfo(dataOutput);\n         }\n-        this.writeSubStreamsInfo(header);\n-        header.write(0);\n+        this.writeSubStreamsInfo(dataOutput);\n+        dataOutput.write(0);\n     }\n     \n-    private void writePackInfo(final DataOutput header) throws IOException {\n-        header.write(6);\n-        this.writeUint64(header, 0L);\n-        this.writeUint64(header, 0xFFFFFFFFL & (long)this.numNonEmptyStreams);\n-        header.write(9);\n-        for (final SevenZArchiveEntry entry : this.files) {\n-            if (entry.hasStream()) {\n-                this.writeUint64(header, entry.getCompressedSize());\n-            }\n-        }\n-        header.write(10);\n-        header.write(1);\n-        for (final SevenZArchiveEntry entry : this.files) {\n-            if (entry.hasStream()) {\n-                header.writeInt(Integer.reverseBytes((int)entry.getCompressedCrcValue()));\n-            }\n-        }\n-        header.write(0);\n-    }\n-    \n-    private void writeUnpackInfo(final DataOutput header) throws IOException {\n-        header.write(7);\n-        header.write(11);\n-        this.writeUint64(header, this.numNonEmptyStreams);\n-        header.write(0);\n-        for (final SevenZArchiveEntry entry : this.files) {\n-            if (entry.hasStream()) {\n-                this.writeFolder(header, entry);\n-            }\n-        }\n-        header.write(12);\n-        for (final SevenZArchiveEntry entry : this.files) {\n-            if (entry.hasStream()) {\n-                final long[] moreSizes = (long[])this.additionalSizes.get(entry);\n-                if (moreSizes != null) {\n-                    for (final long s : moreSizes) {\n-                        this.writeUint64(header, s);\n+    private void writePackInfo(final DataOutput dataOutput) throws IOException {\n+        dataOutput.write(6);\n+        this.writeUint64(dataOutput, 0L);\n+        this.writeUint64(dataOutput, 0xFFFFFFFFL & (long)this.numNonEmptyStreams);\n+        dataOutput.write(9);\n+        for (final SevenZArchiveEntry sevenZArchiveEntry : this.files) {\n+            if (sevenZArchiveEntry.hasStream()) {\n+                this.writeUint64(dataOutput, sevenZArchiveEntry.getCompressedSize());\n+            }\n+        }\n+        dataOutput.write(10);\n+        dataOutput.write(1);\n+        for (final SevenZArchiveEntry sevenZArchiveEntry2 : this.files) {\n+            if (sevenZArchiveEntry2.hasStream()) {\n+                dataOutput.writeInt(Integer.reverseBytes((int)sevenZArchiveEntry2.getCompressedCrcValue()));\n+            }\n+        }\n+        dataOutput.write(0);\n+    }\n+    \n+    private void writeUnpackInfo(final DataOutput dataOutput) throws IOException {\n+        dataOutput.write(7);\n+        dataOutput.write(11);\n+        this.writeUint64(dataOutput, this.numNonEmptyStreams);\n+        dataOutput.write(0);\n+        for (final SevenZArchiveEntry sevenZArchiveEntry : this.files) {\n+            if (sevenZArchiveEntry.hasStream()) {\n+                this.writeFolder(dataOutput, sevenZArchiveEntry);\n+            }\n+        }\n+        dataOutput.write(12);\n+        for (final SevenZArchiveEntry sevenZArchiveEntry2 : this.files) {\n+            if (sevenZArchiveEntry2.hasStream()) {\n+                final long[] array = (long[])this.additionalSizes.get(sevenZArchiveEntry2);\n+                if (array != null) {\n+                    final long[] array2 = array;\n+                    for (int length = array2.length, i = 0; i < length; ++i) {\n+                        this.writeUint64(dataOutput, array2[i]);\n                     }\n                 }\n-                this.writeUint64(header, entry.getSize());\n+                this.writeUint64(dataOutput, sevenZArchiveEntry2.getSize());\n             }\n         }\n-        header.write(10);\n-        header.write(1);\n-        for (final SevenZArchiveEntry entry : this.files) {\n-            if (entry.hasStream()) {\n-                header.writeInt(Integer.reverseBytes((int)entry.getCrcValue()));\n+        dataOutput.write(10);\n+        dataOutput.write(1);\n+        for (final SevenZArchiveEntry sevenZArchiveEntry3 : this.files) {\n+            if (sevenZArchiveEntry3.hasStream()) {\n+                dataOutput.writeInt(Integer.reverseBytes((int)sevenZArchiveEntry3.getCrcValue()));\n             }\n         }\n-        header.write(0);\n+        dataOutput.write(0);\n     }\n     \n-    private void writeFolder(final DataOutput header, final SevenZArchiveEntry entry) throws IOException {\n-        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        int numCoders = 0;\n-        for (final SevenZMethodConfiguration m : this.getContentMethods(entry)) {\n-            ++numCoders;\n-            this.writeSingleCodec(m, bos);\n+    private void writeFolder(final DataOutput dataOutput, final SevenZArchiveEntry sevenZArchiveEntry) throws IOException {\n+        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+        int n = 0;\n+        for (final SevenZMethodConfiguration sevenZMethodConfiguration : this.getContentMethods(sevenZArchiveEntry)) {\n+            ++n;\n+            this.writeSingleCodec(sevenZMethodConfiguration, byteArrayOutputStream);\n+        }\n+        this.writeUint64(dataOutput, n);\n+        dataOutput.write(byteArrayOutputStream.toByteArray());\n+        for (long n2 = 0L; n2 < n - 1; ++n2) {\n+            this.writeUint64(dataOutput, n2 + 1L);\n+            this.writeUint64(dataOutput, n2);\n         }\n-        this.writeUint64(header, numCoders);\n-        header.write(bos.toByteArray());\n-        for (long i = 0L; i < numCoders - 1; ++i) {\n-            this.writeUint64(header, i + 1L);\n-            this.writeUint64(header, i);\n+    }\n+    \n+    private void writeSingleCodec(final SevenZMethodConfiguration sevenZMethodConfiguration, final OutputStream outputStream) throws IOException {\n+        final byte[] id = sevenZMethodConfiguration.getMethod().getId();\n+        final byte[] optionsAsProperties = Coders.findByMethod(sevenZMethodConfiguration.getMethod()).getOptionsAsProperties(sevenZMethodConfiguration.getOptions());\n+        int length = id.length;\n+        if (optionsAsProperties.length > 0) {\n+            length |= 0x20;\n+        }\n+        outputStream.write(length);\n+        outputStream.write(id);\n+        if (optionsAsProperties.length > 0) {\n+            outputStream.write(optionsAsProperties.length);\n+            outputStream.write(optionsAsProperties);\n         }\n     }\n     \n-    private void writeSingleCodec(final SevenZMethodConfiguration m, final OutputStream bos) throws IOException {\n-        final byte[] id = m.getMethod().getId();\n-        final byte[] properties = Coders.findByMethod(m.getMethod()).getOptionsAsProperties(m.getOptions());\n-        int codecFlags = id.length;\n-        if (properties.length > 0) {\n-            codecFlags |= 0x20;\n+    private void writeSubStreamsInfo(final DataOutput dataOutput) throws IOException {\n+        dataOutput.write(8);\n+        dataOutput.write(0);\n+    }\n+    \n+    private void writeFilesInfo(final DataOutput dataOutput) throws IOException {\n+        dataOutput.write(5);\n+        this.writeUint64(dataOutput, this.files.size());\n+        this.writeFileEmptyStreams(dataOutput);\n+        this.writeFileEmptyFiles(dataOutput);\n+        this.writeFileAntiItems(dataOutput);\n+        this.writeFileNames(dataOutput);\n+        this.writeFileCTimes(dataOutput);\n+        this.writeFileATimes(dataOutput);\n+        this.writeFileMTimes(dataOutput);\n+        this.writeFileWindowsAttributes(dataOutput);\n+        dataOutput.write(0);\n+    }\n+    \n+    private void writeFileEmptyStreams(final DataOutput dataOutput) throws IOException {\n+        boolean b = false;\n+        final Iterator<SevenZArchiveEntry> iterator = this.files.iterator();\n+        while (iterator.hasNext()) {\n+            if (!((SevenZArchiveEntry)iterator.next()).hasStream()) {\n+                b = true;\n+                break;\n+            }\n         }\n-        bos.write(codecFlags);\n-        bos.write(id);\n-        if (properties.length > 0) {\n-            bos.write(properties.length);\n-            bos.write(properties);\n+        if (b) {\n+            dataOutput.write(14);\n+            final BitSet set = new BitSet(this.files.size());\n+            for (int i = 0; i < this.files.size(); ++i) {\n+                set.set(i, !((SevenZArchiveEntry)this.files.get(i)).hasStream());\n+            }\n+            final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+            final DataOutputStream dataOutputStream = new DataOutputStream(out);\n+            this.writeBits(dataOutputStream, set, this.files.size());\n+            dataOutputStream.flush();\n+            final byte[] byteArray = out.toByteArray();\n+            this.writeUint64(dataOutput, byteArray.length);\n+            dataOutput.write(byteArray);\n         }\n     }\n     \n-    private void writeSubStreamsInfo(final DataOutput header) throws IOException {\n-        header.write(8);\n-        header.write(0);\n+    private void writeFileEmptyFiles(final DataOutput dataOutput) throws IOException {\n+        boolean b = false;\n+        int n = 0;\n+        final BitSet set = new BitSet(0);\n+        for (final SevenZArchiveEntry sevenZArchiveEntry : this.files) {\n+            if (!sevenZArchiveEntry.hasStream()) {\n+                final boolean directory = sevenZArchiveEntry.isDirectory();\n+                set.set(n++, !directory);\n+                b |= !directory;\n+            }\n+        }\n+        if (b) {\n+            dataOutput.write(15);\n+            final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+            final DataOutputStream dataOutputStream = new DataOutputStream(out);\n+            this.writeBits(dataOutputStream, set, n);\n+            dataOutputStream.flush();\n+            final byte[] byteArray = out.toByteArray();\n+            this.writeUint64(dataOutput, byteArray.length);\n+            dataOutput.write(byteArray);\n+        }\n     }\n     \n-    private void writeFilesInfo(final DataOutput header) throws IOException {\n-        header.write(5);\n-        this.writeUint64(header, this.files.size());\n-        this.writeFileEmptyStreams(header);\n-        this.writeFileEmptyFiles(header);\n-        this.writeFileAntiItems(header);\n-        this.writeFileNames(header);\n-        this.writeFileCTimes(header);\n-        this.writeFileATimes(header);\n-        this.writeFileMTimes(header);\n-        this.writeFileWindowsAttributes(header);\n-        header.write(0);\n+    private void writeFileAntiItems(final DataOutput dataOutput) throws IOException {\n+        int n = 0;\n+        final BitSet set = new BitSet(0);\n+        int n2 = 0;\n+        for (final SevenZArchiveEntry sevenZArchiveEntry : this.files) {\n+            if (!sevenZArchiveEntry.hasStream()) {\n+                final boolean antiItem = sevenZArchiveEntry.isAntiItem();\n+                set.set(n2++, antiItem);\n+                n |= (antiItem ? 1 : 0);\n+            }\n+        }\n+        if (n != 0) {\n+            dataOutput.write(16);\n+            final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+            final DataOutputStream dataOutputStream = new DataOutputStream(out);\n+            this.writeBits(dataOutputStream, set, n2);\n+            dataOutputStream.flush();\n+            final byte[] byteArray = out.toByteArray();\n+            this.writeUint64(dataOutput, byteArray.length);\n+            dataOutput.write(byteArray);\n+        }\n     }\n     \n-    private void writeFileEmptyStreams(final DataOutput header) throws IOException {\n-        boolean hasEmptyStreams = false;\n-        for (final SevenZArchiveEntry entry : this.files) {\n-            if (!entry.hasStream()) {\n-                hasEmptyStreams = true;\n-                break;\n+    private void writeFileNames(final DataOutput dataOutput) throws IOException {\n+        dataOutput.write(17);\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final DataOutputStream dataOutputStream = new DataOutputStream(out);\n+        dataOutputStream.write(0);\n+        final Iterator<SevenZArchiveEntry> iterator = this.files.iterator();\n+        while (iterator.hasNext()) {\n+            dataOutputStream.write(((SevenZArchiveEntry)iterator.next()).getName().getBytes(StandardCharsets.UTF_16LE));\n+            dataOutputStream.writeShort(0);\n+        }\n+        dataOutputStream.flush();\n+        final byte[] byteArray = out.toByteArray();\n+        this.writeUint64(dataOutput, byteArray.length);\n+        dataOutput.write(byteArray);\n+    }\n+    \n+    private void writeFileCTimes(final DataOutput dataOutput) throws IOException {\n+        int n = 0;\n+        final Iterator<SevenZArchiveEntry> iterator = this.files.iterator();\n+        while (iterator.hasNext()) {\n+            if (((SevenZArchiveEntry)iterator.next()).getHasCreationDate()) {\n+                ++n;\n             }\n         }\n-        if (hasEmptyStreams) {\n-            header.write(14);\n-            final BitSet emptyStreams = new BitSet(this.files.size());\n-            for (int i = 0; i < this.files.size(); ++i) {\n-                emptyStreams.set(i, !((SevenZArchiveEntry)this.files.get(i)).hasStream());\n-            }\n-            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-            final DataOutputStream out = new DataOutputStream(baos);\n-            this.writeBits(out, emptyStreams, this.files.size());\n-            out.flush();\n-            final byte[] contents = baos.toByteArray();\n-            this.writeUint64(header, contents.length);\n-            header.write(contents);\n-        }\n-    }\n-    \n-    private void writeFileEmptyFiles(final DataOutput header) throws IOException {\n-        boolean hasEmptyFiles = false;\n-        int emptyStreamCounter = 0;\n-        final BitSet emptyFiles = new BitSet(0);\n-        for (final SevenZArchiveEntry file1 : this.files) {\n-            if (!file1.hasStream()) {\n-                final boolean isDir = file1.isDirectory();\n-                emptyFiles.set(emptyStreamCounter++, !isDir);\n-                hasEmptyFiles |= !isDir;\n-            }\n-        }\n-        if (hasEmptyFiles) {\n-            header.write(15);\n-            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-            final DataOutputStream out = new DataOutputStream(baos);\n-            this.writeBits(out, emptyFiles, emptyStreamCounter);\n-            out.flush();\n-            final byte[] contents = baos.toByteArray();\n-            this.writeUint64(header, contents.length);\n-            header.write(contents);\n-        }\n-    }\n-    \n-    private void writeFileAntiItems(final DataOutput header) throws IOException {\n-        boolean hasAntiItems = false;\n-        final BitSet antiItems = new BitSet(0);\n-        int antiItemCounter = 0;\n-        for (final SevenZArchiveEntry file1 : this.files) {\n-            if (!file1.hasStream()) {\n-                final boolean isAnti = file1.isAntiItem();\n-                antiItems.set(antiItemCounter++, isAnti);\n-                hasAntiItems |= isAnti;\n-            }\n-        }\n-        if (hasAntiItems) {\n-            header.write(16);\n-            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-            final DataOutputStream out = new DataOutputStream(baos);\n-            this.writeBits(out, antiItems, antiItemCounter);\n-            out.flush();\n-            final byte[] contents = baos.toByteArray();\n-            this.writeUint64(header, contents.length);\n-            header.write(contents);\n-        }\n-    }\n-    \n-    private void writeFileNames(final DataOutput header) throws IOException {\n-        header.write(17);\n-        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        final DataOutputStream out = new DataOutputStream(baos);\n-        out.write(0);\n-        for (final SevenZArchiveEntry entry : this.files) {\n-            out.write(entry.getName().getBytes(StandardCharsets.UTF_16LE));\n-            out.writeShort(0);\n-        }\n-        out.flush();\n-        final byte[] contents = baos.toByteArray();\n-        this.writeUint64(header, contents.length);\n-        header.write(contents);\n-    }\n-    \n-    private void writeFileCTimes(final DataOutput header) throws IOException {\n-        int numCreationDates = 0;\n-        for (final SevenZArchiveEntry entry : this.files) {\n-            if (entry.getHasCreationDate()) {\n-                ++numCreationDates;\n-            }\n-        }\n-        if (numCreationDates > 0) {\n-            header.write(18);\n-            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-            final DataOutputStream out = new DataOutputStream(baos);\n-            if (numCreationDates != this.files.size()) {\n-                out.write(0);\n-                final BitSet cTimes = new BitSet(this.files.size());\n+        if (n > 0) {\n+            dataOutput.write(18);\n+            final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+            final DataOutputStream dataOutputStream = new DataOutputStream(out);\n+            if (n != this.files.size()) {\n+                dataOutputStream.write(0);\n+                final BitSet set = new BitSet(this.files.size());\n                 for (int i = 0; i < this.files.size(); ++i) {\n-                    cTimes.set(i, ((SevenZArchiveEntry)this.files.get(i)).getHasCreationDate());\n+                    set.set(i, ((SevenZArchiveEntry)this.files.get(i)).getHasCreationDate());\n                 }\n-                this.writeBits(out, cTimes, this.files.size());\n+                this.writeBits(dataOutputStream, set, this.files.size());\n             }\n             else {\n-                out.write(1);\n+                dataOutputStream.write(1);\n             }\n-            out.write(0);\n-            for (final SevenZArchiveEntry entry2 : this.files) {\n-                if (entry2.getHasCreationDate()) {\n-                    out.writeLong(Long.reverseBytes(SevenZArchiveEntry.javaTimeToNtfsTime(entry2.getCreationDate())));\n+            dataOutputStream.write(0);\n+            for (final SevenZArchiveEntry sevenZArchiveEntry : this.files) {\n+                if (sevenZArchiveEntry.getHasCreationDate()) {\n+                    dataOutputStream.writeLong(Long.reverseBytes(SevenZArchiveEntry.javaTimeToNtfsTime(sevenZArchiveEntry.getCreationDate())));\n                 }\n             }\n-            out.flush();\n-            final byte[] contents = baos.toByteArray();\n-            this.writeUint64(header, contents.length);\n-            header.write(contents);\n+            dataOutputStream.flush();\n+            final byte[] byteArray = out.toByteArray();\n+            this.writeUint64(dataOutput, byteArray.length);\n+            dataOutput.write(byteArray);\n         }\n     }\n     \n-    private void writeFileATimes(final DataOutput header) throws IOException {\n-        int numAccessDates = 0;\n-        for (final SevenZArchiveEntry entry : this.files) {\n-            if (entry.getHasAccessDate()) {\n-                ++numAccessDates;\n-            }\n-        }\n-        if (numAccessDates > 0) {\n-            header.write(19);\n-            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-            final DataOutputStream out = new DataOutputStream(baos);\n-            if (numAccessDates != this.files.size()) {\n-                out.write(0);\n-                final BitSet aTimes = new BitSet(this.files.size());\n+    private void writeFileATimes(final DataOutput dataOutput) throws IOException {\n+        int n = 0;\n+        final Iterator<SevenZArchiveEntry> iterator = this.files.iterator();\n+        while (iterator.hasNext()) {\n+            if (((SevenZArchiveEntry)iterator.next()).getHasAccessDate()) {\n+                ++n;\n+            }\n+        }\n+        if (n > 0) {\n+            dataOutput.write(19);\n+            final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+            final DataOutputStream dataOutputStream = new DataOutputStream(out);\n+            if (n != this.files.size()) {\n+                dataOutputStream.write(0);\n+                final BitSet set = new BitSet(this.files.size());\n                 for (int i = 0; i < this.files.size(); ++i) {\n-                    aTimes.set(i, ((SevenZArchiveEntry)this.files.get(i)).getHasAccessDate());\n+                    set.set(i, ((SevenZArchiveEntry)this.files.get(i)).getHasAccessDate());\n                 }\n-                this.writeBits(out, aTimes, this.files.size());\n+                this.writeBits(dataOutputStream, set, this.files.size());\n             }\n             else {\n-                out.write(1);\n+                dataOutputStream.write(1);\n             }\n-            out.write(0);\n-            for (final SevenZArchiveEntry entry2 : this.files) {\n-                if (entry2.getHasAccessDate()) {\n-                    out.writeLong(Long.reverseBytes(SevenZArchiveEntry.javaTimeToNtfsTime(entry2.getAccessDate())));\n+            dataOutputStream.write(0);\n+            for (final SevenZArchiveEntry sevenZArchiveEntry : this.files) {\n+                if (sevenZArchiveEntry.getHasAccessDate()) {\n+                    dataOutputStream.writeLong(Long.reverseBytes(SevenZArchiveEntry.javaTimeToNtfsTime(sevenZArchiveEntry.getAccessDate())));\n                 }\n             }\n-            out.flush();\n-            final byte[] contents = baos.toByteArray();\n-            this.writeUint64(header, contents.length);\n-            header.write(contents);\n+            dataOutputStream.flush();\n+            final byte[] byteArray = out.toByteArray();\n+            this.writeUint64(dataOutput, byteArray.length);\n+            dataOutput.write(byteArray);\n         }\n     }\n     \n-    private void writeFileMTimes(final DataOutput header) throws IOException {\n-        int numLastModifiedDates = 0;\n-        for (final SevenZArchiveEntry entry : this.files) {\n-            if (entry.getHasLastModifiedDate()) {\n-                ++numLastModifiedDates;\n-            }\n-        }\n-        if (numLastModifiedDates > 0) {\n-            header.write(20);\n-            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-            final DataOutputStream out = new DataOutputStream(baos);\n-            if (numLastModifiedDates != this.files.size()) {\n-                out.write(0);\n-                final BitSet mTimes = new BitSet(this.files.size());\n+    private void writeFileMTimes(final DataOutput dataOutput) throws IOException {\n+        int n = 0;\n+        final Iterator<SevenZArchiveEntry> iterator = this.files.iterator();\n+        while (iterator.hasNext()) {\n+            if (((SevenZArchiveEntry)iterator.next()).getHasLastModifiedDate()) {\n+                ++n;\n+            }\n+        }\n+        if (n > 0) {\n+            dataOutput.write(20);\n+            final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+            final DataOutputStream dataOutputStream = new DataOutputStream(out);\n+            if (n != this.files.size()) {\n+                dataOutputStream.write(0);\n+                final BitSet set = new BitSet(this.files.size());\n                 for (int i = 0; i < this.files.size(); ++i) {\n-                    mTimes.set(i, ((SevenZArchiveEntry)this.files.get(i)).getHasLastModifiedDate());\n+                    set.set(i, ((SevenZArchiveEntry)this.files.get(i)).getHasLastModifiedDate());\n                 }\n-                this.writeBits(out, mTimes, this.files.size());\n+                this.writeBits(dataOutputStream, set, this.files.size());\n             }\n             else {\n-                out.write(1);\n+                dataOutputStream.write(1);\n             }\n-            out.write(0);\n-            for (final SevenZArchiveEntry entry2 : this.files) {\n-                if (entry2.getHasLastModifiedDate()) {\n-                    out.writeLong(Long.reverseBytes(SevenZArchiveEntry.javaTimeToNtfsTime(entry2.getLastModifiedDate())));\n+            dataOutputStream.write(0);\n+            for (final SevenZArchiveEntry sevenZArchiveEntry : this.files) {\n+                if (sevenZArchiveEntry.getHasLastModifiedDate()) {\n+                    dataOutputStream.writeLong(Long.reverseBytes(SevenZArchiveEntry.javaTimeToNtfsTime(sevenZArchiveEntry.getLastModifiedDate())));\n                 }\n             }\n-            out.flush();\n-            final byte[] contents = baos.toByteArray();\n-            this.writeUint64(header, contents.length);\n-            header.write(contents);\n+            dataOutputStream.flush();\n+            final byte[] byteArray = out.toByteArray();\n+            this.writeUint64(dataOutput, byteArray.length);\n+            dataOutput.write(byteArray);\n         }\n     }\n     \n-    private void writeFileWindowsAttributes(final DataOutput header) throws IOException {\n-        int numWindowsAttributes = 0;\n-        for (final SevenZArchiveEntry entry : this.files) {\n-            if (entry.getHasWindowsAttributes()) {\n-                ++numWindowsAttributes;\n-            }\n-        }\n-        if (numWindowsAttributes > 0) {\n-            header.write(21);\n-            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-            final DataOutputStream out = new DataOutputStream(baos);\n-            if (numWindowsAttributes != this.files.size()) {\n-                out.write(0);\n-                final BitSet attributes = new BitSet(this.files.size());\n+    private void writeFileWindowsAttributes(final DataOutput dataOutput) throws IOException {\n+        int n = 0;\n+        final Iterator<SevenZArchiveEntry> iterator = this.files.iterator();\n+        while (iterator.hasNext()) {\n+            if (((SevenZArchiveEntry)iterator.next()).getHasWindowsAttributes()) {\n+                ++n;\n+            }\n+        }\n+        if (n > 0) {\n+            dataOutput.write(21);\n+            final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+            final DataOutputStream dataOutputStream = new DataOutputStream(out);\n+            if (n != this.files.size()) {\n+                dataOutputStream.write(0);\n+                final BitSet set = new BitSet(this.files.size());\n                 for (int i = 0; i < this.files.size(); ++i) {\n-                    attributes.set(i, ((SevenZArchiveEntry)this.files.get(i)).getHasWindowsAttributes());\n+                    set.set(i, ((SevenZArchiveEntry)this.files.get(i)).getHasWindowsAttributes());\n                 }\n-                this.writeBits(out, attributes, this.files.size());\n+                this.writeBits(dataOutputStream, set, this.files.size());\n             }\n             else {\n-                out.write(1);\n+                dataOutputStream.write(1);\n             }\n-            out.write(0);\n-            for (final SevenZArchiveEntry entry2 : this.files) {\n-                if (entry2.getHasWindowsAttributes()) {\n-                    out.writeInt(Integer.reverseBytes(entry2.getWindowsAttributes()));\n+            dataOutputStream.write(0);\n+            for (final SevenZArchiveEntry sevenZArchiveEntry : this.files) {\n+                if (sevenZArchiveEntry.getHasWindowsAttributes()) {\n+                    dataOutputStream.writeInt(Integer.reverseBytes(sevenZArchiveEntry.getWindowsAttributes()));\n                 }\n             }\n-            out.flush();\n-            final byte[] contents = baos.toByteArray();\n-            this.writeUint64(header, contents.length);\n-            header.write(contents);\n+            dataOutputStream.flush();\n+            final byte[] byteArray = out.toByteArray();\n+            this.writeUint64(dataOutput, byteArray.length);\n+            dataOutput.write(byteArray);\n         }\n     }\n     \n-    private void writeUint64(final DataOutput header, long value) throws IOException {\n-        int firstByte = 0;\n-        int mask = 128;\n+    private void writeUint64(final DataOutput dataOutput, long n) throws IOException {\n+        int n2 = 0;\n+        int n3 = 128;\n         int i;\n         for (i = 0; i < 8; ++i) {\n-            if (value < 1L << 7 * (i + 1)) {\n-                firstByte = (int)((long)firstByte | value >>> 8 * i);\n+            if (n < 1L << 7 * (i + 1)) {\n+                n2 = (int)((long)n2 | n >>> 8 * i);\n                 break;\n             }\n-            firstByte |= mask;\n-            mask >>>= 1;\n+            n2 |= n3;\n+            n3 >>>= 1;\n         }\n-        header.write(firstByte);\n+        dataOutput.write(n2);\n         while (i > 0) {\n-            header.write((int)(0xFFL & value));\n-            value >>>= 8;\n+            dataOutput.write((int)(0xFFL & n));\n+            n >>>= 8;\n             --i;\n         }\n     }\n     \n-    private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\n-        int cache = 0;\n-        int shift = 7;\n-        for (int i = 0; i < length; ++i) {\n-            cache |= (bits.get(i) ? 1 : 0) << shift;\n-            if (--shift < 0) {\n-                header.write(cache);\n-                shift = 7;\n-                cache = 0;\n+    private void writeBits(final DataOutput dataOutput, final BitSet set, final int n) throws IOException {\n+        int n2 = 0;\n+        int n3 = 7;\n+        for (int i = 0; i < n; ++i) {\n+            n2 |= (set.get(i) ? 1 : 0) << n3;\n+            if (--n3 < 0) {\n+                dataOutput.write(n2);\n+                n3 = 7;\n+                n2 = 0;\n             }\n         }\n-        if (shift != 7) {\n-            header.write(cache);\n+        if (n3 != 7) {\n+            dataOutput.write(n2);\n         }\n     }\n     \n-    private static <T> Iterable<T> reverse(final Iterable<T> i) {\n-        final LinkedList<T> l = new LinkedList<T>();\n-        for (final T t : i) {\n-            l.addFirst(t);\n+    private static <T> Iterable<T> reverse(final Iterable<T> iterable) {\n+        final LinkedList list = new LinkedList();\n+        final Iterator<T> iterator = iterable.iterator();\n+        while (iterator.hasNext()) {\n+            list.addFirst(iterator.next());\n         }\n-        return l;\n+        return list;\n     }\n }\n"}]}
