{"diffoscope-json-version": 1, "source1": "first/ReadAheadInputStream.class", "source2": "second/ReadAheadInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -191,15 +191,15 @@\n         this.stateChangeLock.lock();\n         try {\n             this.readAheadBuffer.array();\n             if (this.endOfStream || this.readInProgress) {\n                 return;\n             }\n             this.checkReadException();\n-            this.readAheadBuffer.position();\n+            this.readAheadBuffer.position(0);\n             this.readAheadBuffer.flip();\n             this.readInProgress = true;\n         }\n         finally {\n             this.stateChangeLock.unlock();\n         }\n         this.executorService.execute(() -> {\n@@ -215,37 +215,38 @@\n             }\n             finally {\n                 this.stateChangeLock.unlock();\n             }\n             int length = b.length;\n             try {\n                 do {\n-                    final int off;\n-                    this.underlyingInputStream.read(b, off, length);\n                     final int n;\n-                    if (n <= 0) {\n+                    this.underlyingInputStream.read(b, n, length);\n+                    final int n2;\n+                    if (n2 <= 0) {\n                         break;\n                     }\n                     else {\n-                        length -= n;\n+                        length -= n2;\n                     }\n                 } while (length > 0 && !this.isWaiting.get());\n             }\n             catch (final Throwable t) {\n                 if (t instanceof Error) {\n                     throw (Error)t;\n                 }\n             }\n             finally {\n                 this.stateChangeLock.lock();\n                 try {\n-                    this.readAheadBuffer.limit();\n                     final int n;\n+                    this.readAheadBuffer.limit(n);\n+                    final int n2;\n                     final Throwable readException;\n-                    if (n < 0 || readException instanceof EOFException) {\n+                    if (n2 < 0 || readException instanceof EOFException) {\n                         this.endOfStream = true;\n                     }\n                     else if (readException != null) {\n                         this.readAborted = true;\n                         this.readException = readException;\n                     }\n                     this.readInProgress = false;\n@@ -271,15 +272,15 @@\n     \n     @Override\n     public long skip(final long n) throws IOException {\n         if (n <= 0L) {\n             return 0L;\n         }\n         if (n <= this.activeBuffer.remaining()) {\n-            this.activeBuffer.position();\n+            this.activeBuffer.position((int)n + this.activeBuffer.position());\n             return n;\n         }\n         this.stateChangeLock.lock();\n         long skipInternal;\n         try {\n             skipInternal = this.skipInternal(n);\n         }\n@@ -294,27 +295,27 @@\n         this.waitForAsyncReadComplete();\n         if (this.isEndOfStream()) {\n             return 0L;\n         }\n         if (this.available() < n) {\n             final int available = this.available();\n             final long n2 = n - available;\n-            this.activeBuffer.position();\n+            this.activeBuffer.position(0);\n             this.activeBuffer.flip();\n-            this.readAheadBuffer.position();\n+            this.readAheadBuffer.position(0);\n             this.readAheadBuffer.flip();\n             final long skip = this.underlyingInputStream.skip(n2);\n             this.readAsync();\n             return available + skip;\n         }\n         final int n3 = (int)n - this.activeBuffer.remaining();\n         assert n3 > 0;\n-        this.activeBuffer.position();\n+        this.activeBuffer.position(0);\n         this.activeBuffer.flip();\n-        this.readAheadBuffer.position();\n+        this.readAheadBuffer.position(n3 + this.readAheadBuffer.position());\n         this.swapBuffers();\n         this.readAsync();\n         return n;\n     }\n     \n     private void swapBuffers() {\n         final ByteBuffer activeBuffer = this.activeBuffer;\n"}]}
