{"diffoscope-json-version": 1, "source1": "first/PhoneticEngine$PhonemeBuilder.class", "source2": "second/PhoneticEngine$PhonemeBuilder.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -6,63 +6,64 @@\n import java.util.LinkedHashSet;\n import java.util.Set;\n \n static final class PhonemeBuilder\n {\n     private final Set<Rule.Phoneme> phonemes;\n     \n-    public static PhonemeBuilder empty(final Languages.LanguageSet languages) {\n-        return new PhonemeBuilder(new Rule.Phoneme((CharSequence)\"\", languages));\n+    public static PhonemeBuilder empty(final Languages.LanguageSet set) {\n+        return new PhonemeBuilder(new Rule.Phoneme((CharSequence)\"\", set));\n     }\n     \n     private PhonemeBuilder(final Rule.Phoneme phoneme) {\n         (this.phonemes = new LinkedHashSet()).add(phoneme);\n     }\n     \n     private PhonemeBuilder(final Set<Rule.Phoneme> phonemes) {\n         this.phonemes = phonemes;\n     }\n     \n-    public void append(final CharSequence str) {\n-        for (final Rule.Phoneme ph : this.phonemes) {\n-            ph.append(str);\n+    public void append(final CharSequence charSequence) {\n+        final Iterator iterator = this.phonemes.iterator();\n+        while (iterator.hasNext()) {\n+            ((Rule.Phoneme)iterator.next()).append(charSequence);\n         }\n     }\n     \n-    public void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {\n-        final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);\n+    public void apply(final Rule.PhonemeExpr phonemeExpr, final int initialCapacity) {\n+        final LinkedHashSet set = new LinkedHashSet(initialCapacity);\n     Label_0153:\n-        for (final Rule.Phoneme left : this.phonemes) {\n-            for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {\n-                final Languages.LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());\n-                if (!languages.isEmpty()) {\n-                    final Rule.Phoneme join = new Rule.Phoneme(left, right, languages);\n-                    if (newPhonemes.size() >= maxPhonemes) {\n+        for (final Rule.Phoneme phoneme : this.phonemes) {\n+            for (final Rule.Phoneme phoneme2 : phonemeExpr.getPhonemes()) {\n+                final Languages.LanguageSet restrictTo = phoneme.getLanguages().restrictTo(phoneme2.getLanguages());\n+                if (!restrictTo.isEmpty()) {\n+                    final Rule.Phoneme phoneme3 = new Rule.Phoneme(phoneme, phoneme2, restrictTo);\n+                    if (set.size() >= initialCapacity) {\n                         continue;\n                     }\n-                    newPhonemes.add(join);\n-                    if (newPhonemes.size() >= maxPhonemes) {\n+                    set.add(phoneme3);\n+                    if (set.size() >= initialCapacity) {\n                         break Label_0153;\n                     }\n                     continue;\n                 }\n             }\n         }\n         this.phonemes.clear();\n-        this.phonemes.addAll(newPhonemes);\n+        this.phonemes.addAll(set);\n     }\n     \n     public Set<Rule.Phoneme> getPhonemes() {\n         return this.phonemes;\n     }\n     \n     public String makeString() {\n         final StringBuilder sb = new StringBuilder();\n-        for (final Rule.Phoneme ph : this.phonemes) {\n+        for (final Rule.Phoneme phoneme : this.phonemes) {\n             if (sb.length() > 0) {\n                 sb.append(\"|\");\n             }\n-            sb.append(ph.getPhonemeText());\n+            sb.append(phoneme.getPhonemeText());\n         }\n         return sb.toString();\n     }\n }\n"}]}
