{"diffoscope-json-version": 1, "source1": "first/EqualsBuilder.class", "source2": "second/EqualsBuilder.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -20,14 +20,18 @@\n     private boolean isEquals;\n     private boolean testTransients;\n     private boolean testRecursive;\n     private List<Class<?>> bypassReflectionClasses;\n     private Class<?> reflectUpToClass;\n     private String[] excludeFields;\n     \n+    static {\n+        REGISTRY = new ThreadLocal<Set<Pair<IDKey, IDKey>>>();\n+    }\n+    \n     static Set<Pair<IDKey, IDKey>> getRegistry() {\n         return EqualsBuilder.REGISTRY.get();\n     }\n     \n     static Pair<IDKey, IDKey> getRegisterPair(final Object lhs, final Object rhs) {\n         final IDKey left = new IDKey(lhs);\n         final IDKey right = new IDKey(rhs);\n@@ -147,15 +151,18 @@\n                 this.append(lhs, rhs);\n             }\n             else if (this.bypassReflectionClasses != null && (this.bypassReflectionClasses.contains(lhsClass) || this.bypassReflectionClasses.contains(rhsClass))) {\n                 this.isEquals = lhs.equals(rhs);\n             }\n             else {\n                 this.reflectionAppend(lhs, rhs, testClass);\n-                while (testClass.getSuperclass() != null && testClass != this.reflectUpToClass) {\n+                while (testClass.getSuperclass() != null) {\n+                    if (testClass == this.reflectUpToClass) {\n+                        break;\n+                    }\n                     testClass = testClass.getSuperclass();\n                     this.reflectionAppend(lhs, rhs, testClass);\n                 }\n             }\n         }\n         catch (final IllegalArgumentException e) {\n             this.isEquals = false;\n@@ -167,29 +174,33 @@\n         if (isRegistered(lhs, rhs)) {\n             return;\n         }\n         try {\n             register(lhs, rhs);\n             final Field[] fields = clazz.getDeclaredFields();\n             AccessibleObject.setAccessible(fields, true);\n-            for (int i = 0; i < fields.length && this.isEquals; ++i) {\n+            for (int i = 0; i < fields.length; ++i) {\n+                if (!this.isEquals) {\n+                    break;\n+                }\n                 final Field f = fields[i];\n                 if (!ArrayUtils.contains((Object[])this.excludeFields, (Object)f.getName()) && !f.getName().contains(\"$\") && (this.testTransients || !Modifier.isTransient(f.getModifiers())) && !Modifier.isStatic(f.getModifiers()) && !f.isAnnotationPresent((Class<? extends Annotation>)EqualsExclude.class)) {\n                     try {\n                         this.append(f.get(lhs), f.get(rhs));\n                     }\n                     catch (final IllegalAccessException e) {\n                         throw new InternalError(\"Unexpected IllegalAccessException\");\n                     }\n                 }\n             }\n         }\n         finally {\n             unregister(lhs, rhs);\n         }\n+        unregister(lhs, rhs);\n     }\n     \n     public EqualsBuilder appendSuper(final boolean superEquals) {\n         if (!this.isEquals) {\n             return this;\n         }\n         this.isEquals = superEquals;\n@@ -515,12 +526,8 @@\n     protected void setEquals(final boolean isEquals) {\n         this.isEquals = isEquals;\n     }\n     \n     public void reset() {\n         this.isEquals = true;\n     }\n-    \n-    static {\n-        REGISTRY = new ThreadLocal<Set<Pair<IDKey, IDKey>>>();\n-    }\n }\n"}]}
