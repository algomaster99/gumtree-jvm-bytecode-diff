{"diffoscope-json-version": 1, "source1": "first/EnumUtils.class", "source2": "second/EnumUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -21,15 +21,15 @@\n     private static <E extends Enum<E>> Class<E> asEnum(final Class<E> enumClass) {\n         Validate.notNull((Object)enumClass, \"EnumClass must be defined.\", new Object[0]);\n         Validate.isTrue(enumClass.isEnum(), \"%s does not seem to be an Enum type\", new Object[] { enumClass });\n         return enumClass;\n     }\n     \n     private static <E extends Enum<E>> Class<E> checkBitVectorable(final Class<E> enumClass) {\n-        final E[] constants = (E[])asEnum((Class<Enum>)enumClass).getEnumConstants();\n+        final Enum[] constants = (Enum[])asEnum((Class<Enum>)enumClass).getEnumConstants();\n         Validate.isTrue(constants.length <= 64, \"Cannot store %s %s values in %s bits\", new Object[] { Integer.valueOf(constants.length), enumClass.getSimpleName(), Integer.valueOf(64) });\n         return enumClass;\n     }\n     \n     @SafeVarargs\n     public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final E... values) {\n         Validate.noNullElements((Object[])values);\n@@ -101,29 +101,33 @@\n         return getEnumIgnoreCase(enumClass, enumName, (E)null);\n     }\n     \n     public static <E extends Enum<E>> E getEnumIgnoreCase(final Class<E> enumClass, final String enumName, final E defaultEnum) {\n         if (enumName == null || !enumClass.isEnum()) {\n             return defaultEnum;\n         }\n-        for (final E each : (E[])enumClass.getEnumConstants()) {\n+        E[] array;\n+        for (int length = (array = enumClass.getEnumConstants()).length, i = 0; i < length; ++i) {\n+            final E each = array[i];\n             if (each.name().equalsIgnoreCase(enumName)) {\n                 return each;\n             }\n         }\n         return defaultEnum;\n     }\n     \n     public static <E extends Enum<E>> List<E> getEnumList(final Class<E> enumClass) {\n         return new ArrayList<E>((Collection<? extends E>)Arrays.asList((E[])enumClass.getEnumConstants()));\n     }\n     \n     public static <E extends Enum<E>> Map<String, E> getEnumMap(final Class<E> enumClass) {\n         final Map<String, E> map = new LinkedHashMap<String, E>();\n-        for (final E e : (E[])enumClass.getEnumConstants()) {\n+        E[] array;\n+        for (int length = (array = enumClass.getEnumConstants()).length, i = 0; i < length; ++i) {\n+            final E e = array[i];\n             map.put(e.name(), e);\n         }\n         return map;\n     }\n     \n     public static <E extends Enum<E>> boolean isValidEnum(final Class<E> enumClass, final String enumName) {\n         return getEnum(enumClass, enumName) != null;\n@@ -138,15 +142,17 @@\n         return processBitVectors(enumClass, value);\n     }\n     \n     public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, final long... values) {\n         final EnumSet<E> results = EnumSet.noneOf((Class<E>)asEnum((Class<E>)enumClass));\n         final long[] lvalues = ArrayUtils.clone((long[])Validate.notNull((Object)values));\n         ArrayUtils.reverse(lvalues);\n-        for (final E constant : (E[])enumClass.getEnumConstants()) {\n+        E[] array;\n+        for (int length = (array = enumClass.getEnumConstants()).length, i = 0; i < length; ++i) {\n+            final E constant = array[i];\n             final int block = constant.ordinal() / 64;\n             if (block < lvalues.length && (lvalues[block] & 1L << constant.ordinal() % 64) != 0x0L) {\n                 results.add(constant);\n             }\n         }\n         return results;\n     }\n"}]}
