{"diffoscope-json-version": 1, "source1": "first/BHSDCodec.class", "source2": "second/BHSDCodec.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,11 +1,10 @@\n \n package org.apache.commons.compress.harmony.pack200;\n \n-import java.util.List;\n import java.util.ArrayList;\n import java.io.EOFException;\n import java.io.IOException;\n import java.io.InputStream;\n \n public final class BHSDCodec extends Codec\n {\n@@ -15,20 +14,20 @@\n     private final int l;\n     private final int s;\n     private long cardinality;\n     private final long smallest;\n     private final long largest;\n     private final long[] powers;\n     \n-    public BHSDCodec(final int b, final int h) {\n-        this(b, h, 0, 0);\n+    public BHSDCodec(final int n, final int n2) {\n+        this(n, n2, 0, 0);\n     }\n     \n-    public BHSDCodec(final int b, final int h, final int s) {\n-        this(b, h, s, 0);\n+    public BHSDCodec(final int n, final int n2, final int n3) {\n+        this(n, n2, n3, 0);\n     }\n     \n     public BHSDCodec(final int b, final int h, final int s, final int d) {\n         if (b < 1 || b > 5) {\n             throw new IllegalArgumentException(\"1<=b<=5\");\n         }\n         if (h < 1 || h > 256) {\n@@ -56,161 +55,160 @@\n         }\n         else {\n             this.cardinality = (long)((long)(this.l * (1.0 - Math.pow(h, b)) / (1 - h)) + Math.pow(h, b));\n         }\n         this.smallest = this.calculateSmallest();\n         this.largest = this.calculateLargest();\n         this.powers = new long[b];\n-        for (int c = 0; c < b; ++c) {\n-            this.powers[c] = (long)Math.pow(h, c);\n+        for (int i = 0; i < b; ++i) {\n+            this.powers[i] = (long)Math.pow(h, i);\n         }\n     }\n     \n     public long cardinality() {\n         return this.cardinality;\n     }\n     \n-    public int decode(final InputStream in) throws IOException, Pack200Exception {\n+    public int decode(final InputStream inputStream) throws IOException, Pack200Exception {\n         if (this.d != 0) {\n             throw new Pack200Exception(\"Delta encoding used without passing in last value; this is a coding error\");\n         }\n-        return this.decode(in, 0L);\n+        return this.decode(inputStream, 0L);\n     }\n     \n-    public int decode(final InputStream in, final long last) throws IOException, Pack200Exception {\n-        int n = 0;\n-        long z = 0L;\n-        long x = 0L;\n+    public int decode(final InputStream inputStream, final long n) throws IOException, Pack200Exception {\n+        int n2 = 0;\n+        long n3 = 0L;\n+        long n4;\n         do {\n-            x = in.read();\n+            n4 = inputStream.read();\n             ++this.lastBandLength;\n-            z += x * this.powers[n];\n-            ++n;\n-        } while (x >= this.l && n < this.b);\n-        if (x == -1L) {\n+            n3 += n4 * this.powers[n2];\n+            ++n2;\n+        } while (n4 >= this.l && n2 < this.b);\n+        if (n4 == -1L) {\n             throw new EOFException(\"End of stream reached whilst decoding\");\n         }\n         if (this.isSigned()) {\n-            final int u = (1 << this.s) - 1;\n-            if ((z & (long)u) == u) {\n-                z = ~(z >>> this.s);\n+            final int n5 = (1 << this.s) - 1;\n+            if ((n3 & (long)n5) == n5) {\n+                n3 = ~(n3 >>> this.s);\n             }\n             else {\n-                z -= z >>> this.s;\n+                n3 -= n3 >>> this.s;\n             }\n         }\n         if (this.isDelta()) {\n-            z += last;\n+            n3 += n;\n         }\n-        return (int)z;\n+        return (int)n3;\n     }\n     \n-    public int[] decodeInts(final int n, final InputStream in) throws IOException, Pack200Exception {\n-        final int[] band = super.decodeInts(n, in);\n+    public int[] decodeInts(final int n, final InputStream inputStream) throws IOException, Pack200Exception {\n+        final int[] decodeInts = super.decodeInts(n, inputStream);\n         if (this.isDelta()) {\n-            for (int i = 0; i < band.length; ++i) {\n-                while (band[i] > this.largest) {\n-                    final int[] array = band;\n+            for (int i = 0; i < decodeInts.length; ++i) {\n+                while (decodeInts[i] > this.largest) {\n+                    final int[] array = decodeInts;\n                     final int n2 = i;\n                     array[n2] -= this.cardinality;\n                 }\n-                while (band[i] < this.smallest) {\n-                    final int[] array2 = band;\n+                while (decodeInts[i] < this.smallest) {\n+                    final int[] array2 = decodeInts;\n                     final int n3 = i;\n                     array2[n3] += this.cardinality;\n                 }\n             }\n         }\n-        return band;\n+        return decodeInts;\n     }\n     \n-    public int[] decodeInts(final int n, final InputStream in, final int firstValue) throws IOException, Pack200Exception {\n-        final int[] band = super.decodeInts(n, in, firstValue);\n+    public int[] decodeInts(final int n, final InputStream inputStream, final int n2) throws IOException, Pack200Exception {\n+        final int[] decodeInts = super.decodeInts(n, inputStream, n2);\n         if (this.isDelta()) {\n-            for (int i = 0; i < band.length; ++i) {\n-                while (band[i] > this.largest) {\n-                    final int[] array = band;\n-                    final int n2 = i;\n-                    array[n2] -= this.cardinality;\n-                }\n-                while (band[i] < this.smallest) {\n-                    final int[] array2 = band;\n+            for (int i = 0; i < decodeInts.length; ++i) {\n+                while (decodeInts[i] > this.largest) {\n+                    final int[] array = decodeInts;\n                     final int n3 = i;\n-                    array2[n3] += this.cardinality;\n+                    array[n3] -= this.cardinality;\n+                }\n+                while (decodeInts[i] < this.smallest) {\n+                    final int[] array2 = decodeInts;\n+                    final int n4 = i;\n+                    array2[n4] += this.cardinality;\n                 }\n             }\n         }\n-        return band;\n+        return decodeInts;\n     }\n     \n-    public boolean encodes(final long value) {\n-        return value >= this.smallest && value <= this.largest;\n+    public boolean encodes(final long n) {\n+        return n >= this.smallest && n <= this.largest;\n     }\n     \n-    public byte[] encode(final int value, final int last) throws Pack200Exception {\n-        if (!this.encodes(value)) {\n-            throw new Pack200Exception(\"The codec \" + this.toString() + \" does not encode the value \" + value);\n+    public byte[] encode(final int n, final int n2) throws Pack200Exception {\n+        if (!this.encodes(n)) {\n+            throw new Pack200Exception(\"The codec \" + this.toString() + \" does not encode the value \" + n);\n         }\n-        long z = (long)value;\n+        long n3 = (long)n;\n         if (this.isDelta()) {\n-            z -= last;\n+            n3 -= n2;\n         }\n         if (this.isSigned()) {\n-            if (z < -2147483648L) {\n-                z += 4294967296L;\n+            if (n3 < -2147483648L) {\n+                n3 += 4294967296L;\n             }\n-            else if (z > 2147483647L) {\n-                z -= 4294967296L;\n+            else if (n3 > 2147483647L) {\n+                n3 -= 4294967296L;\n             }\n-            if (z < 0L) {\n-                z = (-z << this.s) - 1L;\n+            if (n3 < 0L) {\n+                n3 = (-n3 << this.s) - 1L;\n             }\n             else if (this.s == 1) {\n-                z <<= this.s;\n+                n3 <<= this.s;\n             }\n             else {\n-                z += (z - z % 3L) / 3L;\n+                n3 += (n3 - n3 % 3L) / 3L;\n             }\n         }\n-        else if (z < 0L) {\n+        else if (n3 < 0L) {\n             if (this.cardinality < 4294967296L) {\n-                z += this.cardinality;\n+                n3 += this.cardinality;\n             }\n             else {\n-                z += 4294967296L;\n+                n3 += 4294967296L;\n             }\n         }\n-        if (z < 0L) {\n+        if (n3 < 0L) {\n             throw new Pack200Exception(\"unable to encode\");\n         }\n-        final List byteList = new ArrayList();\n-        for (int n = 0; n < this.b; ++n) {\n-            long byteN;\n-            if (z < this.l) {\n-                byteN = z;\n+        final ArrayList list = new ArrayList();\n+        for (int i = 0; i < this.b; ++i) {\n+            long n4;\n+            if (n3 < this.l) {\n+                n4 = n3;\n             }\n             else {\n-                for (byteN = z % this.h; byteN < this.l; byteN += this.h) {}\n+                for (n4 = n3 % this.h; n4 < this.l; n4 += this.h) {}\n             }\n-            byteList.add(Byte.valueOf((byte)(int)byteN));\n-            if (byteN < this.l) {\n+            list.add(Byte.valueOf((byte)(int)n4));\n+            if (n4 < this.l) {\n                 break;\n             }\n-            z -= byteN;\n-            z /= this.h;\n+            n3 = (n3 - n4) / this.h;\n         }\n-        final byte[] bytes = new byte[byteList.size()];\n-        for (int i = 0; i < bytes.length; ++i) {\n-            bytes[i] = Byte.valueOf(byteList.get(i));\n+        final byte[] array = new byte[list.size()];\n+        for (int j = 0; j < array.length; ++j) {\n+            array[j] = (byte)list.get(j);\n         }\n-        return bytes;\n+        return array;\n     }\n     \n-    public byte[] encode(final int value) throws Pack200Exception {\n-        return this.encode(value, 0);\n+    public byte[] encode(final int n) throws Pack200Exception {\n+        return this.encode(n, 0);\n     }\n     \n     public boolean isDelta() {\n         return this.d != 0;\n     }\n     \n     public boolean isSigned() {\n@@ -219,69 +217,68 @@\n     \n     public long largest() {\n         return this.largest;\n     }\n     \n     private long calculateLargest() {\n         if (this.d == 1) {\n-            final BHSDCodec bh0 = new BHSDCodec(this.b, this.h);\n-            return bh0.largest();\n+            return new BHSDCodec(this.b, this.h).largest();\n         }\n-        long result;\n+        long b;\n         if (this.s == 0) {\n-            result = this.cardinality() - 1L;\n+            b = this.cardinality() - 1L;\n         }\n         else if (this.s == 1) {\n-            result = this.cardinality() / 2L - 1L;\n+            b = this.cardinality() / 2L - 1L;\n         }\n         else {\n             if (this.s != 2) {\n                 throw new Error(\"Unknown s value\");\n             }\n-            result = 3L * this.cardinality() / 4L - 1L;\n+            b = 3L * this.cardinality() / 4L - 1L;\n         }\n-        return Math.min(((this.s == 0) ? 4294967294L : 2147483647L) - 1L, result);\n+        return Math.min(((this.s == 0) ? 4294967294L : 2147483647L) - 1L, b);\n     }\n     \n     public long smallest() {\n         return this.smallest;\n     }\n     \n     private long calculateSmallest() {\n-        long result;\n+        long max;\n         if (this.d == 1 || !this.isSigned()) {\n             if (this.cardinality >= 4294967296L) {\n-                result = -2147483648L;\n+                max = -2147483648L;\n             }\n             else {\n-                result = 0L;\n+                max = 0L;\n             }\n         }\n         else {\n-            result = Math.max(-2147483648L, -this.cardinality() / (long)(1 << this.s));\n+            max = Math.max(-2147483648L, -this.cardinality() / (long)(1 << this.s));\n         }\n-        return result;\n+        return max;\n     }\n     \n     public String toString() {\n-        final StringBuffer buffer = new StringBuffer(11);\n-        buffer.append('(');\n-        buffer.append(this.b);\n-        buffer.append(',');\n-        buffer.append(this.h);\n+        final StringBuffer sb = new StringBuffer(11);\n+        sb.append('(');\n+        sb.append(this.b);\n+        sb.append(',');\n+        sb.append(this.h);\n         if (this.s != 0 || this.d != 0) {\n-            buffer.append(',');\n-            buffer.append(this.s);\n+            sb.append(',');\n+            sb.append(this.s);\n         }\n         if (this.d != 0) {\n-            buffer.append(',');\n-            buffer.append(this.d);\n+            sb.append(',');\n+            sb.append(this.d);\n         }\n-        buffer.append(')');\n-        return buffer.toString();\n+        sb.append(')');\n+        return sb.toString();\n     }\n     \n     public int getB() {\n         return this.b;\n     }\n     \n     public int getH() {\n@@ -294,16 +291,16 @@\n     \n     public int getL() {\n         return this.l;\n     }\n     \n     public boolean equals(final Object o) {\n         if (o instanceof BHSDCodec) {\n-            final BHSDCodec codec = (BHSDCodec)o;\n-            return codec.b == this.b && codec.h == this.h && codec.s == this.s && codec.d == this.d;\n+            final BHSDCodec bhsdCodec = (BHSDCodec)o;\n+            return bhsdCodec.b == this.b && bhsdCodec.h == this.h && bhsdCodec.s == this.s && bhsdCodec.d == this.d;\n         }\n         return false;\n     }\n     \n     public int hashCode() {\n         return ((this.b * 37 + this.h) * 37 + this.s) * 37 + this.d;\n     }\n"}]}
