{"diffoscope-json-version": 1, "source1": "first/ClassPath.class", "source2": "second/ClassPath.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -26,252 +26,254 @@\n     private static final FilenameFilter ARCHIVE_FILTER;\n     private static final FilenameFilter MODULES_FILTER;\n     public static final ClassPath SYSTEM_CLASS_PATH;\n     private final String classPath;\n     private ClassPath parent;\n     private final ClassPath.AbstractPathEntry[] paths;\n     \n-    private static void addJdkModules(final String javaHome, final List<String> list) {\n-        String modulesPath = System.getProperty(\"java.modules.path\");\n-        if (modulesPath == null || modulesPath.trim().isEmpty()) {\n-            modulesPath = javaHome + File.separator + \"jmods\";\n-        }\n-        final File modulesDir = new File(modulesPath);\n-        if (modulesDir.exists()) {\n-            final String[] modules = modulesDir.list(ClassPath.MODULES_FILTER);\n-            for (int i = 0; i < modules.length; ++i) {\n-                list.add(modulesDir.getPath() + File.separatorChar + modules[i]);\n+    private static void addJdkModules(final String str, final List<String> list) {\n+        String pathname = System.getProperty(\"java.modules.path\");\n+        if (pathname == null || pathname.trim().isEmpty()) {\n+            pathname = str + File.separator + \"jmods\";\n+        }\n+        final File file = new File(pathname);\n+        if (file.exists()) {\n+            final String[] list2 = file.list(ClassPath.MODULES_FILTER);\n+            for (int i = 0; i < list2.length; ++i) {\n+                list.add(file.getPath() + File.separatorChar + list2[i]);\n             }\n         }\n     }\n     \n     public static String getClassPath() {\n-        final String classPathProp = System.getProperty(\"java.class.path\");\n-        final String bootClassPathProp = System.getProperty(\"sun.boot.class.path\");\n-        final String extDirs = System.getProperty(\"java.ext.dirs\");\n-        final String javaHome = System.getProperty(\"java.home\");\n-        final List<String> list = new ArrayList<String>();\n-        final Path modulesPath = Paths.get(javaHome, new String[0]).resolve(\"lib/modules\");\n-        if (Files.exists(modulesPath, new LinkOption[0]) && Files.isRegularFile(modulesPath, new LinkOption[0])) {\n-            list.add(modulesPath.toAbsolutePath().toString());\n-        }\n-        addJdkModules(javaHome, list);\n-        getPathComponents(classPathProp, list);\n-        getPathComponents(bootClassPathProp, list);\n-        final List<String> dirs = new ArrayList<String>();\n-        getPathComponents(extDirs, dirs);\n-        for (final String d : dirs) {\n-            final File ext_dir = new File(d);\n-            final String[] extensions = ext_dir.list(ClassPath.ARCHIVE_FILTER);\n-            if (extensions != null) {\n-                for (final String extension : extensions) {\n-                    list.add(ext_dir.getPath() + File.separatorChar + extension);\n+        final String property = System.getProperty(\"java.class.path\");\n+        final String property2 = System.getProperty(\"sun.boot.class.path\");\n+        final String property3 = System.getProperty(\"java.ext.dirs\");\n+        final String property4 = System.getProperty(\"java.home\");\n+        final ArrayList list = new ArrayList();\n+        final Path resolve = Paths.get(property4, new String[0]).resolve(\"lib/modules\");\n+        if (Files.exists(resolve, new LinkOption[0]) && Files.isRegularFile(resolve, new LinkOption[0])) {\n+            list.add(resolve.toAbsolutePath().toString());\n+        }\n+        addJdkModules(property4, list);\n+        getPathComponents(property, list);\n+        getPathComponents(property2, list);\n+        final ArrayList list2 = new ArrayList();\n+        getPathComponents(property3, list2);\n+        final Iterator iterator = list2.iterator();\n+        while (iterator.hasNext()) {\n+            final File file = new File((String)iterator.next());\n+            final String[] list3 = file.list(ClassPath.ARCHIVE_FILTER);\n+            if (list3 != null) {\n+                final String[] array = list3;\n+                for (int length = array.length, i = 0; i < length; ++i) {\n+                    list.add(file.getPath() + File.separatorChar + array[i]);\n                 }\n             }\n         }\n-        final StringBuilder buf = new StringBuilder();\n-        String separator = \"\";\n-        for (final String path : list) {\n-            buf.append(separator);\n-            separator = File.pathSeparator;\n-            buf.append(path);\n-        }\n-        return buf.toString().intern();\n-    }\n-    \n-    private static void getPathComponents(final String path, final List<String> list) {\n-        if (path != null) {\n-            final StringTokenizer tokenizer = new StringTokenizer(path, File.pathSeparator);\n-            while (tokenizer.hasMoreTokens()) {\n-                final String name = tokenizer.nextToken();\n-                final File file = new File(name);\n-                if (file.exists()) {\n-                    list.add(name);\n+        final StringBuilder sb = new StringBuilder();\n+        String pathSeparator = \"\";\n+        for (final String str : list) {\n+            sb.append(pathSeparator);\n+            pathSeparator = File.pathSeparator;\n+            sb.append(str);\n+        }\n+        return sb.toString().intern();\n+    }\n+    \n+    private static void getPathComponents(final String str, final List<String> list) {\n+        if (str != null) {\n+            final StringTokenizer stringTokenizer = new StringTokenizer(str, File.pathSeparator);\n+            while (stringTokenizer.hasMoreTokens()) {\n+                final String nextToken = stringTokenizer.nextToken();\n+                if (new File(nextToken).exists()) {\n+                    list.add(nextToken);\n                 }\n             }\n         }\n     }\n     \n-    static String packageToFolder(final String name) {\n-        return name.replace('.', '/');\n+    static String packageToFolder(final String s) {\n+        return s.replace('.', '/');\n     }\n     \n     @Deprecated\n     public ClassPath() {\n         this(getClassPath());\n     }\n     \n-    public ClassPath(final ClassPath parent, final String classPath) {\n-        this(classPath);\n+    public ClassPath(final ClassPath parent, final String s) {\n+        this(s);\n         this.parent = parent;\n     }\n     \n-    public ClassPath(final String classPath) {\n-        this.classPath = classPath;\n-        final List<ClassPath.AbstractPathEntry> list = new ArrayList<ClassPath.AbstractPathEntry>();\n-        final StringTokenizer tokenizer = new StringTokenizer(classPath, File.pathSeparator);\n-        while (tokenizer.hasMoreTokens()) {\n-            final String path = tokenizer.nextToken();\n-            if (!path.isEmpty()) {\n-                final File file = new File(path);\n+    public ClassPath(final String s) {\n+        this.classPath = s;\n+        final ArrayList list = new ArrayList();\n+        final StringTokenizer stringTokenizer = new StringTokenizer(s, File.pathSeparator);\n+        while (stringTokenizer.hasMoreTokens()) {\n+            final String nextToken = stringTokenizer.nextToken();\n+            if (!nextToken.isEmpty()) {\n+                final File obj = new File(nextToken);\n                 try {\n-                    if (!file.exists()) {\n+                    if (!obj.exists()) {\n                         continue;\n                     }\n-                    if (file.isDirectory()) {\n-                        list.add((ClassPath.AbstractPathEntry)new ClassPath.Dir(path));\n+                    if (obj.isDirectory()) {\n+                        list.add(new ClassPath.Dir(nextToken));\n                     }\n-                    else if (path.endsWith(\".jmod\")) {\n-                        list.add((ClassPath.AbstractPathEntry)new ClassPath.Module(new ZipFile(file)));\n+                    else if (nextToken.endsWith(\".jmod\")) {\n+                        list.add(new ClassPath.Module(new ZipFile(obj)));\n                     }\n-                    else if (path.endsWith(ModularRuntimeImage.MODULES_PATH)) {\n-                        list.add((ClassPath.AbstractPathEntry)new ClassPath.JrtModules(ModularRuntimeImage.MODULES_PATH));\n+                    else if (nextToken.endsWith(ModularRuntimeImage.MODULES_PATH)) {\n+                        list.add(new ClassPath.JrtModules(ModularRuntimeImage.MODULES_PATH));\n                     }\n                     else {\n-                        list.add((ClassPath.AbstractPathEntry)new ClassPath.Jar(new ZipFile(file)));\n+                        list.add(new ClassPath.Jar(new ZipFile(obj)));\n                     }\n                 }\n-                catch (final IOException e) {\n-                    if (!path.endsWith(\".zip\") && !path.endsWith(\".jar\")) {\n+                catch (final IOException obj2) {\n+                    if (!nextToken.endsWith(\".zip\") && !nextToken.endsWith(\".jar\")) {\n                         continue;\n                     }\n-                    System.err.println(\"CLASSPATH component \" + file + \": \" + e);\n+                    System.err.println(\"CLASSPATH component \" + obj + \": \" + obj2);\n                 }\n             }\n         }\n         list.toArray(this.paths = new ClassPath.AbstractPathEntry[list.size()]);\n     }\n     \n     @Override\n     public void close() throws IOException {\n         if (this.paths != null) {\n-            for (final ClassPath.AbstractPathEntry path : this.paths) {\n-                path.close();\n+            final ClassPath.AbstractPathEntry[] paths = this.paths;\n+            for (int length = paths.length, i = 0; i < length; ++i) {\n+                paths[i].close();\n             }\n         }\n     }\n     \n     @Override\n     public boolean equals(final Object o) {\n-        if (o instanceof ClassPath) {\n-            final ClassPath cp = (ClassPath)o;\n-            return this.classPath.equals(cp.toString());\n-        }\n-        return false;\n+        return o instanceof ClassPath && this.classPath.equals(((ClassPath)o).toString());\n     }\n     \n-    public byte[] getBytes(final String name) throws IOException {\n-        return this.getBytes(name, \".class\");\n+    public byte[] getBytes(final String s) throws IOException {\n+        return this.getBytes(s, \".class\");\n     }\n     \n-    public byte[] getBytes(final String name, final String suffix) throws IOException {\n-        DataInputStream dis = null;\n-        try (final InputStream inputStream = this.getInputStream(name, suffix)) {\n+    public byte[] getBytes(final String str, final String str2) throws IOException {\n+        DataInputStream dataInputStream = null;\n+        try (final InputStream inputStream = this.getInputStream(str, str2)) {\n             if (inputStream == null) {\n-                throw new IOException(\"Couldn't find: \" + name + suffix);\n+                throw new IOException(\"Couldn't find: \" + str + str2);\n             }\n-            dis = new DataInputStream(inputStream);\n-            final byte[] bytes = new byte[inputStream.available()];\n-            dis.readFully(bytes);\n-            return bytes;\n+            dataInputStream = new DataInputStream(inputStream);\n+            final byte[] b = new byte[inputStream.available()];\n+            dataInputStream.readFully(b);\n+            return b;\n         }\n         finally {\n-            if (dis != null) {\n-                dis.close();\n+            if (dataInputStream != null) {\n+                dataInputStream.close();\n             }\n         }\n     }\n     \n-    public ClassPath.ClassFile getClassFile(final String name) throws IOException {\n-        return this.getClassFile(name, \".class\");\n+    public ClassPath.ClassFile getClassFile(final String s) throws IOException {\n+        return this.getClassFile(s, \".class\");\n     }\n     \n-    public ClassPath.ClassFile getClassFile(final String name, final String suffix) throws IOException {\n-        ClassPath.ClassFile cf = null;\n+    public ClassPath.ClassFile getClassFile(final String str, final String str2) throws IOException {\n+        ClassPath.ClassFile classFile = null;\n         if (this.parent != null) {\n-            cf = this.parent.getClassFileInternal(name, suffix);\n+            classFile = this.parent.getClassFileInternal(str, str2);\n         }\n-        if (cf == null) {\n-            cf = this.getClassFileInternal(name, suffix);\n+        if (classFile == null) {\n+            classFile = this.getClassFileInternal(str, str2);\n         }\n-        if (cf != null) {\n-            return cf;\n+        if (classFile != null) {\n+            return classFile;\n         }\n-        throw new IOException(\"Couldn't find: \" + name + suffix);\n+        throw new IOException(\"Couldn't find: \" + str + str2);\n     }\n     \n-    private ClassPath.ClassFile getClassFileInternal(final String name, final String suffix) throws IOException {\n-        for (final ClassPath.AbstractPathEntry path : this.paths) {\n-            final ClassPath.ClassFile cf = path.getClassFile(name, suffix);\n-            if (cf != null) {\n-                return cf;\n+    private ClassPath.ClassFile getClassFileInternal(final String s, final String s2) throws IOException {\n+        final ClassPath.AbstractPathEntry[] paths = this.paths;\n+        for (int length = paths.length, i = 0; i < length; ++i) {\n+            final ClassPath.ClassFile classFile = paths[i].getClassFile(s, s2);\n+            if (classFile != null) {\n+                return classFile;\n             }\n         }\n         return null;\n     }\n     \n-    public InputStream getInputStream(final String name) throws IOException {\n-        return this.getInputStream(packageToFolder(name), \".class\");\n+    public InputStream getInputStream(final String s) throws IOException {\n+        return this.getInputStream(packageToFolder(s), \".class\");\n     }\n     \n-    public InputStream getInputStream(final String name, final String suffix) throws IOException {\n-        InputStream inputStream = null;\n+    public InputStream getInputStream(final String str, final String str2) throws IOException {\n+        InputStream resourceAsStream = null;\n         try {\n-            inputStream = this.getClass().getClassLoader().getResourceAsStream(name + suffix);\n+            resourceAsStream = this.getClass().getClassLoader().getResourceAsStream(str + str2);\n         }\n         catch (final Exception ex) {}\n-        if (inputStream != null) {\n-            return inputStream;\n+        if (resourceAsStream != null) {\n+            return resourceAsStream;\n         }\n-        return this.getClassFile(name, suffix).getInputStream();\n+        return this.getClassFile(str, str2).getInputStream();\n     }\n     \n-    public String getPath(String name) throws IOException {\n-        final int index = name.lastIndexOf(46);\n-        String suffix = \"\";\n-        if (index > 0) {\n-            suffix = name.substring(index);\n-            name = name.substring(0, index);\n+    public String getPath(String substring) throws IOException {\n+        final int lastIndex = substring.lastIndexOf(46);\n+        String substring2 = \"\";\n+        if (lastIndex > 0) {\n+            substring2 = substring.substring(lastIndex);\n+            substring = substring.substring(0, lastIndex);\n         }\n-        return this.getPath(name, suffix);\n+        return this.getPath(substring, substring2);\n     }\n     \n-    public String getPath(final String name, final String suffix) throws IOException {\n-        return this.getClassFile(name, suffix).getPath();\n+    public String getPath(final String s, final String s2) throws IOException {\n+        return this.getClassFile(s, s2).getPath();\n     }\n     \n-    public URL getResource(final String name) {\n-        for (final ClassPath.AbstractPathEntry path : this.paths) {\n-            final URL url;\n-            if ((url = path.getResource(name)) != null) {\n-                return url;\n+    public URL getResource(final String s) {\n+        final ClassPath.AbstractPathEntry[] paths = this.paths;\n+        for (int length = paths.length, i = 0; i < length; ++i) {\n+            final URL resource;\n+            if ((resource = paths[i].getResource(s)) != null) {\n+                return resource;\n             }\n         }\n         return null;\n     }\n     \n-    public InputStream getResourceAsStream(final String name) {\n-        for (final ClassPath.AbstractPathEntry path : this.paths) {\n-            final InputStream is;\n-            if ((is = path.getResourceAsStream(name)) != null) {\n-                return is;\n+    public InputStream getResourceAsStream(final String s) {\n+        final ClassPath.AbstractPathEntry[] paths = this.paths;\n+        for (int length = paths.length, i = 0; i < length; ++i) {\n+            final InputStream resourceAsStream;\n+            if ((resourceAsStream = paths[i].getResourceAsStream(s)) != null) {\n+                return resourceAsStream;\n             }\n         }\n         return null;\n     }\n     \n-    public Enumeration<URL> getResources(final String name) {\n-        final Vector<URL> results = new Vector<URL>();\n-        for (final ClassPath.AbstractPathEntry path : this.paths) {\n-            final URL url;\n-            if ((url = path.getResource(name)) != null) {\n-                results.add(url);\n+    public Enumeration<URL> getResources(final String s) {\n+        final Vector vector = new Vector();\n+        final ClassPath.AbstractPathEntry[] paths = this.paths;\n+        for (int length = paths.length, i = 0; i < length; ++i) {\n+            final URL resource;\n+            if ((resource = paths[i].getResource(s)) != null) {\n+                vector.add(resource);\n             }\n         }\n-        return results.elements();\n+        return vector.elements();\n     }\n     \n     @Override\n     public int hashCode() {\n         if (this.parent != null) {\n             return this.classPath.hashCode() + this.parent.hashCode();\n         }\n@@ -283,18 +285,18 @@\n         if (this.parent != null) {\n             return this.parent + File.pathSeparator + this.classPath;\n         }\n         return this.classPath;\n     }\n     \n     static {\n-        ARCHIVE_FILTER = ((dir, name) -> {\n-            name = name.toLowerCase(Locale.ENGLISH);\n-            return name.endsWith(\".zip\") || name.endsWith(\".jar\");\n+        ARCHIVE_FILTER = ((p0, lowerCase) -> {\n+            lowerCase = lowerCase.toLowerCase(Locale.ENGLISH);\n+            return lowerCase.endsWith(\".zip\") || lowerCase.endsWith(\".jar\");\n         });\n-        MODULES_FILTER = ((dir, name) -> {\n-            name = name.toLowerCase(Locale.ENGLISH);\n-            return name.endsWith(\".jmod\");\n+        MODULES_FILTER = ((p0, lowerCase2) -> {\n+            lowerCase2 = lowerCase2.toLowerCase(Locale.ENGLISH);\n+            return lowerCase2.endsWith(\".jmod\");\n         });\n         SYSTEM_CLASS_PATH = new ClassPath(getClassPath());\n     }\n }\n"}]}
