{"diffoscope-json-version": 1, "source1": "first/PerformanceTest.class", "source2": "second/PerformanceTest.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,11 +1,12 @@\n \n package org.apache.commons.csv.perf;\n \n import org.junit.jupiter.api.Test;\n+import java.util.Objects;\n import java.util.Iterator;\n import org.apache.commons.csv.CSVParser;\n import org.apache.commons.csv.CSVRecord;\n import org.apache.commons.csv.CSVFormat;\n import java.io.Reader;\n import java.io.FileReader;\n import java.io.BufferedReader;\n@@ -28,36 +29,66 @@\n     @BeforeAll\n     public static void setUpClass() throws FileNotFoundException, IOException {\n         if (PerformanceTest.BIG_FILE.exists()) {\n             System.out.println(String.format(\"Found test fixture %s: %,d bytes.\", PerformanceTest.BIG_FILE, Long.valueOf(PerformanceTest.BIG_FILE.length())));\n             return;\n         }\n         System.out.println(\"Decompressing test fixture to: \" + PerformanceTest.BIG_FILE + \"...\");\n-        try (final InputStream input = new GZIPInputStream(PerformanceTest.class.getClassLoader().getResourceAsStream(\"org/apache/commons/csv/perf/worldcitiespop.txt.gz\"));\n-             final OutputStream output = new FileOutputStream(PerformanceTest.BIG_FILE)) {\n-            IOUtils.copy(input, output);\n-            System.out.println(String.format(\"Decompressed test fixture %s: %,d bytes.\", PerformanceTest.BIG_FILE, Long.valueOf(PerformanceTest.BIG_FILE.length())));\n+        final InputStream input = new GZIPInputStream(PerformanceTest.class.getClassLoader().getResourceAsStream(\"org/apache/commons/csv/perf/worldcitiespop.txt.gz\"));\n+        Throwable x0 = null;\n+        try {\n+            final OutputStream output = new FileOutputStream(PerformanceTest.BIG_FILE);\n+            Throwable x2 = null;\n+            try {\n+                IOUtils.copy(input, output);\n+                System.out.println(String.format(\"Decompressed test fixture %s: %,d bytes.\", PerformanceTest.BIG_FILE, Long.valueOf(PerformanceTest.BIG_FILE.length())));\n+            }\n+            catch (final Throwable t) {\n+                x2 = t;\n+                throw t;\n+            }\n+            finally {\n+                $closeResource(x2, output);\n+            }\n+        }\n+        catch (final Throwable t2) {\n+            x0 = t2;\n+            throw t2;\n+        }\n+        finally {\n+            $closeResource(x0, input);\n         }\n     }\n     \n     private BufferedReader createBufferedReader() throws IOException {\n         return new BufferedReader(new FileReader(PerformanceTest.BIG_FILE));\n     }\n     \n     private long parse(final Reader reader, final boolean traverseColumns) throws IOException {\n         final CSVFormat format = CSVFormat.DEFAULT.builder().setIgnoreSurroundingSpaces(false).build();\n         long recordCount = 0L;\n-        try (final CSVParser parser = format.parse(reader)) {\n+        final CSVParser parser = format.parse(reader);\n+        Throwable x0 = null;\n+        try {\n             for (final CSVRecord record : parser) {\n                 ++recordCount;\n                 if (traverseColumns) {\n                     for (String s : record) {}\n                 }\n             }\n         }\n+        catch (final Throwable t) {\n+            x0 = t;\n+            throw t;\n+        }\n+        finally {\n+            if (parser != null) {\n+                $closeResource(x0, (AutoCloseable)parser);\n+            }\n+        }\n         return recordCount;\n     }\n     \n     private void println(final String s) {\n         System.out.println(s);\n     }\n     \n@@ -67,71 +98,107 @@\n             ++count;\n         }\n         return count;\n     }\n     \n     public long testParseBigFile(final boolean traverseColumns) throws Exception {\n         final long startMillis = System.currentTimeMillis();\n-        try (final BufferedReader reader = this.createBufferedReader()) {\n+        final BufferedReader reader = this.createBufferedReader();\n+        Throwable x0 = null;\n+        try {\n             final long count = this.parse(reader, traverseColumns);\n             final long totalMillis = System.currentTimeMillis() - startMillis;\n             this.println(String.format(\"File parsed in %,d milliseconds with Commons CSV: %,d lines.\", Long.valueOf(totalMillis), Long.valueOf(count)));\n             return totalMillis;\n         }\n+        catch (final Throwable t) {\n+            x0 = t;\n+            throw t;\n+        }\n+        finally {\n+            if (reader != null) {\n+                $closeResource(x0, reader);\n+            }\n+        }\n     }\n     \n     @Test\n     public void testParseBigFileRepeat() throws Exception {\n         long bestTime = Long.MAX_VALUE;\n         int i = 0;\n         while (true) {\n             final int n = i;\n-            this.getClass();\n+            Objects.requireNonNull(this);\n             if (n >= 10) {\n                 break;\n             }\n             bestTime = Math.min(this.testParseBigFile(false), bestTime);\n             ++i;\n         }\n         final String format = \"Best time out of %,d is %,d milliseconds.\";\n         final Object[] args = new Object[2];\n         final int n2 = 0;\n-        this.getClass();\n+        Objects.requireNonNull(this);\n         args[n2] = Integer.valueOf(10);\n         args[1] = Long.valueOf(bestTime);\n         this.println(String.format(format, args));\n     }\n     \n     @Test\n     public void testReadBigFile() throws Exception {\n         long bestTime = Long.MAX_VALUE;\n         int i = 0;\n         while (true) {\n             final int n = i;\n-            this.getClass();\n+            Objects.requireNonNull(this);\n             if (n >= 10) {\n                 break;\n             }\n+            final BufferedReader in = this.createBufferedReader();\n+            Throwable x0 = null;\n             long startMillis;\n             long count;\n-            try (final BufferedReader in = this.createBufferedReader()) {\n+            try {\n                 startMillis = System.currentTimeMillis();\n                 count = this.readAll(in);\n             }\n+            catch (final Throwable t) {\n+                x0 = t;\n+                throw t;\n+            }\n+            finally {\n+                if (in != null) {\n+                    $closeResource(x0, in);\n+                }\n+            }\n             final long totalMillis = System.currentTimeMillis() - startMillis;\n             bestTime = Math.min(totalMillis, bestTime);\n             this.println(String.format(\"File read in %,d milliseconds: %,d lines.\", Long.valueOf(totalMillis), Long.valueOf(count)));\n             ++i;\n         }\n         final String format = \"Best time out of %,d is %,d milliseconds.\";\n         final Object[] args = new Object[2];\n         final int n2 = 0;\n-        this.getClass();\n+        Objects.requireNonNull(this);\n         args[n2] = Integer.valueOf(10);\n         args[1] = Long.valueOf(bestTime);\n         this.println(String.format(format, args));\n     }\n     \n+    private static /* synthetic */ void $closeResource(final Throwable x0, final AutoCloseable x1) {\n+        if (x0 != null) {\n+            try {\n+                x1.close();\n+            }\n+            catch (final Throwable exception) {\n+                x0.addSuppressed(exception);\n+            }\n+        }\n+        else {\n+            x1.close();\n+        }\n+    }\n+    \n     static {\n         BIG_FILE = new File(System.getProperty(\"java.io.tmpdir\"), \"worldcitiespop.txt\");\n     }\n }\n"}]}
