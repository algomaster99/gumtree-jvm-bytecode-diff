{"diffoscope-json-version": 1, "source1": "first/AES256Options.class", "source2": "second/AES256Options.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,11 +1,10 @@\n \n package org.apache.commons.compress.archivers.sevenz;\n \n-import javax.crypto.SecretKey;\n import java.security.GeneralSecurityException;\n import java.security.spec.AlgorithmParameterSpec;\n import java.security.Key;\n import javax.crypto.spec.IvParameterSpec;\n import java.security.NoSuchAlgorithmException;\n import java.security.SecureRandom;\n import javax.crypto.spec.SecretKeySpec;\n@@ -16,44 +15,43 @@\n     static final String ALGORITHM = \"AES\";\n     static final String TRANSFORMATION = \"AES/CBC/NoPadding\";\n     private final byte[] salt;\n     private final byte[] iv;\n     private final int numCyclesPower;\n     private final Cipher cipher;\n     \n-    static SecretKeySpec newSecretKeySpec(final byte[] bytes) {\n-        return new SecretKeySpec(bytes, \"AES\");\n+    static SecretKeySpec newSecretKeySpec(final byte[] key) {\n+        return new SecretKeySpec(key, \"AES\");\n     }\n     \n-    private static byte[] randomBytes(final int size) {\n-        final byte[] bytes = new byte[size];\n+    private static byte[] randomBytes(final int n) {\n+        final byte[] bytes = new byte[n];\n         try {\n             SecureRandom.getInstanceStrong().nextBytes(bytes);\n         }\n-        catch (final NoSuchAlgorithmException e) {\n-            throw new IllegalStateException(\"No strong secure random available to generate strong AES key\", e);\n+        catch (final NoSuchAlgorithmException cause) {\n+            throw new IllegalStateException(\"No strong secure random available to generate strong AES key\", cause);\n         }\n         return bytes;\n     }\n     \n-    public AES256Options(final char[] password) {\n-        this(password, new byte[0], randomBytes(16), 19);\n+    public AES256Options(final char[] array) {\n+        this(array, new byte[0], randomBytes(16), 19);\n     }\n     \n-    public AES256Options(final char[] password, final byte[] salt, final byte[] iv, final int numCyclesPower) {\n+    public AES256Options(final char[] array, final byte[] salt, final byte[] array2, final int numCyclesPower) {\n         this.salt = salt;\n-        this.iv = iv;\n+        this.iv = array2;\n         this.numCyclesPower = numCyclesPower;\n-        final byte[] aesKeyBytes = AES256SHA256Decoder.sha256Password(password, numCyclesPower, salt);\n-        final SecretKey aesKey = newSecretKeySpec(aesKeyBytes);\n+        final SecretKeySpec secretKeySpec = newSecretKeySpec(AES256SHA256Decoder.sha256Password(array, numCyclesPower, salt));\n         try {\n-            (this.cipher = Cipher.getInstance(\"AES/CBC/NoPadding\")).init(1, aesKey, new IvParameterSpec(iv));\n+            (this.cipher = Cipher.getInstance(\"AES/CBC/NoPadding\")).init(1, secretKeySpec, new IvParameterSpec(array2));\n         }\n-        catch (final GeneralSecurityException generalSecurityException) {\n-            throw new IllegalStateException(\"Encryption error (do you have the JCE Unlimited Strength Jurisdiction Policy Files installed?)\", generalSecurityException);\n+        catch (final GeneralSecurityException cause) {\n+            throw new IllegalStateException(\"Encryption error (do you have the JCE Unlimited Strength Jurisdiction Policy Files installed?)\", cause);\n         }\n     }\n     \n     Cipher getCipher() {\n         return this.cipher;\n     }\n     \n"}]}
