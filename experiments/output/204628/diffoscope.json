{"diffoscope-json-version": 1, "source1": "first/ClassConstantPool.class", "source2": "second/ClassConstantPool.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -28,160 +28,161 @@\n         this.entriesContainsSet = new HashSet<ClassFileEntry>();\n         this.othersContainsSet = new HashSet<ClassFileEntry>();\n         this.mustStartClassPool = new HashSet<ClassFileEntry>();\n         this.others = new ArrayList<ClassFileEntry>(500);\n         this.entries = new ArrayList<ClassFileEntry>(500);\n     }\n     \n-    public ClassFileEntry add(final ClassFileEntry entry) {\n-        if (entry instanceof ByteCode) {\n+    public ClassFileEntry add(final ClassFileEntry classFileEntry) {\n+        if (classFileEntry instanceof ByteCode) {\n             return null;\n         }\n-        if (entry instanceof ConstantPoolEntry) {\n-            if (this.entriesContainsSet.add(entry)) {\n-                this.entries.add(entry);\n+        if (classFileEntry instanceof ConstantPoolEntry) {\n+            if (this.entriesContainsSet.add(classFileEntry)) {\n+                this.entries.add(classFileEntry);\n             }\n         }\n-        else if (this.othersContainsSet.add(entry)) {\n-            this.others.add(entry);\n+        else if (this.othersContainsSet.add(classFileEntry)) {\n+            this.others.add(classFileEntry);\n         }\n-        return entry;\n+        return classFileEntry;\n     }\n     \n     public void addNestedEntries() {\n-        boolean added = true;\n-        final List<ClassFileEntry> parents = new ArrayList<ClassFileEntry>(512);\n-        final List<ClassFileEntry> children = new ArrayList<ClassFileEntry>(512);\n-        parents.addAll(this.entries);\n-        parents.addAll(this.others);\n-        while (added || parents.size() > 0) {\n-            children.clear();\n-            final int entriesOriginalSize = this.entries.size();\n-            final int othersOriginalSize = this.others.size();\n-            for (int indexParents = 0; indexParents < parents.size(); ++indexParents) {\n-                final ClassFileEntry entry = (ClassFileEntry)parents.get(indexParents);\n-                final ClassFileEntry[] entryChildren = entry.getNestedClassFileEntries();\n-                children.addAll(Arrays.asList(entryChildren));\n-                final boolean isAtStart = entry instanceof ByteCode && ((ByteCode)entry).nestedMustStartClassPool();\n-                if (isAtStart) {\n-                    this.mustStartClassPool.addAll((Collection<?>)Arrays.asList(entryChildren));\n+        boolean b = true;\n+        final ArrayList list = new ArrayList(512);\n+        final ArrayList list2 = new ArrayList(512);\n+        list.addAll(this.entries);\n+        list.addAll(this.others);\n+        while (b || list.size() > 0) {\n+            list2.clear();\n+            final int size = this.entries.size();\n+            final int size2 = this.others.size();\n+            for (int i = 0; i < list.size(); ++i) {\n+                final ClassFileEntry classFileEntry = (ClassFileEntry)list.get(i);\n+                final ClassFileEntry[] nestedClassFileEntries = classFileEntry.getNestedClassFileEntries();\n+                list2.addAll(Arrays.asList(nestedClassFileEntries));\n+                if (classFileEntry instanceof ByteCode && ((ByteCode)classFileEntry).nestedMustStartClassPool()) {\n+                    this.mustStartClassPool.addAll((Collection<?>)Arrays.asList(nestedClassFileEntries));\n                 }\n-                this.add(entry);\n+                this.add(classFileEntry);\n             }\n-            added = (this.entries.size() != entriesOriginalSize || this.others.size() != othersOriginalSize);\n-            parents.clear();\n-            parents.addAll(children);\n+            b = (this.entries.size() != size || this.others.size() != size2);\n+            list.clear();\n+            list.addAll(list2);\n         }\n     }\n     \n-    public ClassFileEntry addWithNestedEntries(final ClassFileEntry entry) {\n-        this.add(entry);\n-        for (final ClassFileEntry nestedEntry : entry.getNestedClassFileEntries()) {\n-            this.addWithNestedEntries(nestedEntry);\n+    public ClassFileEntry addWithNestedEntries(final ClassFileEntry classFileEntry) {\n+        this.add(classFileEntry);\n+        final ClassFileEntry[] nestedClassFileEntries = classFileEntry.getNestedClassFileEntries();\n+        for (int length = nestedClassFileEntries.length, i = 0; i < length; ++i) {\n+            this.addWithNestedEntries(nestedClassFileEntries[i]);\n         }\n-        return entry;\n+        return classFileEntry;\n     }\n     \n     public List<ClassFileEntry> entries() {\n         return Collections.unmodifiableList((List<? extends ClassFileEntry>)this.entries);\n     }\n     \n-    public ClassFileEntry get(int i) {\n+    public ClassFileEntry get(int n) {\n         if (!this.resolved) {\n             throw new IllegalStateException(\"Constant pool is not yet resolved; this does not make any sense\");\n         }\n-        return this.entries.get(--i);\n+        return this.entries.get(--n);\n     }\n     \n-    public int indexOf(final ClassFileEntry entry) {\n+    public int indexOf(final ClassFileEntry classFileEntry) {\n         if (!this.resolved) {\n             throw new IllegalStateException(\"Constant pool is not yet resolved; this does not make any sense\");\n         }\n         if (null == this.indexCache) {\n             throw new IllegalStateException(\"Index cache is not initialized!\");\n         }\n-        final Integer entryIndex = Integer.valueOf(this.indexCache.get((Object)entry));\n-        if (entryIndex != null) {\n-            return entryIndex + 1;\n+        final Integer n = Integer.valueOf(this.indexCache.get((Object)classFileEntry));\n+        if (n != null) {\n+            return n + 1;\n         }\n         return -1;\n     }\n     \n     private void initialSort() {\n-        final TreeSet<ClassFileEntry> inCpAll = new TreeSet<ClassFileEntry>(Comparator.comparingInt(arg0 -> ((ConstantPoolEntry)arg0).getGlobalIndex()));\n-        final TreeSet<ClassFileEntry> cpUtf8sNotInCpAll = new TreeSet<ClassFileEntry>(Comparator.comparing(arg0 -> ((CPUTF8)arg0).underlyingString()));\n-        final TreeSet<ClassFileEntry> cpClassesNotInCpAll = new TreeSet<ClassFileEntry>(Comparator.comparing(arg0 -> ((CPClass)arg0).getName()));\n-        for (final ClassFileEntry entry2 : this.entries) {\n-            final ConstantPoolEntry entry3 = (ConstantPoolEntry)entry2;\n-            if (entry3.getGlobalIndex() == -1) {\n-                if (entry3 instanceof CPUTF8) {\n-                    cpUtf8sNotInCpAll.add((ClassFileEntry)entry3);\n+        final TreeSet set = new TreeSet(Comparator.comparingInt(classFileEntry -> ((ConstantPoolEntry)classFileEntry).getGlobalIndex()));\n+        final TreeSet set2 = new TreeSet(Comparator.comparing(classFileEntry2 -> ((CPUTF8)classFileEntry2).underlyingString()));\n+        final TreeSet set3 = new TreeSet(Comparator.comparing(classFileEntry3 -> ((CPClass)classFileEntry3).getName()));\n+        final Iterator<ClassFileEntry> iterator = this.entries.iterator();\n+        while (iterator.hasNext()) {\n+            final ConstantPoolEntry e = (ConstantPoolEntry)iterator.next();\n+            if (e.getGlobalIndex() == -1) {\n+                if (e instanceof CPUTF8) {\n+                    set2.add(e);\n                 }\n                 else {\n-                    if (!(entry3 instanceof CPClass)) {\n+                    if (!(e instanceof CPClass)) {\n                         throw new Error(\"error\");\n                     }\n-                    cpClassesNotInCpAll.add((ClassFileEntry)entry3);\n+                    set3.add(e);\n                 }\n             }\n             else {\n-                inCpAll.add((ClassFileEntry)entry3);\n+                set.add(e);\n             }\n         }\n         this.entries.clear();\n-        this.entries.addAll(inCpAll);\n-        this.entries.addAll(cpUtf8sNotInCpAll);\n-        this.entries.addAll(cpClassesNotInCpAll);\n+        this.entries.addAll(set);\n+        this.entries.addAll(set2);\n+        this.entries.addAll(set3);\n     }\n     \n     public void resolve(final Segment segment) {\n         this.initialSort();\n         this.sortClassPool();\n         this.resolved = true;\n-        this.entries.forEach(entry -> entry.resolve(this));\n-        this.others.forEach(entry -> entry.resolve(this));\n+        this.entries.forEach(classFileEntry -> classFileEntry.resolve(this));\n+        this.others.forEach(classFileEntry2 -> classFileEntry2.resolve(this));\n     }\n     \n     public int size() {\n         return this.entries.size();\n     }\n     \n     protected void sortClassPool() {\n-        final List<ClassFileEntry> startOfPool = new ArrayList<ClassFileEntry>(this.entries.size());\n-        final List<ClassFileEntry> finalSort = new ArrayList<ClassFileEntry>(this.entries.size());\n-        for (final ClassFileEntry entry : this.entries) {\n-            if (this.mustStartClassPool.contains(entry)) {\n-                startOfPool.add(entry);\n+        final ArrayList list = new ArrayList(this.entries.size());\n+        final ArrayList list2 = new ArrayList(this.entries.size());\n+        for (final ClassFileEntry o : this.entries) {\n+            if (this.mustStartClassPool.contains(o)) {\n+                list.add(o);\n             }\n             else {\n-                finalSort.add(entry);\n+                list2.add(o);\n             }\n         }\n         this.indexCache = new HashMap<ClassFileEntry, Integer>(this.entries.size());\n-        int index = 0;\n+        int n = 0;\n         this.entries.clear();\n-        for (final ClassFileEntry entry2 : startOfPool) {\n-            this.indexCache.put(entry2, Integer.valueOf(index));\n-            if (entry2 instanceof CPLong || entry2 instanceof CPDouble) {\n-                this.entries.add(entry2);\n-                this.entries.add(entry2);\n-                index += 2;\n+        for (final ClassFileEntry classFileEntry : list) {\n+            this.indexCache.put(classFileEntry, Integer.valueOf(n));\n+            if (classFileEntry instanceof CPLong || classFileEntry instanceof CPDouble) {\n+                this.entries.add(classFileEntry);\n+                this.entries.add(classFileEntry);\n+                n += 2;\n             }\n             else {\n-                this.entries.add(entry2);\n-                ++index;\n+                this.entries.add(classFileEntry);\n+                ++n;\n             }\n         }\n-        for (final ClassFileEntry entry2 : finalSort) {\n-            this.indexCache.put(entry2, Integer.valueOf(index));\n-            if (entry2 instanceof CPLong || entry2 instanceof CPDouble) {\n-                this.entries.add(entry2);\n-                this.entries.add(entry2);\n-                index += 2;\n+        for (final ClassFileEntry classFileEntry2 : list2) {\n+            this.indexCache.put(classFileEntry2, Integer.valueOf(n));\n+            if (classFileEntry2 instanceof CPLong || classFileEntry2 instanceof CPDouble) {\n+                this.entries.add(classFileEntry2);\n+                this.entries.add(classFileEntry2);\n+                n += 2;\n             }\n             else {\n-                this.entries.add(entry2);\n-                ++index;\n+                this.entries.add(classFileEntry2);\n+                ++n;\n             }\n         }\n     }\n }\n"}]}
