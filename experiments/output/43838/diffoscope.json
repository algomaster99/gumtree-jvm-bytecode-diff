{"diffoscope-json-version": 1, "source1": "first/AbstractYAMLBasedConfiguration.class", "source2": "second/AbstractYAMLBasedConfiguration.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -29,15 +29,15 @@\n     protected void load(final Map<String, Object> map) {\n         final List<ImmutableNode> roots = constructHierarchy(\"\", map);\n         this.getNodeModel().setRootNode((ImmutableNode)roots.get(0));\n     }\n     \n     protected Map<String, Object> constructMap(final ImmutableNode node) {\n         final Map<String, Object> map = new HashMap<String, Object>(node.getChildren().size());\n-        node.forEach(cNode -> addEntry(map, cNode.getNodeName(), cNode.getChildren().isEmpty() ? cNode.getValue() : this.constructMap(cNode)));\n+        node.forEach(cNode -> addEntry(map2, cNode.getNodeName(), cNode.getChildren().isEmpty() ? cNode.getValue() : this.constructMap(cNode)));\n         return map;\n     }\n     \n     private static void addEntry(final Map<String, Object> map, final String key, final Object value) {\n         final Object oldValue = map.get(key);\n         if (oldValue == null) {\n             map.put(key, value);\n@@ -62,20 +62,20 @@\n             return parseCollection((Collection<Object>)elem, key);\n         }\n         return Collections.singletonList(new ImmutableNode.Builder().name(key).value(elem).create());\n     }\n     \n     private static List<ImmutableNode> parseMap(final Map<String, Object> map, final String key) {\n         final ImmutableNode.Builder subtree = new ImmutableNode.Builder().name(key);\n-        map.forEach((k, v) -> constructHierarchy(k, v).forEach(subtree::addChild));\n+        map.forEach((k, v) -> constructHierarchy(k, v).forEach(builder::addChild));\n         return Collections.singletonList(subtree.create());\n     }\n     \n     private static List<ImmutableNode> parseCollection(final Collection<Object> col, final String key) {\n-        return col.stream().flatMap(elem -> constructHierarchy(key, elem).stream()).collect((Collector<? super Object, ?, List<ImmutableNode>>)Collectors.toList());\n+        return col.stream().flatMap(elem -> constructHierarchy(key2, elem).stream()).collect((Collector<? super Object, ?, List<ImmutableNode>>)Collectors.toList());\n     }\n     \n     static void rethrowException(final Exception e) throws ConfigurationException {\n         if (e instanceof ClassCastException) {\n             throw new ConfigurationException(\"Error parsing\", (Throwable)e);\n         }\n         throw new ConfigurationException(\"Unable to load the configuration\", (Throwable)e);\n"}]}
