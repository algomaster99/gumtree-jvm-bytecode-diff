{"diffoscope-json-version": 1, "source1": "first/FinalLocalVariableCheck.class", "source2": "second/FinalLocalVariableCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -46,345 +46,333 @@\n         return new int[] { 58, 8, 9, 7, 6, 86, 91, 10, 28 };\n     }\n     \n     public int[] getAcceptableTokens() {\n         return new int[] { 58, 8, 9, 7, 6, 86, 91, 10, 21, 28 };\n     }\n     \n-    public void visitToken(final DetailAST ast) {\n-        switch (ast.getType()) {\n+    public void visitToken(final DetailAST detailAST) {\n+        switch (detailAST.getType()) {\n             case 6:\n             case 8:\n             case 9:\n             case 91: {\n                 this.scopeStack.push(new FinalLocalVariableCheck.ScopeData());\n                 break;\n             }\n             case 7: {\n                 this.currentScopeAssignedVariables.push(new ArrayDeque<DetailAST>());\n-                if (ast.getParent().getType() != 33 || ast.getParent().getParent().findFirstToken(33) == ast.getParent()) {\n+                if (detailAST.getParent().getType() != 33 || detailAST.getParent().getParent().findFirstToken(33) == detailAST.getParent()) {\n                     this.storePrevScopeUninitializedVariableData();\n                     this.scopeStack.push(new FinalLocalVariableCheck.ScopeData());\n                     break;\n                 }\n                 break;\n             }\n             case 21: {\n-                if (!isInLambda(ast) && ast.findFirstToken(5).findFirstToken(39) == null && !isInAbstractOrNativeMethod(ast) && !ScopeUtil.isInInterfaceBlock(ast) && !isMultipleTypeCatch(ast) && !CheckUtil.isReceiverParameter(ast)) {\n-                    this.insertParameter(ast);\n+                if (!isInLambda(detailAST) && detailAST.findFirstToken(5).findFirstToken(39) == null && !isInAbstractOrNativeMethod(detailAST) && !ScopeUtil.isInInterfaceBlock(detailAST) && !isMultipleTypeCatch(detailAST) && !CheckUtil.isReceiverParameter(detailAST)) {\n+                    this.insertParameter(detailAST);\n                     break;\n                 }\n                 break;\n             }\n             case 10: {\n-                if (ast.getParent().getType() != 6 && ast.findFirstToken(5).findFirstToken(39) == null && !isVariableInForInit(ast) && this.shouldCheckEnhancedForLoopVariable(ast)) {\n-                    this.insertVariable(ast);\n+                if (detailAST.getParent().getType() != 6 && detailAST.findFirstToken(5).findFirstToken(39) == null && !isVariableInForInit(detailAST) && this.shouldCheckEnhancedForLoopVariable(detailAST)) {\n+                    this.insertVariable(detailAST);\n                     break;\n                 }\n                 break;\n             }\n             case 58: {\n-                final int parentType = ast.getParent().getType();\n-                if (isAssignOperator(parentType) && isFirstChild(ast)) {\n-                    final Optional<FinalLocalVariableCheck.FinalVariableCandidate> candidate = this.getFinalCandidate(ast);\n-                    if (candidate.isPresent()) {\n-                        determineAssignmentConditions(ast, candidate.get());\n-                        ((Deque<DetailAST>)this.currentScopeAssignedVariables.peek()).add(ast);\n+                if (isAssignOperator(detailAST.getParent().getType()) && isFirstChild(detailAST)) {\n+                    final Optional<FinalLocalVariableCheck.FinalVariableCandidate> finalCandidate = this.getFinalCandidate(detailAST);\n+                    if (finalCandidate.isPresent()) {\n+                        determineAssignmentConditions(detailAST, finalCandidate.get());\n+                        ((Deque<DetailAST>)this.currentScopeAssignedVariables.peek()).add(detailAST);\n                     }\n-                    this.removeFinalVariableCandidateFromStack(ast);\n+                    this.removeFinalVariableCandidateFromStack(detailAST);\n                     break;\n                 }\n                 break;\n             }\n             case 86: {\n                 ((FinalLocalVariableCheck.ScopeData)this.scopeStack.peek()).containsBreak = true;\n                 break;\n             }\n             case 28: {\n-                if (ast.getParent().getType() == 208) {\n+                if (detailAST.getParent().getType() == 208) {\n                     this.storePrevScopeUninitializedVariableData();\n                     break;\n                 }\n                 break;\n             }\n             default: {\n                 throw new IllegalStateException(\"Incorrect token type\");\n             }\n         }\n     }\n     \n-    public void leaveToken(final DetailAST ast) {\n-        Map<String, FinalLocalVariableCheck.FinalVariableCandidate> scope = null;\n-        final DetailAST parentAst = ast.getParent();\n-        switch (ast.getType()) {\n+    public void leaveToken(final DetailAST detailAST) {\n+        Map map = null;\n+        final DetailAST parent = detailAST.getParent();\n+        switch (detailAST.getType()) {\n             case 6:\n             case 8:\n             case 9:\n             case 91: {\n-                scope = ((FinalLocalVariableCheck.ScopeData)this.scopeStack.pop()).scope;\n+                map = ((FinalLocalVariableCheck.ScopeData)this.scopeStack.pop()).scope;\n                 break;\n             }\n             case 28: {\n-                if (parentAst.getType() != 208) {\n+                if (parent.getType() != 208) {\n                     break;\n                 }\n-                final Deque<DetailAST> prevScopeUninitializedVariableData = (Deque<DetailAST>)this.prevScopeUninitializedVariables.peek();\n-                if (shouldUpdateUninitializedVariables(parentAst)) {\n-                    this.updateAllUninitializedVariables(prevScopeUninitializedVariableData);\n+                final Deque deque = (Deque)this.prevScopeUninitializedVariables.peek();\n+                if (shouldUpdateUninitializedVariables(parent)) {\n+                    this.updateAllUninitializedVariables(deque);\n                     break;\n                 }\n                 break;\n             }\n             case 7: {\n-                final Deque<DetailAST> prevScopeUninitializedVariableData = (Deque<DetailAST>)this.prevScopeUninitializedVariables.peek();\n+                final Deque deque2 = (Deque)this.prevScopeUninitializedVariables.peek();\n                 boolean containsBreak = false;\n-                if (parentAst.getType() != 33 || findLastCaseGroupWhichContainsSlist(parentAst.getParent()) == parentAst) {\n+                if (parent.getType() != 33 || findLastCaseGroupWhichContainsSlist(parent.getParent()) == parent) {\n                     containsBreak = ((FinalLocalVariableCheck.ScopeData)this.scopeStack.peek()).containsBreak;\n-                    scope = ((FinalLocalVariableCheck.ScopeData)this.scopeStack.pop()).scope;\n+                    map = ((FinalLocalVariableCheck.ScopeData)this.scopeStack.pop()).scope;\n                     this.prevScopeUninitializedVariables.pop();\n                 }\n-                if (containsBreak || shouldUpdateUninitializedVariables(parentAst)) {\n-                    this.updateAllUninitializedVariables(prevScopeUninitializedVariableData);\n+                if (containsBreak || shouldUpdateUninitializedVariables(parent)) {\n+                    this.updateAllUninitializedVariables(deque2);\n                 }\n                 this.updateCurrentScopeAssignedVariables();\n                 break;\n             }\n         }\n-        if (scope != null) {\n-            for (final FinalLocalVariableCheck.FinalVariableCandidate candidate : scope.values()) {\n-                final DetailAST ident = candidate.variableIdent;\n-                this.log(ident, \"final.variable\", new Object[] { ident.getText() });\n+        if (map != null) {\n+            final Iterator iterator = map.values().iterator();\n+            while (iterator.hasNext()) {\n+                final DetailAST variableIdent = ((FinalLocalVariableCheck.FinalVariableCandidate)iterator.next()).variableIdent;\n+                this.log(variableIdent, \"final.variable\", new Object[] { variableIdent.getText() });\n             }\n         }\n     }\n     \n     private void updateCurrentScopeAssignedVariables() {\n-        final Deque<DetailAST> poppedScopeAssignedVariableData = (Deque<DetailAST>)this.currentScopeAssignedVariables.pop();\n-        final Deque<DetailAST> currentScopeAssignedVariableData = (Deque<DetailAST>)this.currentScopeAssignedVariables.peek();\n-        if (currentScopeAssignedVariableData != null) {\n-            currentScopeAssignedVariableData.addAll(poppedScopeAssignedVariableData);\n+        final Deque deque = (Deque)this.currentScopeAssignedVariables.pop();\n+        final Deque deque2 = (Deque)this.currentScopeAssignedVariables.peek();\n+        if (deque2 != null) {\n+            deque2.addAll(deque);\n         }\n     }\n     \n-    private static void determineAssignmentConditions(final DetailAST ident, final FinalLocalVariableCheck.FinalVariableCandidate candidate) {\n-        if (candidate.assigned) {\n-            final int[] blockTypes = { 92, 33, 208 };\n-            if (!isInSpecificCodeBlocks(ident, blockTypes)) {\n-                candidate.alreadyAssigned = true;\n+    private static void determineAssignmentConditions(final DetailAST detailAST, final FinalLocalVariableCheck.FinalVariableCandidate finalVariableCandidate) {\n+        if (finalVariableCandidate.assigned) {\n+            if (!isInSpecificCodeBlocks(detailAST, 92, 33, 208)) {\n+                finalVariableCandidate.alreadyAssigned = true;\n             }\n         }\n         else {\n-            candidate.assigned = true;\n+            finalVariableCandidate.assigned = true;\n         }\n     }\n     \n-    private static boolean isInSpecificCodeBlocks(final DetailAST node, final int... blockTypes) {\n-        boolean returnValue = false;\n-        for (final int blockType : blockTypes) {\n-            for (DetailAST token = node; token != null; token = token.getParent()) {\n-                final int type = token.getType();\n-                if (type == blockType) {\n-                    returnValue = true;\n+    private static boolean isInSpecificCodeBlocks(final DetailAST detailAST, final int... array) {\n+        boolean b = false;\n+        for (final int n : array) {\n+            for (DetailAST parent = detailAST; parent != null; parent = parent.getParent()) {\n+                if (parent.getType() == n) {\n+                    b = true;\n                     break;\n                 }\n             }\n         }\n-        return returnValue;\n+        return b;\n     }\n     \n-    private Optional<FinalLocalVariableCheck.FinalVariableCandidate> getFinalCandidate(final DetailAST ast) {\n-        Optional<FinalLocalVariableCheck.FinalVariableCandidate> result = Optional.empty();\n-        FinalLocalVariableCheck.ScopeData scopeData;\n-        for (Iterator<FinalLocalVariableCheck.ScopeData> iterator = this.scopeStack.descendingIterator(); iterator.hasNext() && result.isEmpty(); result = scopeData.findFinalVariableCandidateForAst(ast)) {\n-            scopeData = iterator.next();\n-        }\n-        return result;\n+    private Optional<FinalLocalVariableCheck.FinalVariableCandidate> getFinalCandidate(final DetailAST detailAST) {\n+        Optional<Object> optional = Optional.empty();\n+        for (Iterator<FinalLocalVariableCheck.ScopeData> descendingIterator = this.scopeStack.descendingIterator(); descendingIterator.hasNext() && optional.isEmpty(); optional = ((FinalLocalVariableCheck.ScopeData)descendingIterator.next()).findFinalVariableCandidateForAst(detailAST)) {}\n+        return (Optional<FinalLocalVariableCheck.FinalVariableCandidate>)optional;\n     }\n     \n     private void storePrevScopeUninitializedVariableData() {\n         final FinalLocalVariableCheck.ScopeData scopeData = (FinalLocalVariableCheck.ScopeData)this.scopeStack.peek();\n-        final Deque<DetailAST> prevScopeUninitializedVariableData = new ArrayDeque<DetailAST>();\n+        final ArrayDeque arrayDeque = new ArrayDeque();\n         final Deque uninitializedVariables = scopeData.uninitializedVariables;\n-        final Deque<DetailAST> obj = prevScopeUninitializedVariableData;\n-        Objects.requireNonNull((ArrayDeque)obj);\n+        final ArrayDeque obj = arrayDeque;\n+        Objects.requireNonNull(obj);\n         uninitializedVariables.forEach(obj::push);\n-        this.prevScopeUninitializedVariables.push(prevScopeUninitializedVariableData);\n+        this.prevScopeUninitializedVariables.push(arrayDeque);\n     }\n     \n-    private void updateAllUninitializedVariables(final Deque<DetailAST> prevScopeUninitializedVariableData) {\n-        final boolean hasSomeScopes = !this.currentScopeAssignedVariables.isEmpty();\n-        if (hasSomeScopes) {\n-            this.updateUninitializedVariables(prevScopeUninitializedVariableData);\n+    private void updateAllUninitializedVariables(final Deque<DetailAST> deque) {\n+        if (!this.currentScopeAssignedVariables.isEmpty()) {\n+            this.updateUninitializedVariables(deque);\n             this.prevScopeUninitializedVariables.forEach(this::updateUninitializedVariables);\n         }\n     }\n     \n-    private void updateUninitializedVariables(final Deque<DetailAST> scopeUninitializedVariableData) {\n-        final Iterator<DetailAST> iterator = ((Deque<DetailAST>)this.currentScopeAssignedVariables.peek()).iterator();\n+    private void updateUninitializedVariables(final Deque<DetailAST> deque) {\n+        final Iterator iterator = ((Deque)this.currentScopeAssignedVariables.peek()).iterator();\n         while (iterator.hasNext()) {\n-            final DetailAST assignedVariable = (DetailAST)iterator.next();\n-            boolean shouldRemove = false;\n-            for (final DetailAST variable : scopeUninitializedVariableData) {\n+            final DetailAST detailAST = (DetailAST)iterator.next();\n+            boolean b = false;\n+            for (final DetailAST detailAST2 : deque) {\n                 for (final FinalLocalVariableCheck.ScopeData scopeData : this.scopeStack) {\n-                    final FinalLocalVariableCheck.FinalVariableCandidate candidate = (FinalLocalVariableCheck.FinalVariableCandidate)scopeData.scope.get(variable.getText());\n-                    DetailAST storedVariable = null;\n-                    if (candidate != null) {\n-                        storedVariable = candidate.variableIdent;\n+                    final FinalLocalVariableCheck.FinalVariableCandidate finalVariableCandidate = (FinalLocalVariableCheck.FinalVariableCandidate)scopeData.scope.get(detailAST2.getText());\n+                    DetailAST variableIdent = null;\n+                    if (finalVariableCandidate != null) {\n+                        variableIdent = finalVariableCandidate.variableIdent;\n                     }\n-                    if (storedVariable != null && isSameVariables(assignedVariable, variable)) {\n-                        scopeData.uninitializedVariables.push(variable);\n-                        shouldRemove = true;\n+                    if (variableIdent != null && isSameVariables(detailAST, detailAST2)) {\n+                        scopeData.uninitializedVariables.push(detailAST2);\n+                        b = true;\n                     }\n                 }\n             }\n-            if (shouldRemove) {\n+            if (b) {\n                 iterator.remove();\n             }\n         }\n     }\n     \n-    private static boolean shouldUpdateUninitializedVariables(final DetailAST ast) {\n-        return ast.getLastChild().getType() == 92 || isCaseTokenWithAnotherCaseFollowing(ast);\n+    private static boolean shouldUpdateUninitializedVariables(final DetailAST detailAST) {\n+        return detailAST.getLastChild().getType() == 92 || isCaseTokenWithAnotherCaseFollowing(detailAST);\n     }\n     \n-    private static boolean isCaseTokenWithAnotherCaseFollowing(final DetailAST ast) {\n-        boolean result = false;\n-        if (ast.getType() == 33) {\n-            result = (findLastCaseGroupWhichContainsSlist(ast.getParent()) != ast);\n+    private static boolean isCaseTokenWithAnotherCaseFollowing(final DetailAST detailAST) {\n+        boolean b = false;\n+        if (detailAST.getType() == 33) {\n+            b = (findLastCaseGroupWhichContainsSlist(detailAST.getParent()) != detailAST);\n         }\n-        else if (ast.getType() == 208) {\n-            result = (ast.getNextSibling().getType() == 208);\n+        else if (detailAST.getType() == 208) {\n+            b = (detailAST.getNextSibling().getType() == 208);\n         }\n-        return result;\n+        return b;\n     }\n     \n-    private static DetailAST findLastCaseGroupWhichContainsSlist(final DetailAST literalSwitchAst) {\n-        DetailAST returnValue = null;\n-        for (DetailAST astIterator = literalSwitchAst.getFirstChild(); astIterator != null; astIterator = astIterator.getNextSibling()) {\n-            if (astIterator.findFirstToken(7) != null) {\n-                returnValue = astIterator;\n+    private static DetailAST findLastCaseGroupWhichContainsSlist(final DetailAST detailAST) {\n+        DetailAST detailAST2 = null;\n+        for (DetailAST detailAST3 = detailAST.getFirstChild(); detailAST3 != null; detailAST3 = detailAST3.getNextSibling()) {\n+            if (detailAST3.findFirstToken(7) != null) {\n+                detailAST2 = detailAST3;\n             }\n         }\n-        return returnValue;\n+        return detailAST2;\n     }\n     \n-    private boolean shouldCheckEnhancedForLoopVariable(final DetailAST ast) {\n-        return this.validateEnhancedForLoopVariable || ast.getParent().getType() != 156;\n+    private boolean shouldCheckEnhancedForLoopVariable(final DetailAST detailAST) {\n+        return this.validateEnhancedForLoopVariable || detailAST.getParent().getType() != 156;\n     }\n     \n-    private void insertParameter(final DetailAST ast) {\n-        final Map<String, FinalLocalVariableCheck.FinalVariableCandidate> scope = ((FinalLocalVariableCheck.ScopeData)this.scopeStack.peek()).scope;\n-        final DetailAST astNode = ast.findFirstToken(58);\n-        scope.put(astNode.getText(), new FinalLocalVariableCheck.FinalVariableCandidate(astNode));\n+    private void insertParameter(final DetailAST detailAST) {\n+        final Map scope = ((FinalLocalVariableCheck.ScopeData)this.scopeStack.peek()).scope;\n+        final DetailAST firstToken = detailAST.findFirstToken(58);\n+        scope.put(firstToken.getText(), new FinalLocalVariableCheck.FinalVariableCandidate(firstToken));\n     }\n     \n-    private void insertVariable(final DetailAST ast) {\n-        final Map<String, FinalLocalVariableCheck.FinalVariableCandidate> scope = ((FinalLocalVariableCheck.ScopeData)this.scopeStack.peek()).scope;\n-        final DetailAST astNode = ast.findFirstToken(58);\n-        final FinalLocalVariableCheck.FinalVariableCandidate candidate = new FinalLocalVariableCheck.FinalVariableCandidate(astNode);\n-        candidate.assigned = (ast.getParent().getType() == 156);\n-        scope.put(astNode.getText(), candidate);\n-        if (!isInitialized(astNode)) {\n-            ((FinalLocalVariableCheck.ScopeData)this.scopeStack.peek()).uninitializedVariables.add(astNode);\n+    private void insertVariable(final DetailAST detailAST) {\n+        final Map scope = ((FinalLocalVariableCheck.ScopeData)this.scopeStack.peek()).scope;\n+        final DetailAST firstToken = detailAST.findFirstToken(58);\n+        final FinalLocalVariableCheck.FinalVariableCandidate finalVariableCandidate = new FinalLocalVariableCheck.FinalVariableCandidate(firstToken);\n+        finalVariableCandidate.assigned = (detailAST.getParent().getType() == 156);\n+        scope.put(firstToken.getText(), finalVariableCandidate);\n+        if (!isInitialized(firstToken)) {\n+            ((FinalLocalVariableCheck.ScopeData)this.scopeStack.peek()).uninitializedVariables.add(firstToken);\n         }\n     }\n     \n-    private static boolean isInitialized(final DetailAST ast) {\n-        return ast.getParent().getLastChild().getType() == 80;\n+    private static boolean isInitialized(final DetailAST detailAST) {\n+        return detailAST.getParent().getLastChild().getType() == 80;\n     }\n     \n-    private static boolean isFirstChild(final DetailAST ast) {\n-        return ast.getPreviousSibling() == null;\n+    private static boolean isFirstChild(final DetailAST detailAST) {\n+        return detailAST.getPreviousSibling() == null;\n     }\n     \n-    private void removeFinalVariableCandidateFromStack(final DetailAST ast) {\n-        final Iterator<FinalLocalVariableCheck.ScopeData> iterator = this.scopeStack.descendingIterator();\n-        while (iterator.hasNext()) {\n-            final FinalLocalVariableCheck.ScopeData scopeData = (FinalLocalVariableCheck.ScopeData)iterator.next();\n-            final Map<String, FinalLocalVariableCheck.FinalVariableCandidate> scope = scopeData.scope;\n-            final FinalLocalVariableCheck.FinalVariableCandidate candidate = (FinalLocalVariableCheck.FinalVariableCandidate)scope.get(ast.getText());\n-            DetailAST storedVariable = null;\n-            if (candidate != null) {\n-                storedVariable = candidate.variableIdent;\n-            }\n-            if (storedVariable != null && isSameVariables(storedVariable, ast)) {\n-                if (shouldRemoveFinalVariableCandidate(scopeData, ast)) {\n-                    scope.remove(ast.getText());\n+    private void removeFinalVariableCandidateFromStack(final DetailAST detailAST) {\n+        final Iterator<FinalLocalVariableCheck.ScopeData> descendingIterator = this.scopeStack.descendingIterator();\n+        while (descendingIterator.hasNext()) {\n+            final FinalLocalVariableCheck.ScopeData scopeData = (FinalLocalVariableCheck.ScopeData)descendingIterator.next();\n+            final Map scope = scopeData.scope;\n+            final FinalLocalVariableCheck.FinalVariableCandidate finalVariableCandidate = (FinalLocalVariableCheck.FinalVariableCandidate)scope.get(detailAST.getText());\n+            DetailAST variableIdent = null;\n+            if (finalVariableCandidate != null) {\n+                variableIdent = finalVariableCandidate.variableIdent;\n+            }\n+            if (variableIdent != null && isSameVariables(variableIdent, detailAST)) {\n+                if (shouldRemoveFinalVariableCandidate(scopeData, detailAST)) {\n+                    scope.remove(detailAST.getText());\n                     break;\n                 }\n                 break;\n             }\n         }\n     }\n     \n-    private static boolean isMultipleTypeCatch(final DetailAST parameterDefAst) {\n-        final DetailAST typeAst = parameterDefAst.findFirstToken(13);\n-        return typeAst.findFirstToken(112) != null;\n+    private static boolean isMultipleTypeCatch(final DetailAST detailAST) {\n+        return detailAST.findFirstToken(13).findFirstToken(112) != null;\n     }\n     \n-    private static boolean shouldRemoveFinalVariableCandidate(final FinalLocalVariableCheck.ScopeData scopeData, final DetailAST ast) {\n-        boolean shouldRemove = true;\n-        for (final DetailAST variable : scopeData.uninitializedVariables) {\n-            if (variable.getText().equals(ast.getText())) {\n-                final DetailAST currAstLoopAstParent = getParentLoop(ast);\n-                final DetailAST currVarLoopAstParent = getParentLoop(variable);\n-                if (currAstLoopAstParent == currVarLoopAstParent) {\n-                    final FinalLocalVariableCheck.FinalVariableCandidate candidate = (FinalLocalVariableCheck.FinalVariableCandidate)scopeData.scope.get(ast.getText());\n-                    shouldRemove = candidate.alreadyAssigned;\n+    private static boolean shouldRemoveFinalVariableCandidate(final FinalLocalVariableCheck.ScopeData scopeData, final DetailAST detailAST) {\n+        boolean alreadyAssigned = true;\n+        for (final DetailAST detailAST2 : scopeData.uninitializedVariables) {\n+            if (detailAST2.getText().equals(detailAST.getText())) {\n+                if (getParentLoop(detailAST) == getParentLoop(detailAST2)) {\n+                    alreadyAssigned = ((FinalLocalVariableCheck.FinalVariableCandidate)scopeData.scope.get(detailAST.getText())).alreadyAssigned;\n                 }\n-                scopeData.uninitializedVariables.remove(variable);\n+                scopeData.uninitializedVariables.remove(detailAST2);\n                 break;\n             }\n         }\n-        return shouldRemove;\n+        return alreadyAssigned;\n     }\n     \n-    private static DetailAST getParentLoop(final DetailAST ast) {\n-        DetailAST parentLoop;\n-        for (parentLoop = ast; parentLoop != null && !isLoopAst(parentLoop.getType()); parentLoop = parentLoop.getParent()) {}\n-        return parentLoop;\n+    private static DetailAST getParentLoop(final DetailAST detailAST) {\n+        DetailAST parent;\n+        for (parent = detailAST; parent != null && !isLoopAst(parent.getType()); parent = parent.getParent()) {}\n+        return parent;\n     }\n     \n-    private static boolean isAssignOperator(final int parentType) {\n-        return FinalLocalVariableCheck.ASSIGN_OPERATOR_TYPES.get(parentType);\n+    private static boolean isAssignOperator(final int bitIndex) {\n+        return FinalLocalVariableCheck.ASSIGN_OPERATOR_TYPES.get(bitIndex);\n     }\n     \n-    private static boolean isVariableInForInit(final DetailAST variableDef) {\n-        return variableDef.getParent().getType() == 35;\n+    private static boolean isVariableInForInit(final DetailAST detailAST) {\n+        return detailAST.getParent().getType() == 35;\n     }\n     \n-    private static boolean isInAbstractOrNativeMethod(final DetailAST ast) {\n-        boolean abstractOrNative = false;\n-        for (DetailAST currentAst = ast; currentAst != null && !abstractOrNative; currentAst = currentAst.getParent()) {\n-            if (currentAst.getType() == 9) {\n-                final DetailAST modifiers = currentAst.findFirstToken(5);\n-                abstractOrNative = (modifiers.findFirstToken(40) != null || modifiers.findFirstToken(66) != null);\n+    private static boolean isInAbstractOrNativeMethod(final DetailAST detailAST) {\n+        boolean b = false;\n+        for (DetailAST parent = detailAST; parent != null && !b; parent = parent.getParent()) {\n+            if (parent.getType() == 9) {\n+                final DetailAST firstToken = parent.findFirstToken(5);\n+                b = (firstToken.findFirstToken(40) != null || firstToken.findFirstToken(66) != null);\n             }\n         }\n-        return abstractOrNative;\n+        return b;\n     }\n     \n-    private static boolean isInLambda(final DetailAST paramDef) {\n-        return paramDef.getParent().getParent().getType() == 181;\n+    private static boolean isInLambda(final DetailAST detailAST) {\n+        return detailAST.getParent().getParent().getType() == 181;\n     }\n     \n-    private static DetailAST findFirstUpperNamedBlock(final DetailAST ast) {\n-        DetailAST astTraverse;\n-        for (astTraverse = ast; !TokenUtil.isOfType(astTraverse, new int[] { 9, 14, 154, 8, 203 }) && !ScopeUtil.isClassFieldDef(astTraverse); astTraverse = astTraverse.getParent()) {}\n-        return astTraverse;\n+    private static DetailAST findFirstUpperNamedBlock(final DetailAST detailAST) {\n+        DetailAST parent;\n+        for (parent = detailAST; !TokenUtil.isOfType(parent, new int[] { 9, 14, 154, 8, 203 }) && !ScopeUtil.isClassFieldDef(parent); parent = parent.getParent()) {}\n+        return parent;\n     }\n     \n-    private static boolean isSameVariables(final DetailAST ast1, final DetailAST ast2) {\n-        final DetailAST classOrMethodOfAst1 = findFirstUpperNamedBlock(ast1);\n-        final DetailAST classOrMethodOfAst2 = findFirstUpperNamedBlock(ast2);\n-        return classOrMethodOfAst1 == classOrMethodOfAst2 && ast1.getText().equals(ast2.getText());\n+    private static boolean isSameVariables(final DetailAST detailAST, final DetailAST detailAST2) {\n+        return findFirstUpperNamedBlock(detailAST) == findFirstUpperNamedBlock(detailAST2) && detailAST.getText().equals(detailAST2.getText());\n     }\n     \n-    private static boolean isLoopAst(final int ast) {\n-        return FinalLocalVariableCheck.LOOP_TYPES.get(ast);\n+    private static boolean isLoopAst(final int bitIndex) {\n+        return FinalLocalVariableCheck.LOOP_TYPES.get(bitIndex);\n     }\n     \n     static {\n         ASSIGN_OPERATOR_TYPES = TokenUtil.asBitSet(new int[] { 25, 26, 80, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 129, 130 });\n         LOOP_TYPES = TokenUtil.asBitSet(new int[] { 91, 84, 85 });\n     }\n }\n"}]}
