{"diffoscope-json-version": 1, "source1": "first/Rule.class", "source2": "second/Rule.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -23,257 +23,253 @@\n     private static final String HASH_INCLUDE = \"#include\";\n     private static final Map<NameType, Map<RuleType, Map<String, Map<String, List<Rule>>>>> RULES;\n     private final Rule.RPattern lContext;\n     private final String pattern;\n     private final Rule.PhonemeExpr phoneme;\n     private final Rule.RPattern rContext;\n     \n-    private static boolean contains(final CharSequence chars, final char input) {\n-        for (int i = 0; i < chars.length(); ++i) {\n-            if (chars.charAt(i) == input) {\n+    private static boolean contains(final CharSequence charSequence, final char c) {\n+        for (int i = 0; i < charSequence.length(); ++i) {\n+            if (charSequence.charAt(i) == c) {\n                 return true;\n             }\n         }\n         return false;\n     }\n     \n-    private static String createResourceName(final NameType nameType, final RuleType rt, final String lang) {\n-        return String.format(\"org/apache/commons/codec/language/bm/%s_%s_%s.txt\", nameType.getName(), rt.getName(), lang);\n+    private static String createResourceName(final NameType nameType, final RuleType ruleType, final String s) {\n+        return String.format(\"org/apache/commons/codec/language/bm/%s_%s_%s.txt\", nameType.getName(), ruleType.getName(), s);\n     }\n     \n-    private static Scanner createScanner(final NameType nameType, final RuleType rt, final String lang) {\n-        final String resName = createResourceName(nameType, rt, lang);\n-        final InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\n-        if (rulesIS == null) {\n-            throw new IllegalArgumentException(\"Unable to load resource: \" + resName);\n+    private static Scanner createScanner(final NameType nameType, final RuleType ruleType, final String s) {\n+        final String resourceName = createResourceName(nameType, ruleType, s);\n+        final InputStream resourceAsStream = Languages.class.getClassLoader().getResourceAsStream(resourceName);\n+        if (resourceAsStream == null) {\n+            throw new IllegalArgumentException(\"Unable to load resource: \" + resourceName);\n         }\n-        return new Scanner(rulesIS, \"UTF-8\");\n+        return new Scanner(resourceAsStream, \"UTF-8\");\n     }\n     \n-    private static Scanner createScanner(final String lang) {\n-        final String resName = String.format(\"org/apache/commons/codec/language/bm/%s.txt\", lang);\n-        final InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\n-        if (rulesIS == null) {\n-            throw new IllegalArgumentException(\"Unable to load resource: \" + resName);\n+    private static Scanner createScanner(final String s) {\n+        final String format = String.format(\"org/apache/commons/codec/language/bm/%s.txt\", s);\n+        final InputStream resourceAsStream = Languages.class.getClassLoader().getResourceAsStream(format);\n+        if (resourceAsStream == null) {\n+            throw new IllegalArgumentException(\"Unable to load resource: \" + format);\n         }\n-        return new Scanner(rulesIS, \"UTF-8\");\n+        return new Scanner(resourceAsStream, \"UTF-8\");\n     }\n     \n-    private static boolean endsWith(final CharSequence input, final CharSequence suffix) {\n-        if (suffix.length() > input.length()) {\n+    private static boolean endsWith(final CharSequence charSequence, final CharSequence charSequence2) {\n+        if (charSequence2.length() > charSequence.length()) {\n             return false;\n         }\n-        int i = input.length() - 1;\n-        for (int j = suffix.length() - 1; j >= 0; --j) {\n-            if (input.charAt(i) != suffix.charAt(j)) {\n+        int n = charSequence.length() - 1;\n+        for (int i = charSequence2.length() - 1; i >= 0; --i) {\n+            if (charSequence.charAt(n) != charSequence2.charAt(i)) {\n                 return false;\n             }\n-            --i;\n+            --n;\n         }\n         return true;\n     }\n     \n-    public static List<Rule> getInstance(final NameType nameType, final RuleType rt, final Languages.LanguageSet langs) {\n-        final Map<String, List<Rule>> ruleMap = getInstanceMap(nameType, rt, langs);\n-        final List<Rule> allRules = new ArrayList<Rule>();\n-        for (final List<Rule> rules : ruleMap.values()) {\n-            allRules.addAll(rules);\n+    public static List<Rule> getInstance(final NameType nameType, final RuleType ruleType, final Languages.LanguageSet set) {\n+        final Map<String, List<Rule>> instanceMap = getInstanceMap(nameType, ruleType, set);\n+        final ArrayList list = new ArrayList();\n+        final Iterator<List<Rule>> iterator = instanceMap.values().iterator();\n+        while (iterator.hasNext()) {\n+            list.addAll(iterator.next());\n         }\n-        return allRules;\n+        return list;\n     }\n     \n-    public static List<Rule> getInstance(final NameType nameType, final RuleType rt, final String lang) {\n-        return getInstance(nameType, rt, Languages.LanguageSet.from((Set)new HashSet(Arrays.asList(lang))));\n+    public static List<Rule> getInstance(final NameType nameType, final RuleType ruleType, final String s) {\n+        return getInstance(nameType, ruleType, Languages.LanguageSet.from((Set)new HashSet(Arrays.asList(s))));\n     }\n     \n-    public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt, final Languages.LanguageSet langs) {\n-        return langs.isSingleton() ? getInstanceMap(nameType, rt, langs.getAny()) : getInstanceMap(nameType, rt, \"any\");\n+    public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType ruleType, final Languages.LanguageSet set) {\n+        return set.isSingleton() ? getInstanceMap(nameType, ruleType, set.getAny()) : getInstanceMap(nameType, ruleType, \"any\");\n     }\n     \n-    public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt, final String lang) {\n-        final Map<String, List<Rule>> rules = (Map<String, List<Rule>>)((Map)((Map)Rule.RULES.get(nameType)).get(rt)).get(lang);\n-        if (rules == null) {\n-            throw new IllegalArgumentException(String.format(\"No rules found for %s, %s, %s.\", nameType.getName(), rt.getName(), lang));\n+    public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType ruleType, final String s) {\n+        final Map map = (Map)((Map)((Map)Rule.RULES.get(nameType)).get(ruleType)).get(s);\n+        if (map == null) {\n+            throw new IllegalArgumentException(String.format(\"No rules found for %s, %s, %s.\", nameType.getName(), ruleType.getName(), s));\n         }\n-        return rules;\n+        return map;\n     }\n     \n-    private static Rule.Phoneme parsePhoneme(final String ph) {\n-        final int open = ph.indexOf(\"[\");\n-        if (open < 0) {\n-            return new Rule.Phoneme((CharSequence)ph, Languages.ANY_LANGUAGE);\n+    private static Rule.Phoneme parsePhoneme(final String s) {\n+        final int index = s.indexOf(\"[\");\n+        if (index < 0) {\n+            return new Rule.Phoneme((CharSequence)s, Languages.ANY_LANGUAGE);\n         }\n-        if (!ph.endsWith(\"]\")) {\n+        if (!s.endsWith(\"]\")) {\n             throw new IllegalArgumentException(\"Phoneme expression contains a '[' but does not end in ']'\");\n         }\n-        final String before = ph.substring(0, open);\n-        final String in = ph.substring(open + 1, ph.length() - 1);\n-        final Set<String> langs = new HashSet<String>(Arrays.asList(in.split(\"[+]\")));\n-        return new Rule.Phoneme((CharSequence)before, Languages.LanguageSet.from((Set)langs));\n+        return new Rule.Phoneme((CharSequence)s.substring(0, index), Languages.LanguageSet.from((Set)new HashSet(Arrays.asList(s.substring(index + 1, s.length() - 1).split(\"[+]\")))));\n     }\n     \n-    private static Rule.PhonemeExpr parsePhonemeExpr(final String ph) {\n-        if (!ph.startsWith(\"(\")) {\n-            return (Rule.PhonemeExpr)parsePhoneme(ph);\n+    private static Rule.PhonemeExpr parsePhonemeExpr(final String s) {\n+        if (!s.startsWith(\"(\")) {\n+            return (Rule.PhonemeExpr)parsePhoneme(s);\n         }\n-        if (!ph.endsWith(\")\")) {\n+        if (!s.endsWith(\")\")) {\n             throw new IllegalArgumentException(\"Phoneme starts with '(' so must end with ')'\");\n         }\n-        final List<Rule.Phoneme> phs = new ArrayList<Rule.Phoneme>();\n-        final String body = ph.substring(1, ph.length() - 1);\n-        for (final String part : body.split(\"[|]\")) {\n-            phs.add(parsePhoneme(part));\n-        }\n-        if (body.startsWith(\"|\") || body.endsWith(\"|\")) {\n-            phs.add(new Rule.Phoneme((CharSequence)\"\", Languages.ANY_LANGUAGE));\n-        }\n-        return (Rule.PhonemeExpr)new Rule.PhonemeList((List)phs);\n-    }\n-    \n-    private static Map<String, List<Rule>> parseRules(final Scanner scanner, final String location) {\n-        final Map<String, List<Rule>> lines = new HashMap<String, List<Rule>>();\n-        int currentLine = 0;\n-        boolean inMultilineComment = false;\n+        final ArrayList list = new ArrayList();\n+        final String substring = s.substring(1, s.length() - 1);\n+        final String[] split = substring.split(\"[|]\");\n+        for (int length = split.length, i = 0; i < length; ++i) {\n+            list.add(parsePhoneme(split[i]));\n+        }\n+        if (substring.startsWith(\"|\") || substring.endsWith(\"|\")) {\n+            list.add(new Rule.Phoneme((CharSequence)\"\", Languages.ANY_LANGUAGE));\n+        }\n+        return (Rule.PhonemeExpr)new Rule.PhonemeList((List)list);\n+    }\n+    \n+    private static Map<String, List<Rule>> parseRules(final Scanner scanner, final String s) {\n+        final HashMap hashMap = new HashMap();\n+        int i = 0;\n+        int n = 0;\n         while (scanner.hasNextLine()) {\n-            ++currentLine;\n-            String line;\n-            final String rawLine = line = scanner.nextLine();\n-            if (inMultilineComment) {\n-                if (!line.endsWith(\"*/\")) {\n+            ++i;\n+            String s3;\n+            final String s2 = s3 = scanner.nextLine();\n+            if (n != 0) {\n+                if (!s3.endsWith(\"*/\")) {\n                     continue;\n                 }\n-                inMultilineComment = false;\n+                n = 0;\n             }\n-            else if (line.startsWith(\"/*\")) {\n-                inMultilineComment = true;\n+            else if (s3.startsWith(\"/*\")) {\n+                n = 1;\n             }\n             else {\n-                final int cmtI = line.indexOf(\"//\");\n-                if (cmtI >= 0) {\n-                    line = line.substring(0, cmtI);\n+                final int index = s3.indexOf(\"//\");\n+                if (index >= 0) {\n+                    s3 = s3.substring(0, index);\n                 }\n-                line = line.trim();\n-                if (line.length() == 0) {\n+                final String trim = s3.trim();\n+                if (trim.length() == 0) {\n                     continue;\n                 }\n-                if (line.startsWith(\"#include\")) {\n-                    final String incl = line.substring(\"#include\".length()).trim();\n-                    if (incl.contains(\" \")) {\n-                        throw new IllegalArgumentException(\"Malformed import statement '\" + rawLine + \"' in \" + location);\n+                if (trim.startsWith(\"#include\")) {\n+                    final String trim2 = trim.substring(\"#include\".length()).trim();\n+                    if (trim2.contains(\" \")) {\n+                        throw new IllegalArgumentException(\"Malformed import statement '\" + s2 + \"' in \" + s);\n                     }\n-                    try (final Scanner hashIncludeScanner = createScanner(incl)) {\n-                        lines.putAll(parseRules(hashIncludeScanner, location + \"->\" + incl));\n+                    try (final Scanner scanner2 = createScanner(trim2)) {\n+                        hashMap.putAll(parseRules(scanner2, s + \"->\" + trim2));\n                     }\n                 }\n                 else {\n-                    final String[] parts = line.split(\"\\\\s+\");\n-                    if (parts.length != 4) {\n-                        throw new IllegalArgumentException(\"Malformed rule statement split into \" + parts.length + \" parts: \" + rawLine + \" in \" + location);\n+                    final String[] split = trim.split(\"\\\\s+\");\n+                    if (split.length != 4) {\n+                        throw new IllegalArgumentException(\"Malformed rule statement split into \" + split.length + \" parts: \" + s2 + \" in \" + s);\n                     }\n                     try {\n-                        final String pat = stripQuotes(parts[0]);\n-                        final String lCon = stripQuotes(parts[1]);\n-                        final String rCon = stripQuotes(parts[2]);\n-                        final Rule.PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3]));\n-                        final int cLine = currentLine;\n-                        final Rule r = (Rule)new Rule.Rule$2(pat, lCon, rCon, ph, cLine, location, pat, lCon, rCon);\n-                        final String patternKey = r.pattern.substring(0, 1);\n-                        List<Rule> rules = (List<Rule>)lines.get(patternKey);\n-                        if (rules == null) {\n-                            rules = new ArrayList<Rule>();\n-                            lines.put(patternKey, rules);\n+                        final String stripQuotes = stripQuotes(split[0]);\n+                        final String stripQuotes2 = stripQuotes(split[1]);\n+                        final String stripQuotes3 = stripQuotes(split[2]);\n+                        final Rule.Rule$2 rule$2 = new Rule.Rule$2(stripQuotes, stripQuotes2, stripQuotes3, parsePhonemeExpr(stripQuotes(split[3])), i, s, stripQuotes, stripQuotes2, stripQuotes3);\n+                        final String substring = ((Rule)rule$2).pattern.substring(0, 1);\n+                        List list = (List)hashMap.get(substring);\n+                        if (list == null) {\n+                            list = new ArrayList();\n+                            hashMap.put(substring, list);\n                         }\n-                        rules.add(r);\n+                        list.add(rule$2);\n                     }\n-                    catch (final IllegalArgumentException e) {\n-                        throw new IllegalStateException(\"Problem parsing line '\" + currentLine + \"' in \" + location, e);\n+                    catch (final IllegalArgumentException cause) {\n+                        throw new IllegalStateException(\"Problem parsing line '\" + i + \"' in \" + s, cause);\n                     }\n                 }\n             }\n         }\n-        return lines;\n+        return hashMap;\n     }\n     \n-    private static Rule.RPattern pattern(final String regex) {\n-        final boolean startsWith = regex.startsWith(\"^\");\n-        final boolean endsWith = regex.endsWith(\"$\");\n-        final String content = regex.substring(startsWith ? 1 : 0, endsWith ? (regex.length() - 1) : regex.length());\n-        final boolean boxes = content.contains(\"[\");\n-        if (!boxes) {\n+    private static Rule.RPattern pattern(final String s) {\n+        final int startsWith = s.startsWith(\"^\") ? 1 : 0;\n+        final boolean endsWith = s.endsWith(\"$\");\n+        final String substring = s.substring(startsWith, endsWith ? (s.length() - 1) : s.length());\n+        if (!substring.contains(\"[\")) {\n             if (startsWith && endsWith) {\n-                if (content.length() == 0) {\n+                if (substring.length() == 0) {\n                     return (Rule.RPattern)new Rule.Rule$3();\n                 }\n-                return (Rule.RPattern)new Rule.Rule$4(content);\n+                return (Rule.RPattern)new Rule.Rule$4(substring);\n             }\n             else {\n-                if ((startsWith || endsWith) && content.length() == 0) {\n+                if ((startsWith || endsWith) && substring.length() == 0) {\n                     return Rule.ALL_STRINGS_RMATCHER;\n                 }\n-                if (startsWith) {\n-                    return (Rule.RPattern)new Rule.Rule$5(content);\n+                if (startsWith != 0) {\n+                    return (Rule.RPattern)new Rule.Rule$5(substring);\n                 }\n                 if (endsWith) {\n-                    return (Rule.RPattern)new Rule.Rule$6(content);\n+                    return (Rule.RPattern)new Rule.Rule$6(substring);\n                 }\n             }\n         }\n         else {\n-            final boolean startsWithBox = content.startsWith(\"[\");\n-            final boolean endsWithBox = content.endsWith(\"]\");\n-            if (startsWithBox && endsWithBox) {\n-                String boxContent = content.substring(1, content.length() - 1);\n-                if (!boxContent.contains(\"[\")) {\n-                    final boolean negate = boxContent.startsWith(\"^\");\n-                    if (negate) {\n-                        boxContent = boxContent.substring(1);\n+            final boolean startsWith2 = substring.startsWith(\"[\");\n+            final boolean endsWith2 = substring.endsWith(\"]\");\n+            if (startsWith2 && endsWith2) {\n+                String s2 = substring.substring(1, substring.length() - 1);\n+                if (!s2.contains(\"[\")) {\n+                    final boolean startsWith3 = s2.startsWith(\"^\");\n+                    if (startsWith3) {\n+                        s2 = s2.substring(1);\n                     }\n-                    final String bContent = boxContent;\n-                    final boolean shouldMatch = !negate;\n+                    final String s3 = s2;\n+                    final boolean b = !startsWith3;\n                     if (startsWith && endsWith) {\n-                        return (Rule.RPattern)new Rule.Rule$7(bContent, shouldMatch);\n+                        return (Rule.RPattern)new Rule.Rule$7(s3, b);\n                     }\n-                    if (startsWith) {\n-                        return (Rule.RPattern)new Rule.Rule$8(bContent, shouldMatch);\n+                    if (startsWith != 0) {\n+                        return (Rule.RPattern)new Rule.Rule$8(s3, b);\n                     }\n                     if (endsWith) {\n-                        return (Rule.RPattern)new Rule.Rule$9(bContent, shouldMatch);\n+                        return (Rule.RPattern)new Rule.Rule$9(s3, b);\n                     }\n                 }\n             }\n         }\n-        return (Rule.RPattern)new Rule.Rule$10(regex);\n+        return (Rule.RPattern)new Rule.Rule$10(s);\n     }\n     \n-    private static boolean startsWith(final CharSequence input, final CharSequence prefix) {\n-        if (prefix.length() > input.length()) {\n+    private static boolean startsWith(final CharSequence charSequence, final CharSequence charSequence2) {\n+        if (charSequence2.length() > charSequence.length()) {\n             return false;\n         }\n-        for (int i = 0; i < prefix.length(); ++i) {\n-            if (input.charAt(i) != prefix.charAt(i)) {\n+        for (int i = 0; i < charSequence2.length(); ++i) {\n+            if (charSequence.charAt(i) != charSequence2.charAt(i)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    private static String stripQuotes(String str) {\n-        if (str.startsWith(\"\\\"\")) {\n-            str = str.substring(1);\n+    private static String stripQuotes(String s) {\n+        if (s.startsWith(\"\\\"\")) {\n+            s = s.substring(1);\n         }\n-        if (str.endsWith(\"\\\"\")) {\n-            str = str.substring(0, str.length() - 1);\n+        if (s.endsWith(\"\\\"\")) {\n+            s = s.substring(0, s.length() - 1);\n         }\n-        return str;\n+        return s;\n     }\n     \n-    public Rule(final String pattern, final String lContext, final String rContext, final Rule.PhonemeExpr phoneme) {\n+    public Rule(final String pattern, final String str, final String str2, final Rule.PhonemeExpr phoneme) {\n         this.pattern = pattern;\n-        this.lContext = pattern(lContext + \"$\");\n-        this.rContext = pattern(\"^\" + rContext);\n+        this.lContext = pattern(str + \"$\");\n+        this.rContext = pattern(\"^\" + str2);\n         this.phoneme = phoneme;\n     }\n     \n     public Rule.RPattern getLContext() {\n         return this.lContext;\n     }\n     \n@@ -285,43 +281,41 @@\n         return this.phoneme;\n     }\n     \n     public Rule.RPattern getRContext() {\n         return this.rContext;\n     }\n     \n-    public boolean patternAndContextMatches(final CharSequence input, final int i) {\n-        if (i < 0) {\n+    public boolean patternAndContextMatches(final CharSequence charSequence, final int n) {\n+        if (n < 0) {\n             throw new IndexOutOfBoundsException(\"Can not match pattern at negative indexes\");\n         }\n-        final int patternLength = this.pattern.length();\n-        final int ipl = i + patternLength;\n-        return ipl <= input.length() && input.subSequence(i, ipl).equals(this.pattern) && this.rContext.isMatch(input.subSequence(ipl, input.length())) && this.lContext.isMatch(input.subSequence(0, i));\n+        final int n2 = n + this.pattern.length();\n+        return n2 <= charSequence.length() && charSequence.subSequence(n, n2).equals(this.pattern) && this.rContext.isMatch(charSequence.subSequence(n2, charSequence.length())) && this.lContext.isMatch(charSequence.subSequence(0, n));\n     }\n     \n     static {\n         ALL_STRINGS_RMATCHER = (Rule.RPattern)new Rule.Rule$1();\n         RULES = new EnumMap<NameType, Map<RuleType, Map<String, Map<String, List<Rule>>>>>(NameType.class);\n-        for (final NameType s : NameType.values()) {\n-            final Map<RuleType, Map<String, Map<String, List<Rule>>>> rts = new EnumMap<RuleType, Map<String, Map<String, List<Rule>>>>(RuleType.class);\n-            for (final RuleType rt : RuleType.values()) {\n-                final Map<String, Map<String, List<Rule>>> rs = new HashMap<String, Map<String, List<Rule>>>();\n-                final Languages ls = Languages.getInstance(s);\n-                for (final String l : ls.getLanguages()) {\n-                    try (final Scanner scanner = createScanner(s, rt, l)) {\n-                        rs.put(l, parseRules(scanner, createResourceName(s, rt, l)));\n+        for (final NameType nameType : NameType.values()) {\n+            final EnumMap m = new EnumMap(RuleType.class);\n+            for (final RuleType ruleType : RuleType.values()) {\n+                final HashMap k = new HashMap();\n+                for (final String s : Languages.getInstance(nameType).getLanguages()) {\n+                    try (final Scanner scanner = createScanner(nameType, ruleType, s)) {\n+                        k.put(s, parseRules(scanner, createResourceName(nameType, ruleType, s)));\n                     }\n-                    catch (final IllegalStateException e) {\n-                        throw new IllegalStateException(\"Problem processing \" + createResourceName(s, rt, l), e);\n+                    catch (final IllegalStateException cause) {\n+                        throw new IllegalStateException(\"Problem processing \" + createResourceName(nameType, ruleType, s), cause);\n                     }\n                 }\n-                if (!rt.equals((Object)RuleType.RULES)) {\n-                    try (final Scanner scanner2 = createScanner(s, rt, \"common\")) {\n-                        rs.put(\"common\", parseRules(scanner2, createResourceName(s, rt, \"common\")));\n+                if (!ruleType.equals((Object)RuleType.RULES)) {\n+                    try (final Scanner scanner2 = createScanner(nameType, ruleType, \"common\")) {\n+                        k.put(\"common\", parseRules(scanner2, createResourceName(nameType, ruleType, \"common\")));\n                     }\n                 }\n-                rts.put(rt, Collections.unmodifiableMap((Map<? extends String, ? extends Map<String, List<Rule>>>)rs));\n+                m.put(ruleType, Collections.unmodifiableMap((Map<?, ?>)k));\n             }\n-            Rule.RULES.put(s, Collections.unmodifiableMap((Map<? extends RuleType, ? extends Map<String, Map<String, List<Rule>>>>)rts));\n+            Rule.RULES.put(nameType, (Map<RuleType, Map<String, Map<String, List<Rule>>>>)Collections.unmodifiableMap((Map<?, ?>)m));\n         }\n     }\n }\n"}]}
