{"diffoscope-json-version": 1, "source1": "first/PropertiesConfiguration.class", "source2": "second/PropertiesConfiguration.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,15 +1,14 @@\n \n package org.apache.commons.configuration2;\n \n import java.io.Writer;\n import java.io.IOException;\n import java.io.Reader;\n import java.util.Iterator;\n-import java.util.Collection;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.configuration2.io.FileLocatorUtils;\n import org.apache.commons.configuration2.io.FileBased;\n import org.apache.commons.configuration2.io.FileHandler;\n import java.io.FileNotFoundException;\n import java.net.URL;\n import java.util.Deque;\n@@ -42,134 +41,133 @@\n     private boolean includesAllowed;\n     \n     public PropertiesConfiguration() {\n         this.includesAllowed = true;\n         this.installLayout(this.createLayout());\n     }\n     \n-    private static int countTrailingBS(final String line) {\n-        int bsCount = 0;\n-        for (int idx = line.length() - 1; idx >= 0 && line.charAt(idx) == '\\\\'; --idx) {\n-            ++bsCount;\n+    private static int countTrailingBS(final String s) {\n+        int n = 0;\n+        for (int index = s.length() - 1; index >= 0 && s.charAt(index) == '\\\\'; --index) {\n+            ++n;\n         }\n-        return bsCount;\n+        return n;\n     }\n     \n     public static String getInclude() {\n         return PropertiesConfiguration.include;\n     }\n     \n     public static String getIncludeOptional() {\n         return PropertiesConfiguration.includeOptional;\n     }\n     \n-    static boolean isCommentLine(final String line) {\n-        final String s = line.trim();\n-        return s.isEmpty() || \"#!\".indexOf(s.charAt(0)) >= 0;\n+    static boolean isCommentLine(final String s) {\n+        final String trim = s.trim();\n+        return trim.isEmpty() || \"#!\".indexOf(trim.charAt(0)) >= 0;\n     }\n     \n     private static boolean needsUnescape(final char ch) {\n         return \":#=!\\\\'\\\"\".indexOf(ch) >= 0;\n     }\n     \n-    public static void setInclude(final String inc) {\n-        PropertiesConfiguration.include = inc;\n+    public static void setInclude(final String include) {\n+        PropertiesConfiguration.include = include;\n     }\n     \n-    public static void setIncludeOptional(final String inc) {\n-        PropertiesConfiguration.includeOptional = inc;\n+    public static void setIncludeOptional(final String includeOptional) {\n+        PropertiesConfiguration.includeOptional = includeOptional;\n     }\n     \n-    protected static String unescapeJava(final String str) {\n-        return unescapeJava(str, false);\n+    protected static String unescapeJava(final String s) {\n+        return unescapeJava(s, false);\n     }\n     \n-    protected static String unescapeJava(final String str, final boolean jupCompatible) {\n-        if (str == null) {\n+    protected static String unescapeJava(final String s, final boolean b) {\n+        if (s == null) {\n             return null;\n         }\n-        final int sz = str.length();\n-        final StringBuilder out = new StringBuilder(sz);\n-        final StringBuilder unicode = new StringBuilder(4);\n-        boolean hadSlash = false;\n-        boolean inUnicode = false;\n-        for (int i = 0; i < sz; ++i) {\n-            final char ch = str.charAt(i);\n-            if (inUnicode) {\n-                unicode.append(ch);\n-                if (unicode.length() != 4) {\n+        final int length = s.length();\n+        final StringBuilder sb = new StringBuilder(length);\n+        final StringBuilder obj = new StringBuilder(4);\n+        int n = 0;\n+        int n2 = 0;\n+        for (int i = 0; i < length; ++i) {\n+            final char char1 = s.charAt(i);\n+            if (n2 != 0) {\n+                obj.append(char1);\n+                if (obj.length() != 4) {\n                     continue;\n                 }\n                 try {\n-                    final int value = Integer.parseInt(unicode.toString(), 16);\n-                    out.append((char)value);\n-                    unicode.setLength();\n-                    inUnicode = false;\n-                    hadSlash = false;\n+                    sb.append((char)Integer.parseInt(obj.toString(), 16));\n+                    obj.setLength();\n+                    n2 = 0;\n+                    n = 0;\n                     continue;\n                 }\n-                catch (final NumberFormatException nfe) {\n-                    throw new ConfigurationRuntimeException(\"Unable to parse unicode value: \" + (Object)unicode, (Throwable)nfe);\n+                catch (final NumberFormatException ex) {\n+                    throw new ConfigurationRuntimeException(\"Unable to parse unicode value: \" + (Object)obj, (Throwable)ex);\n                 }\n             }\n-            if (hadSlash) {\n-                hadSlash = false;\n-                switch (ch) {\n+            if (n != 0) {\n+                n = 0;\n+                switch (char1) {\n                     case 'r': {\n-                        out.append('\\r');\n+                        sb.append('\\r');\n                         break;\n                     }\n                     case 'f': {\n-                        out.append('\\f');\n+                        sb.append('\\f');\n                         break;\n                     }\n                     case 't': {\n-                        out.append('\\t');\n+                        sb.append('\\t');\n                         break;\n                     }\n                     case 'n': {\n-                        out.append('\\n');\n+                        sb.append('\\n');\n                         break;\n                     }\n                     default: {\n-                        if (!jupCompatible && ch == 'b') {\n-                            out.append('\\b');\n+                        if (!b && char1 == 'b') {\n+                            sb.append('\\b');\n                             break;\n                         }\n-                        if (ch == 'u') {\n-                            inUnicode = true;\n+                        if (char1 == 'u') {\n+                            n2 = 1;\n                             break;\n                         }\n-                        if (!needsUnescape(ch) && !jupCompatible) {\n-                            out.append('\\\\');\n+                        if (!needsUnescape(char1) && !b) {\n+                            sb.append('\\\\');\n                         }\n-                        out.append(ch);\n+                        sb.append(char1);\n                         break;\n                     }\n                 }\n             }\n-            else if (ch == '\\\\') {\n-                hadSlash = true;\n+            else if (char1 == '\\\\') {\n+                n = 1;\n             }\n             else {\n-                out.append(ch);\n+                sb.append(char1);\n             }\n         }\n-        if (hadSlash) {\n-            out.append('\\\\');\n+        if (n != 0) {\n+            sb.append('\\\\');\n         }\n-        return out.toString();\n+        return sb.toString();\n     }\n     \n     public Object clone() {\n-        final PropertiesConfiguration copy = (PropertiesConfiguration)super.clone();\n+        final PropertiesConfiguration propertiesConfiguration = (PropertiesConfiguration)super.clone();\n         if (this.layout != null) {\n-            copy.setLayout(new PropertiesConfigurationLayout(this.layout));\n+            propertiesConfiguration.setLayout(new PropertiesConfigurationLayout(this.layout));\n         }\n-        return copy;\n+        return propertiesConfiguration;\n     }\n     \n     private PropertiesConfigurationLayout createLayout() {\n         return new PropertiesConfigurationLayout();\n     }\n     \n     public String getFooter() {\n@@ -221,106 +219,105 @@\n         this.addEventListener(ConfigurationEvent.ANY, (EventListener)this.layout);\n     }\n     \n     public boolean isIncludesAllowed() {\n         return this.includesAllowed;\n     }\n     \n-    private void loadIncludeFile(final String fileName, final boolean optional, final Deque<URL> seenStack) throws ConfigurationException {\n+    private void loadIncludeFile(final String s, final boolean b, final Deque<URL> deque) throws ConfigurationException {\n         if (this.locator == null) {\n             throw new ConfigurationException(\"Load operation not properly initialized! Do not call read(InputStream) directly, but use a FileHandler to load a configuration.\");\n         }\n-        URL url = this.locateIncludeFile(this.locator.getBasePath(), fileName);\n+        URL url = this.locateIncludeFile(this.locator.getBasePath(), s);\n         if (url == null) {\n-            final URL baseURL = this.locator.getSourceURL();\n-            if (baseURL != null) {\n-                url = this.locateIncludeFile(baseURL.toString(), fileName);\n+            final URL sourceURL = this.locator.getSourceURL();\n+            if (sourceURL != null) {\n+                url = this.locateIncludeFile(sourceURL.toString(), s);\n             }\n         }\n-        if (optional && url == null) {\n+        if (b && url == null) {\n             return;\n         }\n         if (url == null) {\n-            this.getIncludeListener().accept((Object)new ConfigurationException(\"Cannot resolve include file \" + fileName, (Throwable)new FileNotFoundException(fileName)));\n+            this.getIncludeListener().accept((Object)new ConfigurationException(\"Cannot resolve include file \" + s, (Throwable)new FileNotFoundException(s)));\n         }\n         else {\n-            final FileHandler fh = new FileHandler((FileBased)this);\n-            fh.setFileLocator(this.locator);\n-            final FileLocator orgLocator = this.locator;\n+            final FileHandler fileHandler = new FileHandler((FileBased)this);\n+            fileHandler.setFileLocator(this.locator);\n+            final FileLocator locator = this.locator;\n             try {\n-                if (seenStack.contains(url)) {\n-                    throw new ConfigurationException(String.format(\"Cycle detected loading %s, seen stack: %s\", url, seenStack));\n+                if (deque.contains(url)) {\n+                    throw new ConfigurationException(String.format(\"Cycle detected loading %s, seen stack: %s\", url, deque));\n                 }\n-                seenStack.add(url);\n+                deque.add(url);\n                 try {\n-                    fh.load(url);\n+                    fileHandler.load(url);\n                 }\n                 finally {\n-                    seenStack.pop();\n+                    deque.pop();\n                 }\n             }\n-            catch (final ConfigurationException e) {\n-                this.getIncludeListener().accept((Object)e);\n+            catch (final ConfigurationException ex) {\n+                this.getIncludeListener().accept((Object)ex);\n             }\n             finally {\n-                this.locator = orgLocator;\n+                this.locator = locator;\n             }\n         }\n     }\n     \n-    private URL locateIncludeFile(final String basePath, final String fileName) {\n-        final FileLocator includeLocator = FileLocatorUtils.fileLocator(this.locator).sourceURL((URL)null).basePath(basePath).fileName(fileName).create();\n-        return FileLocatorUtils.locate(includeLocator);\n+    private URL locateIncludeFile(final String s, final String s2) {\n+        return FileLocatorUtils.locate(FileLocatorUtils.fileLocator(this.locator).sourceURL((URL)null).basePath(s).fileName(s2).create());\n     }\n     \n-    boolean propertyLoaded(final String key, final String value, final Deque<URL> seenStack) throws ConfigurationException {\n-        boolean result;\n-        if (StringUtils.isNotEmpty((CharSequence)getInclude()) && key.equalsIgnoreCase(getInclude())) {\n+    boolean propertyLoaded(final String s, final String s2, final Deque<URL> deque) throws ConfigurationException {\n+        boolean b;\n+        if (StringUtils.isNotEmpty((CharSequence)getInclude()) && s.equalsIgnoreCase(getInclude())) {\n             if (this.isIncludesAllowed()) {\n-                final Collection<String> files = this.getListDelimiterHandler().split(value, true);\n-                for (final String f : files) {\n-                    this.loadIncludeFile(this.interpolate(f), false, seenStack);\n+                final Iterator iterator = this.getListDelimiterHandler().split(s2, true).iterator();\n+                while (iterator.hasNext()) {\n+                    this.loadIncludeFile(this.interpolate((String)iterator.next()), false, deque);\n                 }\n             }\n-            result = false;\n+            b = false;\n         }\n-        else if (StringUtils.isNotEmpty((CharSequence)getIncludeOptional()) && key.equalsIgnoreCase(getIncludeOptional())) {\n+        else if (StringUtils.isNotEmpty((CharSequence)getIncludeOptional()) && s.equalsIgnoreCase(getIncludeOptional())) {\n             if (this.isIncludesAllowed()) {\n-                final Collection<String> files = this.getListDelimiterHandler().split(value, true);\n-                for (final String f : files) {\n-                    this.loadIncludeFile(this.interpolate(f), true, seenStack);\n+                final Iterator iterator2 = this.getListDelimiterHandler().split(s2, true).iterator();\n+                while (iterator2.hasNext()) {\n+                    this.loadIncludeFile(this.interpolate((String)iterator2.next()), true, deque);\n                 }\n             }\n-            result = false;\n+            b = false;\n         }\n         else {\n-            this.addPropertyInternal(key, (Object)value);\n-            result = true;\n+            this.addPropertyInternal(s, (Object)s2);\n+            b = true;\n         }\n-        return result;\n+        return b;\n     }\n     \n-    public void read(final Reader in) throws ConfigurationException, IOException {\n-        this.getLayout().load(this, in);\n+    public void read(final Reader reader) throws ConfigurationException, IOException {\n+        this.getLayout().load(this, reader);\n     }\n     \n-    public void setFooter(final String footer) {\n+    public void setFooter(final String footerComment) {\n         this.beginWrite(false);\n         try {\n-            this.getLayout().setFooterComment(footer);\n+            this.getLayout().setFooterComment(footerComment);\n         }\n         finally {\n             this.endWrite();\n         }\n     }\n     \n-    public void setHeader(final String header) {\n+    public void setHeader(final String headerComment) {\n         this.beginWrite(false);\n         try {\n-            this.getLayout().setHeaderComment(header);\n+            this.getLayout().setHeaderComment(headerComment);\n         }\n         finally {\n             this.endWrite();\n         }\n     }\n     \n     public void setIncludeListener(final ConfigurationConsumer<ConfigurationException> includeListener) {\n@@ -337,27 +334,27 @@\n     public void setIOFactory(final PropertiesConfiguration.IOFactory ioFactory) {\n         if (ioFactory == null) {\n             throw new IllegalArgumentException(\"IOFactory must not be null.\");\n         }\n         this.ioFactory = ioFactory;\n     }\n     \n-    public void setLayout(final PropertiesConfigurationLayout layout) {\n-        this.installLayout(layout);\n+    public void setLayout(final PropertiesConfigurationLayout propertiesConfigurationLayout) {\n+        this.installLayout(propertiesConfigurationLayout);\n     }\n     \n-    public void write(final Writer out) throws ConfigurationException, IOException {\n-        this.getLayout().save(this, out);\n+    public void write(final Writer writer) throws ConfigurationException, IOException {\n+        this.getLayout().save(this, writer);\n     }\n     \n     static {\n-        DEFAULT_INCLUDE_LISTENER = (e -> {\n-            throw e;\n+        DEFAULT_INCLUDE_LISTENER = (ex -> {\n+            throw ex;\n         });\n-        NOOP_INCLUDE_LISTENER = (e -> {});\n+        NOOP_INCLUDE_LISTENER = (ex -> {});\n         PropertiesConfiguration.include = \"include\";\n         PropertiesConfiguration.includeOptional = \"includeoptional\";\n         SEPARATORS = new char[] { '=', ':' };\n         WHITE_SPACE = new char[] { ' ', '\\t', '\\f' };\n         LINE_SEPARATOR = System.lineSeparator();\n     }\n }\n"}]}
