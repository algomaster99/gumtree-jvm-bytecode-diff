{"diffoscope-json-version": 1, "source1": "first/AbstractYAMLBasedConfiguration.class", "source2": "second/AbstractYAMLBasedConfiguration.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,92 +1,90 @@\n \n package org.apache.commons.configuration2;\n \n import org.apache.commons.configuration2.ex.ConfigurationException;\n import java.util.Collections;\n-import java.util.ArrayList;\n+import java.util.List;\n import java.util.Collection;\n+import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.HashMap;\n-import java.util.List;\n import java.util.Map;\n import org.apache.commons.configuration2.tree.ImmutableNode;\n import org.apache.commons.configuration2.io.ConfigurationLogger;\n \n public class AbstractYAMLBasedConfiguration extends BaseHierarchicalConfiguration\n {\n     protected AbstractYAMLBasedConfiguration() {\n         this.initLogger(new ConfigurationLogger((Class)this.getClass()));\n     }\n     \n-    protected AbstractYAMLBasedConfiguration(final HierarchicalConfiguration<ImmutableNode> c) {\n-        super((HierarchicalConfiguration)c);\n+    protected AbstractYAMLBasedConfiguration(final HierarchicalConfiguration<ImmutableNode> hierarchicalConfiguration) {\n+        super((HierarchicalConfiguration)hierarchicalConfiguration);\n         this.initLogger(new ConfigurationLogger((Class)this.getClass()));\n     }\n     \n     protected void load(final Map<String, Object> map) {\n-        final List<ImmutableNode> roots = constructHierarchy(\"\", map);\n-        this.getNodeModel().setRootNode((ImmutableNode)roots.get(0));\n+        this.getNodeModel().setRootNode((ImmutableNode)constructHierarchy(\"\", map).get(0));\n     }\n     \n-    protected Map<String, Object> constructMap(final ImmutableNode node) {\n-        final Map<String, Object> map = new HashMap<String, Object>(node.getChildren().size());\n-        for (final ImmutableNode cNode : node.getChildren()) {\n-            final Object value = cNode.getChildren().isEmpty() ? cNode.getValue() : this.constructMap(cNode);\n-            addEntry(map, cNode.getNodeName(), value);\n+    protected Map<String, Object> constructMap(final ImmutableNode immutableNode) {\n+        final HashMap hashMap = new HashMap(immutableNode.getChildren().size());\n+        for (final ImmutableNode immutableNode2 : immutableNode.getChildren()) {\n+            addEntry(hashMap, immutableNode2.getNodeName(), immutableNode2.getChildren().isEmpty() ? immutableNode2.getValue() : this.constructMap(immutableNode2));\n         }\n-        return map;\n+        return hashMap;\n     }\n     \n-    private static void addEntry(final Map<String, Object> map, final String key, final Object value) {\n-        final Object oldValue = map.get(key);\n-        if (oldValue == null) {\n-            map.put(key, value);\n+    private static void addEntry(final Map<String, Object> map, final String s, final Object o) {\n+        final Collection value = map.get(s);\n+        if (value == null) {\n+            map.put(s, o);\n         }\n-        else if (oldValue instanceof Collection) {\n-            final Collection<Object> values = (Collection)oldValue;\n-            values.add(value);\n+        else if (value instanceof Collection) {\n+            ((Collection)value).add(o);\n         }\n         else {\n-            final Collection<Object> values = new ArrayList<Object>();\n-            values.add(oldValue);\n-            values.add(value);\n-            map.put(key, values);\n+            final ArrayList list = new ArrayList();\n+            list.add(value);\n+            list.add(o);\n+            map.put(s, list);\n         }\n     }\n     \n-    private static List<ImmutableNode> constructHierarchy(final String key, final Object elem) {\n-        if (elem instanceof Map) {\n-            return parseMap((Map<String, Object>)elem, key);\n+    private static List<ImmutableNode> constructHierarchy(final String s, final Object o) {\n+        if (o instanceof Map) {\n+            return parseMap((Map<String, Object>)o, s);\n         }\n-        if (elem instanceof Collection) {\n-            return parseCollection((Collection<Object>)elem, key);\n+        if (o instanceof Collection) {\n+            return parseCollection((Collection<Object>)o, s);\n         }\n-        return Collections.singletonList(new ImmutableNode.Builder().name(key).value(elem).create());\n+        return Collections.singletonList(new ImmutableNode.Builder().name(s).value(o).create());\n     }\n     \n-    private static List<ImmutableNode> parseMap(final Map<String, Object> map, final String key) {\n-        final ImmutableNode.Builder subtree = new ImmutableNode.Builder().name(key);\n-        for (final Map.Entry<String, Object> entry : map.entrySet()) {\n-            final List<ImmutableNode> children = constructHierarchy(entry.getKey(), entry.getValue());\n-            for (final ImmutableNode child : children) {\n-                subtree.addChild(child);\n+    private static List<ImmutableNode> parseMap(final Map<String, Object> map, final String s) {\n+        final ImmutableNode.Builder name = new ImmutableNode.Builder().name(s);\n+        for (final Map.Entry entry : map.entrySet()) {\n+            final Iterator<ImmutableNode> iterator2 = constructHierarchy((String)entry.getKey(), entry.getValue()).iterator();\n+            while (iterator2.hasNext()) {\n+                name.addChild((ImmutableNode)iterator2.next());\n             }\n         }\n-        return Collections.singletonList(subtree.create());\n+        return Collections.singletonList(name.create());\n     }\n     \n-    private static List<ImmutableNode> parseCollection(final Collection<Object> col, final String key) {\n-        final List<ImmutableNode> nodes = new ArrayList<ImmutableNode>(col.size());\n-        for (final Object elem : col) {\n-            nodes.addAll(constructHierarchy(key, elem));\n+    private static List<ImmutableNode> parseCollection(final Collection<Object> collection, final String s) {\n+        final ArrayList list = new ArrayList(collection.size());\n+        final Iterator iterator = collection.iterator();\n+        while (iterator.hasNext()) {\n+            list.addAll(constructHierarchy(s, iterator.next()));\n         }\n-        return nodes;\n+        return list;\n     }\n     \n-    static void rethrowException(final Exception e) throws ConfigurationException {\n-        if (e instanceof ClassCastException) {\n-            throw new ConfigurationException(\"Error parsing\", (Throwable)e);\n+    static void rethrowException(final Exception ex) throws ConfigurationException {\n+        if (ex instanceof ClassCastException) {\n+            throw new ConfigurationException(\"Error parsing\", (Throwable)ex);\n         }\n-        throw new ConfigurationException(\"Unable to load the configuration\", (Throwable)e);\n+        throw new ConfigurationException(\"Unable to load the configuration\", (Throwable)ex);\n     }\n }\n"}]}
