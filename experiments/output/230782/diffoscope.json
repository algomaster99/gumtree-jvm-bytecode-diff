{"diffoscope-json-version": 1, "source1": "first/NioZipEncoding.class", "source2": "second/NioZipEncoding.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,17 +1,17 @@\n \n package org.apache.commons.compress.archivers.zip;\n \n import java.nio.charset.CharsetDecoder;\n import java.nio.charset.CodingErrorAction;\n import java.io.IOException;\n import java.nio.charset.CoderResult;\n+import java.nio.charset.CharsetEncoder;\n import java.nio.CharBuffer;\n import java.nio.ByteBuffer;\n-import java.nio.charset.CharsetEncoder;\n import java.nio.charset.Charset;\n \n class NioZipEncoding implements ZipEncoding, CharsetAccessor\n {\n     private final Charset charset;\n     private final boolean useReplacement;\n     private static final char REPLACEMENT = '?';\n@@ -24,89 +24,83 @@\n         this.useReplacement = useReplacement;\n     }\n     \n     public Charset getCharset() {\n         return this.charset;\n     }\n     \n-    public boolean canEncode(final String name) {\n-        final CharsetEncoder enc = this.newEncoder();\n-        return enc.canEncode(name);\n-    }\n-    \n-    public ByteBuffer encode(final String name) {\n-        final CharsetEncoder enc = this.newEncoder();\n-        final CharBuffer cb = CharBuffer.wrap(name);\n-        CharBuffer tmp = null;\n-        ByteBuffer out = ByteBuffer.allocate(estimateInitialBufferSize(enc, cb.remaining()));\n-        while (cb.hasRemaining()) {\n-            final CoderResult res = enc.encode(cb, out, false);\n-            if (res.isUnmappable() || res.isMalformed()) {\n-                final int spaceForSurrogate = estimateIncrementalEncodingSize(enc, 6 * res.length());\n-                if (spaceForSurrogate > out.remaining()) {\n-                    int charCount = 0;\n-                    for (int i = cb.position(); i < cb.limit(); ++i) {\n-                        charCount += (enc.canEncode(cb.get(i)) ? 1 : 6);\n+    public boolean canEncode(final String cs) {\n+        return this.newEncoder().canEncode(cs);\n+    }\n+    \n+    public ByteBuffer encode(final String csq) {\n+        final CharsetEncoder encoder = this.newEncoder();\n+        final CharBuffer wrap = CharBuffer.wrap(csq);\n+        CharBuffer allocate = null;\n+        ByteBuffer byteBuffer = ByteBuffer.allocate(estimateInitialBufferSize(encoder, wrap.remaining()));\n+        while (wrap.hasRemaining()) {\n+            final CoderResult encode = encoder.encode(wrap, byteBuffer, false);\n+            if (encode.isUnmappable() || encode.isMalformed()) {\n+                if (estimateIncrementalEncodingSize(encoder, 6 * encode.length()) > byteBuffer.remaining()) {\n+                    int n = 0;\n+                    for (int i = wrap.position(); i < wrap.limit(); ++i) {\n+                        n += (encoder.canEncode(wrap.get(i)) ? 1 : 6);\n                     }\n-                    final int totalExtraSpace = estimateIncrementalEncodingSize(enc, charCount);\n-                    out = ZipEncodingHelper.growBufferBy(out, totalExtraSpace - out.remaining());\n+                    byteBuffer = ZipEncodingHelper.growBufferBy(byteBuffer, estimateIncrementalEncodingSize(encoder, n) - byteBuffer.remaining());\n                 }\n-                if (tmp == null) {\n-                    tmp = CharBuffer.allocate(6);\n+                if (allocate == null) {\n+                    allocate = CharBuffer.allocate(6);\n                 }\n-                for (int j = 0; j < res.length(); ++j) {\n-                    out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out);\n+                for (int j = 0; j < encode.length(); ++j) {\n+                    byteBuffer = encodeFully(encoder, encodeSurrogate(allocate, wrap.get()), byteBuffer);\n                 }\n             }\n-            else if (res.isOverflow()) {\n-                final int increment = estimateIncrementalEncodingSize(enc, cb.remaining());\n-                out = ZipEncodingHelper.growBufferBy(out, increment);\n+            else if (encode.isOverflow()) {\n+                byteBuffer = ZipEncodingHelper.growBufferBy(byteBuffer, estimateIncrementalEncodingSize(encoder, wrap.remaining()));\n             }\n             else {\n-                if (res.isUnderflow()) {\n+                if (encode.isUnderflow()) {\n                     break;\n                 }\n-                if (res.isError()) {\n+                if (encode.isError()) {\n                     break;\n                 }\n                 continue;\n             }\n         }\n-        enc.encode(cb, out, true);\n-        out.limit();\n-        out.rewind();\n-        return out;\n-    }\n-    \n-    public String decode(final byte[] data) throws IOException {\n-        return this.newDecoder().decode(ByteBuffer.wrap(data)).toString();\n-    }\n-    \n-    private static ByteBuffer encodeFully(final CharsetEncoder enc, final CharBuffer cb, final ByteBuffer out) {\n-        ByteBuffer o = out;\n-        while (cb.hasRemaining()) {\n-            final CoderResult result = enc.encode(cb, o, false);\n-            if (result.isOverflow()) {\n-                final int increment = estimateIncrementalEncodingSize(enc, cb.remaining());\n-                o = ZipEncodingHelper.growBufferBy(o, increment);\n+        encoder.encode(wrap, byteBuffer, true);\n+        byteBuffer.limit();\n+        byteBuffer.rewind();\n+        return byteBuffer;\n+    }\n+    \n+    public String decode(final byte[] array) throws IOException {\n+        return this.newDecoder().decode(ByteBuffer.wrap(array)).toString();\n+    }\n+    \n+    private static ByteBuffer encodeFully(final CharsetEncoder charsetEncoder, final CharBuffer in, final ByteBuffer byteBuffer) {\n+        ByteBuffer growBufferBy = byteBuffer;\n+        while (in.hasRemaining()) {\n+            if (charsetEncoder.encode(in, growBufferBy, false).isOverflow()) {\n+                growBufferBy = ZipEncodingHelper.growBufferBy(growBufferBy, estimateIncrementalEncodingSize(charsetEncoder, in.remaining()));\n             }\n         }\n-        return o;\n+        return growBufferBy;\n     }\n     \n-    private static CharBuffer encodeSurrogate(final CharBuffer cb, final char c) {\n-        cb.position().limit(6);\n-        cb.put('%');\n-        cb.put('U');\n-        cb.put(NioZipEncoding.HEX_CHARS[c >> 12 & 0xF]);\n-        cb.put(NioZipEncoding.HEX_CHARS[c >> 8 & 0xF]);\n-        cb.put(NioZipEncoding.HEX_CHARS[c >> 4 & 0xF]);\n-        cb.put(NioZipEncoding.HEX_CHARS[c & '\\u000f']);\n-        cb.flip();\n-        return cb;\n+    private static CharBuffer encodeSurrogate(final CharBuffer charBuffer, final char c) {\n+        charBuffer.position().limit(6);\n+        charBuffer.put('%');\n+        charBuffer.put('U');\n+        charBuffer.put(NioZipEncoding.HEX_CHARS[c >> 12 & 0xF]);\n+        charBuffer.put(NioZipEncoding.HEX_CHARS[c >> 8 & 0xF]);\n+        charBuffer.put(NioZipEncoding.HEX_CHARS[c >> 4 & 0xF]);\n+        charBuffer.put(NioZipEncoding.HEX_CHARS[c & '\\u000f']);\n+        charBuffer.flip();\n+        return charBuffer;\n     }\n     \n     private CharsetEncoder newEncoder() {\n         if (this.useReplacement) {\n             return this.charset.newEncoder().onMalformedInput(CodingErrorAction.REPLACE).onUnmappableCharacter(CodingErrorAction.REPLACE).replaceWith(NioZipEncoding.REPLACEMENT_BYTES);\n         }\n         return this.charset.newEncoder().onMalformedInput(CodingErrorAction.REPORT).onUnmappableCharacter(CodingErrorAction.REPORT);\n@@ -115,22 +109,20 @@\n     private CharsetDecoder newDecoder() {\n         if (!this.useReplacement) {\n             return this.charset.newDecoder().onMalformedInput(CodingErrorAction.REPORT).onUnmappableCharacter(CodingErrorAction.REPORT);\n         }\n         return this.charset.newDecoder().onMalformedInput(CodingErrorAction.REPLACE).onUnmappableCharacter(CodingErrorAction.REPLACE).replaceWith(NioZipEncoding.REPLACEMENT_STRING);\n     }\n     \n-    private static int estimateInitialBufferSize(final CharsetEncoder enc, final int charChount) {\n-        final float first = enc.maxBytesPerChar();\n-        final float rest = (charChount - 1) * enc.averageBytesPerChar();\n-        return (int)Math.ceil(first + rest);\n+    private static int estimateInitialBufferSize(final CharsetEncoder charsetEncoder, final int n) {\n+        return (int)Math.ceil(charsetEncoder.maxBytesPerChar() + (n - 1) * charsetEncoder.averageBytesPerChar());\n     }\n     \n-    private static int estimateIncrementalEncodingSize(final CharsetEncoder enc, final int charCount) {\n-        return (int)Math.ceil(charCount * enc.averageBytesPerChar());\n+    private static int estimateIncrementalEncodingSize(final CharsetEncoder charsetEncoder, final int n) {\n+        return (int)Math.ceil(n * charsetEncoder.averageBytesPerChar());\n     }\n     \n     static {\n         REPLACEMENT_BYTES = new byte[] { 63 };\n         REPLACEMENT_STRING = String.valueOf('?');\n         HEX_CHARS = new char[] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n     }\n"}]}
