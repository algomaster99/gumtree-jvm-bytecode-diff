{"diffoscope-json-version": 1, "source1": "first/VisibilityModifierCheck.class", "source2": "second/VisibilityModifierCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -44,295 +44,281 @@\n     \n     public VisibilityModifierCheck() {\n         this.publicMemberPattern = Pattern.compile(\"^serialVersionUID$\");\n         this.ignoreAnnotationCanonicalNames = VisibilityModifierCheck.DEFAULT_IGNORE_ANNOTATIONS;\n         this.immutableClassCanonicalNames = VisibilityModifierCheck.DEFAULT_IMMUTABLE_TYPES;\n     }\n     \n-    public void setIgnoreAnnotationCanonicalNames(final String... annotationNames) {\n-        this.ignoreAnnotationCanonicalNames = Set.of(annotationNames);\n+    public void setIgnoreAnnotationCanonicalNames(final String... elements) {\n+        this.ignoreAnnotationCanonicalNames = Set.of(elements);\n     }\n     \n     public void setProtectedAllowed(final boolean protectedAllowed) {\n         this.protectedAllowed = protectedAllowed;\n     }\n     \n     public void setPackageAllowed(final boolean packageAllowed) {\n         this.packageAllowed = packageAllowed;\n     }\n     \n-    public void setPublicMemberPattern(final Pattern pattern) {\n-        this.publicMemberPattern = pattern;\n+    public void setPublicMemberPattern(final Pattern publicMemberPattern) {\n+        this.publicMemberPattern = publicMemberPattern;\n     }\n     \n-    public void setAllowPublicImmutableFields(final boolean allow) {\n-        this.allowPublicImmutableFields = allow;\n+    public void setAllowPublicImmutableFields(final boolean allowPublicImmutableFields) {\n+        this.allowPublicImmutableFields = allowPublicImmutableFields;\n     }\n     \n-    public void setAllowPublicFinalFields(final boolean allow) {\n-        this.allowPublicFinalFields = allow;\n+    public void setAllowPublicFinalFields(final boolean allowPublicFinalFields) {\n+        this.allowPublicFinalFields = allowPublicFinalFields;\n     }\n     \n-    public void setImmutableClassCanonicalNames(final String... classNames) {\n-        this.immutableClassCanonicalNames = Set.of(classNames);\n+    public void setImmutableClassCanonicalNames(final String... elements) {\n+        this.immutableClassCanonicalNames = Set.of(elements);\n     }\n     \n     public int[] getDefaultTokens() {\n         return this.getRequiredTokens();\n     }\n     \n     public int[] getAcceptableTokens() {\n         return this.getRequiredTokens();\n     }\n     \n     public int[] getRequiredTokens() {\n         return new int[] { 10, 30 };\n     }\n     \n-    public void beginTree(final DetailAST rootAst) {\n+    public void beginTree(final DetailAST detailAST) {\n         this.immutableClassShortNames = getClassShortNames(this.immutableClassCanonicalNames);\n         this.ignoreAnnotationShortNames = getClassShortNames(this.ignoreAnnotationCanonicalNames);\n     }\n     \n-    public void visitToken(final DetailAST ast) {\n-        switch (ast.getType()) {\n+    public void visitToken(final DetailAST detailAST) {\n+        switch (detailAST.getType()) {\n             case 10: {\n-                if (!isAnonymousClassVariable(ast)) {\n-                    this.visitVariableDef(ast);\n+                if (!isAnonymousClassVariable(detailAST)) {\n+                    this.visitVariableDef(detailAST);\n                     break;\n                 }\n                 break;\n             }\n             case 30: {\n-                this.visitImport(ast);\n+                this.visitImport(detailAST);\n                 break;\n             }\n             default: {\n-                final String exceptionMsg = \"Unexpected token type: \" + ast.getText();\n-                throw new IllegalArgumentException(exceptionMsg);\n+                throw new IllegalArgumentException(\"Unexpected token type: \" + detailAST.getText());\n             }\n         }\n     }\n     \n-    private static boolean isAnonymousClassVariable(final DetailAST variableDef) {\n-        return variableDef.getParent().getType() != 6;\n+    private static boolean isAnonymousClassVariable(final DetailAST detailAST) {\n+        return detailAST.getParent().getType() != 6;\n     }\n     \n-    private void visitVariableDef(final DetailAST variableDef) {\n-        final boolean inInterfaceOrAnnotationBlock = ScopeUtil.isInInterfaceOrAnnotationBlock(variableDef);\n-        if (!inInterfaceOrAnnotationBlock && !this.hasIgnoreAnnotation(variableDef)) {\n-            final DetailAST varNameAST = variableDef.findFirstToken(13).getNextSibling();\n-            final String varName = varNameAST.getText();\n-            if (!this.hasProperAccessModifier(variableDef, varName)) {\n-                this.log(varNameAST, \"variable.notPrivate\", new Object[] { varName });\n+    private void visitVariableDef(final DetailAST detailAST) {\n+        if (!ScopeUtil.isInInterfaceOrAnnotationBlock(detailAST) && !this.hasIgnoreAnnotation(detailAST)) {\n+            final DetailAST nextSibling = detailAST.findFirstToken(13).getNextSibling();\n+            final String text = nextSibling.getText();\n+            if (!this.hasProperAccessModifier(detailAST, text)) {\n+                this.log(nextSibling, \"variable.notPrivate\", new Object[] { text });\n             }\n         }\n     }\n     \n-    private boolean hasIgnoreAnnotation(final DetailAST variableDef) {\n-        final DetailAST firstIgnoreAnnotation = this.findMatchingAnnotation(variableDef);\n-        return firstIgnoreAnnotation != null;\n+    private boolean hasIgnoreAnnotation(final DetailAST detailAST) {\n+        return this.findMatchingAnnotation(detailAST) != null;\n     }\n     \n-    private void visitImport(final DetailAST importAst) {\n-        if (!isStarImport(importAst)) {\n-            final String canonicalName = getCanonicalName(importAst);\n-            final String shortName = getClassShortName(canonicalName);\n+    private void visitImport(final DetailAST detailAST) {\n+        if (!isStarImport(detailAST)) {\n+            final String canonicalName = getCanonicalName(detailAST);\n+            final String classShortName = getClassShortName(canonicalName);\n             if (!this.immutableClassCanonicalNames.contains(canonicalName)) {\n-                this.immutableClassShortNames.remove(shortName);\n+                this.immutableClassShortNames.remove(classShortName);\n             }\n             if (!this.ignoreAnnotationCanonicalNames.contains(canonicalName)) {\n-                this.ignoreAnnotationShortNames.remove(shortName);\n+                this.ignoreAnnotationShortNames.remove(classShortName);\n             }\n         }\n     }\n     \n-    private static boolean isStarImport(final DetailAST importAst) {\n-        boolean result = false;\n-        DetailAST toVisit = importAst;\n-        while (toVisit != null) {\n-            toVisit = getNextSubTreeNode(toVisit, importAst);\n-            if (toVisit != null && toVisit.getType() == 60) {\n-                result = true;\n+    private static boolean isStarImport(final DetailAST detailAST) {\n+        boolean b = false;\n+        DetailAST nextSubTreeNode = detailAST;\n+        while (nextSubTreeNode != null) {\n+            nextSubTreeNode = getNextSubTreeNode(nextSubTreeNode, detailAST);\n+            if (nextSubTreeNode != null && nextSubTreeNode.getType() == 60) {\n+                b = true;\n                 break;\n             }\n         }\n-        return result;\n+        return b;\n     }\n     \n-    private boolean hasProperAccessModifier(final DetailAST variableDef, final String variableName) {\n-        boolean result = true;\n-        final String variableScope = getVisibilityScope(variableDef);\n-        if (!\"private\".equals(variableScope)) {\n-            result = (isStaticFinalVariable(variableDef) || (this.packageAllowed && \"package\".equals(variableScope)) || (this.protectedAllowed && \"protected\".equals(variableScope)) || this.isIgnoredPublicMember(variableName, variableScope) || this.isAllowedPublicField(variableDef));\n+    private boolean hasProperAccessModifier(final DetailAST detailAST, final String s) {\n+        boolean b = true;\n+        final String visibilityScope = getVisibilityScope(detailAST);\n+        if (!\"private\".equals(visibilityScope)) {\n+            b = (isStaticFinalVariable(detailAST) || (this.packageAllowed && \"package\".equals(visibilityScope)) || (this.protectedAllowed && \"protected\".equals(visibilityScope)) || this.isIgnoredPublicMember(s, visibilityScope) || this.isAllowedPublicField(detailAST));\n         }\n-        return result;\n+        return b;\n     }\n     \n-    private static boolean isStaticFinalVariable(final DetailAST variableDef) {\n-        final Set<String> modifiers = getModifiers(variableDef);\n+    private static boolean isStaticFinalVariable(final DetailAST detailAST) {\n+        final Set<String> modifiers = getModifiers(detailAST);\n         return modifiers.contains(\"static\") && modifiers.contains(\"final\");\n     }\n     \n-    private boolean isIgnoredPublicMember(final String variableName, final String variableScope) {\n-        return \"public\".equals(variableScope) && this.publicMemberPattern.matcher(variableName).find();\n+    private boolean isIgnoredPublicMember(final String input, final String anObject) {\n+        return \"public\".equals(anObject) && this.publicMemberPattern.matcher(input).find();\n     }\n     \n-    private boolean isAllowedPublicField(final DetailAST variableDef) {\n-        return (this.allowPublicFinalFields && isFinalField(variableDef)) || (this.allowPublicImmutableFields && this.isImmutableFieldDefinedInFinalClass(variableDef));\n+    private boolean isAllowedPublicField(final DetailAST detailAST) {\n+        return (this.allowPublicFinalFields && isFinalField(detailAST)) || (this.allowPublicImmutableFields && this.isImmutableFieldDefinedInFinalClass(detailAST));\n     }\n     \n-    private boolean isImmutableFieldDefinedInFinalClass(final DetailAST variableDef) {\n-        final DetailAST classDef = variableDef.getParent().getParent();\n-        final Set<String> classModifiers = getModifiers(classDef);\n-        return (classModifiers.contains(\"final\") || classDef.getType() == 154) && this.isImmutableField(variableDef);\n+    private boolean isImmutableFieldDefinedInFinalClass(final DetailAST detailAST) {\n+        final DetailAST parent = detailAST.getParent().getParent();\n+        return (getModifiers(parent).contains(\"final\") || parent.getType() == 154) && this.isImmutableField(detailAST);\n     }\n     \n-    private static Set<String> getModifiers(final DetailAST defAST) {\n-        final DetailAST modifiersAST = defAST.findFirstToken(5);\n-        final Set<String> modifiersSet = new HashSet<String>();\n-        if (modifiersAST != null) {\n-            for (DetailAST modifier = modifiersAST.getFirstChild(); modifier != null; modifier = modifier.getNextSibling()) {\n-                modifiersSet.add(modifier.getText());\n+    private static Set<String> getModifiers(final DetailAST detailAST) {\n+        final DetailAST firstToken = detailAST.findFirstToken(5);\n+        final HashSet set = new HashSet();\n+        if (firstToken != null) {\n+            for (DetailAST detailAST2 = firstToken.getFirstChild(); detailAST2 != null; detailAST2 = detailAST2.getNextSibling()) {\n+                set.add(detailAST2.getText());\n             }\n         }\n-        return modifiersSet;\n+        return set;\n     }\n     \n-    private static String getVisibilityScope(final DetailAST variableDef) {\n-        final Set<String> modifiers = getModifiers(variableDef);\n-        String accessModifier = \"package\";\n-        for (final String modifier : VisibilityModifierCheck.EXPLICIT_MODS) {\n-            if (modifiers.contains(modifier)) {\n-                accessModifier = modifier;\n+    private static String getVisibilityScope(final DetailAST detailAST) {\n+        final Set<String> modifiers = getModifiers(detailAST);\n+        String s = \"package\";\n+        for (final String s2 : VisibilityModifierCheck.EXPLICIT_MODS) {\n+            if (modifiers.contains(s2)) {\n+                s = s2;\n                 break;\n             }\n         }\n-        return accessModifier;\n+        return s;\n     }\n     \n-    private boolean isImmutableField(final DetailAST variableDef) {\n-        boolean result = false;\n-        if (isFinalField(variableDef)) {\n-            final DetailAST type = variableDef.findFirstToken(13);\n-            final boolean isCanonicalName = isCanonicalName(type);\n-            final String typeName = getCanonicalName(type);\n-            if (this.immutableClassShortNames.contains(typeName) || (isCanonicalName && this.immutableClassCanonicalNames.contains(typeName))) {\n-                final DetailAST typeArgs = getGenericTypeArgs(type, isCanonicalName);\n-                if (typeArgs == null) {\n-                    result = true;\n-                }\n-                else {\n-                    final List<String> argsClassNames = getTypeArgsClassNames(typeArgs);\n-                    result = this.areImmutableTypeArguments(argsClassNames);\n-                }\n+    private boolean isImmutableField(final DetailAST detailAST) {\n+        boolean b = false;\n+        if (isFinalField(detailAST)) {\n+            final DetailAST firstToken = detailAST.findFirstToken(13);\n+            final boolean canonicalName = isCanonicalName(firstToken);\n+            final String canonicalName2 = getCanonicalName(firstToken);\n+            if (this.immutableClassShortNames.contains(canonicalName2) || (canonicalName && this.immutableClassCanonicalNames.contains(canonicalName2))) {\n+                final DetailAST genericTypeArgs = getGenericTypeArgs(firstToken, canonicalName);\n+                b = (genericTypeArgs == null || this.areImmutableTypeArguments(getTypeArgsClassNames(genericTypeArgs)));\n             }\n             else {\n-                result = (!isCanonicalName && isPrimitive(type));\n+                b = (!canonicalName && isPrimitive(firstToken));\n             }\n         }\n-        return result;\n+        return b;\n     }\n     \n-    private static boolean isCanonicalName(final DetailAST type) {\n-        return type.getFirstChild().getType() == 59;\n+    private static boolean isCanonicalName(final DetailAST detailAST) {\n+        return detailAST.getFirstChild().getType() == 59;\n     }\n     \n-    private static DetailAST getGenericTypeArgs(final DetailAST type, final boolean isCanonicalName) {\n-        DetailAST typeArgs;\n-        if (isCanonicalName) {\n-            typeArgs = type.getFirstChild().findFirstToken(163);\n+    private static DetailAST getGenericTypeArgs(final DetailAST detailAST, final boolean b) {\n+        DetailAST detailAST2;\n+        if (b) {\n+            detailAST2 = detailAST.getFirstChild().findFirstToken(163);\n         }\n         else {\n-            typeArgs = type.findFirstToken(163);\n+            detailAST2 = detailAST.findFirstToken(163);\n         }\n-        return typeArgs;\n+        return detailAST2;\n     }\n     \n-    private static List<String> getTypeArgsClassNames(final DetailAST typeArgs) {\n-        final List<String> typeClassNames = new ArrayList<String>();\n-        DetailAST type = typeArgs.findFirstToken(164);\n-        DetailAST sibling;\n+    private static List<String> getTypeArgsClassNames(final DetailAST detailAST) {\n+        final ArrayList list = new ArrayList();\n+        DetailAST detailAST2 = detailAST.findFirstToken(164);\n+        DetailAST nextSibling;\n         do {\n-            final String typeName = getCanonicalName(type);\n-            typeClassNames.add(typeName);\n-            sibling = type.getNextSibling();\n-            type = sibling.getNextSibling();\n-        } while (sibling.getType() == 74);\n-        return typeClassNames;\n+            list.add(getCanonicalName(detailAST2));\n+            nextSibling = detailAST2.getNextSibling();\n+            detailAST2 = nextSibling.getNextSibling();\n+        } while (nextSibling.getType() == 74);\n+        return list;\n     }\n     \n-    private boolean areImmutableTypeArguments(final Collection<String> typeArgsClassNames) {\n-        return typeArgsClassNames.stream().noneMatch(typeName -> !this.immutableClassShortNames.contains(typeName) && !this.immutableClassCanonicalNames.contains(typeName));\n+    private boolean areImmutableTypeArguments(final Collection<String> collection) {\n+        return collection.stream().noneMatch(s -> !this.immutableClassShortNames.contains(s) && !this.immutableClassCanonicalNames.contains(s));\n     }\n     \n-    private static boolean isFinalField(final DetailAST variableDef) {\n-        final DetailAST modifiers = variableDef.findFirstToken(5);\n-        return modifiers.findFirstToken(39) != null;\n+    private static boolean isFinalField(final DetailAST detailAST) {\n+        return detailAST.findFirstToken(5).findFirstToken(39) != null;\n     }\n     \n-    private static boolean isPrimitive(final DetailAST type) {\n-        return type.getFirstChild().getType() != 58;\n+    private static boolean isPrimitive(final DetailAST detailAST) {\n+        return detailAST.getFirstChild().getType() != 58;\n     }\n     \n-    private static String getCanonicalName(final DetailAST type) {\n-        final StringBuilder canonicalNameBuilder = new StringBuilder(256);\n-        DetailAST toVisit = type;\n-        while (toVisit != null) {\n-            toVisit = getNextSubTreeNode(toVisit, type);\n-            if (toVisit != null && toVisit.getType() == 58) {\n-                if (canonicalNameBuilder.length() > 0) {\n-                    canonicalNameBuilder.append('.');\n+    private static String getCanonicalName(final DetailAST detailAST) {\n+        final StringBuilder sb = new StringBuilder(256);\n+        DetailAST nextSubTreeNode = detailAST;\n+        while (nextSubTreeNode != null) {\n+            nextSubTreeNode = getNextSubTreeNode(nextSubTreeNode, detailAST);\n+            if (nextSubTreeNode != null && nextSubTreeNode.getType() == 58) {\n+                if (sb.length() > 0) {\n+                    sb.append('.');\n                 }\n-                canonicalNameBuilder.append(toVisit.getText());\n-                final DetailAST nextSubTreeNode = getNextSubTreeNode(toVisit, type);\n-                if (nextSubTreeNode != null && nextSubTreeNode.getType() == 163) {\n+                sb.append(nextSubTreeNode.getText());\n+                final DetailAST nextSubTreeNode2 = getNextSubTreeNode(nextSubTreeNode, detailAST);\n+                if (nextSubTreeNode2 != null && nextSubTreeNode2.getType() == 163) {\n                     break;\n                 }\n                 continue;\n             }\n         }\n-        return canonicalNameBuilder.toString();\n+        return sb.toString();\n     }\n     \n-    private static DetailAST getNextSubTreeNode(final DetailAST currentNodeAst, final DetailAST subTreeRootAst) {\n-        DetailAST currentNode = currentNodeAst;\n-        DetailAST toVisitAst = currentNode.getFirstChild();\n-        while (toVisitAst == null) {\n-            toVisitAst = currentNode.getNextSibling();\n-            if (currentNode.getParent().getColumnNo() == subTreeRootAst.getColumnNo()) {\n+    private static DetailAST getNextSubTreeNode(final DetailAST detailAST, final DetailAST detailAST2) {\n+        DetailAST parent = detailAST;\n+        DetailAST detailAST3 = parent.getFirstChild();\n+        while (detailAST3 == null) {\n+            detailAST3 = parent.getNextSibling();\n+            if (parent.getParent().getColumnNo() == detailAST2.getColumnNo()) {\n                 break;\n             }\n-            currentNode = currentNode.getParent();\n+            parent = parent.getParent();\n         }\n-        return toVisitAst;\n+        return detailAST3;\n     }\n     \n-    private static Set<String> getClassShortNames(final Set<String> canonicalClassNames) {\n-        return canonicalClassNames.stream().map((Function<? super Object, ?>)CommonUtil::baseClassName).collect((Collector<? super Object, ?, Set<String>>)Collectors.toCollection((Supplier<R>)HashSet::new));\n+    private static Set<String> getClassShortNames(final Set<String> set) {\n+        return set.stream().map((Function<? super Object, ?>)CommonUtil::baseClassName).collect((Collector<? super Object, ?, Set<String>>)Collectors.toCollection((Supplier<R>)HashSet::new));\n     }\n     \n-    private static String getClassShortName(final String canonicalClassName) {\n-        return canonicalClassName.substring(canonicalClassName.lastIndexOf(46) + 1);\n+    private static String getClassShortName(final String s) {\n+        return s.substring(s.lastIndexOf(46) + 1);\n     }\n     \n-    private DetailAST findMatchingAnnotation(final DetailAST variableDef) {\n-        DetailAST matchingAnnotation = null;\n-        final DetailAST holder = AnnotationUtil.getAnnotationHolder(variableDef);\n-        for (DetailAST child = holder.getFirstChild(); child != null; child = child.getNextSibling()) {\n-            if (child.getType() == 159) {\n-                final DetailAST ast = child.getFirstChild();\n-                final String name = FullIdent.createFullIdent(ast.getNextSibling()).getText();\n-                if (this.ignoreAnnotationCanonicalNames.contains(name) || this.ignoreAnnotationShortNames.contains(name)) {\n-                    matchingAnnotation = child;\n+    private DetailAST findMatchingAnnotation(final DetailAST detailAST) {\n+        DetailAST detailAST2 = null;\n+        for (DetailAST detailAST3 = AnnotationUtil.getAnnotationHolder(detailAST).getFirstChild(); detailAST3 != null; detailAST3 = detailAST3.getNextSibling()) {\n+            if (detailAST3.getType() == 159) {\n+                final String text = FullIdent.createFullIdent(detailAST3.getFirstChild().getNextSibling()).getText();\n+                if (this.ignoreAnnotationCanonicalNames.contains(text) || this.ignoreAnnotationShortNames.contains(text)) {\n+                    detailAST2 = detailAST3;\n                     break;\n                 }\n             }\n         }\n-        return matchingAnnotation;\n+        return detailAST2;\n     }\n     \n     static {\n         DEFAULT_IMMUTABLE_TYPES = Set.of(new String[] { \"java.lang.String\", \"java.lang.Integer\", \"java.lang.Byte\", \"java.lang.Character\", \"java.lang.Short\", \"java.lang.Boolean\", \"java.lang.Long\", \"java.lang.Double\", \"java.lang.Float\", \"java.lang.StackTraceElement\", \"java.math.BigInteger\", \"java.math.BigDecimal\", \"java.io.File\", \"java.util.Locale\", \"java.util.UUID\", \"java.net.URL\", \"java.net.URI\", \"java.net.Inet4Address\", \"java.net.Inet6Address\", \"java.net.InetSocketAddress\" });\n         DEFAULT_IGNORE_ANNOTATIONS = Set.of(\"org.junit.Rule\", \"org.junit.ClassRule\", \"com.google.common.annotations.VisibleForTesting\");\n         EXPLICIT_MODS = new String[] { \"public\", \"private\", \"protected\" };\n     }\n"}]}
