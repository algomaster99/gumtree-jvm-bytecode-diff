{"diffoscope-json-version": 1, "source1": "first/SegmentConstantPool.class", "source2": "second/SegmentConstantPool.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -24,182 +24,178 @@\n     public static final int CP_IMETHOD = 12;\n     protected static final String REGEX_MATCH_ALL = \".*\";\n     protected static final String INITSTRING = \"<init>\";\n     protected static final String REGEX_MATCH_INIT = \"^<init>.*\";\n     private final CpBands bands;\n     private final SegmentConstantPoolArrayCache arrayCache;\n     \n-    protected static boolean regexMatches(final String regexString, final String compareString) {\n-        if (\".*\".equals(regexString)) {\n+    protected static boolean regexMatches(final String str, final String s) {\n+        if (\".*\".equals(str)) {\n             return true;\n         }\n-        if (\"^<init>.*\".equals(regexString)) {\n-            return compareString.length() >= \"<init>\".length() && \"<init>\".equals(compareString.substring(0, \"<init>\".length()));\n+        if (\"^<init>.*\".equals(str)) {\n+            return s.length() >= \"<init>\".length() && \"<init>\".equals(s.substring(0, \"<init>\".length()));\n         }\n-        throw new Error(\"regex trying to match a pattern I don't know: \" + regexString);\n+        throw new Error(\"regex trying to match a pattern I don't know: \" + str);\n     }\n     \n     public SegmentConstantPool(final CpBands bands) {\n         this.arrayCache = new SegmentConstantPoolArrayCache();\n         this.bands = bands;\n     }\n     \n-    public ConstantPoolEntry getClassPoolEntry(final String name) {\n-        final String[] classes = this.bands.getCpClass();\n-        final int index = this.matchSpecificPoolEntryIndex(classes, name, 0);\n-        if (index == -1) {\n+    public ConstantPoolEntry getClassPoolEntry(final String s) {\n+        final int matchSpecificPoolEntryIndex = this.matchSpecificPoolEntryIndex(this.bands.getCpClass(), s, 0);\n+        if (matchSpecificPoolEntryIndex == -1) {\n             return null;\n         }\n         try {\n-            return this.getConstantPoolEntry(7, index);\n+            return this.getConstantPoolEntry(7, matchSpecificPoolEntryIndex);\n         }\n         catch (final Pack200Exception ex) {\n             throw new Error(\"Error getting class pool entry\");\n         }\n     }\n     \n-    public ConstantPoolEntry getClassSpecificPoolEntry(final int cp, final long desiredIndex, final String desiredClassName) throws Pack200Exception {\n-        final int index = (int)desiredIndex;\n-        int realIndex = -1;\n+    public ConstantPoolEntry getClassSpecificPoolEntry(final int i, final long n, final String s) throws Pack200Exception {\n+        final int n2 = (int)n;\n         String[] array = null;\n-        switch (cp) {\n+        switch (i) {\n             case 10: {\n                 array = this.bands.getCpFieldClass();\n                 break;\n             }\n             case 11: {\n                 array = this.bands.getCpMethodClass();\n                 break;\n             }\n             case 12: {\n                 array = this.bands.getCpIMethodClass();\n                 break;\n             }\n             default: {\n-                throw new Error(\"Don't know how to handle \" + cp);\n+                throw new Error(\"Don't know how to handle \" + i);\n             }\n         }\n-        realIndex = this.matchSpecificPoolEntryIndex(array, desiredClassName, index);\n-        return this.getConstantPoolEntry(cp, realIndex);\n+        return this.getConstantPoolEntry(i, this.matchSpecificPoolEntryIndex(array, s, n2));\n     }\n     \n-    public ConstantPoolEntry getConstantPoolEntry(final int cp, final long value) throws Pack200Exception {\n-        final int index = (int)value;\n-        if (index == -1) {\n+    public ConstantPoolEntry getConstantPoolEntry(final int n, final long n2) throws Pack200Exception {\n+        final int n3 = (int)n2;\n+        if (n3 == -1) {\n             return null;\n         }\n-        if (index < 0) {\n+        if (n3 < 0) {\n             throw new Pack200Exception(\"Cannot have a negative range\");\n         }\n-        switch (cp) {\n+        switch (n) {\n             case 1: {\n-                return (ConstantPoolEntry)this.bands.cpUTF8Value(index);\n+                return (ConstantPoolEntry)this.bands.cpUTF8Value(n3);\n             }\n             case 2: {\n-                return (ConstantPoolEntry)this.bands.cpIntegerValue(index);\n+                return (ConstantPoolEntry)this.bands.cpIntegerValue(n3);\n             }\n             case 3: {\n-                return (ConstantPoolEntry)this.bands.cpFloatValue(index);\n+                return (ConstantPoolEntry)this.bands.cpFloatValue(n3);\n             }\n             case 4: {\n-                return (ConstantPoolEntry)this.bands.cpLongValue(index);\n+                return (ConstantPoolEntry)this.bands.cpLongValue(n3);\n             }\n             case 5: {\n-                return (ConstantPoolEntry)this.bands.cpDoubleValue(index);\n+                return (ConstantPoolEntry)this.bands.cpDoubleValue(n3);\n             }\n             case 6: {\n-                return (ConstantPoolEntry)this.bands.cpStringValue(index);\n+                return (ConstantPoolEntry)this.bands.cpStringValue(n3);\n             }\n             case 7: {\n-                return (ConstantPoolEntry)this.bands.cpClassValue(index);\n+                return (ConstantPoolEntry)this.bands.cpClassValue(n3);\n             }\n             case 8: {\n                 throw new Error(\"I don't know what to do with signatures yet\");\n             }\n             case 9: {\n                 throw new Error(\"I don't know what to do with descriptors yet\");\n             }\n             case 10: {\n-                return (ConstantPoolEntry)this.bands.cpFieldValue(index);\n+                return (ConstantPoolEntry)this.bands.cpFieldValue(n3);\n             }\n             case 11: {\n-                return (ConstantPoolEntry)this.bands.cpMethodValue(index);\n+                return (ConstantPoolEntry)this.bands.cpMethodValue(n3);\n             }\n             case 12: {\n-                return (ConstantPoolEntry)this.bands.cpIMethodValue(index);\n+                return (ConstantPoolEntry)this.bands.cpIMethodValue(n3);\n             }\n             default: {\n                 throw new Error(\"Get value incomplete\");\n             }\n         }\n     }\n     \n-    public ConstantPoolEntry getInitMethodPoolEntry(final int cp, final long value, final String desiredClassName) throws Pack200Exception {\n-        int realIndex = -1;\n-        if (cp != 11) {\n+    public ConstantPoolEntry getInitMethodPoolEntry(final int n, final long n2, final String s) throws Pack200Exception {\n+        if (n != 11) {\n             throw new Error(\"Nothing but CP_METHOD can be an <init>\");\n         }\n-        realIndex = this.matchSpecificPoolEntryIndex(this.bands.getCpMethodClass(), this.bands.getCpMethodDescriptor(), desiredClassName, \"^<init>.*\", (int)value);\n-        return this.getConstantPoolEntry(cp, realIndex);\n+        return this.getConstantPoolEntry(n, this.matchSpecificPoolEntryIndex(this.bands.getCpMethodClass(), this.bands.getCpMethodDescriptor(), s, \"^<init>.*\", (int)n2));\n     }\n     \n-    public ClassFileEntry getValue(final int cp, final long value) throws Pack200Exception {\n-        final int index = (int)value;\n-        if (index == -1) {\n+    public ClassFileEntry getValue(final int i, final long n) throws Pack200Exception {\n+        final int n2 = (int)n;\n+        if (n2 == -1) {\n             return null;\n         }\n-        if (index < 0) {\n+        if (n2 < 0) {\n             throw new Pack200Exception(\"Cannot have a negative range\");\n         }\n-        switch (cp) {\n+        switch (i) {\n             case 1: {\n-                return (ClassFileEntry)this.bands.cpUTF8Value(index);\n+                return (ClassFileEntry)this.bands.cpUTF8Value(n2);\n             }\n             case 2: {\n-                return (ClassFileEntry)this.bands.cpIntegerValue(index);\n+                return (ClassFileEntry)this.bands.cpIntegerValue(n2);\n             }\n             case 3: {\n-                return (ClassFileEntry)this.bands.cpFloatValue(index);\n+                return (ClassFileEntry)this.bands.cpFloatValue(n2);\n             }\n             case 4: {\n-                return (ClassFileEntry)this.bands.cpLongValue(index);\n+                return (ClassFileEntry)this.bands.cpLongValue(n2);\n             }\n             case 5: {\n-                return (ClassFileEntry)this.bands.cpDoubleValue(index);\n+                return (ClassFileEntry)this.bands.cpDoubleValue(n2);\n             }\n             case 6: {\n-                return (ClassFileEntry)this.bands.cpStringValue(index);\n+                return (ClassFileEntry)this.bands.cpStringValue(n2);\n             }\n             case 7: {\n-                return (ClassFileEntry)this.bands.cpClassValue(index);\n+                return (ClassFileEntry)this.bands.cpClassValue(n2);\n             }\n             case 8: {\n-                return (ClassFileEntry)this.bands.cpSignatureValue(index);\n+                return (ClassFileEntry)this.bands.cpSignatureValue(n2);\n             }\n             case 9: {\n-                return (ClassFileEntry)this.bands.cpNameAndTypeValue(index);\n+                return (ClassFileEntry)this.bands.cpNameAndTypeValue(n2);\n             }\n             default: {\n-                throw new Error(\"Tried to get a value I don't know about: \" + cp);\n+                throw new Error(\"Tried to get a value I don't know about: \" + i);\n             }\n         }\n     }\n     \n-    protected int matchSpecificPoolEntryIndex(final String[] nameArray, final String compareString, final int desiredIndex) {\n-        return this.matchSpecificPoolEntryIndex(nameArray, nameArray, compareString, \".*\", desiredIndex);\n+    protected int matchSpecificPoolEntryIndex(final String[] array, final String s, final int n) {\n+        return this.matchSpecificPoolEntryIndex(array, array, s, \".*\", n);\n     }\n     \n-    protected int matchSpecificPoolEntryIndex(final String[] primaryArray, final String[] secondaryArray, final String primaryCompareString, final String secondaryCompareRegex, final int desiredIndex) {\n-        int instanceCount = -1;\n-        final List<Integer> indexList = this.arrayCache.indexesForArrayKey(primaryArray, primaryCompareString);\n-        if (indexList.isEmpty()) {\n+    protected int matchSpecificPoolEntryIndex(final String[] array, final String[] array2, final String s, final String s2, final int n) {\n+        int n2 = -1;\n+        final List indexesForArrayKey = this.arrayCache.indexesForArrayKey(array, s);\n+        if (indexesForArrayKey.isEmpty()) {\n             return -1;\n         }\n-        for (final Integer element : indexList) {\n-            final int arrayIndex = (int)element;\n-            if (regexMatches(secondaryCompareRegex, secondaryArray[arrayIndex]) && ++instanceCount == desiredIndex) {\n-                return arrayIndex;\n+        final Iterator iterator = indexesForArrayKey.iterator();\n+        while (iterator.hasNext()) {\n+            final int intValue = (int)iterator.next();\n+            if (regexMatches(s2, array2[intValue]) && ++n2 == n) {\n+                return intValue;\n             }\n         }\n         return -1;\n     }\n }\n"}]}
