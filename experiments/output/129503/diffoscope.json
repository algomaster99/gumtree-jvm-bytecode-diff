{"diffoscope-json-version": 1, "source1": "first/IOStream.class", "source2": "second/IOStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -52,105 +52,105 @@\n     }\n     \n     default <T> IOStream<T> of(final T t) {\n         return adapt((Stream<T>)Stream.of((T)t));\n     }\n     \n     default boolean allMatch(final IOPredicate<? super T> predicate) throws IOException {\n-        return ((Stream)this.unwrap()).allMatch(t -> Erase.test(predicate, t));\n+        return ((Stream)this.unwrap()).allMatch(t -> Erase.test(ioPredicate, t));\n     }\n     \n     default boolean anyMatch(final IOPredicate<? super T> predicate) throws IOException {\n-        return ((Stream)this.unwrap()).anyMatch(t -> Erase.test(predicate, t));\n+        return ((Stream)this.unwrap()).anyMatch(t -> Erase.test(ioPredicate, t));\n     }\n     \n     default <R, A> R collect(final Collector<? super T, A, R> collector) {\n         return ((Stream)this.unwrap()).collect(collector);\n     }\n     \n     default <R> R collect(final IOSupplier<R> supplier, final IOBiConsumer<R, ? super T> accumulator, final IOBiConsumer<R, R> combiner) throws IOException {\n-        return ((Stream)this.unwrap()).collect(() -> Erase.get(supplier), (t, u) -> Erase.accept(accumulator, t, u), (t, u) -> Erase.accept(combiner, t, u));\n+        return ((Stream)this.unwrap()).collect(() -> Erase.get(ioSupplier), (t, u) -> Erase.accept(ioBiConsumer, t, u), (t, u) -> Erase.accept(ioBiConsumer2, t, u));\n     }\n     \n     default long count() {\n         return ((Stream)this.unwrap()).count();\n     }\n     \n     default IOStream<T> distinct() {\n         return adapt(((Stream)this.unwrap()).distinct());\n     }\n     \n     default IOStream<T> filter(final IOPredicate<? super T> predicate) throws IOException {\n-        return adapt(((Stream)this.unwrap()).filter(t -> Erase.test(predicate, t)));\n+        return adapt(((Stream)this.unwrap()).filter(t -> Erase.test(ioPredicate, t)));\n     }\n     \n     default Optional<T> findAny() {\n         return ((Stream)this.unwrap()).findAny();\n     }\n     \n     default Optional<T> findFirst() {\n         return ((Stream)this.unwrap()).findFirst();\n     }\n     \n     default <R> IOStream<R> flatMap(final IOFunction<? super T, ? extends IOStream<? extends R>> mapper) throws IOException {\n-        return adapt(((Stream)this.unwrap()).flatMap(t -> (BaseStream)((IOStream)Erase.apply(mapper, t)).unwrap()));\n+        return adapt(((Stream)this.unwrap()).flatMap(t -> (BaseStream)((IOStream)Erase.apply(ioFunction, t)).unwrap()));\n     }\n     \n     default DoubleStream flatMapToDouble(final IOFunction<? super T, ? extends DoubleStream> mapper) throws IOException {\n-        return ((Stream)this.unwrap()).flatMapToDouble(t -> (Object)Erase.apply(mapper, t));\n+        return ((Stream)this.unwrap()).flatMapToDouble(t -> (Object)Erase.apply(ioFunction, t));\n     }\n     \n     default IntStream flatMapToInt(final IOFunction<? super T, ? extends IntStream> mapper) throws IOException {\n-        return ((Stream)this.unwrap()).flatMapToInt(t -> (Object)Erase.apply(mapper, t));\n+        return ((Stream)this.unwrap()).flatMapToInt(t -> (Object)Erase.apply(ioFunction, t));\n     }\n     \n     default LongStream flatMapToLong(final IOFunction<? super T, ? extends LongStream> mapper) throws IOException {\n-        return ((Stream)this.unwrap()).flatMapToLong(t -> (Object)Erase.apply(mapper, t));\n+        return ((Stream)this.unwrap()).flatMapToLong(t -> (Object)Erase.apply(ioFunction, t));\n     }\n     \n     default void forAll(final IOConsumer<T> action) throws IOExceptionList {\n         this.forAll(action, (i, e) -> e);\n     }\n     \n     default void forAll(final IOConsumer<T> action, final BiFunction<Integer, IOException, IOException> exSupplier) throws IOExceptionList {\n         final AtomicReference<List<IOException>> causeList = new AtomicReference<List<IOException>>();\n         final AtomicInteger index = new AtomicInteger();\n         final IOConsumer<T> safeAction = (IOConsumer<T>)IOStreams.toIOConsumer((IOConsumer)action);\n         ((Stream)this.unwrap()).forEach(e -> {\n             try {\n-                safeAction.accept(e);\n+                ioConsumer.accept(e);\n             }\n             catch (final IOException innerEx) {\n-                if (causeList.get() == null) {\n-                    causeList.set(new ArrayList());\n+                if (atomicReference.get() == null) {\n+                    atomicReference.set(new ArrayList());\n                 }\n-                if (exSupplier != null) {\n-                    ((List<IOException>)causeList.get()).add(exSupplier.apply(Integer.valueOf(index.get()), innerEx));\n+                if (biFunction != null) {\n+                    ((List<IOException>)atomicReference.get()).add(biFunction.apply(Integer.valueOf(atomicInteger.get()), innerEx));\n                 }\n             }\n-            index.incrementAndGet();\n+            atomicInteger.incrementAndGet();\n             return;\n         });\n         IOExceptionList.checkEmpty((List)(List)causeList.get(), (Object)null);\n     }\n     \n     default void forEach(final IOConsumer<? super T> action) throws IOException {\n-        ((Stream)this.unwrap()).forEach(e -> Erase.accept(action, e));\n+        ((Stream)this.unwrap()).forEach(e -> Erase.accept(ioConsumer, e));\n     }\n     \n     default void forEachOrdered(final IOConsumer<? super T> action) throws IOException {\n-        ((Stream)this.unwrap()).forEachOrdered(e -> Erase.accept(action, e));\n+        ((Stream)this.unwrap()).forEachOrdered(e -> Erase.accept(ioConsumer, e));\n     }\n     \n     default IOStream<T> limit(final long maxSize) {\n         return adapt(((Stream)this.unwrap()).limit(maxSize));\n     }\n     \n     default <R> IOStream<R> map(final IOFunction<? super T, ? extends R> mapper) throws IOException {\n-        return adapt(((Stream)this.unwrap()).map(t -> Erase.apply(mapper, t)));\n+        return adapt(((Stream)this.unwrap()).map(t -> Erase.apply(ioFunction, t)));\n     }\n     \n     default DoubleStream mapToDouble(final ToDoubleFunction<? super T> mapper) {\n         return ((Stream)this.unwrap()).mapToDouble(mapper);\n     }\n     \n     default IntStream mapToInt(final ToIntFunction<? super T> mapper) {\n@@ -158,51 +158,51 @@\n     }\n     \n     default LongStream mapToLong(final ToLongFunction<? super T> mapper) {\n         return ((Stream)this.unwrap()).mapToLong(mapper);\n     }\n     \n     default Optional<T> max(final IOComparator<? super T> comparator) throws IOException {\n-        return ((Stream)this.unwrap()).max((t, u) -> Erase.compare(comparator, t, u));\n+        return ((Stream)this.unwrap()).max((t, u) -> Erase.compare(ioComparator, t, u));\n     }\n     \n     default Optional<T> min(final IOComparator<? super T> comparator) throws IOException {\n-        return ((Stream)this.unwrap()).min((t, u) -> Erase.compare(comparator, t, u));\n+        return ((Stream)this.unwrap()).min((t, u) -> Erase.compare(ioComparator, t, u));\n     }\n     \n     default boolean noneMatch(final IOPredicate<? super T> predicate) throws IOException {\n-        return ((Stream)this.unwrap()).noneMatch(t -> Erase.test(predicate, t));\n+        return ((Stream)this.unwrap()).noneMatch(t -> Erase.test(ioPredicate, t));\n     }\n     \n     default IOStream<T> peek(final IOConsumer<? super T> action) throws IOException {\n-        return adapt(((Stream)this.unwrap()).peek(t -> Erase.accept(action, t)));\n+        return adapt(((Stream)this.unwrap()).peek(t -> Erase.accept(ioConsumer, t)));\n     }\n     \n     default Optional<T> reduce(final IOBinaryOperator<T> accumulator) throws IOException {\n-        return ((Stream)this.unwrap()).reduce((t, u) -> Erase.apply((IOBiFunction)accumulator, t, u));\n+        return ((Stream)this.unwrap()).reduce((t, u) -> Erase.apply((IOBiFunction)ioBinaryOperator, t, u));\n     }\n     \n     default T reduce(final T identity, final IOBinaryOperator<T> accumulator) throws IOException {\n-        return ((Stream)this.unwrap()).reduce(identity, (t, u) -> Erase.apply((IOBiFunction)accumulator, t, u));\n+        return ((Stream)this.unwrap()).reduce(identity, (t, u) -> Erase.apply((IOBiFunction)ioBinaryOperator, t, u));\n     }\n     \n     default <U> U reduce(final U identity, final IOBiFunction<U, ? super T, U> accumulator, final IOBinaryOperator<U> combiner) throws IOException {\n-        return ((Stream)this.unwrap()).reduce(identity, (t, u) -> Erase.apply(accumulator, t, u), (t, u) -> Erase.apply((IOBiFunction)combiner, t, u));\n+        return ((Stream)this.unwrap()).reduce(identity, (t, u) -> Erase.apply(ioBiFunction, t, u), (t, u) -> Erase.apply((IOBiFunction)ioBinaryOperator, t, u));\n     }\n     \n     default IOStream<T> skip(final long n) {\n         return adapt(((Stream)this.unwrap()).skip(n));\n     }\n     \n     default IOStream<T> sorted() {\n         return adapt(((Stream)this.unwrap()).sorted());\n     }\n     \n     default IOStream<T> sorted(final IOComparator<? super T> comparator) throws IOException {\n-        return adapt(((Stream)this.unwrap()).sorted((t, u) -> Erase.compare(comparator, t, u)));\n+        return adapt(((Stream)this.unwrap()).sorted((t, u) -> Erase.compare(ioComparator, t, u)));\n     }\n     \n     default Object[] toArray() {\n         return ((Stream)this.unwrap()).toArray();\n     }\n     \n     default <A> A[] toArray(final IntFunction<A[]> generator) {\n"}]}
