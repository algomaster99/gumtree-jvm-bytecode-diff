{"diffoscope-json-version": 1, "source1": "first/Segment.class", "source2": "second/Segment.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -8,15 +8,14 @@\n import java.io.ByteArrayInputStream;\n import java.io.BufferedInputStream;\n import java.util.jar.JarOutputStream;\n import java.io.OutputStream;\n import java.io.DataOutputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n-import java.util.Set;\n import java.util.HashSet;\n import org.apache.commons.compress.harmony.pack200.Pack200Exception;\n import org.apache.commons.compress.harmony.unpack200.bytecode.CPClass;\n import org.apache.commons.compress.harmony.unpack200.bytecode.CPUTF8;\n import org.apache.commons.compress.harmony.unpack200.bytecode.ClassConstantPool;\n import org.apache.commons.compress.harmony.unpack200.bytecode.InnerClassesAttribute;\n import org.apache.commons.compress.harmony.unpack200.bytecode.CPMethod;\n@@ -48,339 +47,314 @@\n     private int logLevel;\n     private PrintWriter logStream;\n     private byte[][] classFilesContents;\n     private boolean[] fileDeflate;\n     private boolean[] fileIsClass;\n     private InputStream internalBuffer;\n     \n-    private ClassFile buildClassFile(final int classNum) throws Pack200Exception {\n+    private ClassFile buildClassFile(final int n) throws Pack200Exception {\n         final ClassFile classFile = new ClassFile();\n-        final int[] major = this.classBands.getClassVersionMajor();\n-        final int[] minor = this.classBands.getClassVersionMinor();\n-        if (major != null) {\n-            classFile.major = major[classNum];\n-            classFile.minor = minor[classNum];\n+        final int[] classVersionMajor = this.classBands.getClassVersionMajor();\n+        final int[] classVersionMinor = this.classBands.getClassVersionMinor();\n+        if (classVersionMajor != null) {\n+            classFile.major = classVersionMajor[n];\n+            classFile.minor = classVersionMinor[n];\n         }\n         else {\n             classFile.major = this.header.getDefaultClassMajorVersion();\n             classFile.minor = this.header.getDefaultClassMinorVersion();\n         }\n-        final ClassConstantPool cp = classFile.pool;\n-        final int fullNameIndexInCpClass = this.classBands.getClassThisInts()[classNum];\n-        final String fullName = this.cpBands.getCpClass()[fullNameIndexInCpClass];\n-        int i = fullName.lastIndexOf(\"/\") + 1;\n-        final ArrayList classAttributes = this.classBands.getClassAttributes()[classNum];\n-        SourceFileAttribute sourceFileAttribute = null;\n-        for (int index = 0; index < classAttributes.size(); ++index) {\n-            if (((Attribute)classAttributes.get(index)).isSourceFileAttribute()) {\n-                sourceFileAttribute = classAttributes.get(index);\n-            }\n-        }\n-        if (sourceFileAttribute == null) {\n-            final AttributeLayout SOURCE_FILE = this.attrDefinitionBands.getAttributeDefinitionMap().getAttributeLayout(\"SourceFile\", 0);\n-            if (SOURCE_FILE.matches(this.classBands.getRawClassFlags()[classNum])) {\n-                int firstDollar = -1;\n-                for (int index2 = 0; index2 < fullName.length(); ++index2) {\n-                    if (fullName.charAt(index2) <= '$') {\n-                        firstDollar = index2;\n+        final ClassConstantPool pool = classFile.pool;\n+        final int n2 = this.classBands.getClassThisInts()[n];\n+        final String s = this.cpBands.getCpClass()[n2];\n+        final int n3 = s.lastIndexOf(\"/\") + 1;\n+        final ArrayList list = this.classBands.getClassAttributes()[n];\n+        Object o = null;\n+        for (int i = 0; i < list.size(); ++i) {\n+            if (((Attribute)list.get(i)).isSourceFileAttribute()) {\n+                o = list.get(i);\n+            }\n+        }\n+        if (o == null) {\n+            if (this.attrDefinitionBands.getAttributeDefinitionMap().getAttributeLayout(\"SourceFile\", 0).matches(this.classBands.getRawClassFlags()[n])) {\n+                int endIndex = -1;\n+                for (int j = 0; j < s.length(); ++j) {\n+                    if (s.charAt(j) <= '$') {\n+                        endIndex = j;\n                     }\n                 }\n-                String fileName = null;\n-                if (firstDollar > -1 && i <= firstDollar) {\n-                    fileName = fullName.substring(i, firstDollar) + \".java\";\n+                String s2;\n+                if (endIndex > -1 && n3 <= endIndex) {\n+                    s2 = s.substring(n3, endIndex) + \".java\";\n                 }\n                 else {\n-                    fileName = fullName.substring(i) + \".java\";\n+                    s2 = s.substring(n3) + \".java\";\n                 }\n-                sourceFileAttribute = new SourceFileAttribute(this.cpBands.cpUTF8Value(fileName, false));\n-                classFile.attributes = new Attribute[] { (Attribute)cp.add((ClassFileEntry)sourceFileAttribute) };\n+                classFile.attributes = new Attribute[] { (Attribute)pool.add((ClassFileEntry)new SourceFileAttribute(this.cpBands.cpUTF8Value(s2, false))) };\n             }\n             else {\n                 classFile.attributes = new Attribute[0];\n             }\n         }\n         else {\n-            classFile.attributes = new Attribute[] { (Attribute)cp.add((ClassFileEntry)sourceFileAttribute) };\n+            classFile.attributes = new Attribute[] { (Attribute)pool.add((ClassFileEntry)o) };\n         }\n-        final ArrayList classAttributesWithoutSourceFileAttribute = new ArrayList(classAttributes.size());\n-        for (int index3 = 0; index3 < classAttributes.size(); ++index3) {\n-            final Attribute attrib = (Attribute)classAttributes.get(index3);\n-            if (!attrib.isSourceFileAttribute()) {\n-                classAttributesWithoutSourceFileAttribute.add(attrib);\n-            }\n-        }\n-        final Attribute[] originalAttributes = classFile.attributes;\n-        System.arraycopy(originalAttributes, 0, classFile.attributes = new Attribute[originalAttributes.length + classAttributesWithoutSourceFileAttribute.size()], 0, originalAttributes.length);\n-        for (int index2 = 0; index2 < classAttributesWithoutSourceFileAttribute.size(); ++index2) {\n-            final Attribute attrib2 = (Attribute)classAttributesWithoutSourceFileAttribute.get(index2);\n-            cp.add((ClassFileEntry)attrib2);\n-            classFile.attributes[originalAttributes.length + index2] = attrib2;\n-        }\n-        final ClassFileEntry cfThis = cp.add((ClassFileEntry)this.cpBands.cpClassValue(fullNameIndexInCpClass));\n-        final ClassFileEntry cfSuper = cp.add((ClassFileEntry)this.cpBands.cpClassValue(this.classBands.getClassSuperInts()[classNum]));\n-        ClassFileEntry[] cfInterfaces;\n-        for (cfInterfaces = new ClassFileEntry[this.classBands.getClassInterfacesInts()[classNum].length], i = 0; i < cfInterfaces.length; ++i) {\n-            cfInterfaces[i] = cp.add((ClassFileEntry)this.cpBands.cpClassValue(this.classBands.getClassInterfacesInts()[classNum][i]));\n-        }\n-        ClassFileEntry[] cfFields;\n-        int descriptorIndex;\n-        int nameIndex;\n-        int typeIndex;\n-        CPUTF8 name;\n-        CPUTF8 descriptor;\n-        for (cfFields = new ClassFileEntry[this.classBands.getClassFieldCount()[classNum]], i = 0; i < cfFields.length; ++i) {\n-            descriptorIndex = this.classBands.getFieldDescrInts()[classNum][i];\n-            nameIndex = this.cpBands.getCpDescriptorNameInts()[descriptorIndex];\n-            typeIndex = this.cpBands.getCpDescriptorTypeInts()[descriptorIndex];\n-            name = this.cpBands.cpUTF8Value(nameIndex);\n-            descriptor = this.cpBands.cpSignatureValue(typeIndex);\n-            cfFields[i] = cp.add((ClassFileEntry)new CPField(name, descriptor, this.classBands.getFieldFlags()[classNum][i], (List)this.classBands.getFieldAttributes()[classNum][i]));\n-        }\n-        ClassFileEntry[] cfMethods;\n-        int descriptorIndex2;\n-        int nameIndex2;\n-        int typeIndex2;\n-        CPUTF8 name2;\n-        CPUTF8 descriptor2;\n-        for (cfMethods = new ClassFileEntry[this.classBands.getClassMethodCount()[classNum]], i = 0; i < cfMethods.length; ++i) {\n-            descriptorIndex2 = this.classBands.getMethodDescrInts()[classNum][i];\n-            nameIndex2 = this.cpBands.getCpDescriptorNameInts()[descriptorIndex2];\n-            typeIndex2 = this.cpBands.getCpDescriptorTypeInts()[descriptorIndex2];\n-            name2 = this.cpBands.cpUTF8Value(nameIndex2);\n-            descriptor2 = this.cpBands.cpSignatureValue(typeIndex2);\n-            cfMethods[i] = cp.add((ClassFileEntry)new CPMethod(name2, descriptor2, this.classBands.getMethodFlags()[classNum][i], (List)this.classBands.getMethodAttributes()[classNum][i]));\n-        }\n-        cp.addNestedEntries();\n-        boolean addInnerClassesAttr = false;\n-        final IcTuple[] ic_local = this.getClassBands().getIcLocal()[classNum];\n-        final boolean ic_local_sent = ic_local != null;\n+        final ArrayList list2 = new ArrayList<Attribute>(list.size());\n+        for (int k = 0; k < list.size(); ++k) {\n+            final Attribute e = (Attribute)list.get(k);\n+            if (!e.isSourceFileAttribute()) {\n+                list2.add(e);\n+            }\n+        }\n+        final Attribute[] attributes = classFile.attributes;\n+        System.arraycopy(attributes, 0, classFile.attributes = new Attribute[attributes.length + list2.size()], 0, attributes.length);\n+        for (int l = 0; l < list2.size(); ++l) {\n+            final Attribute attribute = (Attribute)list2.get(l);\n+            pool.add((ClassFileEntry)attribute);\n+            classFile.attributes[attributes.length + l] = attribute;\n+        }\n+        final ClassFileEntry add = pool.add((ClassFileEntry)this.cpBands.cpClassValue(n2));\n+        final ClassFileEntry add2 = pool.add((ClassFileEntry)this.cpBands.cpClassValue(this.classBands.getClassSuperInts()[n]));\n+        final ClassFileEntry[] array = new ClassFileEntry[this.classBands.getClassInterfacesInts()[n].length];\n+        for (int n4 = 0; n4 < array.length; ++n4) {\n+            array[n4] = pool.add((ClassFileEntry)this.cpBands.cpClassValue(this.classBands.getClassInterfacesInts()[n][n4]));\n+        }\n+        final ClassFileEntry[] fields = new ClassFileEntry[this.classBands.getClassFieldCount()[n]];\n+        for (int n5 = 0; n5 < fields.length; ++n5) {\n+            final int n6 = this.classBands.getFieldDescrInts()[n][n5];\n+            fields[n5] = pool.add((ClassFileEntry)new CPField(this.cpBands.cpUTF8Value(this.cpBands.getCpDescriptorNameInts()[n6]), this.cpBands.cpSignatureValue(this.cpBands.getCpDescriptorTypeInts()[n6]), this.classBands.getFieldFlags()[n][n5], (List)this.classBands.getFieldAttributes()[n][n5]));\n+        }\n+        final ClassFileEntry[] methods = new ClassFileEntry[this.classBands.getClassMethodCount()[n]];\n+        for (int n7 = 0; n7 < methods.length; ++n7) {\n+            final int n8 = this.classBands.getMethodDescrInts()[n][n7];\n+            methods[n7] = pool.add((ClassFileEntry)new CPMethod(this.cpBands.cpUTF8Value(this.cpBands.getCpDescriptorNameInts()[n8]), this.cpBands.cpSignatureValue(this.cpBands.getCpDescriptorTypeInts()[n8]), this.classBands.getMethodFlags()[n][n7], (List)this.classBands.getMethodAttributes()[n][n7]));\n+        }\n+        pool.addNestedEntries();\n+        boolean b = false;\n+        final IcTuple[] array2 = this.getClassBands().getIcLocal()[n];\n+        final boolean b2 = array2 != null;\n         final InnerClassesAttribute innerClassesAttribute = new InnerClassesAttribute(\"InnerClasses\");\n-        final IcTuple[] ic_relevant = this.getIcBands().getRelevantIcTuples(fullName, cp);\n-        final List ic_stored = this.computeIcStored(ic_local, ic_relevant);\n-        for (int index4 = 0; index4 < ic_stored.size(); ++index4) {\n-            final IcTuple icStored = (IcTuple)ic_stored.get(index4);\n-            final int innerClassIndex = icStored.thisClassIndex();\n-            final int outerClassIndex = icStored.outerClassIndex();\n-            final int simpleClassNameIndex = icStored.simpleClassNameIndex();\n-            final String innerClassString = icStored.thisClassString();\n-            final String outerClassString = icStored.outerClassString();\n-            final String simpleClassName = icStored.simpleClassName();\n-            CPClass innerClass = null;\n-            CPUTF8 innerName = null;\n-            CPClass outerClass = null;\n-            innerClass = ((innerClassIndex != -1) ? this.cpBands.cpClassValue(innerClassIndex) : this.cpBands.cpClassValue(innerClassString));\n-            if (!icStored.isAnonymous()) {\n-                innerName = ((simpleClassNameIndex != -1) ? this.cpBands.cpUTF8Value(simpleClassNameIndex) : this.cpBands.cpUTF8Value(simpleClassName));\n-            }\n-            if (icStored.isMember()) {\n-                outerClass = ((outerClassIndex != -1) ? this.cpBands.cpClassValue(outerClassIndex) : this.cpBands.cpClassValue(outerClassString));\n-            }\n-            final int flags = icStored.F;\n-            innerClassesAttribute.addInnerClassesEntry(innerClass, outerClass, innerName, flags);\n-            addInnerClassesAttr = true;\n-        }\n-        if (ic_local_sent && ic_local.length == 0) {\n-            addInnerClassesAttr = false;\n-        }\n-        if (!ic_local_sent && ic_relevant.length == 0) {\n-            addInnerClassesAttr = false;\n-        }\n-        if (addInnerClassesAttr) {\n-            final Attribute[] originalAttrs = classFile.attributes;\n-            final Attribute[] newAttrs = new Attribute[originalAttrs.length + 1];\n-            for (int index5 = 0; index5 < originalAttrs.length; ++index5) {\n-                newAttrs[index5] = originalAttrs[index5];\n-            }\n-            newAttrs[newAttrs.length - 1] = (Attribute)innerClassesAttribute;\n-            classFile.attributes = newAttrs;\n-            cp.addWithNestedEntries((ClassFileEntry)innerClassesAttribute);\n-        }\n-        cp.resolve(this);\n-        classFile.accessFlags = (int)this.classBands.getClassFlags()[classNum];\n-        classFile.thisClass = cp.indexOf(cfThis);\n-        classFile.superClass = cp.indexOf(cfSuper);\n-        classFile.interfaces = new int[cfInterfaces.length];\n-        for (i = 0; i < cfInterfaces.length; ++i) {\n-            classFile.interfaces[i] = cp.indexOf(cfInterfaces[i]);\n+        final IcTuple[] relevantIcTuples = this.getIcBands().getRelevantIcTuples(s, pool);\n+        final List computeIcStored = this.computeIcStored(array2, relevantIcTuples);\n+        for (int n9 = 0; n9 < computeIcStored.size(); ++n9) {\n+            final IcTuple icTuple = (IcTuple)computeIcStored.get(n9);\n+            final int thisClassIndex = icTuple.thisClassIndex();\n+            final int outerClassIndex = icTuple.outerClassIndex();\n+            final int simpleClassNameIndex = icTuple.simpleClassNameIndex();\n+            final String thisClassString = icTuple.thisClassString();\n+            final String outerClassString = icTuple.outerClassString();\n+            final String simpleClassName = icTuple.simpleClassName();\n+            CPUTF8 cputf8 = null;\n+            CPClass cpClass = null;\n+            final CPClass cpClass2 = (thisClassIndex != -1) ? this.cpBands.cpClassValue(thisClassIndex) : this.cpBands.cpClassValue(thisClassString);\n+            if (!icTuple.isAnonymous()) {\n+                cputf8 = ((simpleClassNameIndex != -1) ? this.cpBands.cpUTF8Value(simpleClassNameIndex) : this.cpBands.cpUTF8Value(simpleClassName));\n+            }\n+            if (icTuple.isMember()) {\n+                cpClass = ((outerClassIndex != -1) ? this.cpBands.cpClassValue(outerClassIndex) : this.cpBands.cpClassValue(outerClassString));\n+            }\n+            innerClassesAttribute.addInnerClassesEntry(cpClass2, cpClass, cputf8, icTuple.F);\n+            b = true;\n+        }\n+        if (b2 && array2.length == 0) {\n+            b = false;\n+        }\n+        if (!b2 && relevantIcTuples.length == 0) {\n+            b = false;\n+        }\n+        if (b) {\n+            final Attribute[] attributes2 = classFile.attributes;\n+            final Attribute[] attributes3 = new Attribute[attributes2.length + 1];\n+            for (int n10 = 0; n10 < attributes2.length; ++n10) {\n+                attributes3[n10] = attributes2[n10];\n+            }\n+            attributes3[attributes3.length - 1] = (Attribute)innerClassesAttribute;\n+            classFile.attributes = attributes3;\n+            pool.addWithNestedEntries((ClassFileEntry)innerClassesAttribute);\n+        }\n+        pool.resolve(this);\n+        classFile.accessFlags = (int)this.classBands.getClassFlags()[n];\n+        classFile.thisClass = pool.indexOf(add);\n+        classFile.superClass = pool.indexOf(add2);\n+        classFile.interfaces = new int[array.length];\n+        for (int n11 = 0; n11 < array.length; ++n11) {\n+            classFile.interfaces[n11] = pool.indexOf(array[n11]);\n         }\n-        classFile.fields = cfFields;\n-        classFile.methods = cfMethods;\n+        classFile.fields = fields;\n+        classFile.methods = methods;\n         return classFile;\n     }\n     \n-    private List computeIcStored(final IcTuple[] ic_local, final IcTuple[] ic_relevant) {\n-        final List result = new ArrayList(ic_relevant.length);\n-        final List duplicates = new ArrayList(ic_relevant.length);\n-        final Set isInResult = new HashSet(ic_relevant.length);\n-        if (ic_local != null) {\n-            for (int index = 0; index < ic_local.length; ++index) {\n-                if (isInResult.add(ic_local[index])) {\n-                    result.add(ic_local[index]);\n+    private List computeIcStored(final IcTuple[] array, final IcTuple[] array2) {\n+        final ArrayList list = new ArrayList(array2.length);\n+        final ArrayList list2 = new ArrayList(array2.length);\n+        final HashSet set = new HashSet(array2.length);\n+        if (array != null) {\n+            for (int i = 0; i < array.length; ++i) {\n+                if (set.add(array[i])) {\n+                    list.add(array[i]);\n                 }\n             }\n         }\n-        for (int index = 0; index < ic_relevant.length; ++index) {\n-            if (isInResult.add(ic_relevant[index])) {\n-                result.add(ic_relevant[index]);\n+        for (int j = 0; j < array2.length; ++j) {\n+            if (set.add(array2[j])) {\n+                list.add(array2[j]);\n             }\n             else {\n-                duplicates.add(ic_relevant[index]);\n+                list2.add(array2[j]);\n             }\n         }\n-        for (int index = 0; index < duplicates.size(); ++index) {\n-            final IcTuple tuple = (IcTuple)duplicates.get(index);\n-            result.remove(tuple);\n+        for (int k = 0; k < list2.size(); ++k) {\n+            list.remove(list2.get(k));\n         }\n-        return result;\n+        return list;\n     }\n     \n-    private void readSegment(final InputStream in) throws IOException, Pack200Exception {\n+    private void readSegment(final InputStream inputStream) throws IOException, Pack200Exception {\n         this.log(2, \"-------\");\n-        (this.cpBands = new CpBands(this)).read(in);\n-        (this.attrDefinitionBands = new AttrDefinitionBands(this)).read(in);\n-        (this.icBands = new IcBands(this)).read(in);\n-        (this.classBands = new ClassBands(this)).read(in);\n-        (this.bcBands = new BcBands(this)).read(in);\n-        (this.fileBands = new FileBands(this)).read(in);\n+        (this.cpBands = new CpBands(this)).read(inputStream);\n+        (this.attrDefinitionBands = new AttrDefinitionBands(this)).read(inputStream);\n+        (this.icBands = new IcBands(this)).read(inputStream);\n+        (this.classBands = new ClassBands(this)).read(inputStream);\n+        (this.bcBands = new BcBands(this)).read(inputStream);\n+        (this.fileBands = new FileBands(this)).read(inputStream);\n         this.fileBands.processFileBits();\n     }\n     \n     private void parseSegment() throws IOException, Pack200Exception {\n         this.header.unpack();\n         this.cpBands.unpack();\n         this.attrDefinitionBands.unpack();\n         this.icBands.unpack();\n         this.classBands.unpack();\n         this.bcBands.unpack();\n         this.fileBands.unpack();\n-        int classNum = 0;\n+        int n = 0;\n         final int numberOfFiles = this.header.getNumberOfFiles();\n         final String[] fileName = this.fileBands.getFileName();\n         final int[] fileOptions = this.fileBands.getFileOptions();\n         final SegmentOptions options = this.header.getOptions();\n         this.classFilesContents = new byte[numberOfFiles][];\n         this.fileDeflate = new boolean[numberOfFiles];\n         this.fileIsClass = new boolean[numberOfFiles];\n-        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        final DataOutputStream dos = new DataOutputStream(bos);\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final DataOutputStream dataOutputStream = new DataOutputStream(out);\n         for (int i = 0; i < numberOfFiles; ++i) {\n-            String name = fileName[i];\n-            final boolean nameIsEmpty = name == null || name.equals(\"\");\n-            final boolean isClass = (fileOptions[i] & 0x2) == 0x2 || nameIsEmpty;\n-            if (isClass && nameIsEmpty) {\n-                name = this.cpBands.getCpClass()[this.classBands.getClassThisInts()[classNum]] + \".class\";\n-                fileName[i] = name;\n+            final String s = fileName[i];\n+            final boolean b = s == null || s.equals(\"\");\n+            final boolean b2 = (fileOptions[i] & 0x2) == 0x2 || b;\n+            if (b2 && b) {\n+                fileName[i] = this.cpBands.getCpClass()[this.classBands.getClassThisInts()[n]] + \".class\";\n             }\n             if (!this.overrideDeflateHint) {\n                 this.fileDeflate[i] = ((fileOptions[i] & 0x1) == 0x1 || options.shouldDeflate());\n             }\n             else {\n                 this.fileDeflate[i] = this.deflateHint;\n             }\n-            this.fileIsClass[i] = isClass;\n-            if (isClass) {\n-                final ClassFile classFile = this.buildClassFile(classNum);\n-                classFile.write(dos);\n-                dos.flush();\n-                this.classFilesContents[classNum] = bos.toByteArray();\n-                bos.reset();\n-                ++classNum;\n+            this.fileIsClass[i] = b2;\n+            if (b2) {\n+                this.buildClassFile(n).write(dataOutputStream);\n+                dataOutputStream.flush();\n+                this.classFilesContents[n] = out.toByteArray();\n+                out.reset();\n+                ++n;\n             }\n         }\n     }\n     \n-    public void unpack(final InputStream in, final JarOutputStream out) throws IOException, Pack200Exception {\n-        this.unpackRead(in);\n+    public void unpack(final InputStream inputStream, final JarOutputStream jarOutputStream) throws IOException, Pack200Exception {\n+        this.unpackRead(inputStream);\n         this.unpackProcess();\n-        this.unpackWrite(out);\n+        this.unpackWrite(jarOutputStream);\n     }\n     \n     void unpackRead(InputStream in) throws IOException, Pack200Exception {\n         if (!in.markSupported()) {\n             in = new BufferedInputStream(in);\n         }\n         (this.header = new SegmentHeader(this)).read(in);\n-        final int size = (int)this.header.getArchiveSize() - this.header.getArchiveSizeOffset();\n+        final int n = (int)this.header.getArchiveSize() - this.header.getArchiveSizeOffset();\n         if (this.doPreRead && this.header.getArchiveSize() != 0L) {\n-            final byte[] data = new byte[size];\n-            in.read(data);\n-            this.internalBuffer = new BufferedInputStream(new ByteArrayInputStream(data));\n+            final byte[] array = new byte[n];\n+            in.read(array);\n+            this.internalBuffer = new BufferedInputStream(new ByteArrayInputStream(array));\n         }\n         else {\n             this.readSegment(in);\n         }\n     }\n     \n     void unpackProcess() throws IOException, Pack200Exception {\n         if (this.internalBuffer != null) {\n             this.readSegment(this.internalBuffer);\n         }\n         this.parseSegment();\n     }\n     \n-    void unpackWrite(final JarOutputStream out) throws IOException, Pack200Exception {\n-        this.writeJar(out);\n+    void unpackWrite(final JarOutputStream jarOutputStream) throws IOException, Pack200Exception {\n+        this.writeJar(jarOutputStream);\n         if (this.logStream != null) {\n             this.logStream.close();\n         }\n     }\n     \n-    public void writeJar(final JarOutputStream out) throws IOException, Pack200Exception {\n+    public void writeJar(final JarOutputStream jarOutputStream) throws IOException, Pack200Exception {\n         final String[] fileName = this.fileBands.getFileName();\n         final int[] fileModtime = this.fileBands.getFileModtime();\n         final long[] fileSize = this.fileBands.getFileSize();\n         final byte[][] fileBits = this.fileBands.getFileBits();\n-        int classNum = 0;\n+        int n = 0;\n         final int numberOfFiles = this.header.getNumberOfFiles();\n         final long archiveModtime = this.header.getArchiveModtime();\n         for (int i = 0; i < numberOfFiles; ++i) {\n             final String name = fileName[i];\n-            final long modtime = 1000L * (archiveModtime + fileModtime[i]);\n-            final boolean deflate = this.fileDeflate[i];\n-            final JarEntry entry = new JarEntry(name);\n-            if (deflate) {\n-                entry.setMethod(8);\n+            final long n2 = 1000L * (archiveModtime + fileModtime[i]);\n+            final boolean b = this.fileDeflate[i];\n+            final JarEntry ze = new JarEntry(name);\n+            if (b) {\n+                ze.setMethod(8);\n             }\n             else {\n-                entry.setMethod(0);\n-                final CRC32 crc = new CRC32();\n+                ze.setMethod(0);\n+                final CRC32 crc32 = new CRC32();\n                 if (this.fileIsClass[i]) {\n-                    crc.update(this.classFilesContents[classNum]);\n-                    entry.setSize(this.classFilesContents[classNum].length);\n+                    crc32.update(this.classFilesContents[n]);\n+                    ze.setSize(this.classFilesContents[n].length);\n                 }\n                 else {\n-                    crc.update(fileBits[i]);\n-                    entry.setSize(fileSize[i]);\n+                    crc32.update(fileBits[i]);\n+                    ze.setSize(fileSize[i]);\n                 }\n-                entry.setCrc(crc.getValue());\n+                ze.setCrc(crc32.getValue());\n             }\n-            entry.setTime(modtime - (long)TimeZone.getDefault().getRawOffset());\n-            out.putNextEntry(entry);\n+            ze.setTime(n2 - (long)TimeZone.getDefault().getRawOffset());\n+            jarOutputStream.putNextEntry(ze);\n             if (this.fileIsClass[i]) {\n-                entry.setSize(this.classFilesContents[classNum].length);\n-                out.write(this.classFilesContents[classNum]);\n-                ++classNum;\n+                ze.setSize(this.classFilesContents[n].length);\n+                jarOutputStream.write(this.classFilesContents[n]);\n+                ++n;\n             }\n             else {\n-                entry.setSize(fileSize[i]);\n-                out.write(fileBits[i]);\n+                ze.setSize(fileSize[i]);\n+                jarOutputStream.write(fileBits[i]);\n             }\n         }\n     }\n     \n     public SegmentConstantPool getConstantPool() {\n         return this.cpBands.getConstantPool();\n     }\n     \n     public SegmentHeader getSegmentHeader() {\n         return this.header;\n     }\n     \n-    public void setPreRead(final boolean value) {\n-        this.doPreRead = value;\n+    public void setPreRead(final boolean doPreRead) {\n+        this.doPreRead = doPreRead;\n     }\n     \n     protected AttrDefinitionBands getAttrDefinitionBands() {\n         return this.attrDefinitionBands;\n     }\n     \n     protected ClassBands getClassBands() {\n@@ -395,21 +369,21 @@\n         return this.icBands;\n     }\n     \n     public void setLogLevel(final int logLevel) {\n         this.logLevel = logLevel;\n     }\n     \n-    public void setLogStream(final OutputStream logStream) {\n-        this.logStream = new PrintWriter(logStream);\n+    public void setLogStream(final OutputStream out) {\n+        this.logStream = new PrintWriter(out);\n     }\n     \n-    public void log(final int logLevel, final String message) {\n-        if (this.logLevel >= logLevel) {\n-            this.logStream.println(message);\n+    public void log(final int n, final String x) {\n+        if (this.logLevel >= n) {\n+            this.logStream.println(x);\n         }\n     }\n     \n     public void overrideDeflateHint(final boolean deflateHint) {\n         this.overrideDeflateHint = true;\n         this.deflateHint = deflateHint;\n     }\n"}]}
