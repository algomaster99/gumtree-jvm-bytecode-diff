{"diffoscope-json-version": 1, "source1": "first/BeanHelper.class", "source2": "second/BeanHelper.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -30,224 +30,220 @@\n     private final Map<String, BeanFactory> beanFactories;\n     private final BeanFactory defaultBeanFactory;\n     \n     public BeanHelper() {\n         this(null);\n     }\n     \n-    public BeanHelper(final BeanFactory defFactory) {\n+    public BeanHelper(final BeanFactory beanFactory) {\n         this.beanFactories = Collections.synchronizedMap(new HashMap<String, BeanFactory>());\n-        this.defaultBeanFactory = (BeanFactory)((defFactory != null) ? defFactory : DefaultBeanFactory.INSTANCE);\n+        this.defaultBeanFactory = (BeanFactory)((beanFactory != null) ? beanFactory : DefaultBeanFactory.INSTANCE);\n     }\n     \n-    public void registerBeanFactory(final String name, final BeanFactory factory) {\n-        if (name == null) {\n+    public void registerBeanFactory(final String s, final BeanFactory beanFactory) {\n+        if (s == null) {\n             throw new IllegalArgumentException(\"Name for bean factory must not be null!\");\n         }\n-        if (factory == null) {\n+        if (beanFactory == null) {\n             throw new IllegalArgumentException(\"Bean factory must not be null!\");\n         }\n-        this.beanFactories.put(name, factory);\n+        this.beanFactories.put(s, beanFactory);\n     }\n     \n-    public BeanFactory deregisterBeanFactory(final String name) {\n-        return this.beanFactories.remove(name);\n+    public BeanFactory deregisterBeanFactory(final String s) {\n+        return this.beanFactories.remove(s);\n     }\n     \n     public Set<String> registeredFactoryNames() {\n         return this.beanFactories.keySet();\n     }\n     \n     public BeanFactory getDefaultBeanFactory() {\n         return this.defaultBeanFactory;\n     }\n     \n-    public void initBean(final Object bean, final BeanDeclaration data) {\n-        initBeanProperties(bean, data);\n-        final Map<String, Object> nestedBeans = data.getNestedBeanDeclarations();\n-        if (nestedBeans != null) {\n-            if (bean instanceof Collection) {\n-                final Collection<Object> coll = (Collection)bean;\n-                if (nestedBeans.size() == 1) {\n-                    final Map.Entry<String, Object> e = (Map.Entry<String, Object>)nestedBeans.entrySet().iterator().next();\n-                    final String propName = (String)e.getKey();\n-                    final Class<?> defaultClass = getDefaultClass(bean, propName);\n-                    if (e.getValue() instanceof List) {\n-                        final List<BeanDeclaration> decls = (List<BeanDeclaration>)e.getValue();\n-                        for (final BeanDeclaration decl : decls) {\n-                            coll.add(this.createBean(decl, defaultClass));\n+    public void initBean(final Object o, final BeanDeclaration beanDeclaration) {\n+        initBeanProperties(o, beanDeclaration);\n+        final Map nestedBeanDeclarations = beanDeclaration.getNestedBeanDeclarations();\n+        if (nestedBeanDeclarations != null) {\n+            if (o instanceof Collection) {\n+                final Collection collection = (Collection)o;\n+                if (nestedBeanDeclarations.size() == 1) {\n+                    final Map.Entry entry = (Map.Entry)nestedBeanDeclarations.entrySet().iterator().next();\n+                    final Class<?> defaultClass = getDefaultClass(o, entry.getKey());\n+                    if (entry.getValue() instanceof List) {\n+                        final Iterator iterator = ((List)entry.getValue()).iterator();\n+                        while (iterator.hasNext()) {\n+                            collection.add(this.createBean((BeanDeclaration)iterator.next(), defaultClass));\n                         }\n                     }\n                     else {\n-                        final BeanDeclaration decl2 = (BeanDeclaration)e.getValue();\n-                        coll.add(this.createBean(decl2, defaultClass));\n+                        collection.add(this.createBean((BeanDeclaration)entry.getValue(), defaultClass));\n                     }\n                 }\n             }\n             else {\n-                for (final Map.Entry<String, Object> e : nestedBeans.entrySet()) {\n-                    final String propName = (String)e.getKey();\n-                    final Class<?> defaultClass = getDefaultClass(bean, propName);\n-                    final Object prop = e.getValue();\n-                    if (prop instanceof Collection) {\n-                        final Collection<Object> beanCollection = createPropertyCollection(propName, defaultClass);\n-                        for (final Object elemDef : (Collection)prop) {\n-                            beanCollection.add(this.createBean((BeanDeclaration)elemDef));\n+                for (final Map.Entry entry2 : nestedBeanDeclarations.entrySet()) {\n+                    final String s = (String)entry2.getKey();\n+                    final Class<?> defaultClass2 = getDefaultClass(o, s);\n+                    final Object value = entry2.getValue();\n+                    if (value instanceof Collection) {\n+                        final Collection<Object> propertyCollection = createPropertyCollection(s, defaultClass2);\n+                        final Iterator iterator3 = ((Collection)value).iterator();\n+                        while (iterator3.hasNext()) {\n+                            propertyCollection.add(this.createBean((BeanDeclaration)iterator3.next()));\n                         }\n-                        initProperty(bean, propName, beanCollection);\n+                        initProperty(o, s, propertyCollection);\n                     }\n                     else {\n-                        initProperty(bean, propName, this.createBean((BeanDeclaration)e.getValue(), defaultClass));\n+                        initProperty(o, s, this.createBean((BeanDeclaration)entry2.getValue(), defaultClass2));\n                     }\n                 }\n             }\n         }\n     }\n     \n-    public static void initBeanProperties(final Object bean, final BeanDeclaration data) {\n-        final Map<String, Object> properties = data.getBeanProperties();\n-        if (properties != null) {\n-            for (final Map.Entry<String, Object> e : properties.entrySet()) {\n-                final String propName = (String)e.getKey();\n-                initProperty(bean, propName, e.getValue());\n+    public static void initBeanProperties(final Object o, final BeanDeclaration beanDeclaration) {\n+        final Map beanProperties = beanDeclaration.getBeanProperties();\n+        if (beanProperties != null) {\n+            for (final Map.Entry entry : beanProperties.entrySet()) {\n+                initProperty(o, (String)entry.getKey(), entry.getValue());\n             }\n         }\n     }\n     \n-    public static DynaBean createWrapDynaBean(final Object bean) {\n-        if (bean == null) {\n+    public static DynaBean createWrapDynaBean(final Object o) {\n+        if (o == null) {\n             throw new IllegalArgumentException(\"Bean must not be null!\");\n         }\n-        final WrapDynaClass dynaClass = WrapDynaClass.createDynaClass((Class)bean.getClass(), BeanHelper.BEAN_UTILS_BEAN.getPropertyUtils());\n-        return (DynaBean)new WrapDynaBean(bean, dynaClass);\n+        return (DynaBean)new WrapDynaBean(o, WrapDynaClass.createDynaClass((Class)o.getClass(), BeanHelper.BEAN_UTILS_BEAN.getPropertyUtils()));\n     }\n     \n-    public static void copyProperties(final Object dest, final Object orig) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {\n-        BeanHelper.BEAN_UTILS_BEAN.getPropertyUtils().copyProperties(dest, orig);\n+    public static void copyProperties(final Object o, final Object o2) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {\n+        BeanHelper.BEAN_UTILS_BEAN.getPropertyUtils().copyProperties(o, o2);\n     }\n     \n-    private static Class<?> getDefaultClass(final Object bean, final String propName) {\n+    private static Class<?> getDefaultClass(final Object o, final String s) {\n         try {\n-            final PropertyDescriptor desc = BeanHelper.BEAN_UTILS_BEAN.getPropertyUtils().getPropertyDescriptor(bean, propName);\n-            if (desc == null) {\n+            final PropertyDescriptor propertyDescriptor = BeanHelper.BEAN_UTILS_BEAN.getPropertyUtils().getPropertyDescriptor(o, s);\n+            if (propertyDescriptor == null) {\n                 return null;\n             }\n-            return desc.getPropertyType();\n+            return propertyDescriptor.getPropertyType();\n         }\n         catch (final Exception ex) {\n             return null;\n         }\n     }\n     \n-    private static void initProperty(final Object bean, final String propName, final Object value) {\n-        if (!isPropertyWriteable(bean, propName)) {\n-            throw new ConfigurationRuntimeException(\"Property \" + propName + \" cannot be set on \" + bean.getClass().getName());\n+    private static void initProperty(final Object o, final String str, final Object o2) {\n+        if (!isPropertyWriteable(o, str)) {\n+            throw new ConfigurationRuntimeException(\"Property \" + str + \" cannot be set on \" + o.getClass().getName());\n         }\n         try {\n-            BeanHelper.BEAN_UTILS_BEAN.setProperty(bean, propName, value);\n+            BeanHelper.BEAN_UTILS_BEAN.setProperty(o, str, o2);\n         }\n-        catch (final IllegalAccessException iaex) {\n-            throw new ConfigurationRuntimeException((Throwable)iaex);\n+        catch (final IllegalAccessException ex) {\n+            throw new ConfigurationRuntimeException((Throwable)ex);\n         }\n-        catch (final InvocationTargetException itex) {\n-            throw new ConfigurationRuntimeException((Throwable)itex);\n+        catch (final InvocationTargetException ex2) {\n+            throw new ConfigurationRuntimeException((Throwable)ex2);\n         }\n     }\n     \n-    private static Collection<Object> createPropertyCollection(final String propName, final Class<?> propertyClass) {\n-        Collection<Object> beanCollection;\n-        if (List.class.isAssignableFrom(propertyClass)) {\n-            beanCollection = new ArrayList<Object>();\n+    private static Collection<Object> createPropertyCollection(final String str, final Class<?> clazz) {\n+        Cloneable cloneable;\n+        if (List.class.isAssignableFrom(clazz)) {\n+            cloneable = new ArrayList<Object>();\n         }\n         else {\n-            if (!Set.class.isAssignableFrom(propertyClass)) {\n-                throw new UnsupportedOperationException(\"Unable to handle collection of type : \" + propertyClass.getName() + \" for property \" + propName);\n+            if (!Set.class.isAssignableFrom(clazz)) {\n+                throw new UnsupportedOperationException(\"Unable to handle collection of type : \" + clazz.getName() + \" for property \" + str);\n             }\n-            beanCollection = new TreeSet<Object>();\n+            cloneable = new TreeSet<Object>();\n         }\n-        return beanCollection;\n+        return (Collection<Object>)cloneable;\n     }\n     \n-    public static void setProperty(final Object bean, final String propName, final Object value) {\n-        if (isPropertyWriteable(bean, propName)) {\n-            initProperty(bean, propName, value);\n+    public static void setProperty(final Object o, final String s, final Object o2) {\n+        if (isPropertyWriteable(o, s)) {\n+            initProperty(o, s, o2);\n         }\n     }\n     \n-    public Object createBean(final BeanDeclaration data, final Class<?> defaultClass, final Object param) {\n-        if (data == null) {\n+    public Object createBean(final BeanDeclaration beanDeclaration, final Class<?> clazz, final Object o) {\n+        if (beanDeclaration == null) {\n             throw new IllegalArgumentException(\"Bean declaration must not be null!\");\n         }\n-        final BeanFactory factory = this.fetchBeanFactory(data);\n-        final BeanCreationContext bcc = this.createBeanCreationContext(data, defaultClass, param, factory);\n+        final BeanFactory fetchBeanFactory = this.fetchBeanFactory(beanDeclaration);\n+        final BeanCreationContext beanCreationContext = this.createBeanCreationContext(beanDeclaration, clazz, o, fetchBeanFactory);\n         try {\n-            return factory.createBean(bcc);\n+            return fetchBeanFactory.createBean(beanCreationContext);\n         }\n         catch (final Exception ex) {\n             throw new ConfigurationRuntimeException((Throwable)ex);\n         }\n     }\n     \n-    public Object createBean(final BeanDeclaration data, final Class<?> defaultClass) {\n-        return this.createBean(data, defaultClass, null);\n+    public Object createBean(final BeanDeclaration beanDeclaration, final Class<?> clazz) {\n+        return this.createBean(beanDeclaration, clazz, null);\n     }\n     \n-    public Object createBean(final BeanDeclaration data) {\n-        return this.createBean(data, null);\n+    public Object createBean(final BeanDeclaration beanDeclaration) {\n+        return this.createBean(beanDeclaration, null);\n     }\n     \n-    static Class<?> loadClass(final String name) throws ClassNotFoundException {\n-        return ClassUtils.getClass(name);\n+    static Class<?> loadClass(final String s) throws ClassNotFoundException {\n+        return ClassUtils.getClass(s);\n     }\n     \n-    private static boolean isPropertyWriteable(final Object bean, final String propName) {\n-        return BeanHelper.BEAN_UTILS_BEAN.getPropertyUtils().isWriteable(bean, propName);\n+    private static boolean isPropertyWriteable(final Object o, final String s) {\n+        return BeanHelper.BEAN_UTILS_BEAN.getPropertyUtils().isWriteable(o, s);\n     }\n     \n-    private static Class<?> fetchBeanClass(final BeanDeclaration data, final Class<?> defaultClass, final BeanFactory factory) {\n-        final String clsName = data.getBeanClassName();\n-        if (clsName != null) {\n+    private static Class<?> fetchBeanClass(final BeanDeclaration beanDeclaration, final Class<?> clazz, final BeanFactory beanFactory) {\n+        final String beanClassName = beanDeclaration.getBeanClassName();\n+        if (beanClassName != null) {\n             try {\n-                return loadClass(clsName);\n+                return loadClass(beanClassName);\n             }\n-            catch (final ClassNotFoundException cex) {\n-                throw new ConfigurationRuntimeException((Throwable)cex);\n+            catch (final ClassNotFoundException ex) {\n+                throw new ConfigurationRuntimeException((Throwable)ex);\n             }\n         }\n-        if (defaultClass != null) {\n-            return defaultClass;\n+        if (clazz != null) {\n+            return clazz;\n         }\n-        final Class<?> clazz = factory.getDefaultBeanClass();\n-        if (clazz == null) {\n+        final Class defaultBeanClass = beanFactory.getDefaultBeanClass();\n+        if (defaultBeanClass == null) {\n             throw new ConfigurationRuntimeException(\"Bean class is not specified!\");\n         }\n-        return clazz;\n+        return defaultBeanClass;\n     }\n     \n-    private BeanFactory fetchBeanFactory(final BeanDeclaration data) {\n-        final String factoryName = data.getBeanFactoryName();\n-        if (factoryName == null) {\n+    private BeanFactory fetchBeanFactory(final BeanDeclaration beanDeclaration) {\n+        final String beanFactoryName = beanDeclaration.getBeanFactoryName();\n+        if (beanFactoryName == null) {\n             return this.getDefaultBeanFactory();\n         }\n-        final BeanFactory factory = (BeanFactory)this.beanFactories.get(factoryName);\n-        if (factory == null) {\n-            throw new ConfigurationRuntimeException(\"Unknown bean factory: \" + factoryName);\n+        final BeanFactory beanFactory = (BeanFactory)this.beanFactories.get(beanFactoryName);\n+        if (beanFactory == null) {\n+            throw new ConfigurationRuntimeException(\"Unknown bean factory: \" + beanFactoryName);\n         }\n-        return factory;\n+        return beanFactory;\n     }\n     \n-    private BeanCreationContext createBeanCreationContext(final BeanDeclaration data, final Class<?> defaultClass, final Object param, final BeanFactory factory) {\n-        final Class<?> beanClass = fetchBeanClass(data, defaultClass, factory);\n-        return (BeanCreationContext)new BeanHelper.BeanCreationContextImpl(this, (Class)beanClass, data, param, (BeanHelper.BeanHelper$1)null);\n+    private BeanCreationContext createBeanCreationContext(final BeanDeclaration beanDeclaration, final Class<?> clazz, final Object o, final BeanFactory beanFactory) {\n+        return (BeanCreationContext)new BeanHelper.BeanCreationContextImpl(this, (Class)fetchBeanClass(beanDeclaration, clazz, beanFactory), beanDeclaration, o, (BeanHelper.BeanHelper$1)null);\n     }\n     \n     private static BeanUtilsBean initBeanUtilsBean() {\n-        final PropertyUtilsBean propUtilsBean = new PropertyUtilsBean();\n-        propUtilsBean.addBeanIntrospector((BeanIntrospector)new FluentPropertyBeanIntrospector());\n-        return new BeanUtilsBean(new ConvertUtilsBean(), propUtilsBean);\n+        final PropertyUtilsBean propertyUtilsBean = new PropertyUtilsBean();\n+        propertyUtilsBean.addBeanIntrospector((BeanIntrospector)new FluentPropertyBeanIntrospector());\n+        return new BeanUtilsBean(new ConvertUtilsBean(), propertyUtilsBean);\n     }\n     \n     static {\n         INSTANCE = new BeanHelper();\n         BEAN_UTILS_BEAN = initBeanUtilsBean();\n     }\n }\n"}]}
