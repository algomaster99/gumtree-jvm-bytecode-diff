{"diffoscope-json-version": 1, "source1": "first/Pass3bVerifier.class", "source2": "second/Pass3bVerifier.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -35,15 +35,15 @@\n     public Pass3bVerifier(final Verifier myOwner, final int methodNo) {\n         this.myOwner = myOwner;\n         this.methodNo = methodNo;\n     }\n     \n     private void circulationPump(final MethodGen m, final ControlFlowGraph cfg, final InstructionContext start, final Frame vanillaFrame, final InstConstraintVisitor icv, final ExecutionVisitor ev) {\n         final Random random = new Random();\n-        final Pass3bVerifier.InstructionContextQueue icq = new Pass3bVerifier.InstructionContextQueue((Pass3bVerifier.Pass3bVerifier$1)null);\n+        final Pass3bVerifier.InstructionContextQueue icq = new Pass3bVerifier.InstructionContextQueue((Pass3bVerifier.InstructionContextQueue)null);\n         start.execute(vanillaFrame, new ArrayList(), icv, ev);\n         icq.add(start, new ArrayList());\n         while (!icq.isEmpty()) {\n             final InstructionContext u = icq.getIC(0);\n             final ArrayList<InstructionContext> ec = icq.getEC(0);\n             icq.remove(0);\n             final ArrayList<InstructionContext> oldchain = (ArrayList)ec.clone();\n@@ -79,26 +79,28 @@\n                 }\n                 if (theSuccessor.execute(u.getOutFrame((ArrayList)oldchain), (ArrayList)newchain, icv, ev)) {\n                     final ArrayList<InstructionContext> newchainClone = (ArrayList)newchain.clone();\n                     icq.add(theSuccessor, (ArrayList)newchainClone);\n                 }\n             }\n             else {\n-                final InstructionContext[] successors;\n-                final InstructionContext[] succs = successors = u.getSuccessors();\n-                for (final InstructionContext v : successors) {\n+                final InstructionContext[] succs = u.getSuccessors();\n+                InstructionContext[] array;\n+                for (int length = (array = succs).length, k = 0; k < length; ++k) {\n+                    final InstructionContext v = array[k];\n                     if (v.execute(u.getOutFrame((ArrayList)oldchain), (ArrayList)newchain, icv, ev)) {\n                         final ArrayList<InstructionContext> newchainClone2 = (ArrayList)newchain.clone();\n                         icq.add(v, (ArrayList)newchainClone2);\n                     }\n                 }\n             }\n-            final ExceptionHandler[] exceptionHandlers;\n-            final ExceptionHandler[] excHds = exceptionHandlers = u.getExceptionHandlers();\n-            for (final ExceptionHandler excHd : exceptionHandlers) {\n+            final ExceptionHandler[] excHds = u.getExceptionHandlers();\n+            ExceptionHandler[] array2;\n+            for (int length2 = (array2 = excHds).length, l = 0; l < length2; ++l) {\n+                final ExceptionHandler excHd = array2[l];\n                 final InstructionContext v2 = cfg.contextOf(excHd.getHandlerStart());\n                 if (v2.execute(new Frame(u.getOutFrame((ArrayList)oldchain).getLocals(), new OperandStack(u.getOutFrame((ArrayList)oldchain).getStack().maxStack(), (excHd.getExceptionType() == null) ? Type.THROWABLE : excHd.getExceptionType())), new ArrayList(), icv, ev)) {\n                     icq.add(v2, new ArrayList());\n                 }\n             }\n         }\n         InstructionHandle ih = start.getInstruction();\n@@ -127,18 +129,18 @@\n                     returnedType = (Type)Type.VOID;\n                 }\n                 if (returnedType == null) {\n                     continue;\n                 }\n                 if (returnedType instanceof ReferenceType) {\n                     try {\n-                        if (((ReferenceType)returnedType).isCastableTo(m.getReturnType())) {\n+                        if (!((ReferenceType)returnedType).isCastableTo(m.getReturnType())) {\n+                            this.invalidReturnTypeError(returnedType, m);\n                             continue;\n                         }\n-                        this.invalidReturnTypeError(returnedType, m);\n                         continue;\n                     }\n                     catch (final ClassNotFoundException e) {\n                         throw new IllegalArgumentException(e);\n                     }\n                 }\n                 if (returnedType.equals((Object)m.getReturnType().normalizeForStackOrLocal())) {\n"}]}
