{"diffoscope-json-version": 1, "source1": "first/CompositeConfiguration.class", "source2": "second/CompositeConfiguration.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -2,15 +2,14 @@\n package org.apache.commons.configuration2;\n \n import org.apache.commons.configuration2.convert.ListDelimiterHandler;\n import org.apache.commons.configuration2.ex.ConfigurationRuntimeException;\n import java.util.ListIterator;\n import java.util.ArrayList;\n import java.util.Set;\n-import java.util.Objects;\n import java.util.LinkedHashSet;\n import java.util.Iterator;\n import java.util.function.Consumer;\n import java.util.Collection;\n import java.util.LinkedList;\n import java.util.List;\n \n@@ -64,14 +63,15 @@\n                     ((AbstractConfiguration)config).setThrowExceptionOnMissing(this.isThrowExceptionOnMissing());\n                 }\n             }\n         }\n         finally {\n             this.endWrite();\n         }\n+        this.endWrite();\n     }\n     \n     public void addConfigurationFirst(final Configuration config) {\n         this.addConfigurationFirst(config, false);\n     }\n     \n     public void addConfigurationFirst(final Configuration config, final boolean asInMemory) {\n@@ -87,26 +87,28 @@\n                     ((AbstractConfiguration)config).setThrowExceptionOnMissing(this.isThrowExceptionOnMissing());\n                 }\n             }\n         }\n         finally {\n             this.endWrite();\n         }\n+        this.endWrite();\n     }\n     \n     public void removeConfiguration(final Configuration config) {\n         this.beginWrite(false);\n         try {\n-            if (!config.equals((Object)this.inMemoryConfiguration)) {\n+            if (!config.equals(this.inMemoryConfiguration)) {\n                 this.configList.remove(config);\n             }\n         }\n         finally {\n             this.endWrite();\n         }\n+        this.endWrite();\n     }\n     \n     public int getNumberOfConfigurations() {\n         this.beginRead(false);\n         try {\n             return this.configList.size();\n         }\n@@ -125,51 +127,39 @@\n     }\n     \n     protected void addPropertyDirect(final String key, final Object token) {\n         this.inMemoryConfiguration.addProperty(key, token);\n     }\n     \n     protected Object getPropertyInternal(final String key) {\n-        return this.configList.stream().filter(config -> config.containsKey(key)).findFirst().map(config -> config.getProperty(key)).orElse(null);\n+        return this.configList.stream().filter(config -> config.containsKey(s)).findFirst().map(config -> config.getProperty(s2)).orElse(null);\n     }\n     \n     protected Iterator<String> getKeysInternal() {\n         final Set<String> keys = new LinkedHashSet<String>();\n-        this.configList.forEach(config -> {\n-            config.getKeys();\n-            Objects.requireNonNull(keys);\n-            final Iterator iterator;\n-            iterator.forEachRemaining(keys::add);\n-            return;\n-        });\n+        this.configList.forEach(config -> config.getKeys().forEachRemaining(set::add));\n         return keys.iterator();\n     }\n     \n     protected Iterator<String> getKeysInternal(final String key) {\n         final Set<String> keys = new LinkedHashSet<String>();\n-        this.configList.forEach(config -> {\n-            config.getKeys(key);\n-            Objects.requireNonNull(keys);\n-            final Iterator iterator;\n-            iterator.forEachRemaining(keys::add);\n-            return;\n-        });\n+        this.configList.forEach(config -> config.getKeys(s).forEachRemaining(set::add));\n         return keys.iterator();\n     }\n     \n     protected boolean isEmptyInternal() {\n         return this.configList.stream().allMatch(ImmutableConfiguration::isEmpty);\n     }\n     \n     protected void clearPropertyDirect(final String key) {\n-        this.configList.forEach(config -> config.clearProperty(key));\n+        this.configList.forEach(config -> config.clearProperty(s));\n     }\n     \n     protected boolean containsKeyInternal(final String key) {\n-        return this.configList.stream().anyMatch(config -> config.containsKey(key));\n+        return this.configList.stream().anyMatch(config -> config.containsKey(s));\n     }\n     \n     public List<Object> getList(final String key, final List<?> defaultValue) {\n         final List<Object> list = new ArrayList<Object>();\n         final Iterator<Configuration> it = this.configList.iterator();\n         while (it.hasNext() && list.isEmpty()) {\n             final Configuration config = (Configuration)it.next();\n@@ -222,15 +212,15 @@\n         try {\n             final CompositeConfiguration copy = (CompositeConfiguration)super.clone();\n             copy.configList = new LinkedList<Configuration>();\n             copy.inMemoryConfiguration = ConfigurationUtils.cloneConfiguration(this.getInMemoryConfiguration());\n             copy.configList.add(copy.inMemoryConfiguration);\n             this.configList.forEach(config -> {\n                 if (config != this.getInMemoryConfiguration()) {\n-                    copy.addConfiguration(ConfigurationUtils.cloneConfiguration(config));\n+                    compositeConfiguration.addConfiguration(ConfigurationUtils.cloneConfiguration(config));\n                 }\n                 return;\n             });\n             copy.cloneInterpolator((AbstractConfiguration)this);\n             return copy;\n         }\n         catch (final CloneNotSupportedException cnex) {\n"}]}
