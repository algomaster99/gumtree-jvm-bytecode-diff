{"diffoscope-json-version": 1, "source1": "first/Pass3aVerifier$InstOperandConstraintVisitor.class", "source2": "second/Pass3aVerifier$InstOperandConstraintVisitor.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -69,15 +69,15 @@\n     InstOperandConstraintVisitor(final Pass3aVerifier this$0, final ConstantPoolGen constantPoolGen) {\n         this.this$0 = this$0;\n         this.constantPoolGen = constantPoolGen;\n     }\n     \n     private int max_locals() {\n         try {\n-            return Repository.lookupClass(Pass3aVerifier.access$000(this.this$0).getClassName()).getMethods()[Pass3aVerifier.access$100(this.this$0)].getCode().getMaxLocals();\n+            return Repository.lookupClass(Pass3aVerifier.access$0(this.this$0).getClassName()).getMethods()[Pass3aVerifier.access$1(this.this$0)].getCode().getMaxLocals();\n         }\n         catch (final ClassNotFoundException e) {\n             throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n         }\n     }\n     \n     private void constraintViolated(final Instruction i, final String message) {\n@@ -142,42 +142,46 @@\n             if (!(c instanceof ConstantFieldref)) {\n                 this.constraintViolated((Instruction)o, \"Indexing a constant that's not a CONSTANT_Fieldref but a '\" + c + \"'.\");\n             }\n             final String field_name = o.getFieldName(this.constantPoolGen);\n             final JavaClass jc = Repository.lookupClass(this.getObjectType(o).getClassName());\n             Field[] fields = jc.getFields();\n             Field f = null;\n-            for (final Field field : fields) {\n+            Field[] array;\n+            for (int length = (array = fields).length, i = 0; i < length; ++i) {\n+                final Field field = array[i];\n                 if (field.getName().equals(field_name)) {\n                     final Type f_type = Type.getType(field.getSignature());\n                     final Type o_type = o.getType(this.constantPoolGen);\n                     if (f_type.equals((Object)o_type)) {\n                         f = field;\n                         break;\n                     }\n                 }\n             }\n             if (f == null) {\n-                final JavaClass[] superClasses;\n-                final JavaClass[] superclasses = superClasses = jc.getSuperClasses();\n-            Label_0315:\n-                for (final JavaClass superclass : superClasses) {\n-                    final Field[] fields2;\n-                    fields = (fields2 = superclass.getFields());\n-                    for (final Field field2 : fields2) {\n+                final JavaClass[] superclasses = jc.getSuperClasses();\n+                JavaClass[] array2;\n+            Label_0309:\n+                for (int length2 = (array2 = superclasses).length, j = 0; j < length2; ++j) {\n+                    final JavaClass superclass = array2[j];\n+                    fields = superclass.getFields();\n+                    Field[] array3;\n+                    for (int length3 = (array3 = fields).length, k = 0; k < length3; ++k) {\n+                        final Field field2 = array3[k];\n                         if (field2.getName().equals(field_name)) {\n                             final Type f_type2 = Type.getType(field2.getSignature());\n                             final Type o_type2 = o.getType(this.constantPoolGen);\n                             if (f_type2.equals((Object)o_type2)) {\n                                 f = field2;\n                                 if ((f.getAccessFlags() & 0x5) == 0x0) {\n                                     f = null;\n-                                    break Label_0315;\n+                                    break Label_0309;\n                                 }\n-                                break Label_0315;\n+                                break Label_0309;\n                             }\n                         }\n                     }\n                 }\n                 if (f == null) {\n                     this.constraintViolated((Instruction)o, \"Referenced field '\" + field_name + \"' does not exist in class '\" + jc.getClassName() + \"'.\");\n                 }\n@@ -231,18 +235,18 @@\n         if (t instanceof ObjectType) {\n             final Verifier v = VerifierFactory.getVerifier(((ObjectType)t).getClassName());\n             final VerificationResult vr = v.doPass2();\n             if (vr.getStatus() != 1) {\n                 this.constraintViolated((Instruction)o, \"Return type class/interface could not be verified successfully: '\" + vr.getMessage() + \"'.\");\n             }\n         }\n-        final Type[] argumentTypes;\n-        final Type[] ts = argumentTypes = o.getArgumentTypes(this.constantPoolGen);\n-        for (int length = argumentTypes.length, i = 0; i < length; ++i) {\n-            final Type element = t = argumentTypes[i];\n+        final Type[] ts = o.getArgumentTypes(this.constantPoolGen);\n+        Type[] array;\n+        for (int length = (array = ts).length, i = 0; i < length; ++i) {\n+            final Type element = t = array[i];\n             if (t instanceof ArrayType) {\n                 t = ((ArrayType)t).getBasicType();\n             }\n             if (t instanceof ObjectType) {\n                 final Verifier v2 = VerifierFactory.getVerifier(((ObjectType)t).getClassName());\n                 final VerificationResult vr2 = v2.doPass2();\n                 if (vr2.getStatus() != 1) {\n@@ -430,54 +434,54 @@\n             }\n         }\n     }\n     \n     public void visitLLOAD(final LLOAD o) {\n         final int idx = o.getIndex();\n         if (idx < 0) {\n-            this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must be non-negative. [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]\");\n+            this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must be non-negative.\" + \" [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]\");\n         }\n         else {\n             final int maxminus2 = this.max_locals() - 2;\n             if (idx > maxminus2) {\n                 this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must not be greater than max_locals-2 '\" + maxminus2 + \"'.\");\n             }\n         }\n     }\n     \n     public void visitDLOAD(final DLOAD o) {\n         final int idx = o.getIndex();\n         if (idx < 0) {\n-            this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must be non-negative. [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]\");\n+            this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must be non-negative.\" + \" [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]\");\n         }\n         else {\n             final int maxminus2 = this.max_locals() - 2;\n             if (idx > maxminus2) {\n                 this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must not be greater than max_locals-2 '\" + maxminus2 + \"'.\");\n             }\n         }\n     }\n     \n     public void visitLSTORE(final LSTORE o) {\n         final int idx = o.getIndex();\n         if (idx < 0) {\n-            this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must be non-negative. [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]\");\n+            this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must be non-negative.\" + \" [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]\");\n         }\n         else {\n             final int maxminus2 = this.max_locals() - 2;\n             if (idx > maxminus2) {\n                 this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must not be greater than max_locals-2 '\" + maxminus2 + \"'.\");\n             }\n         }\n     }\n     \n     public void visitDSTORE(final DSTORE o) {\n         final int idx = o.getIndex();\n         if (idx < 0) {\n-            this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must be non-negative. [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]\");\n+            this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must be non-negative.\" + \" [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]\");\n         }\n         else {\n             final int maxminus2 = this.max_locals() - 2;\n             if (idx > maxminus2) {\n                 this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must not be greater than max_locals-2 '\" + maxminus2 + \"'.\");\n             }\n         }\n@@ -504,30 +508,32 @@\n     \n     public void visitPUTSTATIC(final PUTSTATIC o) {\n         try {\n             final String field_name = o.getFieldName(this.constantPoolGen);\n             final JavaClass jc = Repository.lookupClass(this.getObjectType((FieldInstruction)o).getClassName());\n             final Field[] fields = jc.getFields();\n             Field f = null;\n-            for (final Field field : fields) {\n+            Field[] array;\n+            for (int length = (array = fields).length, i = 0; i < length; ++i) {\n+                final Field field = array[i];\n                 if (field.getName().equals(field_name)) {\n                     f = field;\n                     break;\n                 }\n             }\n             if (f == null) {\n                 throw new AssertionViolatedException(\"Field '\" + field_name + \"' not found in \" + jc.getClassName());\n             }\n-            if (f.isFinal() && !Pass3aVerifier.access$000(this.this$0).getClassName().equals(this.getObjectType((FieldInstruction)o).getClassName())) {\n-                this.constraintViolated((Instruction)o, \"Referenced field '\" + f + \"' is final and must therefore be declared in the current class '\" + Pass3aVerifier.access$000(this.this$0).getClassName() + \"' which is not the case: it is declared in '\" + o.getReferenceType(this.constantPoolGen) + \"'.\");\n+            if (f.isFinal() && !Pass3aVerifier.access$0(this.this$0).getClassName().equals(this.getObjectType((FieldInstruction)o).getClassName())) {\n+                this.constraintViolated((Instruction)o, \"Referenced field '\" + f + \"' is final and must therefore be declared in the current class '\" + Pass3aVerifier.access$0(this.this$0).getClassName() + \"' which is not the case: it is declared in '\" + o.getReferenceType(this.constantPoolGen) + \"'.\");\n             }\n             if (!f.isStatic()) {\n                 this.constraintViolated((Instruction)o, \"Referenced field '\" + f + \"' is not static which it should be.\");\n             }\n-            final String meth_name = Repository.lookupClass(Pass3aVerifier.access$000(this.this$0).getClassName()).getMethods()[Pass3aVerifier.access$100(this.this$0)].getName();\n+            final String meth_name = Repository.lookupClass(Pass3aVerifier.access$0(this.this$0).getClassName()).getMethods()[Pass3aVerifier.access$1(this.this$0)].getName();\n             if (!jc.isClass() && !meth_name.equals(\"<clinit>\")) {\n                 this.constraintViolated((Instruction)o, \"Interface field '\" + f + \"' must be set in a '\" + \"<clinit>\" + \"' method.\");\n             }\n         }\n         catch (final ClassNotFoundException e) {\n             throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n         }\n@@ -535,15 +541,17 @@\n     \n     public void visitGETSTATIC(final GETSTATIC o) {\n         try {\n             final String field_name = o.getFieldName(this.constantPoolGen);\n             final JavaClass jc = Repository.lookupClass(this.getObjectType((FieldInstruction)o).getClassName());\n             final Field[] fields = jc.getFields();\n             Field f = null;\n-            for (final Field field : fields) {\n+            Field[] array;\n+            for (int length = (array = fields).length, i = 0; i < length; ++i) {\n+                final Field field = array[i];\n                 if (field.getName().equals(field_name)) {\n                     f = field;\n                     break;\n                 }\n             }\n             if (f == null) {\n                 throw new AssertionViolatedException(\"Field '\" + field_name + \"' not found in \" + jc.getClassName());\n@@ -579,33 +587,38 @@\n     }\n     \n     private Method getMethodRecursive(final JavaClass jc, final InvokeInstruction invoke) throws ClassNotFoundException {\n         Method m = this.getMethod(jc, invoke);\n         if (m != null) {\n             return m;\n         }\n-        for (final JavaClass superclass : jc.getSuperClasses()) {\n+        JavaClass[] superClasses;\n+        for (int length = (superClasses = jc.getSuperClasses()).length, i = 0; i < length; ++i) {\n+            final JavaClass superclass = superClasses[i];\n             m = this.getMethod(superclass, invoke);\n             if (m != null) {\n                 return m;\n             }\n         }\n-        for (final JavaClass superclass : jc.getInterfaces()) {\n+        JavaClass[] interfaces;\n+        for (int length2 = (interfaces = jc.getInterfaces()).length, j = 0; j < length2; ++j) {\n+            final JavaClass superclass = interfaces[j];\n             m = this.getMethod(superclass, invoke);\n             if (m != null) {\n                 return m;\n             }\n         }\n         return null;\n     }\n     \n     private Method getMethod(final JavaClass jc, final InvokeInstruction invoke) {\n-        final Method[] methods;\n-        final Method[] ms = methods = jc.getMethods();\n-        for (final Method element : methods) {\n+        final Method[] ms = jc.getMethods();\n+        Method[] array;\n+        for (int length = (array = ms).length, i = 0; i < length; ++i) {\n+            final Method element = array[i];\n             if (element.getName().equals(invoke.getMethodName(this.constantPoolGen)) && Type.getReturnType(element.getSignature()).equals((Object)invoke.getReturnType(this.constantPoolGen)) && this.objarrayequals(Type.getArgumentTypes(element.getSignature()), invoke.getArgumentTypes(this.constantPoolGen))) {\n                 return element;\n             }\n         }\n         return null;\n     }\n     \n@@ -613,24 +626,25 @@\n         try {\n             final String classname = o.getClassName(this.constantPoolGen);\n             final JavaClass jc = Repository.lookupClass(classname);\n             final Method m = this.getMethodRecursive(jc, (InvokeInstruction)o);\n             if (m == null) {\n                 this.constraintViolated((Instruction)o, \"Referenced method '\" + o.getMethodName(this.constantPoolGen) + \"' with expected signature '\" + o.getSignature(this.constantPoolGen) + \"' not found in class '\" + jc.getClassName() + \"'.\");\n             }\n-            JavaClass current = Repository.lookupClass(Pass3aVerifier.access$000(this.this$0).getClassName());\n+            JavaClass current = Repository.lookupClass(Pass3aVerifier.access$0(this.this$0).getClassName());\n             if (current.isSuper() && Repository.instanceOf(current, jc) && !current.equals((Object)jc) && !o.getMethodName(this.constantPoolGen).equals(\"<init>\")) {\n                 int supidx = -1;\n                 Method meth = null;\n                 while (supidx != 0) {\n                     supidx = current.getSuperclassNameIndex();\n                     current = Repository.lookupClass(current.getSuperclassName());\n-                    final Method[] methods;\n-                    final Method[] meths = methods = current.getMethods();\n-                    for (final Method meth2 : methods) {\n+                    final Method[] meths = current.getMethods();\n+                    Method[] array;\n+                    for (int length = (array = meths).length, i = 0; i < length; ++i) {\n+                        final Method meth2 = array[i];\n                         if (meth2.getName().equals(o.getMethodName(this.constantPoolGen)) && Type.getReturnType(meth2.getSignature()).equals((Object)o.getReturnType(this.constantPoolGen)) && this.objarrayequals(Type.getArgumentTypes(meth2.getSignature()), o.getArgumentTypes(this.constantPoolGen))) {\n                             meth = meth2;\n                             break;\n                         }\n                     }\n                     if (meth != null) {\n                         break;\n"}]}
