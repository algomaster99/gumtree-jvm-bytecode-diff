{"diffoscope-json-version": 1, "source1": "first/Conversion.class", "source2": "second/Conversion.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -18,24 +18,24 @@\n     private static final boolean[] TFTF;\n     private static final boolean[] FFTF;\n     private static final boolean[] TTFF;\n     private static final boolean[] FTFF;\n     private static final boolean[] TFFF;\n     private static final boolean[] FFFF;\n     \n-    public static int hexDigitToInt(final char hexDigit) {\n-        final int digit = Character.digit(hexDigit, 16);\n+    public static int hexDigitToInt(final char c) {\n+        final int digit = Character.digit(c, 16);\n         if (digit < 0) {\n-            throw new IllegalArgumentException(\"Cannot interpret '\" + hexDigit + \"' as a hexadecimal digit\");\n+            throw new IllegalArgumentException(\"Cannot interpret '\" + c + \"' as a hexadecimal digit\");\n         }\n         return digit;\n     }\n     \n-    public static int hexDigitMsb0ToInt(final char hexDigit) {\n-        switch (hexDigit) {\n+    public static int hexDigitMsb0ToInt(final char c) {\n+        switch (c) {\n             case '0': {\n                 return 0;\n             }\n             case '1': {\n                 return 8;\n             }\n             case '2': {\n@@ -83,21 +83,21 @@\n                 return 7;\n             }\n             case 'F':\n             case 'f': {\n                 return 15;\n             }\n             default: {\n-                throw new IllegalArgumentException(\"Cannot interpret '\" + hexDigit + \"' as a hexadecimal digit\");\n+                throw new IllegalArgumentException(\"Cannot interpret '\" + c + \"' as a hexadecimal digit\");\n             }\n         }\n     }\n     \n-    public static boolean[] hexDigitToBinary(final char hexDigit) {\n-        switch (hexDigit) {\n+    public static boolean[] hexDigitToBinary(final char c) {\n+        switch (c) {\n             case '0': {\n                 return Conversion.FFFF.clone();\n             }\n             case '1': {\n                 return Conversion.TFFF.clone();\n             }\n             case '2': {\n@@ -145,21 +145,21 @@\n                 return Conversion.FTTT.clone();\n             }\n             case 'F':\n             case 'f': {\n                 return Conversion.TTTT.clone();\n             }\n             default: {\n-                throw new IllegalArgumentException(\"Cannot interpret '\" + hexDigit + \"' as a hexadecimal digit\");\n+                throw new IllegalArgumentException(\"Cannot interpret '\" + c + \"' as a hexadecimal digit\");\n             }\n         }\n     }\n     \n-    public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) {\n-        switch (hexDigit) {\n+    public static boolean[] hexDigitMsb0ToBinary(final char c) {\n+        switch (c) {\n             case '0': {\n                 return Conversion.FFFF.clone();\n             }\n             case '1': {\n                 return Conversion.FFFT.clone();\n             }\n             case '2': {\n@@ -207,146 +207,146 @@\n                 return Conversion.TTTF.clone();\n             }\n             case 'F':\n             case 'f': {\n                 return Conversion.TTTT.clone();\n             }\n             default: {\n-                throw new IllegalArgumentException(\"Cannot interpret '\" + hexDigit + \"' as a hexadecimal digit\");\n+                throw new IllegalArgumentException(\"Cannot interpret '\" + c + \"' as a hexadecimal digit\");\n             }\n         }\n     }\n     \n-    public static char binaryToHexDigit(final boolean[] src) {\n-        return binaryToHexDigit(src, 0);\n+    public static char binaryToHexDigit(final boolean[] array) {\n+        return binaryToHexDigit(array, 0);\n     }\n     \n-    public static char binaryToHexDigit(final boolean[] src, final int srcPos) {\n-        if (src.length == 0) {\n+    public static char binaryToHexDigit(final boolean[] array, final int n) {\n+        if (array.length == 0) {\n             throw new IllegalArgumentException(\"Cannot convert an empty array.\");\n         }\n-        if (src.length > srcPos + 3 && src[srcPos + 3]) {\n-            if (src[srcPos + 2]) {\n-                if (src[srcPos + 1]) {\n-                    return src[srcPos] ? 'f' : 'e';\n+        if (array.length > n + 3 && array[n + 3]) {\n+            if (array[n + 2]) {\n+                if (array[n + 1]) {\n+                    return array[n] ? 'f' : 'e';\n                 }\n-                return src[srcPos] ? 'd' : 'c';\n+                return array[n] ? 'd' : 'c';\n             }\n             else {\n-                if (src[srcPos + 1]) {\n-                    return src[srcPos] ? 'b' : 'a';\n+                if (array[n + 1]) {\n+                    return array[n] ? 'b' : 'a';\n                 }\n-                return src[srcPos] ? '9' : '8';\n+                return array[n] ? '9' : '8';\n             }\n         }\n-        else if (src.length > srcPos + 2 && src[srcPos + 2]) {\n-            if (src[srcPos + 1]) {\n-                return src[srcPos] ? '7' : '6';\n+        else if (array.length > n + 2 && array[n + 2]) {\n+            if (array[n + 1]) {\n+                return array[n] ? '7' : '6';\n             }\n-            return src[srcPos] ? '5' : '4';\n+            return array[n] ? '5' : '4';\n         }\n         else {\n-            if (src.length > srcPos + 1 && src[srcPos + 1]) {\n-                return src[srcPos] ? '3' : '2';\n+            if (array.length > n + 1 && array[n + 1]) {\n+                return array[n] ? '3' : '2';\n             }\n-            return src[srcPos] ? '1' : '0';\n+            return array[n] ? '1' : '0';\n         }\n     }\n     \n-    public static char binaryToHexDigitMsb0_4bits(final boolean[] src) {\n-        return binaryToHexDigitMsb0_4bits(src, 0);\n+    public static char binaryToHexDigitMsb0_4bits(final boolean[] array) {\n+        return binaryToHexDigitMsb0_4bits(array, 0);\n     }\n     \n-    public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) {\n-        if (src.length > 8) {\n-            throw new IllegalArgumentException(\"src.length>8: src.length=\" + src.length);\n+    public static char binaryToHexDigitMsb0_4bits(final boolean[] array, final int i) {\n+        if (array.length > 8) {\n+            throw new IllegalArgumentException(\"src.length>8: src.length=\" + array.length);\n         }\n-        if (src.length - srcPos < 4) {\n-            throw new IllegalArgumentException(\"src.length-srcPos<4: src.length=\" + src.length + \", srcPos=\" + srcPos);\n+        if (array.length - i < 4) {\n+            throw new IllegalArgumentException(\"src.length-srcPos<4: src.length=\" + array.length + \", srcPos=\" + i);\n         }\n-        if (src[srcPos + 3]) {\n-            if (src[srcPos + 2]) {\n-                if (src[srcPos + 1]) {\n-                    return src[srcPos] ? 'f' : '7';\n+        if (array[i + 3]) {\n+            if (array[i + 2]) {\n+                if (array[i + 1]) {\n+                    return array[i] ? 'f' : '7';\n                 }\n-                return src[srcPos] ? 'b' : '3';\n+                return array[i] ? 'b' : '3';\n             }\n             else {\n-                if (src[srcPos + 1]) {\n-                    return src[srcPos] ? 'd' : '5';\n+                if (array[i + 1]) {\n+                    return array[i] ? 'd' : '5';\n                 }\n-                return src[srcPos] ? '9' : '1';\n+                return array[i] ? '9' : '1';\n             }\n         }\n-        else if (src[srcPos + 2]) {\n-            if (src[srcPos + 1]) {\n-                return src[srcPos] ? 'e' : '6';\n+        else if (array[i + 2]) {\n+            if (array[i + 1]) {\n+                return array[i] ? 'e' : '6';\n             }\n-            return src[srcPos] ? 'a' : '2';\n+            return array[i] ? 'a' : '2';\n         }\n         else {\n-            if (src[srcPos + 1]) {\n-                return src[srcPos] ? 'c' : '4';\n+            if (array[i + 1]) {\n+                return array[i] ? 'c' : '4';\n             }\n-            return src[srcPos] ? '8' : '0';\n+            return array[i] ? '8' : '0';\n         }\n     }\n     \n-    public static char binaryBeMsb0ToHexDigit(final boolean[] src) {\n-        return binaryBeMsb0ToHexDigit(src, 0);\n+    public static char binaryBeMsb0ToHexDigit(final boolean[] array) {\n+        return binaryBeMsb0ToHexDigit(array, 0);\n     }\n     \n-    public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) {\n-        if (src.length == 0) {\n+    public static char binaryBeMsb0ToHexDigit(boolean[] array, int n) {\n+        if (array.length == 0) {\n             throw new IllegalArgumentException(\"Cannot convert an empty array.\");\n         }\n-        final int beSrcPos = src.length - 1 - srcPos;\n-        final int srcLen = Math.min(4, beSrcPos + 1);\n-        final boolean[] paddedSrc = new boolean[4];\n-        System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen);\n-        src = paddedSrc;\n-        srcPos = 0;\n-        if (src[srcPos]) {\n-            if (src.length > srcPos + 1 && src[srcPos + 1]) {\n-                if (src.length > srcPos + 2 && src[srcPos + 2]) {\n-                    return (src.length > srcPos + 3 && src[srcPos + 3]) ? 'f' : 'e';\n+        final int n2 = array.length - 1 - n;\n+        final int min = Math.min(4, n2 + 1);\n+        final boolean[] array2 = new boolean[4];\n+        System.arraycopy(array, n2 + 1 - min, array2, 4 - min, min);\n+        array = array2;\n+        n = 0;\n+        if (array[n]) {\n+            if (array.length > n + 1 && array[n + 1]) {\n+                if (array.length > n + 2 && array[n + 2]) {\n+                    return (array.length > n + 3 && array[n + 3]) ? 'f' : 'e';\n                 }\n-                return (src.length > srcPos + 3 && src[srcPos + 3]) ? 'd' : 'c';\n+                return (array.length > n + 3 && array[n + 3]) ? 'd' : 'c';\n             }\n             else {\n-                if (src.length > srcPos + 2 && src[srcPos + 2]) {\n-                    return (src.length > srcPos + 3 && src[srcPos + 3]) ? 'b' : 'a';\n+                if (array.length > n + 2 && array[n + 2]) {\n+                    return (array.length > n + 3 && array[n + 3]) ? 'b' : 'a';\n                 }\n-                return (src.length > srcPos + 3 && src[srcPos + 3]) ? '9' : '8';\n+                return (array.length > n + 3 && array[n + 3]) ? '9' : '8';\n             }\n         }\n-        else if (src.length > srcPos + 1 && src[srcPos + 1]) {\n-            if (src.length > srcPos + 2 && src[srcPos + 2]) {\n-                return (src.length > srcPos + 3 && src[srcPos + 3]) ? '7' : '6';\n+        else if (array.length > n + 1 && array[n + 1]) {\n+            if (array.length > n + 2 && array[n + 2]) {\n+                return (array.length > n + 3 && array[n + 3]) ? '7' : '6';\n             }\n-            return (src.length > srcPos + 3 && src[srcPos + 3]) ? '5' : '4';\n+            return (array.length > n + 3 && array[n + 3]) ? '5' : '4';\n         }\n         else {\n-            if (src.length > srcPos + 2 && src[srcPos + 2]) {\n-                return (src.length > srcPos + 3 && src[srcPos + 3]) ? '3' : '2';\n+            if (array.length > n + 2 && array[n + 2]) {\n+                return (array.length > n + 3 && array[n + 3]) ? '3' : '2';\n             }\n-            return (src.length > srcPos + 3 && src[srcPos + 3]) ? '1' : '0';\n+            return (array.length > n + 3 && array[n + 3]) ? '1' : '0';\n         }\n     }\n     \n-    public static char intToHexDigit(final int nibble) {\n-        final char c = Character.forDigit(nibble, 16);\n-        if (c == '\\0') {\n-            throw new IllegalArgumentException(\"nibble value not between 0 and 15: \" + nibble);\n+    public static char intToHexDigit(final int n) {\n+        final char forDigit = Character.forDigit(n, 16);\n+        if (forDigit == '\\0') {\n+            throw new IllegalArgumentException(\"nibble value not between 0 and 15: \" + n);\n         }\n-        return c;\n+        return forDigit;\n     }\n     \n-    public static char intToHexDigitMsb0(final int nibble) {\n-        switch (nibble) {\n+    public static char intToHexDigitMsb0(final int i) {\n+        switch (i) {\n             case 0: {\n                 return '0';\n             }\n             case 1: {\n                 return '8';\n             }\n             case 2: {\n@@ -388,509 +388,467 @@\n             case 14: {\n                 return '7';\n             }\n             case 15: {\n                 return 'f';\n             }\n             default: {\n-                throw new IllegalArgumentException(\"nibble value not between 0 and 15: \" + nibble);\n+                throw new IllegalArgumentException(\"nibble value not between 0 and 15: \" + i);\n             }\n         }\n     }\n     \n-    public static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts) {\n-        if ((src.length == 0 && srcPos == 0) || 0 == nInts) {\n-            return dstInit;\n+    public static long intArrayToLong(final int[] array, final int n, final long n2, final int n3, final int n4) {\n+        if ((array.length == 0 && n == 0) || 0 == n4) {\n+            return n2;\n         }\n-        if ((nInts - 1) * 32 + dstPos >= 64) {\n+        if ((n4 - 1) * 32 + n3 >= 64) {\n             throw new IllegalArgumentException(\"(nInts-1)*32+dstPos is greater or equal to than 64\");\n         }\n-        long out = dstInit;\n-        for (int i = 0; i < nInts; ++i) {\n-            final int shift = i * 32 + dstPos;\n-            final long bits = (0xFFFFFFFFL & (long)src[i + srcPos]) << shift;\n-            final long mask = 4294967295L << shift;\n-            out = ((out & ~mask) | bits);\n+        long n5 = n2;\n+        for (int i = 0; i < n4; ++i) {\n+            final int n6 = i * 32 + n3;\n+            n5 = ((n5 & ~(4294967295L << n6)) | (0xFFFFFFFFL & (long)array[i + n]) << n6);\n         }\n-        return out;\n+        return n5;\n     }\n     \n-    public static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts) {\n-        if ((src.length == 0 && srcPos == 0) || 0 == nShorts) {\n-            return dstInit;\n+    public static long shortArrayToLong(final short[] array, final int n, final long n2, final int n3, final int n4) {\n+        if ((array.length == 0 && n == 0) || 0 == n4) {\n+            return n2;\n         }\n-        if ((nShorts - 1) * 16 + dstPos >= 64) {\n+        if ((n4 - 1) * 16 + n3 >= 64) {\n             throw new IllegalArgumentException(\"(nShorts-1)*16+dstPos is greater or equal to than 64\");\n         }\n-        long out = dstInit;\n-        for (int i = 0; i < nShorts; ++i) {\n-            final int shift = i * 16 + dstPos;\n-            final long bits = (0xFFFFL & (long)src[i + srcPos]) << shift;\n-            final long mask = 65535L << shift;\n-            out = ((out & ~mask) | bits);\n+        long n5 = n2;\n+        for (int i = 0; i < n4; ++i) {\n+            final int n6 = i * 16 + n3;\n+            n5 = ((n5 & ~(65535L << n6)) | (0xFFFFL & (long)array[i + n]) << n6);\n         }\n-        return out;\n+        return n5;\n     }\n     \n-    public static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts) {\n-        if ((src.length == 0 && srcPos == 0) || 0 == nShorts) {\n-            return dstInit;\n+    public static int shortArrayToInt(final short[] array, final int n, final int n2, final int n3, final int n4) {\n+        if ((array.length == 0 && n == 0) || 0 == n4) {\n+            return n2;\n         }\n-        if ((nShorts - 1) * 16 + dstPos >= 32) {\n+        if ((n4 - 1) * 16 + n3 >= 32) {\n             throw new IllegalArgumentException(\"(nShorts-1)*16+dstPos is greater or equal to than 32\");\n         }\n-        int out = dstInit;\n-        for (int i = 0; i < nShorts; ++i) {\n-            final int shift = i * 16 + dstPos;\n-            final int bits = (0xFFFF & src[i + srcPos]) << shift;\n-            final int mask = 65535 << shift;\n-            out = ((out & ~mask) | bits);\n+        int n5 = n2;\n+        for (int i = 0; i < n4; ++i) {\n+            final int n6 = i * 16 + n3;\n+            n5 = ((n5 & ~(65535 << n6)) | (0xFFFF & array[i + n]) << n6);\n         }\n-        return out;\n+        return n5;\n     }\n     \n-    public static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes) {\n-        if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {\n-            return dstInit;\n+    public static long byteArrayToLong(final byte[] array, final int n, final long n2, final int n3, final int n4) {\n+        if ((array.length == 0 && n == 0) || 0 == n4) {\n+            return n2;\n         }\n-        if ((nBytes - 1) * 8 + dstPos >= 64) {\n+        if ((n4 - 1) * 8 + n3 >= 64) {\n             throw new IllegalArgumentException(\"(nBytes-1)*8+dstPos is greater or equal to than 64\");\n         }\n-        long out = dstInit;\n-        for (int i = 0; i < nBytes; ++i) {\n-            final int shift = i * 8 + dstPos;\n-            final long bits = (0xFFL & (long)src[i + srcPos]) << shift;\n-            final long mask = 255L << shift;\n-            out = ((out & ~mask) | bits);\n+        long n5 = n2;\n+        for (int i = 0; i < n4; ++i) {\n+            final int n6 = i * 8 + n3;\n+            n5 = ((n5 & ~(255L << n6)) | (0xFFL & (long)array[i + n]) << n6);\n         }\n-        return out;\n+        return n5;\n     }\n     \n-    public static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes) {\n-        if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {\n-            return dstInit;\n+    public static int byteArrayToInt(final byte[] array, final int n, final int n2, final int n3, final int n4) {\n+        if ((array.length == 0 && n == 0) || 0 == n4) {\n+            return n2;\n         }\n-        if ((nBytes - 1) * 8 + dstPos >= 32) {\n+        if ((n4 - 1) * 8 + n3 >= 32) {\n             throw new IllegalArgumentException(\"(nBytes-1)*8+dstPos is greater or equal to than 32\");\n         }\n-        int out = dstInit;\n-        for (int i = 0; i < nBytes; ++i) {\n-            final int shift = i * 8 + dstPos;\n-            final int bits = (0xFF & src[i + srcPos]) << shift;\n-            final int mask = 255 << shift;\n-            out = ((out & ~mask) | bits);\n+        int n5 = n2;\n+        for (int i = 0; i < n4; ++i) {\n+            final int n6 = i * 8 + n3;\n+            n5 = ((n5 & ~(255 << n6)) | (0xFF & array[i + n]) << n6);\n         }\n-        return out;\n+        return n5;\n     }\n     \n-    public static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes) {\n-        if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {\n-            return dstInit;\n+    public static short byteArrayToShort(final byte[] array, final int n, final short n2, final int n3, final int n4) {\n+        if ((array.length == 0 && n == 0) || 0 == n4) {\n+            return n2;\n         }\n-        if ((nBytes - 1) * 8 + dstPos >= 16) {\n+        if ((n4 - 1) * 8 + n3 >= 16) {\n             throw new IllegalArgumentException(\"(nBytes-1)*8+dstPos is greater or equal to than 16\");\n         }\n-        short out = dstInit;\n-        for (int i = 0; i < nBytes; ++i) {\n-            final int shift = i * 8 + dstPos;\n-            final int bits = (0xFF & src[i + srcPos]) << shift;\n-            final int mask = 255 << shift;\n-            out = (short)((out & ~mask) | bits);\n+        short n5 = n2;\n+        for (int i = 0; i < n4; ++i) {\n+            final int n6 = i * 8 + n3;\n+            n5 = (short)((n5 & ~(255 << n6)) | (0xFF & array[i + n]) << n6);\n         }\n-        return out;\n+        return n5;\n     }\n     \n-    public static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex) {\n-        if (0 == nHex) {\n-            return dstInit;\n+    public static long hexToLong(final String s, final int n, final long n2, final int n3, final int n4) {\n+        if (0 == n4) {\n+            return n2;\n         }\n-        if ((nHex - 1) * 4 + dstPos >= 64) {\n+        if ((n4 - 1) * 4 + n3 >= 64) {\n             throw new IllegalArgumentException(\"(nHexs-1)*4+dstPos is greater or equal to than 64\");\n         }\n-        long out = dstInit;\n-        for (int i = 0; i < nHex; ++i) {\n-            final int shift = i * 4 + dstPos;\n-            final long bits = (0xFL & (long)hexDigitToInt(src.charAt(i + srcPos))) << shift;\n-            final long mask = 15L << shift;\n-            out = ((out & ~mask) | bits);\n+        long n5 = n2;\n+        for (int i = 0; i < n4; ++i) {\n+            final int n6 = i * 4 + n3;\n+            n5 = ((n5 & ~(15L << n6)) | (0xFL & (long)hexDigitToInt(s.charAt(i + n))) << n6);\n         }\n-        return out;\n+        return n5;\n     }\n     \n-    public static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex) {\n-        if (0 == nHex) {\n-            return dstInit;\n+    public static int hexToInt(final String s, final int n, final int n2, final int n3, final int n4) {\n+        if (0 == n4) {\n+            return n2;\n         }\n-        if ((nHex - 1) * 4 + dstPos >= 32) {\n+        if ((n4 - 1) * 4 + n3 >= 32) {\n             throw new IllegalArgumentException(\"(nHexs-1)*4+dstPos is greater or equal to than 32\");\n         }\n-        int out = dstInit;\n-        for (int i = 0; i < nHex; ++i) {\n-            final int shift = i * 4 + dstPos;\n-            final int bits = (0xF & hexDigitToInt(src.charAt(i + srcPos))) << shift;\n-            final int mask = 15 << shift;\n-            out = ((out & ~mask) | bits);\n+        int n5 = n2;\n+        for (int i = 0; i < n4; ++i) {\n+            final int n6 = i * 4 + n3;\n+            n5 = ((n5 & ~(15 << n6)) | (0xF & hexDigitToInt(s.charAt(i + n))) << n6);\n         }\n-        return out;\n+        return n5;\n     }\n     \n-    public static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex) {\n-        if (0 == nHex) {\n-            return dstInit;\n+    public static short hexToShort(final String s, final int n, final short n2, final int n3, final int n4) {\n+        if (0 == n4) {\n+            return n2;\n         }\n-        if ((nHex - 1) * 4 + dstPos >= 16) {\n+        if ((n4 - 1) * 4 + n3 >= 16) {\n             throw new IllegalArgumentException(\"(nHexs-1)*4+dstPos is greater or equal to than 16\");\n         }\n-        short out = dstInit;\n-        for (int i = 0; i < nHex; ++i) {\n-            final int shift = i * 4 + dstPos;\n-            final int bits = (0xF & hexDigitToInt(src.charAt(i + srcPos))) << shift;\n-            final int mask = 15 << shift;\n-            out = (short)((out & ~mask) | bits);\n+        short n5 = n2;\n+        for (int i = 0; i < n4; ++i) {\n+            final int n6 = i * 4 + n3;\n+            n5 = (short)((n5 & ~(15 << n6)) | (0xF & hexDigitToInt(s.charAt(i + n))) << n6);\n         }\n-        return out;\n+        return n5;\n     }\n     \n-    public static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex) {\n-        if (0 == nHex) {\n-            return dstInit;\n+    public static byte hexToByte(final String s, final int n, final byte b, final int n2, final int n3) {\n+        if (0 == n3) {\n+            return b;\n         }\n-        if ((nHex - 1) * 4 + dstPos >= 8) {\n+        if ((n3 - 1) * 4 + n2 >= 8) {\n             throw new IllegalArgumentException(\"(nHexs-1)*4+dstPos is greater or equal to than 8\");\n         }\n-        byte out = dstInit;\n-        for (int i = 0; i < nHex; ++i) {\n-            final int shift = i * 4 + dstPos;\n-            final int bits = (0xF & hexDigitToInt(src.charAt(i + srcPos))) << shift;\n-            final int mask = 15 << shift;\n-            out = (byte)((out & ~mask) | bits);\n+        byte b2 = b;\n+        for (int i = 0; i < n3; ++i) {\n+            final int n4 = i * 4 + n2;\n+            b2 = (byte)((b2 & ~(15 << n4)) | (0xF & hexDigitToInt(s.charAt(i + n))) << n4);\n         }\n-        return out;\n+        return b2;\n     }\n     \n-    public static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools) {\n-        if ((src.length == 0 && srcPos == 0) || 0 == nBools) {\n-            return dstInit;\n+    public static long binaryToLong(final boolean[] array, final int n, final long n2, final int n3, final int n4) {\n+        if ((array.length == 0 && n == 0) || 0 == n4) {\n+            return n2;\n         }\n-        if (nBools - 1 + dstPos >= 64) {\n+        if (n4 - 1 + n3 >= 64) {\n             throw new IllegalArgumentException(\"nBools-1+dstPos is greater or equal to than 64\");\n         }\n-        long out = dstInit;\n-        for (int i = 0; i < nBools; ++i) {\n-            final int shift = i + dstPos;\n-            final long bits = (src[i + srcPos] ? 1 : 0) << shift;\n-            final long mask = 1L << shift;\n-            out = ((out & ~mask) | bits);\n+        long n5 = n2;\n+        for (int i = 0; i < n4; ++i) {\n+            final int n6 = i + n3;\n+            n5 = ((n5 & ~(1L << n6)) | (array[i + n] ? 1 : 0) << n6);\n         }\n-        return out;\n+        return n5;\n     }\n     \n-    public static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools) {\n-        if ((src.length == 0 && srcPos == 0) || 0 == nBools) {\n-            return dstInit;\n+    public static int binaryToInt(final boolean[] array, final int n, final int n2, final int n3, final int n4) {\n+        if ((array.length == 0 && n == 0) || 0 == n4) {\n+            return n2;\n         }\n-        if (nBools - 1 + dstPos >= 32) {\n+        if (n4 - 1 + n3 >= 32) {\n             throw new IllegalArgumentException(\"nBools-1+dstPos is greater or equal to than 32\");\n         }\n-        int out = dstInit;\n-        for (int i = 0; i < nBools; ++i) {\n-            final int shift = i + dstPos;\n-            final int bits = (src[i + srcPos] ? 1 : 0) << shift;\n-            final int mask = 1 << shift;\n-            out = ((out & ~mask) | bits);\n+        int n5 = n2;\n+        for (int i = 0; i < n4; ++i) {\n+            final int n6 = i + n3;\n+            n5 = ((n5 & ~(1 << n6)) | (array[i + n] ? 1 : 0) << n6);\n         }\n-        return out;\n+        return n5;\n     }\n     \n-    public static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools) {\n-        if ((src.length == 0 && srcPos == 0) || 0 == nBools) {\n-            return dstInit;\n+    public static short binaryToShort(final boolean[] array, final int n, final short n2, final int n3, final int n4) {\n+        if ((array.length == 0 && n == 0) || 0 == n4) {\n+            return n2;\n         }\n-        if (nBools - 1 + dstPos >= 16) {\n+        if (n4 - 1 + n3 >= 16) {\n             throw new IllegalArgumentException(\"nBools-1+dstPos is greater or equal to than 16\");\n         }\n-        short out = dstInit;\n-        for (int i = 0; i < nBools; ++i) {\n-            final int shift = i + dstPos;\n-            final int bits = (src[i + srcPos] ? 1 : 0) << shift;\n-            final int mask = 1 << shift;\n-            out = (short)((out & ~mask) | bits);\n+        short n5 = n2;\n+        for (int i = 0; i < n4; ++i) {\n+            final int n6 = i + n3;\n+            n5 = (short)((n5 & ~(1 << n6)) | (array[i + n] ? 1 : 0) << n6);\n         }\n-        return out;\n+        return n5;\n     }\n     \n-    public static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools) {\n-        if ((src.length == 0 && srcPos == 0) || 0 == nBools) {\n-            return dstInit;\n+    public static byte binaryToByte(final boolean[] array, final int n, final byte b, final int n2, final int n3) {\n+        if ((array.length == 0 && n == 0) || 0 == n3) {\n+            return b;\n         }\n-        if (nBools - 1 + dstPos >= 8) {\n+        if (n3 - 1 + n2 >= 8) {\n             throw new IllegalArgumentException(\"nBools-1+dstPos is greater or equal to than 8\");\n         }\n-        byte out = dstInit;\n-        for (int i = 0; i < nBools; ++i) {\n-            final int shift = i + dstPos;\n-            final int bits = (src[i + srcPos] ? 1 : 0) << shift;\n-            final int mask = 1 << shift;\n-            out = (byte)((out & ~mask) | bits);\n+        byte b2 = b;\n+        for (int i = 0; i < n3; ++i) {\n+            final int n4 = i + n2;\n+            b2 = (byte)((b2 & ~(1 << n4)) | (array[i + n] ? 1 : 0) << n4);\n         }\n-        return out;\n+        return b2;\n     }\n     \n-    public static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts) {\n-        if (0 == nInts) {\n-            return dst;\n+    public static int[] longToIntArray(final long n, final int n2, final int[] array, final int n3, final int n4) {\n+        if (0 == n4) {\n+            return array;\n         }\n-        if ((nInts - 1) * 32 + srcPos >= 64) {\n+        if ((n4 - 1) * 32 + n2 >= 64) {\n             throw new IllegalArgumentException(\"(nInts-1)*32+srcPos is greater or equal to than 64\");\n         }\n-        for (int i = 0; i < nInts; ++i) {\n-            final int shift = i * 32 + srcPos;\n-            dst[dstPos + i] = (int)(-1L & src >> shift);\n+        for (int i = 0; i < n4; ++i) {\n+            array[n3 + i] = (int)(-1L & n >> i * 32 + n2);\n         }\n-        return dst;\n+        return array;\n     }\n     \n-    public static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) {\n-        if (0 == nShorts) {\n-            return dst;\n+    public static short[] longToShortArray(final long n, final int n2, final short[] array, final int n3, final int n4) {\n+        if (0 == n4) {\n+            return array;\n         }\n-        if ((nShorts - 1) * 16 + srcPos >= 64) {\n+        if ((n4 - 1) * 16 + n2 >= 64) {\n             throw new IllegalArgumentException(\"(nShorts-1)*16+srcPos is greater or equal to than 64\");\n         }\n-        for (int i = 0; i < nShorts; ++i) {\n-            final int shift = i * 16 + srcPos;\n-            dst[dstPos + i] = (short)(0xFFFFL & src >> shift);\n+        for (int i = 0; i < n4; ++i) {\n+            array[n3 + i] = (short)(0xFFFFL & n >> i * 16 + n2);\n         }\n-        return dst;\n+        return array;\n     }\n     \n-    public static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) {\n-        if (0 == nShorts) {\n-            return dst;\n+    public static short[] intToShortArray(final int n, final int n2, final short[] array, final int n3, final int n4) {\n+        if (0 == n4) {\n+            return array;\n         }\n-        if ((nShorts - 1) * 16 + srcPos >= 32) {\n+        if ((n4 - 1) * 16 + n2 >= 32) {\n             throw new IllegalArgumentException(\"(nShorts-1)*16+srcPos is greater or equal to than 32\");\n         }\n-        for (int i = 0; i < nShorts; ++i) {\n-            final int shift = i * 16 + srcPos;\n-            dst[dstPos + i] = (short)(0xFFFF & src >> shift);\n+        for (int i = 0; i < n4; ++i) {\n+            array[n3 + i] = (short)(0xFFFF & n >> i * 16 + n2);\n         }\n-        return dst;\n+        return array;\n     }\n     \n-    public static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) {\n-        if (0 == nBytes) {\n-            return dst;\n+    public static byte[] longToByteArray(final long n, final int n2, final byte[] array, final int n3, final int n4) {\n+        if (0 == n4) {\n+            return array;\n         }\n-        if ((nBytes - 1) * 8 + srcPos >= 64) {\n+        if ((n4 - 1) * 8 + n2 >= 64) {\n             throw new IllegalArgumentException(\"(nBytes-1)*8+srcPos is greater or equal to than 64\");\n         }\n-        for (int i = 0; i < nBytes; ++i) {\n-            final int shift = i * 8 + srcPos;\n-            dst[dstPos + i] = (byte)(0xFFL & src >> shift);\n+        for (int i = 0; i < n4; ++i) {\n+            array[n3 + i] = (byte)(0xFFL & n >> i * 8 + n2);\n         }\n-        return dst;\n+        return array;\n     }\n     \n-    public static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) {\n-        if (0 == nBytes) {\n-            return dst;\n+    public static byte[] intToByteArray(final int n, final int n2, final byte[] array, final int n3, final int n4) {\n+        if (0 == n4) {\n+            return array;\n         }\n-        if ((nBytes - 1) * 8 + srcPos >= 32) {\n+        if ((n4 - 1) * 8 + n2 >= 32) {\n             throw new IllegalArgumentException(\"(nBytes-1)*8+srcPos is greater or equal to than 32\");\n         }\n-        for (int i = 0; i < nBytes; ++i) {\n-            final int shift = i * 8 + srcPos;\n-            dst[dstPos + i] = (byte)(0xFF & src >> shift);\n+        for (int i = 0; i < n4; ++i) {\n+            array[n3 + i] = (byte)(0xFF & n >> i * 8 + n2);\n         }\n-        return dst;\n+        return array;\n     }\n     \n-    public static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) {\n-        if (0 == nBytes) {\n-            return dst;\n+    public static byte[] shortToByteArray(final short n, final int n2, final byte[] array, final int n3, final int n4) {\n+        if (0 == n4) {\n+            return array;\n         }\n-        if ((nBytes - 1) * 8 + srcPos >= 16) {\n+        if ((n4 - 1) * 8 + n2 >= 16) {\n             throw new IllegalArgumentException(\"(nBytes-1)*8+srcPos is greater or equal to than 16\");\n         }\n-        for (int i = 0; i < nBytes; ++i) {\n-            final int shift = i * 8 + srcPos;\n-            dst[dstPos + i] = (byte)(0xFF & src >> shift);\n+        for (int i = 0; i < n4; ++i) {\n+            array[n3 + i] = (byte)(0xFF & n >> i * 8 + n2);\n         }\n-        return dst;\n+        return array;\n     }\n     \n-    public static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {\n-        if (0 == nHexs) {\n-            return dstInit;\n+    public static String longToHex(final long n, final int n2, final String str, final int n3, final int n4) {\n+        if (0 == n4) {\n+            return str;\n         }\n-        if ((nHexs - 1) * 4 + srcPos >= 64) {\n+        if ((n4 - 1) * 4 + n2 >= 64) {\n             throw new IllegalArgumentException(\"(nHexs-1)*4+srcPos is greater or equal to than 64\");\n         }\n-        final StringBuilder sb = new StringBuilder(dstInit);\n-        int append = sb.length();\n-        for (int i = 0; i < nHexs; ++i) {\n-            final int shift = i * 4 + srcPos;\n-            final int bits = (int)(0xFL & src >> shift);\n-            if (dstPos + i == append) {\n-                ++append;\n-                sb.append(intToHexDigit(bits));\n+        final StringBuilder sb = new StringBuilder(str);\n+        int length = sb.length();\n+        for (int i = 0; i < n4; ++i) {\n+            final int n5 = (int)(0xFL & n >> i * 4 + n2);\n+            if (n3 + i == length) {\n+                ++length;\n+                sb.append(intToHexDigit(n5));\n             }\n             else {\n                 sb.setCharAt();\n             }\n         }\n         return sb.toString();\n     }\n     \n-    public static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {\n-        if (0 == nHexs) {\n-            return dstInit;\n+    public static String intToHex(final int n, final int n2, final String str, final int n3, final int n4) {\n+        if (0 == n4) {\n+            return str;\n         }\n-        if ((nHexs - 1) * 4 + srcPos >= 32) {\n+        if ((n4 - 1) * 4 + n2 >= 32) {\n             throw new IllegalArgumentException(\"(nHexs-1)*4+srcPos is greater or equal to than 32\");\n         }\n-        final StringBuilder sb = new StringBuilder(dstInit);\n-        int append = sb.length();\n-        for (int i = 0; i < nHexs; ++i) {\n-            final int shift = i * 4 + srcPos;\n-            final int bits = 0xF & src >> shift;\n-            if (dstPos + i == append) {\n-                ++append;\n-                sb.append(intToHexDigit(bits));\n+        final StringBuilder sb = new StringBuilder(str);\n+        int length = sb.length();\n+        for (int i = 0; i < n4; ++i) {\n+            final int n5 = 0xF & n >> i * 4 + n2;\n+            if (n3 + i == length) {\n+                ++length;\n+                sb.append(intToHexDigit(n5));\n             }\n             else {\n                 sb.setCharAt();\n             }\n         }\n         return sb.toString();\n     }\n     \n-    public static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {\n-        if (0 == nHexs) {\n-            return dstInit;\n+    public static String shortToHex(final short n, final int n2, final String str, final int n3, final int n4) {\n+        if (0 == n4) {\n+            return str;\n         }\n-        if ((nHexs - 1) * 4 + srcPos >= 16) {\n+        if ((n4 - 1) * 4 + n2 >= 16) {\n             throw new IllegalArgumentException(\"(nHexs-1)*4+srcPos is greater or equal to than 16\");\n         }\n-        final StringBuilder sb = new StringBuilder(dstInit);\n-        int append = sb.length();\n-        for (int i = 0; i < nHexs; ++i) {\n-            final int shift = i * 4 + srcPos;\n-            final int bits = 0xF & src >> shift;\n-            if (dstPos + i == append) {\n-                ++append;\n-                sb.append(intToHexDigit(bits));\n+        final StringBuilder sb = new StringBuilder(str);\n+        int length = sb.length();\n+        for (int i = 0; i < n4; ++i) {\n+            final int n5 = 0xF & n >> i * 4 + n2;\n+            if (n3 + i == length) {\n+                ++length;\n+                sb.append(intToHexDigit(n5));\n             }\n             else {\n                 sb.setCharAt();\n             }\n         }\n         return sb.toString();\n     }\n     \n-    public static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {\n-        if (0 == nHexs) {\n-            return dstInit;\n+    public static String byteToHex(final byte b, final int n, final String str, final int n2, final int n3) {\n+        if (0 == n3) {\n+            return str;\n         }\n-        if ((nHexs - 1) * 4 + srcPos >= 8) {\n+        if ((n3 - 1) * 4 + n >= 8) {\n             throw new IllegalArgumentException(\"(nHexs-1)*4+srcPos is greater or equal to than 8\");\n         }\n-        final StringBuilder sb = new StringBuilder(dstInit);\n-        int append = sb.length();\n-        for (int i = 0; i < nHexs; ++i) {\n-            final int shift = i * 4 + srcPos;\n-            final int bits = 0xF & src >> shift;\n-            if (dstPos + i == append) {\n-                ++append;\n-                sb.append(intToHexDigit(bits));\n+        final StringBuilder sb = new StringBuilder(str);\n+        int length = sb.length();\n+        for (int i = 0; i < n3; ++i) {\n+            final int n4 = 0xF & b >> i * 4 + n;\n+            if (n2 + i == length) {\n+                ++length;\n+                sb.append(intToHexDigit(n4));\n             }\n             else {\n                 sb.setCharAt();\n             }\n         }\n         return sb.toString();\n     }\n     \n-    public static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) {\n-        if (0 == nBools) {\n-            return dst;\n+    public static boolean[] longToBinary(final long n, final int n2, final boolean[] array, final int n3, final int n4) {\n+        if (0 == n4) {\n+            return array;\n         }\n-        if (nBools - 1 + srcPos >= 64) {\n+        if (n4 - 1 + n2 >= 64) {\n             throw new IllegalArgumentException(\"nBools-1+srcPos is greater or equal to than 64\");\n         }\n-        for (int i = 0; i < nBools; ++i) {\n-            final int shift = i + srcPos;\n-            dst[dstPos + i] = ((0x1L & src >> shift) != 0x0L);\n+        for (int i = 0; i < n4; ++i) {\n+            array[n3 + i] = ((0x1L & n >> i + n2) != 0x0L);\n         }\n-        return dst;\n+        return array;\n     }\n     \n-    public static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) {\n-        if (0 == nBools) {\n-            return dst;\n+    public static boolean[] intToBinary(final int n, final int n2, final boolean[] array, final int n3, final int n4) {\n+        if (0 == n4) {\n+            return array;\n         }\n-        if (nBools - 1 + srcPos >= 32) {\n+        if (n4 - 1 + n2 >= 32) {\n             throw new IllegalArgumentException(\"nBools-1+srcPos is greater or equal to than 32\");\n         }\n-        for (int i = 0; i < nBools; ++i) {\n-            final int shift = i + srcPos;\n-            dst[dstPos + i] = ((0x1 & src >> shift) != 0x0);\n+        for (int i = 0; i < n4; ++i) {\n+            array[n3 + i] = ((0x1 & n >> i + n2) != 0x0);\n         }\n-        return dst;\n+        return array;\n     }\n     \n-    public static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) {\n-        if (0 == nBools) {\n-            return dst;\n+    public static boolean[] shortToBinary(final short n, final int n2, final boolean[] array, final int n3, final int n4) {\n+        if (0 == n4) {\n+            return array;\n         }\n-        if (nBools - 1 + srcPos >= 16) {\n+        if (n4 - 1 + n2 >= 16) {\n             throw new IllegalArgumentException(\"nBools-1+srcPos is greater or equal to than 16\");\n         }\n-        assert nBools - 1 < 16 - srcPos;\n-        for (int i = 0; i < nBools; ++i) {\n-            final int shift = i + srcPos;\n-            dst[dstPos + i] = ((0x1 & src >> shift) != 0x0);\n+        assert n4 - 1 < 16 - n2;\n+        for (int i = 0; i < n4; ++i) {\n+            array[n3 + i] = ((0x1 & n >> i + n2) != 0x0);\n         }\n-        return dst;\n+        return array;\n     }\n     \n-    public static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) {\n-        if (0 == nBools) {\n-            return dst;\n+    public static boolean[] byteToBinary(final byte b, final int n, final boolean[] array, final int n2, final int n3) {\n+        if (0 == n3) {\n+            return array;\n         }\n-        if (nBools - 1 + srcPos >= 8) {\n+        if (n3 - 1 + n >= 8) {\n             throw new IllegalArgumentException(\"nBools-1+srcPos is greater or equal to than 8\");\n         }\n-        for (int i = 0; i < nBools; ++i) {\n-            final int shift = i + srcPos;\n-            dst[dstPos + i] = ((0x1 & src >> shift) != 0x0);\n+        for (int i = 0; i < n3; ++i) {\n+            array[n2 + i] = ((0x1 & b >> i + n) != 0x0);\n         }\n-        return dst;\n+        return array;\n     }\n     \n-    public static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes) {\n-        if (0 == nBytes) {\n-            return dst;\n+    public static byte[] uuidToByteArray(final UUID uuid, final byte[] array, final int n, final int a) {\n+        if (0 == a) {\n+            return array;\n         }\n-        if (nBytes > 16) {\n+        if (a > 16) {\n             throw new IllegalArgumentException(\"nBytes is greater than 16\");\n         }\n-        longToByteArray(src.getMostSignificantBits(), 0, dst, dstPos, Math.min(nBytes, 8));\n-        if (nBytes >= 8) {\n-            longToByteArray(src.getLeastSignificantBits(), 0, dst, dstPos + 8, nBytes - 8);\n+        longToByteArray(uuid.getMostSignificantBits(), 0, array, n, Math.min(a, 8));\n+        if (a >= 8) {\n+            longToByteArray(uuid.getLeastSignificantBits(), 0, array, n + 8, a - 8);\n         }\n-        return dst;\n+        return array;\n     }\n     \n-    public static UUID byteArrayToUuid(final byte[] src, final int srcPos) {\n-        if (src.length - srcPos < 16) {\n+    public static UUID byteArrayToUuid(final byte[] array, final int n) {\n+        if (array.length - n < 16) {\n             throw new IllegalArgumentException(\"Need at least 16 bytes for UUID\");\n         }\n-        return new UUID(byteArrayToLong(src, srcPos, 0L, 0, 8), byteArrayToLong(src, srcPos + 8, 0L, 0, 8));\n+        return new UUID(byteArrayToLong(array, n, 0L, 0, 8), byteArrayToLong(array, n + 8, 0L, 0, 8));\n     }\n     \n     static {\n         TTTT = new boolean[] { true, true, true, true };\n         FTTT = new boolean[] { false, true, true, true };\n         TFTT = new boolean[] { true, false, true, true };\n         FFTT = new boolean[] { false, false, true, true };\n"}]}
