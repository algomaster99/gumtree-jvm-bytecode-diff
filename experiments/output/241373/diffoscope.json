{"diffoscope-json-version": 1, "source1": "first/XMLTokener.class", "source2": "second/XMLTokener.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -4,29 +4,28 @@\n import java.io.Reader;\n import java.util.HashMap;\n \n public class XMLTokener extends JSONTokener\n {\n     public static final HashMap<String, Character> entity;\n     \n-    public XMLTokener(final Reader r) {\n-        super(r);\n+    public XMLTokener(final Reader reader) {\n+        super(reader);\n     }\n     \n     public XMLTokener(final String s) {\n         super(s);\n     }\n     \n     public String nextCDATA() throws JSONException {\n         final StringBuilder sb = new StringBuilder();\n         while (this.more()) {\n-            final char c = this.next();\n-            sb.append(c);\n-            final int i = sb.length() - 3;\n-            if (i >= 0 && sb.charAt() == ']' && sb.charAt() == ']' && sb.charAt() == '>') {\n+            sb.append(this.next());\n+            final int length = sb.length() - 3;\n+            if (length >= 0 && sb.charAt() == ']' && sb.charAt() == ']' && sb.charAt() == '>') {\n                 sb.setLength();\n                 return sb.toString();\n             }\n         }\n         throw this.syntaxError(\"Unclosed CDATA\");\n     }\n     \n@@ -54,58 +53,57 @@\n                 sb.append(c);\n             }\n             c = this.next();\n         }\n         return sb.toString().trim();\n     }\n     \n-    public Object nextEntity(final char ampersand) throws JSONException {\n-        final StringBuilder sb = new StringBuilder();\n-        char c;\n+    public Object nextEntity(final char c) throws JSONException {\n+        final StringBuilder obj = new StringBuilder();\n+        char next;\n         while (true) {\n-            c = this.next();\n-            if (!Character.isLetterOrDigit(c) && c != '#') {\n+            next = this.next();\n+            if (!Character.isLetterOrDigit(next) && next != '#') {\n                 break;\n             }\n-            sb.append(Character.toLowerCase(c));\n+            obj.append(Character.toLowerCase(next));\n         }\n-        if (c == ';') {\n-            final String string = sb.toString();\n-            return unescapeEntity(string);\n+        if (next == ';') {\n+            return unescapeEntity(obj.toString());\n         }\n-        throw this.syntaxError(\"Missing ';' in XML entity: &\" + (Object)sb);\n+        throw this.syntaxError(\"Missing ';' in XML entity: &\" + (Object)obj);\n     }\n     \n-    static String unescapeEntity(final String e) {\n-        if (e == null || e.isEmpty()) {\n+    static String unescapeEntity(final String s) {\n+        if (s == null || s.isEmpty()) {\n             return \"\";\n         }\n-        if (e.charAt(0) == '#') {\n-            int cp;\n-            if (e.charAt(1) == 'x' || e.charAt(1) == 'X') {\n-                cp = Integer.parseInt(e.substring(2), 16);\n+        if (s.charAt(0) == '#') {\n+            int n;\n+            if (s.charAt(1) == 'x' || s.charAt(1) == 'X') {\n+                n = Integer.parseInt(s.substring(2), 16);\n             }\n             else {\n-                cp = Integer.parseInt(e.substring(1));\n+                n = Integer.parseInt(s.substring(1));\n             }\n-            return new String(new int[] { cp }, 0, 1);\n+            return new String(new int[] { n }, 0, 1);\n         }\n-        final Character knownEntity = Character.valueOf(XMLTokener.entity.get((Object)e));\n-        if (knownEntity == null) {\n-            return '&' + e + ';';\n+        final Character c = Character.valueOf(XMLTokener.entity.get((Object)s));\n+        if (c == null) {\n+            return '&' + s + ';';\n         }\n-        return knownEntity.toString();\n+        return c.toString();\n     }\n     \n     public Object nextMeta() throws JSONException {\n-        char c;\n+        char next;\n         do {\n-            c = this.next();\n-        } while (Character.isWhitespace(c));\n-        switch (c) {\n+            next = this.next();\n+        } while (Character.isWhitespace(next));\n+        switch (next) {\n             case '\\0': {\n                 throw this.syntaxError(\"Misshaped meta tag\");\n             }\n             case '<': {\n                 return XML.LT;\n             }\n             case '>': {\n@@ -121,30 +119,30 @@\n                 return XML.BANG;\n             }\n             case '?': {\n                 return XML.QUEST;\n             }\n             case '\\\"':\n             case '\\'': {\n-                final char q = c;\n+                char next2;\n                 do {\n-                    c = this.next();\n-                    if (c == '\\0') {\n+                    next2 = this.next();\n+                    if (next2 == '\\0') {\n                         throw this.syntaxError(\"Unterminated string\");\n                     }\n-                } while (c != q);\n+                } while (next2 != next);\n                 return Boolean.TRUE;\n             }\n             default: {\n                 while (true) {\n-                    c = this.next();\n-                    if (Character.isWhitespace(c)) {\n+                    final char next3 = this.next();\n+                    if (Character.isWhitespace(next3)) {\n                         return Boolean.TRUE;\n                     }\n-                    switch (c) {\n+                    switch (next3) {\n                         case '\\0': {\n                             throw this.syntaxError(\"Unterminated string\");\n                         }\n                         case '!':\n                         case '\\\"':\n                         case '\\'':\n                         case '/':\n@@ -162,19 +160,19 @@\n                 }\n                 break;\n             }\n         }\n     }\n     \n     public Object nextToken() throws JSONException {\n-        char c;\n+        char ch;\n         do {\n-            c = this.next();\n-        } while (Character.isWhitespace(c));\n-        switch (c) {\n+            ch = this.next();\n+        } while (Character.isWhitespace(ch));\n+        switch (ch) {\n             case '\\0': {\n                 throw this.syntaxError(\"Misshaped element\");\n             }\n             case '<': {\n                 throw this.syntaxError(\"Misplaced '<'\");\n             }\n             case '>': {\n@@ -190,54 +188,54 @@\n                 return XML.BANG;\n             }\n             case '?': {\n                 return XML.QUEST;\n             }\n             case '\\\"':\n             case '\\'': {\n-                final char q = c;\n+                final char c = ch;\n                 final StringBuilder sb = new StringBuilder();\n                 while (true) {\n-                    c = this.next();\n-                    if (c == '\\0') {\n+                    final char next = this.next();\n+                    if (next == '\\0') {\n                         throw this.syntaxError(\"Unterminated string\");\n                     }\n-                    if (c == q) {\n+                    if (next == c) {\n                         return sb.toString();\n                     }\n-                    if (c == '&') {\n-                        sb.append(this.nextEntity(c));\n+                    if (next == '&') {\n+                        sb.append(this.nextEntity(next));\n                     }\n                     else {\n-                        sb.append(c);\n+                        sb.append(next);\n                     }\n                 }\n                 break;\n             }\n             default: {\n-                final StringBuilder sb = new StringBuilder();\n+                final StringBuilder sb2 = new StringBuilder();\n                 while (true) {\n-                    sb.append(c);\n-                    c = this.next();\n-                    if (Character.isWhitespace(c)) {\n-                        return sb.toString();\n+                    sb2.append(ch);\n+                    ch = this.next();\n+                    if (Character.isWhitespace(ch)) {\n+                        return sb2.toString();\n                     }\n-                    switch (c) {\n+                    switch (ch) {\n                         case '\\0': {\n-                            return sb.toString();\n+                            return sb2.toString();\n                         }\n                         case '!':\n                         case '/':\n                         case '=':\n                         case '>':\n                         case '?':\n                         case '[':\n                         case ']': {\n                             this.back();\n-                            return sb.toString();\n+                            return sb2.toString();\n                         }\n                         case '\\\"':\n                         case '\\'':\n                         case '<': {\n                             throw this.syntaxError(\"Bad character in a name\");\n                         }\n                         default: {\n@@ -246,49 +244,49 @@\n                     }\n                 }\n                 break;\n             }\n         }\n     }\n     \n-    public void skipPast(final String to) {\n-        int offset = 0;\n-        final int length = to.length();\n-        final char[] circle = new char[length];\n+    public void skipPast(final String s) {\n+        int n = 0;\n+        final int length = s.length();\n+        final char[] array = new char[length];\n         for (int i = 0; i < length; ++i) {\n-            final char c = this.next();\n-            if (c == '\\0') {\n+            final char next = this.next();\n+            if (next == '\\0') {\n                 return;\n             }\n-            circle[i] = c;\n+            array[i] = next;\n         }\n         while (true) {\n-            int j = offset;\n+            int n2 = n;\n             boolean b = true;\n-            for (int i = 0; i < length; ++i) {\n-                if (circle[j] != to.charAt(i)) {\n+            for (int j = 0; j < length; ++j) {\n+                if (array[n2] != s.charAt(j)) {\n                     b = false;\n                     break;\n                 }\n-                if (++j >= length) {\n-                    j -= length;\n+                if (++n2 >= length) {\n+                    n2 -= length;\n                 }\n             }\n             if (b) {\n                 return;\n             }\n-            final char c = this.next();\n-            if (c == '\\0') {\n+            final char next2 = this.next();\n+            if (next2 == '\\0') {\n                 return;\n             }\n-            circle[offset] = c;\n-            if (++offset < length) {\n+            array[n] = next2;\n+            if (++n < length) {\n                 continue;\n             }\n-            offset -= length;\n+            n -= length;\n         }\n     }\n     \n     static {\n         (entity = new HashMap<String, Character>(8)).put(\"amp\", XML.AMP);\n         XMLTokener.entity.put(\"apos\", XML.APOS);\n         XMLTokener.entity.put(\"gt\", XML.GT);\n"}]}
