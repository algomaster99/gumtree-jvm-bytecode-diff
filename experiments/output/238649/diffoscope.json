{"diffoscope-json-version": 1, "source1": "first/FieldUtils.class", "source2": "second/FieldUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -16,264 +16,261 @@\n import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.lang3.Validate;\n import java.lang.reflect.AccessibleObject;\n import java.lang.reflect.Field;\n \n public class FieldUtils\n {\n-    public static Field getField(final Class<?> cls, final String fieldName) {\n-        final Field field = getField(cls, fieldName, false);\n+    public static Field getField(final Class<?> clazz, final String s) {\n+        final Field field = getField(clazz, s, false);\n         MemberUtils.setAccessibleWorkaround((AccessibleObject)field);\n         return field;\n     }\n     \n-    public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) {\n-        Validate.notNull((Object)cls, \"cls\", new Object[0]);\n-        Validate.isTrue(StringUtils.isNotBlank((CharSequence)fieldName), \"The field name must not be blank/empty\", new Object[0]);\n-        for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) {\n+    public static Field getField(final Class<?> clazz, final String s, final boolean b) {\n+        Validate.notNull((Object)clazz, \"cls\", new Object[0]);\n+        Validate.isTrue(StringUtils.isNotBlank((CharSequence)s), \"The field name must not be blank/empty\", new Object[0]);\n+        for (Class<?> superclass = clazz; superclass != null; superclass = superclass.getSuperclass()) {\n             try {\n-                final Field field = acls.getDeclaredField(fieldName);\n-                if (!Modifier.isPublic(field.getModifiers())) {\n-                    if (!forceAccess) {\n+                final Field declaredField = superclass.getDeclaredField(s);\n+                if (!Modifier.isPublic(declaredField.getModifiers())) {\n+                    if (!b) {\n                         continue;\n                     }\n-                    field.setAccessible(true);\n+                    declaredField.setAccessible(true);\n                 }\n-                return field;\n+                return declaredField;\n             }\n             catch (final NoSuchFieldException ex) {}\n         }\n-        Field match = null;\n-        for (final Class<?> class1 : ClassUtils.getAllInterfaces((Class)cls)) {\n+        Field field = null;\n+        for (final Class clazz2 : ClassUtils.getAllInterfaces((Class)clazz)) {\n             try {\n-                final Field test = class1.getField(fieldName);\n-                Validate.isTrue(match == null, \"Reference to field %s is ambiguous relative to %s; a matching field exists on two or more implemented interfaces.\", new Object[] { fieldName, cls });\n-                match = test;\n+                final Field field2 = clazz2.getField(s);\n+                Validate.isTrue(field == null, \"Reference to field %s is ambiguous relative to %s; a matching field exists on two or more implemented interfaces.\", new Object[] { s, clazz });\n+                field = field2;\n             }\n             catch (final NoSuchFieldException ex2) {}\n         }\n-        return match;\n+        return field;\n     }\n     \n-    public static Field getDeclaredField(final Class<?> cls, final String fieldName) {\n-        return getDeclaredField(cls, fieldName, false);\n+    public static Field getDeclaredField(final Class<?> clazz, final String s) {\n+        return getDeclaredField(clazz, s, false);\n     }\n     \n-    public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) {\n-        Validate.notNull((Object)cls, \"cls\", new Object[0]);\n-        Validate.isTrue(StringUtils.isNotBlank((CharSequence)fieldName), \"The field name must not be blank/empty\", new Object[0]);\n+    public static Field getDeclaredField(final Class<?> clazz, final String name, final boolean b) {\n+        Validate.notNull((Object)clazz, \"cls\", new Object[0]);\n+        Validate.isTrue(StringUtils.isNotBlank((CharSequence)name), \"The field name must not be blank/empty\", new Object[0]);\n         try {\n-            final Field field = cls.getDeclaredField(fieldName);\n-            if (!MemberUtils.isAccessible((Member)field)) {\n-                if (!forceAccess) {\n+            final Field declaredField = clazz.getDeclaredField(name);\n+            if (!MemberUtils.isAccessible((Member)declaredField)) {\n+                if (!b) {\n                     return null;\n                 }\n-                field.setAccessible(true);\n+                declaredField.setAccessible(true);\n             }\n-            return field;\n+            return declaredField;\n         }\n         catch (final NoSuchFieldException ex) {\n             return null;\n         }\n     }\n     \n-    public static Field[] getAllFields(final Class<?> cls) {\n-        final List<Field> allFieldsList = getAllFieldsList(cls);\n-        return allFieldsList.toArray(ArrayUtils.EMPTY_FIELD_ARRAY);\n+    public static Field[] getAllFields(final Class<?> clazz) {\n+        return getAllFieldsList(clazz).toArray(ArrayUtils.EMPTY_FIELD_ARRAY);\n     }\n     \n-    public static List<Field> getAllFieldsList(final Class<?> cls) {\n-        Validate.notNull((Object)cls, \"cls\", new Object[0]);\n-        final List<Field> allFields = new ArrayList<Field>();\n-        for (Class<?> currentClass = cls; currentClass != null; currentClass = currentClass.getSuperclass()) {\n-            final Field[] declaredFields = currentClass.getDeclaredFields();\n-            Collections.addAll(allFields, declaredFields);\n+    public static List<Field> getAllFieldsList(final Class<?> clazz) {\n+        Validate.notNull((Object)clazz, \"cls\", new Object[0]);\n+        final ArrayList c = new ArrayList();\n+        for (Class<?> superclass = clazz; superclass != null; superclass = superclass.getSuperclass()) {\n+            Collections.addAll(c, superclass.getDeclaredFields());\n         }\n-        return allFields;\n+        return c;\n     }\n     \n-    public static Field[] getFieldsWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls) {\n-        final List<Field> annotatedFieldsList = getFieldsListWithAnnotation(cls, annotationCls);\n-        return annotatedFieldsList.toArray(ArrayUtils.EMPTY_FIELD_ARRAY);\n+    public static Field[] getFieldsWithAnnotation(final Class<?> clazz, final Class<? extends Annotation> clazz2) {\n+        return getFieldsListWithAnnotation(clazz, clazz2).toArray(ArrayUtils.EMPTY_FIELD_ARRAY);\n     }\n     \n-    public static List<Field> getFieldsListWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls) {\n-        Validate.notNull((Object)annotationCls, \"annotationCls\", new Object[0]);\n-        final List<Field> allFields = getAllFieldsList(cls);\n-        final List<Field> annotatedFields = new ArrayList<Field>();\n-        for (final Field field : allFields) {\n-            if (field.getAnnotation(annotationCls) != null) {\n-                annotatedFields.add(field);\n+    public static List<Field> getFieldsListWithAnnotation(final Class<?> clazz, final Class<? extends Annotation> annotationClass) {\n+        Validate.notNull((Object)annotationClass, \"annotationCls\", new Object[0]);\n+        final List<Field> allFieldsList = getAllFieldsList(clazz);\n+        final ArrayList list = new ArrayList();\n+        for (final Field field : allFieldsList) {\n+            if (field.getAnnotation(annotationClass) != null) {\n+                list.add(field);\n             }\n         }\n-        return annotatedFields;\n+        return list;\n     }\n     \n     public static Object readStaticField(final Field field) throws IllegalAccessException {\n         return readStaticField(field, false);\n     }\n     \n-    public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException {\n+    public static Object readStaticField(final Field field, final boolean b) throws IllegalAccessException {\n         Validate.notNull((Object)field, \"field\", new Object[0]);\n         Validate.isTrue(Modifier.isStatic(field.getModifiers()), \"The field '%s' is not static\", new Object[] { field.getName() });\n-        return readField(field, (Object)null, forceAccess);\n+        return readField(field, (Object)null, b);\n     }\n     \n-    public static Object readStaticField(final Class<?> cls, final String fieldName) throws IllegalAccessException {\n-        return readStaticField(cls, fieldName, false);\n+    public static Object readStaticField(final Class<?> clazz, final String s) throws IllegalAccessException {\n+        return readStaticField(clazz, s, false);\n     }\n     \n-    public static Object readStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException {\n-        final Field field = getField(cls, fieldName, forceAccess);\n-        Validate.notNull((Object)field, \"Cannot locate field '%s' on %s\", new Object[] { fieldName, cls });\n+    public static Object readStaticField(final Class<?> clazz, final String s, final boolean b) throws IllegalAccessException {\n+        final Field field = getField(clazz, s, b);\n+        Validate.notNull((Object)field, \"Cannot locate field '%s' on %s\", new Object[] { s, clazz });\n         return readStaticField(field, false);\n     }\n     \n-    public static Object readDeclaredStaticField(final Class<?> cls, final String fieldName) throws IllegalAccessException {\n-        return readDeclaredStaticField(cls, fieldName, false);\n+    public static Object readDeclaredStaticField(final Class<?> clazz, final String s) throws IllegalAccessException {\n+        return readDeclaredStaticField(clazz, s, false);\n     }\n     \n-    public static Object readDeclaredStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException {\n-        final Field field = getDeclaredField(cls, fieldName, forceAccess);\n-        Validate.notNull((Object)field, \"Cannot locate declared field %s.%s\", new Object[] { cls.getName(), fieldName });\n-        return readStaticField(field, false);\n+    public static Object readDeclaredStaticField(final Class<?> clazz, final String s, final boolean b) throws IllegalAccessException {\n+        final Field declaredField = getDeclaredField(clazz, s, b);\n+        Validate.notNull((Object)declaredField, \"Cannot locate declared field %s.%s\", new Object[] { clazz.getName(), s });\n+        return readStaticField(declaredField, false);\n     }\n     \n-    public static Object readField(final Field field, final Object target) throws IllegalAccessException {\n-        return readField(field, target, false);\n+    public static Object readField(final Field field, final Object o) throws IllegalAccessException {\n+        return readField(field, o, false);\n     }\n     \n-    public static Object readField(final Field field, final Object target, final boolean forceAccess) throws IllegalAccessException {\n-        Validate.notNull((Object)field, \"field\", new Object[0]);\n-        if (forceAccess && !field.isAccessible()) {\n-            field.setAccessible(true);\n+    public static Object readField(final Field accessibleWorkaround, final Object obj, final boolean b) throws IllegalAccessException {\n+        Validate.notNull((Object)accessibleWorkaround, \"field\", new Object[0]);\n+        if (b && !accessibleWorkaround.isAccessible()) {\n+            accessibleWorkaround.setAccessible(true);\n         }\n         else {\n-            MemberUtils.setAccessibleWorkaround((AccessibleObject)field);\n+            MemberUtils.setAccessibleWorkaround((AccessibleObject)accessibleWorkaround);\n         }\n-        return field.get(target);\n+        return accessibleWorkaround.get(obj);\n     }\n     \n-    public static Object readField(final Object target, final String fieldName) throws IllegalAccessException {\n-        return readField(target, fieldName, false);\n+    public static Object readField(final Object o, final String s) throws IllegalAccessException {\n+        return readField(o, s, false);\n     }\n     \n-    public static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException {\n-        Validate.notNull(target, \"target\", new Object[0]);\n-        final Class<?> cls = target.getClass();\n-        final Field field = getField(cls, fieldName, forceAccess);\n-        Validate.isTrue(field != null, \"Cannot locate field %s on %s\", new Object[] { fieldName, cls });\n-        return readField(field, target, false);\n+    public static Object readField(final Object o, final String s, final boolean b) throws IllegalAccessException {\n+        Validate.notNull(o, \"target\", new Object[0]);\n+        final Class<?> class1 = o.getClass();\n+        final Field field = getField(class1, s, b);\n+        Validate.isTrue(field != null, \"Cannot locate field %s on %s\", new Object[] { s, class1 });\n+        return readField(field, o, false);\n     }\n     \n-    public static Object readDeclaredField(final Object target, final String fieldName) throws IllegalAccessException {\n-        return readDeclaredField(target, fieldName, false);\n+    public static Object readDeclaredField(final Object o, final String s) throws IllegalAccessException {\n+        return readDeclaredField(o, s, false);\n     }\n     \n-    public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException {\n-        Validate.notNull(target, \"target\", new Object[0]);\n-        final Class<?> cls = target.getClass();\n-        final Field field = getDeclaredField(cls, fieldName, forceAccess);\n-        Validate.isTrue(field != null, \"Cannot locate declared field %s.%s\", new Object[] { cls, fieldName });\n-        return readField(field, target, false);\n+    public static Object readDeclaredField(final Object o, final String s, final boolean b) throws IllegalAccessException {\n+        Validate.notNull(o, \"target\", new Object[0]);\n+        final Class<?> class1 = o.getClass();\n+        final Field declaredField = getDeclaredField(class1, s, b);\n+        Validate.isTrue(declaredField != null, \"Cannot locate declared field %s.%s\", new Object[] { class1, s });\n+        return readField(declaredField, o, false);\n     }\n     \n-    public static void writeStaticField(final Field field, final Object value) throws IllegalAccessException {\n-        writeStaticField(field, value, false);\n+    public static void writeStaticField(final Field field, final Object o) throws IllegalAccessException {\n+        writeStaticField(field, o, false);\n     }\n     \n-    public static void writeStaticField(final Field field, final Object value, final boolean forceAccess) throws IllegalAccessException {\n+    public static void writeStaticField(final Field field, final Object o, final boolean b) throws IllegalAccessException {\n         Validate.notNull((Object)field, \"field\", new Object[0]);\n         Validate.isTrue(Modifier.isStatic(field.getModifiers()), \"The field %s.%s is not static\", new Object[] { field.getDeclaringClass().getName(), field.getName() });\n-        writeField(field, (Object)null, value, forceAccess);\n+        writeField(field, (Object)null, o, b);\n     }\n     \n-    public static void writeStaticField(final Class<?> cls, final String fieldName, final Object value) throws IllegalAccessException {\n-        writeStaticField(cls, fieldName, value, false);\n+    public static void writeStaticField(final Class<?> clazz, final String s, final Object o) throws IllegalAccessException {\n+        writeStaticField(clazz, s, o, false);\n     }\n     \n-    public static void writeStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException {\n-        final Field field = getField(cls, fieldName, forceAccess);\n-        Validate.notNull((Object)field, \"Cannot locate field %s on %s\", new Object[] { fieldName, cls });\n-        writeStaticField(field, value, false);\n+    public static void writeStaticField(final Class<?> clazz, final String s, final Object o, final boolean b) throws IllegalAccessException {\n+        final Field field = getField(clazz, s, b);\n+        Validate.notNull((Object)field, \"Cannot locate field %s on %s\", new Object[] { s, clazz });\n+        writeStaticField(field, o, false);\n     }\n     \n-    public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value) throws IllegalAccessException {\n-        writeDeclaredStaticField(cls, fieldName, value, false);\n+    public static void writeDeclaredStaticField(final Class<?> clazz, final String s, final Object o) throws IllegalAccessException {\n+        writeDeclaredStaticField(clazz, s, o, false);\n     }\n     \n-    public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException {\n-        final Field field = getDeclaredField(cls, fieldName, forceAccess);\n-        Validate.notNull((Object)field, \"Cannot locate declared field %s.%s\", new Object[] { cls.getName(), fieldName });\n-        writeField(field, (Object)null, value, false);\n+    public static void writeDeclaredStaticField(final Class<?> clazz, final String s, final Object o, final boolean b) throws IllegalAccessException {\n+        final Field declaredField = getDeclaredField(clazz, s, b);\n+        Validate.notNull((Object)declaredField, \"Cannot locate declared field %s.%s\", new Object[] { clazz.getName(), s });\n+        writeField(declaredField, (Object)null, o, false);\n     }\n     \n-    public static void writeField(final Field field, final Object target, final Object value) throws IllegalAccessException {\n-        writeField(field, target, value, false);\n+    public static void writeField(final Field field, final Object o, final Object o2) throws IllegalAccessException {\n+        writeField(field, o, o2, false);\n     }\n     \n-    public static void writeField(final Field field, final Object target, final Object value, final boolean forceAccess) throws IllegalAccessException {\n-        Validate.notNull((Object)field, \"field\", new Object[0]);\n-        if (forceAccess && !field.isAccessible()) {\n-            field.setAccessible(true);\n+    public static void writeField(final Field accessibleWorkaround, final Object obj, final Object value, final boolean b) throws IllegalAccessException {\n+        Validate.notNull((Object)accessibleWorkaround, \"field\", new Object[0]);\n+        if (b && !accessibleWorkaround.isAccessible()) {\n+            accessibleWorkaround.setAccessible(true);\n         }\n         else {\n-            MemberUtils.setAccessibleWorkaround((AccessibleObject)field);\n+            MemberUtils.setAccessibleWorkaround((AccessibleObject)accessibleWorkaround);\n         }\n-        field.set(target, value);\n+        accessibleWorkaround.set(obj, value);\n     }\n     \n     public static void removeFinalModifier(final Field field) {\n         removeFinalModifier(field, true);\n     }\n     \n     @Deprecated\n-    public static void removeFinalModifier(final Field field, final boolean forceAccess) {\n-        Validate.notNull((Object)field, \"field\", new Object[0]);\n+    public static void removeFinalModifier(final Field obj, final boolean b) {\n+        Validate.notNull((Object)obj, \"field\", new Object[0]);\n         try {\n-            if (Modifier.isFinal(field.getModifiers())) {\n-                final Field modifiersField = Field.class.getDeclaredField(\"modifiers\");\n-                final boolean doForceAccess = forceAccess && !modifiersField.isAccessible();\n-                if (doForceAccess) {\n-                    modifiersField.setAccessible(true);\n+            if (Modifier.isFinal(obj.getModifiers())) {\n+                final Field declaredField = Field.class.getDeclaredField(\"modifiers\");\n+                final boolean b2 = b && !declaredField.isAccessible();\n+                if (b2) {\n+                    declaredField.setAccessible(true);\n                 }\n                 try {\n-                    modifiersField.setInt(field, field.getModifiers() & 0xFFFFFFEF);\n+                    declaredField.setInt(obj, obj.getModifiers() & 0xFFFFFFEF);\n                 }\n                 finally {\n-                    if (doForceAccess) {\n-                        modifiersField.setAccessible(false);\n+                    if (b2) {\n+                        declaredField.setAccessible(false);\n                     }\n                 }\n             }\n         }\n-        catch (final NoSuchFieldException | IllegalAccessException e) {\n+        catch (final NoSuchFieldException | IllegalAccessException cause) {\n             if (SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_12)) {\n-                throw new UnsupportedOperationException(\"In java 12+ final cannot be removed.\", e);\n+                throw new UnsupportedOperationException(\"In java 12+ final cannot be removed.\", (Throwable)cause);\n             }\n         }\n     }\n     \n-    public static void writeField(final Object target, final String fieldName, final Object value) throws IllegalAccessException {\n-        writeField(target, fieldName, value, false);\n+    public static void writeField(final Object o, final String s, final Object o2) throws IllegalAccessException {\n+        writeField(o, s, o2, false);\n     }\n     \n-    public static void writeField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException {\n-        Validate.notNull(target, \"target\", new Object[0]);\n-        final Class<?> cls = target.getClass();\n-        final Field field = getField(cls, fieldName, forceAccess);\n-        Validate.isTrue(field != null, \"Cannot locate declared field %s.%s\", new Object[] { cls.getName(), fieldName });\n-        writeField(field, target, value, false);\n+    public static void writeField(final Object o, final String s, final Object o2, final boolean b) throws IllegalAccessException {\n+        Validate.notNull(o, \"target\", new Object[0]);\n+        final Class<?> class1 = o.getClass();\n+        final Field field = getField(class1, s, b);\n+        Validate.isTrue(field != null, \"Cannot locate declared field %s.%s\", new Object[] { class1.getName(), s });\n+        writeField(field, o, o2, false);\n     }\n     \n-    public static void writeDeclaredField(final Object target, final String fieldName, final Object value) throws IllegalAccessException {\n-        writeDeclaredField(target, fieldName, value, false);\n+    public static void writeDeclaredField(final Object o, final String s, final Object o2) throws IllegalAccessException {\n+        writeDeclaredField(o, s, o2, false);\n     }\n     \n-    public static void writeDeclaredField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException {\n-        Validate.notNull(target, \"target\", new Object[0]);\n-        final Class<?> cls = target.getClass();\n-        final Field field = getDeclaredField(cls, fieldName, forceAccess);\n-        Validate.isTrue(field != null, \"Cannot locate declared field %s.%s\", new Object[] { cls.getName(), fieldName });\n-        writeField(field, target, value, false);\n+    public static void writeDeclaredField(final Object o, final String s, final Object o2, final boolean b) throws IllegalAccessException {\n+        Validate.notNull(o, \"target\", new Object[0]);\n+        final Class<?> class1 = o.getClass();\n+        final Field declaredField = getDeclaredField(class1, s, b);\n+        Validate.isTrue(declaredField != null, \"Cannot locate declared field %s.%s\", new Object[] { class1.getName(), s });\n+        writeField(declaredField, o, o2, false);\n     }\n }\n"}]}
