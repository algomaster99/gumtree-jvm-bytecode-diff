{"diffoscope-json-version": 1, "source1": "first/ModelTransaction.class", "source2": "second/ModelTransaction.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -26,131 +26,129 @@\n     private final Collection<ImmutableNode> addedNodes;\n     private final Collection<ImmutableNode> removedNodes;\n     private final Collection<ImmutableNode> allRemovedNodes;\n     private final SortedMap<Integer, Map<ImmutableNode, ModelTransaction.Operations>> operations;\n     private Map<ImmutableNode, Object> newReferences;\n     private ImmutableNode newRoot;\n     \n-    public ModelTransaction(final TreeData treeData, final NodeSelector selector, final NodeKeyResolver<ImmutableNode> resolver) {\n-        this.currentData = treeData;\n+    public ModelTransaction(final TreeData currentData, final NodeSelector rootNodeSelector, final NodeKeyResolver<ImmutableNode> resolver) {\n+        this.currentData = currentData;\n         this.resolver = resolver;\n         this.replacementMapping = this.getCurrentData().copyReplacementMapping();\n         this.replacedNodes = new HashMap<ImmutableNode, ImmutableNode>();\n         this.parentMapping = this.getCurrentData().copyParentMapping();\n         this.operations = new TreeMap<Integer, Map<ImmutableNode, ModelTransaction.Operations>>();\n         this.addedNodes = new LinkedList<ImmutableNode>();\n         this.removedNodes = new LinkedList<ImmutableNode>();\n         this.allRemovedNodes = new LinkedList<ImmutableNode>();\n-        this.queryRoot = this.initQueryRoot(treeData, selector);\n-        this.rootNodeSelector = selector;\n+        this.queryRoot = this.initQueryRoot(currentData, rootNodeSelector);\n+        this.rootNodeSelector = rootNodeSelector;\n     }\n     \n     public NodeKeyResolver<ImmutableNode> getResolver() {\n         return this.resolver;\n     }\n     \n     public ImmutableNode getQueryRoot() {\n         return this.queryRoot;\n     }\n     \n-    public void addAddNodesOperation(final ImmutableNode parent, final Collection<? extends ImmutableNode> newNodes) {\n-        final ModelTransaction.ChildrenUpdateOperation op = new ModelTransaction.ChildrenUpdateOperation(this, (ModelTransaction.ModelTransaction$1)null);\n-        op.addNewNodes((Collection)newNodes);\n-        this.fetchOperations(parent, -1).addChildrenOperation(op);\n+    public void addAddNodesOperation(final ImmutableNode immutableNode, final Collection<? extends ImmutableNode> collection) {\n+        final ModelTransaction.ChildrenUpdateOperation childrenUpdateOperation = new ModelTransaction.ChildrenUpdateOperation(this, (ModelTransaction.ModelTransaction$1)null);\n+        childrenUpdateOperation.addNewNodes((Collection)collection);\n+        this.fetchOperations(immutableNode, -1).addChildrenOperation(childrenUpdateOperation);\n     }\n     \n-    public void addAddNodeOperation(final ImmutableNode parent, final ImmutableNode newChild) {\n-        final ModelTransaction.ChildrenUpdateOperation op = new ModelTransaction.ChildrenUpdateOperation(this, (ModelTransaction.ModelTransaction$1)null);\n-        op.addNewNode(newChild);\n-        this.fetchOperations(parent, -1).addChildrenOperation(op);\n+    public void addAddNodeOperation(final ImmutableNode immutableNode, final ImmutableNode immutableNode2) {\n+        final ModelTransaction.ChildrenUpdateOperation childrenUpdateOperation = new ModelTransaction.ChildrenUpdateOperation(this, (ModelTransaction.ModelTransaction$1)null);\n+        childrenUpdateOperation.addNewNode(immutableNode2);\n+        this.fetchOperations(immutableNode, -1).addChildrenOperation(childrenUpdateOperation);\n     }\n     \n-    public void addAttributeOperation(final ImmutableNode target, final String name, final Object value) {\n-        this.fetchOperations(target, -1).addOperation((ModelTransaction.Operation)new ModelTransaction.AddAttributeOperation(name, value));\n+    public void addAttributeOperation(final ImmutableNode immutableNode, final String s, final Object o) {\n+        this.fetchOperations(immutableNode, -1).addOperation((ModelTransaction.Operation)new ModelTransaction.AddAttributeOperation(s, o));\n     }\n     \n-    public void addAttributesOperation(final ImmutableNode target, final Map<String, Object> attributes) {\n-        this.fetchOperations(target, -1).addOperation((ModelTransaction.Operation)new ModelTransaction.AddAttributesOperation((Map)attributes));\n+    public void addAttributesOperation(final ImmutableNode immutableNode, final Map<String, Object> map) {\n+        this.fetchOperations(immutableNode, -1).addOperation((ModelTransaction.Operation)new ModelTransaction.AddAttributesOperation((Map)map));\n     }\n     \n-    public void addRemoveNodeOperation(final ImmutableNode parent, final ImmutableNode node) {\n-        final ModelTransaction.ChildrenUpdateOperation op = new ModelTransaction.ChildrenUpdateOperation(this, (ModelTransaction.ModelTransaction$1)null);\n-        op.addNodeToRemove(node);\n-        this.fetchOperations(parent, -1).addChildrenOperation(op);\n+    public void addRemoveNodeOperation(final ImmutableNode immutableNode, final ImmutableNode immutableNode2) {\n+        final ModelTransaction.ChildrenUpdateOperation childrenUpdateOperation = new ModelTransaction.ChildrenUpdateOperation(this, (ModelTransaction.ModelTransaction$1)null);\n+        childrenUpdateOperation.addNodeToRemove(immutableNode2);\n+        this.fetchOperations(immutableNode, -1).addChildrenOperation(childrenUpdateOperation);\n     }\n     \n-    public void addRemoveAttributeOperation(final ImmutableNode target, final String name) {\n-        this.fetchOperations(target, -1).addOperation((ModelTransaction.Operation)new ModelTransaction.RemoveAttributeOperation(name));\n+    public void addRemoveAttributeOperation(final ImmutableNode immutableNode, final String s) {\n+        this.fetchOperations(immutableNode, -1).addOperation((ModelTransaction.Operation)new ModelTransaction.RemoveAttributeOperation(s));\n     }\n     \n-    public void addClearNodeValueOperation(final ImmutableNode target) {\n-        this.addChangeNodeValueOperation(target, null);\n+    public void addClearNodeValueOperation(final ImmutableNode immutableNode) {\n+        this.addChangeNodeValueOperation(immutableNode, null);\n     }\n     \n-    public void addChangeNodeValueOperation(final ImmutableNode target, final Object newValue) {\n-        this.fetchOperations(target, -1).addOperation((ModelTransaction.Operation)new ModelTransaction.ChangeNodeValueOperation(newValue));\n+    public void addChangeNodeValueOperation(final ImmutableNode immutableNode, final Object o) {\n+        this.fetchOperations(immutableNode, -1).addOperation((ModelTransaction.Operation)new ModelTransaction.ChangeNodeValueOperation(o));\n     }\n     \n-    public void addChangeNodeNameOperation(final ImmutableNode target, final String newName) {\n-        this.fetchOperations(target, -1).addOperation((ModelTransaction.Operation)new ModelTransaction.ChangeNodeNameOperation(newName));\n+    public void addChangeNodeNameOperation(final ImmutableNode immutableNode, final String s) {\n+        this.fetchOperations(immutableNode, -1).addOperation((ModelTransaction.Operation)new ModelTransaction.ChangeNodeNameOperation(s));\n     }\n     \n-    public void addNewReferences(final Map<ImmutableNode, ?> refs) {\n-        this.fetchReferenceMap().putAll(refs);\n+    public void addNewReferences(final Map<ImmutableNode, ?> map) {\n+        this.fetchReferenceMap().putAll(map);\n     }\n     \n-    public void addNewReference(final ImmutableNode node, final Object ref) {\n-        this.fetchReferenceMap().put(node, ref);\n+    public void addNewReference(final ImmutableNode immutableNode, final Object o) {\n+        this.fetchReferenceMap().put(immutableNode, o);\n     }\n     \n     public TreeData execute() {\n         this.executeOperations();\n         this.updateParentMapping();\n         return new TreeData(this.newRoot, (Map)this.parentMapping, (Map)this.replacementMapping, this.currentData.getNodeTracker().update(this.newRoot, this.rootNodeSelector, (NodeKeyResolver)this.getResolver(), (NodeHandler)this.getCurrentData()), this.updateReferenceTracker());\n     }\n     \n     public TreeData getCurrentData() {\n         return this.currentData;\n     }\n     \n-    ImmutableNode getParent(final ImmutableNode node) {\n-        return this.getCurrentData().getParent(node);\n+    ImmutableNode getParent(final ImmutableNode immutableNode) {\n+        return this.getCurrentData().getParent(immutableNode);\n     }\n     \n-    ModelTransaction.Operations fetchOperations(final ImmutableNode target, final int level) {\n-        final Integer nodeLevel = Integer.valueOf((level == -1) ? this.level(target) : level);\n-        final Map<ImmutableNode, ModelTransaction.Operations> levelOperations = (Map<ImmutableNode, ModelTransaction.Operations>)this.operations.computeIfAbsent(nodeLevel, k -> new HashMap());\n-        ModelTransaction.Operations ops = (ModelTransaction.Operations)levelOperations.get(target);\n-        if (ops == null) {\n-            ops = new ModelTransaction.Operations(this, (ModelTransaction.ModelTransaction$1)null);\n-            levelOperations.put(target, ops);\n+    ModelTransaction.Operations fetchOperations(final ImmutableNode immutableNode, final int n) {\n+        final Map map = (Map)this.operations.computeIfAbsent(Integer.valueOf((n == -1) ? this.level(immutableNode) : n), p0 -> new HashMap());\n+        ModelTransaction.Operations operations = (ModelTransaction.Operations)map.get(immutableNode);\n+        if (operations == null) {\n+            operations = new ModelTransaction.Operations(this, (ModelTransaction.ModelTransaction$1)null);\n+            map.put(immutableNode, operations);\n         }\n-        return ops;\n+        return operations;\n     }\n     \n-    private ImmutableNode initQueryRoot(final TreeData treeData, final NodeSelector selector) {\n-        return (selector == null) ? treeData.getRootNode() : treeData.getNodeTracker().getTrackedNode(selector);\n+    private ImmutableNode initQueryRoot(final TreeData treeData, final NodeSelector nodeSelector) {\n+        return (nodeSelector == null) ? treeData.getRootNode() : treeData.getNodeTracker().getTrackedNode(nodeSelector);\n     }\n     \n-    private int level(final ImmutableNode node) {\n-        ImmutableNode current = this.getCurrentData().getParent(node);\n-        int level = 0;\n-        while (current != null) {\n-            ++level;\n-            current = this.getCurrentData().getParent(current);\n+    private int level(final ImmutableNode immutableNode) {\n+        ImmutableNode immutableNode2 = this.getCurrentData().getParent(immutableNode);\n+        int n = 0;\n+        while (immutableNode2 != null) {\n+            ++n;\n+            immutableNode2 = this.getCurrentData().getParent(immutableNode2);\n         }\n-        return level;\n+        return n;\n     }\n     \n     private void executeOperations() {\n         while (!this.operations.isEmpty()) {\n-            final Integer level = Integer.valueOf(this.operations.lastKey());\n-            final Map<ImmutableNode, ModelTransaction.Operations> levelOps = (Map<ImmutableNode, ModelTransaction.Operations>)this.operations.remove(level);\n-            for (final Map.Entry<ImmutableNode, ModelTransaction.Operations> e : levelOps.entrySet()) {\n-                ((ModelTransaction.Operations)e.getValue()).apply((ImmutableNode)e.getKey(), (int)level);\n+            final Integer n = Integer.valueOf(this.operations.lastKey());\n+            for (final Map.Entry entry : ((Map)this.operations.remove(n)).entrySet()) {\n+                ((ModelTransaction.Operations)entry.getValue()).apply((ImmutableNode)entry.getKey(), (int)n);\n             }\n         }\n     }\n     \n     private void updateParentMapping() {\n         this.replacementMapping.putAll(this.replacedNodes);\n         if (this.replacementMapping.size() > 200) {\n@@ -165,89 +163,91 @@\n     private void rebuildParentMapping() {\n         this.replacementMapping.clear();\n         this.parentMapping.clear();\n         InMemoryNodeModel.updateParentMapping((Map)this.parentMapping, this.newRoot);\n     }\n     \n     private void updateParentMappingForAddedNodes() {\n-        for (final ImmutableNode node : this.addedNodes) {\n-            InMemoryNodeModel.updateParentMapping((Map)this.parentMapping, node);\n+        final Iterator<ImmutableNode> iterator = this.addedNodes.iterator();\n+        while (iterator.hasNext()) {\n+            InMemoryNodeModel.updateParentMapping((Map)this.parentMapping, (ImmutableNode)iterator.next());\n         }\n     }\n     \n     private void updateParentMappingForRemovedNodes() {\n-        for (final ImmutableNode node : this.removedNodes) {\n-            this.removeNodesFromParentAndReplacementMapping(node);\n+        final Iterator<ImmutableNode> iterator = this.removedNodes.iterator();\n+        while (iterator.hasNext()) {\n+            this.removeNodesFromParentAndReplacementMapping(iterator.next());\n         }\n     }\n     \n-    private void removeNodesFromParentAndReplacementMapping(final ImmutableNode root) {\n-        NodeTreeWalker.INSTANCE.walkBFS((Object)root, (ConfigurationNodeVisitor)new ModelTransaction.ModelTransaction$1(this), (NodeHandler)this.getCurrentData());\n+    private void removeNodesFromParentAndReplacementMapping(final ImmutableNode immutableNode) {\n+        NodeTreeWalker.INSTANCE.walkBFS((Object)immutableNode, (ConfigurationNodeVisitor)new ModelTransaction.ModelTransaction$1(this), (NodeHandler)this.getCurrentData());\n     }\n     \n-    private void removeNodeFromReplacementMapping(final ImmutableNode node) {\n-        ImmutableNode replacement = node;\n+    private void removeNodeFromReplacementMapping(final ImmutableNode immutableNode) {\n+        ImmutableNode immutableNode2 = immutableNode;\n         do {\n-            replacement = this.replacementMapping.remove(replacement);\n-        } while (replacement != null);\n+            immutableNode2 = this.replacementMapping.remove(immutableNode2);\n+        } while (immutableNode2 != null);\n     }\n     \n     private ReferenceTracker updateReferenceTracker() {\n-        ReferenceTracker tracker = this.currentData.getReferenceTracker();\n+        ReferenceTracker referenceTracker = this.currentData.getReferenceTracker();\n         if (this.newReferences != null) {\n-            tracker = tracker.addReferences((Map)this.newReferences);\n+            referenceTracker = referenceTracker.addReferences((Map)this.newReferences);\n         }\n-        return tracker.updateReferences((Map)this.replacedNodes, (Collection)this.allRemovedNodes);\n+        return referenceTracker.updateReferences((Map)this.replacedNodes, (Collection)this.allRemovedNodes);\n     }\n     \n     private Map<ImmutableNode, Object> fetchReferenceMap() {\n         if (this.newReferences == null) {\n             this.newReferences = new HashMap<ImmutableNode, Object>();\n         }\n         return this.newReferences;\n     }\n     \n-    private static <E> Collection<E> concatenate(final Collection<E> col1, final Collection<? extends E> col2) {\n-        if (col2 == null) {\n-            return col1;\n+    private static <E> Collection<E> concatenate(final Collection<E> collection, final Collection<? extends E> collection2) {\n+        if (collection2 == null) {\n+            return collection;\n         }\n-        final Collection<E> result = (col1 != null) ? col1 : new ArrayList<E>(col2.size());\n-        result.addAll(col2);\n-        return result;\n+        final ArrayList<E> list = (ArrayList<E>)((collection != null) ? collection : new ArrayList<E>(collection2.size()));\n+        list.addAll((Collection<?>)collection2);\n+        return list;\n     }\n     \n-    private static <E> Set<E> concatenate(final Set<E> set1, final Set<? extends E> set2) {\n+    private static <E> Set<E> concatenate(final Set<E> set, final Set<? extends E> set2) {\n         if (set2 == null) {\n-            return set1;\n+            return set;\n         }\n-        final Set<E> result = (set1 != null) ? set1 : new HashSet<E>();\n-        result.addAll(set2);\n-        return result;\n+        final HashSet<E> set3 = (HashSet<E>)((set != null) ? set : new HashSet<E>());\n+        set3.addAll((Collection<?>)set2);\n+        return set3;\n     }\n     \n-    private static <K, V> Map<K, V> concatenate(final Map<K, V> map1, final Map<? extends K, ? extends V> map2) {\n+    private static <K, V> Map<K, V> concatenate(final Map<K, V> map, final Map<? extends K, ? extends V> map2) {\n         if (map2 == null) {\n-            return map1;\n+            return map;\n         }\n-        final Map<K, V> result = (map1 != null) ? map1 : new HashMap<K, V>();\n-        result.putAll(map2);\n-        return result;\n+        final HashMap<K, V> hashMap = (HashMap<K, V>)((map != null) ? map : new HashMap<K, V>());\n+        hashMap.putAll((Map<?, ?>)map2);\n+        return hashMap;\n     }\n     \n-    private static <E> Collection<E> append(final Collection<E> col, final E node) {\n-        final Collection<E> result = (col != null) ? col : new LinkedList<E>();\n-        result.add(node);\n-        return result;\n+    private static <E> Collection<E> append(final Collection<E> collection, final E e) {\n+        final LinkedList<E> list = (LinkedList<E>)((collection != null) ? collection : new LinkedList<E>());\n+        list.add(e);\n+        return list;\n     }\n     \n-    private static <E> Set<E> append(final Set<E> col, final E elem) {\n-        final Set<E> result = (col != null) ? col : new HashSet<E>();\n-        result.add(elem);\n-        return result;\n+    private static <E> Set<E> append(final Set<E> set, final E e) {\n+        final HashSet<E> set2 = (HashSet<E>)((set != null) ? set : new HashSet<E>());\n+        set2.add(e);\n+        return set2;\n     }\n     \n-    private static <K, V> Map<K, V> append(final Map<K, V> map, final K key, final V value) {\n-        final Map<K, V> result = (map != null) ? map : new HashMap<K, V>();\n-        result.put(key, value);\n-        return result;\n+    private static <K, V> Map<K, V> append(final Map<K, V> map, final K k, final V v) {\n+        final HashMap<K, V> hashMap = (HashMap<K, V>)((map != null) ? map : new HashMap<K, V>());\n+        hashMap.put(k, v);\n+        return hashMap;\n     }\n }\n"}]}
