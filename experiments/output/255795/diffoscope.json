{"diffoscope-json-version": 1, "source1": "first/FramedLZ4CompressorInputStream.class", "source2": "second/FramedLZ4CompressorInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -37,24 +37,24 @@\n     private InputStream currentBlock;\n     private boolean endReached;\n     private boolean inUncompressed;\n     private final XXHash32 contentHash;\n     private final XXHash32 blockHash;\n     private byte[] blockDependencyBuffer;\n     \n-    public FramedLZ4CompressorInputStream(final InputStream in) throws IOException {\n-        this(in, false);\n+    public FramedLZ4CompressorInputStream(final InputStream inputStream) throws IOException {\n+        this(inputStream, false);\n     }\n     \n-    public FramedLZ4CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException {\n+    public FramedLZ4CompressorInputStream(final InputStream inputStream, final boolean decompressConcatenated) throws IOException {\n         this.oneByte = new byte[1];\n         this.supplier = this::readOneByte;\n         this.contentHash = new XXHash32();\n         this.blockHash = new XXHash32();\n-        this.inputStream = new CountingInputStream(in);\n+        this.inputStream = new CountingInputStream(inputStream);\n         this.decompressConcatenated = decompressConcatenated;\n         this.init(true);\n     }\n     \n     public int read() throws IOException {\n         return (this.read(this.oneByte, 0, 1) == -1) ? -1 : (this.oneByte[0] & 0xFF);\n     }\n@@ -67,152 +67,152 @@\n             }\n         }\n         finally {\n             this.inputStream.close();\n         }\n     }\n     \n-    public int read(final byte[] b, final int off, final int len) throws IOException {\n-        if (len == 0) {\n+    public int read(final byte[] array, final int n, final int n2) throws IOException {\n+        if (n2 == 0) {\n             return 0;\n         }\n         if (this.endReached) {\n             return -1;\n         }\n-        int r = this.readOnce(b, off, len);\n-        if (r == -1) {\n+        int n3 = this.readOnce(array, n, n2);\n+        if (n3 == -1) {\n             this.nextBlock();\n             if (!this.endReached) {\n-                r = this.readOnce(b, off, len);\n+                n3 = this.readOnce(array, n, n2);\n             }\n         }\n-        if (r != -1) {\n+        if (n3 != -1) {\n             if (this.expectBlockDependency) {\n-                this.appendToBlockDependencyBuffer(b, off, r);\n+                this.appendToBlockDependencyBuffer(array, n, n3);\n             }\n             if (this.expectContentChecksum) {\n-                this.contentHash.update(b, off, r);\n+                this.contentHash.update(array, n, n3);\n             }\n         }\n-        return r;\n+        return n3;\n     }\n     \n     public long getCompressedCount() {\n         return this.inputStream.getBytesRead();\n     }\n     \n-    private void init(final boolean firstFrame) throws IOException {\n-        if (this.readSignature(firstFrame)) {\n+    private void init(final boolean b) throws IOException {\n+        if (this.readSignature(b)) {\n             this.readFrameDescriptor();\n             this.nextBlock();\n         }\n     }\n     \n-    private boolean readSignature(final boolean firstFrame) throws IOException {\n-        final String garbageMessage = firstFrame ? \"Not a LZ4 frame stream\" : \"LZ4 frame stream followed by garbage\";\n-        final byte[] b = new byte[4];\n-        int read = IOUtils.readFully((InputStream)this.inputStream, b);\n-        this.count(read);\n-        if (0 == read && !firstFrame) {\n+    private boolean readSignature(final boolean b) throws IOException {\n+        final String s = b ? \"Not a LZ4 frame stream\" : \"LZ4 frame stream followed by garbage\";\n+        final byte[] array = new byte[4];\n+        final int fully = IOUtils.readFully((InputStream)this.inputStream, array);\n+        this.count(fully);\n+        if (fully == 0 && !b) {\n             this.endReached = true;\n             return false;\n         }\n-        if (4 != read) {\n-            throw new IOException(garbageMessage);\n+        if (4 != fully) {\n+            throw new IOException(s);\n         }\n-        read = this.skipSkippableFrame(b);\n-        if (0 == read && !firstFrame) {\n+        final int skipSkippableFrame = this.skipSkippableFrame(array);\n+        if (skipSkippableFrame == 0 && !b) {\n             this.endReached = true;\n             return false;\n         }\n-        if (4 != read || !matches(b, 4)) {\n-            throw new IOException(garbageMessage);\n+        if (4 != skipSkippableFrame || !matches(array, 4)) {\n+            throw new IOException(s);\n         }\n         return true;\n     }\n     \n     private void readFrameDescriptor() throws IOException {\n-        final int flags = this.readOneByte();\n-        if (flags == -1) {\n+        final int oneByte = this.readOneByte();\n+        if (oneByte == -1) {\n             throw new IOException(\"Premature end of stream while reading frame flags\");\n         }\n-        this.contentHash.update(flags);\n-        if ((flags & 0xC0) != 0x40) {\n-            throw new IOException(\"Unsupported version \" + (flags >> 6));\n+        this.contentHash.update(oneByte);\n+        if ((oneByte & 0xC0) != 0x40) {\n+            throw new IOException(\"Unsupported version \" + (oneByte >> 6));\n         }\n-        this.expectBlockDependency = ((flags & 0x20) == 0x0);\n+        this.expectBlockDependency = ((oneByte & 0x20) == 0x0);\n         if (this.expectBlockDependency) {\n             if (this.blockDependencyBuffer == null) {\n                 this.blockDependencyBuffer = new byte[65536];\n             }\n         }\n         else {\n             this.blockDependencyBuffer = null;\n         }\n-        this.expectBlockChecksum = ((flags & 0x10) != 0x0);\n-        this.expectContentSize = ((flags & 0x8) != 0x0);\n-        this.expectContentChecksum = ((flags & 0x4) != 0x0);\n-        final int bdByte = this.readOneByte();\n-        if (bdByte == -1) {\n+        this.expectBlockChecksum = ((oneByte & 0x10) != 0x0);\n+        this.expectContentSize = ((oneByte & 0x8) != 0x0);\n+        this.expectContentChecksum = ((oneByte & 0x4) != 0x0);\n+        final int oneByte2 = this.readOneByte();\n+        if (oneByte2 == -1) {\n             throw new IOException(\"Premature end of stream while reading frame BD byte\");\n         }\n-        this.contentHash.update(bdByte);\n+        this.contentHash.update(oneByte2);\n         if (this.expectContentSize) {\n-            final byte[] contentSize = new byte[8];\n-            final int skipped = IOUtils.readFully((InputStream)this.inputStream, contentSize);\n-            this.count(skipped);\n-            if (8 != skipped) {\n+            final byte[] array = new byte[8];\n+            final int fully = IOUtils.readFully((InputStream)this.inputStream, array);\n+            this.count(fully);\n+            if (8 != fully) {\n                 throw new IOException(\"Premature end of stream while reading content size\");\n             }\n-            this.contentHash.update(contentSize, 0, contentSize.length);\n+            this.contentHash.update(array, 0, array.length);\n         }\n-        final int headerHash = this.readOneByte();\n-        if (headerHash == -1) {\n+        final int oneByte3 = this.readOneByte();\n+        if (oneByte3 == -1) {\n             throw new IOException(\"Premature end of stream while reading frame header checksum\");\n         }\n-        final int expectedHash = (int)(this.contentHash.getValue() >> 8 & 0xFFL);\n+        final int n = (int)(this.contentHash.getValue() >> 8 & 0xFFL);\n         this.contentHash.reset();\n-        if (headerHash != expectedHash) {\n+        if (oneByte3 != n) {\n             throw new IOException(\"Frame header checksum mismatch\");\n         }\n     }\n     \n     private void nextBlock() throws IOException {\n         this.maybeFinishCurrentBlock();\n-        final long len = ByteUtils.fromLittleEndian(this.supplier, 4);\n-        final boolean uncompressed = (len & 0xFFFFFFFF80000000L) != 0x0L;\n-        final int realLen = (int)(len & 0x7FFFFFFFL);\n-        if (realLen < 0) {\n+        final long fromLittleEndian = ByteUtils.fromLittleEndian(this.supplier, 4);\n+        final boolean b = (fromLittleEndian & 0xFFFFFFFF80000000L) != 0x0L;\n+        final int n = (int)(fromLittleEndian & 0x7FFFFFFFL);\n+        if (n < 0) {\n             throw new IOException(\"Found illegal block with negative size\");\n         }\n-        if (realLen == 0) {\n+        if (n == 0) {\n             this.verifyContentChecksum();\n             if (!this.decompressConcatenated) {\n                 this.endReached = true;\n             }\n             else {\n                 this.init(false);\n             }\n             return;\n         }\n-        InputStream capped = (InputStream)new BoundedInputStream((InputStream)this.inputStream, (long)realLen);\n+        Object currentBlock = new BoundedInputStream((InputStream)this.inputStream, (long)n);\n         if (this.expectBlockChecksum) {\n-            capped = (InputStream)new ChecksumCalculatingInputStream((Checksum)this.blockHash, capped);\n+            currentBlock = new ChecksumCalculatingInputStream((Checksum)this.blockHash, (InputStream)currentBlock);\n         }\n-        if (uncompressed) {\n+        if (b) {\n             this.inUncompressed = true;\n-            this.currentBlock = capped;\n+            this.currentBlock = (InputStream)currentBlock;\n         }\n         else {\n             this.inUncompressed = false;\n-            final BlockLZ4CompressorInputStream s = new BlockLZ4CompressorInputStream(capped);\n+            final BlockLZ4CompressorInputStream currentBlock2 = new BlockLZ4CompressorInputStream((InputStream)currentBlock);\n             if (this.expectBlockDependency) {\n-                s.prefill(this.blockDependencyBuffer);\n+                currentBlock2.prefill(this.blockDependencyBuffer);\n             }\n-            this.currentBlock = (InputStream)s;\n+            this.currentBlock = (InputStream)currentBlock2;\n         }\n     }\n     \n     private void maybeFinishCurrentBlock() throws IOException {\n         if (this.currentBlock != null) {\n             this.currentBlock.close();\n             this.currentBlock = null;\n@@ -226,100 +226,99 @@\n     private void verifyContentChecksum() throws IOException {\n         if (this.expectContentChecksum) {\n             this.verifyChecksum(this.contentHash, \"content\");\n         }\n         this.contentHash.reset();\n     }\n     \n-    private void verifyChecksum(final XXHash32 hash, final String kind) throws IOException {\n-        final byte[] checksum = new byte[4];\n-        final int read = IOUtils.readFully((InputStream)this.inputStream, checksum);\n-        this.count(read);\n-        if (4 != read) {\n-            throw new IOException(\"Premature end of stream while reading \" + kind + \" checksum\");\n-        }\n-        final long expectedHash = hash.getValue();\n-        if (expectedHash != ByteUtils.fromLittleEndian(checksum)) {\n-            throw new IOException(kind + \" checksum mismatch.\");\n+    private void verifyChecksum(final XXHash32 xxHash32, final String s) throws IOException {\n+        final byte[] array = new byte[4];\n+        final int fully = IOUtils.readFully((InputStream)this.inputStream, array);\n+        this.count(fully);\n+        if (4 != fully) {\n+            throw new IOException(\"Premature end of stream while reading \" + s + \" checksum\");\n+        }\n+        if (xxHash32.getValue() != ByteUtils.fromLittleEndian(array)) {\n+            throw new IOException(s + \" checksum mismatch.\");\n         }\n     }\n     \n     private int readOneByte() throws IOException {\n-        final int b = this.inputStream.read();\n-        if (b != -1) {\n+        final int read = this.inputStream.read();\n+        if (read != -1) {\n             this.count(1);\n-            return b & 0xFF;\n+            return read & 0xFF;\n         }\n         return -1;\n     }\n     \n-    private int readOnce(final byte[] b, final int off, final int len) throws IOException {\n+    private int readOnce(final byte[] array, final int n, final int n2) throws IOException {\n         if (this.inUncompressed) {\n-            final int cnt = this.currentBlock.read(b, off, len);\n-            this.count(cnt);\n-            return cnt;\n-        }\n-        final BlockLZ4CompressorInputStream l = (BlockLZ4CompressorInputStream)this.currentBlock;\n-        final long before = l.getBytesRead();\n-        final int cnt2 = this.currentBlock.read(b, off, len);\n-        this.count(l.getBytesRead() - before);\n-        return cnt2;\n+            final int read = this.currentBlock.read(array, n, n2);\n+            this.count(read);\n+            return read;\n+        }\n+        final BlockLZ4CompressorInputStream blockLZ4CompressorInputStream = (BlockLZ4CompressorInputStream)this.currentBlock;\n+        final long bytesRead = blockLZ4CompressorInputStream.getBytesRead();\n+        final int read2 = this.currentBlock.read(array, n, n2);\n+        this.count(blockLZ4CompressorInputStream.getBytesRead() - bytesRead);\n+        return read2;\n     }\n     \n-    private static boolean isSkippableFrameSignature(final byte[] b) {\n-        if ((b[0] & 0x50) != 0x50) {\n+    private static boolean isSkippableFrameSignature(final byte[] array) {\n+        if ((array[0] & 0x50) != 0x50) {\n             return false;\n         }\n         for (int i = 1; i < 4; ++i) {\n-            if (b[i] != FramedLZ4CompressorInputStream.SKIPPABLE_FRAME_TRAILER[i - 1]) {\n+            if (array[i] != FramedLZ4CompressorInputStream.SKIPPABLE_FRAME_TRAILER[i - 1]) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    private int skipSkippableFrame(final byte[] b) throws IOException {\n-        int read = 4;\n-        while (read == 4 && isSkippableFrameSignature(b)) {\n-            final long len = ByteUtils.fromLittleEndian(this.supplier, 4);\n-            if (len < 0L) {\n+    private int skipSkippableFrame(final byte[] array) throws IOException {\n+        int fully = 4;\n+        while (fully == 4 && isSkippableFrameSignature(array)) {\n+            final long fromLittleEndian = ByteUtils.fromLittleEndian(this.supplier, 4);\n+            if (fromLittleEndian < 0L) {\n                 throw new IOException(\"Found illegal skippable frame with negative size\");\n             }\n-            final long skipped = IOUtils.skip((InputStream)this.inputStream, len);\n-            this.count(skipped);\n-            if (len != skipped) {\n+            final long skip = IOUtils.skip((InputStream)this.inputStream, fromLittleEndian);\n+            this.count(skip);\n+            if (fromLittleEndian != skip) {\n                 throw new IOException(\"Premature end of stream while skipping frame\");\n             }\n-            read = IOUtils.readFully((InputStream)this.inputStream, b);\n-            this.count(read);\n+            fully = IOUtils.readFully((InputStream)this.inputStream, array);\n+            this.count(fully);\n         }\n-        return read;\n+        return fully;\n     }\n     \n-    private void appendToBlockDependencyBuffer(final byte[] b, final int off, int len) {\n-        len = Math.min(len, this.blockDependencyBuffer.length);\n-        if (len > 0) {\n-            final int keep = this.blockDependencyBuffer.length - len;\n-            if (keep > 0) {\n-                System.arraycopy(this.blockDependencyBuffer, len, this.blockDependencyBuffer, 0, keep);\n+    private void appendToBlockDependencyBuffer(final byte[] array, final int n, int min) {\n+        min = Math.min(min, this.blockDependencyBuffer.length);\n+        if (min > 0) {\n+            final int n2 = this.blockDependencyBuffer.length - min;\n+            if (n2 > 0) {\n+                System.arraycopy(this.blockDependencyBuffer, min, this.blockDependencyBuffer, 0, n2);\n             }\n-            System.arraycopy(b, off, this.blockDependencyBuffer, keep, len);\n+            System.arraycopy(array, n, this.blockDependencyBuffer, n2, min);\n         }\n     }\n     \n-    public static boolean matches(final byte[] signature, final int length) {\n-        if (length < FramedLZ4CompressorInputStream.LZ4_SIGNATURE.length) {\n+    public static boolean matches(final byte[] array, final int n) {\n+        if (n < FramedLZ4CompressorInputStream.LZ4_SIGNATURE.length) {\n             return false;\n         }\n-        byte[] shortenedSig = signature;\n-        if (signature.length > FramedLZ4CompressorInputStream.LZ4_SIGNATURE.length) {\n-            shortenedSig = new byte[FramedLZ4CompressorInputStream.LZ4_SIGNATURE.length];\n-            System.arraycopy(signature, 0, shortenedSig, 0, FramedLZ4CompressorInputStream.LZ4_SIGNATURE.length);\n+        byte[] a = array;\n+        if (array.length > FramedLZ4CompressorInputStream.LZ4_SIGNATURE.length) {\n+            a = new byte[FramedLZ4CompressorInputStream.LZ4_SIGNATURE.length];\n+            System.arraycopy(array, 0, a, 0, FramedLZ4CompressorInputStream.LZ4_SIGNATURE.length);\n         }\n-        return Arrays.equals(shortenedSig, FramedLZ4CompressorInputStream.LZ4_SIGNATURE);\n+        return Arrays.equals(a, FramedLZ4CompressorInputStream.LZ4_SIGNATURE);\n     }\n     \n     static {\n         LZ4_SIGNATURE = new byte[] { 4, 34, 77, 24 };\n         SKIPPABLE_FRAME_TRAILER = new byte[] { 42, 77, 24 };\n     }\n }\n"}]}
