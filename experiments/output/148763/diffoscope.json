{"diffoscope-json-version": 1, "source1": "first/Blake3.class", "source2": "second/Blake3.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -20,40 +20,45 @@\n     private static final int ROOT = 8;\n     private static final int KEYED_HASH = 16;\n     private static final int DERIVE_KEY_CONTEXT = 32;\n     private static final int DERIVE_KEY_MATERIAL = 64;\n     private static final byte[][] MSG_SCHEDULE;\n     private final Blake3.EngineState engineState;\n     \n+    static {\n+        IV = new int[] { 1779033703, -1150833019, 1013904242, -1521486534, 1359893119, -1694144372, 528734635, 1541459225 };\n+        MSG_SCHEDULE = new byte[][] { { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }, { 2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8 }, { 3, 4, 10, 12, 13, 2, 7, 14, 6, 5, 9, 0, 11, 15, 8, 1 }, { 10, 7, 12, 9, 14, 3, 13, 15, 4, 0, 11, 2, 5, 8, 1, 6 }, { 12, 13, 9, 11, 15, 10, 14, 8, 7, 2, 5, 3, 0, 1, 6, 4 }, { 9, 14, 11, 5, 8, 12, 15, 1, 13, 3, 0, 10, 2, 6, 4, 7 }, { 11, 15, 5, 0, 1, 9, 8, 6, 14, 10, 2, 12, 3, 4, 7, 13 } };\n+    }\n+    \n     private Blake3(final int[] key, final int flags) {\n-        this.engineState = new Blake3.EngineState(key, flags, (Blake3.Blake3$1)null);\n+        this.engineState = new Blake3.EngineState(key, flags, (Blake3.EngineState)null);\n     }\n     \n     public Blake3 reset() {\n-        Blake3.EngineState.access$100(this.engineState);\n+        Blake3.EngineState.access$1(this.engineState);\n         return this;\n     }\n     \n     public Blake3 update(final byte[] in) {\n         return this.update(in, 0, in.length);\n     }\n     \n     public Blake3 update(final byte[] in, final int offset, final int length) {\n         checkBufferArgs(in, offset, length);\n-        Blake3.EngineState.access$200(this.engineState, in, offset, length);\n+        Blake3.EngineState.access$2(this.engineState, in, offset, length);\n         return this;\n     }\n     \n     public Blake3 doFinalize(final byte[] out) {\n         return this.doFinalize(out, 0, out.length);\n     }\n     \n     public Blake3 doFinalize(final byte[] out, final int offset, final int length) {\n         checkBufferArgs(out, offset, length);\n-        Blake3.EngineState.access$300(this.engineState, out, offset, length);\n+        Blake3.EngineState.access$3(this.engineState, out, offset, length);\n         return this;\n     }\n     \n     public byte[] doFinalize(final int nrBytes) {\n         if (nrBytes < 0) {\n             throw new IllegalArgumentException(\"Requested bytes must be non-negative\");\n         }\n@@ -72,18 +77,18 @@\n             throw new IllegalArgumentException(\"Blake3 keys must be 32 bytes\");\n         }\n         return new Blake3(unpackInts(key, 8), 16);\n     }\n     \n     public static Blake3 initKeyDerivationFunction(final byte[] kdfContext) {\n         Objects.requireNonNull(kdfContext);\n-        final Blake3.EngineState kdf = new Blake3.EngineState(Blake3.IV, 32, (Blake3.Blake3$1)null);\n-        Blake3.EngineState.access$200(kdf, kdfContext, 0, kdfContext.length);\n+        final Blake3.EngineState kdf = new Blake3.EngineState(Blake3.IV, 32, (Blake3.EngineState)null);\n+        Blake3.EngineState.access$2(kdf, kdfContext, 0, kdfContext.length);\n         final byte[] key = new byte[32];\n-        Blake3.EngineState.access$300(kdf, key, 0, key.length);\n+        Blake3.EngineState.access$3(kdf, key, 0, key.length);\n         return new Blake3(unpackInts(key, 8), 64);\n     }\n     \n     public static byte[] hash(final byte[] data) {\n         return initHash().update(data).doFinalize(32);\n     }\n     \n@@ -166,19 +171,14 @@\n         }\n         return state;\n     }\n     \n     private static Blake3.Output parentOutput(final int[] leftChildCV, final int[] rightChildCV, final int[] key, final int flags) {\n         final int[] blockWords = Arrays.copyOf(leftChildCV, 16);\n         System.arraycopy(rightChildCV, 0, blockWords, 8, 8);\n-        return new Blake3.Output((int[])key.clone(), blockWords, 0L, 64, flags | 0x4, (Blake3.Blake3$1)null);\n+        return new Blake3.Output((int[])key.clone(), blockWords, 0L, 64, flags | 0x4, (Blake3.Output)null);\n     }\n     \n     private static int[] parentChainingValue(final int[] leftChildCV, final int[] rightChildCV, final int[] key, final int flags) {\n-        return Blake3.Output.access$500(parentOutput(leftChildCV, rightChildCV, key, flags));\n-    }\n-    \n-    static {\n-        IV = new int[] { 1779033703, -1150833019, 1013904242, -1521486534, 1359893119, -1694144372, 528734635, 1541459225 };\n-        MSG_SCHEDULE = new byte[][] { { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }, { 2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8 }, { 3, 4, 10, 12, 13, 2, 7, 14, 6, 5, 9, 0, 11, 15, 8, 1 }, { 10, 7, 12, 9, 14, 3, 13, 15, 4, 0, 11, 2, 5, 8, 1, 6 }, { 12, 13, 9, 11, 15, 10, 14, 8, 7, 2, 5, 3, 0, 1, 6, 4 }, { 9, 14, 11, 5, 8, 12, 15, 1, 13, 3, 0, 10, 2, 6, 4, 7 }, { 11, 15, 5, 0, 1, 9, 8, 6, 14, 10, 2, 12, 3, 4, 7, 13 } };\n+        return Blake3.Output.access$1(parentOutput(leftChildCV, rightChildCV, key, flags));\n     }\n }\n"}]}
