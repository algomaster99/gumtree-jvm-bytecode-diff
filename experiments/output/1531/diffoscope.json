{"diffoscope-json-version": 1, "source1": "first/ArjArchiveInputStream.class", "source2": "second/ArjArchiveInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -167,19 +167,23 @@\n     }\n     \n     private LocalFileHeader readLocalFileHeader() throws IOException {\n         final byte[] basicHeaderBytes = this.readHeader();\n         if (basicHeaderBytes == null) {\n             return null;\n         }\n-        try (final DataInputStream basicHeader = new DataInputStream(new ByteArrayInputStream(basicHeaderBytes))) {\n+        final DataInputStream basicHeader = new DataInputStream(new ByteArrayInputStream(basicHeaderBytes));\n+        Throwable x0 = null;\n+        try {\n             final int firstHeaderSize = basicHeader.readUnsignedByte();\n             final byte[] firstHeaderBytes = new byte[firstHeaderSize - 1];\n             basicHeader.readFully(firstHeaderBytes);\n-            try (final DataInputStream firstHeader = new DataInputStream(new ByteArrayInputStream(firstHeaderBytes))) {\n+            final DataInputStream firstHeader = new DataInputStream(new ByteArrayInputStream(firstHeaderBytes));\n+            Throwable x2 = null;\n+            try {\n                 final LocalFileHeader localFileHeader = new LocalFileHeader();\n                 localFileHeader.archiverVersionNumber = firstHeader.readUnsignedByte();\n                 localFileHeader.minVersionToExtract = firstHeader.readUnsignedByte();\n                 localFileHeader.hostOS = firstHeader.readUnsignedByte();\n                 localFileHeader.arjFlags = firstHeader.readUnsignedByte();\n                 localFileHeader.method = firstHeader.readUnsignedByte();\n                 localFileHeader.fileType = firstHeader.readUnsignedByte();\n@@ -208,14 +212,28 @@\n                         throw new IOException(\"Extended header CRC32 verification failure\");\n                     }\n                     extendedHeaders.add(extendedHeaderBytes);\n                 }\n                 localFileHeader.extendedHeaders = extendedHeaders.toArray(new byte[extendedHeaders.size()][]);\n                 return localFileHeader;\n             }\n+            catch (final Throwable t) {\n+                x2 = t;\n+                throw t;\n+            }\n+            finally {\n+                $closeResource(x2, firstHeader);\n+            }\n+        }\n+        catch (final Throwable t2) {\n+            x0 = t2;\n+            throw t2;\n+        }\n+        finally {\n+            $closeResource(x0, basicHeader);\n         }\n     }\n     \n     private void readExtraData(final int firstHeaderSize, final DataInputStream firstHeader, final LocalFileHeader localFileHeader) throws IOException {\n         if (firstHeaderSize >= 33) {\n             localFileHeader.extendedFilePosition = this.read32(firstHeader);\n             if (firstHeaderSize >= 45) {\n@@ -268,8 +286,22 @@\n             throw new IllegalStateException(\"No current arj entry\");\n         }\n         if (this.currentLocalFileHeader.method != 0) {\n             throw new IOException(\"Unsupported compression method \" + this.currentLocalFileHeader.method);\n         }\n         return this.currentInputStream.read(b, off, len);\n     }\n+    \n+    private static /* synthetic */ void $closeResource(final Throwable x0, final AutoCloseable x1) {\n+        if (x0 != null) {\n+            try {\n+                x1.close();\n+            }\n+            catch (final Throwable exception) {\n+                x0.addSuppressed(exception);\n+            }\n+        }\n+        else {\n+            x1.close();\n+        }\n+    }\n }\n"}]}
