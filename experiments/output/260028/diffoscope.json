{"diffoscope-json-version": 1, "source1": "first/WriterOutputStream.class", "source2": "second/WriterOutputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -27,32 +27,31 @@\n         return new WriterOutputStream.Builder();\n     }\n     \n     private static void checkIbmJdkWithBrokenUTF16(final Charset charset) {\n         if (!StandardCharsets.UTF_16.name().equals(charset.name())) {\n             return;\n         }\n-        final String TEST_STRING_2 = \"v\\u00e9s\";\n         final byte[] bytes = \"v\\u00e9s\".getBytes(charset);\n-        final CharsetDecoder charsetDecoder2 = charset.newDecoder();\n-        final ByteBuffer bb2 = ByteBuffer.allocate(16);\n-        final CharBuffer cb2 = CharBuffer.allocate(\"v\\u00e9s\".length());\n-        for (int len = bytes.length, i = 0; i < len; ++i) {\n-            bb2.put(bytes[i]);\n-            bb2.flip();\n+        final CharsetDecoder decoder = charset.newDecoder();\n+        final ByteBuffer allocate = ByteBuffer.allocate(16);\n+        final CharBuffer allocate2 = CharBuffer.allocate(\"v\\u00e9s\".length());\n+        for (int length = bytes.length, i = 0; i < length; ++i) {\n+            allocate.put(bytes[i]);\n+            allocate.flip();\n             try {\n-                charsetDecoder2.decode(bb2, cb2, i == len - 1);\n+                decoder.decode(allocate, allocate2, i == length - 1);\n             }\n-            catch (final IllegalArgumentException e) {\n+            catch (final IllegalArgumentException ex) {\n                 throw new UnsupportedOperationException(\"UTF-16 requested when running on an IBM JDK with broken UTF-16 support. Please find a JDK that supports UTF-16 if you intend to use UF-16 with WriterOutputStream\");\n             }\n-            bb2.compact();\n+            allocate.compact();\n         }\n-        cb2.rewind();\n-        if (!\"v\\u00e9s\".equals(cb2.toString())) {\n+        allocate2.rewind();\n+        if (!\"v\\u00e9s\".equals(allocate2.toString())) {\n             throw new UnsupportedOperationException(\"UTF-16 requested when running on an IBM JDK with broken UTF-16 support. Please find a JDK that supports UTF-16 if you intend to use UF-16 with WriterOutputStream\");\n         }\n     }\n     \n     @Deprecated\n     public WriterOutputStream(final Writer writer) {\n         this(writer, Charset.defaultCharset(), 8192, false);\n@@ -60,41 +59,41 @@\n     \n     @Deprecated\n     public WriterOutputStream(final Writer writer, final Charset charset) {\n         this(writer, charset, 8192, false);\n     }\n     \n     @Deprecated\n-    public WriterOutputStream(final Writer writer, final Charset charset, final int bufferSize, final boolean writeImmediately) {\n-        this(writer, Charsets.toCharset(charset).newDecoder().onMalformedInput(CodingErrorAction.REPLACE).onUnmappableCharacter(CodingErrorAction.REPLACE).replaceWith(\"?\"), bufferSize, writeImmediately);\n+    public WriterOutputStream(final Writer writer, final Charset charset, final int n, final boolean b) {\n+        this(writer, Charsets.toCharset(charset).newDecoder().onMalformedInput(CodingErrorAction.REPLACE).onUnmappableCharacter(CodingErrorAction.REPLACE).replaceWith(\"?\"), n, b);\n     }\n     \n     @Deprecated\n-    public WriterOutputStream(final Writer writer, final CharsetDecoder decoder) {\n-        this(writer, decoder, 8192, false);\n+    public WriterOutputStream(final Writer writer, final CharsetDecoder charsetDecoder) {\n+        this(writer, charsetDecoder, 8192, false);\n     }\n     \n     @Deprecated\n-    public WriterOutputStream(final Writer writer, final CharsetDecoder decoder, final int bufferSize, final boolean writeImmediately) {\n+    public WriterOutputStream(final Writer writer, final CharsetDecoder charsetDecoder, final int capacity, final boolean writeImmediately) {\n         this.decoderIn = ByteBuffer.allocate(128);\n-        checkIbmJdkWithBrokenUTF16(CharsetDecoders.toCharsetDecoder(decoder).charset());\n+        checkIbmJdkWithBrokenUTF16(CharsetDecoders.toCharsetDecoder(charsetDecoder).charset());\n         this.writer = writer;\n-        this.decoder = CharsetDecoders.toCharsetDecoder(decoder);\n+        this.decoder = CharsetDecoders.toCharsetDecoder(charsetDecoder);\n         this.writeImmediately = writeImmediately;\n-        this.decoderOut = CharBuffer.allocate(bufferSize);\n+        this.decoderOut = CharBuffer.allocate(capacity);\n     }\n     \n     @Deprecated\n-    public WriterOutputStream(final Writer writer, final String charsetName) {\n-        this(writer, charsetName, 8192, false);\n+    public WriterOutputStream(final Writer writer, final String s) {\n+        this(writer, s, 8192, false);\n     }\n     \n     @Deprecated\n-    public WriterOutputStream(final Writer writer, final String charsetName, final int bufferSize, final boolean writeImmediately) {\n-        this(writer, Charsets.toCharset(charsetName), bufferSize, writeImmediately);\n+    public WriterOutputStream(final Writer writer, final String s, final int n, final boolean b) {\n+        this(writer, Charsets.toCharset(s), n, b);\n     }\n     \n     @Override\n     public void close() throws IOException {\n         this.processInput(true);\n         this.flushOutput();\n         this.writer.close();\n@@ -111,46 +110,46 @@\n             this.writer.write(this.decoderOut.array(), 0, this.decoderOut.position());\n             this.decoderOut.rewind();\n         }\n     }\n     \n     private void processInput(final boolean endOfInput) throws IOException {\n         this.decoderIn.flip();\n-        CoderResult coderResult;\n+        CoderResult decode;\n         while (true) {\n-            coderResult = this.decoder.decode(this.decoderIn, this.decoderOut, endOfInput);\n-            if (!coderResult.isOverflow()) {\n+            decode = this.decoder.decode(this.decoderIn, this.decoderOut, endOfInput);\n+            if (!decode.isOverflow()) {\n                 break;\n             }\n             this.flushOutput();\n         }\n-        if (coderResult.isUnderflow()) {\n+        if (decode.isUnderflow()) {\n             this.decoderIn.compact();\n             return;\n         }\n         throw new IOException(\"Unexpected coder result\");\n     }\n     \n     @Override\n-    public void write(final byte[] b) throws IOException {\n-        this.write(b, 0, b.length);\n+    public void write(final byte[] array) throws IOException {\n+        this.write(array, 0, array.length);\n     }\n     \n     @Override\n-    public void write(final byte[] b, int off, int len) throws IOException {\n-        while (len > 0) {\n-            final int c = Math.min(len, this.decoderIn.remaining());\n-            this.decoderIn.put(b, off, c);\n+    public void write(final byte[] src, int offset, int i) throws IOException {\n+        while (i > 0) {\n+            final int min = Math.min(i, this.decoderIn.remaining());\n+            this.decoderIn.put(src, offset, min);\n             this.processInput(false);\n-            len -= c;\n-            off += c;\n+            i -= min;\n+            offset += min;\n         }\n         if (this.writeImmediately) {\n             this.flushOutput();\n         }\n     }\n     \n     @Override\n-    public void write(final int b) throws IOException {\n-        this.write(new byte[] { (byte)b }, 0, 1);\n+    public void write(final int n) throws IOException {\n+        this.write(new byte[] { (byte)n }, 0, 1);\n     }\n }\n"}]}
