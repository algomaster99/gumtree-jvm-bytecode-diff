{"diffoscope-json-version": 1, "source1": "first/Lexer.class", "source2": "second/Lexer.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -17,22 +17,22 @@\n     private final char commentStart;\n     private final boolean ignoreSurroundingSpaces;\n     private final boolean ignoreEmptyLines;\n     private final ExtendedBufferedReader reader;\n     private String firstEol;\n     private boolean isLastTokenDelimiter;\n     \n-    Lexer(final CSVFormat format, final ExtendedBufferedReader reader) {\n+    Lexer(final CSVFormat csvFormat, final ExtendedBufferedReader reader) {\n         this.reader = reader;\n-        this.delimiter = format.getDelimiterString().toCharArray();\n-        this.escape = this.mapNullToDisabled(format.getEscapeCharacter());\n-        this.quoteChar = this.mapNullToDisabled(format.getQuoteCharacter());\n-        this.commentStart = this.mapNullToDisabled(format.getCommentMarker());\n-        this.ignoreSurroundingSpaces = format.getIgnoreSurroundingSpaces();\n-        this.ignoreEmptyLines = format.getIgnoreEmptyLines();\n+        this.delimiter = csvFormat.getDelimiterString().toCharArray();\n+        this.escape = this.mapNullToDisabled(csvFormat.getEscapeCharacter());\n+        this.quoteChar = this.mapNullToDisabled(csvFormat.getQuoteCharacter());\n+        this.commentStart = this.mapNullToDisabled(csvFormat.getCommentMarker());\n+        this.ignoreSurroundingSpaces = csvFormat.getIgnoreSurroundingSpaces();\n+        this.ignoreEmptyLines = csvFormat.getIgnoreEmptyLines();\n         this.delimiterBuf = new char[this.delimiter.length - 1];\n         this.escapeDelimiterBuf = new char[2 * this.delimiter.length - 1];\n     }\n     \n     @Override\n     public void close() throws IOException {\n         this.reader.close();\n@@ -50,246 +50,242 @@\n         return this.firstEol;\n     }\n     \n     boolean isClosed() {\n         return this.reader.isClosed();\n     }\n     \n-    boolean isCommentStart(final int ch) {\n-        return ch == this.commentStart;\n+    boolean isCommentStart(final int n) {\n+        return n == this.commentStart;\n     }\n     \n-    boolean isDelimiter(final int ch) throws IOException {\n+    boolean isDelimiter(final int n) throws IOException {\n         this.isLastTokenDelimiter = false;\n-        if (ch != this.delimiter[0]) {\n+        if (n != this.delimiter[0]) {\n             return false;\n         }\n         if (this.delimiter.length == 1) {\n             return this.isLastTokenDelimiter = true;\n         }\n         this.reader.lookAhead(this.delimiterBuf);\n         for (int i = 0; i < this.delimiterBuf.length; ++i) {\n             if (this.delimiterBuf[i] != this.delimiter[i + 1]) {\n                 return false;\n             }\n         }\n-        final int count = this.reader.read(this.delimiterBuf, 0, this.delimiterBuf.length);\n-        return this.isLastTokenDelimiter = (count != -1);\n+        return this.isLastTokenDelimiter = (this.reader.read(this.delimiterBuf, 0, this.delimiterBuf.length) != -1);\n     }\n     \n-    boolean isEndOfFile(final int ch) {\n-        return ch == -1;\n+    boolean isEndOfFile(final int n) {\n+        return n == -1;\n     }\n     \n-    boolean isEscape(final int ch) {\n-        return ch == this.escape;\n+    boolean isEscape(final int n) {\n+        return n == this.escape;\n     }\n     \n     boolean isEscapeDelimiter() throws IOException {\n         this.reader.lookAhead(this.escapeDelimiterBuf);\n         if (this.escapeDelimiterBuf[0] != this.delimiter[0]) {\n             return false;\n         }\n         for (int i = 1; i < this.delimiter.length; ++i) {\n             if (this.escapeDelimiterBuf[2 * i] != this.delimiter[i] || this.escapeDelimiterBuf[2 * i - 1] != this.escape) {\n                 return false;\n             }\n         }\n-        final int count = this.reader.read(this.escapeDelimiterBuf, 0, this.escapeDelimiterBuf.length);\n-        return count != -1;\n+        return this.reader.read(this.escapeDelimiterBuf, 0, this.escapeDelimiterBuf.length) != -1;\n     }\n     \n-    private boolean isMetaChar(final int ch) {\n-        return ch == this.escape || ch == this.quoteChar || ch == this.commentStart;\n+    private boolean isMetaChar(final int n) {\n+        return n == this.escape || n == this.quoteChar || n == this.commentStart;\n     }\n     \n-    boolean isQuoteChar(final int ch) {\n-        return ch == this.quoteChar;\n+    boolean isQuoteChar(final int n) {\n+        return n == this.quoteChar;\n     }\n     \n-    boolean isStartOfLine(final int ch) {\n-        return ch == 10 || ch == 13 || ch == -2;\n+    boolean isStartOfLine(final int n) {\n+        return n == 10 || n == 13 || n == -2;\n     }\n     \n     private char mapNullToDisabled(final Character c) {\n         return (c == null) ? '\\ufffe' : ((char)c);\n     }\n     \n     Token nextToken(final Token token) throws IOException {\n         int lastChar = this.reader.getLastChar();\n-        int c = this.reader.read();\n-        boolean eol = this.readEndOfLine(c);\n+        int n = this.reader.read();\n+        boolean b = this.readEndOfLine(n);\n         if (this.ignoreEmptyLines) {\n-            while (eol && this.isStartOfLine(lastChar)) {\n-                lastChar = c;\n-                c = this.reader.read();\n-                eol = this.readEndOfLine(c);\n-                if (this.isEndOfFile(c)) {\n+            while (b && this.isStartOfLine(lastChar)) {\n+                lastChar = n;\n+                n = this.reader.read();\n+                b = this.readEndOfLine(n);\n+                if (this.isEndOfFile(n)) {\n                     token.type = Token.Type.EOF;\n                     return token;\n                 }\n             }\n         }\n-        if (this.isEndOfFile(lastChar) || (!this.isLastTokenDelimiter && this.isEndOfFile(c))) {\n+        if (this.isEndOfFile(lastChar) || (!this.isLastTokenDelimiter && this.isEndOfFile(n))) {\n             token.type = Token.Type.EOF;\n             return token;\n         }\n-        if (!this.isStartOfLine(lastChar) || !this.isCommentStart(c)) {\n+        if (!this.isStartOfLine(lastChar) || !this.isCommentStart(n)) {\n             while (token.type == Token.Type.INVALID) {\n                 if (this.ignoreSurroundingSpaces) {\n-                    while (Character.isWhitespace((char)c) && !this.isDelimiter(c) && !eol) {\n-                        c = this.reader.read();\n-                        eol = this.readEndOfLine(c);\n+                    while (Character.isWhitespace((char)n) && !this.isDelimiter(n) && !b) {\n+                        n = this.reader.read();\n+                        b = this.readEndOfLine(n);\n                     }\n                 }\n-                if (this.isDelimiter(c)) {\n+                if (this.isDelimiter(n)) {\n                     token.type = Token.Type.TOKEN;\n                 }\n-                else if (eol) {\n+                else if (b) {\n                     token.type = Token.Type.EORECORD;\n                 }\n-                else if (this.isQuoteChar(c)) {\n+                else if (this.isQuoteChar(n)) {\n                     this.parseEncapsulatedToken(token);\n                 }\n-                else if (this.isEndOfFile(c)) {\n+                else if (this.isEndOfFile(n)) {\n                     token.type = Token.Type.EOF;\n                     token.isReady = true;\n                 }\n                 else {\n-                    this.parseSimpleToken(token, c);\n+                    this.parseSimpleToken(token, n);\n                 }\n             }\n             return token;\n         }\n         final String line = this.reader.readLine();\n         if (line == null) {\n             token.type = Token.Type.EOF;\n             return token;\n         }\n-        final String comment = line.trim();\n-        token.content.append(comment);\n+        token.content.append(line.trim());\n         token.type = Token.Type.COMMENT;\n         return token;\n     }\n     \n     private Token parseEncapsulatedToken(final Token token) throws IOException {\n         token.isQuoted = true;\n-        final long startLineNumber = this.getCurrentLineNumber();\n+        final long currentLineNumber = this.getCurrentLineNumber();\n         while (true) {\n-            int c = this.reader.read();\n-            if (this.isEscape(c)) {\n+            final int read = this.reader.read();\n+            if (this.isEscape(read)) {\n                 if (this.isEscapeDelimiter()) {\n                     token.content.append(this.delimiter);\n                 }\n                 else {\n-                    final int unescaped = this.readEscape();\n-                    if (unescaped == -1) {\n-                        token.content.append((char)c).append((char)this.reader.getLastChar());\n+                    final int escape = this.readEscape();\n+                    if (escape == -1) {\n+                        token.content.append((char)read).append((char)this.reader.getLastChar());\n                     }\n                     else {\n-                        token.content.append((char)unescaped);\n+                        token.content.append((char)escape);\n                     }\n                 }\n             }\n-            else if (this.isQuoteChar(c)) {\n+            else if (this.isQuoteChar(read)) {\n                 if (!this.isQuoteChar(this.reader.lookAhead())) {\n                     break;\n                 }\n-                c = this.reader.read();\n-                token.content.append((char)c);\n+                token.content.append((char)this.reader.read());\n             }\n             else {\n-                if (this.isEndOfFile(c)) {\n-                    throw new IOException(\"(startline \" + startLineNumber + \") EOF reached before encapsulated token finished\");\n+                if (this.isEndOfFile(read)) {\n+                    throw new IOException(\"(startline \" + currentLineNumber + \") EOF reached before encapsulated token finished\");\n                 }\n-                token.content.append((char)c);\n+                token.content.append((char)read);\n             }\n         }\n-        int c;\n+        int read2;\n         do {\n-            c = this.reader.read();\n-            if (this.isDelimiter(c)) {\n+            read2 = this.reader.read();\n+            if (this.isDelimiter(read2)) {\n                 token.type = Token.Type.TOKEN;\n                 return token;\n             }\n-            if (this.isEndOfFile(c)) {\n+            if (this.isEndOfFile(read2)) {\n                 token.type = Token.Type.EOF;\n                 token.isReady = true;\n                 return token;\n             }\n-            if (this.readEndOfLine(c)) {\n+            if (this.readEndOfLine(read2)) {\n                 token.type = Token.Type.EORECORD;\n                 return token;\n             }\n-        } while (Character.isWhitespace((char)c));\n+        } while (Character.isWhitespace((char)read2));\n         throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid char between encapsulated token and delimiter\");\n     }\n     \n-    private Token parseSimpleToken(final Token token, int ch) throws IOException {\n+    private Token parseSimpleToken(final Token token, int read) throws IOException {\n         while (true) {\n-            while (!this.readEndOfLine(ch)) {\n-                if (this.isEndOfFile(ch)) {\n+            while (!this.readEndOfLine(read)) {\n+                if (this.isEndOfFile(read)) {\n                     token.type = Token.Type.EOF;\n                     token.isReady = true;\n                 }\n                 else {\n-                    if (!this.isDelimiter(ch)) {\n-                        if (this.isEscape(ch)) {\n+                    if (!this.isDelimiter(read)) {\n+                        if (this.isEscape(read)) {\n                             if (this.isEscapeDelimiter()) {\n                                 token.content.append(this.delimiter);\n                             }\n                             else {\n-                                final int unescaped = this.readEscape();\n-                                if (unescaped == -1) {\n-                                    token.content.append((char)ch).append((char)this.reader.getLastChar());\n+                                final int escape = this.readEscape();\n+                                if (escape == -1) {\n+                                    token.content.append((char)read).append((char)this.reader.getLastChar());\n                                 }\n                                 else {\n-                                    token.content.append((char)unescaped);\n+                                    token.content.append((char)escape);\n                                 }\n                             }\n                         }\n                         else {\n-                            token.content.append((char)ch);\n+                            token.content.append((char)read);\n                         }\n-                        ch = this.reader.read();\n+                        read = this.reader.read();\n                         continue;\n                     }\n                     token.type = Token.Type.TOKEN;\n                 }\n                 if (this.ignoreSurroundingSpaces) {\n                     this.trimTrailingSpaces(token.content);\n                 }\n                 return token;\n             }\n             token.type = Token.Type.EORECORD;\n             continue;\n         }\n     }\n     \n-    boolean readEndOfLine(int ch) throws IOException {\n-        if (ch == 13 && this.reader.lookAhead() == 10) {\n-            ch = this.reader.read();\n+    boolean readEndOfLine(int read) throws IOException {\n+        if (read == 13 && this.reader.lookAhead() == 10) {\n+            read = this.reader.read();\n             if (this.firstEol == null) {\n                 this.firstEol = \"\\r\\n\";\n             }\n         }\n         if (this.firstEol == null) {\n-            if (ch == 10) {\n+            if (read == 10) {\n                 this.firstEol = Lexer.LF_STRING;\n             }\n-            else if (ch == 13) {\n+            else if (read == 13) {\n                 this.firstEol = Lexer.CR_STRING;\n             }\n         }\n-        return ch == 10 || ch == 13;\n+        return read == 10 || read == 13;\n     }\n     \n     int readEscape() throws IOException {\n-        final int ch = this.reader.read();\n-        switch (ch) {\n+        final int read = this.reader.read();\n+        switch (read) {\n             case 114: {\n                 return 13;\n             }\n             case 110: {\n                 return 10;\n             }\n             case 116: {\n@@ -302,33 +298,33 @@\n                 return 12;\n             }\n             case 8:\n             case 9:\n             case 10:\n             case 12:\n             case 13: {\n-                return ch;\n+                return read;\n             }\n             case -1: {\n                 throw new IOException(\"EOF whilst processing escape sequence\");\n             }\n             default: {\n-                if (this.isMetaChar(ch)) {\n-                    return ch;\n+                if (this.isMetaChar(read)) {\n+                    return read;\n                 }\n                 return -1;\n             }\n         }\n     }\n     \n-    void trimTrailingSpaces(final StringBuilder buffer) {\n+    void trimTrailingSpaces(final StringBuilder sb) {\n         int length;\n-        for (length = buffer.length(); length > 0 && Character.isWhitespace(buffer.charAt()); --length) {}\n-        if (length != buffer.length()) {\n-            buffer.setLength();\n+        for (length = sb.length(); length > 0 && Character.isWhitespace(sb.charAt()); --length) {}\n+        if (length != sb.length()) {\n+            sb.setLength();\n         }\n     }\n     \n     static {\n         CR_STRING = Character.toString('\\r');\n         LF_STRING = Character.toString('\\n');\n     }\n"}]}
