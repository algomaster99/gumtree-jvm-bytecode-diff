{"diffoscope-json-version": 1, "source1": "first/TarUtils.class", "source2": "second/TarUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,33 +1,38 @@\n \n package org.apache.commons.compress.archivers.tar;\n \n-import org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\n import java.nio.charset.StandardCharsets;\n import java.io.ByteArrayOutputStream;\n import java.util.HashMap;\n import java.util.Map;\n import org.apache.commons.compress.utils.IOUtils;\n import java.io.InputStream;\n import java.util.Collections;\n import java.util.ArrayList;\n import java.util.List;\n import java.nio.ByteBuffer;\n import java.io.IOException;\n import java.io.UncheckedIOException;\n import java.math.BigInteger;\n import java.nio.charset.Charset;\n+import org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\n import org.apache.commons.compress.archivers.zip.ZipEncoding;\n \n public class TarUtils\n {\n     private static final int BYTE_MASK = 255;\n     static final ZipEncoding DEFAULT_ENCODING;\n     static final ZipEncoding FALLBACK_ENCODING;\n     \n+    static {\n+        DEFAULT_ENCODING = ZipEncodingHelper.getZipEncoding((String)null);\n+        FALLBACK_ENCODING = (ZipEncoding)new TarUtils.TarUtils$1();\n+    }\n+    \n     public static long computeCheckSum(final byte[] buf) {\n         long sum = 0L;\n         for (final byte element : buf) {\n             sum += (0xFF & element);\n         }\n         return sum;\n     }\n@@ -144,15 +149,15 @@\n         }\n         else {\n             long val;\n             for (val = value; remaining >= 0 && val != 0L; val >>>= 3, --remaining) {\n                 buffer[offset + remaining] = (byte)(48 + (byte)(val & 0x7L));\n             }\n             if (val != 0L) {\n-                throw new IllegalArgumentException(value + \"=\" + Long.toOctalString(value) + \" will not fit in octal number buffer of length \" + length);\n+                throw new IllegalArgumentException(String.valueOf(value) + \"=\" + Long.toOctalString(value) + \" will not fit in octal number buffer of length \" + length);\n             }\n         }\n         while (remaining >= 0) {\n             buffer[offset + remaining] = 48;\n             --remaining;\n         }\n     }\n@@ -161,22 +166,22 @@\n         final byte[] remainder = new byte[length - 1];\n         System.arraycopy(buffer, offset + 1, remainder, 0, length - 1);\n         BigInteger val = new BigInteger(remainder);\n         if (negative) {\n             val = val.add(BigInteger.valueOf(-1L)).not();\n         }\n         if (val.bitLength() > 63) {\n-            throw new IllegalArgumentException(\"At offset \" + offset + \", \" + length + \" byte binary number exceeds maximum signed long value\");\n+            throw new IllegalArgumentException(\"At offset \" + offset + \", \" + length + \" byte binary number\" + \" exceeds maximum signed long\" + \" value\");\n         }\n         return negative ? (-val.longValue()) : val.longValue();\n     }\n     \n     private static long parseBinaryLong(final byte[] buffer, final int offset, final int length, final boolean negative) {\n         if (length >= 9) {\n-            throw new IllegalArgumentException(\"At offset \" + offset + \", \" + length + \" byte binary number exceeds maximum signed long value\");\n+            throw new IllegalArgumentException(\"At offset \" + offset + \", \" + length + \" byte binary number\" + \" exceeds maximum signed long\" + \" value\");\n         }\n         long val = 0L;\n         for (int i = 1; i < length; ++i) {\n             val = (val << 8) + (buffer[offset + i] & 0xFF);\n         }\n         if (negative) {\n             --val;\n@@ -255,15 +260,22 @@\n         }\n         if (buffer[start] == 0) {\n             return 0L;\n         }\n         while (start < end && buffer[start] == 32) {\n             ++start;\n         }\n-        for (byte trailer = buffer[end - 1]; start < end && (trailer == 0 || trailer == 32); --end, trailer = buffer[end - 1]) {}\n+        byte trailer = buffer[end - 1];\n+        while (start < end) {\n+            if (trailer != 0 && trailer != 32) {\n+                break;\n+            }\n+            --end;\n+            trailer = buffer[end - 1];\n+        }\n         while (start < end) {\n             final byte currentByte = buffer[start];\n             if (currentByte < 48 || currentByte > 55) {\n                 throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));\n             }\n             result = (result << 3) + (currentByte - 48);\n             ++start;\n@@ -326,18 +338,18 @@\n         return parsePaxHeaders(inputStream, sparseHeaders, globalPaxHeaders, -1L);\n     }\n     \n     protected static Map<String, String> parsePaxHeaders(final InputStream inputStream, final List<TarArchiveStructSparse> sparseHeaders, final Map<String, String> globalPaxHeaders, final long headerSize) throws IOException {\n         final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n         Long offset = null;\n         int totalRead = 0;\n-        while (true) {\n+        int ch;\n+        do {\n             int len = 0;\n             int read = 0;\n-            int ch;\n             while ((ch = inputStream.read()) != -1) {\n                 ++read;\n                 ++totalRead;\n                 if (ch == 10) {\n                     break;\n                 }\n                 if (ch == 32) {\n@@ -381,52 +393,51 @@\n                                 catch (final NumberFormatException ex) {\n                                     throw new IOException(\"Failed to read Paxheader.GNU.sparse.offset contains a non-numeric value\");\n                                 }\n                                 if (offset < 0L) {\n                                     throw new IOException(\"Failed to read Paxheader.GNU.sparse.offset contains negative value\");\n                                 }\n                             }\n-                            if (keyword.equals(\"GNU.sparse.numbytes\")) {\n-                                if (offset == null) {\n-                                    throw new IOException(\"Failed to read Paxheader.GNU.sparse.offset is expected before GNU.sparse.numbytes shows up.\");\n-                                }\n-                                long numbytes;\n-                                try {\n-                                    numbytes = Long.parseLong(value);\n-                                }\n-                                catch (final NumberFormatException ex2) {\n-                                    throw new IOException(\"Failed to read Paxheader.GNU.sparse.numbytes contains a non-numeric value.\");\n-                                }\n-                                if (numbytes < 0L) {\n-                                    throw new IOException(\"Failed to read Paxheader.GNU.sparse.numbytes contains negative value\");\n-                                }\n-                                sparseHeaders.add(new TarArchiveStructSparse((long)offset, numbytes));\n-                                offset = null;\n+                            if (!keyword.equals(\"GNU.sparse.numbytes\")) {\n+                                break;\n+                            }\n+                            if (offset == null) {\n+                                throw new IOException(\"Failed to read Paxheader.GNU.sparse.offset is expected before GNU.sparse.numbytes shows up.\");\n+                            }\n+                            long numbytes;\n+                            try {\n+                                numbytes = Long.parseLong(value);\n                             }\n+                            catch (final NumberFormatException ex2) {\n+                                throw new IOException(\"Failed to read Paxheader.GNU.sparse.numbytes contains a non-numeric value.\");\n+                            }\n+                            if (numbytes < 0L) {\n+                                throw new IOException(\"Failed to read Paxheader.GNU.sparse.numbytes contains negative value\");\n+                            }\n+                            sparseHeaders.add(new TarArchiveStructSparse((long)offset, numbytes));\n+                            offset = null;\n                             break;\n                         }\n                         else {\n                             coll.write(ch);\n                         }\n                     }\n                     break;\n                 }\n                 if (ch < 48 || ch > 57) {\n                     throw new IOException(\"Failed to read Paxheader. Encountered a non-number while reading length\");\n                 }\n                 len *= 10;\n                 len += ch - 48;\n             }\n-            if (ch == -1) {\n-                if (offset != null) {\n-                    sparseHeaders.add(new TarArchiveStructSparse((long)offset, 0L));\n-                }\n-                return headers;\n-            }\n+        } while (ch != -1);\n+        if (offset != null) {\n+            sparseHeaders.add(new TarArchiveStructSparse((long)offset, 0L));\n         }\n+        return headers;\n     }\n     \n     public static TarArchiveStructSparse parseSparse(final byte[] buffer, final int offset) {\n         final long sparseOffset = parseOctalOrBinary(buffer, offset, 12);\n         final long sparseNumbytes = parseOctalOrBinary(buffer, offset + 12, 12);\n         return new TarArchiveStructSparse(sparseOffset, sparseNumbytes);\n     }\n@@ -482,13 +493,8 @@\n             signedSum += b;\n         }\n         return storedSum == unsignedSum || storedSum == signedSum;\n     }\n     \n     private TarUtils() {\n     }\n-    \n-    static {\n-        DEFAULT_ENCODING = ZipEncodingHelper.getZipEncoding((String)null);\n-        FALLBACK_ENCODING = (ZipEncoding)new TarUtils.TarUtils$1();\n-    }\n }\n"}]}
