{"diffoscope-json-version": 1, "source1": "first/XpathQueryGenerator.class", "source2": "second/XpathQueryGenerator.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -19,20 +19,20 @@\n     private final DetailAST rootAst;\n     private final int lineNumber;\n     private final int columnNumber;\n     private final int tokenType;\n     private final FileText fileText;\n     private final int tabWidth;\n     \n-    public XpathQueryGenerator(final TreeWalkerAuditEvent event, final int tabWidth) {\n-        this(event.getRootAst(), event.getLine(), event.getColumn(), event.getTokenType(), event.getFileContents().getText(), tabWidth);\n+    public XpathQueryGenerator(final TreeWalkerAuditEvent treeWalkerAuditEvent, final int n) {\n+        this(treeWalkerAuditEvent.getRootAst(), treeWalkerAuditEvent.getLine(), treeWalkerAuditEvent.getColumn(), treeWalkerAuditEvent.getTokenType(), treeWalkerAuditEvent.getFileContents().getText(), n);\n     }\n     \n-    public XpathQueryGenerator(final DetailAST rootAst, final int lineNumber, final int columnNumber, final FileText fileText, final int tabWidth) {\n-        this(rootAst, lineNumber, columnNumber, 0, fileText, tabWidth);\n+    public XpathQueryGenerator(final DetailAST detailAST, final int n, final int n2, final FileText fileText, final int n3) {\n+        this(detailAST, n, n2, 0, fileText, n3);\n     }\n     \n     public XpathQueryGenerator(final DetailAST rootAst, final int lineNumber, final int columnNumber, final int tokenType, final FileText fileText, final int tabWidth) {\n         this.rootAst = rootAst;\n         this.lineNumber = lineNumber;\n         this.columnNumber = columnNumber;\n         this.tokenType = tokenType;\n@@ -40,142 +40,142 @@\n         this.tabWidth = tabWidth;\n     }\n     \n     public List<String> generate() {\n         return this.getMatchingAstElements().stream().map((Function<? super Object, ?>)XpathQueryGenerator::generateXpathQuery).collect((Collector<? super Object, ?, List<String>>)Collectors.toList());\n     }\n     \n-    private static DetailAST findChildWithTextAttribute(final DetailAST root) {\n-        return TokenUtil.findFirstTokenByPredicate(root, (Predicate)XpathUtil::supportsTextAttribute).orElse(null);\n+    private static DetailAST findChildWithTextAttribute(final DetailAST detailAST) {\n+        return TokenUtil.findFirstTokenByPredicate(detailAST, (Predicate)XpathUtil::supportsTextAttribute).orElse(null);\n     }\n     \n-    private static DetailAST findChildWithTextAttributeRecursively(final DetailAST root) {\n-        DetailAST res = findChildWithTextAttribute(root);\n-        for (DetailAST ast = root.getFirstChild(); ast != null && res == null; res = findChildWithTextAttributeRecursively(ast), ast = ast.getNextSibling()) {}\n-        return res;\n-    }\n-    \n-    public static String generateXpathQuery(final DetailAST ast) {\n-        final StringBuilder xpathQueryBuilder = new StringBuilder(getXpathQuery(null, ast));\n-        if (!isXpathQueryForNodeIsAccurateEnough(ast)) {\n-            xpathQueryBuilder.append('[');\n-            final DetailAST child = findChildWithTextAttributeRecursively(ast);\n-            if (child == null) {\n-                xpathQueryBuilder.append(findPositionAmongSiblings(ast));\n+    private static DetailAST findChildWithTextAttributeRecursively(final DetailAST detailAST) {\n+        DetailAST detailAST2 = findChildWithTextAttribute(detailAST);\n+        for (DetailAST detailAST3 = detailAST.getFirstChild(); detailAST3 != null && detailAST2 == null; detailAST2 = findChildWithTextAttributeRecursively(detailAST3), detailAST3 = detailAST3.getNextSibling()) {}\n+        return detailAST2;\n+    }\n+    \n+    public static String generateXpathQuery(final DetailAST detailAST) {\n+        final StringBuilder sb = new StringBuilder(getXpathQuery(null, detailAST));\n+        if (!isXpathQueryForNodeIsAccurateEnough(detailAST)) {\n+            sb.append('[');\n+            final DetailAST childWithTextAttributeRecursively = findChildWithTextAttributeRecursively(detailAST);\n+            if (childWithTextAttributeRecursively == null) {\n+                sb.append(findPositionAmongSiblings(detailAST));\n             }\n             else {\n-                xpathQueryBuilder.append('.').append(getXpathQuery(ast, child));\n+                sb.append('.').append(getXpathQuery(detailAST, childWithTextAttributeRecursively));\n             }\n-            xpathQueryBuilder.append(']');\n+            sb.append(']');\n         }\n-        return xpathQueryBuilder.toString();\n+        return sb.toString();\n     }\n     \n-    private static int findPositionAmongSiblings(final DetailAST ast) {\n-        DetailAST cur = ast;\n-        int pos = 0;\n-        while (cur != null) {\n-            if (cur.getType() == ast.getType()) {\n-                ++pos;\n+    private static int findPositionAmongSiblings(final DetailAST detailAST) {\n+        DetailAST previousSibling = detailAST;\n+        int n = 0;\n+        while (previousSibling != null) {\n+            if (previousSibling.getType() == detailAST.getType()) {\n+                ++n;\n             }\n-            cur = cur.getPreviousSibling();\n+            previousSibling = previousSibling.getPreviousSibling();\n         }\n-        return pos;\n+        return n;\n     }\n     \n-    private static boolean isXpathQueryForNodeIsAccurateEnough(final DetailAST ast) {\n-        return !hasAtLeastOneSiblingWithSameTokenType(ast) || XpathUtil.supportsTextAttribute(ast) || findChildWithTextAttribute(ast) != null;\n+    private static boolean isXpathQueryForNodeIsAccurateEnough(final DetailAST detailAST) {\n+        return !hasAtLeastOneSiblingWithSameTokenType(detailAST) || XpathUtil.supportsTextAttribute(detailAST) || findChildWithTextAttribute(detailAST) != null;\n     }\n     \n     private List<DetailAST> getMatchingAstElements() {\n-        final List<DetailAST> result = new ArrayList<DetailAST>();\n-        DetailAST toVisit;\n-        for (DetailAST curNode = this.rootAst; curNode != null; curNode = toVisit) {\n-            if (this.isMatchingByLineAndColumnAndTokenType(curNode)) {\n-                result.add(curNode);\n-            }\n-            for (toVisit = curNode.getFirstChild(); curNode != null && toVisit == null; toVisit = curNode.getNextSibling(), curNode = curNode.getParent()) {}\n-        }\n-        return result;\n-    }\n-    \n-    private static String getXpathQuery(final DetailAST root, final DetailAST ast) {\n-        final StringBuilder resultBuilder = new StringBuilder(1024);\n-        for (DetailAST cur = ast; cur != root; cur = cur.getParent()) {\n-            final StringBuilder curNodeQueryBuilder = new StringBuilder(256);\n-            curNodeQueryBuilder.append('/').append(TokenUtil.getTokenName(cur.getType()));\n-            if (XpathUtil.supportsTextAttribute(cur)) {\n-                curNodeQueryBuilder.append(\"[@text='\").append(encode(XpathUtil.getTextAttributeValue(cur))).append(\"']\");\n+        final ArrayList list = new ArrayList();\n+        DetailAST detailAST2;\n+        for (DetailAST detailAST = this.rootAst; detailAST != null; detailAST = detailAST2) {\n+            if (this.isMatchingByLineAndColumnAndTokenType(detailAST)) {\n+                list.add(detailAST);\n+            }\n+            for (detailAST2 = detailAST.getFirstChild(); detailAST != null && detailAST2 == null; detailAST2 = detailAST.getNextSibling(), detailAST = detailAST.getParent()) {}\n+        }\n+        return list;\n+    }\n+    \n+    private static String getXpathQuery(final DetailAST detailAST, final DetailAST detailAST2) {\n+        final StringBuilder sb = new StringBuilder(1024);\n+        for (DetailAST parent = detailAST2; parent != detailAST; parent = parent.getParent()) {\n+            final StringBuilder s = new StringBuilder(256);\n+            s.append('/').append(TokenUtil.getTokenName(parent.getType()));\n+            if (XpathUtil.supportsTextAttribute(parent)) {\n+                s.append(\"[@text='\").append(encode(XpathUtil.getTextAttributeValue(parent))).append(\"']\");\n             }\n             else {\n-                final DetailAST child = findChildWithTextAttribute(cur);\n-                if (child != null && child != ast) {\n-                    curNodeQueryBuilder.append(\"[.\").append(getXpathQuery(cur, child)).append(']');\n+                final DetailAST childWithTextAttribute = findChildWithTextAttribute(parent);\n+                if (childWithTextAttribute != null && childWithTextAttribute != detailAST2) {\n+                    s.append(\"[.\").append(getXpathQuery(parent, childWithTextAttribute)).append(']');\n                 }\n             }\n-            resultBuilder.insert(0, curNodeQueryBuilder);\n+            sb.insert(0, s);\n         }\n-        return resultBuilder.toString();\n+        return sb.toString();\n     }\n     \n-    private static boolean hasAtLeastOneSiblingWithSameTokenType(final DetailAST ast) {\n-        boolean result = false;\n-        for (DetailAST prev = ast.getPreviousSibling(); prev != null; prev = prev.getPreviousSibling()) {\n-            if (prev.getType() == ast.getType()) {\n-                result = true;\n+    private static boolean hasAtLeastOneSiblingWithSameTokenType(final DetailAST detailAST) {\n+        boolean b = false;\n+        for (DetailAST detailAST2 = detailAST.getPreviousSibling(); detailAST2 != null; detailAST2 = detailAST2.getPreviousSibling()) {\n+            if (detailAST2.getType() == detailAST.getType()) {\n+                b = true;\n                 break;\n             }\n         }\n-        for (DetailAST next = ast.getNextSibling(); next != null; next = next.getNextSibling()) {\n-            if (next.getType() == ast.getType()) {\n-                result = true;\n+        for (DetailAST detailAST3 = detailAST.getNextSibling(); detailAST3 != null; detailAST3 = detailAST3.getNextSibling()) {\n+            if (detailAST3.getType() == detailAST.getType()) {\n+                b = true;\n                 break;\n             }\n         }\n-        return result;\n+        return b;\n     }\n     \n-    private int expandedTabColumn(final DetailAST ast) {\n-        return 1 + CommonUtil.lengthExpandedTabs(this.fileText.get(this.lineNumber - 1), ast.getColumnNo(), this.tabWidth);\n+    private int expandedTabColumn(final DetailAST detailAST) {\n+        return 1 + CommonUtil.lengthExpandedTabs(this.fileText.get(this.lineNumber - 1), detailAST.getColumnNo(), this.tabWidth);\n     }\n     \n-    private boolean isMatchingByLineAndColumnAndTokenType(final DetailAST ast) {\n-        return ast.getLineNo() == this.lineNumber && this.expandedTabColumn(ast) == this.columnNumber && (this.tokenType == 0 || this.tokenType == ast.getType());\n+    private boolean isMatchingByLineAndColumnAndTokenType(final DetailAST detailAST) {\n+        return detailAST.getLineNo() == this.lineNumber && this.expandedTabColumn(detailAST) == this.columnNumber && (this.tokenType == 0 || this.tokenType == detailAST.getType());\n     }\n     \n-    private static String encode(final String value) {\n+    private static String encode(final String s) {\n         final StringBuilder sb = new StringBuilder(256);\n-        value.codePoints().forEach(chr -> sb.append(encodeCharacter(Character.toChars(chr)[0])));\n+        s.codePoints().forEach(codePoint -> sb2.append(encodeCharacter(Character.toChars(codePoint)[0])));\n         return sb.toString();\n     }\n     \n-    private static String encodeCharacter(final char chr) {\n-        String encode = null;\n-        switch (chr) {\n+    private static String encodeCharacter(final char c) {\n+        String value = null;\n+        switch (c) {\n             case '<': {\n-                encode = \"&lt;\";\n+                value = \"&lt;\";\n                 break;\n             }\n             case '>': {\n-                encode = \"&gt;\";\n+                value = \"&gt;\";\n                 break;\n             }\n             case '\\'': {\n-                encode = \"&apos;&apos;\";\n+                value = \"&apos;&apos;\";\n                 break;\n             }\n             case '\\\"': {\n-                encode = \"&quot;\";\n+                value = \"&quot;\";\n                 break;\n             }\n             case '&': {\n-                encode = \"&amp;\";\n+                value = \"&amp;\";\n                 break;\n             }\n             default: {\n-                encode = String.valueOf(chr);\n+                value = String.valueOf(c);\n                 break;\n             }\n         }\n-        return encode;\n+        return value;\n     }\n }\n"}]}
