{"diffoscope-json-version": 1, "source1": "first/TarArchiveOutputStream.class", "source2": "second/TarArchiveOutputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -10,16 +10,16 @@\n import java.util.Iterator;\n import java.nio.charset.StandardCharsets;\n import java.io.StringWriter;\n import java.util.HashMap;\n import java.util.Map;\n import org.apache.commons.compress.archivers.ArchiveEntry;\n import java.io.IOException;\n-import org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\n import java.io.OutputStream;\n+import org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\n import org.apache.commons.compress.archivers.zip.ZipEncoding;\n import org.apache.commons.compress.utils.CountingOutputStream;\n import org.apache.commons.compress.utils.FixedLengthBlockOutputStream;\n import org.apache.commons.compress.archivers.ArchiveOutputStream;\n \n public class TarArchiveOutputStream extends ArchiveOutputStream\n {\n@@ -46,14 +46,18 @@\n     private final CountingOutputStream countingOut;\n     private final ZipEncoding zipEncoding;\n     final String encoding;\n     private boolean addPaxHeadersForNonAsciiNames;\n     private static final ZipEncoding ASCII;\n     private static final int BLOCK_SIZE_UNSPECIFIED = -511;\n     \n+    static {\n+        ASCII = ZipEncodingHelper.getZipEncoding(\"ASCII\");\n+    }\n+    \n     public TarArchiveOutputStream(final OutputStream os) {\n         this(os, -511);\n     }\n     \n     public TarArchiveOutputStream(final OutputStream os, final String encoding) {\n         this(os, -511, encoding);\n     }\n@@ -138,14 +142,18 @@\n         }\n         finally {\n             if (!this.closed) {\n                 this.out.close();\n                 this.closed = true;\n             }\n         }\n+        if (!this.closed) {\n+            this.out.close();\n+            this.closed = true;\n+        }\n     }\n     \n     @Deprecated\n     public int getRecordSize() {\n         return 512;\n     }\n     \n@@ -246,16 +254,16 @@\n     \n     private byte[] encodeExtendedPaxHeadersContents(final Map<String, String> headers) {\n         final StringWriter w = new StringWriter();\n         for (final Map.Entry<String, String> h : headers.entrySet()) {\n             final String key = (String)h.getKey();\n             final String value = (String)h.getValue();\n             int len = key.length() + value.length() + 3 + 2;\n-            String line = len + \" \" + key + \"=\" + value + \"\\n\";\n-            for (int actualLength = line.getBytes(StandardCharsets.UTF_8).length; len != actualLength; len = actualLength, line = len + \" \" + key + \"=\" + value + \"\\n\", actualLength = line.getBytes(StandardCharsets.UTF_8).length) {}\n+            String line = String.valueOf(len) + \" \" + key + \"=\" + value + \"\\n\";\n+            for (int actualLength = line.getBytes(StandardCharsets.UTF_8).length; len != actualLength; len = actualLength, line = String.valueOf(len) + \" \" + key + \"=\" + value + \"\\n\", actualLength = line.getBytes(StandardCharsets.UTF_8).length) {}\n             w.write(line);\n         }\n         return w.toString().getBytes(StandardCharsets.UTF_8);\n     }\n     \n     private String stripTo7Bits(final String name) {\n         final int length = name.length();\n@@ -348,15 +356,15 @@\n     \n     private void failForBigNumberWithPosixMessage(final String field, final long value, final long maxValue) {\n         this.failForBigNumber(field, value, maxValue, \" Use STAR or POSIX extensions to overcome this limit\");\n     }\n     \n     private void failForBigNumber(final String field, final long value, final long maxValue, final String additionalMsg) {\n         if (value < 0L || value > maxValue) {\n-            throw new IllegalArgumentException(field + \" '\" + value + \"' is too big ( > \" + maxValue + \" ).\" + additionalMsg);\n+            throw new IllegalArgumentException(String.valueOf(field) + \" '\" + value + \"' is too big ( > \" + maxValue + \" ).\" + additionalMsg);\n         }\n     }\n     \n     private boolean handleLongName(final TarArchiveEntry entry, final String name, final Map<String, String> paxHeaders, final String paxHeaderName, final byte linkType, final String fieldName) throws IOException {\n         final ByteBuffer encodedName = this.zipEncoding.encode(name);\n         final int len = encodedName.limit() - encodedName.position();\n         if (len >= 100) {\n@@ -370,26 +378,22 @@\n                 this.transferModTime(entry, longLinkEntry);\n                 this.putArchiveEntry((ArchiveEntry)longLinkEntry);\n                 this.write(encodedName.array(), encodedName.arrayOffset(), len);\n                 this.write(0);\n                 this.closeArchiveEntry();\n             }\n             else if (this.longFileMode != 1) {\n-                throw new IllegalArgumentException(fieldName + \" '\" + name + \"' is too long ( > \" + 100 + \" bytes)\");\n+                throw new IllegalArgumentException(String.valueOf(fieldName) + \" '\" + name + \"' is too long ( > \" + 100 + \" bytes)\");\n             }\n         }\n         return false;\n     }\n     \n     private void transferModTime(final TarArchiveEntry from, final TarArchiveEntry to) {\n         Date fromModTime = from.getModTime();\n         final long fromModTimeSeconds = fromModTime.getTime() / 1000L;\n         if (fromModTimeSeconds < 0L || fromModTimeSeconds > 8589934591L) {\n             fromModTime = new Date(0L);\n         }\n         to.setModTime(fromModTime);\n     }\n-    \n-    static {\n-        ASCII = ZipEncodingHelper.getZipEncoding(\"ASCII\");\n-    }\n }\n"}]}
