{"diffoscope-json-version": 1, "source1": "first/PkgImportControl.class", "source2": "second/PkgImportControl.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -14,119 +14,118 @@\n     private static final String DOT_ESCAPED_REGEX = \"\\\\\\\\.\";\n     private final List<AbstractImportControl> children;\n     private final String fullPackageName;\n     private final Pattern patternForPartialMatch;\n     private final Pattern patternForExactMatch;\n     private final boolean regex;\n     \n-    PkgImportControl(final String packageName, final boolean regex, final MismatchStrategy strategyOnMismatch) {\n-        super((AbstractImportControl)null, strategyOnMismatch);\n+    PkgImportControl(final String fullPackageName, final boolean regex, final MismatchStrategy mismatchStrategy) {\n+        super((AbstractImportControl)null, mismatchStrategy);\n         this.children = new ArrayList<AbstractImportControl>();\n         this.regex = regex;\n         if (regex) {\n-            this.fullPackageName = encloseInGroup(packageName);\n+            this.fullPackageName = encloseInGroup(fullPackageName);\n             this.patternForPartialMatch = createPatternForPartialMatch(this.fullPackageName);\n             this.patternForExactMatch = createPatternForExactMatch(this.fullPackageName);\n         }\n         else {\n-            this.fullPackageName = packageName;\n+            this.fullPackageName = fullPackageName;\n             this.patternForPartialMatch = null;\n             this.patternForExactMatch = null;\n         }\n     }\n     \n-    PkgImportControl(final PkgImportControl parent, final String subPackageName, final boolean regex, final MismatchStrategy strategyOnMismatch) {\n-        super((AbstractImportControl)parent, strategyOnMismatch);\n+    PkgImportControl(final PkgImportControl pkgImportControl, final String s, final boolean b, final MismatchStrategy mismatchStrategy) {\n+        super((AbstractImportControl)pkgImportControl, mismatchStrategy);\n         this.children = new ArrayList<AbstractImportControl>();\n-        if (regex || parent.regex) {\n-            final String parentRegex = ensureSelfContainedRegex(parent.fullPackageName, parent.regex);\n-            final String thisRegex = ensureSelfContainedRegex(subPackageName, regex);\n-            this.fullPackageName = parentRegex + \"\\\\.\" + thisRegex;\n+        if (b || pkgImportControl.regex) {\n+            this.fullPackageName = ensureSelfContainedRegex(pkgImportControl.fullPackageName, pkgImportControl.regex) + \"\\\\.\" + ensureSelfContainedRegex(s, b);\n             this.patternForPartialMatch = createPatternForPartialMatch(this.fullPackageName);\n             this.patternForExactMatch = createPatternForExactMatch(this.fullPackageName);\n             this.regex = true;\n         }\n         else {\n-            this.fullPackageName = parent.fullPackageName + \".\" + subPackageName;\n+            this.fullPackageName = pkgImportControl.fullPackageName + \".\" + s;\n             this.patternForPartialMatch = null;\n             this.patternForExactMatch = null;\n             this.regex = false;\n         }\n     }\n     \n-    private static String ensureSelfContainedRegex(final String input, final boolean alreadyRegex) {\n-        String result;\n-        if (alreadyRegex) {\n-            result = encloseInGroup(input);\n+    private static String ensureSelfContainedRegex(final String s, final boolean b) {\n+        String s2;\n+        if (b) {\n+            s2 = encloseInGroup(s);\n         }\n         else {\n-            result = toRegex(input);\n+            s2 = toRegex(s);\n         }\n-        return result;\n+        return s2;\n     }\n     \n-    private static String encloseInGroup(final String expression) {\n-        return \"(?:\" + expression;\n+    private static String encloseInGroup(final String s) {\n+        return \"(?:\" + s;\n     }\n     \n     private static String toRegex(final String input) {\n         return PkgImportControl.DOT_REGEX_PATTERN.matcher(input).replaceAll(\"\\\\\\\\.\");\n     }\n     \n-    private static Pattern createPatternForPartialMatch(final String expression) {\n-        return Pattern.compile(expression + \"(?:\\\\..*)?\");\n+    private static Pattern createPatternForPartialMatch(final String s) {\n+        return Pattern.compile(s + \"(?:\\\\..*)?\");\n     }\n     \n-    private static Pattern createPatternForExactMatch(final String expression) {\n-        return Pattern.compile(expression);\n+    private static Pattern createPatternForExactMatch(final String regex) {\n+        return Pattern.compile(regex);\n     }\n     \n-    public AbstractImportControl locateFinest(final String forPkg, final String forFileName) {\n-        AbstractImportControl finestMatch = null;\n-        if (this.matchesAtFront(forPkg)) {\n-            finestMatch = this;\n-            for (final AbstractImportControl child : this.children) {\n-                final AbstractImportControl match = child.locateFinest(forPkg, forFileName);\n-                if (match != null) {\n-                    finestMatch = match;\n+    public AbstractImportControl locateFinest(final String s, final String s2) {\n+        AbstractImportControl abstractImportControl = null;\n+        if (this.matchesAtFront(s)) {\n+            abstractImportControl = this;\n+            final Iterator<AbstractImportControl> iterator = this.children.iterator();\n+            while (iterator.hasNext()) {\n+                final AbstractImportControl locateFinest = ((AbstractImportControl)iterator.next()).locateFinest(s, s2);\n+                if (locateFinest != null) {\n+                    abstractImportControl = locateFinest;\n                     break;\n                 }\n             }\n         }\n-        return finestMatch;\n+        return abstractImportControl;\n     }\n     \n-    public void addChild(final AbstractImportControl importControl) {\n-        this.children.add(importControl);\n+    public void addChild(final AbstractImportControl abstractImportControl) {\n+        this.children.add(abstractImportControl);\n     }\n     \n-    private boolean matchesAtFront(final String pkg) {\n-        boolean result;\n+    private boolean matchesAtFront(final String input) {\n+        boolean b;\n         if (this.regex) {\n-            result = this.patternForPartialMatch.matcher(pkg).matches();\n+            b = this.patternForPartialMatch.matcher(input).matches();\n         }\n         else {\n-            result = this.matchesAtFrontNoRegex(pkg);\n+            b = this.matchesAtFrontNoRegex(input);\n         }\n-        return result;\n+        return b;\n     }\n     \n-    private boolean matchesAtFrontNoRegex(final String pkg) {\n+    private boolean matchesAtFrontNoRegex(final String s) {\n         final int length = this.fullPackageName.length();\n-        return pkg.startsWith(this.fullPackageName) && (pkg.length() == length || pkg.charAt(length) == '.');\n+        return s.startsWith(this.fullPackageName) && (s.length() == length || s.charAt(length) == '.');\n     }\n     \n-    protected boolean matchesExactly(final String pkg, final String fileName) {\n-        boolean result;\n+    protected boolean matchesExactly(final String s, final String s2) {\n+        boolean b;\n         if (this.regex) {\n-            result = this.patternForExactMatch.matcher(pkg).matches();\n+            b = this.patternForExactMatch.matcher(s).matches();\n         }\n         else {\n-            result = this.fullPackageName.equals(pkg);\n+            b = this.fullPackageName.equals(s);\n         }\n-        return result;\n+        return b;\n     }\n     \n     static {\n         DOT_REGEX_PATTERN = Pattern.compile(\"\\\\.\");\n     }\n }\n"}]}
