{"diffoscope-json-version": 1, "source1": "first/Memoizer.class", "source2": "second/Memoizer.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,11 +1,10 @@\n \n package org.apache.commons.lang3.concurrent;\n \n-import java.util.concurrent.Callable;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.CancellationException;\n import java.util.concurrent.FutureTask;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.Future;\n import java.util.concurrent.ConcurrentMap;\n \n@@ -21,44 +20,43 @@\n     \n     public Memoizer(final Computable<I, O> computable, final boolean recalculate) {\n         this.cache = new ConcurrentHashMap<I, Future<O>>();\n         this.computable = computable;\n         this.recalculate = recalculate;\n     }\n     \n-    public O compute(final I arg) throws InterruptedException {\n+    public O compute(final I n) throws InterruptedException {\n         while (true) {\n-            Future<O> future = (Future<O>)this.cache.get(arg);\n+            Future<?> future = (Future<?>)this.cache.get(n);\n             if (future == null) {\n-                final Callable<O> eval = (Callable<O>)(() -> this.computable.compute(arg));\n-                final FutureTask<O> futureTask = new FutureTask<O>(eval);\n-                future = this.cache.putIfAbsent(arg, futureTask);\n+                final FutureTask<O> futureTask = new FutureTask<O>(() -> this.computable.compute(o));\n+                future = this.cache.putIfAbsent(n, futureTask);\n                 if (future == null) {\n                     future = futureTask;\n                     futureTask.run();\n                 }\n             }\n             try {\n-                return future.get();\n+                return (O)future.get();\n             }\n-            catch (final CancellationException e) {\n-                this.cache.remove(arg, future);\n+            catch (final CancellationException ex) {\n+                this.cache.remove(n, future);\n             }\n-            catch (final ExecutionException e2) {\n+            catch (final ExecutionException ex2) {\n                 if (this.recalculate) {\n-                    this.cache.remove(arg, future);\n+                    this.cache.remove(n, future);\n                 }\n-                throw this.launderException(e2.getCause());\n+                throw this.launderException(ex2.getCause());\n             }\n         }\n     }\n     \n-    private RuntimeException launderException(final Throwable throwable) {\n-        if (throwable instanceof RuntimeException) {\n-            return (RuntimeException)throwable;\n+    private RuntimeException launderException(final Throwable cause) {\n+        if (cause instanceof RuntimeException) {\n+            return (RuntimeException)cause;\n         }\n-        if (throwable instanceof Error) {\n-            throw (Error)throwable;\n+        if (cause instanceof Error) {\n+            throw (Error)cause;\n         }\n-        throw new IllegalStateException(\"Unchecked exception\", throwable);\n+        throw new IllegalStateException(\"Unchecked exception\", cause);\n     }\n }\n"}]}
