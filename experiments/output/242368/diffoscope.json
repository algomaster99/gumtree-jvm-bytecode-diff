{"diffoscope-json-version": 1, "source1": "first/Pass3aVerifier$InstOperandConstraintVisitor.class", "source2": "second/Pass3aVerifier$InstOperandConstraintVisitor.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -17,19 +17,18 @@\n import org.apache.bcel.classfile.ConstantString;\n import org.apache.bcel.classfile.ConstantFloat;\n import org.apache.bcel.classfile.ConstantInteger;\n import org.apache.bcel.generic.LDC;\n import org.apache.bcel.generic.ISTORE;\n import org.apache.bcel.generic.INVOKEINTERFACE;\n import org.apache.bcel.verifier.VerificationResult;\n-import org.apache.bcel.verifier.Verifier;\n import org.apache.bcel.verifier.VerifierFactory;\n import org.apache.bcel.classfile.ConstantInterfaceMethodref;\n-import org.apache.bcel.classfile.ConstantUtf8;\n import org.apache.bcel.classfile.ConstantNameAndType;\n+import org.apache.bcel.classfile.ConstantUtf8;\n import org.apache.bcel.classfile.ConstantMethodref;\n import org.apache.bcel.generic.INVOKESTATIC;\n import org.apache.bcel.generic.INVOKESPECIAL;\n import org.apache.bcel.generic.INVOKEVIRTUAL;\n import org.apache.bcel.generic.INVOKEDYNAMIC;\n import org.apache.bcel.generic.INSTANCEOF;\n import org.apache.bcel.generic.ILOAD;\n@@ -67,628 +66,602 @@\n     private final ConstantPoolGen constantPoolGen;\n     \n     InstOperandConstraintVisitor(final Pass3aVerifier this$0, final ConstantPoolGen constantPoolGen) {\n         this.this$0 = this$0;\n         this.constantPoolGen = constantPoolGen;\n     }\n     \n-    private void constraintViolated(final Instruction i, final String message) {\n-        throw new StaticCodeInstructionOperandConstraintException(\"Instruction \" + this.this$0.tostring((Object)i) + \" constraint violated: \" + message);\n+    private void constraintViolated(final Instruction instruction, final String str) {\n+        throw new StaticCodeInstructionOperandConstraintException(\"Instruction \" + this.this$0.tostring((Object)instruction) + \" constraint violated: \" + str);\n     }\n     \n-    private Method getMethod(final JavaClass jc, final InvokeInstruction invoke) {\n-        final Method[] methods;\n-        final Method[] ms = methods = jc.getMethods();\n-        for (final Method element : methods) {\n-            if (element.getName().equals(invoke.getMethodName(this.constantPoolGen)) && Type.getReturnType(element.getSignature()).equals((Object)invoke.getReturnType(this.constantPoolGen)) && this.objarrayequals(Type.getArgumentTypes(element.getSignature()), invoke.getArgumentTypes(this.constantPoolGen))) {\n-                return element;\n+    private Method getMethod(final JavaClass javaClass, final InvokeInstruction invokeInstruction) {\n+        for (final Method method : javaClass.getMethods()) {\n+            if (method.getName().equals(invokeInstruction.getMethodName(this.constantPoolGen)) && Type.getReturnType(method.getSignature()).equals((Object)invokeInstruction.getReturnType(this.constantPoolGen)) && this.objarrayequals(Type.getArgumentTypes(method.getSignature()), invokeInstruction.getArgumentTypes(this.constantPoolGen))) {\n+                return method;\n             }\n         }\n         return null;\n     }\n     \n-    private Method getMethodRecursive(final JavaClass jc, final InvokeInstruction invoke) throws ClassNotFoundException {\n-        Method m = this.getMethod(jc, invoke);\n-        if (m != null) {\n-            return m;\n-        }\n-        for (final JavaClass superclass : jc.getSuperClasses()) {\n-            m = this.getMethod(superclass, invoke);\n-            if (m != null) {\n-                return m;\n-            }\n-        }\n-        for (final JavaClass superclass : jc.getInterfaces()) {\n-            m = this.getMethod(superclass, invoke);\n-            if (m != null) {\n-                return m;\n+    private Method getMethodRecursive(final JavaClass javaClass, final InvokeInstruction invokeInstruction) throws ClassNotFoundException {\n+        final Method method = this.getMethod(javaClass, invokeInstruction);\n+        if (method != null) {\n+            return method;\n+        }\n+        final JavaClass[] superClasses = javaClass.getSuperClasses();\n+        for (int length = superClasses.length, i = 0; i < length; ++i) {\n+            final Method method2 = this.getMethod(superClasses[i], invokeInstruction);\n+            if (method2 != null) {\n+                return method2;\n+            }\n+        }\n+        final JavaClass[] interfaces = javaClass.getInterfaces();\n+        for (int length2 = interfaces.length, j = 0; j < length2; ++j) {\n+            final Method method3 = this.getMethod(interfaces[j], invokeInstruction);\n+            if (method3 != null) {\n+                return method3;\n             }\n         }\n         return null;\n     }\n     \n-    private ObjectType getObjectType(final FieldInstruction o) {\n-        final ReferenceType rt = o.getReferenceType(this.constantPoolGen);\n-        if (rt instanceof ObjectType) {\n-            return (ObjectType)rt;\n+    private ObjectType getObjectType(final FieldInstruction fieldInstruction) {\n+        final ReferenceType referenceType = fieldInstruction.getReferenceType(this.constantPoolGen);\n+        if (referenceType instanceof ObjectType) {\n+            return (ObjectType)referenceType;\n         }\n-        this.constraintViolated((Instruction)o, \"expecting ObjectType but got \" + rt);\n+        this.constraintViolated((Instruction)fieldInstruction, \"expecting ObjectType but got \" + referenceType);\n         return null;\n     }\n     \n-    private void indexValid(final Instruction i, final int idx) {\n-        if (idx < 0 || idx >= this.constantPoolGen.getSize()) {\n-            this.constraintViolated(i, \"Illegal constant pool index '\" + idx + \"'.\");\n+    private void indexValid(final Instruction instruction, final int i) {\n+        if (i < 0 || i >= this.constantPoolGen.getSize()) {\n+            this.constraintViolated(instruction, \"Illegal constant pool index '\" + i + \"'.\");\n         }\n     }\n     \n     private int max_locals() {\n         try {\n             return Repository.lookupClass(Pass3aVerifier.access$000(this.this$0).getClassName()).getMethods()[Pass3aVerifier.access$100(this.this$0)].getCode().getMaxLocals();\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj, (Throwable)obj);\n         }\n     }\n     \n-    private boolean objarrayequals(final Object[] o, final Object[] p) {\n-        if (o.length != p.length) {\n+    private boolean objarrayequals(final Object[] array, final Object[] array2) {\n+        if (array.length != array2.length) {\n             return false;\n         }\n-        for (int i = 0; i < o.length; ++i) {\n-            if (!o[i].equals(p[i])) {\n+        for (int i = 0; i < array.length; ++i) {\n+            if (!array[i].equals(array2[i])) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    public void visitALOAD(final ALOAD o) {\n-        final int idx = o.getIndex();\n-        if (idx < 0) {\n-            this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must be non-negative.\");\n+    public void visitALOAD(final ALOAD aload) {\n+        final int index = aload.getIndex();\n+        if (index < 0) {\n+            this.constraintViolated((Instruction)aload, \"Index '\" + index + \"' must be non-negative.\");\n         }\n         else {\n-            final int maxminus1 = this.max_locals() - 1;\n-            if (idx > maxminus1) {\n-                this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must not be greater than max_locals-1 '\" + maxminus1 + \"'.\");\n+            final int i = this.max_locals() - 1;\n+            if (index > i) {\n+                this.constraintViolated((Instruction)aload, \"Index '\" + index + \"' must not be greater than max_locals-1 '\" + i + \"'.\");\n             }\n         }\n     }\n     \n-    public void visitANEWARRAY(final ANEWARRAY o) {\n-        this.indexValid((Instruction)o, o.getIndex());\n-        final Constant c = this.constantPoolGen.getConstant(o.getIndex());\n-        if (!(c instanceof ConstantClass)) {\n-            this.constraintViolated((Instruction)o, \"Expecting a CONSTANT_Class operand, but found a '\" + this.this$0.tostring((Object)c) + \"'.\");\n+    public void visitANEWARRAY(final ANEWARRAY anewarray) {\n+        this.indexValid((Instruction)anewarray, anewarray.getIndex());\n+        final Constant constant = this.constantPoolGen.getConstant(anewarray.getIndex());\n+        if (!(constant instanceof ConstantClass)) {\n+            this.constraintViolated((Instruction)anewarray, \"Expecting a CONSTANT_Class operand, but found a '\" + this.this$0.tostring((Object)constant) + \"'.\");\n         }\n-        final Type t = o.getType(this.constantPoolGen);\n-        if (t instanceof ArrayType) {\n-            final int dimensions = ((ArrayType)t).getDimensions();\n+        final Type type = anewarray.getType(this.constantPoolGen);\n+        if (type instanceof ArrayType) {\n+            final int dimensions = ((ArrayType)type).getDimensions();\n             if (dimensions > 255) {\n-                this.constraintViolated((Instruction)o, \"Not allowed to create an array with more than 255 dimensions; actual: \" + dimensions);\n+                this.constraintViolated((Instruction)anewarray, \"Not allowed to create an array with more than 255 dimensions; actual: \" + dimensions);\n             }\n         }\n     }\n     \n-    public void visitASTORE(final ASTORE o) {\n-        final int idx = o.getIndex();\n-        if (idx < 0) {\n-            this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must be non-negative.\");\n+    public void visitASTORE(final ASTORE astore) {\n+        final int index = astore.getIndex();\n+        if (index < 0) {\n+            this.constraintViolated((Instruction)astore, \"Index '\" + index + \"' must be non-negative.\");\n         }\n         else {\n-            final int maxminus1 = this.max_locals() - 1;\n-            if (idx > maxminus1) {\n-                this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must not be greater than max_locals-1 '\" + maxminus1 + \"'.\");\n+            final int i = this.max_locals() - 1;\n+            if (index > i) {\n+                this.constraintViolated((Instruction)astore, \"Index '\" + index + \"' must not be greater than max_locals-1 '\" + i + \"'.\");\n             }\n         }\n     }\n     \n-    public void visitCHECKCAST(final CHECKCAST o) {\n-        this.indexValid((Instruction)o, o.getIndex());\n-        final Constant c = this.constantPoolGen.getConstant(o.getIndex());\n-        if (!(c instanceof ConstantClass)) {\n-            this.constraintViolated((Instruction)o, \"Expecting a CONSTANT_Class operand, but found a '\" + this.this$0.tostring((Object)c) + \"'.\");\n+    public void visitCHECKCAST(final CHECKCAST checkcast) {\n+        this.indexValid((Instruction)checkcast, checkcast.getIndex());\n+        final Constant constant = this.constantPoolGen.getConstant(checkcast.getIndex());\n+        if (!(constant instanceof ConstantClass)) {\n+            this.constraintViolated((Instruction)checkcast, \"Expecting a CONSTANT_Class operand, but found a '\" + this.this$0.tostring((Object)constant) + \"'.\");\n         }\n     }\n     \n-    public void visitDLOAD(final DLOAD o) {\n-        final int idx = o.getIndex();\n-        if (idx < 0) {\n-            this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must be non-negative. [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]\");\n+    public void visitDLOAD(final DLOAD dload) {\n+        final int index = dload.getIndex();\n+        if (index < 0) {\n+            this.constraintViolated((Instruction)dload, \"Index '\" + index + \"' must be non-negative. [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]\");\n         }\n         else {\n-            final int maxminus2 = this.max_locals() - 2;\n-            if (idx > maxminus2) {\n-                this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must not be greater than max_locals-2 '\" + maxminus2 + \"'.\");\n+            final int i = this.max_locals() - 2;\n+            if (index > i) {\n+                this.constraintViolated((Instruction)dload, \"Index '\" + index + \"' must not be greater than max_locals-2 '\" + i + \"'.\");\n             }\n         }\n     }\n     \n-    public void visitDSTORE(final DSTORE o) {\n-        final int idx = o.getIndex();\n-        if (idx < 0) {\n-            this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must be non-negative. [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]\");\n+    public void visitDSTORE(final DSTORE dstore) {\n+        final int index = dstore.getIndex();\n+        if (index < 0) {\n+            this.constraintViolated((Instruction)dstore, \"Index '\" + index + \"' must be non-negative. [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]\");\n         }\n         else {\n-            final int maxminus2 = this.max_locals() - 2;\n-            if (idx > maxminus2) {\n-                this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must not be greater than max_locals-2 '\" + maxminus2 + \"'.\");\n+            final int i = this.max_locals() - 2;\n+            if (index > i) {\n+                this.constraintViolated((Instruction)dstore, \"Index '\" + index + \"' must not be greater than max_locals-2 '\" + i + \"'.\");\n             }\n         }\n     }\n     \n-    public void visitFieldInstruction(final FieldInstruction o) {\n+    public void visitFieldInstruction(final FieldInstruction fieldInstruction) {\n         try {\n-            this.indexValid((Instruction)o, o.getIndex());\n-            final Constant c = this.constantPoolGen.getConstant(o.getIndex());\n-            if (!(c instanceof ConstantFieldref)) {\n-                this.constraintViolated((Instruction)o, \"Indexing a constant that's not a CONSTANT_Fieldref but a '\" + this.this$0.tostring((Object)c) + \"'.\");\n-            }\n-            final String field_name = o.getFieldName(this.constantPoolGen);\n-            final JavaClass jc = Repository.lookupClass(this.getObjectType(o).getClassName());\n-            Field[] fields = jc.getFields();\n-            Field f = null;\n-            for (final Field field : fields) {\n-                if (field.getName().equals(field_name)) {\n-                    final Type fType = Type.getType(field.getSignature());\n-                    final Type oType = o.getType(this.constantPoolGen);\n-                    if (fType.equals((Object)oType)) {\n-                        f = field;\n-                        break;\n-                    }\n+            this.indexValid((Instruction)fieldInstruction, fieldInstruction.getIndex());\n+            final Constant constant = this.constantPoolGen.getConstant(fieldInstruction.getIndex());\n+            if (!(constant instanceof ConstantFieldref)) {\n+                this.constraintViolated((Instruction)fieldInstruction, \"Indexing a constant that's not a CONSTANT_Fieldref but a '\" + this.this$0.tostring((Object)constant) + \"'.\");\n+            }\n+            final String fieldName = fieldInstruction.getFieldName(this.constantPoolGen);\n+            final JavaClass lookupClass = Repository.lookupClass(this.getObjectType(fieldInstruction).getClassName());\n+            final Field[] fields = lookupClass.getFields();\n+            Field field = null;\n+            for (final Field field2 : fields) {\n+                if (field2.getName().equals(fieldName) && Type.getType(field2.getSignature()).equals((Object)fieldInstruction.getType(this.constantPoolGen))) {\n+                    field = field2;\n+                    break;\n                 }\n             }\n-            if (f == null) {\n-                final JavaClass[] superClasses;\n-                final JavaClass[] superclasses = superClasses = jc.getSuperClasses();\n+            if (field == null) {\n+                final JavaClass[] superClasses = lookupClass.getSuperClasses();\n             Label_0322:\n-                for (final JavaClass superclass : superClasses) {\n-                    final Field[] fields2;\n-                    fields = (fields2 = superclass.getFields());\n-                    for (final Field field2 : fields2) {\n-                        if (field2.getName().equals(field_name)) {\n-                            final Type fType2 = Type.getType(field2.getSignature());\n-                            final Type oType2 = o.getType(this.constantPoolGen);\n-                            if (fType2.equals((Object)oType2)) {\n-                                f = field2;\n-                                if ((f.getAccessFlags() & 0x5) == 0x0) {\n-                                    f = null;\n-                                    break Label_0322;\n-                                }\n+                for (int length2 = superClasses.length, j = 0; j < length2; ++j) {\n+                    final Field[] fields2 = superClasses[j].getFields();\n+                    final int length3 = fields2.length;\n+                    int k = 0;\n+                    while (k < length3) {\n+                        final Field field3 = fields2[k];\n+                        if (field3.getName().equals(fieldName) && Type.getType(field3.getSignature()).equals((Object)fieldInstruction.getType(this.constantPoolGen))) {\n+                            field = field3;\n+                            if ((field.getAccessFlags() & 0x5) == 0x0) {\n+                                field = null;\n                                 break Label_0322;\n                             }\n+                            break Label_0322;\n+                        }\n+                        else {\n+                            ++k;\n                         }\n                     }\n                 }\n-                if (f == null) {\n-                    this.constraintViolated((Instruction)o, \"Referenced field '\" + field_name + \"' does not exist in class '\" + jc.getClassName() + \"'.\");\n+                if (field == null) {\n+                    this.constraintViolated((Instruction)fieldInstruction, \"Referenced field '\" + fieldName + \"' does not exist in class '\" + lookupClass.getClassName() + \"'.\");\n                 }\n             }\n             else {\n-                Type.getType(f.getSignature());\n-                o.getType(this.constantPoolGen);\n+                Type.getType(field.getSignature());\n+                fieldInstruction.getType(this.constantPoolGen);\n             }\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj, (Throwable)obj);\n         }\n     }\n     \n-    public void visitFLOAD(final FLOAD o) {\n-        final int idx = o.getIndex();\n-        if (idx < 0) {\n-            this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must be non-negative.\");\n+    public void visitFLOAD(final FLOAD fload) {\n+        final int index = fload.getIndex();\n+        if (index < 0) {\n+            this.constraintViolated((Instruction)fload, \"Index '\" + index + \"' must be non-negative.\");\n         }\n         else {\n-            final int maxminus1 = this.max_locals() - 1;\n-            if (idx > maxminus1) {\n-                this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must not be greater than max_locals-1 '\" + maxminus1 + \"'.\");\n+            final int i = this.max_locals() - 1;\n+            if (index > i) {\n+                this.constraintViolated((Instruction)fload, \"Index '\" + index + \"' must not be greater than max_locals-1 '\" + i + \"'.\");\n             }\n         }\n     }\n     \n-    public void visitFSTORE(final FSTORE o) {\n-        final int idx = o.getIndex();\n-        if (idx < 0) {\n-            this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must be non-negative.\");\n+    public void visitFSTORE(final FSTORE fstore) {\n+        final int index = fstore.getIndex();\n+        if (index < 0) {\n+            this.constraintViolated((Instruction)fstore, \"Index '\" + index + \"' must be non-negative.\");\n         }\n         else {\n-            final int maxminus1 = this.max_locals() - 1;\n-            if (idx > maxminus1) {\n-                this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must not be greater than max_locals-1 '\" + maxminus1 + \"'.\");\n+            final int i = this.max_locals() - 1;\n+            if (index > i) {\n+                this.constraintViolated((Instruction)fstore, \"Index '\" + index + \"' must not be greater than max_locals-1 '\" + i + \"'.\");\n             }\n         }\n     }\n     \n-    public void visitGETSTATIC(final GETSTATIC o) {\n+    public void visitGETSTATIC(final GETSTATIC getstatic) {\n         try {\n-            final String field_name = o.getFieldName(this.constantPoolGen);\n-            final JavaClass jc = Repository.lookupClass(this.getObjectType((FieldInstruction)o).getClassName());\n-            final Field[] fields = jc.getFields();\n-            Field f = null;\n+            final String fieldName = getstatic.getFieldName(this.constantPoolGen);\n+            final JavaClass lookupClass = Repository.lookupClass(this.getObjectType((FieldInstruction)getstatic).getClassName());\n+            final Field[] fields = lookupClass.getFields();\n+            Field obj = null;\n             for (final Field field : fields) {\n-                if (field.getName().equals(field_name)) {\n-                    f = field;\n+                if (field.getName().equals(fieldName)) {\n+                    obj = field;\n                     break;\n                 }\n             }\n-            if (f == null) {\n-                throw new AssertionViolatedException(\"Field '\" + field_name + \"' not found in \" + jc.getClassName());\n+            if (obj == null) {\n+                throw new AssertionViolatedException(\"Field '\" + fieldName + \"' not found in \" + lookupClass.getClassName());\n             }\n-            if (!f.isStatic()) {\n-                this.constraintViolated((Instruction)o, \"Referenced field '\" + f + \"' is not static which it should be.\");\n+            if (!obj.isStatic()) {\n+                this.constraintViolated((Instruction)getstatic, \"Referenced field '\" + obj + \"' is not static which it should be.\");\n             }\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj2) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj2, (Throwable)obj2);\n         }\n     }\n     \n-    public void visitIINC(final IINC o) {\n-        final int idx = o.getIndex();\n-        if (idx < 0) {\n-            this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must be non-negative.\");\n+    public void visitIINC(final IINC iinc) {\n+        final int index = iinc.getIndex();\n+        if (index < 0) {\n+            this.constraintViolated((Instruction)iinc, \"Index '\" + index + \"' must be non-negative.\");\n         }\n         else {\n-            final int maxminus1 = this.max_locals() - 1;\n-            if (idx > maxminus1) {\n-                this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must not be greater than max_locals-1 '\" + maxminus1 + \"'.\");\n+            final int i = this.max_locals() - 1;\n+            if (index > i) {\n+                this.constraintViolated((Instruction)iinc, \"Index '\" + index + \"' must not be greater than max_locals-1 '\" + i + \"'.\");\n             }\n         }\n     }\n     \n-    public void visitILOAD(final ILOAD o) {\n-        final int idx = o.getIndex();\n-        if (idx < 0) {\n-            this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must be non-negative.\");\n+    public void visitILOAD(final ILOAD iload) {\n+        final int index = iload.getIndex();\n+        if (index < 0) {\n+            this.constraintViolated((Instruction)iload, \"Index '\" + index + \"' must be non-negative.\");\n         }\n         else {\n-            final int maxminus1 = this.max_locals() - 1;\n-            if (idx > maxminus1) {\n-                this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must not be greater than max_locals-1 '\" + maxminus1 + \"'.\");\n+            final int i = this.max_locals() - 1;\n+            if (index > i) {\n+                this.constraintViolated((Instruction)iload, \"Index '\" + index + \"' must not be greater than max_locals-1 '\" + i + \"'.\");\n             }\n         }\n     }\n     \n-    public void visitINSTANCEOF(final INSTANCEOF o) {\n-        this.indexValid((Instruction)o, o.getIndex());\n-        final Constant c = this.constantPoolGen.getConstant(o.getIndex());\n-        if (!(c instanceof ConstantClass)) {\n-            this.constraintViolated((Instruction)o, \"Expecting a CONSTANT_Class operand, but found a '\" + this.this$0.tostring((Object)c) + \"'.\");\n+    public void visitINSTANCEOF(final INSTANCEOF instanceof1) {\n+        this.indexValid((Instruction)instanceof1, instanceof1.getIndex());\n+        final Constant constant = this.constantPoolGen.getConstant(instanceof1.getIndex());\n+        if (!(constant instanceof ConstantClass)) {\n+            this.constraintViolated((Instruction)instanceof1, \"Expecting a CONSTANT_Class operand, but found a '\" + this.this$0.tostring((Object)constant) + \"'.\");\n         }\n     }\n     \n-    public void visitINVOKEDYNAMIC(final INVOKEDYNAMIC o) {\n+    public void visitINVOKEDYNAMIC(final INVOKEDYNAMIC invokedynamic) {\n         throw new UnsupportedOperationException(\"INVOKEDYNAMIC instruction is not supported at this time\");\n     }\n     \n-    public void visitInvokeInstruction(final InvokeInstruction o) {\n-        this.indexValid((Instruction)o, o.getIndex());\n-        if (o instanceof INVOKEVIRTUAL || o instanceof INVOKESPECIAL || o instanceof INVOKESTATIC) {\n-            final Constant c = this.constantPoolGen.getConstant(o.getIndex());\n-            if (!(c instanceof ConstantMethodref)) {\n-                this.constraintViolated((Instruction)o, \"Indexing a constant that's not a CONSTANT_Methodref but a '\" + this.this$0.tostring((Object)c) + \"'.\");\n+    public void visitInvokeInstruction(final InvokeInstruction invokeInstruction) {\n+        this.indexValid((Instruction)invokeInstruction, invokeInstruction.getIndex());\n+        if (invokeInstruction instanceof INVOKEVIRTUAL || invokeInstruction instanceof INVOKESPECIAL || invokeInstruction instanceof INVOKESTATIC) {\n+            final Constant constant = this.constantPoolGen.getConstant(invokeInstruction.getIndex());\n+            if (!(constant instanceof ConstantMethodref)) {\n+                this.constraintViolated((Instruction)invokeInstruction, \"Indexing a constant that's not a CONSTANT_Methodref but a '\" + this.this$0.tostring((Object)constant) + \"'.\");\n             }\n             else {\n-                final ConstantNameAndType cnat = (ConstantNameAndType)this.constantPoolGen.getConstant(((ConstantMethodref)c).getNameAndTypeIndex());\n-                final ConstantUtf8 cutf8 = (ConstantUtf8)this.constantPoolGen.getConstant(cnat.getNameIndex());\n-                if (cutf8.getBytes().equals(\"<init>\") && !(o instanceof INVOKESPECIAL)) {\n-                    this.constraintViolated((Instruction)o, \"Only INVOKESPECIAL is allowed to invoke instance initialization methods.\");\n+                final ConstantUtf8 constantUtf8 = (ConstantUtf8)this.constantPoolGen.getConstant(((ConstantNameAndType)this.constantPoolGen.getConstant(((ConstantMethodref)constant).getNameAndTypeIndex())).getNameIndex());\n+                if (constantUtf8.getBytes().equals(\"<init>\") && !(invokeInstruction instanceof INVOKESPECIAL)) {\n+                    this.constraintViolated((Instruction)invokeInstruction, \"Only INVOKESPECIAL is allowed to invoke instance initialization methods.\");\n                 }\n-                if (!cutf8.getBytes().equals(\"<init>\") && cutf8.getBytes().startsWith(\"<\")) {\n-                    this.constraintViolated((Instruction)o, \"No method with a name beginning with '<' other than the instance initialization methods may be called by the method invocation instructions.\");\n+                if (!constantUtf8.getBytes().equals(\"<init>\") && constantUtf8.getBytes().startsWith(\"<\")) {\n+                    this.constraintViolated((Instruction)invokeInstruction, \"No method with a name beginning with '<' other than the instance initialization methods may be called by the method invocation instructions.\");\n                 }\n             }\n         }\n         else {\n-            final Constant c = this.constantPoolGen.getConstant(o.getIndex());\n-            if (!(c instanceof ConstantInterfaceMethodref)) {\n-                this.constraintViolated((Instruction)o, \"Indexing a constant that's not a CONSTANT_InterfaceMethodref but a '\" + this.this$0.tostring((Object)c) + \"'.\");\n-            }\n-            final ConstantNameAndType cnat = (ConstantNameAndType)this.constantPoolGen.getConstant(((ConstantInterfaceMethodref)c).getNameAndTypeIndex());\n-            final String name = ((ConstantUtf8)this.constantPoolGen.getConstant(cnat.getNameIndex())).getBytes();\n-            if (name.equals(\"<init>\")) {\n-                this.constraintViolated((Instruction)o, \"Method to invoke must not be '<init>'.\");\n-            }\n-            if (name.equals(\"<clinit>\")) {\n-                this.constraintViolated((Instruction)o, \"Method to invoke must not be '<clinit>'.\");\n-            }\n-        }\n-        Type t = o.getReturnType(this.constantPoolGen);\n-        if (t instanceof ArrayType) {\n-            t = ((ArrayType)t).getBasicType();\n-        }\n-        if (t instanceof ObjectType) {\n-            final Verifier v = VerifierFactory.getVerifier(((ObjectType)t).getClassName());\n-            final VerificationResult vr = v.doPass2();\n-            if (vr.getStatus() != 1) {\n-                this.constraintViolated((Instruction)o, \"Return type class/interface could not be verified successfully: '\" + vr.getMessage() + \"'.\");\n-            }\n-        }\n-        final Type[] argumentTypes;\n-        final Type[] ts = argumentTypes = o.getArgumentTypes(this.constantPoolGen);\n-        for (int length = argumentTypes.length, i = 0; i < length; ++i) {\n-            final Type element = t = argumentTypes[i];\n-            if (t instanceof ArrayType) {\n-                t = ((ArrayType)t).getBasicType();\n-            }\n-            if (t instanceof ObjectType) {\n-                final Verifier v2 = VerifierFactory.getVerifier(((ObjectType)t).getClassName());\n-                final VerificationResult vr2 = v2.doPass2();\n-                if (vr2.getStatus() != 1) {\n-                    this.constraintViolated((Instruction)o, \"Argument type class/interface could not be verified successfully: '\" + vr2.getMessage() + \"'.\");\n+            final Constant constant2 = this.constantPoolGen.getConstant(invokeInstruction.getIndex());\n+            if (!(constant2 instanceof ConstantInterfaceMethodref)) {\n+                this.constraintViolated((Instruction)invokeInstruction, \"Indexing a constant that's not a CONSTANT_InterfaceMethodref but a '\" + this.this$0.tostring((Object)constant2) + \"'.\");\n+            }\n+            final String bytes = ((ConstantUtf8)this.constantPoolGen.getConstant(((ConstantNameAndType)this.constantPoolGen.getConstant(((ConstantInterfaceMethodref)constant2).getNameAndTypeIndex())).getNameIndex())).getBytes();\n+            if (bytes.equals(\"<init>\")) {\n+                this.constraintViolated((Instruction)invokeInstruction, \"Method to invoke must not be '<init>'.\");\n+            }\n+            if (bytes.equals(\"<clinit>\")) {\n+                this.constraintViolated((Instruction)invokeInstruction, \"Method to invoke must not be '<clinit>'.\");\n+            }\n+        }\n+        Type type = invokeInstruction.getReturnType(this.constantPoolGen);\n+        if (type instanceof ArrayType) {\n+            type = ((ArrayType)type).getBasicType();\n+        }\n+        if (type instanceof ObjectType) {\n+            final VerificationResult doPass2 = VerifierFactory.getVerifier(((ObjectType)type).getClassName()).doPass2();\n+            if (doPass2.getStatus() != 1) {\n+                this.constraintViolated((Instruction)invokeInstruction, \"Return type class/interface could not be verified successfully: '\" + doPass2.getMessage() + \"'.\");\n+            }\n+        }\n+        for (Type basicType : invokeInstruction.getArgumentTypes(this.constantPoolGen)) {\n+            if (basicType instanceof ArrayType) {\n+                basicType = ((ArrayType)basicType).getBasicType();\n+            }\n+            if (basicType instanceof ObjectType) {\n+                final VerificationResult doPass3 = VerifierFactory.getVerifier(((ObjectType)basicType).getClassName()).doPass2();\n+                if (doPass3.getStatus() != 1) {\n+                    this.constraintViolated((Instruction)invokeInstruction, \"Argument type class/interface could not be verified successfully: '\" + doPass3.getMessage() + \"'.\");\n                 }\n             }\n         }\n     }\n     \n-    public void visitINVOKEINTERFACE(final INVOKEINTERFACE o) {\n+    public void visitINVOKEINTERFACE(final INVOKEINTERFACE invokeinterface) {\n         try {\n-            final String classname = o.getClassName(this.constantPoolGen);\n-            final JavaClass jc = Repository.lookupClass(classname);\n-            final Method m = this.getMethodRecursive(jc, (InvokeInstruction)o);\n-            if (m == null) {\n-                this.constraintViolated((Instruction)o, \"Referenced method '\" + o.getMethodName(this.constantPoolGen) + \"' with expected signature '\" + o.getSignature(this.constantPoolGen) + \"' not found in class '\" + jc.getClassName() + \"'.\");\n+            final JavaClass lookupClass = Repository.lookupClass(invokeinterface.getClassName(this.constantPoolGen));\n+            if (this.getMethodRecursive(lookupClass, (InvokeInstruction)invokeinterface) == null) {\n+                this.constraintViolated((Instruction)invokeinterface, \"Referenced method '\" + invokeinterface.getMethodName(this.constantPoolGen) + \"' with expected signature '\" + invokeinterface.getSignature(this.constantPoolGen) + \"' not found in class '\" + lookupClass.getClassName() + \"'.\");\n             }\n-            if (jc.isClass()) {\n-                this.constraintViolated((Instruction)o, \"Referenced class '\" + jc.getClassName() + \"' is a class, but not an interface as expected.\");\n+            if (lookupClass.isClass()) {\n+                this.constraintViolated((Instruction)invokeinterface, \"Referenced class '\" + lookupClass.getClassName() + \"' is a class, but not an interface as expected.\");\n             }\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj, (Throwable)obj);\n         }\n     }\n     \n-    public void visitINVOKESPECIAL(final INVOKESPECIAL o) {\n+    public void visitINVOKESPECIAL(final INVOKESPECIAL invokespecial) {\n         try {\n-            final String classname = o.getClassName(this.constantPoolGen);\n-            final JavaClass jc = Repository.lookupClass(classname);\n-            final Method m = this.getMethodRecursive(jc, (InvokeInstruction)o);\n-            if (m == null) {\n-                this.constraintViolated((Instruction)o, \"Referenced method '\" + o.getMethodName(this.constantPoolGen) + \"' with expected signature '\" + o.getSignature(this.constantPoolGen) + \"' not found in class '\" + jc.getClassName() + \"'.\");\n-            }\n-            JavaClass current = Repository.lookupClass(Pass3aVerifier.access$000(this.this$0).getClassName());\n-            if (current.isSuper() && Repository.instanceOf(current, jc) && !current.equals((Object)jc) && !o.getMethodName(this.constantPoolGen).equals(\"<init>\")) {\n-                int supidx = -1;\n-                Method meth = null;\n-                while (supidx != 0) {\n-                    supidx = current.getSuperclassNameIndex();\n-                    current = Repository.lookupClass(current.getSuperclassName());\n-                    final Method[] methods;\n-                    final Method[] meths = methods = current.getMethods();\n-                    for (final Method meth2 : methods) {\n-                        if (meth2.getName().equals(o.getMethodName(this.constantPoolGen)) && Type.getReturnType(meth2.getSignature()).equals((Object)o.getReturnType(this.constantPoolGen)) && this.objarrayequals(Type.getArgumentTypes(meth2.getSignature()), o.getArgumentTypes(this.constantPoolGen))) {\n-                            meth = meth2;\n+            final JavaClass lookupClass = Repository.lookupClass(invokespecial.getClassName(this.constantPoolGen));\n+            if (this.getMethodRecursive(lookupClass, (InvokeInstruction)invokespecial) == null) {\n+                this.constraintViolated((Instruction)invokespecial, \"Referenced method '\" + invokespecial.getMethodName(this.constantPoolGen) + \"' with expected signature '\" + invokespecial.getSignature(this.constantPoolGen) + \"' not found in class '\" + lookupClass.getClassName() + \"'.\");\n+            }\n+            JavaClass javaClass = Repository.lookupClass(Pass3aVerifier.access$000(this.this$0).getClassName());\n+            if (javaClass.isSuper() && Repository.instanceOf(javaClass, lookupClass) && !javaClass.equals((Object)lookupClass) && !invokespecial.getMethodName(this.constantPoolGen).equals(\"<init>\")) {\n+                int i = -1;\n+                Method method = null;\n+                while (i != 0) {\n+                    i = javaClass.getSuperclassNameIndex();\n+                    javaClass = Repository.lookupClass(javaClass.getSuperclassName());\n+                    for (final Method method2 : javaClass.getMethods()) {\n+                        if (method2.getName().equals(invokespecial.getMethodName(this.constantPoolGen)) && Type.getReturnType(method2.getSignature()).equals((Object)invokespecial.getReturnType(this.constantPoolGen)) && this.objarrayequals(Type.getArgumentTypes(method2.getSignature()), invokespecial.getArgumentTypes(this.constantPoolGen))) {\n+                            method = method2;\n                             break;\n                         }\n                     }\n-                    if (meth != null) {\n+                    if (method != null) {\n                         break;\n                     }\n                 }\n-                if (meth == null) {\n-                    this.constraintViolated((Instruction)o, \"ACC_SUPER special lookup procedure not successful: method '\" + o.getMethodName(this.constantPoolGen) + \"' with proper signature not declared in superclass hierarchy.\");\n+                if (method == null) {\n+                    this.constraintViolated((Instruction)invokespecial, \"ACC_SUPER special lookup procedure not successful: method '\" + invokespecial.getMethodName(this.constantPoolGen) + \"' with proper signature not declared in superclass hierarchy.\");\n                 }\n             }\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj, (Throwable)obj);\n         }\n     }\n     \n-    public void visitINVOKESTATIC(final INVOKESTATIC o) {\n+    public void visitINVOKESTATIC(final INVOKESTATIC invokestatic) {\n         try {\n-            final String classname = o.getClassName(this.constantPoolGen);\n-            final JavaClass jc = Repository.lookupClass(classname);\n-            final Method m = this.getMethodRecursive(jc, (InvokeInstruction)o);\n-            if (m == null) {\n-                this.constraintViolated((Instruction)o, \"Referenced method '\" + o.getMethodName(this.constantPoolGen) + \"' with expected signature '\" + o.getSignature(this.constantPoolGen) + \"' not found in class '\" + jc.getClassName() + \"'.\");\n+            final JavaClass lookupClass = Repository.lookupClass(invokestatic.getClassName(this.constantPoolGen));\n+            final Method methodRecursive = this.getMethodRecursive(lookupClass, (InvokeInstruction)invokestatic);\n+            if (methodRecursive == null) {\n+                this.constraintViolated((Instruction)invokestatic, \"Referenced method '\" + invokestatic.getMethodName(this.constantPoolGen) + \"' with expected signature '\" + invokestatic.getSignature(this.constantPoolGen) + \"' not found in class '\" + lookupClass.getClassName() + \"'.\");\n             }\n-            else if (!m.isStatic()) {\n-                this.constraintViolated((Instruction)o, \"Referenced method '\" + o.getMethodName(this.constantPoolGen) + \"' has ACC_STATIC unset.\");\n+            else if (!methodRecursive.isStatic()) {\n+                this.constraintViolated((Instruction)invokestatic, \"Referenced method '\" + invokestatic.getMethodName(this.constantPoolGen) + \"' has ACC_STATIC unset.\");\n             }\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj, (Throwable)obj);\n         }\n     }\n     \n-    public void visitINVOKEVIRTUAL(final INVOKEVIRTUAL o) {\n+    public void visitINVOKEVIRTUAL(final INVOKEVIRTUAL invokevirtual) {\n         try {\n-            final String classname = o.getClassName(this.constantPoolGen);\n-            final JavaClass jc = Repository.lookupClass(classname);\n-            final Method m = this.getMethodRecursive(jc, (InvokeInstruction)o);\n-            if (m == null) {\n-                this.constraintViolated((Instruction)o, \"Referenced method '\" + o.getMethodName(this.constantPoolGen) + \"' with expected signature '\" + o.getSignature(this.constantPoolGen) + \"' not found in class '\" + jc.getClassName() + \"'.\");\n+            final JavaClass lookupClass = Repository.lookupClass(invokevirtual.getClassName(this.constantPoolGen));\n+            if (this.getMethodRecursive(lookupClass, (InvokeInstruction)invokevirtual) == null) {\n+                this.constraintViolated((Instruction)invokevirtual, \"Referenced method '\" + invokevirtual.getMethodName(this.constantPoolGen) + \"' with expected signature '\" + invokevirtual.getSignature(this.constantPoolGen) + \"' not found in class '\" + lookupClass.getClassName() + \"'.\");\n             }\n-            if (!jc.isClass()) {\n-                this.constraintViolated((Instruction)o, \"Referenced class '\" + jc.getClassName() + \"' is an interface, but not a class as expected.\");\n+            if (!lookupClass.isClass()) {\n+                this.constraintViolated((Instruction)invokevirtual, \"Referenced class '\" + lookupClass.getClassName() + \"' is an interface, but not a class as expected.\");\n             }\n         }\n-        catch (final ClassNotFoundException e) {\n-            this.this$0.addMessage(\"Unable to verify INVOKEVITUAL as cannot load target class: \" + e.getCause());\n+        catch (final ClassNotFoundException ex) {\n+            this.this$0.addMessage(\"Unable to verify INVOKEVITUAL as cannot load target class: \" + ex.getCause());\n         }\n     }\n     \n-    public void visitISTORE(final ISTORE o) {\n-        final int idx = o.getIndex();\n-        if (idx < 0) {\n-            this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must be non-negative.\");\n+    public void visitISTORE(final ISTORE istore) {\n+        final int index = istore.getIndex();\n+        if (index < 0) {\n+            this.constraintViolated((Instruction)istore, \"Index '\" + index + \"' must be non-negative.\");\n         }\n         else {\n-            final int maxminus1 = this.max_locals() - 1;\n-            if (idx > maxminus1) {\n-                this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must not be greater than max_locals-1 '\" + maxminus1 + \"'.\");\n+            final int i = this.max_locals() - 1;\n+            if (index > i) {\n+                this.constraintViolated((Instruction)istore, \"Index '\" + index + \"' must not be greater than max_locals-1 '\" + i + \"'.\");\n             }\n         }\n     }\n     \n     public void visitLDC(final LDC ldc) {\n         this.indexValid((Instruction)ldc, ldc.getIndex());\n-        final Constant c = this.constantPoolGen.getConstant(ldc.getIndex());\n-        if (c instanceof ConstantClass) {\n-            this.this$0.addMessage(\"Operand of LDC or LDC_W is CONSTANT_Class '\" + this.this$0.tostring((Object)c) + \"' - this is only supported in JDK 1.5 and higher.\");\n+        final Constant constant = this.constantPoolGen.getConstant(ldc.getIndex());\n+        if (constant instanceof ConstantClass) {\n+            this.this$0.addMessage(\"Operand of LDC or LDC_W is CONSTANT_Class '\" + this.this$0.tostring((Object)constant) + \"' - this is only supported in JDK 1.5 and higher.\");\n         }\n-        else if (!(c instanceof ConstantInteger) && !(c instanceof ConstantFloat) && !(c instanceof ConstantString)) {\n-            this.constraintViolated((Instruction)ldc, \"Operand of LDC or LDC_W must be one of CONSTANT_Integer, CONSTANT_Float or CONSTANT_String, but is '\" + this.this$0.tostring((Object)c) + \"'.\");\n+        else if (!(constant instanceof ConstantInteger) && !(constant instanceof ConstantFloat) && !(constant instanceof ConstantString)) {\n+            this.constraintViolated((Instruction)ldc, \"Operand of LDC or LDC_W must be one of CONSTANT_Integer, CONSTANT_Float or CONSTANT_String, but is '\" + this.this$0.tostring((Object)constant) + \"'.\");\n         }\n     }\n     \n-    public void visitLDC2_W(final LDC2_W o) {\n-        this.indexValid((Instruction)o, o.getIndex());\n-        final Constant c = this.constantPoolGen.getConstant(o.getIndex());\n-        if (!(c instanceof ConstantLong) && !(c instanceof ConstantDouble)) {\n-            this.constraintViolated((Instruction)o, \"Operand of LDC2_W must be CONSTANT_Long or CONSTANT_Double, but is '\" + this.this$0.tostring((Object)c) + \"'.\");\n+    public void visitLDC2_W(final LDC2_W ldc2_W) {\n+        this.indexValid((Instruction)ldc2_W, ldc2_W.getIndex());\n+        final Constant constant = this.constantPoolGen.getConstant(ldc2_W.getIndex());\n+        if (!(constant instanceof ConstantLong) && !(constant instanceof ConstantDouble)) {\n+            this.constraintViolated((Instruction)ldc2_W, \"Operand of LDC2_W must be CONSTANT_Long or CONSTANT_Double, but is '\" + this.this$0.tostring((Object)constant) + \"'.\");\n         }\n         try {\n-            this.indexValid((Instruction)o, o.getIndex() + 1);\n+            this.indexValid((Instruction)ldc2_W, ldc2_W.getIndex() + 1);\n         }\n-        catch (final StaticCodeInstructionOperandConstraintException e) {\n-            throw new AssertionViolatedException(\"Does not BCEL handle that? LDC2_W operand has a problem.\", (Throwable)e);\n+        catch (final StaticCodeInstructionOperandConstraintException ex) {\n+            throw new AssertionViolatedException(\"Does not BCEL handle that? LDC2_W operand has a problem.\", (Throwable)ex);\n         }\n     }\n     \n-    public void visitLLOAD(final LLOAD o) {\n-        final int idx = o.getIndex();\n-        if (idx < 0) {\n-            this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must be non-negative. [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]\");\n+    public void visitLLOAD(final LLOAD lload) {\n+        final int index = lload.getIndex();\n+        if (index < 0) {\n+            this.constraintViolated((Instruction)lload, \"Index '\" + index + \"' must be non-negative. [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]\");\n         }\n         else {\n-            final int maxminus2 = this.max_locals() - 2;\n-            if (idx > maxminus2) {\n-                this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must not be greater than max_locals-2 '\" + maxminus2 + \"'.\");\n+            final int i = this.max_locals() - 2;\n+            if (index > i) {\n+                this.constraintViolated((Instruction)lload, \"Index '\" + index + \"' must not be greater than max_locals-2 '\" + i + \"'.\");\n             }\n         }\n     }\n     \n     public void visitLoadClass(final LoadClass loadClass) {\n-        final ObjectType t = loadClass.getLoadClassType(this.constantPoolGen);\n-        if (t != null) {\n-            final Verifier v = VerifierFactory.getVerifier(t.getClassName());\n-            final VerificationResult vr = v.doPass1();\n-            if (vr.getStatus() != 1) {\n-                this.constraintViolated((Instruction)loadClass, \"Class '\" + loadClass.getLoadClassType(this.constantPoolGen).getClassName() + \"' is referenced, but cannot be loaded: '\" + vr + \"'.\");\n+        final ObjectType loadClassType = loadClass.getLoadClassType(this.constantPoolGen);\n+        if (loadClassType != null) {\n+            final VerificationResult doPass1 = VerifierFactory.getVerifier(loadClassType.getClassName()).doPass1();\n+            if (doPass1.getStatus() != 1) {\n+                this.constraintViolated((Instruction)loadClass, \"Class '\" + loadClass.getLoadClassType(this.constantPoolGen).getClassName() + \"' is referenced, but cannot be loaded: '\" + doPass1 + \"'.\");\n             }\n         }\n     }\n     \n-    public void visitLOOKUPSWITCH(final LOOKUPSWITCH o) {\n-        final int[] matchs = o.getMatchs();\n-        int max = Integer.MIN_VALUE;\n+    public void visitLOOKUPSWITCH(final LOOKUPSWITCH lookupswitch) {\n+        final int[] matchs = lookupswitch.getMatchs();\n+        int n = Integer.MIN_VALUE;\n         for (int i = 0; i < matchs.length; ++i) {\n-            if (matchs[i] == max && i != 0) {\n-                this.constraintViolated((Instruction)o, \"Match '\" + matchs[i] + \"' occurs more than once.\");\n+            if (matchs[i] == n && i != 0) {\n+                this.constraintViolated((Instruction)lookupswitch, \"Match '\" + matchs[i] + \"' occurs more than once.\");\n             }\n-            if (matchs[i] < max) {\n-                this.constraintViolated((Instruction)o, \"Lookup table must be sorted but isn't.\");\n+            if (matchs[i] < n) {\n+                this.constraintViolated((Instruction)lookupswitch, \"Lookup table must be sorted but isn't.\");\n             }\n             else {\n-                max = matchs[i];\n+                n = matchs[i];\n             }\n         }\n     }\n     \n-    public void visitLSTORE(final LSTORE o) {\n-        final int idx = o.getIndex();\n-        if (idx < 0) {\n-            this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must be non-negative. [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]\");\n+    public void visitLSTORE(final LSTORE lstore) {\n+        final int index = lstore.getIndex();\n+        if (index < 0) {\n+            this.constraintViolated((Instruction)lstore, \"Index '\" + index + \"' must be non-negative. [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]\");\n         }\n         else {\n-            final int maxminus2 = this.max_locals() - 2;\n-            if (idx > maxminus2) {\n-                this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must not be greater than max_locals-2 '\" + maxminus2 + \"'.\");\n+            final int i = this.max_locals() - 2;\n+            if (index > i) {\n+                this.constraintViolated((Instruction)lstore, \"Index '\" + index + \"' must not be greater than max_locals-2 '\" + i + \"'.\");\n             }\n         }\n     }\n     \n-    public void visitMULTIANEWARRAY(final MULTIANEWARRAY o) {\n-        this.indexValid((Instruction)o, o.getIndex());\n-        final Constant c = this.constantPoolGen.getConstant(o.getIndex());\n-        if (!(c instanceof ConstantClass)) {\n-            this.constraintViolated((Instruction)o, \"Expecting a CONSTANT_Class operand, but found a '\" + this.this$0.tostring((Object)c) + \"'.\");\n+    public void visitMULTIANEWARRAY(final MULTIANEWARRAY multianewarray) {\n+        this.indexValid((Instruction)multianewarray, multianewarray.getIndex());\n+        final Constant constant = this.constantPoolGen.getConstant(multianewarray.getIndex());\n+        if (!(constant instanceof ConstantClass)) {\n+            this.constraintViolated((Instruction)multianewarray, \"Expecting a CONSTANT_Class operand, but found a '\" + this.this$0.tostring((Object)constant) + \"'.\");\n         }\n-        final int dimensions2create = o.getDimensions();\n-        if (dimensions2create < 1) {\n-            this.constraintViolated((Instruction)o, \"Number of dimensions to create must be greater than zero.\");\n+        final short dimensions = multianewarray.getDimensions();\n+        if (dimensions < 1) {\n+            this.constraintViolated((Instruction)multianewarray, \"Number of dimensions to create must be greater than zero.\");\n         }\n-        final Type t = o.getType(this.constantPoolGen);\n-        if (t instanceof ArrayType) {\n-            final int dimensions = ((ArrayType)t).getDimensions();\n-            if (dimensions < dimensions2create) {\n-                this.constraintViolated((Instruction)o, \"Not allowed to create array with more dimensions ('\" + dimensions2create + \"') than the one referenced by the CONSTANT_Class '\" + t + \"'.\");\n+        final Type type = multianewarray.getType(this.constantPoolGen);\n+        if (type instanceof ArrayType) {\n+            if (((ArrayType)type).getDimensions() < dimensions) {\n+                this.constraintViolated((Instruction)multianewarray, \"Not allowed to create array with more dimensions ('\" + dimensions + \"') than the one referenced by the CONSTANT_Class '\" + type + \"'.\");\n             }\n         }\n         else {\n-            this.constraintViolated((Instruction)o, \"Expecting a CONSTANT_Class referencing an array type. [Constraint not found in The Java Virtual Machine Specification, Second Edition, 4.8.1]\");\n+            this.constraintViolated((Instruction)multianewarray, \"Expecting a CONSTANT_Class referencing an array type. [Constraint not found in The Java Virtual Machine Specification, Second Edition, 4.8.1]\");\n         }\n     }\n     \n-    public void visitNEW(final NEW o) {\n-        this.indexValid((Instruction)o, o.getIndex());\n-        final Constant c = this.constantPoolGen.getConstant(o.getIndex());\n-        if (!(c instanceof ConstantClass)) {\n-            this.constraintViolated((Instruction)o, \"Expecting a CONSTANT_Class operand, but found a '\" + this.this$0.tostring((Object)c) + \"'.\");\n+    public void visitNEW(final NEW new1) {\n+        this.indexValid((Instruction)new1, new1.getIndex());\n+        final Constant constant = this.constantPoolGen.getConstant(new1.getIndex());\n+        if (!(constant instanceof ConstantClass)) {\n+            this.constraintViolated((Instruction)new1, \"Expecting a CONSTANT_Class operand, but found a '\" + this.this$0.tostring((Object)constant) + \"'.\");\n         }\n-        else {\n-            final ConstantUtf8 cutf8 = (ConstantUtf8)this.constantPoolGen.getConstant(((ConstantClass)c).getNameIndex());\n-            final Type t = Type.getType(\"L\" + cutf8.getBytes() + \";\");\n-            if (t instanceof ArrayType) {\n-                this.constraintViolated((Instruction)o, \"NEW must not be used to create an array.\");\n-            }\n+        else if (Type.getType(\"L\" + ((ConstantUtf8)this.constantPoolGen.getConstant(((ConstantClass)constant).getNameIndex())).getBytes() + \";\") instanceof ArrayType) {\n+            this.constraintViolated((Instruction)new1, \"NEW must not be used to create an array.\");\n         }\n     }\n     \n-    public void visitNEWARRAY(final NEWARRAY o) {\n-        final byte t = o.getTypecode();\n-        if (t != 4 && t != 5 && t != 6 && t != 7 && t != 8 && t != 9 && t != 10 && t != 11) {\n-            this.constraintViolated((Instruction)o, \"Illegal type code '\" + this.this$0.tostring((Object)Byte.valueOf(t)) + \"' for 'atype' operand.\");\n+    public void visitNEWARRAY(final NEWARRAY newarray) {\n+        final byte typecode = newarray.getTypecode();\n+        if (typecode != 4 && typecode != 5 && typecode != 6 && typecode != 7 && typecode != 8 && typecode != 9 && typecode != 10 && typecode != 11) {\n+            this.constraintViolated((Instruction)newarray, \"Illegal type code '\" + this.this$0.tostring((Object)Byte.valueOf(typecode)) + \"' for 'atype' operand.\");\n         }\n     }\n     \n-    public void visitPUTSTATIC(final PUTSTATIC o) {\n+    public void visitPUTSTATIC(final PUTSTATIC putstatic) {\n         try {\n-            final String field_name = o.getFieldName(this.constantPoolGen);\n-            final JavaClass jc = Repository.lookupClass(this.getObjectType((FieldInstruction)o).getClassName());\n-            final Field[] fields = jc.getFields();\n-            Field f = null;\n+            final String fieldName = putstatic.getFieldName(this.constantPoolGen);\n+            final JavaClass lookupClass = Repository.lookupClass(this.getObjectType((FieldInstruction)putstatic).getClassName());\n+            final Field[] fields = lookupClass.getFields();\n+            Field obj = null;\n             for (final Field field : fields) {\n-                if (field.getName().equals(field_name)) {\n-                    f = field;\n+                if (field.getName().equals(fieldName)) {\n+                    obj = field;\n                     break;\n                 }\n             }\n-            if (f == null) {\n-                throw new AssertionViolatedException(\"Field '\" + field_name + \"' not found in \" + jc.getClassName());\n+            if (obj == null) {\n+                throw new AssertionViolatedException(\"Field '\" + fieldName + \"' not found in \" + lookupClass.getClassName());\n             }\n-            if (f.isFinal() && !Pass3aVerifier.access$000(this.this$0).getClassName().equals(this.getObjectType((FieldInstruction)o).getClassName())) {\n-                this.constraintViolated((Instruction)o, \"Referenced field '\" + f + \"' is final and must therefore be declared in the current class '\" + Pass3aVerifier.access$000(this.this$0).getClassName() + \"' which is not the case: it is declared in '\" + o.getReferenceType(this.constantPoolGen) + \"'.\");\n+            if (obj.isFinal() && !Pass3aVerifier.access$000(this.this$0).getClassName().equals(this.getObjectType((FieldInstruction)putstatic).getClassName())) {\n+                this.constraintViolated((Instruction)putstatic, \"Referenced field '\" + obj + \"' is final and must therefore be declared in the current class '\" + Pass3aVerifier.access$000(this.this$0).getClassName() + \"' which is not the case: it is declared in '\" + putstatic.getReferenceType(this.constantPoolGen) + \"'.\");\n             }\n-            if (!f.isStatic()) {\n-                this.constraintViolated((Instruction)o, \"Referenced field '\" + f + \"' is not static which it should be.\");\n+            if (!obj.isStatic()) {\n+                this.constraintViolated((Instruction)putstatic, \"Referenced field '\" + obj + \"' is not static which it should be.\");\n             }\n-            final String meth_name = Repository.lookupClass(Pass3aVerifier.access$000(this.this$0).getClassName()).getMethods()[Pass3aVerifier.access$100(this.this$0)].getName();\n-            if (!jc.isClass() && !meth_name.equals(\"<clinit>\")) {\n-                this.constraintViolated((Instruction)o, \"Interface field '\" + f + \"' must be set in a '\" + \"<clinit>\" + \"' method.\");\n+            final String name = Repository.lookupClass(Pass3aVerifier.access$000(this.this$0).getClassName()).getMethods()[Pass3aVerifier.access$100(this.this$0)].getName();\n+            if (!lookupClass.isClass() && !name.equals(\"<clinit>\")) {\n+                this.constraintViolated((Instruction)putstatic, \"Interface field '\" + obj + \"' must be set in a '\" + \"<clinit>\" + \"' method.\");\n             }\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj2) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj2, (Throwable)obj2);\n         }\n     }\n     \n-    public void visitRET(final RET o) {\n-        final int idx = o.getIndex();\n-        if (idx < 0) {\n-            this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must be non-negative.\");\n+    public void visitRET(final RET ret) {\n+        final int index = ret.getIndex();\n+        if (index < 0) {\n+            this.constraintViolated((Instruction)ret, \"Index '\" + index + \"' must be non-negative.\");\n         }\n         else {\n-            final int maxminus1 = this.max_locals() - 1;\n-            if (idx > maxminus1) {\n-                this.constraintViolated((Instruction)o, \"Index '\" + idx + \"' must not be greater than max_locals-1 '\" + maxminus1 + \"'.\");\n+            final int i = this.max_locals() - 1;\n+            if (index > i) {\n+                this.constraintViolated((Instruction)ret, \"Index '\" + index + \"' must not be greater than max_locals-1 '\" + i + \"'.\");\n             }\n         }\n     }\n     \n-    public void visitTABLESWITCH(final TABLESWITCH o) {\n+    public void visitTABLESWITCH(final TABLESWITCH tableswitch) {\n     }\n }\n"}]}
