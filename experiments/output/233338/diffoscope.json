{"diffoscope-json-version": 1, "source1": "first/MergeCombiner.class", "source2": "second/MergeCombiner.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -8,69 +8,70 @@\n import java.util.Iterator;\n import java.util.List;\n import java.util.Collection;\n import java.util.LinkedList;\n \n public class MergeCombiner extends NodeCombiner\n {\n-    public ImmutableNode combine(final ImmutableNode node1, final ImmutableNode node2) {\n-        final ImmutableNode.Builder result = new ImmutableNode.Builder();\n-        result.name(node1.getNodeName());\n-        result.value(node1.getValue());\n-        this.addAttributes(result, node1, node2);\n-        final List<ImmutableNode> children2 = new LinkedList<ImmutableNode>(node2.getChildren());\n-        for (final ImmutableNode child1 : node1) {\n-            final ImmutableNode child2 = this.canCombine(node2, child1, children2);\n-            if (child2 != null) {\n-                result.addChild(this.combine(child1, child2));\n-                children2.remove(child2);\n+    public ImmutableNode combine(final ImmutableNode immutableNode, final ImmutableNode immutableNode2) {\n+        final ImmutableNode.Builder builder = new ImmutableNode.Builder();\n+        builder.name(immutableNode.getNodeName());\n+        builder.value(immutableNode.getValue());\n+        this.addAttributes(builder, immutableNode, immutableNode2);\n+        final LinkedList list = new LinkedList(immutableNode2.getChildren());\n+        for (final ImmutableNode immutableNode3 : immutableNode) {\n+            final ImmutableNode canCombine = this.canCombine(immutableNode2, immutableNode3, list);\n+            if (canCombine != null) {\n+                builder.addChild(this.combine(immutableNode3, canCombine));\n+                list.remove(canCombine);\n             }\n             else {\n-                result.addChild(child1);\n+                builder.addChild(immutableNode3);\n             }\n         }\n-        for (final ImmutableNode c : children2) {\n-            result.addChild(c);\n+        final Iterator iterator2 = list.iterator();\n+        while (iterator2.hasNext()) {\n+            builder.addChild((ImmutableNode)iterator2.next());\n         }\n-        return result.create();\n+        return builder.create();\n     }\n     \n-    protected void addAttributes(final ImmutableNode.Builder result, final ImmutableNode node1, final ImmutableNode node2) {\n-        final Map<String, Object> attributes = new HashMap<String, Object>(node1.getAttributes());\n-        for (final Map.Entry<String, Object> e : node2.getAttributes().entrySet()) {\n-            if (!attributes.containsKey(e.getKey())) {\n-                attributes.put(e.getKey(), e.getValue());\n+    protected void addAttributes(final ImmutableNode.Builder builder, final ImmutableNode immutableNode, final ImmutableNode immutableNode2) {\n+        final HashMap hashMap = new HashMap(immutableNode.getAttributes());\n+        for (final Map.Entry entry : immutableNode2.getAttributes().entrySet()) {\n+            if (!hashMap.containsKey(entry.getKey())) {\n+                hashMap.put(entry.getKey(), entry.getValue());\n             }\n         }\n-        result.addAttributes((Map)attributes);\n+        builder.addAttributes((Map)hashMap);\n     }\n     \n-    protected ImmutableNode canCombine(final ImmutableNode node2, final ImmutableNode child, final List<ImmutableNode> children2) {\n-        final Map<String, Object> attrs1 = child.getAttributes();\n-        final List<ImmutableNode> nodes = new ArrayList<ImmutableNode>();\n-        final List<ImmutableNode> children3 = MergeCombiner.HANDLER.getChildren((Object)node2, child.getNodeName());\n-        for (final ImmutableNode node3 : children3) {\n-            if (matchAttributes(attrs1, node3)) {\n-                nodes.add(node3);\n+    protected ImmutableNode canCombine(final ImmutableNode immutableNode, final ImmutableNode immutableNode2, final List<ImmutableNode> list) {\n+        final Map attributes = immutableNode2.getAttributes();\n+        final ArrayList list2 = new ArrayList();\n+        for (final ImmutableNode immutableNode3 : MergeCombiner.HANDLER.getChildren((Object)immutableNode, immutableNode2.getNodeName())) {\n+            if (matchAttributes(attributes, immutableNode3)) {\n+                list2.add(immutableNode3);\n             }\n         }\n-        if (nodes.size() == 1) {\n-            return nodes.get(0);\n-        }\n-        if (nodes.size() > 1 && !this.isListNode(child)) {\n-            for (final ImmutableNode node3 : nodes) {\n-                children2.remove(node3);\n+        if (list2.size() == 1) {\n+            return (ImmutableNode)list2.get(0);\n+        }\n+        if (list2.size() > 1 && !this.isListNode(immutableNode2)) {\n+            final Iterator iterator2 = list2.iterator();\n+            while (iterator2.hasNext()) {\n+                list.remove(iterator2.next());\n             }\n         }\n         return null;\n     }\n     \n-    private static boolean matchAttributes(final Map<String, Object> attrs1, final ImmutableNode node) {\n-        final Map<String, Object> attrs2 = node.getAttributes();\n-        for (final Map.Entry<String, Object> e : attrs1.entrySet()) {\n-            if (attrs2.containsKey(e.getKey()) && !Objects.equals(e.getValue(), attrs2.get((Object)e.getKey()))) {\n+    private static boolean matchAttributes(final Map<String, Object> map, final ImmutableNode immutableNode) {\n+        final Map attributes = immutableNode.getAttributes();\n+        for (final Map.Entry entry : map.entrySet()) {\n+            if (attributes.containsKey(entry.getKey()) && !Objects.equals(entry.getValue(), attributes.get(entry.getKey()))) {\n                 return false;\n             }\n         }\n         return true;\n     }\n }\n"}]}
