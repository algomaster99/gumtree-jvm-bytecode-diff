{"diffoscope-json-version": 1, "source1": "first/MultipleStringLiteralsCheck.class", "source2": "second/MultipleStringLiteralsCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -45,19 +45,18 @@\n             this.ignoreStringsRegexp = null;\n         }\n         else {\n             this.ignoreStringsRegexp = ignoreStringsRegexp;\n         }\n     }\n     \n-    public final void setIgnoreOccurrenceContext(final String... strRep) {\n+    public final void setIgnoreOccurrenceContext(final String... array) {\n         this.ignoreOccurrenceContext.clear();\n-        for (final String s : strRep) {\n-            final int type = TokenUtil.getTokenId(s);\n-            this.ignoreOccurrenceContext.set(type);\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            this.ignoreOccurrenceContext.set(TokenUtil.getTokenId(array[i]));\n         }\n     }\n     \n     public int[] getDefaultTokens() {\n         return this.getRequiredTokens();\n     }\n     \n@@ -65,53 +64,49 @@\n         return this.getRequiredTokens();\n     }\n     \n     public int[] getRequiredTokens() {\n         return new int[] { 139, 205 };\n     }\n     \n-    public void visitToken(final DetailAST ast) {\n-        if (!this.isInIgnoreOccurrenceContext(ast)) {\n-            String currentString;\n-            if (ast.getType() == 205) {\n-                final String strippedString = CheckUtil.stripIndentAndInitialNewLineFromTextBlock(ast.getText());\n-                currentString = \"\\\"\" + strippedString;\n+    public void visitToken(final DetailAST detailAST) {\n+        if (!this.isInIgnoreOccurrenceContext(detailAST)) {\n+            String text;\n+            if (detailAST.getType() == 205) {\n+                text = \"\\\"\" + CheckUtil.stripIndentAndInitialNewLineFromTextBlock(detailAST.getText());\n             }\n             else {\n-                currentString = ast.getText();\n+                text = detailAST.getText();\n             }\n-            if (this.ignoreStringsRegexp == null || !this.ignoreStringsRegexp.matcher(currentString).find()) {\n-                ((List<DetailAST>)this.stringMap.computeIfAbsent(currentString, key -> new ArrayList())).add(ast);\n+            if (this.ignoreStringsRegexp == null || !this.ignoreStringsRegexp.matcher(text).find()) {\n+                ((List<DetailAST>)this.stringMap.computeIfAbsent(text, p0 -> new ArrayList())).add(detailAST);\n             }\n         }\n     }\n     \n-    private boolean isInIgnoreOccurrenceContext(final DetailAST ast) {\n-        boolean isInIgnoreOccurrenceContext = false;\n-        for (DetailAST token = ast; token != null; token = token.getParent()) {\n-            final int type = token.getType();\n-            if (this.ignoreOccurrenceContext.get(type)) {\n-                isInIgnoreOccurrenceContext = true;\n+    private boolean isInIgnoreOccurrenceContext(final DetailAST detailAST) {\n+        boolean b = false;\n+        for (DetailAST parent = detailAST; parent != null; parent = parent.getParent()) {\n+            if (this.ignoreOccurrenceContext.get(parent.getType())) {\n+                b = true;\n                 break;\n             }\n         }\n-        return isInIgnoreOccurrenceContext;\n+        return b;\n     }\n     \n-    public void beginTree(final DetailAST rootAST) {\n+    public void beginTree(final DetailAST detailAST) {\n         this.stringMap.clear();\n     }\n     \n-    public void finishTree(final DetailAST rootAST) {\n-        for (final Map.Entry<String, List<DetailAST>> stringListEntry : this.stringMap.entrySet()) {\n-            final List<DetailAST> hits = (List<DetailAST>)stringListEntry.getValue();\n-            if (hits.size() > this.allowedDuplicates) {\n-                final DetailAST firstFinding = (DetailAST)hits.get(0);\n-                final String recurringString = MultipleStringLiteralsCheck.ALL_NEW_LINES.matcher(stringListEntry.getKey()).replaceAll(\"\\\\\\\\n\");\n-                this.log(firstFinding, \"multiple.string.literal\", new Object[] { recurringString, Integer.valueOf(hits.size()) });\n+    public void finishTree(final DetailAST detailAST) {\n+        for (final Map.Entry entry : this.stringMap.entrySet()) {\n+            final List list = (List)entry.getValue();\n+            if (list.size() > this.allowedDuplicates) {\n+                this.log((DetailAST)list.get(0), \"multiple.string.literal\", new Object[] { MultipleStringLiteralsCheck.ALL_NEW_LINES.matcher((CharSequence)entry.getKey()).replaceAll(\"\\\\\\\\n\"), Integer.valueOf(list.size()) });\n             }\n         }\n     }\n     \n     static {\n         ALL_NEW_LINES = Pattern.compile(\"\\\\R\");\n     }\n"}]}
