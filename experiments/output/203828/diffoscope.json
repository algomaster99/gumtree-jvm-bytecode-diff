{"diffoscope-json-version": 1, "source1": "first/BHSDCodec.class", "source2": "second/BHSDCodec.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,11 +1,10 @@\n \n package org.apache.commons.compress.harmony.pack200;\n \n-import java.util.List;\n import java.util.ArrayList;\n import org.apache.commons.compress.utils.ExactMath;\n import java.io.EOFException;\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.Arrays;\n \n@@ -17,20 +16,20 @@\n     private final int l;\n     private final int s;\n     private long cardinality;\n     private final long smallest;\n     private final long largest;\n     private final long[] powers;\n     \n-    public BHSDCodec(final int b, final int h) {\n-        this(b, h, 0, 0);\n+    public BHSDCodec(final int n, final int n2) {\n+        this(n, n2, 0, 0);\n     }\n     \n-    public BHSDCodec(final int b, final int h, final int s) {\n-        this(b, h, s, 0);\n+    public BHSDCodec(final int n, final int n2, final int n3) {\n+        this(n, n2, n3, 0);\n     }\n     \n     public BHSDCodec(final int b, final int h, final int s, final int d) {\n         if (b < 1 || b > 5) {\n             throw new IllegalArgumentException(\"1<=b<=5\");\n         }\n         if (h < 1 || h > 256) {\n@@ -57,150 +56,149 @@\n             this.cardinality = b * 255 + 1;\n         }\n         else {\n             this.cardinality = (long)((long)(this.l * (1.0 - Math.pow(h, b)) / (1 - h)) + Math.pow(h, b));\n         }\n         this.smallest = this.calculateSmallest();\n         this.largest = this.calculateLargest();\n-        Arrays.setAll(this.powers = new long[b], c -> (long)Math.pow(h, c));\n+        Arrays.setAll(this.powers = new long[b], n3 -> (long)Math.pow(n, n3));\n     }\n     \n     public long cardinality() {\n         return this.cardinality;\n     }\n     \n-    public int decode(final InputStream in) throws IOException, Pack200Exception {\n+    public int decode(final InputStream inputStream) throws IOException, Pack200Exception {\n         if (this.d != 0) {\n             throw new Pack200Exception(\"Delta encoding used without passing in last value; this is a coding error\");\n         }\n-        return this.decode(in, 0L);\n+        return this.decode(inputStream, 0L);\n     }\n     \n-    public int decode(final InputStream in, final long last) throws IOException, Pack200Exception {\n-        int n = 0;\n-        long z = 0L;\n-        long x = 0L;\n+    public int decode(final InputStream inputStream, final long n) throws IOException, Pack200Exception {\n+        int n2 = 0;\n+        long n3 = 0L;\n+        long n4;\n         do {\n-            x = in.read();\n+            n4 = inputStream.read();\n             ++this.lastBandLength;\n-            z += x * this.powers[n];\n-            ++n;\n-        } while (x >= this.l && n < this.b);\n-        if (x == -1L) {\n+            n3 += n4 * this.powers[n2];\n+            ++n2;\n+        } while (n4 >= this.l && n2 < this.b);\n+        if (n4 == -1L) {\n             throw new EOFException(\"End of stream reached whilst decoding\");\n         }\n         if (this.isSigned()) {\n-            final int u = (1 << this.s) - 1;\n-            if ((z & (long)u) == u) {\n-                z = ~(z >>> this.s);\n+            final int n5 = (1 << this.s) - 1;\n+            if ((n3 & (long)n5) == n5) {\n+                n3 = ~(n3 >>> this.s);\n             }\n             else {\n-                z -= z >>> this.s;\n+                n3 -= n3 >>> this.s;\n             }\n         }\n         if (this.isDelta()) {\n-            z += last;\n+            n3 += n;\n         }\n-        return (int)z;\n+        return (int)n3;\n     }\n     \n-    public int[] decodeInts(final int n, final InputStream in) throws IOException, Pack200Exception {\n-        final int[] band = super.decodeInts(n, in);\n+    public int[] decodeInts(final int n, final InputStream inputStream) throws IOException, Pack200Exception {\n+        final int[] decodeInts = super.decodeInts(n, inputStream);\n         if (this.isDelta()) {\n-            for (int i = 0; i < band.length; ++i) {\n-                while (band[i] > this.largest) {\n-                    final int[] array = band;\n+            for (int i = 0; i < decodeInts.length; ++i) {\n+                while (decodeInts[i] > this.largest) {\n+                    final int[] array = decodeInts;\n                     final int n2 = i;\n                     array[n2] -= this.cardinality;\n                 }\n-                while (band[i] < this.smallest) {\n-                    band[i] = ExactMath.add(band[i], this.cardinality);\n+                while (decodeInts[i] < this.smallest) {\n+                    decodeInts[i] = ExactMath.add(decodeInts[i], this.cardinality);\n                 }\n             }\n         }\n-        return band;\n+        return decodeInts;\n     }\n     \n-    public int[] decodeInts(final int n, final InputStream in, final int firstValue) throws IOException, Pack200Exception {\n-        final int[] band = super.decodeInts(n, in, firstValue);\n+    public int[] decodeInts(final int n, final InputStream inputStream, final int n2) throws IOException, Pack200Exception {\n+        final int[] decodeInts = super.decodeInts(n, inputStream, n2);\n         if (this.isDelta()) {\n-            for (int i = 0; i < band.length; ++i) {\n-                while (band[i] > this.largest) {\n-                    final int[] array = band;\n-                    final int n2 = i;\n-                    array[n2] -= this.cardinality;\n+            for (int i = 0; i < decodeInts.length; ++i) {\n+                while (decodeInts[i] > this.largest) {\n+                    final int[] array = decodeInts;\n+                    final int n3 = i;\n+                    array[n3] -= this.cardinality;\n                 }\n-                while (band[i] < this.smallest) {\n-                    band[i] = ExactMath.add(band[i], this.cardinality);\n+                while (decodeInts[i] < this.smallest) {\n+                    decodeInts[i] = ExactMath.add(decodeInts[i], this.cardinality);\n                 }\n             }\n         }\n-        return band;\n+        return decodeInts;\n     }\n     \n-    public boolean encodes(final long value) {\n-        return value >= this.smallest && value <= this.largest;\n+    public boolean encodes(final long n) {\n+        return n >= this.smallest && n <= this.largest;\n     }\n     \n-    public byte[] encode(final int value, final int last) throws Pack200Exception {\n-        if (!this.encodes(value)) {\n-            throw new Pack200Exception(\"The codec \" + this + \" does not encode the value \" + value);\n+    public byte[] encode(final int i, final int n) throws Pack200Exception {\n+        if (!this.encodes(i)) {\n+            throw new Pack200Exception(\"The codec \" + this + \" does not encode the value \" + i);\n         }\n-        long z = (long)value;\n+        long n2 = (long)i;\n         if (this.isDelta()) {\n-            z -= last;\n+            n2 -= n;\n         }\n         if (this.isSigned()) {\n-            if (z < -2147483648L) {\n-                z += 4294967296L;\n+            if (n2 < -2147483648L) {\n+                n2 += 4294967296L;\n             }\n-            else if (z > 2147483647L) {\n-                z -= 4294967296L;\n+            else if (n2 > 2147483647L) {\n+                n2 -= 4294967296L;\n             }\n-            if (z < 0L) {\n-                z = (-z << this.s) - 1L;\n+            if (n2 < 0L) {\n+                n2 = (-n2 << this.s) - 1L;\n             }\n             else if (this.s == 1) {\n-                z <<= this.s;\n+                n2 <<= this.s;\n             }\n             else {\n-                z += (z - z % 3L) / 3L;\n+                n2 += (n2 - n2 % 3L) / 3L;\n             }\n         }\n-        else if (z < 0L) {\n-            z += Math.min(this.cardinality, 4294967296L);\n+        else if (n2 < 0L) {\n+            n2 += Math.min(this.cardinality, 4294967296L);\n         }\n-        if (z < 0L) {\n+        if (n2 < 0L) {\n             throw new Pack200Exception(\"unable to encode\");\n         }\n-        final List<Byte> byteList = new ArrayList<Byte>();\n-        for (int n = 0; n < this.b; ++n) {\n-            long byteN;\n-            if (z < this.l) {\n-                byteN = z;\n+        final ArrayList list = new ArrayList();\n+        for (int j = 0; j < this.b; ++j) {\n+            long n3;\n+            if (n2 < this.l) {\n+                n3 = n2;\n             }\n             else {\n-                for (byteN = z % this.h; byteN < this.l; byteN += this.h) {}\n+                for (n3 = n2 % this.h; n3 < this.l; n3 += this.h) {}\n             }\n-            byteList.add(Byte.valueOf((byte)(int)byteN));\n-            if (byteN < this.l) {\n+            list.add(Byte.valueOf((byte)(int)n3));\n+            if (n3 < this.l) {\n                 break;\n             }\n-            z -= byteN;\n-            z /= this.h;\n+            n2 = (n2 - n3) / this.h;\n         }\n-        final byte[] bytes = new byte[byteList.size()];\n-        for (int i = 0; i < bytes.length; ++i) {\n-            bytes[i] = Byte.valueOf(byteList.get(i));\n+        final byte[] array = new byte[list.size()];\n+        for (int k = 0; k < array.length; ++k) {\n+            array[k] = (byte)list.get(k);\n         }\n-        return bytes;\n+        return array;\n     }\n     \n-    public byte[] encode(final int value) throws Pack200Exception {\n-        return this.encode(value, 0);\n+    public byte[] encode(final int n) throws Pack200Exception {\n+        return this.encode(n, 0);\n     }\n     \n     public boolean isDelta() {\n         return this.d != 0;\n     }\n     \n     public boolean isSigned() {\n@@ -209,69 +207,68 @@\n     \n     public long largest() {\n         return this.largest;\n     }\n     \n     private long calculateLargest() {\n         if (this.d == 1) {\n-            final BHSDCodec bh0 = new BHSDCodec(this.b, this.h);\n-            return bh0.largest();\n+            return new BHSDCodec(this.b, this.h).largest();\n         }\n-        long result;\n+        long b;\n         if (this.s == 0) {\n-            result = this.cardinality() - 1L;\n+            b = this.cardinality() - 1L;\n         }\n         else if (this.s == 1) {\n-            result = this.cardinality() / 2L - 1L;\n+            b = this.cardinality() / 2L - 1L;\n         }\n         else {\n             if (this.s != 2) {\n                 throw new Error(\"Unknown s value\");\n             }\n-            result = 3L * this.cardinality() / 4L - 1L;\n+            b = 3L * this.cardinality() / 4L - 1L;\n         }\n-        return Math.min(((this.s == 0) ? 4294967294L : 2147483647L) - 1L, result);\n+        return Math.min(((this.s == 0) ? 4294967294L : 2147483647L) - 1L, b);\n     }\n     \n     public long smallest() {\n         return this.smallest;\n     }\n     \n     private long calculateSmallest() {\n-        long result;\n+        long max;\n         if (this.d == 1 || !this.isSigned()) {\n             if (this.cardinality >= 4294967296L) {\n-                result = -2147483648L;\n+                max = -2147483648L;\n             }\n             else {\n-                result = 0L;\n+                max = 0L;\n             }\n         }\n         else {\n-            result = Math.max(-2147483648L, -this.cardinality() / (long)(1 << this.s));\n+            max = Math.max(-2147483648L, -this.cardinality() / (long)(1 << this.s));\n         }\n-        return result;\n+        return max;\n     }\n     \n     public String toString() {\n-        final StringBuilder buffer = new StringBuilder(11);\n-        buffer.append('(');\n-        buffer.append(this.b);\n-        buffer.append(',');\n-        buffer.append(this.h);\n+        final StringBuilder sb = new StringBuilder(11);\n+        sb.append('(');\n+        sb.append(this.b);\n+        sb.append(',');\n+        sb.append(this.h);\n         if (this.s != 0 || this.d != 0) {\n-            buffer.append(',');\n-            buffer.append(this.s);\n+            sb.append(',');\n+            sb.append(this.s);\n         }\n         if (this.d != 0) {\n-            buffer.append(',');\n-            buffer.append(this.d);\n+            sb.append(',');\n+            sb.append(this.d);\n         }\n-        buffer.append(')');\n-        return buffer.toString();\n+        sb.append(')');\n+        return sb.toString();\n     }\n     \n     public int getB() {\n         return this.b;\n     }\n     \n     public int getH() {\n@@ -284,16 +281,16 @@\n     \n     public int getL() {\n         return this.l;\n     }\n     \n     public boolean equals(final Object o) {\n         if (o instanceof BHSDCodec) {\n-            final BHSDCodec codec = (BHSDCodec)o;\n-            return codec.b == this.b && codec.h == this.h && codec.s == this.s && codec.d == this.d;\n+            final BHSDCodec bhsdCodec = (BHSDCodec)o;\n+            return bhsdCodec.b == this.b && bhsdCodec.h == this.h && bhsdCodec.s == this.s && bhsdCodec.d == this.d;\n         }\n         return false;\n     }\n     \n     public int hashCode() {\n         return ((this.b * 37 + this.h) * 37 + this.s) * 37 + this.d;\n     }\n"}]}
