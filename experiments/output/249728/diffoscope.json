{"diffoscope-json-version": 1, "source1": "first/Main.class", "source2": "second/Main.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -4,27 +4,27 @@\n import org.apache.commons.logging.LogFactory;\n import java.io.OutputStream;\n import java.nio.file.Path;\n import java.io.InputStream;\n import com.puppycrawl.tools.checkstyle.utils.ChainedPropertyUtil;\n import java.nio.file.Files;\n import java.nio.file.OpenOption;\n-import com.puppycrawl.tools.checkstyle.api.AuditListener;\n import com.puppycrawl.tools.checkstyle.api.RootModule;\n import java.util.Properties;\n+import com.puppycrawl.tools.checkstyle.api.AuditListener;\n import com.puppycrawl.tools.checkstyle.api.Configuration;\n import java.util.logging.Handler;\n import java.util.logging.Filter;\n import java.util.logging.Level;\n import java.util.logging.ConsoleHandler;\n import java.util.logging.Logger;\n import com.puppycrawl.tools.checkstyle.utils.XpathUtil;\n import java.util.Iterator;\n-import java.util.regex.Pattern;\n import java.util.Collection;\n+import java.util.regex.Pattern;\n import java.util.LinkedList;\n import java.io.PrintStream;\n import java.io.File;\n import java.util.function.Consumer;\n import java.util.Objects;\n import java.util.List;\n import java.io.IOException;\n@@ -40,263 +40,247 @@\n     private static final Log LOG;\n     private static final int EXIT_WITH_INVALID_USER_INPUT_CODE = -1;\n     private static final int EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE = -2;\n     \n     private Main() {\n     }\n     \n-    public static void main(final String... args) throws IOException {\n+    public static void main(final String... array) throws IOException {\n         final Main.CliOptions cliOptions = new Main.CliOptions();\n         final CommandLine commandLine = new CommandLine((Object)cliOptions);\n         commandLine.setUsageHelpWidth(100);\n         commandLine.setCaseInsensitiveEnumValuesAllowed(true);\n-        int exitStatus = 0;\n-        int errorCounter = 0;\n+        int status = 0;\n+        int execute = 0;\n         try {\n-            final CommandLine.ParseResult parseResult = commandLine.parseArgs(args);\n-            if (parseResult.isVersionHelpRequested()) {\n+            final CommandLine.ParseResult args = commandLine.parseArgs(array);\n+            if (args.isVersionHelpRequested()) {\n                 System.out.println(getVersionString());\n             }\n-            else if (parseResult.isUsageHelpRequested()) {\n+            else if (args.isUsageHelpRequested()) {\n                 commandLine.usage(System.out);\n             }\n             else {\n-                exitStatus = (errorCounter = execute(parseResult, cliOptions));\n+                status = (execute = execute(args, cliOptions));\n             }\n         }\n         catch (final CommandLine.ParameterException ex) {\n-            exitStatus = -1;\n+            status = -1;\n             System.err.println(ex.getMessage());\n             System.err.println(\"Usage: checkstyle [OPTIONS]... FILES...\");\n             System.err.println(\"Try 'checkstyle --help' for more information.\");\n         }\n         catch (final CheckstyleException ex2) {\n-            exitStatus = -2;\n-            errorCounter = 1;\n+            status = -2;\n+            execute = 1;\n             ex2.printStackTrace();\n         }\n         finally {\n-            if (errorCounter > 0) {\n-                final LocalizedMessage errorCounterViolation = new LocalizedMessage(\"com.puppycrawl.tools.checkstyle.messages\", (Class)Main.class, \"Main.errorCounter\", new Object[] { String.valueOf(errorCounter) });\n-                System.err.println(errorCounterViolation.getMessage());\n+            if (execute > 0) {\n+                System.err.println(new LocalizedMessage(\"com.puppycrawl.tools.checkstyle.messages\", (Class)Main.class, \"Main.errorCounter\", new Object[] { String.valueOf(execute) }).getMessage());\n             }\n         }\n-        Runtime.getRuntime().exit(exitStatus);\n+        Runtime.getRuntime().exit(status);\n     }\n     \n     private static String getVersionString() {\n         return \"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion();\n     }\n     \n-    private static int execute(final CommandLine.ParseResult parseResult, final Main.CliOptions options) throws IOException, CheckstyleException {\n-        final List<File> filesToProcess = getFilesToProcess(options);\n-        final List<String> messages = options.validateCli(parseResult, (List)filesToProcess);\n-        final boolean hasMessages = !messages.isEmpty();\n-        int exitStatus;\n-        if (hasMessages) {\n-            final List<String> list = messages;\n+    private static int execute(final CommandLine.ParseResult parseResult, final Main.CliOptions cliOptions) throws IOException, CheckstyleException {\n+        final List<File> filesToProcess = getFilesToProcess(cliOptions);\n+        final List validateCli = cliOptions.validateCli(parseResult, (List)filesToProcess);\n+        int runCli;\n+        if (!validateCli.isEmpty()) {\n+            final List list = validateCli;\n             final PrintStream out = System.out;\n             Objects.requireNonNull(out);\n             list.forEach(out::println);\n-            exitStatus = -1;\n+            runCli = -1;\n         }\n         else {\n-            exitStatus = runCli(options, filesToProcess);\n-        }\n-        return exitStatus;\n-    }\n-    \n-    private static List<File> getFilesToProcess(final Main.CliOptions options) {\n-        final List<Pattern> patternsToExclude = options.getExclusions();\n-        final List<File> result = new LinkedList<File>();\n-        for (final File file : options.files) {\n-            result.addAll(listFiles(file, patternsToExclude));\n+            runCli = runCli(cliOptions, filesToProcess);\n         }\n-        return result;\n+        return runCli;\n     }\n     \n-    private static List<File> listFiles(final File node, final List<Pattern> patternsToExclude) {\n-        final List<File> result = new LinkedList<File>();\n-        if (node.canRead() && !isPathExcluded(node.getAbsolutePath(), patternsToExclude)) {\n-            if (node.isDirectory()) {\n-                final File[] files = node.listFiles();\n-                if (files != null) {\n-                    for (final File element : files) {\n-                        result.addAll(listFiles(element, patternsToExclude));\n+    private static List<File> getFilesToProcess(final Main.CliOptions cliOptions) {\n+        final List exclusions = cliOptions.getExclusions();\n+        final LinkedList list = new LinkedList();\n+        final Iterator iterator = cliOptions.files.iterator();\n+        while (iterator.hasNext()) {\n+            list.addAll(listFiles(iterator.next(), (List<Pattern>)exclusions));\n+        }\n+        return list;\n+    }\n+    \n+    private static List<File> listFiles(final File file, final List<Pattern> list) {\n+        final LinkedList list2 = new LinkedList();\n+        if (file.canRead() && !isPathExcluded(file.getAbsolutePath(), list)) {\n+            if (file.isDirectory()) {\n+                final File[] listFiles = file.listFiles();\n+                if (listFiles != null) {\n+                    final File[] array = listFiles;\n+                    for (int length = array.length, i = 0; i < length; ++i) {\n+                        list2.addAll(listFiles(array[i], list));\n                     }\n                 }\n             }\n-            else if (node.isFile()) {\n-                result.add(node);\n+            else if (file.isFile()) {\n+                list2.add(file);\n             }\n         }\n-        return result;\n+        return list2;\n     }\n     \n-    private static boolean isPathExcluded(final String path, final Iterable<Pattern> patternsToExclude) {\n-        boolean result = false;\n-        for (final Pattern pattern : patternsToExclude) {\n-            if (pattern.matcher(path).find()) {\n-                result = true;\n+    private static boolean isPathExcluded(final String input, final Iterable<Pattern> iterable) {\n+        boolean b = false;\n+        final Iterator<Pattern> iterator = iterable.iterator();\n+        while (iterator.hasNext()) {\n+            if (((Pattern)iterator.next()).matcher(input).find()) {\n+                b = true;\n                 break;\n             }\n         }\n-        return result;\n+        return b;\n     }\n     \n-    private static int runCli(final Main.CliOptions options, final List<File> filesToProcess) throws IOException, CheckstyleException {\n-        int result = 0;\n-        final boolean hasSuppressionLineColumnNumber = options.suppressionLineColumnNumber != null;\n-        if (options.printAst) {\n-            final File file = (File)filesToProcess.get(0);\n-            final String stringAst = AstTreeStringPrinter.printFileAst(file, JavaParser.Options.WITHOUT_COMMENTS);\n-            System.out.print(stringAst);\n-        }\n-        else if (Objects.nonNull(options.xpath)) {\n-            final String branch = XpathUtil.printXpathBranch(options.xpath, (File)filesToProcess.get(0));\n-            System.out.print(branch);\n-        }\n-        else if (options.printAstWithComments) {\n-            final File file = (File)filesToProcess.get(0);\n-            final String stringAst = AstTreeStringPrinter.printFileAst(file, JavaParser.Options.WITH_COMMENTS);\n-            System.out.print(stringAst);\n-        }\n-        else if (options.printJavadocTree) {\n-            final File file = (File)filesToProcess.get(0);\n-            final String stringAst = DetailNodeTreeStringPrinter.printFileAst(file);\n-            System.out.print(stringAst);\n-        }\n-        else if (options.printTreeWithJavadoc) {\n-            final File file = (File)filesToProcess.get(0);\n-            final String stringAst = AstTreeStringPrinter.printJavaAndJavadocTree(file);\n-            System.out.print(stringAst);\n-        }\n-        else if (hasSuppressionLineColumnNumber) {\n-            final File file = (File)filesToProcess.get(0);\n-            final String stringSuppressions = SuppressionsStringPrinter.printSuppressions(file, options.suppressionLineColumnNumber, options.tabWidth);\n-            System.out.print(stringSuppressions);\n+    private static int runCli(final Main.CliOptions cliOptions, final List<File> list) throws IOException, CheckstyleException {\n+        int runCheckstyle = 0;\n+        final boolean b = cliOptions.suppressionLineColumnNumber != null;\n+        if (cliOptions.printAst) {\n+            System.out.print(AstTreeStringPrinter.printFileAst((File)list.get(0), JavaParser.Options.WITHOUT_COMMENTS));\n+        }\n+        else if (Objects.nonNull(cliOptions.xpath)) {\n+            System.out.print(XpathUtil.printXpathBranch(cliOptions.xpath, (File)list.get(0)));\n+        }\n+        else if (cliOptions.printAstWithComments) {\n+            System.out.print(AstTreeStringPrinter.printFileAst((File)list.get(0), JavaParser.Options.WITH_COMMENTS));\n+        }\n+        else if (cliOptions.printJavadocTree) {\n+            System.out.print(DetailNodeTreeStringPrinter.printFileAst((File)list.get(0)));\n+        }\n+        else if (cliOptions.printTreeWithJavadoc) {\n+            System.out.print(AstTreeStringPrinter.printJavaAndJavadocTree((File)list.get(0)));\n+        }\n+        else if (b) {\n+            System.out.print(SuppressionsStringPrinter.printSuppressions((File)list.get(0), cliOptions.suppressionLineColumnNumber, cliOptions.tabWidth));\n         }\n         else {\n-            if (options.debug) {\n-                final Logger parentLogger = Logger.getLogger(Main.class.getName()).getParent();\n+            if (cliOptions.debug) {\n+                final Logger parent = Logger.getLogger(Main.class.getName()).getParent();\n                 final ConsoleHandler handler = new ConsoleHandler();\n                 handler.setLevel(Level.FINEST);\n                 handler.setFilter((Filter)new Main.OnlyCheckstyleLoggersFilter());\n-                parentLogger.addHandler(handler);\n-                parentLogger.setLevel(Level.FINEST);\n+                parent.addHandler(handler);\n+                parent.setLevel(Level.FINEST);\n             }\n             if (Main.LOG.isDebugEnabled()) {\n                 Main.LOG.debug((Object)\"Checkstyle debug logging enabled\");\n                 Main.LOG.debug(\"Running Checkstyle with version: \" + Main.class.getPackage().getImplementationVersion());\n             }\n-            result = runCheckstyle(options, filesToProcess);\n+            runCheckstyle = runCheckstyle(cliOptions, list);\n         }\n-        return result;\n+        return runCheckstyle;\n     }\n     \n-    private static int runCheckstyle(final Main.CliOptions options, final List<File> filesToProcess) throws CheckstyleException, IOException {\n-        Properties props;\n-        if (options.propertiesFile == null) {\n-            props = System.getProperties();\n+    private static int runCheckstyle(final Main.CliOptions cliOptions, final List<File> list) throws CheckstyleException, IOException {\n+        Properties properties;\n+        if (cliOptions.propertiesFile == null) {\n+            properties = System.getProperties();\n         }\n         else {\n-            props = loadProperties(options.propertiesFile);\n+            properties = loadProperties(cliOptions.propertiesFile);\n         }\n-        final ThreadModeSettings multiThreadModeSettings = new ThreadModeSettings(1, 1);\n+        final ThreadModeSettings threadModeSettings = new ThreadModeSettings(1, 1);\n         ConfigurationLoader.IgnoredModulesOptions ignoredModulesOptions;\n-        if (options.executeIgnoredModules) {\n+        if (cliOptions.executeIgnoredModules) {\n             ignoredModulesOptions = ConfigurationLoader.IgnoredModulesOptions.EXECUTE;\n         }\n         else {\n             ignoredModulesOptions = ConfigurationLoader.IgnoredModulesOptions.OMIT;\n         }\n-        final Configuration config = ConfigurationLoader.loadConfiguration(options.configurationFile, (PropertyResolver)new PropertiesExpander(props), ignoredModulesOptions, multiThreadModeSettings);\n-        final ClassLoader moduleClassLoader = Checker.class.getClassLoader();\n-        final RootModule rootModule = getRootModule(config.getName(), moduleClassLoader);\n-        int errorCounter;\n+        final Configuration loadConfiguration = ConfigurationLoader.loadConfiguration(cliOptions.configurationFile, (PropertyResolver)new PropertiesExpander(properties), ignoredModulesOptions, threadModeSettings);\n+        final ClassLoader classLoader = Checker.class.getClassLoader();\n+        final RootModule rootModule = getRootModule(loadConfiguration.getName(), classLoader);\n+        int process;\n         try {\n-            AuditListener listener;\n-            if (options.generateXpathSuppressionsFile) {\n-                final Configuration treeWalkerConfig = getTreeWalkerConfig(config);\n+            Object listener;\n+            if (cliOptions.generateXpathSuppressionsFile) {\n+                final Configuration treeWalkerConfig = getTreeWalkerConfig(loadConfiguration);\n                 if (treeWalkerConfig != null) {\n-                    final DefaultConfiguration moduleConfig = new DefaultConfiguration(XpathFileGeneratorAstFilter.class.getName());\n-                    moduleConfig.addProperty(\"tabWidth\", String.valueOf(options.tabWidth));\n-                    ((DefaultConfiguration)treeWalkerConfig).addChild((Configuration)moduleConfig);\n+                    final DefaultConfiguration defaultConfiguration = new DefaultConfiguration(XpathFileGeneratorAstFilter.class.getName());\n+                    defaultConfiguration.addProperty(\"tabWidth\", String.valueOf(cliOptions.tabWidth));\n+                    ((DefaultConfiguration)treeWalkerConfig).addChild((Configuration)defaultConfiguration);\n                 }\n-                listener = (AuditListener)new XpathFileGeneratorAuditListener(getOutputStream(options.outputPath), getOutputStreamOptions(options.outputPath));\n+                listener = new XpathFileGeneratorAuditListener(getOutputStream(cliOptions.outputPath), getOutputStreamOptions(cliOptions.outputPath));\n             }\n             else {\n-                listener = createListener(options.format, options.outputPath);\n+                listener = createListener(cliOptions.format, cliOptions.outputPath);\n             }\n-            rootModule.setModuleClassLoader(moduleClassLoader);\n-            rootModule.configure(config);\n-            rootModule.addListener(listener);\n-            errorCounter = rootModule.process((List)filesToProcess);\n+            rootModule.setModuleClassLoader(classLoader);\n+            rootModule.configure(loadConfiguration);\n+            rootModule.addListener((AuditListener)listener);\n+            process = rootModule.process((List)list);\n         }\n         finally {\n             rootModule.destroy();\n         }\n-        return errorCounter;\n+        return process;\n     }\n     \n     private static Properties loadProperties(final File file) throws CheckstyleException {\n         final Properties properties = new Properties();\n-        try (final InputStream stream = Files.newInputStream(file.toPath(), new OpenOption[0])) {\n-            properties.load(stream);\n+        try (final InputStream inputStream = Files.newInputStream(file.toPath(), new OpenOption[0])) {\n+            properties.load(inputStream);\n         }\n         catch (final IOException ex) {\n-            final LocalizedMessage loadPropertiesExceptionMessage = new LocalizedMessage(\"com.puppycrawl.tools.checkstyle.messages\", (Class)Main.class, \"Main.loadProperties\", new Object[] { file.getAbsolutePath() });\n-            throw new CheckstyleException(loadPropertiesExceptionMessage.getMessage(), (Throwable)ex);\n+            throw new CheckstyleException(new LocalizedMessage(\"com.puppycrawl.tools.checkstyle.messages\", (Class)Main.class, \"Main.loadProperties\", new Object[] { file.getAbsolutePath() }).getMessage(), (Throwable)ex);\n         }\n         return ChainedPropertyUtil.getResolvedProperties(properties);\n     }\n     \n-    private static RootModule getRootModule(final String name, final ClassLoader moduleClassLoader) throws CheckstyleException {\n-        final ModuleFactory factory = (ModuleFactory)new PackageObjectFactory(Checker.class.getPackage().getName(), moduleClassLoader);\n-        return (RootModule)factory.createModule(name);\n+    private static RootModule getRootModule(final String s, final ClassLoader classLoader) throws CheckstyleException {\n+        return (RootModule)((ModuleFactory)new PackageObjectFactory(Checker.class.getPackage().getName(), classLoader)).createModule(s);\n     }\n     \n-    private static Configuration getTreeWalkerConfig(final Configuration config) {\n-        Configuration result = null;\n-        final Configuration[] children2;\n-        final Configuration[] children = children2 = config.getChildren();\n-        for (final Configuration child : children2) {\n-            if (\"TreeWalker\".equals(child.getName())) {\n-                result = child;\n+    private static Configuration getTreeWalkerConfig(final Configuration configuration) {\n+        Configuration configuration2 = null;\n+        for (final Configuration configuration3 : configuration.getChildren()) {\n+            if (\"TreeWalker\".equals(configuration3.getName())) {\n+                configuration2 = configuration3;\n                 break;\n             }\n         }\n-        return result;\n+        return configuration2;\n     }\n     \n-    private static AuditListener createListener(final Main.OutputFormat format, final Path outputLocation) throws IOException {\n-        final OutputStream out = getOutputStream(outputLocation);\n-        final AbstractAutomaticBean.OutputStreamOptions closeOutputStreamOption = getOutputStreamOptions(outputLocation);\n-        return format.createListener(out, closeOutputStreamOption);\n+    private static AuditListener createListener(final Main.OutputFormat outputFormat, final Path path) throws IOException {\n+        return outputFormat.createListener(getOutputStream(path), getOutputStreamOptions(path));\n     }\n     \n-    private static OutputStream getOutputStream(final Path outputPath) throws IOException {\n-        OutputStream result;\n-        if (outputPath == null) {\n-            result = System.out;\n+    private static OutputStream getOutputStream(final Path path) throws IOException {\n+        OutputStream outputStream;\n+        if (path == null) {\n+            outputStream = System.out;\n         }\n         else {\n-            result = Files.newOutputStream(outputPath, new OpenOption[0]);\n+            outputStream = Files.newOutputStream(path, new OpenOption[0]);\n         }\n-        return result;\n+        return outputStream;\n     }\n     \n-    private static AbstractAutomaticBean.OutputStreamOptions getOutputStreamOptions(final Path outputPath) {\n-        AbstractAutomaticBean.OutputStreamOptions result;\n-        if (outputPath == null) {\n-            result = AbstractAutomaticBean.OutputStreamOptions.NONE;\n+    private static AbstractAutomaticBean.OutputStreamOptions getOutputStreamOptions(final Path path) {\n+        AbstractAutomaticBean.OutputStreamOptions outputStreamOptions;\n+        if (path == null) {\n+            outputStreamOptions = AbstractAutomaticBean.OutputStreamOptions.NONE;\n         }\n         else {\n-            result = AbstractAutomaticBean.OutputStreamOptions.CLOSE;\n+            outputStreamOptions = AbstractAutomaticBean.OutputStreamOptions.CLOSE;\n         }\n-        return result;\n+        return outputStreamOptions;\n     }\n     \n     static {\n         LOG = LogFactory.getLog((Class)Main.class);\n     }\n }\n"}]}
