{"diffoscope-json-version": 1, "source1": "first/UnusedImportsCheck.class", "source2": "second/UnusedImportsCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,16 +1,16 @@\n \n package com.puppycrawl.tools.checkstyle.checks.imports;\n \n import java.util.List;\n-import com.puppycrawl.tools.checkstyle.utils.JavadocUtil;\n+import java.util.function.Predicate;\n import com.puppycrawl.tools.checkstyle.checks.javadoc.JavadocTag;\n+import com.puppycrawl.tools.checkstyle.utils.JavadocUtil;\n import java.util.ArrayList;\n import com.puppycrawl.tools.checkstyle.api.TextBlock;\n-import com.puppycrawl.tools.checkstyle.api.FileContents;\n import java.util.Collection;\n import java.util.regex.Matcher;\n import com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n import com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n import com.puppycrawl.tools.checkstyle.api.DetailAST;\n import java.util.HashSet;\n import com.puppycrawl.tools.checkstyle.api.FullIdent;\n@@ -34,162 +34,160 @@\n     private UnusedImportsCheck.Frame currentFrame;\n     \n     public UnusedImportsCheck() {\n         this.imports = new HashSet<FullIdent>();\n         this.processJavadoc = true;\n     }\n     \n-    public void setProcessJavadoc(final boolean value) {\n-        this.processJavadoc = value;\n+    public void setProcessJavadoc(final boolean processJavadoc) {\n+        this.processJavadoc = processJavadoc;\n     }\n     \n-    public void beginTree(final DetailAST rootAST) {\n+    public void beginTree(final DetailAST detailAST) {\n         this.collect = false;\n         this.currentFrame = UnusedImportsCheck.Frame.compilationUnit();\n         this.imports.clear();\n     }\n     \n-    public void finishTree(final DetailAST rootAST) {\n+    public void finishTree(final DetailAST detailAST) {\n         this.currentFrame.finish();\n-        this.imports.stream().filter(imprt -> this.isUnusedImport(imprt.getText())).forEach(imprt -> this.log(imprt.getDetailAst(), \"import.unused\", new Object[] { imprt.getText() }));\n+        this.imports.stream().filter(fullIdent -> this.isUnusedImport(fullIdent.getText())).forEach(fullIdent2 -> this.log(fullIdent2.getDetailAst(), \"import.unused\", new Object[] { fullIdent2.getText() }));\n     }\n     \n     public int[] getDefaultTokens() {\n         return this.getRequiredTokens();\n     }\n     \n     public int[] getRequiredTokens() {\n         return new int[] { 58, 30, 152, 16, 157, 161, 154, 155, 14, 15, 9, 8, 10, 199, 203, 6, 7 };\n     }\n     \n     public int[] getAcceptableTokens() {\n         return this.getRequiredTokens();\n     }\n     \n-    public void visitToken(final DetailAST ast) {\n-        switch (ast.getType()) {\n+    public void visitToken(final DetailAST detailAST) {\n+        switch (detailAST.getType()) {\n             case 58: {\n                 if (this.collect) {\n-                    this.processIdent(ast);\n+                    this.processIdent(detailAST);\n                     break;\n                 }\n                 break;\n             }\n             case 30: {\n-                this.processImport(ast);\n+                this.processImport(detailAST);\n                 break;\n             }\n             case 152: {\n-                this.processStaticImport(ast);\n+                this.processStaticImport(detailAST);\n                 break;\n             }\n             case 6:\n             case 7: {\n                 this.currentFrame = this.currentFrame.push();\n                 break;\n             }\n             default: {\n                 this.collect = true;\n                 if (this.processJavadoc) {\n-                    this.collectReferencesFromJavadoc(ast);\n+                    this.collectReferencesFromJavadoc(detailAST);\n                     break;\n                 }\n                 break;\n             }\n         }\n     }\n     \n-    public void leaveToken(final DetailAST ast) {\n-        if (TokenUtil.isOfType(ast, new int[] { 6, 7 })) {\n+    public void leaveToken(final DetailAST detailAST) {\n+        if (TokenUtil.isOfType(detailAST, new int[] { 6, 7 })) {\n             this.currentFrame = this.currentFrame.pop();\n         }\n     }\n     \n-    private boolean isUnusedImport(final String imprt) {\n-        final Matcher javaLangPackageMatcher = UnusedImportsCheck.JAVA_LANG_PACKAGE_PATTERN.matcher(imprt);\n-        return !this.currentFrame.isReferencedType(CommonUtil.baseClassName(imprt)) || javaLangPackageMatcher.matches();\n+    private boolean isUnusedImport(final String input) {\n+        final Matcher matcher = UnusedImportsCheck.JAVA_LANG_PACKAGE_PATTERN.matcher(input);\n+        return !this.currentFrame.isReferencedType(CommonUtil.baseClassName(input)) || matcher.matches();\n     }\n     \n-    private void processIdent(final DetailAST ast) {\n-        final DetailAST parent = ast.getParent();\n-        final int parentType = parent.getType();\n-        final boolean isPossibleDotClassOrInMethod = parentType == 59 || parentType == 9;\n-        final boolean isQualifiedIdent = parentType == 59 && !TokenUtil.isOfType(ast.getPreviousSibling(), new int[] { 59 }) && ast.getNextSibling() != null;\n-        if (TokenUtil.isTypeDeclaration(parentType)) {\n-            this.currentFrame.addDeclaredType(ast.getText());\n+    private void processIdent(final DetailAST detailAST) {\n+        final int type = detailAST.getParent().getType();\n+        final boolean b = type == 59 || type == 9;\n+        final boolean b2 = type == 59 && !TokenUtil.isOfType(detailAST.getPreviousSibling(), new int[] { 59 }) && detailAST.getNextSibling() != null;\n+        if (TokenUtil.isTypeDeclaration(type)) {\n+            this.currentFrame.addDeclaredType(detailAST.getText());\n         }\n-        else if (!isPossibleDotClassOrInMethod || isQualifiedIdent) {\n-            this.currentFrame.addReferencedType(ast.getText());\n+        else if (!b || b2) {\n+            this.currentFrame.addReferencedType(detailAST.getText());\n         }\n     }\n     \n-    private void processImport(final DetailAST ast) {\n-        final FullIdent name = FullIdent.createFullIdentBelow(ast);\n-        if (!name.getText().endsWith(\".*\")) {\n-            this.imports.add(name);\n+    private void processImport(final DetailAST detailAST) {\n+        final FullIdent fullIdentBelow = FullIdent.createFullIdentBelow(detailAST);\n+        if (!fullIdentBelow.getText().endsWith(\".*\")) {\n+            this.imports.add(fullIdentBelow);\n         }\n     }\n     \n-    private void processStaticImport(final DetailAST ast) {\n-        final FullIdent name = FullIdent.createFullIdent(ast.getFirstChild().getNextSibling());\n-        if (!name.getText().endsWith(\".*\")) {\n-            this.imports.add(name);\n+    private void processStaticImport(final DetailAST detailAST) {\n+        final FullIdent fullIdent = FullIdent.createFullIdent(detailAST.getFirstChild().getNextSibling());\n+        if (!fullIdent.getText().endsWith(\".*\")) {\n+            this.imports.add(fullIdent);\n         }\n     }\n     \n-    private void collectReferencesFromJavadoc(final DetailAST ast) {\n-        final FileContents contents = this.getFileContents();\n-        final int lineNo = ast.getLineNo();\n-        final TextBlock textBlock = contents.getJavadocBefore(lineNo);\n-        if (textBlock != null) {\n-            this.currentFrame.addReferencedTypes((Collection)collectReferencesFromJavadoc(textBlock));\n+    private void collectReferencesFromJavadoc(final DetailAST detailAST) {\n+        final TextBlock javadocBefore = this.getFileContents().getJavadocBefore(detailAST.getLineNo());\n+        if (javadocBefore != null) {\n+            this.currentFrame.addReferencedTypes((Collection)collectReferencesFromJavadoc(javadocBefore));\n         }\n     }\n     \n     private static Set<String> collectReferencesFromJavadoc(final TextBlock textBlock) {\n-        final List<JavadocTag> tags = new ArrayList<JavadocTag>();\n-        tags.addAll(getValidTags(textBlock, JavadocUtil.JavadocTagType.INLINE));\n-        tags.addAll(getValidTags(textBlock, JavadocUtil.JavadocTagType.BLOCK));\n-        final Set<String> references = new HashSet<String>();\n-        tags.stream().filter(JavadocTag::canReferenceImports).forEach(tag -> references.addAll(processJavadocTag(tag)));\n-        return references;\n+        final ArrayList list = new ArrayList();\n+        list.addAll(getValidTags(textBlock, JavadocUtil.JavadocTagType.INLINE));\n+        list.addAll(getValidTags(textBlock, JavadocUtil.JavadocTagType.BLOCK));\n+        final HashSet set = new HashSet();\n+        list.stream().filter(JavadocTag::canReferenceImports).forEach(javadocTag -> set2.addAll(processJavadocTag(javadocTag)));\n+        return set;\n     }\n     \n-    private static List<JavadocTag> getValidTags(final TextBlock cmt, final JavadocUtil.JavadocTagType tagType) {\n-        return JavadocUtil.getJavadocTags(cmt, tagType).getValidTags();\n+    private static List<JavadocTag> getValidTags(final TextBlock textBlock, final JavadocUtil.JavadocTagType javadocTagType) {\n+        return JavadocUtil.getJavadocTags(textBlock, javadocTagType).getValidTags();\n     }\n     \n-    private static Set<String> processJavadocTag(final JavadocTag tag) {\n-        final Set<String> references = new HashSet<String>();\n-        final String identifier = tag.getFirstArg();\n-        for (final Pattern pattern : new Pattern[] { UnusedImportsCheck.FIRST_CLASS_NAME, UnusedImportsCheck.ARGUMENT_NAME }) {\n-            references.addAll(matchPattern(identifier, pattern));\n+    private static Set<String> processJavadocTag(final JavadocTag javadocTag) {\n+        final HashSet set = new HashSet();\n+        final String firstArg = javadocTag.getFirstArg();\n+        final Pattern[] array = { UnusedImportsCheck.FIRST_CLASS_NAME, UnusedImportsCheck.ARGUMENT_NAME };\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            set.addAll(matchPattern(firstArg, array[i]));\n         }\n-        return references;\n+        return set;\n     }\n     \n-    private static Set<String> matchPattern(final String identifier, final Pattern pattern) {\n-        final Set<String> references = new HashSet<String>();\n-        final Matcher matcher = pattern.matcher(identifier);\n+    private static Set<String> matchPattern(final String input, final Pattern pattern) {\n+        final HashSet set = new HashSet();\n+        final Matcher matcher = pattern.matcher(input);\n         while (matcher.find()) {\n-            references.add(topLevelType(matcher.group(1)));\n+            set.add(topLevelType(matcher.group(1)));\n         }\n-        return references;\n+        return set;\n     }\n     \n-    private static String topLevelType(final String type) {\n-        final int dotIndex = type.indexOf(46);\n-        String topLevelType;\n-        if (dotIndex == -1) {\n-            topLevelType = type;\n+    private static String topLevelType(final String s) {\n+        final int index = s.indexOf(46);\n+        String substring;\n+        if (index == -1) {\n+            substring = s;\n         }\n         else {\n-            topLevelType = type.substring(0, dotIndex);\n+            substring = s.substring(0, index);\n         }\n-        return topLevelType;\n+        return substring;\n     }\n     \n     static {\n         CLASS_NAME = CommonUtil.createPattern(\"((:?[\\\\p{L}_$][\\\\p{L}\\\\p{N}_$]*\\\\.)*[\\\\p{L}_$][\\\\p{L}\\\\p{N}_$]*)\");\n         FIRST_CLASS_NAME = CommonUtil.createPattern(\"^\" + String.valueOf((Object)UnusedImportsCheck.CLASS_NAME));\n         ARGUMENT_NAME = CommonUtil.createPattern(\"[(,]\\\\s*\" + UnusedImportsCheck.CLASS_NAME.pattern());\n         JAVA_LANG_PACKAGE_PATTERN = CommonUtil.createPattern(\"^java\\\\.lang\\\\.[a-zA-Z]+$\");\n"}]}
