{"diffoscope-json-version": 1, "source1": "first/MultiReadOnlySeekableByteChannel.class", "source2": "second/MultiReadOnlySeekableByteChannel.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -20,157 +20,160 @@\n \n public class MultiReadOnlySeekableByteChannel implements SeekableByteChannel\n {\n     private final List<SeekableByteChannel> channels;\n     private long globalPosition;\n     private int currentChannelIdx;\n     \n-    public MultiReadOnlySeekableByteChannel(final List<SeekableByteChannel> channels) {\n-        this.channels = Collections.unmodifiableList((List<? extends SeekableByteChannel>)new ArrayList<SeekableByteChannel>(Objects.requireNonNull(channels, \"channels must not be null\")));\n+    public MultiReadOnlySeekableByteChannel(final List<SeekableByteChannel> obj) {\n+        this.channels = Collections.unmodifiableList((List<? extends SeekableByteChannel>)new ArrayList<SeekableByteChannel>(Objects.requireNonNull(obj, \"channels must not be null\")));\n     }\n     \n     @Override\n-    public synchronized int read(final ByteBuffer dst) throws IOException {\n+    public synchronized int read(final ByteBuffer byteBuffer) throws IOException {\n         if (!this.isOpen()) {\n             throw new ClosedChannelException();\n         }\n-        if (!dst.hasRemaining()) {\n+        if (!byteBuffer.hasRemaining()) {\n             return 0;\n         }\n-        int totalBytesRead = 0;\n-        while (dst.hasRemaining() && this.currentChannelIdx < this.channels.size()) {\n-            final SeekableByteChannel currentChannel = (SeekableByteChannel)this.channels.get(this.currentChannelIdx);\n-            final int newBytesRead = currentChannel.read(dst);\n-            if (newBytesRead == -1) {\n+        int n = 0;\n+        while (byteBuffer.hasRemaining() && this.currentChannelIdx < this.channels.size()) {\n+            final SeekableByteChannel seekableByteChannel = (SeekableByteChannel)this.channels.get(this.currentChannelIdx);\n+            final int read = seekableByteChannel.read(byteBuffer);\n+            if (read == -1) {\n                 ++this.currentChannelIdx;\n             }\n             else {\n-                if (currentChannel.position() >= currentChannel.size()) {\n+                if (seekableByteChannel.position() >= seekableByteChannel.size()) {\n                     ++this.currentChannelIdx;\n                 }\n-                totalBytesRead += newBytesRead;\n+                n += read;\n             }\n         }\n-        if (totalBytesRead > 0) {\n-            this.globalPosition += totalBytesRead;\n-            return totalBytesRead;\n+        if (n > 0) {\n+            this.globalPosition += n;\n+            return n;\n         }\n         return -1;\n     }\n     \n     @Override\n     public void close() throws IOException {\n-        IOException first = null;\n-        for (final SeekableByteChannel ch : this.channels) {\n+        Throwable cause = null;\n+        for (final SeekableByteChannel seekableByteChannel : this.channels) {\n             try {\n-                ch.close();\n+                seekableByteChannel.close();\n             }\n             catch (final IOException ex) {\n-                if (first != null) {\n+                if (cause != null) {\n                     continue;\n                 }\n-                first = ex;\n+                cause = ex;\n             }\n         }\n-        if (first != null) {\n-            throw new IOException(\"failed to close wrapped channel\", first);\n+        if (cause != null) {\n+            throw new IOException(\"failed to close wrapped channel\", cause);\n         }\n     }\n     \n     @Override\n     public boolean isOpen() {\n-        for (final SeekableByteChannel ch : this.channels) {\n-            if (!ch.isOpen()) {\n+        final Iterator<SeekableByteChannel> iterator = this.channels.iterator();\n+        while (iterator.hasNext()) {\n+            if (!((SeekableByteChannel)iterator.next()).isOpen()) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n     @Override\n     public long position() {\n         return this.globalPosition;\n     }\n     \n-    public synchronized SeekableByteChannel position(final long channelNumber, final long relativeOffset) throws IOException {\n+    public synchronized SeekableByteChannel position(final long n, final long n2) throws IOException {\n         if (!this.isOpen()) {\n             throw new ClosedChannelException();\n         }\n-        long globalPosition = relativeOffset;\n-        for (int i = 0; i < channelNumber; ++i) {\n-            globalPosition += ((SeekableByteChannel)this.channels.get(i)).size();\n+        long n3 = n2;\n+        for (int n4 = 0; n4 < n; ++n4) {\n+            n3 += ((SeekableByteChannel)this.channels.get(n4)).size();\n         }\n-        return this.position(globalPosition);\n+        return this.position(n3);\n     }\n     \n     @Override\n     public long size() throws IOException {\n         if (!this.isOpen()) {\n             throw new ClosedChannelException();\n         }\n-        long acc = 0L;\n-        for (final SeekableByteChannel ch : this.channels) {\n-            acc += ch.size();\n+        long n = 0L;\n+        final Iterator<SeekableByteChannel> iterator = this.channels.iterator();\n+        while (iterator.hasNext()) {\n+            n += ((SeekableByteChannel)iterator.next()).size();\n         }\n-        return acc;\n+        return n;\n     }\n     \n     @Override\n-    public SeekableByteChannel truncate(final long size) {\n+    public SeekableByteChannel truncate(final long n) {\n         throw new NonWritableChannelException();\n     }\n     \n     @Override\n-    public int write(final ByteBuffer src) {\n+    public int write(final ByteBuffer byteBuffer) {\n         throw new NonWritableChannelException();\n     }\n     \n     @Override\n-    public synchronized SeekableByteChannel position(final long newPosition) throws IOException {\n-        if (newPosition < 0L) {\n-            throw new IOException(\"Negative position: \" + newPosition);\n+    public synchronized SeekableByteChannel position(final long n) throws IOException {\n+        if (n < 0L) {\n+            throw new IOException(\"Negative position: \" + n);\n         }\n         if (!this.isOpen()) {\n             throw new ClosedChannelException();\n         }\n-        this.globalPosition = newPosition;\n-        long pos = newPosition;\n+        this.globalPosition = n;\n+        long n2 = n;\n         for (int i = 0; i < this.channels.size(); ++i) {\n-            final SeekableByteChannel currentChannel = (SeekableByteChannel)this.channels.get(i);\n-            final long size = currentChannel.size();\n-            long newChannelPos;\n-            if (pos == -1L) {\n-                newChannelPos = 0L;\n+            final SeekableByteChannel seekableByteChannel = (SeekableByteChannel)this.channels.get(i);\n+            final long size = seekableByteChannel.size();\n+            long n3;\n+            if (n2 == -1L) {\n+                n3 = 0L;\n             }\n-            else if (pos <= size) {\n+            else if (n2 <= size) {\n                 this.currentChannelIdx = i;\n-                final long tmp = pos;\n-                pos = -1L;\n-                newChannelPos = tmp;\n+                final long n4 = n2;\n+                n2 = -1L;\n+                n3 = n4;\n             }\n             else {\n-                pos -= size;\n-                newChannelPos = size;\n+                n2 -= size;\n+                n3 = size;\n             }\n-            currentChannel.position(newChannelPos);\n+            seekableByteChannel.position(n3);\n         }\n         return this;\n     }\n     \n-    public static SeekableByteChannel forSeekableByteChannels(final SeekableByteChannel... channels) {\n-        if (((SeekableByteChannel[])Objects.requireNonNull(channels, \"channels must not be null\")).length == 1) {\n-            return channels[0];\n+    public static SeekableByteChannel forSeekableByteChannels(final SeekableByteChannel... array) {\n+        if (((SeekableByteChannel[])Objects.requireNonNull(array, \"channels must not be null\")).length == 1) {\n+            return array[0];\n         }\n-        return new MultiReadOnlySeekableByteChannel(Arrays.asList(channels));\n+        return new MultiReadOnlySeekableByteChannel(Arrays.asList(array));\n     }\n     \n-    public static SeekableByteChannel forFiles(final File... files) throws IOException {\n-        final List<SeekableByteChannel> channels = new ArrayList<SeekableByteChannel>();\n-        for (final File f : (File[])Objects.requireNonNull(files, \"files must not be null\")) {\n-            channels.add(Files.newByteChannel(f.toPath(), StandardOpenOption.READ));\n+    public static SeekableByteChannel forFiles(final File... obj) throws IOException {\n+        final ArrayList list = new ArrayList();\n+        final File[] array = (File[])Objects.requireNonNull(obj, \"files must not be null\");\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            list.add(Files.newByteChannel(array[i].toPath(), StandardOpenOption.READ));\n         }\n-        if (channels.size() == 1) {\n-            return channels.get(0);\n+        if (list.size() == 1) {\n+            return (SeekableByteChannel)list.get(0);\n         }\n-        return new MultiReadOnlySeekableByteChannel(channels);\n+        return new MultiReadOnlySeekableByteChannel(list);\n     }\n }\n"}]}
