{"diffoscope-json-version": 1, "source1": "first/XMLPropertyListConfiguration.class", "source2": "second/XMLPropertyListConfiguration.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -41,199 +41,195 @@\n     private static final int INDENT_SIZE = 4;\n     private static final String DATA_ENCODING = \"UTF-8\";\n     private FileLocator locator;\n     \n     public XMLPropertyListConfiguration() {\n     }\n     \n-    public XMLPropertyListConfiguration(final HierarchicalConfiguration<ImmutableNode> configuration) {\n-        super((HierarchicalConfiguration)configuration);\n+    public XMLPropertyListConfiguration(final HierarchicalConfiguration<ImmutableNode> hierarchicalConfiguration) {\n+        super((HierarchicalConfiguration)hierarchicalConfiguration);\n     }\n     \n-    XMLPropertyListConfiguration(final ImmutableNode root) {\n-        super((NodeModel)new InMemoryNodeModel(root));\n+    XMLPropertyListConfiguration(final ImmutableNode immutableNode) {\n+        super((NodeModel)new InMemoryNodeModel(immutableNode));\n     }\n     \n-    private void setPropertyDirect(final String key, final Object value) {\n+    private void setPropertyDirect(final String s, final Object o) {\n         this.setDetailEvents(false);\n         try {\n-            this.clearProperty(key);\n-            this.addPropertyDirect(key, value);\n+            this.clearProperty(s);\n+            this.addPropertyDirect(s, o);\n         }\n         finally {\n             this.setDetailEvents(true);\n         }\n     }\n     \n-    protected void setPropertyInternal(final String key, final Object value) {\n-        if (value instanceof byte[] || value instanceof List) {\n-            this.setPropertyDirect(key, value);\n+    protected void setPropertyInternal(final String s, final Object o) {\n+        if (o instanceof byte[] || o instanceof List) {\n+            this.setPropertyDirect(s, o);\n         }\n-        else if (value instanceof Object[]) {\n-            this.setPropertyDirect(key, Arrays.asList((Object[])value));\n+        else if (o instanceof Object[]) {\n+            this.setPropertyDirect(s, Arrays.asList((Object[])o));\n         }\n         else {\n-            super.setPropertyInternal(key, value);\n+            super.setPropertyInternal(s, o);\n         }\n     }\n     \n-    protected void addPropertyInternal(final String key, final Object value) {\n-        if (value instanceof byte[] || value instanceof List) {\n-            this.addPropertyDirect(key, value);\n+    protected void addPropertyInternal(final String s, final Object o) {\n+        if (o instanceof byte[] || o instanceof List) {\n+            this.addPropertyDirect(s, o);\n         }\n-        else if (value instanceof Object[]) {\n-            this.addPropertyDirect(key, (Object)Arrays.asList((Object[])value));\n+        else if (o instanceof Object[]) {\n+            this.addPropertyDirect(s, (Object)Arrays.asList((Object[])o));\n         }\n         else {\n-            super.addPropertyInternal(key, value);\n+            super.addPropertyInternal(s, o);\n         }\n     }\n     \n     public void initFileLocator(final FileLocator locator) {\n         this.locator = locator;\n     }\n     \n-    public void read(final Reader in) throws ConfigurationException {\n-        final EntityResolver resolver = (publicId, systemId) -> new InputSource(this.getClass().getClassLoader().getResourceAsStream(\"PropertyList-1.0.dtd\"));\n-        final XMLPropertyListConfiguration.XMLPropertyListHandler handler = new XMLPropertyListConfiguration.XMLPropertyListHandler(this);\n+    public void read(final Reader characterStream) throws ConfigurationException {\n+        final EntityResolver entityResolver = (p0, p1) -> new InputSource(this.getClass().getClassLoader().getResourceAsStream(\"PropertyList-1.0.dtd\"));\n+        final XMLPropertyListConfiguration.XMLPropertyListHandler contentHandler = new XMLPropertyListConfiguration.XMLPropertyListHandler(this);\n         try {\n-            final SAXParserFactory factory = SAXParserFactory.newInstance();\n-            factory.setValidating(true);\n-            final SAXParser parser = factory.newSAXParser();\n-            parser.getXMLReader().setEntityResolver(resolver);\n-            parser.getXMLReader().setContentHandler((ContentHandler)handler);\n-            parser.getXMLReader().parse(new InputSource(in));\n-            this.getNodeModel().mergeRoot(handler.getResultBuilder().createNode(), (String)null, (Map)null, (Object)null, (NodeKeyResolver)this);\n+            final SAXParserFactory instance = SAXParserFactory.newInstance();\n+            instance.setValidating(true);\n+            final SAXParser saxParser = instance.newSAXParser();\n+            saxParser.getXMLReader().setEntityResolver(entityResolver);\n+            saxParser.getXMLReader().setContentHandler((ContentHandler)contentHandler);\n+            saxParser.getXMLReader().parse(new InputSource(characterStream));\n+            this.getNodeModel().mergeRoot(contentHandler.getResultBuilder().createNode(), (String)null, (Map)null, (Object)null, (NodeKeyResolver)this);\n         }\n-        catch (final Exception e) {\n-            throw new ConfigurationException(\"Unable to parse the configuration file\", (Throwable)e);\n+        catch (final Exception ex) {\n+            throw new ConfigurationException(\"Unable to parse the configuration file\", (Throwable)ex);\n         }\n     }\n     \n     public void write(final Writer out) throws ConfigurationException {\n         if (this.locator == null) {\n             throw new ConfigurationException(\"Save operation not properly initialized! Do not call write(Writer) directly, but use a FileHandler to save a configuration.\");\n         }\n-        final PrintWriter writer = new PrintWriter(out);\n+        final PrintWriter printWriter = new PrintWriter(out);\n         if (this.locator.getEncoding() != null) {\n-            writer.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"\" + this.locator.getEncoding() + \"\\\"?>\");\n+            printWriter.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"\" + this.locator.getEncoding() + \"\\\"?>\");\n         }\n         else {\n-            writer.println(\"<?xml version=\\\"1.0\\\"?>\");\n+            printWriter.println(\"<?xml version=\\\"1.0\\\"?>\");\n         }\n-        writer.println(\"<!DOCTYPE plist SYSTEM \\\"file://localhost/System/Library/DTDs/PropertyList.dtd\\\">\");\n-        writer.println(\"<plist version=\\\"1.0\\\">\");\n-        this.printNode(writer, 1, (ImmutableNode)this.getNodeModel().getNodeHandler().getRootNode());\n-        writer.println(\"</plist>\");\n-        writer.flush();\n+        printWriter.println(\"<!DOCTYPE plist SYSTEM \\\"file://localhost/System/Library/DTDs/PropertyList.dtd\\\">\");\n+        printWriter.println(\"<plist version=\\\"1.0\\\">\");\n+        this.printNode(printWriter, 1, (ImmutableNode)this.getNodeModel().getNodeHandler().getRootNode());\n+        printWriter.println(\"</plist>\");\n+        printWriter.flush();\n     }\n     \n-    private void printNode(final PrintWriter out, final int indentLevel, final ImmutableNode node) {\n-        final String padding = StringUtils.repeat(\" \", indentLevel * 4);\n-        if (node.getNodeName() != null) {\n-            out.println(padding + \"<key>\" + StringEscapeUtils.escapeXml10(node.getNodeName()) + \"</key>\");\n+    private void printNode(final PrintWriter printWriter, final int n, final ImmutableNode immutableNode) {\n+        final String repeat = StringUtils.repeat(\" \", n * 4);\n+        if (immutableNode.getNodeName() != null) {\n+            printWriter.println(repeat + \"<key>\" + StringEscapeUtils.escapeXml10(immutableNode.getNodeName()) + \"</key>\");\n         }\n-        final List<ImmutableNode> children = node.getChildren();\n+        final List children = immutableNode.getChildren();\n         if (!children.isEmpty()) {\n-            out.println(padding + \"<dict>\");\n-            final Iterator<ImmutableNode> it = children.iterator();\n-            while (it.hasNext()) {\n-                final ImmutableNode child = (ImmutableNode)it.next();\n-                this.printNode(out, indentLevel + 1, child);\n-                if (it.hasNext()) {\n-                    out.println();\n+            printWriter.println(repeat + \"<dict>\");\n+            final Iterator iterator = children.iterator();\n+            while (iterator.hasNext()) {\n+                this.printNode(printWriter, n + 1, (ImmutableNode)iterator.next());\n+                if (iterator.hasNext()) {\n+                    printWriter.println();\n                 }\n             }\n-            out.println(padding + \"</dict>\");\n+            printWriter.println(repeat + \"</dict>\");\n         }\n-        else if (node.getValue() == null) {\n-            out.println(padding + \"<dict/>\");\n+        else if (immutableNode.getValue() == null) {\n+            printWriter.println(repeat + \"<dict/>\");\n         }\n         else {\n-            final Object value = node.getValue();\n-            this.printValue(out, indentLevel, value);\n+            this.printValue(printWriter, n, immutableNode.getValue());\n         }\n     }\n     \n-    private void printValue(final PrintWriter out, final int indentLevel, final Object value) {\n-        final String padding = StringUtils.repeat(\" \", indentLevel * 4);\n-        if (value instanceof Date) {\n+    private void printValue(final PrintWriter printWriter, final int n, final Object obj) {\n+        final String repeat = StringUtils.repeat(\" \", n * 4);\n+        if (obj instanceof Date) {\n             synchronized (XMLPropertyListConfiguration.PListNodeBuilder.access$000()) {\n-                out.println(padding + \"<date>\" + XMLPropertyListConfiguration.PListNodeBuilder.access$000().format((Date)value) + \"</date>\");\n+                printWriter.println(repeat + \"<date>\" + XMLPropertyListConfiguration.PListNodeBuilder.access$000().format((Date)obj) + \"</date>\");\n             }\n         }\n-        else if (value instanceof Calendar) {\n-            this.printValue(out, indentLevel, ((Calendar)value).getTime());\n+        else if (obj instanceof Calendar) {\n+            this.printValue(printWriter, n, ((Calendar)obj).getTime());\n         }\n-        else if (value instanceof Number) {\n-            if (value instanceof Double || value instanceof Float || value instanceof BigDecimal) {\n-                out.println(padding + \"<real>\" + value.toString() + \"</real>\");\n+        else if (obj instanceof Number) {\n+            if (obj instanceof Double || obj instanceof Float || obj instanceof BigDecimal) {\n+                printWriter.println(repeat + \"<real>\" + obj.toString() + \"</real>\");\n             }\n             else {\n-                out.println(padding + \"<integer>\" + value.toString() + \"</integer>\");\n+                printWriter.println(repeat + \"<integer>\" + obj.toString() + \"</integer>\");\n             }\n         }\n-        else if (value instanceof Boolean) {\n-            if ((boolean)value) {\n-                out.println(padding + \"<true/>\");\n+        else if (obj instanceof Boolean) {\n+            if ((boolean)obj) {\n+                printWriter.println(repeat + \"<true/>\");\n             }\n             else {\n-                out.println(padding + \"<false/>\");\n+                printWriter.println(repeat + \"<false/>\");\n             }\n         }\n-        else if (value instanceof List) {\n-            out.println(padding + \"<array>\");\n-            for (final Object o : (List)value) {\n-                this.printValue(out, indentLevel + 1, o);\n-            }\n-            out.println(padding + \"</array>\");\n-        }\n-        else if (value instanceof HierarchicalConfiguration) {\n-            final HierarchicalConfiguration<ImmutableNode> config = (HierarchicalConfiguration<ImmutableNode>)value;\n-            this.printNode(out, indentLevel, (ImmutableNode)config.getNodeModel().getNodeHandler().getRootNode());\n-        }\n-        else if (value instanceof ImmutableConfiguration) {\n-            out.println(padding + \"<dict>\");\n-            final ImmutableConfiguration config2 = (ImmutableConfiguration)value;\n-            final Iterator<String> it = config2.getKeys();\n-            while (it.hasNext()) {\n-                final String key = (String)it.next();\n-                final ImmutableNode node = new ImmutableNode.Builder().name(key).value(config2.getProperty(key)).create();\n-                this.printNode(out, indentLevel + 1, node);\n-                if (it.hasNext()) {\n-                    out.println();\n+        else if (obj instanceof List) {\n+            printWriter.println(repeat + \"<array>\");\n+            final Iterator iterator = ((List)obj).iterator();\n+            while (iterator.hasNext()) {\n+                this.printValue(printWriter, n + 1, iterator.next());\n+            }\n+            printWriter.println(repeat + \"</array>\");\n+        }\n+        else if (obj instanceof HierarchicalConfiguration) {\n+            this.printNode(printWriter, n, (ImmutableNode)((HierarchicalConfiguration)obj).getNodeModel().getNodeHandler().getRootNode());\n+        }\n+        else if (obj instanceof ImmutableConfiguration) {\n+            printWriter.println(repeat + \"<dict>\");\n+            final ImmutableConfiguration immutableConfiguration = (ImmutableConfiguration)obj;\n+            final Iterator keys = immutableConfiguration.getKeys();\n+            while (keys.hasNext()) {\n+                final String s = (String)keys.next();\n+                this.printNode(printWriter, n + 1, new ImmutableNode.Builder().name(s).value(immutableConfiguration.getProperty(s)).create());\n+                if (keys.hasNext()) {\n+                    printWriter.println();\n                 }\n             }\n-            out.println(padding + \"</dict>\");\n+            printWriter.println(repeat + \"</dict>\");\n         }\n-        else if (value instanceof Map) {\n-            final Map<String, Object> map = transformMap((Map<?, ?>)value);\n-            this.printValue(out, indentLevel, new MapConfiguration((Map)map));\n+        else if (obj instanceof Map) {\n+            this.printValue(printWriter, n, new MapConfiguration((Map)transformMap((Map<?, ?>)obj)));\n         }\n-        else if (value instanceof byte[]) {\n-            String base64;\n+        else if (obj instanceof byte[]) {\n+            String s2;\n             try {\n-                base64 = new String(Base64.encodeBase64((byte[])value), \"UTF-8\");\n+                s2 = new String(Base64.encodeBase64((byte[])obj), \"UTF-8\");\n             }\n-            catch (final UnsupportedEncodingException e) {\n-                throw new AssertionError((Object)e);\n+            catch (final UnsupportedEncodingException detailMessage) {\n+                throw new AssertionError((Object)detailMessage);\n             }\n-            out.println(padding + \"<data>\" + StringEscapeUtils.escapeXml10(base64) + \"</data>\");\n+            printWriter.println(repeat + \"<data>\" + StringEscapeUtils.escapeXml10(s2) + \"</data>\");\n         }\n-        else if (value != null) {\n-            out.println(padding + \"<string>\" + StringEscapeUtils.escapeXml10(String.valueOf(value)) + \"</string>\");\n+        else if (obj != null) {\n+            printWriter.println(repeat + \"<string>\" + StringEscapeUtils.escapeXml10(String.valueOf(obj)) + \"</string>\");\n         }\n         else {\n-            out.println(padding + \"<string/>\");\n+            printWriter.println(repeat + \"<string/>\");\n         }\n     }\n     \n-    private static Map<String, Object> transformMap(final Map<?, ?> src) {\n-        final Map<String, Object> dest = new HashMap<String, Object>();\n-        for (final Map.Entry<?, ?> e : src.entrySet()) {\n-            if (e.getKey() instanceof String) {\n-                dest.put(e.getKey(), (Object)e.getValue());\n+    private static Map<String, Object> transformMap(final Map<?, ?> map) {\n+        final HashMap hashMap = new HashMap();\n+        for (final Map.Entry entry : map.entrySet()) {\n+            if (entry.getKey() instanceof String) {\n+                hashMap.put(entry.getKey(), entry.getValue());\n             }\n         }\n-        return dest;\n+        return hashMap;\n     }\n }\n"}]}
