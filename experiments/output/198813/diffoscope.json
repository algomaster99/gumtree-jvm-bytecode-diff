{"diffoscope-json-version": 1, "source1": "first/Type.class", "source2": "second/Type.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,12 +1,11 @@\n \n package org.apache.bcel.generic;\n \n import java.lang.reflect.Method;\n-import java.util.List;\n import java.util.ArrayList;\n import org.apache.bcel.classfile.ClassFormatException;\n import org.apache.bcel.classfile.Utility;\n \n public abstract class Type\n {\n     @Deprecated\n@@ -28,29 +27,29 @@\n     public static final ObjectType STRINGBUFFER;\n     public static final ObjectType THROWABLE;\n     public static final Type[] NO_ARGS;\n     public static final ReferenceType NULL;\n     public static final Type UNKNOWN;\n     private static final ThreadLocal<Integer> consumed_chars;\n     \n-    protected Type(final byte t, final String s) {\n-        this.type = t;\n-        this.signature = s;\n+    protected Type(final byte type, final String signature) {\n+        this.type = type;\n+        this.signature = signature;\n     }\n     \n     @Override\n     public int hashCode() {\n         return this.type ^ this.signature.hashCode();\n     }\n     \n     @Override\n     public boolean equals(final Object o) {\n         if (o instanceof Type) {\n-            final Type t = (Type)o;\n-            return this.type == t.type && this.signature.equals(t.signature);\n+            final Type type = (Type)o;\n+            return this.type == type.type && this.signature.equals(type.signature);\n         }\n         return false;\n     }\n     \n     public String getSignature() {\n         return this.signature;\n     }\n@@ -82,202 +81,197 @@\n     }\n     \n     @Override\n     public String toString() {\n         return (this.equals(Type.NULL) || this.type >= 15) ? this.signature : Utility.signatureToString(this.signature, false);\n     }\n     \n-    public static String getMethodSignature(final Type return_type, final Type[] arg_types) {\n-        final StringBuilder buf = new StringBuilder(\"(\");\n-        if (arg_types != null) {\n-            for (final Type arg_type : arg_types) {\n-                buf.append(arg_type.getSignature());\n+    public static String getMethodSignature(final Type type, final Type[] array) {\n+        final StringBuilder sb = new StringBuilder(\"(\");\n+        if (array != null) {\n+            for (int length = array.length, i = 0; i < length; ++i) {\n+                sb.append(array[i].getSignature());\n             }\n         }\n-        buf.append(')');\n-        buf.append(return_type.getSignature());\n-        return buf.toString();\n+        sb.append(')');\n+        sb.append(type.getSignature());\n+        return sb.toString();\n     }\n     \n-    private static int unwrap(final ThreadLocal<Integer> tl) {\n-        return Integer.valueOf(tl.get());\n+    private static int unwrap(final ThreadLocal<Integer> threadLocal) {\n+        return Integer.valueOf(threadLocal.get());\n     }\n     \n-    private static void wrap(final ThreadLocal<Integer> tl, final int value) {\n-        tl.set(Integer.valueOf(value));\n+    private static void wrap(final ThreadLocal<Integer> threadLocal, final int i) {\n+        threadLocal.set(Integer.valueOf(i));\n     }\n     \n-    public static Type getType(final String signature) throws StringIndexOutOfBoundsException {\n-        final byte type = Utility.typeOfSignature(signature);\n-        if (type <= 12) {\n+    public static Type getType(final String s) throws StringIndexOutOfBoundsException {\n+        final byte typeOfSignature = Utility.typeOfSignature(s);\n+        if (typeOfSignature <= 12) {\n             wrap(Type.consumed_chars, 1);\n-            return (Type)BasicType.getType(type);\n+            return (Type)BasicType.getType(typeOfSignature);\n         }\n-        if (type == 13) {\n-            int dim = 0;\n+        if (typeOfSignature == 13) {\n+            int n = 0;\n             do {\n-                ++dim;\n-            } while (signature.charAt(dim) == '[');\n-            final Type t = getType(signature.substring(dim));\n-            final int _temp = unwrap(Type.consumed_chars) + dim;\n-            wrap(Type.consumed_chars, _temp);\n-            return (Type)new ArrayType(t, dim);\n-        }\n-        final String parsedSignature = Utility.typeSignatureToString(signature, false);\n-        wrap(Type.consumed_chars, parsedSignature.length() + 2);\n-        return (Type)ObjectType.getInstance(parsedSignature.replace('/', '.'));\n+                ++n;\n+            } while (s.charAt(n) == '[');\n+            final Type type = getType(s.substring(n));\n+            wrap(Type.consumed_chars, unwrap(Type.consumed_chars) + n);\n+            return (Type)new ArrayType(type, n);\n+        }\n+        final String typeSignatureToString = Utility.typeSignatureToString(s, false);\n+        wrap(Type.consumed_chars, typeSignatureToString.length() + 2);\n+        return (Type)ObjectType.getInstance(typeSignatureToString.replace('/', '.'));\n     }\n     \n-    public static Type getReturnType(final String signature) {\n+    public static Type getReturnType(final String str) {\n         try {\n-            final int index = signature.lastIndexOf(41) + 1;\n-            return getType(signature.substring(index));\n+            return getType(str.substring(str.lastIndexOf(41) + 1));\n         }\n-        catch (final StringIndexOutOfBoundsException e) {\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)e);\n+        catch (final StringIndexOutOfBoundsException ex) {\n+            throw new ClassFormatException(\"Invalid method signature: \" + str, (Throwable)ex);\n         }\n     }\n     \n-    public static Type[] getArgumentTypes(final String signature) {\n-        final List<Type> vec = new ArrayList<Type>();\n+    public static Type[] getArgumentTypes(final String s) {\n+        final ArrayList list = new ArrayList();\n         try {\n-            int index = signature.indexOf(40) + 1;\n-            if (index <= 0) {\n-                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n+            int n = s.indexOf(40) + 1;\n+            if (n <= 0) {\n+                throw new ClassFormatException(\"Invalid method signature: \" + s);\n             }\n-            while (signature.charAt(index) != ')') {\n-                vec.add(getType(signature.substring(index)));\n-                index += unwrap(Type.consumed_chars);\n+            while (s.charAt(n) != ')') {\n+                list.add(getType(s.substring(n)));\n+                n += unwrap(Type.consumed_chars);\n             }\n         }\n-        catch (final StringIndexOutOfBoundsException e) {\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)e);\n+        catch (final StringIndexOutOfBoundsException ex) {\n+            throw new ClassFormatException(\"Invalid method signature: \" + s, (Throwable)ex);\n         }\n-        final Type[] types = new Type[vec.size()];\n-        vec.toArray(types);\n-        return types;\n+        final Type[] array = new Type[list.size()];\n+        list.toArray(array);\n+        return array;\n     }\n     \n-    public static Type getType(final Class<?> cl) {\n-        if (cl == null) {\n+    public static Type getType(final Class<?> obj) {\n+        if (obj == null) {\n             throw new IllegalArgumentException(\"Class must not be null\");\n         }\n-        if (cl.isArray()) {\n-            return getType(cl.getName());\n+        if (obj.isArray()) {\n+            return getType(obj.getName());\n         }\n-        if (!cl.isPrimitive()) {\n-            return (Type)ObjectType.getInstance(cl.getName());\n+        if (!obj.isPrimitive()) {\n+            return (Type)ObjectType.getInstance(obj.getName());\n         }\n-        if (cl == Integer.TYPE) {\n+        if (obj == Integer.TYPE) {\n             return (Type)Type.INT;\n         }\n-        if (cl == Void.TYPE) {\n+        if (obj == Void.TYPE) {\n             return (Type)Type.VOID;\n         }\n-        if (cl == Double.TYPE) {\n+        if (obj == Double.TYPE) {\n             return (Type)Type.DOUBLE;\n         }\n-        if (cl == Float.TYPE) {\n+        if (obj == Float.TYPE) {\n             return (Type)Type.FLOAT;\n         }\n-        if (cl == Boolean.TYPE) {\n+        if (obj == Boolean.TYPE) {\n             return (Type)Type.BOOLEAN;\n         }\n-        if (cl == Byte.TYPE) {\n+        if (obj == Byte.TYPE) {\n             return (Type)Type.BYTE;\n         }\n-        if (cl == Short.TYPE) {\n+        if (obj == Short.TYPE) {\n             return (Type)Type.SHORT;\n         }\n-        if (cl == Byte.TYPE) {\n+        if (obj == Byte.TYPE) {\n             return (Type)Type.BYTE;\n         }\n-        if (cl == Long.TYPE) {\n+        if (obj == Long.TYPE) {\n             return (Type)Type.LONG;\n         }\n-        if (cl == Character.TYPE) {\n+        if (obj == Character.TYPE) {\n             return (Type)Type.CHAR;\n         }\n-        throw new IllegalStateException(\"Ooops, what primitive type is \" + cl);\n+        throw new IllegalStateException(\"Ooops, what primitive type is \" + obj);\n     }\n     \n-    public static Type[] getTypes(final Class<?>[] classes) {\n-        final Type[] ret = new Type[classes.length];\n-        for (int i = 0; i < ret.length; ++i) {\n-            ret[i] = getType(classes[i]);\n+    public static Type[] getTypes(final Class<?>[] array) {\n+        final Type[] array2 = new Type[array.length];\n+        for (int i = 0; i < array2.length; ++i) {\n+            array2[i] = getType(array[i]);\n         }\n-        return ret;\n+        return array2;\n     }\n     \n-    public static String getSignature(final Method meth) {\n+    public static String getSignature(final Method method) {\n         final StringBuilder sb = new StringBuilder(\"(\");\n-        final Class<?>[] parameterTypes;\n-        final Class<?>[] params = parameterTypes = meth.getParameterTypes();\n-        for (final Class<?> param : parameterTypes) {\n-            sb.append(getType(param).getSignature());\n+        final Class<?>[] parameterTypes = method.getParameterTypes();\n+        for (int length = parameterTypes.length, i = 0; i < length; ++i) {\n+            sb.append(getType(parameterTypes[i]).getSignature());\n         }\n         sb.append(\")\");\n-        sb.append(getType(meth.getReturnType()).getSignature());\n+        sb.append(getType(method.getReturnType()).getSignature());\n         return sb.toString();\n     }\n     \n-    static int size(final int coded) {\n-        return coded & 0x3;\n+    static int size(final int n) {\n+        return n & 0x3;\n     }\n     \n-    static int consumed(final int coded) {\n-        return coded >> 2;\n+    static int consumed(final int n) {\n+        return n >> 2;\n     }\n     \n-    static int encode(final int size, final int consumed) {\n-        return consumed << 2 | size;\n+    static int encode(final int n, final int n2) {\n+        return n2 << 2 | n;\n     }\n     \n-    static int getArgumentTypesSize(final String signature) {\n-        int res = 0;\n+    static int getArgumentTypesSize(final String s) {\n+        int n = 0;\n         try {\n-            int index = signature.indexOf(40) + 1;\n-            if (index <= 0) {\n-                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n+            int n2 = s.indexOf(40) + 1;\n+            if (n2 <= 0) {\n+                throw new ClassFormatException(\"Invalid method signature: \" + s);\n             }\n-            while (signature.charAt(index) != ')') {\n-                final int coded = getTypeSize(signature.substring(index));\n-                res += size(coded);\n-                index += consumed(coded);\n+            while (s.charAt(n2) != ')') {\n+                final int typeSize = getTypeSize(s.substring(n2));\n+                n += size(typeSize);\n+                n2 += consumed(typeSize);\n             }\n         }\n-        catch (final StringIndexOutOfBoundsException e) {\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)e);\n+        catch (final StringIndexOutOfBoundsException ex) {\n+            throw new ClassFormatException(\"Invalid method signature: \" + s, (Throwable)ex);\n         }\n-        return res;\n+        return n;\n     }\n     \n-    static int getTypeSize(final String signature) throws StringIndexOutOfBoundsException {\n-        final byte type = Utility.typeOfSignature(signature);\n-        if (type <= 12) {\n-            return encode(BasicType.getType(type).getSize(), 1);\n+    static int getTypeSize(final String str) throws StringIndexOutOfBoundsException {\n+        final byte typeOfSignature = Utility.typeOfSignature(str);\n+        if (typeOfSignature <= 12) {\n+            return encode(BasicType.getType(typeOfSignature).getSize(), 1);\n         }\n-        if (type == 13) {\n-            int dim = 0;\n+        if (typeOfSignature == 13) {\n+            int n = 0;\n             do {\n-                ++dim;\n-            } while (signature.charAt(dim) == '[');\n-            final int consumed = consumed(getTypeSize(signature.substring(dim)));\n-            return encode(1, dim + consumed);\n+                ++n;\n+            } while (str.charAt(n) == '[');\n+            return encode(1, n + consumed(getTypeSize(str.substring(n))));\n         }\n-        final int index = signature.indexOf(59);\n+        final int index = str.indexOf(59);\n         if (index < 0) {\n-            throw new ClassFormatException(\"Invalid signature: \" + signature);\n+            throw new ClassFormatException(\"Invalid signature: \" + str);\n         }\n         return encode(1, index + 1);\n     }\n     \n-    static int getReturnTypeSize(final String signature) {\n-        final int index = signature.lastIndexOf(41) + 1;\n-        return size(getTypeSize(signature.substring(index)));\n+    static int getReturnTypeSize(final String s) {\n+        return size(getTypeSize(s.substring(s.lastIndexOf(41) + 1)));\n     }\n     \n     void setSignature(final String signature) {\n         this.signature = signature;\n     }\n     \n     static {\n"}]}
