{"diffoscope-json-version": 1, "source1": "first/JavadocMethodCheck.class", "source2": "second/JavadocMethodCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,11 +1,10 @@\n \n package com.puppycrawl.tools.checkstyle.checks.javadoc;\n \n-import com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n import java.util.HashSet;\n import java.util.ListIterator;\n import com.puppycrawl.tools.checkstyle.api.FullIdent;\n import java.util.regex.Matcher;\n import java.util.regex.MatchResult;\n import java.util.ArrayList;\n import java.util.Iterator;\n@@ -13,14 +12,15 @@\n import java.util.Collection;\n import com.puppycrawl.tools.checkstyle.utils.AnnotationUtil;\n import com.puppycrawl.tools.checkstyle.utils.CheckUtil;\n import com.puppycrawl.tools.checkstyle.api.TextBlock;\n import com.puppycrawl.tools.checkstyle.api.FileContents;\n import com.puppycrawl.tools.checkstyle.api.DetailAST;\n import java.util.Arrays;\n+import com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n import java.util.Set;\n import com.puppycrawl.tools.checkstyle.checks.naming.AccessModifierOption;\n import java.util.regex.Pattern;\n import com.puppycrawl.tools.checkstyle.StatelessCheck;\n import com.puppycrawl.tools.checkstyle.api.AbstractCheck;\n \n @StatelessCheck\n@@ -45,14 +45,23 @@\n     private static final Pattern MATCH_JAVADOC_NOARG_CURLY;\n     private AccessModifierOption[] accessModifiers;\n     private boolean validateThrows;\n     private boolean allowMissingParamTags;\n     private boolean allowMissingReturnTag;\n     private Set<String> allowedAnnotations;\n     \n+    static {\n+        MATCH_JAVADOC_ARG = CommonUtil.createPattern(\"^\\\\s*(?>\\\\*|\\\\/\\\\*\\\\*)?\\\\s*@(throws|exception|param)\\\\s+(\\\\S+)\\\\s+\\\\S*\");\n+        MATCH_JAVADOC_ARG_MISSING_DESCRIPTION = CommonUtil.createPattern(\"^\\\\s*(?>\\\\*|\\\\/\\\\*\\\\*)?\\\\s*@(throws|exception|param)\\\\s+(\\\\S[^*]*)(?:(\\\\s+|\\\\*\\\\/))?\");\n+        MATCH_JAVADOC_MULTILINE_CONT = CommonUtil.createPattern(\"(\\\\*\\\\/|@|[^\\\\s\\\\*])\");\n+        MATCH_JAVADOC_NOARG = CommonUtil.createPattern(\"^\\\\s*(?>\\\\*|\\\\/\\\\*\\\\*)?\\\\s*@(return|see)\\\\s+\\\\S\");\n+        MATCH_JAVADOC_NOARG_MULTILINE_START = CommonUtil.createPattern(\"^\\\\s*(?>\\\\*|\\\\/\\\\*\\\\*)?\\\\s*@(return|see)\\\\s*$\");\n+        MATCH_JAVADOC_NOARG_CURLY = CommonUtil.createPattern(\"\\\\{\\\\s*@(inheritDoc)\\\\s*\\\\}\");\n+    }\n+    \n     public JavadocMethodCheck() {\n         this.accessModifiers = new AccessModifierOption[] { AccessModifierOption.PUBLIC, AccessModifierOption.PROTECTED, AccessModifierOption.PACKAGE, AccessModifierOption.PRIVATE };\n         this.allowedAnnotations = Set.of(\"Override\");\n     }\n     \n     public void setValidateThrows(final boolean value) {\n         this.validateThrows = value;\n@@ -101,15 +110,15 @@\n             }\n         }\n     }\n     \n     private boolean shouldCheck(final DetailAST ast) {\n         final AccessModifierOption surroundingAccessModifier = CheckUtil.getSurroundingAccessModifier(ast);\n         final AccessModifierOption accessModifier = CheckUtil.getAccessModifierFromModifiersToken(ast);\n-        return surroundingAccessModifier != null && Arrays.stream(this.accessModifiers).anyMatch(modifier -> modifier == surroundingAccessModifier) && Arrays.stream(this.accessModifiers).anyMatch(modifier -> modifier == accessModifier);\n+        return surroundingAccessModifier != null && Arrays.stream(this.accessModifiers).anyMatch(modifier -> modifier == accessModifierOption) && Arrays.stream(this.accessModifiers).anyMatch(modifier -> modifier == accessModifierOption2);\n     }\n     \n     private void checkComment(final DetailAST ast, final TextBlock comment) {\n         final List<JavadocTag> tags = getMethodTags(comment);\n         if (!this.hasShortCircuitTag(ast, tags)) {\n             if (ast.getType() == 161) {\n                 this.checkReturnTag(tags, ast.getLineNo(), true);\n@@ -261,26 +270,26 @@\n         DetailAST startNode;\n         for (startNode = ast; startNode.getType() == 59; startNode = startNode.getFirstChild()) {}\n         return startNode;\n     }\n     \n     private static boolean isInIgnoreBlock(final DetailAST methodBodyAst, final DetailAST throwAst) {\n         DetailAST ancestor;\n-        for (ancestor = throwAst.getParent(); ancestor != methodBodyAst && (ancestor.getType() != 95 || ancestor.findFirstToken(96) == null) && ancestor.getType() != 181 && ancestor.getType() != 6; ancestor = ancestor.getParent()) {\n+        for (ancestor = throwAst.getParent(); ancestor != methodBodyAst && ((ancestor.getType() != 95 || ancestor.findFirstToken(96) == null) && ancestor.getType() != 181) && ancestor.getType() != 6; ancestor = ancestor.getParent()) {\n             if (ancestor.getType() == 96 || ancestor.getType() == 97) {\n                 ancestor = ancestor.getParent();\n             }\n         }\n         return ancestor != methodBodyAst;\n     }\n     \n     private static List<JavadocMethodCheck.ExceptionInfo> combineExceptionInfo(final Collection<JavadocMethodCheck.ExceptionInfo> first, final Iterable<JavadocMethodCheck.ExceptionInfo> second) {\n         final List<JavadocMethodCheck.ExceptionInfo> result = new ArrayList<JavadocMethodCheck.ExceptionInfo>(first);\n         for (final JavadocMethodCheck.ExceptionInfo exceptionInfo : second) {\n-            if (result.stream().noneMatch(item -> isExceptionInfoSame(item, exceptionInfo))) {\n+            if (result.stream().noneMatch(item -> isExceptionInfoSame(item, info2))) {\n                 result.add(exceptionInfo);\n             }\n         }\n         return result;\n     }\n     \n     public static List<DetailAST> findTokensInAstByType(final DetailAST root, final int astType) {\n@@ -326,16 +335,16 @@\n             }\n             this.log(tag.getLineNo(), tag.getColumnNo(), \"javadoc.unusedTag\", new Object[] { \"@param\", arg1 });\n         }\n         if (!this.allowMissingParamTags && reportExpectedTags) {\n             for (final DetailAST param : params) {\n                 this.log(param, \"javadoc.expectedTag\", new Object[] { JavadocTagInfo.PARAM.getText(), param.getText() });\n             }\n-            for (DetailAST typeParam : typeParams) {\n-                this.log(typeParam, \"javadoc.expectedTag\", new Object[] { JavadocTagInfo.PARAM.getText(), \"<\" + typeParam.findFirstToken(58).getText() });\n+            for (final DetailAST typeParam : typeParams) {\n+                this.log(typeParam, \"javadoc.expectedTag\", new Object[] { JavadocTagInfo.PARAM.getText(), \"<\" + typeParam.findFirstToken(58).getText() + \">\" });\n             }\n         }\n     }\n     \n     private static boolean searchMatchingTypeParameter(final Iterable<DetailAST> typeParams, final String requiredTypeName) {\n         final Iterator<DetailAST> typeParamsIt = typeParams.iterator();\n         boolean found = false;\n@@ -432,17 +441,8 @@\n                 final String class1ShortName = class1.substring(class1.lastIndexOf(46) + 1);\n                 final String class2ShortName = class2.substring(class2.lastIndexOf(46) + 1);\n                 result = class1ShortName.equals(class2ShortName);\n             }\n         }\n         return result;\n     }\n-    \n-    static {\n-        MATCH_JAVADOC_ARG = CommonUtil.createPattern(\"^\\\\s*(?>\\\\*|\\\\/\\\\*\\\\*)?\\\\s*@(throws|exception|param)\\\\s+(\\\\S+)\\\\s+\\\\S*\");\n-        MATCH_JAVADOC_ARG_MISSING_DESCRIPTION = CommonUtil.createPattern(\"^\\\\s*(?>\\\\*|\\\\/\\\\*\\\\*)?\\\\s*@(throws|exception|param)\\\\s+(\\\\S[^*]*)(?:(\\\\s+|\\\\*\\\\/))?\");\n-        MATCH_JAVADOC_MULTILINE_CONT = CommonUtil.createPattern(\"(\\\\*\\\\/|@|[^\\\\s\\\\*])\");\n-        MATCH_JAVADOC_NOARG = CommonUtil.createPattern(\"^\\\\s*(?>\\\\*|\\\\/\\\\*\\\\*)?\\\\s*@(return|see)\\\\s+\\\\S\");\n-        MATCH_JAVADOC_NOARG_MULTILINE_START = CommonUtil.createPattern(\"^\\\\s*(?>\\\\*|\\\\/\\\\*\\\\*)?\\\\s*@(return|see)\\\\s*$\");\n-        MATCH_JAVADOC_NOARG_CURLY = CommonUtil.createPattern(\"\\\\{\\\\s*@(inheritDoc)\\\\s*\\\\}\");\n-    }\n }\n"}]}
