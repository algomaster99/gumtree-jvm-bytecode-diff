{"diffoscope-json-version": 1, "source1": "first/SevenZFile.class", "source2": "second/SevenZFile.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -37,14 +37,18 @@\n     private int currentEntryIndex;\n     private int currentFolderIndex;\n     private InputStream currentFolderInputStream;\n     private byte[] password;\n     private final ArrayList<InputStream> deferredBlockStreams;\n     static final byte[] sevenZSignature;\n     \n+    static {\n+        sevenZSignature = new byte[] { 55, 122, -68, -81, 39, 28 };\n+    }\n+    \n     public SevenZFile(final File filename, final byte[] password) throws IOException {\n         this(Files.newByteChannel(filename.toPath(), (Set<? extends OpenOption>)EnumSet.of(StandardOpenOption.READ), (FileAttribute<?>[])new FileAttribute[0]), filename.getAbsolutePath(), password, true);\n     }\n     \n     public SevenZFile(final SeekableByteChannel channel) throws IOException {\n         this(channel, \"unknown archive\", null);\n     }\n@@ -76,14 +80,17 @@\n             succeeded = true;\n         }\n         finally {\n             if (!succeeded && closeOnError) {\n                 this.channel.close();\n             }\n         }\n+        if (!succeeded && closeOnError) {\n+            this.channel.close();\n+        }\n     }\n     \n     public SevenZFile(final File filename) throws IOException {\n         this(filename, null);\n     }\n     \n     @Override\n@@ -95,14 +102,19 @@\n             finally {\n                 this.channel = null;\n                 if (this.password != null) {\n                     Arrays.fill(this.password, (byte)0);\n                 }\n                 this.password = null;\n             }\n+            this.channel = null;\n+            if (this.password != null) {\n+                Arrays.fill(this.password, (byte)0);\n+            }\n+            this.password = null;\n         }\n     }\n     \n     public SevenZArchiveEntry getNextEntry() throws IOException {\n         if (this.currentEntryIndex >= this.archive.files.length - 1) {\n             return null;\n         }\n@@ -155,19 +167,40 @@\n             return archive;\n         }\n         throw new IOException(\"Broken or unsupported archive: no Header\");\n     }\n     \n     private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\n         final StartHeader startHeader = new StartHeader();\n-        try (final DataInputStream dataInputStream = new DataInputStream((InputStream)new CRC32VerifyingInputStream((InputStream)new BoundedSeekableByteChannelInputStream(this.channel, 20L), 20L, startHeaderCrc))) {\n-            startHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\n-            startHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\n-            startHeader.nextHeaderCrc = (0xFFFFFFFFL & (long)Integer.reverseBytes(dataInputStream.readInt()));\n-            return startHeader;\n+        Throwable t = null;\n+        try {\n+            final DataInputStream dataInputStream = new DataInputStream((InputStream)new CRC32VerifyingInputStream((InputStream)new BoundedSeekableByteChannelInputStream(this.channel, 20L), 20L, startHeaderCrc));\n+            try {\n+                startHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\n+                startHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\n+                startHeader.nextHeaderCrc = (0xFFFFFFFFL & (long)Integer.reverseBytes(dataInputStream.readInt()));\n+                return startHeader;\n+            }\n+            finally {\n+                if (dataInputStream != null) {\n+                    dataInputStream.close();\n+                }\n+            }\n+        }\n+        finally {\n+            if (t == null) {\n+                final Throwable exception;\n+                t = exception;\n+            }\n+            else {\n+                final Throwable exception;\n+                if (t != exception) {\n+                    t.addSuppressed(exception);\n+                }\n+            }\n         }\n     }\n     \n     private void readHeader(final ByteBuffer header, final Archive archive) throws IOException {\n         int nid = getUnsignedByte(header);\n         if (nid == 2) {\n             this.readArchiveProperties(header);\n@@ -196,30 +229,50 @@\n             input.get(property);\n         }\n     }\n     \n     private ByteBuffer readEncodedHeader(final ByteBuffer header, final Archive archive, final byte[] password) throws IOException {\n         this.readStreamsInfo(header, archive);\n         final Folder folder = archive.folders[0];\n-        final int firstPackStreamIndex = 0;\n         final long folderOffset = 32L + archive.packPos + 0L;\n         this.channel.position(folderOffset);\n         InputStream inputStreamStack = (InputStream)new BoundedSeekableByteChannelInputStream(this.channel, archive.packSizes[0]);\n         for (final Coder coder : folder.getOrderedCoders()) {\n             if (coder.numInStreams != 1L || coder.numOutStreams != 1L) {\n                 throw new IOException(\"Multi input/output stream coders are not yet supported\");\n             }\n             inputStreamStack = Coders.addDecoder(this.fileName, inputStreamStack, folder.getUnpackSizeForCoder(coder), coder, password);\n         }\n         if (folder.hasCrc) {\n             inputStreamStack = (InputStream)new CRC32VerifyingInputStream(inputStreamStack, folder.getUnpackSize(), folder.crc);\n         }\n         final byte[] nextHeader = new byte[(int)folder.getUnpackSize()];\n-        try (final DataInputStream nextHeaderInputStream = new DataInputStream(inputStreamStack)) {\n-            nextHeaderInputStream.readFully(nextHeader);\n+        Throwable t = null;\n+        try {\n+            final DataInputStream nextHeaderInputStream = new DataInputStream(inputStreamStack);\n+            try {\n+                nextHeaderInputStream.readFully(nextHeader);\n+            }\n+            finally {\n+                if (nextHeaderInputStream != null) {\n+                    nextHeaderInputStream.close();\n+                }\n+            }\n+        }\n+        finally {\n+            if (t == null) {\n+                final Throwable exception;\n+                t = exception;\n+            }\n+            else {\n+                final Throwable exception;\n+                if (t != exception) {\n+                    t.addSuppressed(exception);\n+                }\n+            }\n         }\n         return ByteBuffer.wrap(nextHeader).order(ByteOrder.LITTLE_ENDIAN);\n     }\n     \n     private void readStreamsInfo(final ByteBuffer header, final Archive archive) throws IOException {\n         int nid = getUnsignedByte(header);\n         if (nid == 6) {\n@@ -283,15 +336,17 @@\n         for (int i = 0; i < (int)numFolders; ++i) {\n             folders[i] = this.readFolder(header);\n         }\n         nid = getUnsignedByte(header);\n         if (nid != 12) {\n             throw new IOException(\"Expected kCodersUnpackSize, got \" + nid);\n         }\n-        for (final Folder folder : folders) {\n+        Folder[] array;\n+        for (int length = (array = folders).length, l = 0; l < length; ++l) {\n+            final Folder folder = array[l];\n             folder.unpackSizes = new long[(int)folder.totalOutputStreams];\n             for (int j = 0; j < folder.totalOutputStreams; ++j) {\n                 folder.unpackSizes[j] = readUint64(header);\n             }\n         }\n         nid = getUnsignedByte(header);\n         if (nid == 10) {\n@@ -309,34 +364,40 @@\n         }\n         if (nid != 0) {\n             throw new IOException(\"Badly terminated UnpackInfo\");\n         }\n     }\n     \n     private void readSubStreamsInfo(final ByteBuffer header, final Archive archive) throws IOException {\n-        for (final Folder folder : archive.folders) {\n+        Folder[] folders;\n+        for (int length = (folders = archive.folders).length, l = 0; l < length; ++l) {\n+            final Folder folder = folders[l];\n             folder.numUnpackSubStreams = 1;\n         }\n         int totalUnpackStreams = archive.folders.length;\n         int nid = getUnsignedByte(header);\n         if (nid == 13) {\n             totalUnpackStreams = 0;\n-            for (final Folder folder2 : archive.folders) {\n+            Folder[] folders2;\n+            for (int length2 = (folders2 = archive.folders).length, n = 0; n < length2; ++n) {\n+                final Folder folder2 = folders2[n];\n                 final long numStreams = readUint64(header);\n                 folder2.numUnpackSubStreams = (int)numStreams;\n                 totalUnpackStreams += numStreams;\n             }\n             nid = getUnsignedByte(header);\n         }\n         final SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\n         subStreamsInfo.unpackSizes = new long[totalUnpackStreams];\n         subStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\n         subStreamsInfo.crcs = new long[totalUnpackStreams];\n         int nextUnpackStream = 0;\n-        for (final Folder folder3 : archive.folders) {\n+        Folder[] folders3;\n+        for (int length3 = (folders3 = archive.folders).length, n2 = 0; n2 < length3; ++n2) {\n+            final Folder folder3 = folders3[n2];\n             if (folder3.numUnpackSubStreams != 0) {\n                 long sum = 0L;\n                 if (nid == 9) {\n                     for (int i = 0; i < folder3.numUnpackSubStreams - 1; ++i) {\n                         final long size = readUint64(header);\n                         subStreamsInfo.unpackSizes[nextUnpackStream++] = size;\n                         sum += size;\n@@ -345,30 +406,34 @@\n                 subStreamsInfo.unpackSizes[nextUnpackStream++] = folder3.getUnpackSize() - sum;\n             }\n         }\n         if (nid == 9) {\n             nid = getUnsignedByte(header);\n         }\n         int numDigests = 0;\n-        for (final Folder folder4 : archive.folders) {\n+        Folder[] folders4;\n+        for (int length4 = (folders4 = archive.folders).length, n3 = 0; n3 < length4; ++n3) {\n+            final Folder folder4 = folders4[n3];\n             if (folder4.numUnpackSubStreams != 1 || !folder4.hasCrc) {\n                 numDigests += folder4.numUnpackSubStreams;\n             }\n         }\n         if (nid == 10) {\n             final BitSet hasMissingCrc = this.readAllOrBits(header, numDigests);\n             final long[] missingCrcs = new long[numDigests];\n             for (int j = 0; j < numDigests; ++j) {\n                 if (hasMissingCrc.get(j)) {\n                     missingCrcs[j] = (0xFFFFFFFFL & (long)header.getInt());\n                 }\n             }\n             int nextCrc = 0;\n             int nextMissingCrc = 0;\n-            for (final Folder folder5 : archive.folders) {\n+            Folder[] folders5;\n+            for (int length5 = (folders5 = archive.folders).length, n4 = 0; n4 < length5; ++n4) {\n+                final Folder folder5 = folders5[n4];\n                 if (folder5.numUnpackSubStreams == 1 && folder5.hasCrc) {\n                     subStreamsInfo.hasCrc.set(nextCrc, true);\n                     subStreamsInfo.crcs[nextCrc] = folder5.crc;\n                     ++nextCrc;\n                 }\n                 else {\n                     for (int k = 0; k < folder5.numUnpackSubStreams; ++k) {\n@@ -744,16 +809,37 @@\n         if (this.archive.files[this.currentEntryIndex].getSize() == 0L) {\n             return new ByteArrayInputStream(new byte[0]);\n         }\n         if (this.deferredBlockStreams.isEmpty()) {\n             throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n         }\n         while (this.deferredBlockStreams.size() > 1) {\n-            try (final InputStream stream = (InputStream)this.deferredBlockStreams.remove(0)) {\n-                IOUtils.skip(stream, Long.MAX_VALUE);\n+            Throwable t = null;\n+            try {\n+                final InputStream stream = (InputStream)this.deferredBlockStreams.remove(0);\n+                try {\n+                    IOUtils.skip(stream, Long.MAX_VALUE);\n+                }\n+                finally {\n+                    if (stream != null) {\n+                        stream.close();\n+                    }\n+                }\n+            }\n+            finally {\n+                if (t == null) {\n+                    final Throwable exception;\n+                    t = exception;\n+                }\n+                else {\n+                    final Throwable exception;\n+                    if (t != exception) {\n+                        t.addSuppressed(exception);\n+                    }\n+                }\n             }\n         }\n         return this.deferredBlockStreams.get(0);\n     }\n     \n     public int read(final byte[] b) throws IOException {\n         return this.read(b, 0, b.length);\n@@ -799,26 +885,22 @@\n             return 0L;\n         }\n         final int current = input.position();\n         final int maxSkip = input.remaining();\n         if (maxSkip < bytesToSkip) {\n             bytesToSkip = maxSkip;\n         }\n-        input.position();\n+        input.position(current + (int)bytesToSkip);\n         return bytesToSkip;\n     }\n     \n     private void readFully(final ByteBuffer buf) throws IOException {\n         buf.rewind();\n         IOUtils.readFully((ReadableByteChannel)this.channel, buf);\n         buf.flip();\n     }\n     \n     @Override\n     public String toString() {\n         return this.archive.toString();\n     }\n-    \n-    static {\n-        sevenZSignature = new byte[] { 55, 122, -68, -81, 39, 28 };\n-    }\n }\n"}]}
