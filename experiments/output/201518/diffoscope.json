{"diffoscope-json-version": 1, "source1": "first/UnixCrypt.class", "source2": "second/UnixCrypt.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -9,202 +9,176 @@\n     private static final int[] CON_SALT;\n     private static final int[] COV2CHAR;\n     private static final char[] SALT_CHARS;\n     private static final boolean[] SHIFT2;\n     private static final int[][] SKB;\n     private static final int[][] SPTRANS;\n     \n-    public static String crypt(final byte[] original) {\n-        return crypt(original, null);\n+    public static String crypt(final byte[] array) {\n+        return crypt(array, null);\n     }\n     \n-    public static String crypt(final byte[] original, String salt) {\n-        if (salt == null) {\n-            final ThreadLocalRandom randomGenerator = ThreadLocalRandom.current();\n-            final int numSaltChars = UnixCrypt.SALT_CHARS.length;\n-            salt = \"\" + UnixCrypt.SALT_CHARS[randomGenerator.nextInt(numSaltChars)] + UnixCrypt.SALT_CHARS[randomGenerator.nextInt(numSaltChars)];\n-        }\n-        else if (!salt.matches(\"^[./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz]{2,}$\")) {\n-            throw new IllegalArgumentException(\"Invalid salt value: \" + salt);\n-        }\n-        final StringBuilder buffer = new StringBuilder(\"             \");\n-        final char charZero = salt.charAt(0);\n-        final char charOne = salt.charAt(1);\n-        buffer.setCharAt();\n-        buffer.setCharAt();\n-        final int eSwap0 = UnixCrypt.CON_SALT[charZero];\n-        final int eSwap2 = UnixCrypt.CON_SALT[charOne] << 4;\n-        final byte[] key = new byte[8];\n-        for (int i = 0; i < key.length; ++i) {\n-            key[i] = 0;\n-        }\n-        for (int i = 0; i < key.length && i < original.length; ++i) {\n-            final int iChar = original[i];\n-            key[i] = (byte)(iChar << 1);\n-        }\n-        final int[] schedule = desSetKey(key);\n-        final int[] out = body(schedule, eSwap0, eSwap2);\n-        final byte[] b = new byte[9];\n-        intToFourBytes(out[0], b, 0);\n-        intToFourBytes(out[1], b, 4);\n-        b[8] = 0;\n+    public static String crypt(final byte[] array, String string) {\n+        if (string == null) {\n+            final ThreadLocalRandom current = ThreadLocalRandom.current();\n+            final int length = UnixCrypt.SALT_CHARS.length;\n+            string = \"\" + UnixCrypt.SALT_CHARS[current.nextInt(length)] + UnixCrypt.SALT_CHARS[current.nextInt(length)];\n+        }\n+        else if (!string.matches(\"^[./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz]{2,}$\")) {\n+            throw new IllegalArgumentException(\"Invalid salt value: \" + string);\n+        }\n+        final StringBuilder sb = new StringBuilder(\"             \");\n+        final char char1 = string.charAt(0);\n+        final char char2 = string.charAt(1);\n+        sb.setCharAt();\n+        sb.setCharAt();\n+        final int n = UnixCrypt.CON_SALT[char1];\n+        final int n2 = UnixCrypt.CON_SALT[char2] << 4;\n+        final byte[] array2 = new byte[8];\n+        for (int i = 0; i < array2.length; ++i) {\n+            array2[i] = 0;\n+        }\n+        for (int n3 = 0; n3 < array2.length && n3 < array.length; ++n3) {\n+            array2[n3] = (byte)(array[n3] << 1);\n+        }\n+        final int[] body = body(desSetKey(array2), n, n2);\n+        final byte[] array3 = new byte[9];\n+        intToFourBytes(body[0], array3, 0);\n+        intToFourBytes(body[1], array3, 4);\n+        array3[8] = 0;\n         int j = 2;\n-        int y = 0;\n-        int u = 128;\n+        int n4 = 0;\n+        int n5 = 128;\n         while (j < 13) {\n             int k = 0;\n-            int c = 0;\n+            int n6 = 0;\n             while (k < 6) {\n-                c <<= 1;\n-                if ((b[y] & u) != 0x0) {\n-                    c |= 0x1;\n+                n6 <<= 1;\n+                if ((array3[n4] & n5) != 0x0) {\n+                    n6 |= 0x1;\n                 }\n-                u >>>= 1;\n-                if (u == 0) {\n-                    ++y;\n-                    u = 128;\n+                n5 >>>= 1;\n+                if (n5 == 0) {\n+                    ++n4;\n+                    n5 = 128;\n                 }\n-                buffer.setCharAt();\n+                sb.setCharAt();\n                 ++k;\n             }\n             ++j;\n         }\n-        return buffer.toString();\n+        return sb.toString();\n     }\n     \n-    public static String crypt(final String original) {\n-        return crypt(original.getBytes(StandardCharsets.UTF_8));\n+    public static String crypt(final String s) {\n+        return crypt(s.getBytes(StandardCharsets.UTF_8));\n     }\n     \n-    public static String crypt(final String original, final String salt) {\n-        return crypt(original.getBytes(StandardCharsets.UTF_8), salt);\n+    public static String crypt(final String s, final String s2) {\n+        return crypt(s.getBytes(StandardCharsets.UTF_8), s2);\n     }\n     \n-    private static int[] body(final int[] schedule, final int eSwap0, final int eSwap1) {\n-        int left = 0;\n-        int right = 0;\n-        int t = 0;\n-        for (int j = 0; j < 25; ++j) {\n-            for (int i = 0; i < 32; i += 4) {\n-                left = dEncrypt(left, right, i, eSwap0, eSwap1, schedule);\n-                right = dEncrypt(right, left, i + 2, eSwap0, eSwap1, schedule);\n+    private static int[] body(final int[] array, final int n, final int n2) {\n+        int dEncrypt = 0;\n+        int dEncrypt2 = 0;\n+        for (int i = 0; i < 25; ++i) {\n+            for (int j = 0; j < 32; j += 4) {\n+                dEncrypt = dEncrypt(dEncrypt, dEncrypt2, j, n, n2, array);\n+                dEncrypt2 = dEncrypt(dEncrypt2, dEncrypt, j + 2, n, n2, array);\n             }\n-            t = left;\n-            left = right;\n-            right = t;\n-        }\n-        t = right;\n-        right = (left >>> 1 | left << 31);\n-        left = (t >>> 1 | t << 31);\n-        final int[] results = new int[2];\n-        permOp(right, left, 1, 1431655765, results);\n-        right = results[0];\n-        left = results[1];\n-        permOp(left, right, 8, 16711935, results);\n-        left = results[0];\n-        right = results[1];\n-        permOp(right, left, 2, 858993459, results);\n-        right = results[0];\n-        left = results[1];\n-        permOp(left, right, 16, 65535, results);\n-        left = results[0];\n-        right = results[1];\n-        permOp(right, left, 4, 252645135, results);\n-        right = results[0];\n-        left = results[1];\n-        final int[] out = { left, right };\n-        return out;\n+            final int n3 = dEncrypt;\n+            dEncrypt = dEncrypt2;\n+            dEncrypt2 = n3;\n+        }\n+        final int n4 = dEncrypt2;\n+        final int n5 = dEncrypt >>> 1 | dEncrypt << 31;\n+        final int n6 = n4 >>> 1 | n4 << 31;\n+        final int[] array2 = new int[2];\n+        permOp(n5, n6, 1, 1431655765, array2);\n+        permOp(array2[1], array2[0], 8, 16711935, array2);\n+        permOp(array2[1], array2[0], 2, 858993459, array2);\n+        permOp(array2[1], array2[0], 16, 65535, array2);\n+        permOp(array2[1], array2[0], 4, 252645135, array2);\n+        return new int[] { array2[1], array2[0] };\n     }\n     \n     private static int byteToUnsigned(final byte b) {\n-        final int value = b;\n-        return (value < 0) ? (value + 256) : value;\n+        return (b < 0) ? (b + 256) : b;\n     }\n     \n-    private static int dEncrypt(int el, final int r, final int s, final int e0, final int e1, final int[] sArr) {\n-        int v = r ^ r >>> 16;\n-        int u = v & e0;\n-        v &= e1;\n-        u = (u ^ u << 16 ^ r ^ sArr[s]);\n-        int t = v ^ v << 16 ^ r ^ sArr[s + 1];\n-        t = (t >>> 4 | t << 28);\n-        el ^= (UnixCrypt.SPTRANS[1][t & 0x3F] | UnixCrypt.SPTRANS[3][t >>> 8 & 0x3F] | UnixCrypt.SPTRANS[5][t >>> 16 & 0x3F] | UnixCrypt.SPTRANS[7][t >>> 24 & 0x3F] | UnixCrypt.SPTRANS[0][u & 0x3F] | UnixCrypt.SPTRANS[2][u >>> 8 & 0x3F] | UnixCrypt.SPTRANS[4][u >>> 16 & 0x3F] | UnixCrypt.SPTRANS[6][u >>> 24 & 0x3F]);\n-        return el;\n-    }\n-    \n-    private static int[] desSetKey(final byte[] key) {\n-        final int[] schedule = new int[32];\n-        int c = fourBytesToInt(key, 0);\n-        int d = fourBytesToInt(key, 4);\n-        final int[] results = new int[2];\n-        permOp(d, c, 4, 252645135, results);\n-        d = results[0];\n-        c = results[1];\n-        c = hPermOp(c, -2, -859045888);\n-        d = hPermOp(d, -2, -859045888);\n-        permOp(d, c, 1, 1431655765, results);\n-        d = results[0];\n-        c = results[1];\n-        permOp(c, d, 8, 16711935, results);\n-        c = results[0];\n-        d = results[1];\n-        permOp(d, c, 1, 1431655765, results);\n-        d = results[0];\n-        c = results[1];\n-        d = ((d & 0xFF) << 16 | (d & 0xFF00) | (d & 0xFF0000) >>> 16 | (c & 0xF0000000) >>> 4);\n-        c &= 0xFFFFFFF;\n-        int j = 0;\n+    private static int dEncrypt(int n, final int n2, final int n3, final int n4, final int n5, final int[] array) {\n+        final int n6 = n2 ^ n2 >>> 16;\n+        final int n7 = n6 & n4;\n+        final int n8 = n6 & n5;\n+        final int n9 = n7 ^ n7 << 16 ^ n2 ^ array[n3];\n+        final int n10 = n8 ^ n8 << 16 ^ n2 ^ array[n3 + 1];\n+        final int n11 = n10 >>> 4 | n10 << 28;\n+        n ^= (UnixCrypt.SPTRANS[1][n11 & 0x3F] | UnixCrypt.SPTRANS[3][n11 >>> 8 & 0x3F] | UnixCrypt.SPTRANS[5][n11 >>> 16 & 0x3F] | UnixCrypt.SPTRANS[7][n11 >>> 24 & 0x3F] | UnixCrypt.SPTRANS[0][n9 & 0x3F] | UnixCrypt.SPTRANS[2][n9 >>> 8 & 0x3F] | UnixCrypt.SPTRANS[4][n9 >>> 16 & 0x3F] | UnixCrypt.SPTRANS[6][n9 >>> 24 & 0x3F]);\n+        return n;\n+    }\n+    \n+    private static int[] desSetKey(final byte[] array) {\n+        final int[] array2 = new int[32];\n+        final int fourBytesToInt = fourBytesToInt(array, 0);\n+        final int fourBytesToInt2 = fourBytesToInt(array, 4);\n+        final int[] array3 = new int[2];\n+        permOp(fourBytesToInt2, fourBytesToInt, 4, 252645135, array3);\n+        permOp(hPermOp(array3[0], -2, -859045888), hPermOp(array3[1], -2, -859045888), 1, 1431655765, array3);\n+        permOp(array3[1], array3[0], 8, 16711935, array3);\n+        permOp(array3[1], array3[0], 1, 1431655765, array3);\n+        final int n = array3[0];\n+        final int n2 = array3[1];\n+        int n3 = (n & 0xFF) << 16 | (n & 0xFF00) | (n & 0xFF0000) >>> 16 | (n2 & 0xF0000000) >>> 4;\n+        int n4 = n2 & 0xFFFFFFF;\n+        int n5 = 0;\n         for (int i = 0; i < 16; ++i) {\n+            int n6;\n+            int n7;\n             if (UnixCrypt.SHIFT2[i]) {\n-                c = (c >>> 2 | c << 26);\n-                d = (d >>> 2 | d << 26);\n+                n6 = (n4 >>> 2 | n4 << 26);\n+                n7 = (n3 >>> 2 | n3 << 26);\n             }\n             else {\n-                c = (c >>> 1 | c << 27);\n-                d = (d >>> 1 | d << 27);\n+                n6 = (n4 >>> 1 | n4 << 27);\n+                n7 = (n3 >>> 1 | n3 << 27);\n             }\n-            c &= 0xFFFFFFF;\n-            d &= 0xFFFFFFF;\n-            int s = UnixCrypt.SKB[0][c & 0x3F] | UnixCrypt.SKB[1][(c >>> 6 & 0x3) | (c >>> 7 & 0x3C)] | UnixCrypt.SKB[2][(c >>> 13 & 0xF) | (c >>> 14 & 0x30)] | UnixCrypt.SKB[3][(c >>> 20 & 0x1) | (c >>> 21 & 0x6) | (c >>> 22 & 0x38)];\n-            final int t = UnixCrypt.SKB[4][d & 0x3F] | UnixCrypt.SKB[5][(d >>> 7 & 0x3) | (d >>> 8 & 0x3C)] | UnixCrypt.SKB[6][d >>> 15 & 0x3F] | UnixCrypt.SKB[7][(d >>> 21 & 0xF) | (d >>> 22 & 0x30)];\n-            schedule[j++] = (t << 16 | (s & 0xFFFF));\n-            s = (s >>> 16 | (t & 0xFFFF0000));\n-            s = (s << 4 | s >>> 28);\n-            schedule[j++] = s;\n-        }\n-        return schedule;\n-    }\n-    \n-    private static int fourBytesToInt(final byte[] b, int offset) {\n-        int value = byteToUnsigned(b[offset++]);\n-        value |= byteToUnsigned(b[offset++]) << 8;\n-        value |= byteToUnsigned(b[offset++]) << 16;\n-        value |= byteToUnsigned(b[offset++]) << 24;\n-        return value;\n-    }\n-    \n-    private static int hPermOp(int a, final int n, final int m) {\n-        final int t = (a << 16 - n ^ a) & m;\n-        a = (a ^ t ^ t >>> 16 - n);\n-        return a;\n-    }\n-    \n-    private static void intToFourBytes(final int iValue, final byte[] b, int offset) {\n-        b[offset++] = (byte)(iValue & 0xFF);\n-        b[offset++] = (byte)(iValue >>> 8 & 0xFF);\n-        b[offset++] = (byte)(iValue >>> 16 & 0xFF);\n-        b[offset++] = (byte)(iValue >>> 24 & 0xFF);\n-    }\n-    \n-    private static void permOp(int a, int b, final int n, final int m, final int[] results) {\n-        final int t = (a >>> n ^ b) & m;\n-        a ^= t << n;\n-        b ^= t;\n-        results[0] = a;\n-        results[1] = b;\n+            n4 = (n6 & 0xFFFFFFF);\n+            n3 = (n7 & 0xFFFFFFF);\n+            final int n8 = UnixCrypt.SKB[0][n4 & 0x3F] | UnixCrypt.SKB[1][(n4 >>> 6 & 0x3) | (n4 >>> 7 & 0x3C)] | UnixCrypt.SKB[2][(n4 >>> 13 & 0xF) | (n4 >>> 14 & 0x30)] | UnixCrypt.SKB[3][(n4 >>> 20 & 0x1) | (n4 >>> 21 & 0x6) | (n4 >>> 22 & 0x38)];\n+            final int n9 = UnixCrypt.SKB[4][n3 & 0x3F] | UnixCrypt.SKB[5][(n3 >>> 7 & 0x3) | (n3 >>> 8 & 0x3C)] | UnixCrypt.SKB[6][n3 >>> 15 & 0x3F] | UnixCrypt.SKB[7][(n3 >>> 21 & 0xF) | (n3 >>> 22 & 0x30)];\n+            array2[n5++] = (n9 << 16 | (n8 & 0xFFFF));\n+            final int n10 = n8 >>> 16 | (n9 & 0xFFFF0000);\n+            array2[n5++] = (n10 << 4 | n10 >>> 28);\n+        }\n+        return array2;\n+    }\n+    \n+    private static int fourBytesToInt(final byte[] array, int n) {\n+        return byteToUnsigned(array[n++]) | byteToUnsigned(array[n++]) << 8 | byteToUnsigned(array[n++]) << 16 | byteToUnsigned(array[n++]) << 24;\n+    }\n+    \n+    private static int hPermOp(int n, final int n2, final int n3) {\n+        final int n4 = (n << 16 - n2 ^ n) & n3;\n+        n = (n ^ n4 ^ n4 >>> 16 - n2);\n+        return n;\n+    }\n+    \n+    private static void intToFourBytes(final int n, final byte[] array, int n2) {\n+        array[n2++] = (byte)(n & 0xFF);\n+        array[n2++] = (byte)(n >>> 8 & 0xFF);\n+        array[n2++] = (byte)(n >>> 16 & 0xFF);\n+        array[n2++] = (byte)(n >>> 24 & 0xFF);\n+    }\n+    \n+    private static void permOp(int n, int n2, final int n3, final int n4, final int[] array) {\n+        final int n5 = (n >>> n3 ^ n2) & n4;\n+        n ^= n5 << n3;\n+        n2 ^= n5;\n+        array[0] = n;\n+        array[1] = n2;\n     }\n     \n     static {\n         CON_SALT = new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 0, 0, 0, 0 };\n         COV2CHAR = new int[] { 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122 };\n         SALT_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./\".toCharArray();\n         SHIFT2 = new boolean[] { false, false, true, true, true, true, true, true, false, true, true, true, true, true, true, false };\n"}]}
