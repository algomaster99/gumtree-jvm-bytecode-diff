{"diffoscope-json-version": 1, "source1": "first/ReversedLinesFileReader.class", "source2": "second/ReversedLinesFileReader.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,14 +1,13 @@\n \n package org.apache.commons.io.input;\n \n import java.util.Collections;\n import java.util.ArrayList;\n import java.util.List;\n-import java.nio.charset.CharsetEncoder;\n import java.nio.file.Files;\n import java.nio.file.StandardOpenOption;\n import java.nio.file.OpenOption;\n import org.apache.commons.io.StandardLineSeparator;\n import java.io.UnsupportedEncodingException;\n import java.nio.charset.StandardCharsets;\n import org.apache.commons.io.Charsets;\n@@ -39,32 +38,30 @@\n         this(file, 8192, Charset.defaultCharset());\n     }\n     \n     public ReversedLinesFileReader(final File file, final Charset charset) throws IOException {\n         this(file.toPath(), charset);\n     }\n     \n-    public ReversedLinesFileReader(final File file, final int blockSize, final Charset charset) throws IOException {\n-        this(file.toPath(), blockSize, charset);\n+    public ReversedLinesFileReader(final File file, final int n, final Charset charset) throws IOException {\n+        this(file.toPath(), n, charset);\n     }\n     \n-    public ReversedLinesFileReader(final File file, final int blockSize, final String charsetName) throws IOException {\n-        this(file.toPath(), blockSize, charsetName);\n+    public ReversedLinesFileReader(final File file, final int n, final String s) throws IOException {\n+        this(file.toPath(), n, s);\n     }\n     \n-    public ReversedLinesFileReader(final Path file, final Charset charset) throws IOException {\n-        this(file, 8192, charset);\n+    public ReversedLinesFileReader(final Path path, final Charset charset) throws IOException {\n+        this(path, 8192, charset);\n     }\n     \n-    public ReversedLinesFileReader(final Path file, final int blockSize, final Charset charset) throws IOException {\n+    public ReversedLinesFileReader(final Path path, final int blockSize, final Charset obj) throws IOException {\n         this.blockSize = blockSize;\n-        this.charset = Charsets.toCharset(charset);\n-        final CharsetEncoder charsetEncoder = this.charset.newEncoder();\n-        final float maxBytesPerChar = charsetEncoder.maxBytesPerChar();\n-        if (maxBytesPerChar == 1.0f) {\n+        this.charset = Charsets.toCharset(obj);\n+        if (this.charset.newEncoder().maxBytesPerChar() == 1.0f) {\n             this.byteDecrement = 1;\n         }\n         else if (this.charset == StandardCharsets.UTF_8) {\n             this.byteDecrement = 1;\n         }\n         else if (this.charset == Charset.forName(\"Shift_JIS\") || this.charset == Charset.forName(\"windows-31j\") || this.charset == Charset.forName(\"x-windows-949\") || this.charset == Charset.forName(\"gbk\") || this.charset == Charset.forName(\"x-windows-950\")) {\n             this.byteDecrement = 1;\n@@ -72,71 +69,71 @@\n         else if (this.charset == StandardCharsets.UTF_16BE || this.charset == StandardCharsets.UTF_16LE) {\n             this.byteDecrement = 2;\n         }\n         else {\n             if (this.charset == StandardCharsets.UTF_16) {\n                 throw new UnsupportedEncodingException(\"For UTF-16, you need to specify the byte order (use UTF-16BE or UTF-16LE)\");\n             }\n-            throw new UnsupportedEncodingException(\"Encoding \" + charset + \" is not supported yet (feel free to submit a patch)\");\n+            throw new UnsupportedEncodingException(\"Encoding \" + obj + \" is not supported yet (feel free to submit a patch)\");\n         }\n         this.newLineSequences = new byte[][] { StandardLineSeparator.CRLF.getBytes(this.charset), StandardLineSeparator.LF.getBytes(this.charset), StandardLineSeparator.CR.getBytes(this.charset) };\n         this.avoidNewlineSplitBufferSize = this.newLineSequences[0].length;\n-        this.channel = Files.newByteChannel(file, StandardOpenOption.READ);\n+        this.channel = Files.newByteChannel(path, StandardOpenOption.READ);\n         this.totalByteLength = this.channel.size();\n-        int lastBlockLength = (int)(this.totalByteLength % blockSize);\n-        if (lastBlockLength > 0) {\n+        int n = (int)(this.totalByteLength % blockSize);\n+        if (n > 0) {\n             this.totalBlockCount = this.totalByteLength / blockSize + 1L;\n         }\n         else {\n             this.totalBlockCount = this.totalByteLength / blockSize;\n             if (this.totalByteLength > 0L) {\n-                lastBlockLength = blockSize;\n+                n = blockSize;\n             }\n         }\n-        this.currentFilePart = new ReversedLinesFileReader.FilePart(this, this.totalBlockCount, lastBlockLength, (byte[])null, (ReversedLinesFileReader.ReversedLinesFileReader$1)null);\n+        this.currentFilePart = new ReversedLinesFileReader.FilePart(this, this.totalBlockCount, n, (byte[])null, (ReversedLinesFileReader.ReversedLinesFileReader$1)null);\n     }\n     \n-    public ReversedLinesFileReader(final Path file, final int blockSize, final String charsetName) throws IOException {\n-        this(file, blockSize, Charsets.toCharset(charsetName));\n+    public ReversedLinesFileReader(final Path path, final int n, final String s) throws IOException {\n+        this(path, n, Charsets.toCharset(s));\n     }\n     \n     @Override\n     public void close() throws IOException {\n         this.channel.close();\n     }\n     \n     public String readLine() throws IOException {\n-        String line;\n-        for (line = ReversedLinesFileReader.FilePart.access$700(this.currentFilePart); line == null; line = ReversedLinesFileReader.FilePart.access$700(this.currentFilePart)) {\n+        String anObject;\n+        for (anObject = ReversedLinesFileReader.FilePart.access$700(this.currentFilePart); anObject == null; anObject = ReversedLinesFileReader.FilePart.access$700(this.currentFilePart)) {\n             this.currentFilePart = ReversedLinesFileReader.FilePart.access$800(this.currentFilePart);\n             if (this.currentFilePart == null) {\n                 break;\n             }\n         }\n-        if (\"\".equals(line) && !this.trailingNewlineOfFileSkipped) {\n+        if (\"\".equals(anObject) && !this.trailingNewlineOfFileSkipped) {\n             this.trailingNewlineOfFileSkipped = true;\n-            line = this.readLine();\n+            anObject = this.readLine();\n         }\n-        return line;\n+        return anObject;\n     }\n     \n-    public List<String> readLines(final int lineCount) throws IOException {\n-        if (lineCount < 0) {\n+    public List<String> readLines(final int initialCapacity) throws IOException {\n+        if (initialCapacity < 0) {\n             throw new IllegalArgumentException(\"lineCount < 0\");\n         }\n-        final ArrayList<String> arrayList = new ArrayList<String>(lineCount);\n-        for (int i = 0; i < lineCount; ++i) {\n+        final ArrayList list = new ArrayList(initialCapacity);\n+        for (int i = 0; i < initialCapacity; ++i) {\n             final String line = this.readLine();\n             if (line == null) {\n-                return arrayList;\n+                return list;\n             }\n-            arrayList.add(line);\n+            list.add(line);\n         }\n-        return arrayList;\n+        return list;\n     }\n     \n-    public String toString(final int lineCount) throws IOException {\n-        final List<String> lines = this.readLines(lineCount);\n+    public String toString(final int n) throws IOException {\n+        final List<String> lines = this.readLines(n);\n         Collections.reverse(lines);\n         return lines.isEmpty() ? \"\" : (String.join((CharSequence)System.lineSeparator(), (Iterable<? extends CharSequence>)lines) + System.lineSeparator());\n     }\n }\n"}]}
