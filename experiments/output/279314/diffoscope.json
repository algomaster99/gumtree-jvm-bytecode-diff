{"diffoscope-json-version": 1, "source1": "first/BZip2CompressorInputStream.class", "source2": "second/BZip2CompressorInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -40,109 +40,108 @@\n     private int su_j2;\n     private int su_rNToGo;\n     private int su_rTPos;\n     private int su_tPos;\n     private char su_z;\n     private BZip2CompressorInputStream.Data data;\n     \n-    private static boolean bsGetBit(final BitInputStream bin) throws IOException {\n-        return bsR(bin, 1) != 0;\n+    private static boolean bsGetBit(final BitInputStream bitInputStream) throws IOException {\n+        return bsR(bitInputStream, 1) != 0;\n     }\n     \n-    private static int bsGetInt(final BitInputStream bin) throws IOException {\n-        return bsR(bin, 32);\n+    private static int bsGetInt(final BitInputStream bitInputStream) throws IOException {\n+        return bsR(bitInputStream, 32);\n     }\n     \n-    private static char bsGetUByte(final BitInputStream bin) throws IOException {\n-        return (char)bsR(bin, 8);\n+    private static char bsGetUByte(final BitInputStream bitInputStream) throws IOException {\n+        return (char)bsR(bitInputStream, 8);\n     }\n     \n-    private static int bsR(final BitInputStream bin, final int n) throws IOException {\n-        final long thech = bin.readBits(n);\n-        if (thech < 0L) {\n+    private static int bsR(final BitInputStream bitInputStream, final int n) throws IOException {\n+        final long bits = bitInputStream.readBits(n);\n+        if (bits < 0L) {\n             throw new IOException(\"Unexpected end of stream\");\n         }\n-        return (int)thech;\n+        return (int)bits;\n     }\n     \n-    private static void checkBounds(final int checkVal, final int limitExclusive, final String name) throws IOException {\n-        if (checkVal < 0) {\n-            throw new IOException(\"Corrupted input, \" + name + \" value negative\");\n+    private static void checkBounds(final int n, final int n2, final String s) throws IOException {\n+        if (n < 0) {\n+            throw new IOException(\"Corrupted input, \" + s + \" value negative\");\n         }\n-        if (checkVal >= limitExclusive) {\n-            throw new IOException(\"Corrupted input, \" + name + \" value too big\");\n+        if (n >= n2) {\n+            throw new IOException(\"Corrupted input, \" + s + \" value too big\");\n         }\n     }\n     \n-    private static void hbCreateDecodeTables(final int[] limit, final int[] base, final int[] perm, final char[] length, final int minLen, final int maxLen, final int alphaSize) throws IOException {\n-        int i = minLen;\n-        int pp = 0;\n-        while (i <= maxLen) {\n-            for (int j = 0; j < alphaSize; ++j) {\n-                if (length[j] == i) {\n-                    perm[pp++] = j;\n+    private static void hbCreateDecodeTables(final int[] array, final int[] array2, final int[] array3, final char[] array4, final int n, final int n2, final int n3) throws IOException {\n+        char c = (char)n;\n+        int n4 = 0;\n+        while (c <= n2) {\n+            for (int i = 0; i < n3; ++i) {\n+                if (array4[i] == c) {\n+                    array3[n4++] = i;\n                 }\n             }\n-            ++i;\n+            ++c;\n         }\n-        i = 23;\n-        while (--i > 0) {\n-            limit[i] = (base[i] = 0);\n-        }\n-        for (i = 0; i < alphaSize; ++i) {\n-            final int l = length[i];\n-            checkBounds(l, 258, \"length\");\n-            final int n = l + 1;\n-            ++base[n];\n-        }\n-        i = 1;\n-        int b = base[0];\n-        while (i < 23) {\n-            b += base[i];\n-            base[i] = b;\n-            ++i;\n+        int n5 = 23;\n+        while (--n5 > 0) {\n+            array[n5] = (array2[n5] = 0);\n         }\n-        i = minLen;\n-        int vec = 0;\n-        int b2 = base[i];\n-        while (i <= maxLen) {\n-            final int nb = base[i + 1];\n-            vec += nb - b2;\n-            b2 = nb;\n-            limit[i] = vec - 1;\n-            vec <<= 1;\n-            ++i;\n+        for (final char c2 : array4) {\n+            checkBounds(c2, 258, \"length\");\n+            final int n6 = c2 + '\\u0001';\n+            ++array2[n6];\n+        }\n+        int k = 1;\n+        int n7 = array2[0];\n+        while (k < 23) {\n+            n7 += array2[k];\n+            array2[k] = n7;\n+            ++k;\n         }\n-        for (i = minLen + 1; i <= maxLen; ++i) {\n-            base[i] = (limit[i - 1] + 1 << 1) - base[i];\n+        int l = n;\n+        int n8 = 0;\n+        int n9 = array2[l];\n+        while (l <= n2) {\n+            final int n10 = array2[l + 1];\n+            final int n11 = n8 + (n10 - n9);\n+            n9 = n10;\n+            array[l] = n11 - 1;\n+            n8 = n11 << 1;\n+            ++l;\n+        }\n+        for (int n12 = n + 1; n12 <= n2; ++n12) {\n+            array2[n12] = (array[n12 - 1] + 1 << 1) - array2[n12];\n         }\n     }\n     \n-    public static boolean matches(final byte[] signature, final int length) {\n-        return length >= 3 && signature[0] == 66 && signature[1] == 90 && signature[2] == 104;\n+    public static boolean matches(final byte[] array, final int n) {\n+        return n >= 3 && array[0] == 66 && array[1] == 90 && array[2] == 104;\n     }\n     \n-    public BZip2CompressorInputStream(final InputStream in) throws IOException {\n-        this(in, false);\n+    public BZip2CompressorInputStream(final InputStream inputStream) throws IOException {\n+        this(inputStream, false);\n     }\n     \n-    public BZip2CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException {\n+    public BZip2CompressorInputStream(final InputStream inputStream, final boolean decompressConcatenated) throws IOException {\n         this.crc = new CRC();\n         this.currentState = 1;\n-        this.bin = new BitInputStream((InputStream)((in == System.in) ? new CloseShieldFilterInputStream(in) : in), ByteOrder.BIG_ENDIAN);\n+        this.bin = new BitInputStream((InputStream)((inputStream == System.in) ? new CloseShieldFilterInputStream(inputStream) : inputStream), ByteOrder.BIG_ENDIAN);\n         this.decompressConcatenated = decompressConcatenated;\n         this.init(true);\n         this.initBlock();\n     }\n     \n     public void close() throws IOException {\n-        final BitInputStream inShadow = this.bin;\n-        if (inShadow != null) {\n+        final BitInputStream bin = this.bin;\n+        if (bin != null) {\n             try {\n-                inShadow.close();\n+                bin.close();\n             }\n             finally {\n                 this.data = null;\n                 this.bin = null;\n             }\n         }\n     }\n@@ -153,37 +152,37 @@\n         this.data = null;\n         if (this.storedCombinedCRC != this.computedCombinedCRC) {\n             throw new IOException(\"BZip2 CRC error\");\n         }\n         return !this.decompressConcatenated || !this.init(false);\n     }\n     \n-    private void createHuffmanDecodingTables(final int alphaSize, final int nGroups) throws IOException {\n-        final BZip2CompressorInputStream.Data dataShadow = this.data;\n-        final char[][] len = dataShadow.temp_charArray2d;\n-        final int[] minLens = dataShadow.minLens;\n-        final int[][] limit = dataShadow.limit;\n-        final int[][] base = dataShadow.base;\n-        final int[][] perm = dataShadow.perm;\n-        for (int t = 0; t < nGroups; ++t) {\n-            int minLen = 32;\n-            int maxLen = 0;\n-            final char[] len_t = len[t];\n-            int i = alphaSize;\n-            while (--i >= 0) {\n-                final char lent = len_t[i];\n-                if (lent > maxLen) {\n-                    maxLen = lent;\n+    private void createHuffmanDecodingTables(final int n, final int n2) throws IOException {\n+        final BZip2CompressorInputStream.Data data = this.data;\n+        final char[][] temp_charArray2d = data.temp_charArray2d;\n+        final int[] minLens = data.minLens;\n+        final int[][] limit = data.limit;\n+        final int[][] base = data.base;\n+        final int[][] perm = data.perm;\n+        for (int i = 0; i < n2; ++i) {\n+            char c = ' ';\n+            char c2 = '\\0';\n+            final char[] array = temp_charArray2d[i];\n+            int n3 = n;\n+            while (--n3 >= 0) {\n+                final char c3 = array[n3];\n+                if (c3 > c2) {\n+                    c2 = c3;\n                 }\n-                if (lent < minLen) {\n-                    minLen = lent;\n+                if (c3 < c) {\n+                    c = c3;\n                 }\n             }\n-            hbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen, maxLen, alphaSize);\n-            minLens[t] = minLen;\n+            hbCreateDecodeTables(limit[i], base[i], perm[i], temp_charArray2d[i], c, c2, n);\n+            minLens[i] = c;\n         }\n     }\n     \n     private void endBlock() throws IOException {\n         this.computedBlockCRC = this.crc.getFinalCRC();\n         if (this.storedBlockCRC != this.computedBlockCRC) {\n             this.computedCombinedCRC = (this.storedCombinedCRC << 1 | this.storedCombinedCRC >>> 31);\n@@ -194,198 +193,198 @@\n         this.computedCombinedCRC ^= this.computedBlockCRC;\n     }\n     \n     private void getAndMoveToFrontDecode() throws IOException {\n         final BitInputStream bin = this.bin;\n         this.origPtr = bsR(bin, 24);\n         this.recvDecodingTables();\n-        final BZip2CompressorInputStream.Data dataShadow = this.data;\n-        final byte[] ll8 = dataShadow.ll8;\n-        final int[] unzftab = dataShadow.unzftab;\n-        final byte[] selector = dataShadow.selector;\n-        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n-        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n-        final int[] minLens = dataShadow.minLens;\n-        final int[][] limit = dataShadow.limit;\n-        final int[][] base = dataShadow.base;\n-        final int[][] perm = dataShadow.perm;\n-        final int limitLast = this.blockSize100k * 100000;\n-        int i = 256;\n-        while (--i >= 0) {\n-            yy[i] = (char)i;\n-            unzftab[i] = 0;\n-        }\n-        int groupNo = 0;\n-        int groupPos = 49;\n-        final int eob = this.nInUse + 1;\n-        int nextSym = this.getAndMoveToFrontDecode0();\n-        int lastShadow = -1;\n-        int zt = selector[groupNo] & 0xFF;\n-        checkBounds(zt, 6, \"zt\");\n-        int[] base_zt = base[zt];\n-        int[] limit_zt = limit[zt];\n-        int[] perm_zt = perm[zt];\n-        int minLens_zt = minLens[zt];\n-        while (nextSym != eob) {\n-            if (nextSym == 0 || nextSym == 1) {\n-                int s = -1;\n-                int n = 1;\n+        final BZip2CompressorInputStream.Data data = this.data;\n+        final byte[] ll8 = data.ll8;\n+        final int[] unzftab = data.unzftab;\n+        final byte[] selector = data.selector;\n+        final byte[] seqToUnseq = data.seqToUnseq;\n+        final char[] getAndMoveToFrontDecode_yy = data.getAndMoveToFrontDecode_yy;\n+        final int[] minLens = data.minLens;\n+        final int[][] limit = data.limit;\n+        final int[][] base = data.base;\n+        final int[][] perm = data.perm;\n+        final int n = this.blockSize100k * 100000;\n+        int n2 = 256;\n+        while (--n2 >= 0) {\n+            getAndMoveToFrontDecode_yy[n2] = (char)n2;\n+            unzftab[n2] = 0;\n+        }\n+        int n3 = 0;\n+        int n4 = 49;\n+        final int n5 = this.nInUse + 1;\n+        int i = this.getAndMoveToFrontDecode0();\n+        int last = -1;\n+        final int n6 = selector[n3] & 0xFF;\n+        checkBounds(n6, 6, \"zt\");\n+        int[] array = base[n6];\n+        int[] array2 = limit[n6];\n+        int[] array3 = perm[n6];\n+        int n7 = minLens[n6];\n+        while (i != n5) {\n+            if (i == 0 || i == 1) {\n+                int n8 = -1;\n+                int n9 = 1;\n                 while (true) {\n-                    if (nextSym == 0) {\n-                        s += n;\n+                    if (i == 0) {\n+                        n8 += n9;\n                     }\n                     else {\n-                        if (nextSym != 1) {\n+                        if (i != 1) {\n                             break;\n                         }\n-                        s += n << 1;\n+                        n8 += n9 << 1;\n                     }\n-                    if (groupPos == 0) {\n-                        groupPos = 49;\n-                        checkBounds(++groupNo, 18002, \"groupNo\");\n-                        zt = (selector[groupNo] & 0xFF);\n-                        checkBounds(zt, 6, \"zt\");\n-                        base_zt = base[zt];\n-                        limit_zt = limit[zt];\n-                        perm_zt = perm[zt];\n-                        minLens_zt = minLens[zt];\n+                    if (n4 == 0) {\n+                        n4 = 49;\n+                        checkBounds(++n3, 18002, \"groupNo\");\n+                        final int n10 = selector[n3] & 0xFF;\n+                        checkBounds(n10, 6, \"zt\");\n+                        array = base[n10];\n+                        array2 = limit[n10];\n+                        array3 = perm[n10];\n+                        n7 = minLens[n10];\n                     }\n                     else {\n-                        --groupPos;\n+                        --n4;\n                     }\n-                    int zn = minLens_zt;\n-                    checkBounds(zn, 258, \"zn\");\n-                    int zvec;\n-                    for (zvec = bsR(bin, zn); zvec > limit_zt[zn]; zvec = (zvec << 1 | bsR(bin, 1))) {\n-                        checkBounds(++zn, 258, \"zn\");\n+                    int n11 = n7;\n+                    checkBounds(n11, 258, \"zn\");\n+                    int j;\n+                    for (j = bsR(bin, n11); j > array2[n11]; j = (j << 1 | bsR(bin, 1))) {\n+                        checkBounds(++n11, 258, \"zn\");\n                     }\n-                    final int tmp = zvec - base_zt[zn];\n-                    checkBounds(tmp, 258, \"zvec\");\n-                    nextSym = perm_zt[tmp];\n-                    n <<= 1;\n-                }\n-                checkBounds(s, this.data.ll8.length, \"s\");\n-                final int yy2 = yy[0];\n-                checkBounds(yy2, 256, \"yy\");\n-                final byte ch = seqToUnseq[yy2];\n-                final int[] array = unzftab;\n-                final int n2 = ch & 0xFF;\n-                array[n2] += s + 1;\n-                final int from = ++lastShadow;\n-                lastShadow += s;\n-                checkBounds(lastShadow, this.data.ll8.length, \"lastShadow\");\n-                Arrays.fill(ll8, from, lastShadow + 1, ch);\n-                if (lastShadow >= limitLast) {\n-                    throw new IOException(\"Block overrun while expanding RLE in MTF, \" + lastShadow + \" exceeds \" + limitLast);\n+                    final int n12 = j - array[n11];\n+                    checkBounds(n12, 258, \"zvec\");\n+                    i = array3[n12];\n+                    n9 <<= 1;\n+                }\n+                checkBounds(n8, this.data.ll8.length, \"s\");\n+                final char c = getAndMoveToFrontDecode_yy[0];\n+                checkBounds(c, 256, \"yy\");\n+                final byte val = seqToUnseq[c];\n+                final int[] array4 = unzftab;\n+                final int n13 = val & 0xFF;\n+                array4[n13] += n8 + 1;\n+                final int fromIndex = ++last;\n+                last += n8;\n+                checkBounds(last, this.data.ll8.length, \"lastShadow\");\n+                Arrays.fill(ll8, fromIndex, last + 1, val);\n+                if (last >= n) {\n+                    throw new IOException(\"Block overrun while expanding RLE in MTF, \" + last + \" exceeds \" + n);\n                 }\n                 continue;\n             }\n             else {\n-                if (++lastShadow >= limitLast) {\n-                    throw new IOException(\"Block overrun in MTF, \" + lastShadow + \" exceeds \" + limitLast);\n+                if (++last >= n) {\n+                    throw new IOException(\"Block overrun in MTF, \" + last + \" exceeds \" + n);\n                 }\n-                checkBounds(nextSym, 257, \"nextSym\");\n-                final char tmp2 = yy[nextSym - 1];\n-                checkBounds(tmp2, 256, \"yy\");\n-                final int[] array2 = unzftab;\n-                final int n3 = seqToUnseq[tmp2] & 0xFF;\n-                ++array2[n3];\n-                ll8[lastShadow] = seqToUnseq[tmp2];\n-                if (nextSym <= 16) {\n-                    for (int j = nextSym - 1; j > 0; yy[j] = yy[--j]) {}\n+                checkBounds(i, 257, \"nextSym\");\n+                final char c2 = getAndMoveToFrontDecode_yy[i - 1];\n+                checkBounds(c2, 256, \"yy\");\n+                final int[] array5 = unzftab;\n+                final int n14 = seqToUnseq[c2] & 0xFF;\n+                ++array5[n14];\n+                ll8[last] = seqToUnseq[c2];\n+                if (i <= 16) {\n+                    for (int k = i - 1; k > 0; getAndMoveToFrontDecode_yy[k] = getAndMoveToFrontDecode_yy[--k]) {}\n                 }\n                 else {\n-                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n+                    System.arraycopy(getAndMoveToFrontDecode_yy, 0, getAndMoveToFrontDecode_yy, 1, i - 1);\n                 }\n-                yy[0] = tmp2;\n-                if (groupPos == 0) {\n-                    groupPos = 49;\n-                    checkBounds(++groupNo, 18002, \"groupNo\");\n-                    zt = (selector[groupNo] & 0xFF);\n-                    checkBounds(zt, 6, \"zt\");\n-                    base_zt = base[zt];\n-                    limit_zt = limit[zt];\n-                    perm_zt = perm[zt];\n-                    minLens_zt = minLens[zt];\n+                getAndMoveToFrontDecode_yy[0] = c2;\n+                if (n4 == 0) {\n+                    n4 = 49;\n+                    checkBounds(++n3, 18002, \"groupNo\");\n+                    final int n15 = selector[n3] & 0xFF;\n+                    checkBounds(n15, 6, \"zt\");\n+                    array = base[n15];\n+                    array2 = limit[n15];\n+                    array3 = perm[n15];\n+                    n7 = minLens[n15];\n                 }\n                 else {\n-                    --groupPos;\n+                    --n4;\n                 }\n-                int zn2 = minLens_zt;\n-                checkBounds(zn2, 258, \"zn\");\n-                int zvec2;\n-                for (zvec2 = bsR(bin, zn2); zvec2 > limit_zt[zn2]; zvec2 = (zvec2 << 1 | bsR(bin, 1))) {\n-                    checkBounds(++zn2, 258, \"zn\");\n+                int n16 = n7;\n+                checkBounds(n16, 258, \"zn\");\n+                int l;\n+                for (l = bsR(bin, n16); l > array2[n16]; l = (l << 1 | bsR(bin, 1))) {\n+                    checkBounds(++n16, 258, \"zn\");\n                 }\n-                final int idx = zvec2 - base_zt[zn2];\n-                checkBounds(idx, 258, \"zvec\");\n-                nextSym = perm_zt[idx];\n+                final int n17 = l - array[n16];\n+                checkBounds(n17, 258, \"zvec\");\n+                i = array3[n17];\n             }\n         }\n-        this.last = lastShadow;\n+        this.last = last;\n     }\n     \n     private int getAndMoveToFrontDecode0() throws IOException {\n-        final BZip2CompressorInputStream.Data dataShadow = this.data;\n-        final int zt = dataShadow.selector[0] & 0xFF;\n-        checkBounds(zt, 6, \"zt\");\n-        final int[] limit_zt = dataShadow.limit[zt];\n-        int zn = dataShadow.minLens[zt];\n-        checkBounds(zn, 258, \"zn\");\n-        int zvec;\n-        for (zvec = bsR(this.bin, zn); zvec > limit_zt[zn]; zvec = (zvec << 1 | bsR(this.bin, 1))) {\n-            checkBounds(++zn, 258, \"zn\");\n-        }\n-        final int tmp = zvec - dataShadow.base[zt][zn];\n-        checkBounds(tmp, 258, \"zvec\");\n-        return dataShadow.perm[zt][tmp];\n+        final BZip2CompressorInputStream.Data data = this.data;\n+        final int n = data.selector[0] & 0xFF;\n+        checkBounds(n, 6, \"zt\");\n+        final int[] array = data.limit[n];\n+        int n2 = data.minLens[n];\n+        checkBounds(n2, 258, \"zn\");\n+        int i;\n+        for (i = bsR(this.bin, n2); i > array[n2]; i = (i << 1 | bsR(this.bin, 1))) {\n+            checkBounds(++n2, 258, \"zn\");\n+        }\n+        final int n3 = i - data.base[n][n2];\n+        checkBounds(n3, 258, \"zvec\");\n+        return data.perm[n][n3];\n     }\n     \n     public long getCompressedCount() {\n         return this.bin.getBytesRead();\n     }\n     \n-    private boolean init(final boolean isFirstStream) throws IOException {\n+    private boolean init(final boolean b) throws IOException {\n         if (null == this.bin) {\n             throw new IOException(\"No InputStream\");\n         }\n-        if (!isFirstStream) {\n+        if (!b) {\n             this.bin.clearBitCache();\n         }\n-        final int magic0 = this.readNextByte(this.bin);\n-        if (magic0 == -1 && !isFirstStream) {\n+        final int nextByte = this.readNextByte(this.bin);\n+        if (nextByte == -1 && !b) {\n             return false;\n         }\n-        final int magic2 = this.readNextByte(this.bin);\n-        final int magic3 = this.readNextByte(this.bin);\n-        if (magic0 != 66 || magic2 != 90 || magic3 != 104) {\n-            throw new IOException(isFirstStream ? \"Stream is not in the BZip2 format\" : \"Garbage after a valid BZip2 stream\");\n+        final int nextByte2 = this.readNextByte(this.bin);\n+        final int nextByte3 = this.readNextByte(this.bin);\n+        if (nextByte != 66 || nextByte2 != 90 || nextByte3 != 104) {\n+            throw new IOException(b ? \"Stream is not in the BZip2 format\" : \"Garbage after a valid BZip2 stream\");\n         }\n-        final int blockSize = this.readNextByte(this.bin);\n-        if (blockSize < 49 || blockSize > 57) {\n+        final int nextByte4 = this.readNextByte(this.bin);\n+        if (nextByte4 < 49 || nextByte4 > 57) {\n             throw new IOException(\"BZip2 block size is invalid\");\n         }\n-        this.blockSize100k = blockSize - 48;\n+        this.blockSize100k = nextByte4 - 48;\n         this.computedCombinedCRC = 0;\n         return true;\n     }\n     \n     private void initBlock() throws IOException {\n         final BitInputStream bin = this.bin;\n         do {\n-            final char magic0 = bsGetUByte(bin);\n-            final char magic2 = bsGetUByte(bin);\n-            final char magic3 = bsGetUByte(bin);\n-            final char magic4 = bsGetUByte(bin);\n-            final char magic5 = bsGetUByte(bin);\n-            final char magic6 = bsGetUByte(bin);\n-            if (magic0 == '\\u0017' && magic2 == 'r' && magic3 == 'E' && magic4 == '8' && magic5 == 'P' && magic6 == '\\u0090') {\n+            final char bsGetUByte = bsGetUByte(bin);\n+            final char bsGetUByte2 = bsGetUByte(bin);\n+            final char bsGetUByte3 = bsGetUByte(bin);\n+            final char bsGetUByte4 = bsGetUByte(bin);\n+            final char bsGetUByte5 = bsGetUByte(bin);\n+            final char bsGetUByte6 = bsGetUByte(bin);\n+            if (bsGetUByte == '\\u0017' && bsGetUByte2 == 'r' && bsGetUByte3 == 'E' && bsGetUByte4 == '8' && bsGetUByte5 == 'P' && bsGetUByte6 == '\\u0090') {\n                 continue;\n             }\n-            if (magic0 != '1' || magic2 != 'A' || magic3 != 'Y' || magic4 != '&' || magic5 != 'S' || magic6 != 'Y') {\n+            if (bsGetUByte != '1' || bsGetUByte2 != 'A' || bsGetUByte3 != 'Y' || bsGetUByte4 != '&' || bsGetUByte5 != 'S' || bsGetUByte6 != 'Y') {\n                 this.currentState = 0;\n                 throw new IOException(\"Bad block header\");\n             }\n             this.storedBlockCRC = bsGetInt(bin);\n             this.blockRandomised = (bsR(bin, 1) == 1);\n             if (this.data == null) {\n                 this.data = new BZip2CompressorInputStream.Data(this.blockSize100k);\n@@ -395,56 +394,56 @@\n             this.currentState = 1;\n         } while (!this.complete());\n     }\n     \n     private void makeMaps() {\n         final boolean[] inUse = this.data.inUse;\n         final byte[] seqToUnseq = this.data.seqToUnseq;\n-        int nInUseShadow = 0;\n+        int nInUse = 0;\n         for (int i = 0; i < 256; ++i) {\n             if (inUse[i]) {\n-                seqToUnseq[nInUseShadow++] = (byte)i;\n+                seqToUnseq[nInUse++] = (byte)i;\n             }\n         }\n-        this.nInUse = nInUseShadow;\n+        this.nInUse = nInUse;\n     }\n     \n     public int read() throws IOException {\n         if (this.bin != null) {\n-            final int r = this.read0();\n-            this.count((r < 0) ? -1 : 1);\n-            return r;\n+            final int read0 = this.read0();\n+            this.count((read0 < 0) ? -1 : 1);\n+            return read0;\n         }\n         throw new IOException(\"Stream closed\");\n     }\n     \n-    public int read(final byte[] dest, final int offs, final int len) throws IOException {\n-        if (offs < 0) {\n-            throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\");\n+    public int read(final byte[] array, final int n, final int n2) throws IOException {\n+        if (n < 0) {\n+            throw new IndexOutOfBoundsException(\"offs(\" + n + \") < 0.\");\n         }\n-        if (len < 0) {\n-            throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\");\n+        if (n2 < 0) {\n+            throw new IndexOutOfBoundsException(\"len(\" + n2 + \") < 0.\");\n         }\n-        if (offs + len > dest.length) {\n-            throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\" + len + \") > dest.length(\" + dest.length + \").\");\n+        if (n + n2 > array.length) {\n+            throw new IndexOutOfBoundsException(\"offs(\" + n + \") + len(\" + n2 + \") > dest.length(\" + array.length + \").\");\n         }\n         if (this.bin == null) {\n             throw new IOException(\"Stream closed\");\n         }\n-        if (len == 0) {\n+        if (n2 == 0) {\n             return 0;\n         }\n-        final int hi = offs + len;\n-        int destOffs = offs;\n-        int b;\n-        while (destOffs < hi && (b = this.read0()) >= 0) {\n-            dest[destOffs++] = (byte)b;\n+        final int n3 = n + n2;\n+        int n4 = n;\n+        int read0;\n+        while (n4 < n3 && (read0 = this.read0()) >= 0) {\n+            array[n4++] = (byte)read0;\n             this.count(1);\n         }\n-        return (destOffs == offs) ? -1 : (destOffs - offs);\n+        return (n4 == n) ? -1 : (n4 - n);\n     }\n     \n     private int read0() throws IOException {\n         switch (this.currentState) {\n             case 0: {\n                 return -1;\n             }\n@@ -471,139 +470,137 @@\n             }\n             default: {\n                 throw new IllegalStateException();\n             }\n         }\n     }\n     \n-    private int readNextByte(final BitInputStream in) throws IOException {\n-        final long b = in.readBits(8);\n-        return (int)b;\n+    private int readNextByte(final BitInputStream bitInputStream) throws IOException {\n+        return (int)bitInputStream.readBits(8);\n     }\n     \n     private void recvDecodingTables() throws IOException {\n         final BitInputStream bin = this.bin;\n-        final BZip2CompressorInputStream.Data dataShadow = this.data;\n-        final boolean[] inUse = dataShadow.inUse;\n-        final byte[] pos = dataShadow.recvDecodingTables_pos;\n-        final byte[] selector = dataShadow.selector;\n-        final byte[] selectorMtf = dataShadow.selectorMtf;\n-        int inUse2 = 0;\n+        final BZip2CompressorInputStream.Data data = this.data;\n+        final boolean[] inUse = data.inUse;\n+        final byte[] recvDecodingTables_pos = data.recvDecodingTables_pos;\n+        final byte[] selector = data.selector;\n+        final byte[] selectorMtf = data.selectorMtf;\n+        int n = 0;\n         for (int i = 0; i < 16; ++i) {\n             if (bsGetBit(bin)) {\n-                inUse2 |= 1 << i;\n+                n |= 1 << i;\n             }\n         }\n         Arrays.fill(inUse, false);\n-        for (int i = 0; i < 16; ++i) {\n-            if ((inUse2 & 1 << i) != 0x0) {\n-                final int i2 = i << 4;\n-                for (int j = 0; j < 16; ++j) {\n+        for (int j = 0; j < 16; ++j) {\n+            if ((n & 1 << j) != 0x0) {\n+                final int n2 = j << 4;\n+                for (int k = 0; k < 16; ++k) {\n                     if (bsGetBit(bin)) {\n-                        inUse[i2 + j] = true;\n+                        inUse[n2 + k] = true;\n                     }\n                 }\n             }\n         }\n         this.makeMaps();\n-        final int alphaSize = this.nInUse + 2;\n-        final int nGroups = bsR(bin, 3);\n-        final int selectors = bsR(bin, 15);\n-        if (selectors < 0) {\n+        final int n3 = this.nInUse + 2;\n+        final int bsR = bsR(bin, 3);\n+        final int bsR2 = bsR(bin, 15);\n+        if (bsR2 < 0) {\n             throw new IOException(\"Corrupted input, nSelectors value negative\");\n         }\n-        checkBounds(alphaSize, 259, \"alphaSize\");\n-        checkBounds(nGroups, 7, \"nGroups\");\n-        for (int k = 0; k < selectors; ++k) {\n-            int l = 0;\n+        checkBounds(n3, 259, \"alphaSize\");\n+        checkBounds(bsR, 7, \"nGroups\");\n+        for (int l = 0; l < bsR2; ++l) {\n+            int n4 = 0;\n             while (bsGetBit(bin)) {\n-                ++l;\n+                ++n4;\n             }\n-            if (k < 18002) {\n-                selectorMtf[k] = (byte)l;\n+            if (l < 18002) {\n+                selectorMtf[l] = (byte)n4;\n             }\n         }\n-        final int nSelectors = Math.min(selectors, 18002);\n-        int v = nGroups;\n-        while (--v >= 0) {\n-            pos[v] = (byte)v;\n-        }\n-        for (int m = 0; m < nSelectors; ++m) {\n-            int v2 = selectorMtf[m] & 0xFF;\n-            checkBounds(v2, 6, \"selectorMtf\");\n-            final byte tmp = pos[v2];\n-            while (v2 > 0) {\n-                pos[v2] = pos[v2 - 1];\n-                --v2;\n-            }\n-            selector[m] = (pos[0] = tmp);\n-        }\n-        final char[][] len = dataShadow.temp_charArray2d;\n-        for (int t = 0; t < nGroups; ++t) {\n-            int curr = bsR(bin, 5);\n-            final char[] len_t = len[t];\n-            for (int i3 = 0; i3 < alphaSize; ++i3) {\n+        final int min = Math.min(bsR2, 18002);\n+        int n5 = bsR;\n+        while (--n5 >= 0) {\n+            recvDecodingTables_pos[n5] = (byte)n5;\n+        }\n+        for (int n6 = 0; n6 < min; ++n6) {\n+            int n7 = selectorMtf[n6] & 0xFF;\n+            checkBounds(n7, 6, \"selectorMtf\");\n+            final byte b = recvDecodingTables_pos[n7];\n+            while (n7 > 0) {\n+                recvDecodingTables_pos[n7] = recvDecodingTables_pos[n7 - 1];\n+                --n7;\n+            }\n+            selector[n6] = (recvDecodingTables_pos[0] = b);\n+        }\n+        final char[][] temp_charArray2d = data.temp_charArray2d;\n+        for (int n8 = 0; n8 < bsR; ++n8) {\n+            int bsR3 = bsR(bin, 5);\n+            final char[] array = temp_charArray2d[n8];\n+            for (int n9 = 0; n9 < n3; ++n9) {\n                 while (bsGetBit(bin)) {\n-                    curr += (bsGetBit(bin) ? -1 : 1);\n+                    bsR3 += (bsGetBit(bin) ? -1 : 1);\n                 }\n-                len_t[i3] = (char)curr;\n+                array[n9] = (char)bsR3;\n             }\n         }\n-        this.createHuffmanDecodingTables(alphaSize, nGroups);\n+        this.createHuffmanDecodingTables(n3, bsR);\n     }\n     \n     private int setupBlock() throws IOException {\n         if (this.currentState == 0 || this.data == null) {\n             return -1;\n         }\n         final int[] cftab = this.data.cftab;\n-        final int ttLen = this.last + 1;\n-        final int[] tt = this.data.initTT(ttLen);\n+        final int n = this.last + 1;\n+        final int[] initTT = this.data.initTT(n);\n         final byte[] ll8 = this.data.ll8;\n         cftab[0] = 0;\n         System.arraycopy(this.data.unzftab, 0, cftab, 1, 256);\n         int i = 1;\n-        int c = cftab[0];\n+        int n2 = cftab[0];\n         while (i <= 256) {\n-            c += cftab[i];\n-            cftab[i] = c;\n+            n2 += cftab[i];\n+            cftab[i] = n2;\n             ++i;\n         }\n-        i = 0;\n-        for (int lastShadow = this.last; i <= lastShadow; ++i) {\n-            final int tmp = cftab[ll8[i] & 0xFF]++;\n-            checkBounds(tmp, ttLen, \"tt index\");\n-            tt[tmp] = i;\n+        for (int j = 0; j <= this.last; ++j) {\n+            final int n3 = cftab[ll8[j] & 0xFF]++;\n+            checkBounds(n3, n, \"tt index\");\n+            initTT[n3] = j;\n         }\n-        if (this.origPtr < 0 || this.origPtr >= tt.length) {\n+        if (this.origPtr < 0 || this.origPtr >= initTT.length) {\n             throw new IOException(\"Stream corrupted\");\n         }\n-        this.su_tPos = tt[this.origPtr];\n+        this.su_tPos = initTT[this.origPtr];\n         this.su_count = 0;\n         this.su_i2 = 0;\n         this.su_ch2 = 256;\n         if (this.blockRandomised) {\n             this.su_rNToGo = 0;\n             this.su_rTPos = 0;\n             return this.setupRandPartA();\n         }\n         return this.setupNoRandPartA();\n     }\n     \n     private int setupNoRandPartA() throws IOException {\n         if (this.su_i2 <= this.last) {\n             this.su_chPrev = this.su_ch2;\n-            final int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xFF;\n-            this.su_ch2 = su_ch2Shadow;\n+            final int su_ch2 = this.data.ll8[this.su_tPos] & 0xFF;\n+            this.su_ch2 = su_ch2;\n             checkBounds(this.su_tPos, this.data.tt.length, \"su_tPos\");\n             this.su_tPos = this.data.tt[this.su_tPos];\n             ++this.su_i2;\n             this.currentState = 6;\n-            this.crc.updateCRC(su_ch2Shadow);\n-            return su_ch2Shadow;\n+            this.crc.updateCRC(su_ch2);\n+            return su_ch2;\n         }\n         this.currentState = 5;\n         this.endBlock();\n         this.initBlock();\n         return this.setupBlock();\n     }\n     \n@@ -620,45 +617,45 @@\n             return this.setupNoRandPartC();\n         }\n         return this.setupNoRandPartA();\n     }\n     \n     private int setupNoRandPartC() throws IOException {\n         if (this.su_j2 < this.su_z) {\n-            final int su_ch2Shadow = this.su_ch2;\n-            this.crc.updateCRC(su_ch2Shadow);\n+            final int su_ch2 = this.su_ch2;\n+            this.crc.updateCRC(su_ch2);\n             ++this.su_j2;\n             this.currentState = 7;\n-            return su_ch2Shadow;\n+            return su_ch2;\n         }\n         ++this.su_i2;\n         this.su_count = 0;\n         return this.setupNoRandPartA();\n     }\n     \n     private int setupRandPartA() throws IOException {\n         if (this.su_i2 <= this.last) {\n             this.su_chPrev = this.su_ch2;\n-            int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xFF;\n+            final int n = this.data.ll8[this.su_tPos] & 0xFF;\n             checkBounds(this.su_tPos, this.data.tt.length, \"su_tPos\");\n             this.su_tPos = this.data.tt[this.su_tPos];\n             if (this.su_rNToGo == 0) {\n                 this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1;\n                 if (++this.su_rTPos == 512) {\n                     this.su_rTPos = 0;\n                 }\n             }\n             else {\n                 --this.su_rNToGo;\n             }\n-            su_ch2Shadow = (this.su_ch2 = (su_ch2Shadow ^ ((this.su_rNToGo == 1) ? 1 : 0)));\n+            final int n2 = this.su_ch2 = (n ^ ((this.su_rNToGo == 1) ? 1 : 0));\n             ++this.su_i2;\n             this.currentState = 3;\n-            this.crc.updateCRC(su_ch2Shadow);\n-            return su_ch2Shadow;\n+            this.crc.updateCRC(n2);\n+            return n2;\n         }\n         this.endBlock();\n         this.initBlock();\n         return this.setupBlock();\n     }\n     \n     private int setupRandPartB() throws IOException {\n"}]}
