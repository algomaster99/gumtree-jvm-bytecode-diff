{"diffoscope-json-version": 1, "source1": "first/JavaClass.class", "source2": "second/JavaClass.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -46,14 +46,20 @@\n     private AnnotationEntry[] annotations;\n     private byte source;\n     private boolean isAnonymous;\n     private boolean isNested;\n     private boolean computedNestedTypeStatus;\n     private transient Repository repository;\n     \n+    static {\n+        EMPTY_ARRAY = new JavaClass[0];\n+        debug = Boolean.getBoolean(\"JavaClass.debug\");\n+        JavaClass.bcelComparator = (BCELComparator)new JavaClass.JavaClass$1();\n+    }\n+    \n     static void Debug(final String str) {\n         if (JavaClass.debug) {\n             System.out.println(str);\n         }\n     }\n     \n     public static BCELComparator getComparator() {\n@@ -101,15 +107,17 @@\n         this.minor = minor;\n         this.constantPool = constantPool;\n         this.interfaces = interfaces;\n         this.fields = fields;\n         this.methods = methods;\n         this.attributes = attributes;\n         this.source = source;\n-        for (final Attribute attribute : attributes) {\n+        Attribute[] array;\n+        for (int length = (array = attributes).length, j = 0; j < length; ++j) {\n+            final Attribute attribute = array[j];\n             if (attribute instanceof SourceFile) {\n                 this.sourceFileName = ((SourceFile)attribute).getSourceFileName();\n                 break;\n             }\n         }\n         this.className = constantPool.getConstantString(classNameIndex, (byte)7);\n         this.className = Utility.compactClassName(this.className, false);\n@@ -142,15 +150,17 @@\n         return this.getClassName().compareTo(obj.getClassName());\n     }\n     \n     private void computeNestedTypeStatus() {\n         if (this.computedNestedTypeStatus) {\n             return;\n         }\n-        for (final Attribute attribute : this.attributes) {\n+        Attribute[] attributes;\n+        for (int length = (attributes = this.attributes).length, i = 0; i < length; ++i) {\n+            final Attribute attribute = attributes[i];\n             if (attribute instanceof InnerClasses) {\n                 ((InnerClasses)attribute).forEach(innerClass -> {\n                     boolean innerClassAttributeRefersToMe = false;\n                     final String innerClassName = this.constantPool.getConstantString(innerClass.getInnerClassIndex(), (byte)7);\n                     final String innerClassName2 = Utility.compactClassName(innerClassName, false);\n                     if (innerClassName2.equals(this.getClassName())) {\n                         innerClassAttributeRefersToMe = true;\n@@ -170,17 +180,17 @@\n     \n     public JavaClass copy() {\n         try {\n             final JavaClass c = (JavaClass)this.clone();\n             c.constantPool = this.constantPool.copy();\n             c.interfaces = this.interfaces.clone();\n             c.interfaceNames = this.interfaceNames.clone();\n-            Arrays.setAll(c.fields = new Field[this.fields.length], i -> this.fields[i].copy(c.constantPool));\n-            Arrays.setAll(c.methods = new Method[this.methods.length], i -> this.methods[i].copy(c.constantPool));\n-            Arrays.setAll(c.attributes = new Attribute[this.attributes.length], i -> this.attributes[i].copy(c.constantPool));\n+            Arrays.setAll(c.fields = new Field[this.fields.length], i -> this.fields[i].copy(javaClass.constantPool));\n+            Arrays.setAll(c.methods = new Method[this.methods.length], i -> this.methods[i].copy(javaClass2.constantPool));\n+            Arrays.setAll(c.attributes = new Attribute[this.attributes.length], i -> this.attributes[i].copy(javaClass3.constantPool));\n             return c;\n         }\n         catch (final CloneNotSupportedException e) {\n             return null;\n         }\n     }\n     \n@@ -189,28 +199,36 @@\n         file.writeShort(this.minor);\n         file.writeShort(this.major);\n         this.constantPool.dump(file);\n         file.writeShort(super.getAccessFlags());\n         file.writeShort(this.classNameIndex);\n         file.writeShort(this.superclassNameIndex);\n         file.writeShort(this.interfaces.length);\n-        for (final int interface1 : this.interfaces) {\n+        int[] interfaces;\n+        for (int length = (interfaces = this.interfaces).length, i = 0; i < length; ++i) {\n+            final int interface1 = interfaces[i];\n             file.writeShort(interface1);\n         }\n         file.writeShort(this.fields.length);\n-        for (final Field field : this.fields) {\n+        Field[] fields;\n+        for (int length2 = (fields = this.fields).length, j = 0; j < length2; ++j) {\n+            final Field field = fields[j];\n             field.dump(file);\n         }\n         file.writeShort(this.methods.length);\n-        for (final Method method : this.methods) {\n+        Method[] methods;\n+        for (int length3 = (methods = this.methods).length, k = 0; k < length3; ++k) {\n+            final Method method = methods[k];\n             method.dump(file);\n         }\n         if (this.attributes != null) {\n             file.writeShort(this.attributes.length);\n-            for (final Attribute attribute : this.attributes) {\n+            Attribute[] attributes;\n+            for (int length4 = (attributes = this.attributes).length, l = 0; l < length4; ++l) {\n+                final Attribute attribute = attributes[l];\n                 attribute.dump(file);\n             }\n         }\n         else {\n             file.writeShort(0);\n         }\n         file.flush();\n@@ -220,16 +238,37 @@\n         final String parent = file.getParent();\n         if (parent != null) {\n             final File dir = new File(parent);\n             if (!dir.mkdirs() && !dir.isDirectory()) {\n                 throw new IOException(\"Could not create the directory \" + dir);\n             }\n         }\n-        try (final DataOutputStream dos = new DataOutputStream(new FileOutputStream(file))) {\n-            this.dump(dos);\n+        Throwable t = null;\n+        try {\n+            final DataOutputStream dos = new DataOutputStream(new FileOutputStream(file));\n+            try {\n+                this.dump(dos);\n+            }\n+            finally {\n+                if (dos != null) {\n+                    dos.close();\n+                }\n+            }\n+        }\n+        finally {\n+            if (t == null) {\n+                final Throwable exception;\n+                t = exception;\n+            }\n+            else {\n+                final Throwable exception;\n+                if (t != exception) {\n+                    t.addSuppressed(exception);\n+                }\n+            }\n         }\n     }\n     \n     public void dump(final OutputStream file) throws IOException {\n         this.dump(new DataOutputStream(file));\n     }\n     \n@@ -251,15 +290,17 @@\n             final JavaClass[] interfaces = clazz.getInterfaces();\n             if (clazz.isInterface()) {\n                 allInterfaces.add(clazz);\n             }\n             else if (souper != null) {\n                 queue.enqueue(souper);\n             }\n-            for (final JavaClass iface : interfaces) {\n+            JavaClass[] array;\n+            for (int length = (array = interfaces).length, i = 0; i < length; ++i) {\n+                final JavaClass iface = array[i];\n                 queue.enqueue(iface);\n             }\n         }\n         return allInterfaces.toArray(JavaClass.EMPTY_ARRAY);\n     }\n     \n     public AnnotationEntry[] getAnnotationEntries() {\n@@ -271,16 +312,39 @@\n     \n     public Attribute[] getAttributes() {\n         return this.attributes;\n     }\n     \n     public byte[] getBytes() {\n         final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        try (final DataOutputStream dos = new DataOutputStream(baos)) {\n-            this.dump(dos);\n+        try {\n+            Throwable t = null;\n+            try {\n+                final DataOutputStream dos = new DataOutputStream(baos);\n+                try {\n+                    this.dump(dos);\n+                }\n+                finally {\n+                    if (dos != null) {\n+                        dos.close();\n+                    }\n+                }\n+            }\n+            finally {\n+                if (t == null) {\n+                    final Throwable exception;\n+                    t = exception;\n+                }\n+                else {\n+                    final Throwable exception;\n+                    if (t != exception) {\n+                        t.addSuppressed(exception);\n+                    }\n+                }\n+            }\n         }\n         catch (final IOException e) {\n             e.printStackTrace();\n         }\n         return baos.toByteArray();\n     }\n     \n@@ -322,15 +386,17 @@\n     }\n     \n     public int getMajor() {\n         return this.major;\n     }\n     \n     public Method getMethod(final java.lang.reflect.Method m) {\n-        for (final Method method : this.methods) {\n+        Method[] methods;\n+        for (int length = (methods = this.methods).length, i = 0; i < length; ++i) {\n+            final Method method = methods[i];\n             if (m.getName().equals(method.getName()) && m.getModifiers() == method.getModifiers() && Type.getSignature(m).equals(method.getSignature())) {\n                 return method;\n             }\n         }\n         return null;\n     }\n     \n@@ -384,34 +450,37 @@\n     \n     public int hashCode() {\n         return JavaClass.bcelComparator.hashCode((Object)this);\n     }\n     \n     public boolean implementationOf(final JavaClass inter) throws ClassNotFoundException {\n         if (!inter.isInterface()) {\n-            throw new IllegalArgumentException(inter.getClassName() + \" is no interface\");\n+            throw new IllegalArgumentException(String.valueOf(inter.getClassName()) + \" is no interface\");\n         }\n         if (this.equals(inter)) {\n             return true;\n         }\n-        final JavaClass[] allInterfaces;\n-        final JavaClass[] superInterfaces = allInterfaces = this.getAllInterfaces();\n-        for (final JavaClass superInterface : allInterfaces) {\n+        final JavaClass[] superInterfaces = this.getAllInterfaces();\n+        JavaClass[] array;\n+        for (int length = (array = superInterfaces).length, i = 0; i < length; ++i) {\n+            final JavaClass superInterface = array[i];\n             if (superInterface.equals(inter)) {\n                 return true;\n             }\n         }\n         return false;\n     }\n     \n     public final boolean instanceOf(final JavaClass superclass) throws ClassNotFoundException {\n         if (this.equals(superclass)) {\n             return true;\n         }\n-        for (final JavaClass clazz : this.getSuperClasses()) {\n+        JavaClass[] superClasses;\n+        for (int length = (superClasses = this.getSuperClasses()).length, i = 0; i < length; ++i) {\n+            final JavaClass clazz = superClasses[i];\n             if (clazz.equals(superclass)) {\n                 return true;\n             }\n         }\n         return superclass.isInterface() && this.implementationOf(superclass);\n     }\n     \n@@ -491,15 +560,15 @@\n     \n     public void setSuperclassNameIndex(final int superclassNameIndex) {\n         this.superclassNameIndex = superclassNameIndex;\n     }\n     \n     public String toString() {\n         String access = Utility.accessToString(super.getAccessFlags(), true);\n-        access = (access.isEmpty() ? \"\" : (access + \" \"));\n+        access = (access.isEmpty() ? \"\" : (String.valueOf(access) + \" \"));\n         final StringBuilder buf = new StringBuilder(128);\n         buf.append(access).append(Utility.classOrInterface(super.getAccessFlags())).append(\" \").append(this.className).append(\" extends \").append(Utility.compactClassName(this.superclassName, false)).append('\\n');\n         final int size = this.interfaces.length;\n         if (size > 0) {\n             buf.append(\"implements\\t\\t\");\n             for (int i = 0; i < size; ++i) {\n                 buf.append(this.interfaceNames[i]);\n@@ -513,39 +582,41 @@\n         buf.append(\"compiled from\\t\\t\").append(this.sourceFileName).append('\\n');\n         buf.append(\"compiler version\\t\").append(this.major).append(\".\").append(this.minor).append('\\n');\n         buf.append(\"access flags\\t\\t\").append(super.getAccessFlags()).append('\\n');\n         buf.append(\"constant pool\\t\\t\").append(this.constantPool.getLength()).append(\" entries\\n\");\n         buf.append(\"ACC_SUPER flag\\t\\t\").append(this.isSuper()).append(\"\\n\");\n         if (this.attributes.length > 0) {\n             buf.append(\"\\nAttribute(s):\\n\");\n-            for (final Attribute attribute : this.attributes) {\n+            Attribute[] attributes;\n+            for (int length = (attributes = this.attributes).length, j = 0; j < length; ++j) {\n+                final Attribute attribute = attributes[j];\n                 buf.append(indent((Object)attribute));\n             }\n         }\n         final AnnotationEntry[] annotations = this.getAnnotationEntries();\n         if (annotations != null && annotations.length > 0) {\n             buf.append(\"\\nAnnotation(s):\\n\");\n-            for (final AnnotationEntry annotation : annotations) {\n+            AnnotationEntry[] array;\n+            for (int length2 = (array = annotations).length, k = 0; k < length2; ++k) {\n+                final AnnotationEntry annotation = array[k];\n                 buf.append(indent((Object)annotation));\n             }\n         }\n         if (this.fields.length > 0) {\n             buf.append(\"\\n\").append(this.fields.length).append(\" fields:\\n\");\n-            for (final Field field : this.fields) {\n+            Field[] fields;\n+            for (int length3 = (fields = this.fields).length, l = 0; l < length3; ++l) {\n+                final Field field = fields[l];\n                 buf.append(\"\\t\").append(field).append('\\n');\n             }\n         }\n         if (this.methods.length > 0) {\n             buf.append(\"\\n\").append(this.methods.length).append(\" methods:\\n\");\n-            for (final Method method : this.methods) {\n+            Method[] methods;\n+            for (int length4 = (methods = this.methods).length, n = 0; n < length4; ++n) {\n+                final Method method = methods[n];\n                 buf.append(\"\\t\").append(method).append('\\n');\n             }\n         }\n         return buf.toString();\n     }\n-    \n-    static {\n-        EMPTY_ARRAY = new JavaClass[0];\n-        debug = Boolean.getBoolean(\"JavaClass.debug\");\n-        JavaClass.bcelComparator = (BCELComparator)new JavaClass.JavaClass$1();\n-    }\n }\n"}]}
