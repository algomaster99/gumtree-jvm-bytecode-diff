{"diffoscope-json-version": 1, "source1": "first/PercentCodec.class", "source2": "second/PercentCodec.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -20,156 +20,151 @@\n         this.alwaysEncodeChars = new BitSet();\n         this.alwaysEncodeCharsMin = Integer.MAX_VALUE;\n         this.alwaysEncodeCharsMax = Integer.MIN_VALUE;\n         this.plusForSpace = false;\n         this.insertAlwaysEncodeChar((byte)37);\n     }\n     \n-    public PercentCodec(final byte[] alwaysEncodeChars, final boolean plusForSpace) {\n+    public PercentCodec(final byte[] array, final boolean plusForSpace) {\n         this.alwaysEncodeChars = new BitSet();\n         this.alwaysEncodeCharsMin = Integer.MAX_VALUE;\n         this.alwaysEncodeCharsMax = Integer.MIN_VALUE;\n         this.plusForSpace = plusForSpace;\n-        this.insertAlwaysEncodeChars(alwaysEncodeChars);\n+        this.insertAlwaysEncodeChars(array);\n     }\n     \n-    private void insertAlwaysEncodeChars(final byte[] alwaysEncodeCharsArray) {\n-        if (alwaysEncodeCharsArray != null) {\n-            for (final byte b : alwaysEncodeCharsArray) {\n-                this.insertAlwaysEncodeChar(b);\n+    private void insertAlwaysEncodeChars(final byte[] array) {\n+        if (array != null) {\n+            for (int length = array.length, i = 0; i < length; ++i) {\n+                this.insertAlwaysEncodeChar(array[i]);\n             }\n         }\n         this.insertAlwaysEncodeChar((byte)37);\n     }\n     \n-    private void insertAlwaysEncodeChar(final byte b) {\n-        this.alwaysEncodeChars.set(b);\n-        if (b < this.alwaysEncodeCharsMin) {\n-            this.alwaysEncodeCharsMin = b;\n+    private void insertAlwaysEncodeChar(final byte alwaysEncodeCharsMax) {\n+        this.alwaysEncodeChars.set(alwaysEncodeCharsMax);\n+        if (alwaysEncodeCharsMax < this.alwaysEncodeCharsMin) {\n+            this.alwaysEncodeCharsMin = alwaysEncodeCharsMax;\n         }\n-        if (b > this.alwaysEncodeCharsMax) {\n-            this.alwaysEncodeCharsMax = b;\n+        if (alwaysEncodeCharsMax > this.alwaysEncodeCharsMax) {\n+            this.alwaysEncodeCharsMax = alwaysEncodeCharsMax;\n         }\n     }\n     \n-    public byte[] encode(final byte[] bytes) throws EncoderException {\n-        if (bytes == null) {\n+    public byte[] encode(final byte[] array) throws EncoderException {\n+        if (array == null) {\n             return null;\n         }\n-        final int expectedEncodingBytes = this.expectedEncodingBytes(bytes);\n-        final boolean willEncode = expectedEncodingBytes != bytes.length;\n-        if (willEncode || (this.plusForSpace && this.containsSpace(bytes))) {\n-            return this.doEncode(bytes, expectedEncodingBytes, willEncode);\n-        }\n-        return bytes;\n+        final int expectedEncodingBytes = this.expectedEncodingBytes(array);\n+        final boolean b = expectedEncodingBytes != array.length;\n+        if (b || (this.plusForSpace && this.containsSpace(array))) {\n+            return this.doEncode(array, expectedEncodingBytes, b);\n+        }\n+        return array;\n     }\n     \n-    private byte[] doEncode(final byte[] bytes, final int expectedLength, final boolean willEncode) {\n-        final ByteBuffer buffer = ByteBuffer.allocate(expectedLength);\n-        for (final byte b : bytes) {\n-            if (willEncode && this.canEncode(b)) {\n-                byte bb = b;\n-                if (bb < 0) {\n-                    bb += 256;\n+    private byte[] doEncode(final byte[] array, final int capacity, final boolean b) {\n+        final ByteBuffer allocate = ByteBuffer.allocate(capacity);\n+        for (final byte b2 : array) {\n+            if (b && this.canEncode(b2)) {\n+                byte b3 = b2;\n+                if (b3 < 0) {\n+                    b3 += 256;\n                 }\n-                final char hex1 = Utils.hexDigit(bb >> 4);\n-                final char hex2 = Utils.hexDigit((int)bb);\n-                buffer.put((byte)37);\n-                buffer.put((byte)hex1);\n-                buffer.put((byte)hex2);\n+                final char hexDigit = Utils.hexDigit(b3 >> 4);\n+                final char hexDigit2 = Utils.hexDigit((int)b3);\n+                allocate.put((byte)37);\n+                allocate.put((byte)hexDigit);\n+                allocate.put((byte)hexDigit2);\n             }\n-            else if (this.plusForSpace && b == 32) {\n-                buffer.put((byte)43);\n+            else if (this.plusForSpace && b2 == 32) {\n+                allocate.put((byte)43);\n             }\n             else {\n-                buffer.put(b);\n+                allocate.put(b2);\n             }\n         }\n-        return buffer.array();\n+        return allocate.array();\n     }\n     \n-    private int expectedEncodingBytes(final byte[] bytes) {\n-        int byteCount = 0;\n-        for (final byte b : bytes) {\n-            byteCount += (this.canEncode(b) ? 3 : 1);\n+    private int expectedEncodingBytes(final byte[] array) {\n+        int n = 0;\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            n += (this.canEncode(array[i]) ? 3 : 1);\n         }\n-        return byteCount;\n+        return n;\n     }\n     \n-    private boolean containsSpace(final byte[] bytes) {\n-        for (final byte b : bytes) {\n-            if (b == 32) {\n+    private boolean containsSpace(final byte[] array) {\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            if (array[i] == 32) {\n                 return true;\n             }\n         }\n         return false;\n     }\n     \n-    private boolean canEncode(final byte c) {\n-        return !this.isAsciiChar(c) || (this.inAlwaysEncodeCharsRange(c) && this.alwaysEncodeChars.get(c));\n+    private boolean canEncode(final byte bitIndex) {\n+        return !this.isAsciiChar(bitIndex) || (this.inAlwaysEncodeCharsRange(bitIndex) && this.alwaysEncodeChars.get(bitIndex));\n     }\n     \n-    private boolean inAlwaysEncodeCharsRange(final byte c) {\n-        return c >= this.alwaysEncodeCharsMin && c <= this.alwaysEncodeCharsMax;\n+    private boolean inAlwaysEncodeCharsRange(final byte b) {\n+        return b >= this.alwaysEncodeCharsMin && b <= this.alwaysEncodeCharsMax;\n     }\n     \n-    private boolean isAsciiChar(final byte c) {\n-        return c >= 0;\n+    private boolean isAsciiChar(final byte b) {\n+        return b >= 0;\n     }\n     \n-    public byte[] decode(final byte[] bytes) throws DecoderException {\n-        if (bytes == null) {\n+    public byte[] decode(final byte[] array) throws DecoderException {\n+        if (array == null) {\n             return null;\n         }\n-        final ByteBuffer buffer = ByteBuffer.allocate(this.expectedDecodingBytes(bytes));\n-        for (int i = 0; i < bytes.length; ++i) {\n-            final byte b = bytes[i];\n+        final ByteBuffer allocate = ByteBuffer.allocate(this.expectedDecodingBytes(array));\n+        for (int i = 0; i < array.length; ++i) {\n+            final byte b = array[i];\n             if (b == 37) {\n                 try {\n-                    final int u = Utils.digit16(bytes[++i]);\n-                    final int l = Utils.digit16(bytes[++i]);\n-                    buffer.put((byte)((u << 4) + l));\n+                    allocate.put((byte)((Utils.digit16(array[++i]) << 4) + Utils.digit16(array[++i])));\n                     continue;\n                 }\n-                catch (final ArrayIndexOutOfBoundsException e) {\n-                    throw new DecoderException(\"Invalid percent decoding: \", (Throwable)e);\n+                catch (final ArrayIndexOutOfBoundsException ex) {\n+                    throw new DecoderException(\"Invalid percent decoding: \", (Throwable)ex);\n                 }\n             }\n             if (this.plusForSpace && b == 43) {\n-                buffer.put((byte)32);\n+                allocate.put((byte)32);\n             }\n             else {\n-                buffer.put(b);\n+                allocate.put(b);\n             }\n         }\n-        return buffer.array();\n+        return allocate.array();\n     }\n     \n-    private int expectedDecodingBytes(final byte[] bytes) {\n-        int byteCount = 0;\n-        byte b;\n-        for (int i = 0; i < bytes.length; i += ((b == 37) ? 3 : 1), ++byteCount) {\n-            b = bytes[i];\n-        }\n-        return byteCount;\n+    private int expectedDecodingBytes(final byte[] array) {\n+        int n = 0;\n+        for (int i = 0; i < array.length; i += ((array[i] == 37) ? 3 : 1), ++n) {}\n+        return n;\n     }\n     \n-    public Object encode(final Object obj) throws EncoderException {\n-        if (obj == null) {\n+    public Object encode(final Object o) throws EncoderException {\n+        if (o == null) {\n             return null;\n         }\n-        if (obj instanceof byte[]) {\n-            return this.encode((byte[])obj);\n+        if (o instanceof byte[]) {\n+            return this.encode((byte[])o);\n         }\n-        throw new EncoderException(\"Objects of type \" + obj.getClass().getName() + \" cannot be Percent encoded\");\n+        throw new EncoderException(\"Objects of type \" + o.getClass().getName() + \" cannot be Percent encoded\");\n     }\n     \n-    public Object decode(final Object obj) throws DecoderException {\n-        if (obj == null) {\n+    public Object decode(final Object o) throws DecoderException {\n+        if (o == null) {\n             return null;\n         }\n-        if (obj instanceof byte[]) {\n-            return this.decode((byte[])obj);\n+        if (o instanceof byte[]) {\n+            return this.decode((byte[])o);\n         }\n-        throw new DecoderException(\"Objects of type \" + obj.getClass().getName() + \" cannot be Percent decoded\");\n+        throw new DecoderException(\"Objects of type \" + o.getClass().getName() + \" cannot be Percent decoded\");\n     }\n }\n"}]}
