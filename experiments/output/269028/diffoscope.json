{"diffoscope-json-version": 1, "source1": "first/RequireThisCheck.class", "source2": "second/RequireThisCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,14 +1,14 @@\n \n package com.puppycrawl.tools.checkstyle.checks.coding;\n \n import java.util.HashSet;\n+import java.util.Set;\n import com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n import java.util.Iterator;\n-import java.util.Set;\n import com.puppycrawl.tools.checkstyle.utils.CheckUtil;\n import com.puppycrawl.tools.checkstyle.utils.ScopeUtil;\n import java.util.Queue;\n import java.util.LinkedList;\n import java.util.HashMap;\n import java.util.ArrayDeque;\n import com.puppycrawl.tools.checkstyle.api.DetailAST;\n@@ -59,57 +59,57 @@\n         return new int[] { 14, 15, 154, 157, 8, 9, 91, 7, 58, 199, 203, 95, 178 };\n     }\n     \n     public int[] getAcceptableTokens() {\n         return this.getRequiredTokens();\n     }\n     \n-    public void beginTree(final DetailAST rootAST) {\n+    public void beginTree(final DetailAST detailAST) {\n         this.frames = new HashMap<DetailAST, RequireThisCheck.AbstractFrame>();\n         this.current.clear();\n-        final Deque<RequireThisCheck.AbstractFrame> frameStack = new LinkedList<RequireThisCheck.AbstractFrame>();\n-        DetailAST toVisit;\n-        for (DetailAST curNode = rootAST; curNode != null; curNode = toVisit) {\n-            collectDeclarations(frameStack, curNode);\n-            for (toVisit = curNode.getFirstChild(); curNode != null && toVisit == null; toVisit = curNode.getNextSibling(), curNode = curNode.getParent()) {\n-                this.endCollectingDeclarations(frameStack, curNode);\n+        final LinkedList list = new LinkedList();\n+        DetailAST detailAST2;\n+        for (DetailAST parent = detailAST; parent != null; parent = detailAST2) {\n+            collectDeclarations(list, parent);\n+            for (detailAST2 = parent.getFirstChild(); parent != null && detailAST2 == null; detailAST2 = parent.getNextSibling(), parent = parent.getParent()) {\n+                this.endCollectingDeclarations(list, parent);\n             }\n         }\n     }\n     \n-    public void visitToken(final DetailAST ast) {\n-        switch (ast.getType()) {\n+    public void visitToken(final DetailAST detailAST) {\n+        switch (detailAST.getType()) {\n             case 58: {\n-                this.processIdent(ast);\n+                this.processIdent(detailAST);\n                 break;\n             }\n             case 7:\n             case 8:\n             case 9:\n             case 14:\n             case 15:\n             case 91:\n             case 154:\n             case 157:\n             case 199: {\n-                this.current.push(this.frames.get(ast));\n+                this.current.push(this.frames.get(detailAST));\n                 break;\n             }\n             case 95: {\n-                if (ast.getFirstChild().getType() == 176) {\n-                    this.current.push(this.frames.get(ast));\n+                if (detailAST.getFirstChild().getType() == 176) {\n+                    this.current.push(this.frames.get(detailAST));\n                     break;\n                 }\n                 break;\n             }\n         }\n     }\n     \n-    public void leaveToken(final DetailAST ast) {\n-        switch (ast.getType()) {\n+    public void leaveToken(final DetailAST detailAST) {\n+        switch (detailAST.getType()) {\n             case 7:\n             case 8:\n             case 9:\n             case 14:\n             case 15:\n             case 91:\n             case 154:\n@@ -124,515 +124,491 @@\n                     break;\n                 }\n                 break;\n             }\n         }\n     }\n     \n-    private void processIdent(final DetailAST ast) {\n-        int parentType = ast.getParent().getType();\n-        if (parentType == 28 && ast.getParent().getParent().getParent().getType() == 161) {\n-            parentType = 161;\n+    private void processIdent(final DetailAST detailAST) {\n+        int type = detailAST.getParent().getType();\n+        if (type == 28 && detailAST.getParent().getParent().getParent().getType() == 161) {\n+            type = 161;\n         }\n-        switch (parentType) {\n+        switch (type) {\n             case 159:\n             case 160:\n             case 161: {\n                 break;\n             }\n             case 27: {\n                 if (this.checkMethods) {\n-                    final RequireThisCheck.AbstractFrame frame = this.getMethodWithoutThis(ast);\n-                    if (frame != null) {\n-                        this.logViolation(\"require.this.method\", ast, frame);\n+                    final RequireThisCheck.AbstractFrame methodWithoutThis = this.getMethodWithoutThis(detailAST);\n+                    if (methodWithoutThis != null) {\n+                        this.logViolation(\"require.this.method\", detailAST, methodWithoutThis);\n                     }\n                     break;\n                 }\n                 break;\n             }\n             default: {\n                 if (!this.checkFields) {\n                     break;\n                 }\n-                final RequireThisCheck.AbstractFrame frame = this.getFieldWithoutThis(ast, parentType);\n-                final boolean canUseThis = !isInCompactConstructor(ast);\n-                if (frame != null && canUseThis) {\n-                    this.logViolation(\"require.this.variable\", ast, frame);\n+                final RequireThisCheck.AbstractFrame fieldWithoutThis = this.getFieldWithoutThis(detailAST, type);\n+                final boolean b = !isInCompactConstructor(detailAST);\n+                if (fieldWithoutThis != null && b) {\n+                    this.logViolation(\"require.this.variable\", detailAST, fieldWithoutThis);\n                     break;\n                 }\n                 break;\n             }\n         }\n     }\n     \n-    private void logViolation(final String msgKey, final DetailAST ast, final RequireThisCheck.AbstractFrame frame) {\n-        if (frame.getFrameName().equals(this.getNearestClassFrameName())) {\n-            this.log(ast, msgKey, new Object[] { ast.getText(), \"\" });\n+    private void logViolation(final String s, final DetailAST detailAST, final RequireThisCheck.AbstractFrame abstractFrame) {\n+        if (abstractFrame.getFrameName().equals(this.getNearestClassFrameName())) {\n+            this.log(detailAST, s, new Object[] { detailAST.getText(), \"\" });\n         }\n-        else if (!(frame instanceof RequireThisCheck.AnonymousClassFrame)) {\n-            this.log(ast, msgKey, new Object[] { ast.getText(), frame.getFrameName() });\n+        else if (!(abstractFrame instanceof RequireThisCheck.AnonymousClassFrame)) {\n+            this.log(detailAST, s, new Object[] { detailAST.getText(), abstractFrame.getFrameName() });\n         }\n     }\n     \n-    private RequireThisCheck.AbstractFrame getFieldWithoutThis(final DetailAST ast, final int parentType) {\n-        final boolean importOrPackage = ScopeUtil.getSurroundingScope(ast) == null;\n-        final boolean typeName = parentType == 13 || parentType == 136;\n-        RequireThisCheck.AbstractFrame frame = null;\n-        if (!importOrPackage && !typeName && !isDeclarationToken(parentType) && !isLambdaParameter(ast)) {\n-            final RequireThisCheck.AbstractFrame fieldFrame = this.findClassFrame(ast, false);\n-            if (fieldFrame != null && ((RequireThisCheck.ClassFrame)fieldFrame).hasInstanceMember(ast)) {\n-                frame = this.getClassFrameWhereViolationIsFound(ast);\n+    private RequireThisCheck.AbstractFrame getFieldWithoutThis(final DetailAST detailAST, final int n) {\n+        final boolean b = ScopeUtil.getSurroundingScope(detailAST) == null;\n+        final boolean b2 = n == 13 || n == 136;\n+        RequireThisCheck.AbstractFrame classFrameWhereViolationIsFound = null;\n+        if (!b && !b2 && !isDeclarationToken(n) && !isLambdaParameter(detailAST)) {\n+            final RequireThisCheck.AbstractFrame classFrame = this.findClassFrame(detailAST, false);\n+            if (classFrame != null && ((RequireThisCheck.ClassFrame)classFrame).hasInstanceMember(detailAST)) {\n+                classFrameWhereViolationIsFound = this.getClassFrameWhereViolationIsFound(detailAST);\n             }\n         }\n-        return frame;\n+        return classFrameWhereViolationIsFound;\n     }\n     \n-    private static boolean isInCompactConstructor(final DetailAST ast) {\n-        boolean isInCompactCtor = false;\n-        for (DetailAST parent = ast; parent != null; parent = parent.getParent()) {\n+    private static boolean isInCompactConstructor(final DetailAST detailAST) {\n+        boolean b = false;\n+        for (DetailAST parent = detailAST; parent != null; parent = parent.getParent()) {\n             if (parent.getType() == 203) {\n-                isInCompactCtor = true;\n+                b = true;\n                 break;\n             }\n         }\n-        return isInCompactCtor;\n+        return b;\n     }\n     \n-    private static void collectDeclarations(final Deque<RequireThisCheck.AbstractFrame> frameStack, final DetailAST ast) {\n-        final RequireThisCheck.AbstractFrame frame = (RequireThisCheck.AbstractFrame)frameStack.peek();\n-        switch (ast.getType()) {\n+    private static void collectDeclarations(final Deque<RequireThisCheck.AbstractFrame> deque, final DetailAST detailAST) {\n+        final RequireThisCheck.AbstractFrame abstractFrame = (RequireThisCheck.AbstractFrame)deque.peek();\n+        switch (detailAST.getType()) {\n             case 10: {\n-                collectVariableDeclarations(ast, frame);\n+                collectVariableDeclarations(detailAST, abstractFrame);\n                 break;\n             }\n             case 202: {\n-                final DetailAST componentIdent = ast.findFirstToken(58);\n-                ((RequireThisCheck.ClassFrame)frame).addInstanceMember(componentIdent);\n+                ((RequireThisCheck.ClassFrame)abstractFrame).addInstanceMember(detailAST.findFirstToken(58));\n                 break;\n             }\n             case 21: {\n-                if (!CheckUtil.isReceiverParameter(ast) && !isLambdaParameter(ast)) {\n-                    final DetailAST parameterIdent = ast.findFirstToken(58);\n-                    frame.addIdent(parameterIdent);\n+                if (!CheckUtil.isReceiverParameter(detailAST) && !isLambdaParameter(detailAST)) {\n+                    abstractFrame.addIdent(detailAST.findFirstToken(58));\n                     break;\n                 }\n                 break;\n             }\n             case 178: {\n-                final DetailAST resourceIdent = ast.findFirstToken(58);\n-                if (resourceIdent != null) {\n-                    frame.addIdent(resourceIdent);\n+                final DetailAST firstToken = detailAST.findFirstToken(58);\n+                if (firstToken != null) {\n+                    abstractFrame.addIdent(firstToken);\n                     break;\n                 }\n                 break;\n             }\n             case 14:\n             case 15:\n             case 154:\n             case 157:\n             case 199: {\n-                final DetailAST classFrameNameIdent = ast.findFirstToken(58);\n-                frameStack.addFirst((RequireThisCheck.AbstractFrame)new RequireThisCheck.ClassFrame(frame, classFrameNameIdent));\n+                deque.addFirst((RequireThisCheck.AbstractFrame)new RequireThisCheck.ClassFrame(abstractFrame, detailAST.findFirstToken(58)));\n                 break;\n             }\n             case 7: {\n-                frameStack.addFirst((RequireThisCheck.AbstractFrame)new RequireThisCheck.BlockFrame(frame, ast));\n+                deque.addFirst((RequireThisCheck.AbstractFrame)new RequireThisCheck.BlockFrame(abstractFrame, detailAST));\n                 break;\n             }\n             case 9: {\n-                collectMethodDeclarations(frameStack, ast, frame);\n+                collectMethodDeclarations(deque, detailAST, abstractFrame);\n                 break;\n             }\n             case 8:\n             case 203: {\n-                final DetailAST ctorFrameNameIdent = ast.findFirstToken(58);\n-                frameStack.addFirst((RequireThisCheck.AbstractFrame)new RequireThisCheck.ConstructorFrame(frame, ctorFrameNameIdent));\n+                deque.addFirst((RequireThisCheck.AbstractFrame)new RequireThisCheck.ConstructorFrame(abstractFrame, detailAST.findFirstToken(58)));\n                 break;\n             }\n             case 155: {\n-                final DetailAST ident = ast.findFirstToken(58);\n-                ((RequireThisCheck.ClassFrame)frame).addStaticMember(ident);\n+                ((RequireThisCheck.ClassFrame)abstractFrame).addStaticMember(detailAST.findFirstToken(58));\n                 break;\n             }\n             case 96: {\n-                final RequireThisCheck.AbstractFrame catchFrame = (RequireThisCheck.AbstractFrame)new RequireThisCheck.CatchFrame(frame, ast);\n-                frameStack.addFirst(catchFrame);\n+                deque.addFirst((RequireThisCheck.AbstractFrame)new RequireThisCheck.CatchFrame(abstractFrame, detailAST));\n                 break;\n             }\n             case 91: {\n-                final RequireThisCheck.AbstractFrame forFrame = (RequireThisCheck.AbstractFrame)new RequireThisCheck.ForFrame(frame, ast);\n-                frameStack.addFirst(forFrame);\n+                deque.addFirst((RequireThisCheck.AbstractFrame)new RequireThisCheck.ForFrame(abstractFrame, detailAST));\n                 break;\n             }\n             case 136: {\n-                if (isAnonymousClassDef(ast)) {\n-                    frameStack.addFirst((RequireThisCheck.AbstractFrame)new RequireThisCheck.AnonymousClassFrame(frame, ast.toString()));\n+                if (isAnonymousClassDef(detailAST)) {\n+                    deque.addFirst((RequireThisCheck.AbstractFrame)new RequireThisCheck.AnonymousClassFrame(abstractFrame, detailAST.toString()));\n                     break;\n                 }\n                 break;\n             }\n             case 95: {\n-                if (ast.getFirstChild().getType() == 176) {\n-                    frameStack.addFirst((RequireThisCheck.AbstractFrame)new RequireThisCheck.TryWithResourcesFrame(frame, ast));\n+                if (detailAST.getFirstChild().getType() == 176) {\n+                    deque.addFirst((RequireThisCheck.AbstractFrame)new RequireThisCheck.TryWithResourcesFrame(abstractFrame, detailAST));\n                     break;\n                 }\n                 break;\n             }\n         }\n     }\n     \n-    private static void collectVariableDeclarations(final DetailAST ast, final RequireThisCheck.AbstractFrame frame) {\n-        final DetailAST ident = ast.findFirstToken(58);\n-        if (frame.getType() == RequireThisCheck.FrameType.CLASS_FRAME) {\n-            final DetailAST mods = ast.findFirstToken(5);\n-            if (ScopeUtil.isInInterfaceBlock(ast) || mods.findFirstToken(64) != null) {\n-                ((RequireThisCheck.ClassFrame)frame).addStaticMember(ident);\n+    private static void collectVariableDeclarations(final DetailAST detailAST, final RequireThisCheck.AbstractFrame abstractFrame) {\n+        final DetailAST firstToken = detailAST.findFirstToken(58);\n+        if (abstractFrame.getType() == RequireThisCheck.FrameType.CLASS_FRAME) {\n+            final DetailAST firstToken2 = detailAST.findFirstToken(5);\n+            if (ScopeUtil.isInInterfaceBlock(detailAST) || firstToken2.findFirstToken(64) != null) {\n+                ((RequireThisCheck.ClassFrame)abstractFrame).addStaticMember(firstToken);\n             }\n             else {\n-                ((RequireThisCheck.ClassFrame)frame).addInstanceMember(ident);\n+                ((RequireThisCheck.ClassFrame)abstractFrame).addInstanceMember(firstToken);\n             }\n         }\n         else {\n-            frame.addIdent(ident);\n+            abstractFrame.addIdent(firstToken);\n         }\n     }\n     \n-    private static void collectMethodDeclarations(final Deque<RequireThisCheck.AbstractFrame> frameStack, final DetailAST ast, final RequireThisCheck.AbstractFrame frame) {\n-        final DetailAST methodFrameNameIdent = ast.findFirstToken(58);\n-        final DetailAST mods = ast.findFirstToken(5);\n-        if (mods.findFirstToken(64) == null) {\n-            ((RequireThisCheck.ClassFrame)frame).addInstanceMethod(methodFrameNameIdent);\n+    private static void collectMethodDeclarations(final Deque<RequireThisCheck.AbstractFrame> deque, final DetailAST detailAST, final RequireThisCheck.AbstractFrame abstractFrame) {\n+        final DetailAST firstToken = detailAST.findFirstToken(58);\n+        if (detailAST.findFirstToken(5).findFirstToken(64) == null) {\n+            ((RequireThisCheck.ClassFrame)abstractFrame).addInstanceMethod(firstToken);\n         }\n         else {\n-            ((RequireThisCheck.ClassFrame)frame).addStaticMethod(methodFrameNameIdent);\n+            ((RequireThisCheck.ClassFrame)abstractFrame).addStaticMethod(firstToken);\n         }\n-        frameStack.addFirst((RequireThisCheck.AbstractFrame)new RequireThisCheck.MethodFrame(frame, methodFrameNameIdent));\n+        deque.addFirst((RequireThisCheck.AbstractFrame)new RequireThisCheck.MethodFrame(abstractFrame, firstToken));\n     }\n     \n-    private void endCollectingDeclarations(final Queue<RequireThisCheck.AbstractFrame> frameStack, final DetailAST ast) {\n-        switch (ast.getType()) {\n+    private void endCollectingDeclarations(final Queue<RequireThisCheck.AbstractFrame> queue, final DetailAST detailAST) {\n+        switch (detailAST.getType()) {\n             case 7:\n             case 8:\n             case 9:\n             case 14:\n             case 15:\n             case 91:\n             case 96:\n             case 154:\n             case 157:\n             case 199:\n             case 203: {\n-                this.frames.put(ast, frameStack.poll());\n+                this.frames.put(detailAST, queue.poll());\n                 break;\n             }\n             case 136: {\n-                if (isAnonymousClassDef(ast)) {\n-                    frameStack.remove();\n+                if (isAnonymousClassDef(detailAST)) {\n+                    queue.remove();\n                     break;\n                 }\n                 break;\n             }\n             case 95: {\n-                if (ast.getFirstChild().getType() == 176) {\n-                    this.frames.put(ast, frameStack.poll());\n+                if (detailAST.getFirstChild().getType() == 176) {\n+                    this.frames.put(detailAST, queue.poll());\n                     break;\n                 }\n                 break;\n             }\n         }\n     }\n     \n-    private static boolean isAnonymousClassDef(final DetailAST ast) {\n-        final DetailAST lastChild = ast.getLastChild();\n+    private static boolean isAnonymousClassDef(final DetailAST detailAST) {\n+        final DetailAST lastChild = detailAST.getLastChild();\n         return lastChild != null && lastChild.getType() == 6;\n     }\n     \n-    private RequireThisCheck.AbstractFrame getClassFrameWhereViolationIsFound(final DetailAST ast) {\n-        RequireThisCheck.AbstractFrame frameWhereViolationIsFound = null;\n-        final RequireThisCheck.AbstractFrame variableDeclarationFrame = this.findFrame(ast, false);\n-        final RequireThisCheck.FrameType variableDeclarationFrameType = variableDeclarationFrame.getType();\n-        final DetailAST prevSibling = ast.getPreviousSibling();\n-        if (variableDeclarationFrameType == RequireThisCheck.FrameType.CLASS_FRAME && !this.validateOnlyOverlapping && (prevSibling == null || !isInExpression(ast)) && canBeReferencedFromStaticContext(ast)) {\n-            frameWhereViolationIsFound = variableDeclarationFrame;\n+    private RequireThisCheck.AbstractFrame getClassFrameWhereViolationIsFound(final DetailAST detailAST) {\n+        RequireThisCheck.AbstractFrame abstractFrame = null;\n+        final RequireThisCheck.AbstractFrame frame = this.findFrame(detailAST, false);\n+        final RequireThisCheck.FrameType type = frame.getType();\n+        final DetailAST previousSibling = detailAST.getPreviousSibling();\n+        if (type == RequireThisCheck.FrameType.CLASS_FRAME && !this.validateOnlyOverlapping && (previousSibling == null || !isInExpression(detailAST)) && canBeReferencedFromStaticContext(detailAST)) {\n+            abstractFrame = frame;\n         }\n-        else if (variableDeclarationFrameType == RequireThisCheck.FrameType.METHOD_FRAME) {\n-            if (this.isOverlappingByArgument(ast)) {\n-                if (!isUserDefinedArrangementOfThis(variableDeclarationFrame, ast) && !isReturnedVariable(variableDeclarationFrame, ast) && canBeReferencedFromStaticContext(ast) && this.canAssignValueToClassField(ast)) {\n-                    frameWhereViolationIsFound = this.findFrame(ast, true);\n+        else if (type == RequireThisCheck.FrameType.METHOD_FRAME) {\n+            if (this.isOverlappingByArgument(detailAST)) {\n+                if (!isUserDefinedArrangementOfThis(frame, detailAST) && !isReturnedVariable(frame, detailAST) && canBeReferencedFromStaticContext(detailAST) && this.canAssignValueToClassField(detailAST)) {\n+                    abstractFrame = this.findFrame(detailAST, true);\n                 }\n             }\n-            else if (!this.validateOnlyOverlapping && prevSibling == null && isAssignToken(ast.getParent().getType()) && !isUserDefinedArrangementOfThis(variableDeclarationFrame, ast) && canBeReferencedFromStaticContext(ast) && this.canAssignValueToClassField(ast)) {\n-                frameWhereViolationIsFound = this.findFrame(ast, true);\n+            else if (!this.validateOnlyOverlapping && previousSibling == null && isAssignToken(detailAST.getParent().getType()) && !isUserDefinedArrangementOfThis(frame, detailAST) && canBeReferencedFromStaticContext(detailAST) && this.canAssignValueToClassField(detailAST)) {\n+                abstractFrame = this.findFrame(detailAST, true);\n             }\n         }\n-        else if (variableDeclarationFrameType == RequireThisCheck.FrameType.CTOR_FRAME && this.isOverlappingByArgument(ast) && !isUserDefinedArrangementOfThis(variableDeclarationFrame, ast)) {\n-            frameWhereViolationIsFound = this.findFrame(ast, true);\n+        else if (type == RequireThisCheck.FrameType.CTOR_FRAME && this.isOverlappingByArgument(detailAST) && !isUserDefinedArrangementOfThis(frame, detailAST)) {\n+            abstractFrame = this.findFrame(detailAST, true);\n         }\n-        else if (variableDeclarationFrameType == RequireThisCheck.FrameType.BLOCK_FRAME && this.isOverlappingByLocalVariable(ast) && this.canAssignValueToClassField(ast) && !isUserDefinedArrangementOfThis(variableDeclarationFrame, ast) && !isReturnedVariable(variableDeclarationFrame, ast) && canBeReferencedFromStaticContext(ast)) {\n-            frameWhereViolationIsFound = this.findFrame(ast, true);\n+        else if (type == RequireThisCheck.FrameType.BLOCK_FRAME && this.isOverlappingByLocalVariable(detailAST) && this.canAssignValueToClassField(detailAST) && !isUserDefinedArrangementOfThis(frame, detailAST) && !isReturnedVariable(frame, detailAST) && canBeReferencedFromStaticContext(detailAST)) {\n+            abstractFrame = this.findFrame(detailAST, true);\n         }\n-        return frameWhereViolationIsFound;\n+        return abstractFrame;\n     }\n     \n-    private static boolean isInExpression(final DetailAST ast) {\n-        return 59 == ast.getParent().getType() || 180 == ast.getParent().getType();\n+    private static boolean isInExpression(final DetailAST detailAST) {\n+        return 59 == detailAST.getParent().getType() || 180 == detailAST.getParent().getType();\n     }\n     \n-    private static boolean isUserDefinedArrangementOfThis(final RequireThisCheck.AbstractFrame currentFrame, final DetailAST ident) {\n-        final DetailAST blockFrameNameIdent = currentFrame.getFrameNameIdent();\n-        final DetailAST definitionToken = blockFrameNameIdent.getParent();\n-        final DetailAST blockStartToken = definitionToken.findFirstToken(7);\n-        final DetailAST blockEndToken = getBlockEndToken(blockFrameNameIdent, blockStartToken);\n-        boolean userDefinedArrangementOfThis = false;\n-        final Set<DetailAST> variableUsagesInsideBlock = getAllTokensWhichAreEqualToCurrent(definitionToken, ident, blockEndToken.getLineNo());\n-        for (final DetailAST variableUsage : variableUsagesInsideBlock) {\n-            final DetailAST prevSibling = variableUsage.getPreviousSibling();\n-            if (prevSibling != null && prevSibling.getType() == 78) {\n-                userDefinedArrangementOfThis = true;\n+    private static boolean isUserDefinedArrangementOfThis(final RequireThisCheck.AbstractFrame abstractFrame, final DetailAST detailAST) {\n+        final DetailAST frameNameIdent = abstractFrame.getFrameNameIdent();\n+        final DetailAST parent = frameNameIdent.getParent();\n+        final DetailAST blockEndToken = getBlockEndToken(frameNameIdent, parent.findFirstToken(7));\n+        boolean b = false;\n+        final Iterator<DetailAST> iterator = getAllTokensWhichAreEqualToCurrent(parent, detailAST, blockEndToken.getLineNo()).iterator();\n+        while (iterator.hasNext()) {\n+            final DetailAST previousSibling = ((DetailAST)iterator.next()).getPreviousSibling();\n+            if (previousSibling != null && previousSibling.getType() == 78) {\n+                b = true;\n                 break;\n             }\n         }\n-        return userDefinedArrangementOfThis;\n+        return b;\n     }\n     \n-    private static DetailAST getBlockEndToken(final DetailAST blockNameIdent, final DetailAST blockStartToken) {\n-        DetailAST blockEndToken = null;\n-        final DetailAST blockNameIdentParent = blockNameIdent.getParent();\n-        if (blockNameIdentParent.getType() == 33) {\n-            blockEndToken = blockNameIdentParent.getNextSibling();\n+    private static DetailAST getBlockEndToken(final DetailAST detailAST, final DetailAST detailAST2) {\n+        DetailAST nextSibling = null;\n+        final DetailAST parent = detailAST.getParent();\n+        if (parent.getType() == 33) {\n+            nextSibling = parent.getNextSibling();\n         }\n         else {\n-            final Set<DetailAST> rcurlyTokens = getAllTokensOfType(blockNameIdent, 73);\n-            for (final DetailAST currentRcurly : rcurlyTokens) {\n-                final DetailAST parent = currentRcurly.getParent();\n-                if (TokenUtil.areOnSameLine(blockStartToken, parent)) {\n-                    blockEndToken = currentRcurly;\n+            for (final DetailAST detailAST3 : getAllTokensOfType(detailAST, 73)) {\n+                if (TokenUtil.areOnSameLine(detailAST2, detailAST3.getParent())) {\n+                    nextSibling = detailAST3;\n                 }\n             }\n         }\n-        return blockEndToken;\n+        return nextSibling;\n     }\n     \n-    private static boolean isReturnedVariable(final RequireThisCheck.AbstractFrame currentFrame, final DetailAST ident) {\n-        final DetailAST blockFrameNameIdent = currentFrame.getFrameNameIdent();\n-        final DetailAST definitionToken = blockFrameNameIdent.getParent();\n-        final DetailAST blockStartToken = definitionToken.findFirstToken(7);\n-        final DetailAST blockEndToken = getBlockEndToken(blockFrameNameIdent, blockStartToken);\n-        final Set<DetailAST> returnsInsideBlock = getAllTokensOfType(definitionToken, 88, blockEndToken.getLineNo());\n-        return returnsInsideBlock.stream().anyMatch(returnToken -> isAstInside(returnToken, ident));\n+    private static boolean isReturnedVariable(final RequireThisCheck.AbstractFrame abstractFrame, final DetailAST detailAST) {\n+        final DetailAST frameNameIdent = abstractFrame.getFrameNameIdent();\n+        final DetailAST parent = frameNameIdent.getParent();\n+        return getAllTokensOfType(parent, 88, getBlockEndToken(frameNameIdent, parent.findFirstToken(7)).getLineNo()).stream().anyMatch(detailAST3 -> isAstInside(detailAST3, detailAST2));\n     }\n     \n-    private static boolean isAstInside(final DetailAST tree, final DetailAST ast) {\n-        boolean result = false;\n-        if (isAstSimilar(tree, ast)) {\n-            result = true;\n+    private static boolean isAstInside(final DetailAST detailAST, final DetailAST detailAST2) {\n+        boolean astInside = false;\n+        if (isAstSimilar(detailAST, detailAST2)) {\n+            astInside = true;\n         }\n         else {\n-            for (DetailAST child = tree.getFirstChild(); child != null && !result; result = isAstInside(child, ast), child = child.getNextSibling()) {}\n+            for (DetailAST detailAST3 = detailAST.getFirstChild(); detailAST3 != null && !astInside; astInside = isAstInside(detailAST3, detailAST2), detailAST3 = detailAST3.getNextSibling()) {}\n         }\n-        return result;\n+        return astInside;\n     }\n     \n-    private static boolean canBeReferencedFromStaticContext(final DetailAST ident) {\n-        boolean staticContext = false;\n-        final DetailAST codeBlockDefinition = getCodeBlockDefinitionToken(ident);\n-        if (codeBlockDefinition != null) {\n-            final DetailAST modifiers = codeBlockDefinition.getFirstChild();\n-            staticContext = (codeBlockDefinition.getType() == 12 || modifiers.findFirstToken(64) != null);\n+    private static boolean canBeReferencedFromStaticContext(final DetailAST detailAST) {\n+        boolean b = false;\n+        final DetailAST codeBlockDefinitionToken = getCodeBlockDefinitionToken(detailAST);\n+        if (codeBlockDefinitionToken != null) {\n+            final DetailAST firstChild = codeBlockDefinitionToken.getFirstChild();\n+            b = (codeBlockDefinitionToken.getType() == 12 || firstChild.findFirstToken(64) != null);\n         }\n-        return !staticContext;\n+        return !b;\n     }\n     \n-    private static DetailAST getCodeBlockDefinitionToken(final DetailAST ident) {\n+    private static DetailAST getCodeBlockDefinitionToken(final DetailAST detailAST) {\n         DetailAST parent;\n-        for (parent = ident; parent != null && parent.getType() != 9 && parent.getType() != 12; parent = parent.getParent()) {}\n+        for (parent = detailAST; parent != null && parent.getType() != 9 && parent.getType() != 12; parent = parent.getParent()) {}\n         return parent;\n     }\n     \n-    private boolean canAssignValueToClassField(final DetailAST ast) {\n-        final RequireThisCheck.AbstractFrame fieldUsageFrame = this.findFrame(ast, false);\n-        final boolean fieldUsageInConstructor = isInsideConstructorFrame(fieldUsageFrame);\n-        final RequireThisCheck.AbstractFrame declarationFrame = this.findFrame(ast, true);\n-        final boolean finalField = ((RequireThisCheck.ClassFrame)declarationFrame).hasFinalField(ast);\n-        return fieldUsageInConstructor || !finalField;\n-    }\n-    \n-    private static boolean isInsideConstructorFrame(final RequireThisCheck.AbstractFrame frame) {\n-        RequireThisCheck.AbstractFrame fieldUsageFrame;\n-        for (fieldUsageFrame = frame; fieldUsageFrame.getType() == RequireThisCheck.FrameType.BLOCK_FRAME; fieldUsageFrame = fieldUsageFrame.getParent()) {}\n-        return fieldUsageFrame.getType() == RequireThisCheck.FrameType.CTOR_FRAME;\n-    }\n-    \n-    private boolean isOverlappingByArgument(final DetailAST ast) {\n-        boolean overlapping = false;\n-        final DetailAST parent = ast.getParent();\n-        final DetailAST sibling = ast.getNextSibling();\n-        if (sibling != null && isAssignToken(parent.getType())) {\n-            if (isCompoundAssignToken(parent.getType())) {\n-                overlapping = true;\n-            }\n-            else {\n-                final RequireThisCheck.ClassFrame classFrame = (RequireThisCheck.ClassFrame)this.findFrame(ast, true);\n-                final Set<DetailAST> exprIdents = getAllTokensOfType(sibling, 58);\n-                overlapping = classFrame.containsFieldOrVariableDef((Set)exprIdents, ast);\n-            }\n+    private boolean canAssignValueToClassField(final DetailAST detailAST) {\n+        final boolean insideConstructorFrame = isInsideConstructorFrame(this.findFrame(detailAST, false));\n+        final boolean hasFinalField = ((RequireThisCheck.ClassFrame)this.findFrame(detailAST, true)).hasFinalField(detailAST);\n+        return insideConstructorFrame || !hasFinalField;\n+    }\n+    \n+    private static boolean isInsideConstructorFrame(final RequireThisCheck.AbstractFrame abstractFrame) {\n+        RequireThisCheck.AbstractFrame parent;\n+        for (parent = abstractFrame; parent.getType() == RequireThisCheck.FrameType.BLOCK_FRAME; parent = parent.getParent()) {}\n+        return parent.getType() == RequireThisCheck.FrameType.CTOR_FRAME;\n+    }\n+    \n+    private boolean isOverlappingByArgument(final DetailAST detailAST) {\n+        boolean b = false;\n+        final DetailAST parent = detailAST.getParent();\n+        final DetailAST nextSibling = detailAST.getNextSibling();\n+        if (nextSibling != null && isAssignToken(parent.getType())) {\n+            b = (isCompoundAssignToken(parent.getType()) || ((RequireThisCheck.ClassFrame)this.findFrame(detailAST, true)).containsFieldOrVariableDef((Set)getAllTokensOfType(nextSibling, 58), detailAST));\n         }\n-        return overlapping;\n+        return b;\n     }\n     \n-    private boolean isOverlappingByLocalVariable(final DetailAST ast) {\n-        boolean overlapping = false;\n-        final DetailAST parent = ast.getParent();\n-        if (isAssignToken(parent.getType())) {\n-            final RequireThisCheck.ClassFrame classFrame = (RequireThisCheck.ClassFrame)this.findFrame(ast, true);\n-            final Set<DetailAST> exprIdents = getAllTokensOfType(ast.getNextSibling(), 58);\n-            overlapping = classFrame.containsFieldOrVariableDef((Set)exprIdents, ast);\n+    private boolean isOverlappingByLocalVariable(final DetailAST detailAST) {\n+        boolean containsFieldOrVariableDef = false;\n+        if (isAssignToken(detailAST.getParent().getType())) {\n+            containsFieldOrVariableDef = ((RequireThisCheck.ClassFrame)this.findFrame(detailAST, true)).containsFieldOrVariableDef((Set)getAllTokensOfType(detailAST.getNextSibling(), 58), detailAST);\n         }\n-        return overlapping;\n+        return containsFieldOrVariableDef;\n     }\n     \n-    private static Set<DetailAST> getAllTokensOfType(final DetailAST ast, final int tokenType) {\n-        DetailAST vertex = ast;\n-        final Set<DetailAST> result = new HashSet<DetailAST>();\n-        final Deque<DetailAST> stack = new ArrayDeque<DetailAST>();\n-        while (vertex != null || !stack.isEmpty()) {\n-            if (!stack.isEmpty()) {\n-                vertex = stack.pop();\n+    private static Set<DetailAST> getAllTokensOfType(final DetailAST detailAST, final int n) {\n+        DetailAST firstChild = detailAST;\n+        final HashSet set = new HashSet();\n+        final ArrayDeque arrayDeque = new ArrayDeque();\n+        while (firstChild != null || !arrayDeque.isEmpty()) {\n+            if (!arrayDeque.isEmpty()) {\n+                firstChild = (DetailAST)arrayDeque.pop();\n             }\n-            while (vertex != null) {\n-                if (vertex.getType() == tokenType) {\n-                    result.add(vertex);\n+            while (firstChild != null) {\n+                if (firstChild.getType() == n) {\n+                    set.add(firstChild);\n                 }\n-                if (vertex.getNextSibling() != null) {\n-                    stack.push(vertex.getNextSibling());\n+                if (firstChild.getNextSibling() != null) {\n+                    arrayDeque.push(firstChild.getNextSibling());\n                 }\n-                vertex = vertex.getFirstChild();\n+                firstChild = firstChild.getFirstChild();\n             }\n         }\n-        return result;\n+        return set;\n     }\n     \n-    private static Set<DetailAST> getAllTokensOfType(final DetailAST ast, final int tokenType, final int endLineNumber) {\n-        DetailAST vertex = ast;\n-        final Set<DetailAST> result = new HashSet<DetailAST>();\n-        final Deque<DetailAST> stack = new ArrayDeque<DetailAST>();\n-        while (vertex != null || !stack.isEmpty()) {\n-            if (!stack.isEmpty()) {\n-                vertex = stack.pop();\n+    private static Set<DetailAST> getAllTokensOfType(final DetailAST detailAST, final int n, final int n2) {\n+        DetailAST firstChild = detailAST;\n+        final HashSet set = new HashSet();\n+        final ArrayDeque arrayDeque = new ArrayDeque();\n+        while (firstChild != null || !arrayDeque.isEmpty()) {\n+            if (!arrayDeque.isEmpty()) {\n+                firstChild = (DetailAST)arrayDeque.pop();\n             }\n-            while (vertex != null) {\n-                if (tokenType == vertex.getType() && vertex.getLineNo() <= endLineNumber) {\n-                    result.add(vertex);\n+            while (firstChild != null) {\n+                if (n == firstChild.getType() && firstChild.getLineNo() <= n2) {\n+                    set.add(firstChild);\n                 }\n-                if (vertex.getNextSibling() != null) {\n-                    stack.push(vertex.getNextSibling());\n+                if (firstChild.getNextSibling() != null) {\n+                    arrayDeque.push(firstChild.getNextSibling());\n                 }\n-                vertex = vertex.getFirstChild();\n+                firstChild = firstChild.getFirstChild();\n             }\n         }\n-        return result;\n+        return set;\n     }\n     \n-    private static Set<DetailAST> getAllTokensWhichAreEqualToCurrent(final DetailAST ast, final DetailAST token, final int endLineNumber) {\n-        DetailAST vertex = ast;\n-        final Set<DetailAST> result = new HashSet<DetailAST>();\n-        final Deque<DetailAST> stack = new ArrayDeque<DetailAST>();\n-        while (vertex != null || !stack.isEmpty()) {\n-            if (!stack.isEmpty()) {\n-                vertex = stack.pop();\n+    private static Set<DetailAST> getAllTokensWhichAreEqualToCurrent(final DetailAST detailAST, final DetailAST detailAST2, final int n) {\n+        DetailAST firstChild = detailAST;\n+        final HashSet set = new HashSet();\n+        final ArrayDeque arrayDeque = new ArrayDeque();\n+        while (firstChild != null || !arrayDeque.isEmpty()) {\n+            if (!arrayDeque.isEmpty()) {\n+                firstChild = (DetailAST)arrayDeque.pop();\n             }\n-            while (vertex != null) {\n-                if (isAstSimilar(token, vertex) && vertex.getLineNo() <= endLineNumber) {\n-                    result.add(vertex);\n+            while (firstChild != null) {\n+                if (isAstSimilar(detailAST2, firstChild) && firstChild.getLineNo() <= n) {\n+                    set.add(firstChild);\n                 }\n-                if (vertex.getNextSibling() != null) {\n-                    stack.push(vertex.getNextSibling());\n+                if (firstChild.getNextSibling() != null) {\n+                    arrayDeque.push(firstChild.getNextSibling());\n                 }\n-                vertex = vertex.getFirstChild();\n+                firstChild = firstChild.getFirstChild();\n             }\n         }\n-        return result;\n+        return set;\n     }\n     \n-    private RequireThisCheck.AbstractFrame getMethodWithoutThis(final DetailAST ast) {\n-        RequireThisCheck.AbstractFrame result = null;\n+    private RequireThisCheck.AbstractFrame getMethodWithoutThis(final DetailAST detailAST) {\n+        RequireThisCheck.AbstractFrame abstractFrame = null;\n         if (!this.validateOnlyOverlapping) {\n-            final RequireThisCheck.AbstractFrame frame = this.findFrame(ast, true);\n-            if (frame != null && ((RequireThisCheck.ClassFrame)frame).hasInstanceMethod(ast) && !((RequireThisCheck.ClassFrame)frame).hasStaticMethod(ast)) {\n-                result = frame;\n+            final RequireThisCheck.AbstractFrame frame = this.findFrame(detailAST, true);\n+            if (frame != null && ((RequireThisCheck.ClassFrame)frame).hasInstanceMethod(detailAST) && !((RequireThisCheck.ClassFrame)frame).hasStaticMethod(detailAST)) {\n+                abstractFrame = frame;\n             }\n         }\n-        return result;\n+        return abstractFrame;\n     }\n     \n-    private RequireThisCheck.AbstractFrame findClassFrame(final DetailAST name, final boolean lookForMethod) {\n-        RequireThisCheck.AbstractFrame frame = (RequireThisCheck.AbstractFrame)this.current.peek();\n+    private RequireThisCheck.AbstractFrame findClassFrame(final DetailAST detailAST, final boolean b) {\n+        RequireThisCheck.AbstractFrame parent = (RequireThisCheck.AbstractFrame)this.current.peek();\n+        RequireThisCheck.AbstractFrame frame;\n         while (true) {\n-            frame = findFrame(frame, name, lookForMethod);\n+            frame = findFrame(parent, detailAST, b);\n             if (frame == null || frame instanceof RequireThisCheck.ClassFrame) {\n                 break;\n             }\n-            frame = frame.getParent();\n+            parent = frame.getParent();\n         }\n         return frame;\n     }\n     \n-    private RequireThisCheck.AbstractFrame findFrame(final DetailAST name, final boolean lookForMethod) {\n-        return findFrame(this.current.peek(), name, lookForMethod);\n+    private RequireThisCheck.AbstractFrame findFrame(final DetailAST detailAST, final boolean b) {\n+        return findFrame(this.current.peek(), detailAST, b);\n     }\n     \n-    private static RequireThisCheck.AbstractFrame findFrame(final RequireThisCheck.AbstractFrame frame, final DetailAST name, final boolean lookForMethod) {\n-        return frame.getIfContains(name, lookForMethod);\n+    private static RequireThisCheck.AbstractFrame findFrame(final RequireThisCheck.AbstractFrame abstractFrame, final DetailAST detailAST, final boolean b) {\n+        return abstractFrame.getIfContains(detailAST, b);\n     }\n     \n-    private static boolean isDeclarationToken(final int parentType) {\n-        return RequireThisCheck.DECLARATION_TOKENS.get(parentType);\n+    private static boolean isDeclarationToken(final int bitIndex) {\n+        return RequireThisCheck.DECLARATION_TOKENS.get(bitIndex);\n     }\n     \n-    private static boolean isAssignToken(final int tokenType) {\n-        return RequireThisCheck.ASSIGN_TOKENS.get(tokenType);\n+    private static boolean isAssignToken(final int bitIndex) {\n+        return RequireThisCheck.ASSIGN_TOKENS.get(bitIndex);\n     }\n     \n-    private static boolean isCompoundAssignToken(final int tokenType) {\n-        return RequireThisCheck.COMPOUND_ASSIGN_TOKENS.get(tokenType);\n+    private static boolean isCompoundAssignToken(final int bitIndex) {\n+        return RequireThisCheck.COMPOUND_ASSIGN_TOKENS.get(bitIndex);\n     }\n     \n     private String getNearestClassFrameName() {\n-        RequireThisCheck.AbstractFrame frame;\n-        for (frame = this.current.peek(); frame.getType() != RequireThisCheck.FrameType.CLASS_FRAME; frame = frame.getParent()) {}\n-        return frame.getFrameName();\n+        RequireThisCheck.AbstractFrame parent;\n+        for (parent = this.current.peek(); parent.getType() != RequireThisCheck.FrameType.CLASS_FRAME; parent = parent.getParent()) {}\n+        return parent.getFrameName();\n     }\n     \n-    private static boolean isLambdaParameter(final DetailAST ast) {\n+    private static boolean isLambdaParameter(final DetailAST detailAST) {\n         DetailAST parent;\n-        for (parent = ast; parent != null && parent.getType() != 181; parent = parent.getParent()) {}\n-        boolean isLambdaParameter;\n+        for (parent = detailAST; parent != null && parent.getType() != 181; parent = parent.getParent()) {}\n+        boolean b;\n         if (parent == null) {\n-            isLambdaParameter = false;\n+            b = false;\n         }\n-        else if (ast.getType() == 21) {\n-            isLambdaParameter = true;\n+        else if (detailAST.getType() == 21) {\n+            b = true;\n         }\n         else {\n-            final DetailAST lambdaParameters = parent.findFirstToken(20);\n-            if (lambdaParameters == null) {\n-                isLambdaParameter = parent.getFirstChild().getText().equals(ast.getText());\n+            final DetailAST firstToken = parent.findFirstToken(20);\n+            if (firstToken == null) {\n+                b = parent.getFirstChild().getText().equals(detailAST.getText());\n             }\n             else {\n-                isLambdaParameter = TokenUtil.findFirstTokenByPredicate(lambdaParameters, paramDef -> {\n-                    final DetailAST param = paramDef.findFirstToken(58);\n-                    return param != null && param.getText().equals(ast.getText());\n+                b = TokenUtil.findFirstTokenByPredicate(firstToken, detailAST3 -> {\n+                    detailAST3.findFirstToken(58);\n+                    final DetailAST detailAST4;\n+                    return detailAST4 != null && detailAST4.getText().equals(detailAST2.getText());\n                 }).isPresent();\n             }\n         }\n-        return isLambdaParameter;\n+        return b;\n     }\n     \n-    private static boolean isAstSimilar(final DetailAST left, final DetailAST right) {\n-        return left.getType() == right.getType() && left.getText().equals(right.getText());\n+    private static boolean isAstSimilar(final DetailAST detailAST, final DetailAST detailAST2) {\n+        return detailAST.getType() == detailAST2.getType() && detailAST.getText().equals(detailAST2.getText());\n     }\n     \n     static {\n         DECLARATION_TOKENS = TokenUtil.asBitSet(new int[] { 10, 8, 9, 14, 154, 157, 15, 21, 164, 199, 202, 178 });\n         ASSIGN_TOKENS = TokenUtil.asBitSet(new int[] { 80, 98, 100, 101, 102, 103, 104, 105, 106, 107 });\n         COMPOUND_ASSIGN_TOKENS = TokenUtil.asBitSet(new int[] { 98, 100, 101, 102, 103, 104, 105, 106, 107 });\n     }\n"}]}
