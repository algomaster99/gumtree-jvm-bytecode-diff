{"diffoscope-json-version": 1, "source1": "first/ZipArchiveOutputStream.class", "source2": "second/ZipArchiveOutputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -100,40 +100,40 @@\n     static final byte[] LFH_SIG;\n     static final byte[] DD_SIG;\n     static final byte[] CFH_SIG;\n     static final byte[] EOCD_SIG;\n     static final byte[] ZIP64_EOCD_SIG;\n     static final byte[] ZIP64_EOCD_LOC_SIG;\n     \n-    public ZipArchiveOutputStream(final OutputStream out) {\n+    public ZipArchiveOutputStream(final OutputStream outputStream) {\n         this.comment = \"\";\n         this.level = -1;\n         this.method = 8;\n         this.entries = new LinkedList<ZipArchiveEntry>();\n         this.metaData = new HashMap<ZipArchiveEntry, ZipArchiveOutputStream.EntryMetaData>();\n         this.encoding = \"UTF8\";\n         this.zipEncoding = ZipEncodingHelper.getZipEncoding(\"UTF8\");\n         this.useUTF8Flag = true;\n         this.createUnicodeExtraFields = ZipArchiveOutputStream.UnicodeExtraFieldPolicy.NEVER;\n         this.zip64Mode = Zip64Mode.AsNeeded;\n         this.copyBuffer = new byte[32768];\n         this.calendarInstance = Calendar.getInstance();\n         this.numberOfCDInDiskData = new HashMap<Integer, Integer>();\n-        this.outputStream = out;\n+        this.outputStream = outputStream;\n         this.channel = null;\n         this.def = new Deflater(this.level, true);\n-        this.streamCompressor = StreamCompressor.create(out, this.def);\n+        this.streamCompressor = StreamCompressor.create(outputStream, this.def);\n         this.isSplitZip = false;\n     }\n     \n     public ZipArchiveOutputStream(final File file) throws IOException {\n         this(file.toPath(), new OpenOption[0]);\n     }\n     \n-    public ZipArchiveOutputStream(final Path file, final OpenOption... options) throws IOException {\n+    public ZipArchiveOutputStream(final Path path, final OpenOption... options) throws IOException {\n         this.comment = \"\";\n         this.level = -1;\n         this.method = 8;\n         this.entries = new LinkedList<ZipArchiveEntry>();\n         this.metaData = new HashMap<ZipArchiveEntry, ZipArchiveOutputStream.EntryMetaData>();\n         this.encoding = \"UTF8\";\n         this.zipEncoding = ZipEncodingHelper.getZipEncoding(\"UTF8\");\n@@ -141,52 +141,52 @@\n         this.createUnicodeExtraFields = ZipArchiveOutputStream.UnicodeExtraFieldPolicy.NEVER;\n         this.zip64Mode = Zip64Mode.AsNeeded;\n         this.copyBuffer = new byte[32768];\n         this.calendarInstance = Calendar.getInstance();\n         this.numberOfCDInDiskData = new HashMap<Integer, Integer>();\n         this.def = new Deflater(this.level, true);\n         OutputStream outputStream = null;\n-        SeekableByteChannel channel = null;\n-        StreamCompressor streamCompressor = null;\n+        SeekableByteChannel byteChannel = null;\n+        StreamCompressor streamCompressor;\n         try {\n-            channel = Files.newByteChannel(file, EnumSet.of(StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.TRUNCATE_EXISTING), (FileAttribute<?>[])new FileAttribute[0]);\n-            streamCompressor = StreamCompressor.create(channel, this.def);\n+            byteChannel = Files.newByteChannel(path, EnumSet.of(StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.TRUNCATE_EXISTING), (FileAttribute<?>[])new FileAttribute[0]);\n+            streamCompressor = StreamCompressor.create(byteChannel, this.def);\n         }\n-        catch (final IOException e) {\n-            IOUtils.closeQuietly((Closeable)channel);\n-            channel = null;\n-            outputStream = Files.newOutputStream(file, options);\n+        catch (final IOException ex) {\n+            IOUtils.closeQuietly((Closeable)byteChannel);\n+            byteChannel = null;\n+            outputStream = Files.newOutputStream(path, options);\n             streamCompressor = StreamCompressor.create(outputStream, this.def);\n         }\n         this.outputStream = outputStream;\n-        this.channel = channel;\n+        this.channel = byteChannel;\n         this.streamCompressor = streamCompressor;\n         this.isSplitZip = false;\n     }\n     \n-    public ZipArchiveOutputStream(final File file, final long zipSplitSize) throws IOException {\n-        this(file.toPath(), zipSplitSize);\n+    public ZipArchiveOutputStream(final File file, final long n) throws IOException {\n+        this(file.toPath(), n);\n     }\n     \n-    public ZipArchiveOutputStream(final Path path, final long zipSplitSize) throws IOException {\n+    public ZipArchiveOutputStream(final Path path, final long n) throws IOException {\n         this.comment = \"\";\n         this.level = -1;\n         this.method = 8;\n         this.entries = new LinkedList<ZipArchiveEntry>();\n         this.metaData = new HashMap<ZipArchiveEntry, ZipArchiveOutputStream.EntryMetaData>();\n         this.encoding = \"UTF8\";\n         this.zipEncoding = ZipEncodingHelper.getZipEncoding(\"UTF8\");\n         this.useUTF8Flag = true;\n         this.createUnicodeExtraFields = ZipArchiveOutputStream.UnicodeExtraFieldPolicy.NEVER;\n         this.zip64Mode = Zip64Mode.AsNeeded;\n         this.copyBuffer = new byte[32768];\n         this.calendarInstance = Calendar.getInstance();\n         this.numberOfCDInDiskData = new HashMap<Integer, Integer>();\n         this.def = new Deflater(this.level, true);\n-        this.outputStream = (OutputStream)new ZipSplitOutputStream(path, zipSplitSize);\n+        this.outputStream = (OutputStream)new ZipSplitOutputStream(path, n);\n         this.streamCompressor = StreamCompressor.create(this.outputStream, this.def);\n         this.channel = null;\n         this.isSplitZip = true;\n     }\n     \n     public ZipArchiveOutputStream(final SeekableByteChannel channel) {\n         this.comment = \"\";\n@@ -225,100 +225,95 @@\n         return this.encoding;\n     }\n     \n     public void setUseLanguageEncodingFlag(final boolean b) {\n         this.useUTF8Flag = (b && ZipEncodingHelper.isUTF8(this.encoding));\n     }\n     \n-    public void setCreateUnicodeExtraFields(final ZipArchiveOutputStream.UnicodeExtraFieldPolicy b) {\n-        this.createUnicodeExtraFields = b;\n+    public void setCreateUnicodeExtraFields(final ZipArchiveOutputStream.UnicodeExtraFieldPolicy createUnicodeExtraFields) {\n+        this.createUnicodeExtraFields = createUnicodeExtraFields;\n     }\n     \n-    public void setFallbackToUTF8(final boolean b) {\n-        this.fallbackToUTF8 = b;\n+    public void setFallbackToUTF8(final boolean fallbackToUTF8) {\n+        this.fallbackToUTF8 = fallbackToUTF8;\n     }\n     \n-    public void setUseZip64(final Zip64Mode mode) {\n-        this.zip64Mode = mode;\n+    public void setUseZip64(final Zip64Mode zip64Mode) {\n+        this.zip64Mode = zip64Mode;\n     }\n     \n     public long getBytesWritten() {\n         return this.streamCompressor.getTotalBytesWritten();\n     }\n     \n     public void finish() throws IOException {\n         if (this.finished) {\n             throw new IOException(\"This archive has already been finished\");\n         }\n         if (this.entry != null) {\n             throw new IOException(\"This archive contains unclosed entries.\");\n         }\n-        final long cdOverallOffset = this.streamCompressor.getTotalBytesWritten();\n-        this.cdOffset = cdOverallOffset;\n+        final long totalBytesWritten = this.streamCompressor.getTotalBytesWritten();\n+        this.cdOffset = totalBytesWritten;\n         if (this.isSplitZip) {\n             final ZipSplitOutputStream zipSplitOutputStream = (ZipSplitOutputStream)this.outputStream;\n             this.cdOffset = zipSplitOutputStream.getCurrentSplitSegmentBytesWritten();\n             this.cdDiskNumberStart = zipSplitOutputStream.getCurrentSplitSegmentIndex();\n         }\n         this.writeCentralDirectoryInChunks();\n-        this.cdLength = this.streamCompressor.getTotalBytesWritten() - cdOverallOffset;\n-        final ByteBuffer commentData = this.zipEncoding.encode(this.comment);\n-        final long commentLength = commentData.limit() - (long)commentData.position();\n-        this.eocdLength = 22L + commentLength;\n+        this.cdLength = this.streamCompressor.getTotalBytesWritten() - totalBytesWritten;\n+        final ByteBuffer encode = this.zipEncoding.encode(this.comment);\n+        this.eocdLength = 22L + (encode.limit() - (long)encode.position());\n         this.writeZip64CentralDirectory();\n         this.writeCentralDirectoryEnd();\n         this.metaData.clear();\n         this.entries.clear();\n         this.streamCompressor.close();\n         if (this.isSplitZip) {\n             this.outputStream.close();\n         }\n         this.finished = true;\n     }\n     \n     private void writeCentralDirectoryInChunks() throws IOException {\n-        final int NUM_PER_WRITE = 1000;\n         final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(70000);\n-        int count = 0;\n-        for (final ZipArchiveEntry ze : this.entries) {\n-            byteArrayOutputStream.write(this.createCentralFileHeader(ze));\n-            if (++count > 1000) {\n+        int n = 0;\n+        final Iterator<ZipArchiveEntry> iterator = this.entries.iterator();\n+        while (iterator.hasNext()) {\n+            byteArrayOutputStream.write(this.createCentralFileHeader((ZipArchiveEntry)iterator.next()));\n+            if (++n > 1000) {\n                 this.writeCounted(byteArrayOutputStream.toByteArray());\n                 byteArrayOutputStream.reset();\n-                count = 0;\n+                n = 0;\n             }\n         }\n         this.writeCounted(byteArrayOutputStream.toByteArray());\n     }\n     \n     public void closeArchiveEntry() throws IOException {\n         this.preClose();\n         this.flushDeflater();\n-        final long bytesWritten = this.streamCompressor.getTotalBytesWritten() - ZipArchiveOutputStream.CurrentEntry.access$000(this.entry);\n-        final long realCrc = this.streamCompressor.getCrc32();\n+        final long n = this.streamCompressor.getTotalBytesWritten() - ZipArchiveOutputStream.CurrentEntry.access$000(this.entry);\n+        final long crc32 = this.streamCompressor.getCrc32();\n         ZipArchiveOutputStream.CurrentEntry.access$102(this.entry, this.streamCompressor.getBytesRead());\n-        final Zip64Mode effectiveMode = this.getEffectiveZip64Mode(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n-        final boolean actuallyNeedsZip64 = this.handleSizesAndCrc(bytesWritten, realCrc, effectiveMode);\n-        this.closeEntry(actuallyNeedsZip64, false);\n+        this.closeEntry(this.handleSizesAndCrc(n, crc32, this.getEffectiveZip64Mode(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry))), false);\n         this.streamCompressor.reset();\n     }\n     \n-    private void closeCopiedEntry(final boolean phased) throws IOException {\n+    private void closeCopiedEntry(final boolean b) throws IOException {\n         this.preClose();\n         ZipArchiveOutputStream.CurrentEntry.access$102(this.entry, ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize());\n-        final Zip64Mode effectiveMode = this.getEffectiveZip64Mode(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n-        final boolean actuallyNeedsZip64 = this.checkIfNeedsZip64(effectiveMode);\n-        this.closeEntry(actuallyNeedsZip64, phased);\n+        this.closeEntry(this.checkIfNeedsZip64(this.getEffectiveZip64Mode(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry))), b);\n     }\n     \n-    private void closeEntry(final boolean actuallyNeedsZip64, final boolean phased) throws IOException {\n-        if (!phased && this.channel != null) {\n-            this.rewriteSizesAndCrc(actuallyNeedsZip64);\n+    private void closeEntry(final boolean b, final boolean b2) throws IOException {\n+        if (!b2 && this.channel != null) {\n+            this.rewriteSizesAndCrc(b);\n         }\n-        if (!phased) {\n+        if (!b2) {\n             this.writeDataDescriptor(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n         }\n         this.entry = null;\n     }\n     \n     private void preClose() throws IOException {\n         if (this.finished) {\n@@ -328,230 +323,228 @@\n             throw new IOException(\"No current entry to close\");\n         }\n         if (!ZipArchiveOutputStream.CurrentEntry.access$300(this.entry)) {\n             this.write(ByteUtils.EMPTY_BYTE_ARRAY, 0, 0);\n         }\n     }\n     \n-    public void addRawArchiveEntry(final ZipArchiveEntry entry, final InputStream rawStream) throws IOException {\n-        final ZipArchiveEntry ae = new ZipArchiveEntry(entry);\n-        if (this.hasZip64Extra(ae)) {\n-            ae.removeExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n-        }\n-        final boolean is2PhaseSource = ae.getCrc() != -1L && ae.getSize() != -1L && ae.getCompressedSize() != -1L;\n-        this.putArchiveEntry((ArchiveEntry)ae, is2PhaseSource);\n-        this.copyFromZipInputStream(rawStream);\n-        this.closeCopiedEntry(is2PhaseSource);\n+    public void addRawArchiveEntry(final ZipArchiveEntry zipArchiveEntry, final InputStream inputStream) throws IOException {\n+        final ZipArchiveEntry zipArchiveEntry2 = new ZipArchiveEntry(zipArchiveEntry);\n+        if (this.hasZip64Extra(zipArchiveEntry2)) {\n+            zipArchiveEntry2.removeExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n+        }\n+        final boolean b = zipArchiveEntry2.getCrc() != -1L && zipArchiveEntry2.getSize() != -1L && zipArchiveEntry2.getCompressedSize() != -1L;\n+        this.putArchiveEntry((ArchiveEntry)zipArchiveEntry2, b);\n+        this.copyFromZipInputStream(inputStream);\n+        this.closeCopiedEntry(b);\n     }\n     \n     private void flushDeflater() throws IOException {\n         if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getMethod() == 8) {\n             this.streamCompressor.flushDeflater();\n         }\n     }\n     \n-    private boolean handleSizesAndCrc(final long bytesWritten, final long crc, final Zip64Mode effectiveMode) throws ZipException {\n+    private boolean handleSizesAndCrc(final long n, final long crc, final Zip64Mode zip64Mode) throws ZipException {\n         if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getMethod() == 8) {\n             ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setSize(ZipArchiveOutputStream.CurrentEntry.access$100(this.entry));\n-            ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setCompressedSize(bytesWritten);\n+            ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setCompressedSize(n);\n             ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setCrc(crc);\n         }\n         else if (this.channel == null) {\n             if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getCrc() != crc) {\n                 throw new ZipException(\"Bad CRC checksum for entry \" + ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getName() + \": \" + Long.toHexString(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getCrc()) + \" instead of \" + Long.toHexString(crc));\n             }\n-            if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize() != bytesWritten) {\n-                throw new ZipException(\"Bad size for entry \" + ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getName() + \": \" + ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize() + \" instead of \" + bytesWritten);\n+            if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize() != n) {\n+                throw new ZipException(\"Bad size for entry \" + ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getName() + \": \" + ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize() + \" instead of \" + n);\n             }\n         }\n         else {\n-            ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setSize(bytesWritten);\n-            ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setCompressedSize(bytesWritten);\n+            ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setSize(n);\n+            ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setCompressedSize(n);\n             ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setCrc(crc);\n         }\n-        return this.checkIfNeedsZip64(effectiveMode);\n+        return this.checkIfNeedsZip64(zip64Mode);\n     }\n     \n-    private boolean checkIfNeedsZip64(final Zip64Mode effectiveMode) throws ZipException {\n-        final boolean actuallyNeedsZip64 = this.isZip64Required(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry), effectiveMode);\n-        if (actuallyNeedsZip64 && effectiveMode == Zip64Mode.Never) {\n+    private boolean checkIfNeedsZip64(final Zip64Mode zip64Mode) throws ZipException {\n+        final boolean zip64Required = this.isZip64Required(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry), zip64Mode);\n+        if (zip64Required && zip64Mode == Zip64Mode.Never) {\n             throw new Zip64RequiredException(Zip64RequiredException.getEntryTooBigMessage(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry)));\n         }\n-        return actuallyNeedsZip64;\n+        return zip64Required;\n     }\n     \n-    private boolean isZip64Required(final ZipArchiveEntry entry1, final Zip64Mode requestedMode) {\n-        return requestedMode == Zip64Mode.Always || requestedMode == Zip64Mode.AlwaysWithCompatibility || this.isTooLargeForZip32(entry1);\n+    private boolean isZip64Required(final ZipArchiveEntry zipArchiveEntry, final Zip64Mode zip64Mode) {\n+        return zip64Mode == Zip64Mode.Always || zip64Mode == Zip64Mode.AlwaysWithCompatibility || this.isTooLargeForZip32(zipArchiveEntry);\n     }\n     \n     private boolean isTooLargeForZip32(final ZipArchiveEntry zipArchiveEntry) {\n         return zipArchiveEntry.getSize() >= 4294967295L || zipArchiveEntry.getCompressedSize() >= 4294967295L;\n     }\n     \n-    private void rewriteSizesAndCrc(final boolean actuallyNeedsZip64) throws IOException {\n-        final long save = this.channel.position();\n+    private void rewriteSizesAndCrc(final boolean b) throws IOException {\n+        final long position = this.channel.position();\n         this.channel.position(ZipArchiveOutputStream.CurrentEntry.access$400(this.entry));\n         this.writeOut(ZipLong.getBytes(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getCrc()));\n-        if (!this.hasZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry)) || !actuallyNeedsZip64) {\n+        if (!this.hasZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry)) || !b) {\n             this.writeOut(ZipLong.getBytes(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getCompressedSize()));\n             this.writeOut(ZipLong.getBytes(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize()));\n         }\n         else {\n             this.writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n             this.writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n         }\n         if (this.hasZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry))) {\n             final ByteBuffer name = this.getName(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n-            final int nameLen = name.limit() - name.position();\n-            this.channel.position(ZipArchiveOutputStream.CurrentEntry.access$400(this.entry) + 12L + 4L + nameLen + 4L);\n+            this.channel.position(ZipArchiveOutputStream.CurrentEntry.access$400(this.entry) + 12L + 4L + (name.limit() - name.position()) + 4L);\n             this.writeOut(ZipEightByteInteger.getBytes(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize()));\n             this.writeOut(ZipEightByteInteger.getBytes(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getCompressedSize()));\n-            if (!actuallyNeedsZip64) {\n+            if (!b) {\n                 this.channel.position(ZipArchiveOutputStream.CurrentEntry.access$400(this.entry) - 10L);\n                 this.writeOut(ZipShort.getBytes(this.versionNeededToExtract(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getMethod(), false, false)));\n                 ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).removeExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n                 ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setExtra();\n                 if (ZipArchiveOutputStream.CurrentEntry.access$500(this.entry)) {\n                     this.hasUsedZip64 = false;\n                 }\n             }\n         }\n-        this.channel.position(save);\n+        this.channel.position(position);\n     }\n     \n     public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\n         this.putArchiveEntry(archiveEntry, false);\n     }\n     \n-    private void putArchiveEntry(final ArchiveEntry archiveEntry, final boolean phased) throws IOException {\n+    private void putArchiveEntry(final ArchiveEntry archiveEntry, final boolean b) throws IOException {\n         if (this.finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n         if (this.entry != null) {\n             this.closeArchiveEntry();\n         }\n         this.entry = new ZipArchiveOutputStream.CurrentEntry((ZipArchiveEntry)archiveEntry, (ZipArchiveOutputStream.ZipArchiveOutputStream$1)null);\n         this.entries.add(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n         this.setDefaults(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n-        final Zip64Mode effectiveMode = this.getEffectiveZip64Mode(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n-        this.validateSizeInformation(effectiveMode);\n-        if (this.shouldAddZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry), effectiveMode)) {\n-            final Zip64ExtendedInformationExtraField z64 = this.getZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n+        final Zip64Mode effectiveZip64Mode = this.getEffectiveZip64Mode(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n+        this.validateSizeInformation(effectiveZip64Mode);\n+        if (this.shouldAddZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry), effectiveZip64Mode)) {\n+            final Zip64ExtendedInformationExtraField zip64Extra = this.getZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n             ZipEightByteInteger size;\n-            ZipEightByteInteger compressedSize;\n-            if (phased) {\n+            ZipEightByteInteger zero;\n+            if (b) {\n                 size = new ZipEightByteInteger(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize());\n-                compressedSize = new ZipEightByteInteger(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getCompressedSize());\n+                zero = new ZipEightByteInteger(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getCompressedSize());\n             }\n             else if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getMethod() == 0 && ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize() != -1L) {\n-                size = (compressedSize = new ZipEightByteInteger(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize()));\n+                size = (zero = new ZipEightByteInteger(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize()));\n             }\n             else {\n-                size = (compressedSize = ZipEightByteInteger.ZERO);\n+                size = (zero = ZipEightByteInteger.ZERO);\n             }\n-            z64.setSize(size);\n-            z64.setCompressedSize(compressedSize);\n+            zip64Extra.setSize(size);\n+            zip64Extra.setCompressedSize(zero);\n             ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setExtra();\n         }\n         if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getMethod() == 8 && this.hasCompressionLevelChanged) {\n             this.def.setLevel(this.level);\n             this.hasCompressionLevelChanged = false;\n         }\n-        this.writeLocalFileHeader((ZipArchiveEntry)archiveEntry, phased);\n+        this.writeLocalFileHeader((ZipArchiveEntry)archiveEntry, b);\n     }\n     \n-    private void setDefaults(final ZipArchiveEntry entry) {\n-        if (entry.getMethod() == -1) {\n-            entry.setMethod(this.method);\n+    private void setDefaults(final ZipArchiveEntry zipArchiveEntry) {\n+        if (zipArchiveEntry.getMethod() == -1) {\n+            zipArchiveEntry.setMethod(this.method);\n         }\n-        if (entry.getTime() == -1L) {\n-            entry.setTime(System.currentTimeMillis());\n+        if (zipArchiveEntry.getTime() == -1L) {\n+            zipArchiveEntry.setTime(System.currentTimeMillis());\n         }\n     }\n     \n-    private void validateSizeInformation(final Zip64Mode effectiveMode) throws ZipException {\n+    private void validateSizeInformation(final Zip64Mode zip64Mode) throws ZipException {\n         if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getMethod() == 0 && this.channel == null) {\n             if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize() == -1L) {\n                 throw new ZipException(\"Uncompressed size is required for STORED method when not writing to a file\");\n             }\n             if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getCrc() == -1L) {\n                 throw new ZipException(\"CRC checksum is required for STORED method when not writing to a file\");\n             }\n             ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setCompressedSize(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize());\n         }\n-        if ((ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize() >= 4294967295L || ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getCompressedSize() >= 4294967295L) && effectiveMode == Zip64Mode.Never) {\n+        if ((ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize() >= 4294967295L || ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getCompressedSize() >= 4294967295L) && zip64Mode == Zip64Mode.Never) {\n             throw new Zip64RequiredException(Zip64RequiredException.getEntryTooBigMessage(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry)));\n         }\n     }\n     \n-    private boolean shouldAddZip64Extra(final ZipArchiveEntry entry, final Zip64Mode mode) {\n-        return mode == Zip64Mode.Always || mode == Zip64Mode.AlwaysWithCompatibility || entry.getSize() >= 4294967295L || entry.getCompressedSize() >= 4294967295L || (entry.getSize() == -1L && this.channel != null && mode != Zip64Mode.Never);\n+    private boolean shouldAddZip64Extra(final ZipArchiveEntry zipArchiveEntry, final Zip64Mode zip64Mode) {\n+        return zip64Mode == Zip64Mode.Always || zip64Mode == Zip64Mode.AlwaysWithCompatibility || zipArchiveEntry.getSize() >= 4294967295L || zipArchiveEntry.getCompressedSize() >= 4294967295L || (zipArchiveEntry.getSize() == -1L && this.channel != null && zip64Mode != Zip64Mode.Never);\n     }\n     \n     public void setComment(final String comment) {\n         this.comment = comment;\n     }\n     \n-    public void setLevel(final int level) {\n-        if (level < -1 || level > 9) {\n-            throw new IllegalArgumentException(\"Invalid compression level: \" + level);\n+    public void setLevel(final int n) {\n+        if (n < -1 || n > 9) {\n+            throw new IllegalArgumentException(\"Invalid compression level: \" + n);\n         }\n-        if (this.level == level) {\n+        if (this.level == n) {\n             return;\n         }\n         this.hasCompressionLevelChanged = true;\n-        this.level = level;\n+        this.level = n;\n     }\n     \n     public void setMethod(final int method) {\n         this.method = method;\n     }\n     \n-    public boolean canWriteEntryData(final ArchiveEntry ae) {\n-        if (ae instanceof ZipArchiveEntry) {\n-            final ZipArchiveEntry zae = (ZipArchiveEntry)ae;\n-            return zae.getMethod() != ZipMethod.IMPLODING.getCode() && zae.getMethod() != ZipMethod.UNSHRINKING.getCode() && ZipUtil.canHandleEntryData(zae);\n+    public boolean canWriteEntryData(final ArchiveEntry archiveEntry) {\n+        if (archiveEntry instanceof ZipArchiveEntry) {\n+            final ZipArchiveEntry zipArchiveEntry = (ZipArchiveEntry)archiveEntry;\n+            return zipArchiveEntry.getMethod() != ZipMethod.IMPLODING.getCode() && zipArchiveEntry.getMethod() != ZipMethod.UNSHRINKING.getCode() && ZipUtil.canHandleEntryData(zipArchiveEntry);\n         }\n         return false;\n     }\n     \n-    public void writePreamble(final byte[] preamble) throws IOException {\n-        this.writePreamble(preamble, 0, preamble.length);\n+    public void writePreamble(final byte[] array) throws IOException {\n+        this.writePreamble(array, 0, array.length);\n     }\n     \n-    public void writePreamble(final byte[] preamble, final int offset, final int length) throws IOException {\n+    public void writePreamble(final byte[] array, final int n, final int n2) throws IOException {\n         if (this.entry != null) {\n             throw new IllegalStateException(\"Preamble must be written before creating an entry\");\n         }\n-        this.streamCompressor.writeCounted(preamble, offset, length);\n+        this.streamCompressor.writeCounted(array, n, n2);\n     }\n     \n-    public void write(final byte[] b, final int offset, final int length) throws IOException {\n+    public void write(final byte[] array, final int n, final int n2) throws IOException {\n         if (this.entry == null) {\n             throw new IllegalStateException(\"No current entry\");\n         }\n         ZipUtil.checkRequestedFeatures(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n-        final long writtenThisTime = this.streamCompressor.write(b, offset, length, ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getMethod());\n-        this.count(writtenThisTime);\n+        this.count(this.streamCompressor.write(array, n, n2, ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getMethod()));\n     }\n     \n-    private void writeCounted(final byte[] data) throws IOException {\n-        this.streamCompressor.writeCounted(data);\n+    private void writeCounted(final byte[] array) throws IOException {\n+        this.streamCompressor.writeCounted(array);\n     }\n     \n-    private void copyFromZipInputStream(final InputStream src) throws IOException {\n+    private void copyFromZipInputStream(final InputStream inputStream) throws IOException {\n         if (this.entry == null) {\n             throw new IllegalStateException(\"No current entry\");\n         }\n         ZipUtil.checkRequestedFeatures(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n         ZipArchiveOutputStream.CurrentEntry.access$302(this.entry, true);\n-        int length;\n-        while ((length = src.read(this.copyBuffer)) >= 0) {\n-            this.streamCompressor.writeCounted(this.copyBuffer, 0, length);\n-            this.count(length);\n+        int read;\n+        while ((read = inputStream.read(this.copyBuffer)) >= 0) {\n+            this.streamCompressor.writeCounted(this.copyBuffer, 0, read);\n+            this.count(read);\n         }\n     }\n     \n     public void close() throws IOException {\n         try {\n             if (!this.finished) {\n                 this.finish();\n@@ -568,272 +561,260 @@\n         }\n     }\n     \n     protected final void deflate() throws IOException {\n         this.streamCompressor.deflate();\n     }\n     \n-    protected void writeLocalFileHeader(final ZipArchiveEntry ze) throws IOException {\n-        this.writeLocalFileHeader(ze, false);\n+    protected void writeLocalFileHeader(final ZipArchiveEntry zipArchiveEntry) throws IOException {\n+        this.writeLocalFileHeader(zipArchiveEntry, false);\n     }\n     \n-    private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n-        final boolean encodable = this.zipEncoding.canEncode(ze.getName());\n-        final ByteBuffer name = this.getName(ze);\n+    private void writeLocalFileHeader(final ZipArchiveEntry zipArchiveEntry, final boolean b) throws IOException {\n+        final boolean canEncode = this.zipEncoding.canEncode(zipArchiveEntry.getName());\n+        final ByteBuffer name = this.getName(zipArchiveEntry);\n         if (this.createUnicodeExtraFields != ZipArchiveOutputStream.UnicodeExtraFieldPolicy.NEVER) {\n-            this.addUnicodeExtraFields(ze, encodable, name);\n+            this.addUnicodeExtraFields(zipArchiveEntry, canEncode, name);\n         }\n-        long localHeaderStart = this.streamCompressor.getTotalBytesWritten();\n+        long n = this.streamCompressor.getTotalBytesWritten();\n         if (this.isSplitZip) {\n-            final ZipSplitOutputStream splitOutputStream = (ZipSplitOutputStream)this.outputStream;\n-            ze.setDiskNumberStart((long)splitOutputStream.getCurrentSplitSegmentIndex());\n-            localHeaderStart = splitOutputStream.getCurrentSplitSegmentBytesWritten();\n-        }\n-        final byte[] localHeader = this.createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n-        this.metaData.put(ze, new ZipArchiveOutputStream.EntryMetaData(localHeaderStart, this.usesDataDescriptor(ze.getMethod(), phased), (ZipArchiveOutputStream.ZipArchiveOutputStream$1)null));\n-        ZipArchiveOutputStream.CurrentEntry.access$402(this.entry, localHeaderStart + 14L);\n-        this.writeCounted(localHeader);\n+            final ZipSplitOutputStream zipSplitOutputStream = (ZipSplitOutputStream)this.outputStream;\n+            zipArchiveEntry.setDiskNumberStart((long)zipSplitOutputStream.getCurrentSplitSegmentIndex());\n+            n = zipSplitOutputStream.getCurrentSplitSegmentBytesWritten();\n+        }\n+        final byte[] localFileHeader = this.createLocalFileHeader(zipArchiveEntry, name, canEncode, b, n);\n+        this.metaData.put(zipArchiveEntry, new ZipArchiveOutputStream.EntryMetaData(n, this.usesDataDescriptor(zipArchiveEntry.getMethod(), b), (ZipArchiveOutputStream.ZipArchiveOutputStream$1)null));\n+        ZipArchiveOutputStream.CurrentEntry.access$402(this.entry, n + 14L);\n+        this.writeCounted(localFileHeader);\n         ZipArchiveOutputStream.CurrentEntry.access$002(this.entry, this.streamCompressor.getTotalBytesWritten());\n     }\n     \n-    private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, final long archiveOffset) {\n-        final ZipExtraField oldEx = ze.getExtraField(ResourceAlignmentExtraField.ID);\n-        if (oldEx != null) {\n-            ze.removeExtraField(ResourceAlignmentExtraField.ID);\n-        }\n-        final ResourceAlignmentExtraField oldAlignmentEx = (oldEx instanceof ResourceAlignmentExtraField) ? ((ResourceAlignmentExtraField)oldEx) : null;\n-        int alignment = ze.getAlignment();\n-        if (alignment <= 0 && oldAlignmentEx != null) {\n-            alignment = oldAlignmentEx.getAlignment();\n-        }\n-        if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n-            final int oldLength = 30 + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n-            final int padding = (int)(-archiveOffset - oldLength - 4L - 2L & (long)(alignment - 1));\n-            ze.addExtraField((ZipExtraField)new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n-        }\n-        final byte[] extra = ze.getLocalFileDataExtra();\n-        final int nameLen = name.limit() - name.position();\n-        final int len = 30 + nameLen + extra.length;\n-        final byte[] buf = new byte[len];\n-        System.arraycopy(ZipArchiveOutputStream.LFH_SIG, 0, buf, 0, 4);\n-        final int zipMethod = ze.getMethod();\n-        final boolean dataDescriptor = this.usesDataDescriptor(zipMethod, phased);\n-        ZipShort.putShort(this.versionNeededToExtract(zipMethod, this.hasZip64Extra(ze), dataDescriptor), buf, 4);\n-        final GeneralPurposeBit generalPurposeBit = this.getGeneralPurposeBits(!encodable && this.fallbackToUTF8, dataDescriptor);\n-        generalPurposeBit.encode(buf, 6);\n-        ZipShort.putShort(zipMethod, buf, 8);\n-        ZipUtil.toDosTime(this.calendarInstance, ze.getTime(), buf, 10);\n-        if (phased || (zipMethod != 8 && this.channel == null)) {\n-            ZipLong.putLong(ze.getCrc(), buf, 14);\n+    private byte[] createLocalFileHeader(final ZipArchiveEntry zipArchiveEntry, final ByteBuffer byteBuffer, final boolean b, final boolean b2, final long n) {\n+        final ZipExtraField extraField = zipArchiveEntry.getExtraField(ResourceAlignmentExtraField.ID);\n+        if (extraField != null) {\n+            zipArchiveEntry.removeExtraField(ResourceAlignmentExtraField.ID);\n+        }\n+        final ResourceAlignmentExtraField resourceAlignmentExtraField = (extraField instanceof ResourceAlignmentExtraField) ? ((ResourceAlignmentExtraField)extraField) : null;\n+        int n2 = zipArchiveEntry.getAlignment();\n+        if (n2 <= 0 && resourceAlignmentExtraField != null) {\n+            n2 = resourceAlignmentExtraField.getAlignment();\n+        }\n+        if (n2 > 1 || (resourceAlignmentExtraField != null && !resourceAlignmentExtraField.allowMethodChange())) {\n+            zipArchiveEntry.addExtraField((ZipExtraField)new ResourceAlignmentExtraField(n2, resourceAlignmentExtraField != null && resourceAlignmentExtraField.allowMethodChange(), (int)(-n - (30 + byteBuffer.limit() - byteBuffer.position() + zipArchiveEntry.getLocalFileDataExtra().length) - 4L - 2L & (long)(n2 - 1))));\n+        }\n+        final byte[] localFileDataExtra = zipArchiveEntry.getLocalFileDataExtra();\n+        final int n3 = byteBuffer.limit() - byteBuffer.position();\n+        final byte[] array = new byte[30 + n3 + localFileDataExtra.length];\n+        System.arraycopy(ZipArchiveOutputStream.LFH_SIG, 0, array, 0, 4);\n+        final int method = zipArchiveEntry.getMethod();\n+        final boolean usesDataDescriptor = this.usesDataDescriptor(method, b2);\n+        ZipShort.putShort(this.versionNeededToExtract(method, this.hasZip64Extra(zipArchiveEntry), usesDataDescriptor), array, 4);\n+        this.getGeneralPurposeBits(!b && this.fallbackToUTF8, usesDataDescriptor).encode(array, 6);\n+        ZipShort.putShort(method, array, 8);\n+        ZipUtil.toDosTime(this.calendarInstance, zipArchiveEntry.getTime(), array, 10);\n+        if (b2 || (method != 8 && this.channel == null)) {\n+            ZipLong.putLong(zipArchiveEntry.getCrc(), array, 14);\n         }\n         else {\n-            System.arraycopy(ZipArchiveOutputStream.LZERO, 0, buf, 14, 4);\n+            System.arraycopy(ZipArchiveOutputStream.LZERO, 0, array, 14, 4);\n         }\n         if (this.hasZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry))) {\n-            ZipLong.ZIP64_MAGIC.putLong(buf, 18);\n-            ZipLong.ZIP64_MAGIC.putLong(buf, 22);\n+            ZipLong.ZIP64_MAGIC.putLong(array, 18);\n+            ZipLong.ZIP64_MAGIC.putLong(array, 22);\n         }\n-        else if (phased) {\n-            ZipLong.putLong(ze.getCompressedSize(), buf, 18);\n-            ZipLong.putLong(ze.getSize(), buf, 22);\n-        }\n-        else if (zipMethod == 8 || this.channel != null) {\n-            System.arraycopy(ZipArchiveOutputStream.LZERO, 0, buf, 18, 4);\n-            System.arraycopy(ZipArchiveOutputStream.LZERO, 0, buf, 22, 4);\n+        else if (b2) {\n+            ZipLong.putLong(zipArchiveEntry.getCompressedSize(), array, 18);\n+            ZipLong.putLong(zipArchiveEntry.getSize(), array, 22);\n+        }\n+        else if (method == 8 || this.channel != null) {\n+            System.arraycopy(ZipArchiveOutputStream.LZERO, 0, array, 18, 4);\n+            System.arraycopy(ZipArchiveOutputStream.LZERO, 0, array, 22, 4);\n         }\n         else {\n-            ZipLong.putLong(ze.getSize(), buf, 18);\n-            ZipLong.putLong(ze.getSize(), buf, 22);\n+            ZipLong.putLong(zipArchiveEntry.getSize(), array, 18);\n+            ZipLong.putLong(zipArchiveEntry.getSize(), array, 22);\n         }\n-        ZipShort.putShort(nameLen, buf, 26);\n-        ZipShort.putShort(extra.length, buf, 28);\n-        System.arraycopy(name.array(), name.arrayOffset(), buf, 30, nameLen);\n-        System.arraycopy(extra, 0, buf, 30 + nameLen, extra.length);\n-        return buf;\n+        ZipShort.putShort(n3, array, 26);\n+        ZipShort.putShort(localFileDataExtra.length, array, 28);\n+        System.arraycopy(byteBuffer.array(), byteBuffer.arrayOffset(), array, 30, n3);\n+        System.arraycopy(localFileDataExtra, 0, array, 30 + n3, localFileDataExtra.length);\n+        return array;\n     }\n     \n-    private void addUnicodeExtraFields(final ZipArchiveEntry ze, final boolean encodable, final ByteBuffer name) throws IOException {\n-        if (this.createUnicodeExtraFields == ZipArchiveOutputStream.UnicodeExtraFieldPolicy.ALWAYS || !encodable) {\n-            ze.addExtraField((ZipExtraField)new UnicodePathExtraField(ze.getName(), name.array(), name.arrayOffset(), name.limit() - name.position()));\n+    private void addUnicodeExtraFields(final ZipArchiveEntry zipArchiveEntry, final boolean b, final ByteBuffer byteBuffer) throws IOException {\n+        if (this.createUnicodeExtraFields == ZipArchiveOutputStream.UnicodeExtraFieldPolicy.ALWAYS || !b) {\n+            zipArchiveEntry.addExtraField((ZipExtraField)new UnicodePathExtraField(zipArchiveEntry.getName(), byteBuffer.array(), byteBuffer.arrayOffset(), byteBuffer.limit() - byteBuffer.position()));\n         }\n-        final String comm = ze.getComment();\n-        if (comm != null && !comm.isEmpty()) {\n-            final boolean commentEncodable = this.zipEncoding.canEncode(comm);\n-            if (this.createUnicodeExtraFields == ZipArchiveOutputStream.UnicodeExtraFieldPolicy.ALWAYS || !commentEncodable) {\n-                final ByteBuffer commentB = this.getEntryEncoding(ze).encode(comm);\n-                ze.addExtraField((ZipExtraField)new UnicodeCommentExtraField(comm, commentB.array(), commentB.arrayOffset(), commentB.limit() - commentB.position()));\n+        final String comment = zipArchiveEntry.getComment();\n+        if (comment != null && !comment.isEmpty()) {\n+            final boolean canEncode = this.zipEncoding.canEncode(comment);\n+            if (this.createUnicodeExtraFields == ZipArchiveOutputStream.UnicodeExtraFieldPolicy.ALWAYS || !canEncode) {\n+                final ByteBuffer encode = this.getEntryEncoding(zipArchiveEntry).encode(comment);\n+                zipArchiveEntry.addExtraField((ZipExtraField)new UnicodeCommentExtraField(comment, encode.array(), encode.arrayOffset(), encode.limit() - encode.position()));\n             }\n         }\n     }\n     \n-    protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n-        if (!this.usesDataDescriptor(ze.getMethod(), false)) {\n+    protected void writeDataDescriptor(final ZipArchiveEntry zipArchiveEntry) throws IOException {\n+        if (!this.usesDataDescriptor(zipArchiveEntry.getMethod(), false)) {\n             return;\n         }\n         this.writeCounted(ZipArchiveOutputStream.DD_SIG);\n-        this.writeCounted(ZipLong.getBytes(ze.getCrc()));\n-        if (!this.hasZip64Extra(ze)) {\n-            this.writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n-            this.writeCounted(ZipLong.getBytes(ze.getSize()));\n+        this.writeCounted(ZipLong.getBytes(zipArchiveEntry.getCrc()));\n+        if (!this.hasZip64Extra(zipArchiveEntry)) {\n+            this.writeCounted(ZipLong.getBytes(zipArchiveEntry.getCompressedSize()));\n+            this.writeCounted(ZipLong.getBytes(zipArchiveEntry.getSize()));\n         }\n         else {\n-            this.writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n-            this.writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n+            this.writeCounted(ZipEightByteInteger.getBytes(zipArchiveEntry.getCompressedSize()));\n+            this.writeCounted(ZipEightByteInteger.getBytes(zipArchiveEntry.getSize()));\n         }\n     }\n     \n-    protected void writeCentralFileHeader(final ZipArchiveEntry ze) throws IOException {\n-        final byte[] centralFileHeader = this.createCentralFileHeader(ze);\n-        this.writeCounted(centralFileHeader);\n+    protected void writeCentralFileHeader(final ZipArchiveEntry zipArchiveEntry) throws IOException {\n+        this.writeCounted(this.createCentralFileHeader(zipArchiveEntry));\n     }\n     \n-    private byte[] createCentralFileHeader(final ZipArchiveEntry ze) throws IOException {\n-        final ZipArchiveOutputStream.EntryMetaData entryMetaData = (ZipArchiveOutputStream.EntryMetaData)this.metaData.get(ze);\n-        final boolean needsZip64Extra = this.hasZip64Extra(ze) || ze.getCompressedSize() >= 4294967295L || ze.getSize() >= 4294967295L || ZipArchiveOutputStream.EntryMetaData.access$800(entryMetaData) >= 4294967295L || ze.getDiskNumberStart() >= 65535L || this.zip64Mode == Zip64Mode.Always || this.zip64Mode == Zip64Mode.AlwaysWithCompatibility;\n-        if (needsZip64Extra && this.zip64Mode == Zip64Mode.Never) {\n+    private byte[] createCentralFileHeader(final ZipArchiveEntry zipArchiveEntry) throws IOException {\n+        final ZipArchiveOutputStream.EntryMetaData entryMetaData = (ZipArchiveOutputStream.EntryMetaData)this.metaData.get(zipArchiveEntry);\n+        final boolean b = this.hasZip64Extra(zipArchiveEntry) || zipArchiveEntry.getCompressedSize() >= 4294967295L || zipArchiveEntry.getSize() >= 4294967295L || ZipArchiveOutputStream.EntryMetaData.access$800(entryMetaData) >= 4294967295L || zipArchiveEntry.getDiskNumberStart() >= 65535L || this.zip64Mode == Zip64Mode.Always || this.zip64Mode == Zip64Mode.AlwaysWithCompatibility;\n+        if (b && this.zip64Mode == Zip64Mode.Never) {\n             throw new Zip64RequiredException(\"Archive's size exceeds the limit of 4GByte.\");\n         }\n-        this.handleZip64Extra(ze, ZipArchiveOutputStream.EntryMetaData.access$800(entryMetaData), needsZip64Extra);\n-        return this.createCentralFileHeader(ze, this.getName(ze), entryMetaData, needsZip64Extra);\n+        this.handleZip64Extra(zipArchiveEntry, ZipArchiveOutputStream.EntryMetaData.access$800(entryMetaData), b);\n+        return this.createCentralFileHeader(zipArchiveEntry, this.getName(zipArchiveEntry), entryMetaData, b);\n     }\n     \n-    private byte[] createCentralFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final ZipArchiveOutputStream.EntryMetaData entryMetaData, final boolean needsZip64Extra) throws IOException {\n+    private byte[] createCentralFileHeader(final ZipArchiveEntry zipArchiveEntry, final ByteBuffer byteBuffer, final ZipArchiveOutputStream.EntryMetaData entryMetaData, final boolean b) throws IOException {\n         if (this.isSplitZip) {\n-            final int currentSplitSegment = ((ZipSplitOutputStream)this.outputStream).getCurrentSplitSegmentIndex();\n-            if (this.numberOfCDInDiskData.get(Integer.valueOf(currentSplitSegment)) == null) {\n-                this.numberOfCDInDiskData.put(Integer.valueOf(currentSplitSegment), Integer.valueOf(1));\n+            final int currentSplitSegmentIndex = ((ZipSplitOutputStream)this.outputStream).getCurrentSplitSegmentIndex();\n+            if (this.numberOfCDInDiskData.get(Integer.valueOf(currentSplitSegmentIndex)) == null) {\n+                this.numberOfCDInDiskData.put(Integer.valueOf(currentSplitSegmentIndex), Integer.valueOf(1));\n             }\n             else {\n-                final int originalNumberOfCD = (int)Integer.valueOf(this.numberOfCDInDiskData.get((Object)Integer.valueOf(currentSplitSegment)));\n-                this.numberOfCDInDiskData.put(Integer.valueOf(currentSplitSegment), Integer.valueOf(originalNumberOfCD + 1));\n+                this.numberOfCDInDiskData.put(Integer.valueOf(currentSplitSegmentIndex), Integer.valueOf((int)Integer.valueOf(this.numberOfCDInDiskData.get((Object)Integer.valueOf(currentSplitSegmentIndex))) + 1));\n             }\n         }\n-        final byte[] extra = ze.getCentralDirectoryExtra();\n-        final int extraLength = extra.length;\n-        String comm = ze.getComment();\n-        if (comm == null) {\n-            comm = \"\";\n-        }\n-        final ByteBuffer commentB = this.getEntryEncoding(ze).encode(comm);\n-        final int nameLen = name.limit() - name.position();\n-        final int commentLen = commentB.limit() - commentB.position();\n-        final int len = 46 + nameLen + extraLength + commentLen;\n-        final byte[] buf = new byte[len];\n-        System.arraycopy(ZipArchiveOutputStream.CFH_SIG, 0, buf, 0, 4);\n-        ZipShort.putShort(ze.getPlatform() << 8 | (this.hasUsedZip64 ? 45 : 20), buf, 4);\n-        final int zipMethod = ze.getMethod();\n-        final boolean encodable = this.zipEncoding.canEncode(ze.getName());\n-        ZipShort.putShort(this.versionNeededToExtract(zipMethod, needsZip64Extra, ZipArchiveOutputStream.EntryMetaData.access$900(entryMetaData)), buf, 6);\n-        this.getGeneralPurposeBits(!encodable && this.fallbackToUTF8, ZipArchiveOutputStream.EntryMetaData.access$900(entryMetaData)).encode(buf, 8);\n-        ZipShort.putShort(zipMethod, buf, 10);\n-        ZipUtil.toDosTime(this.calendarInstance, ze.getTime(), buf, 12);\n-        ZipLong.putLong(ze.getCrc(), buf, 16);\n-        if (ze.getCompressedSize() >= 4294967295L || ze.getSize() >= 4294967295L || this.zip64Mode == Zip64Mode.Always || this.zip64Mode == Zip64Mode.AlwaysWithCompatibility) {\n-            ZipLong.ZIP64_MAGIC.putLong(buf, 20);\n-            ZipLong.ZIP64_MAGIC.putLong(buf, 24);\n+        final byte[] centralDirectoryExtra = zipArchiveEntry.getCentralDirectoryExtra();\n+        final int length = centralDirectoryExtra.length;\n+        String comment = zipArchiveEntry.getComment();\n+        if (comment == null) {\n+            comment = \"\";\n+        }\n+        final ByteBuffer encode = this.getEntryEncoding(zipArchiveEntry).encode(comment);\n+        final int n = byteBuffer.limit() - byteBuffer.position();\n+        final int n2 = encode.limit() - encode.position();\n+        final byte[] array = new byte[46 + n + length + n2];\n+        System.arraycopy(ZipArchiveOutputStream.CFH_SIG, 0, array, 0, 4);\n+        ZipShort.putShort(zipArchiveEntry.getPlatform() << 8 | (this.hasUsedZip64 ? 45 : 20), array, 4);\n+        final int method = zipArchiveEntry.getMethod();\n+        final boolean canEncode = this.zipEncoding.canEncode(zipArchiveEntry.getName());\n+        ZipShort.putShort(this.versionNeededToExtract(method, b, ZipArchiveOutputStream.EntryMetaData.access$900(entryMetaData)), array, 6);\n+        this.getGeneralPurposeBits(!canEncode && this.fallbackToUTF8, ZipArchiveOutputStream.EntryMetaData.access$900(entryMetaData)).encode(array, 8);\n+        ZipShort.putShort(method, array, 10);\n+        ZipUtil.toDosTime(this.calendarInstance, zipArchiveEntry.getTime(), array, 12);\n+        ZipLong.putLong(zipArchiveEntry.getCrc(), array, 16);\n+        if (zipArchiveEntry.getCompressedSize() >= 4294967295L || zipArchiveEntry.getSize() >= 4294967295L || this.zip64Mode == Zip64Mode.Always || this.zip64Mode == Zip64Mode.AlwaysWithCompatibility) {\n+            ZipLong.ZIP64_MAGIC.putLong(array, 20);\n+            ZipLong.ZIP64_MAGIC.putLong(array, 24);\n         }\n         else {\n-            ZipLong.putLong(ze.getCompressedSize(), buf, 20);\n-            ZipLong.putLong(ze.getSize(), buf, 24);\n+            ZipLong.putLong(zipArchiveEntry.getCompressedSize(), array, 20);\n+            ZipLong.putLong(zipArchiveEntry.getSize(), array, 24);\n         }\n-        ZipShort.putShort(nameLen, buf, 28);\n-        ZipShort.putShort(extraLength, buf, 30);\n-        ZipShort.putShort(commentLen, buf, 32);\n+        ZipShort.putShort(n, array, 28);\n+        ZipShort.putShort(length, array, 30);\n+        ZipShort.putShort(n2, array, 32);\n         if (this.isSplitZip) {\n-            if (ze.getDiskNumberStart() >= 65535L || this.zip64Mode == Zip64Mode.Always) {\n-                ZipShort.putShort(65535, buf, 34);\n+            if (zipArchiveEntry.getDiskNumberStart() >= 65535L || this.zip64Mode == Zip64Mode.Always) {\n+                ZipShort.putShort(65535, array, 34);\n             }\n             else {\n-                ZipShort.putShort((int)ze.getDiskNumberStart(), buf, 34);\n+                ZipShort.putShort((int)zipArchiveEntry.getDiskNumberStart(), array, 34);\n             }\n         }\n         else {\n-            System.arraycopy(ZipArchiveOutputStream.ZERO, 0, buf, 34, 2);\n+            System.arraycopy(ZipArchiveOutputStream.ZERO, 0, array, 34, 2);\n         }\n-        ZipShort.putShort(ze.getInternalAttributes(), buf, 36);\n-        ZipLong.putLong(ze.getExternalAttributes(), buf, 38);\n+        ZipShort.putShort(zipArchiveEntry.getInternalAttributes(), array, 36);\n+        ZipLong.putLong(zipArchiveEntry.getExternalAttributes(), array, 38);\n         if (ZipArchiveOutputStream.EntryMetaData.access$800(entryMetaData) >= 4294967295L || this.zip64Mode == Zip64Mode.Always) {\n-            ZipLong.putLong(4294967295L, buf, 42);\n+            ZipLong.putLong(4294967295L, array, 42);\n         }\n         else {\n-            ZipLong.putLong(Math.min(ZipArchiveOutputStream.EntryMetaData.access$800(entryMetaData), 4294967295L), buf, 42);\n+            ZipLong.putLong(Math.min(ZipArchiveOutputStream.EntryMetaData.access$800(entryMetaData), 4294967295L), array, 42);\n         }\n-        System.arraycopy(name.array(), name.arrayOffset(), buf, 46, nameLen);\n-        final int extraStart = 46 + nameLen;\n-        System.arraycopy(extra, 0, buf, extraStart, extraLength);\n-        final int commentStart = extraStart + extraLength;\n-        System.arraycopy(commentB.array(), commentB.arrayOffset(), buf, commentStart, commentLen);\n-        return buf;\n-    }\n-    \n-    private void handleZip64Extra(final ZipArchiveEntry ze, final long lfhOffset, final boolean needsZip64Extra) {\n-        if (needsZip64Extra) {\n-            final Zip64ExtendedInformationExtraField z64 = this.getZip64Extra(ze);\n-            if (ze.getCompressedSize() >= 4294967295L || ze.getSize() >= 4294967295L || this.zip64Mode == Zip64Mode.Always || this.zip64Mode == Zip64Mode.AlwaysWithCompatibility) {\n-                z64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));\n-                z64.setSize(new ZipEightByteInteger(ze.getSize()));\n+        System.arraycopy(byteBuffer.array(), byteBuffer.arrayOffset(), array, 46, n);\n+        final int n3 = 46 + n;\n+        System.arraycopy(centralDirectoryExtra, 0, array, n3, length);\n+        System.arraycopy(encode.array(), encode.arrayOffset(), array, n3 + length, n2);\n+        return array;\n+    }\n+    \n+    private void handleZip64Extra(final ZipArchiveEntry zipArchiveEntry, final long n, final boolean b) {\n+        if (b) {\n+            final Zip64ExtendedInformationExtraField zip64Extra = this.getZip64Extra(zipArchiveEntry);\n+            if (zipArchiveEntry.getCompressedSize() >= 4294967295L || zipArchiveEntry.getSize() >= 4294967295L || this.zip64Mode == Zip64Mode.Always || this.zip64Mode == Zip64Mode.AlwaysWithCompatibility) {\n+                zip64Extra.setCompressedSize(new ZipEightByteInteger(zipArchiveEntry.getCompressedSize()));\n+                zip64Extra.setSize(new ZipEightByteInteger(zipArchiveEntry.getSize()));\n             }\n             else {\n-                z64.setCompressedSize((ZipEightByteInteger)null);\n-                z64.setSize((ZipEightByteInteger)null);\n+                zip64Extra.setCompressedSize((ZipEightByteInteger)null);\n+                zip64Extra.setSize((ZipEightByteInteger)null);\n             }\n-            final boolean needsToEncodeLfhOffset = lfhOffset >= 4294967295L || this.zip64Mode == Zip64Mode.Always;\n-            final boolean needsToEncodeDiskNumberStart = ze.getDiskNumberStart() >= 65535L || this.zip64Mode == Zip64Mode.Always;\n-            if (needsToEncodeLfhOffset || needsToEncodeDiskNumberStart) {\n-                z64.setRelativeHeaderOffset(new ZipEightByteInteger(lfhOffset));\n+            final boolean b2 = n >= 4294967295L || this.zip64Mode == Zip64Mode.Always;\n+            final boolean b3 = zipArchiveEntry.getDiskNumberStart() >= 65535L || this.zip64Mode == Zip64Mode.Always;\n+            if (b2 || b3) {\n+                zip64Extra.setRelativeHeaderOffset(new ZipEightByteInteger(n));\n             }\n-            if (needsToEncodeDiskNumberStart) {\n-                z64.setDiskStartNumber(new ZipLong(ze.getDiskNumberStart()));\n+            if (b3) {\n+                zip64Extra.setDiskStartNumber(new ZipLong(zipArchiveEntry.getDiskNumberStart()));\n             }\n-            ze.setExtra();\n+            zipArchiveEntry.setExtra();\n         }\n     }\n     \n     protected void writeCentralDirectoryEnd() throws IOException {\n         if (!this.hasUsedZip64 && this.isSplitZip) {\n             ((ZipSplitOutputStream)this.outputStream).prepareToWriteUnsplittableContent(this.eocdLength);\n         }\n         this.validateIfZip64IsNeededInEOCD();\n         this.writeCounted(ZipArchiveOutputStream.EOCD_SIG);\n-        int numberOfThisDisk = 0;\n+        int currentSplitSegmentIndex = 0;\n         if (this.isSplitZip) {\n-            numberOfThisDisk = ((ZipSplitOutputStream)this.outputStream).getCurrentSplitSegmentIndex();\n+            currentSplitSegmentIndex = ((ZipSplitOutputStream)this.outputStream).getCurrentSplitSegmentIndex();\n         }\n-        this.writeCounted(ZipShort.getBytes(numberOfThisDisk));\n+        this.writeCounted(ZipShort.getBytes(currentSplitSegmentIndex));\n         this.writeCounted(ZipShort.getBytes((int)this.cdDiskNumberStart));\n-        final int numberOfEntries = this.entries.size();\n-        final int numOfEntriesOnThisDisk = this.isSplitZip ? ((this.numberOfCDInDiskData.get(Integer.valueOf(numberOfThisDisk)) == null) ? 0 : ((int)Integer.valueOf(this.numberOfCDInDiskData.get((Object)Integer.valueOf(numberOfThisDisk))))) : numberOfEntries;\n-        final byte[] numOfEntriesOnThisDiskData = ZipShort.getBytes(Math.min(numOfEntriesOnThisDisk, 65535));\n-        this.writeCounted(numOfEntriesOnThisDiskData);\n-        final byte[] num = ZipShort.getBytes(Math.min(numberOfEntries, 65535));\n-        this.writeCounted(num);\n+        final int size = this.entries.size();\n+        this.writeCounted(ZipShort.getBytes(Math.min(this.isSplitZip ? ((this.numberOfCDInDiskData.get(Integer.valueOf(currentSplitSegmentIndex)) == null) ? 0 : ((int)Integer.valueOf(this.numberOfCDInDiskData.get((Object)Integer.valueOf(currentSplitSegmentIndex))))) : size, 65535)));\n+        this.writeCounted(ZipShort.getBytes(Math.min(size, 65535)));\n         this.writeCounted(ZipLong.getBytes(Math.min(this.cdLength, 4294967295L)));\n         this.writeCounted(ZipLong.getBytes(Math.min(this.cdOffset, 4294967295L)));\n-        final ByteBuffer data = this.zipEncoding.encode(this.comment);\n-        final int dataLen = data.limit() - data.position();\n-        this.writeCounted(ZipShort.getBytes(dataLen));\n-        this.streamCompressor.writeCounted(data.array(), data.arrayOffset(), dataLen);\n+        final ByteBuffer encode = this.zipEncoding.encode(this.comment);\n+        final int n = encode.limit() - encode.position();\n+        this.writeCounted(ZipShort.getBytes(n));\n+        this.streamCompressor.writeCounted(encode.array(), encode.arrayOffset(), n);\n     }\n     \n     private void validateIfZip64IsNeededInEOCD() throws Zip64RequiredException {\n         if (this.zip64Mode != Zip64Mode.Never) {\n             return;\n         }\n-        int numberOfThisDisk = 0;\n+        int currentSplitSegmentIndex = 0;\n         if (this.isSplitZip) {\n-            numberOfThisDisk = ((ZipSplitOutputStream)this.outputStream).getCurrentSplitSegmentIndex();\n+            currentSplitSegmentIndex = ((ZipSplitOutputStream)this.outputStream).getCurrentSplitSegmentIndex();\n         }\n-        if (numberOfThisDisk >= 65535) {\n+        if (currentSplitSegmentIndex >= 65535) {\n             throw new Zip64RequiredException(\"Number of the disk of End Of Central Directory exceeds the limit of 65535.\");\n         }\n         if (this.cdDiskNumberStart >= 65535L) {\n             throw new Zip64RequiredException(\"Number of the disk with the start of Central Directory exceeds the limit of 65535.\");\n         }\n-        final int numOfEntriesOnThisDisk = (this.numberOfCDInDiskData.get(Integer.valueOf(numberOfThisDisk)) == null) ? 0 : ((int)Integer.valueOf(this.numberOfCDInDiskData.get((Object)Integer.valueOf(numberOfThisDisk))));\n-        if (numOfEntriesOnThisDisk >= 65535) {\n+        if (((this.numberOfCDInDiskData.get(Integer.valueOf(currentSplitSegmentIndex)) == null) ? 0 : ((int)Integer.valueOf(this.numberOfCDInDiskData.get((Object)Integer.valueOf(currentSplitSegmentIndex))))) >= 65535) {\n             throw new Zip64RequiredException(\"Number of entries on this disk exceeds the limit of 65535.\");\n         }\n         if (this.entries.size() >= 65535) {\n             throw new Zip64RequiredException(\"Archive contains more than 65535 entries.\");\n         }\n         if (this.cdLength >= 4294967295L) {\n             throw new Zip64RequiredException(\"The size of the entire central directory exceeds the limit of 4GByte.\");\n@@ -849,145 +830,138 @@\n         }\n         if (!this.hasUsedZip64 && this.shouldUseZip64EOCD()) {\n             this.hasUsedZip64 = true;\n         }\n         if (!this.hasUsedZip64) {\n             return;\n         }\n-        long offset = this.streamCompressor.getTotalBytesWritten();\n-        long diskNumberStart = 0L;\n+        long n = this.streamCompressor.getTotalBytesWritten();\n+        long n2 = 0L;\n         if (this.isSplitZip) {\n             final ZipSplitOutputStream zipSplitOutputStream = (ZipSplitOutputStream)this.outputStream;\n-            offset = zipSplitOutputStream.getCurrentSplitSegmentBytesWritten();\n-            diskNumberStart = zipSplitOutputStream.getCurrentSplitSegmentIndex();\n+            n = zipSplitOutputStream.getCurrentSplitSegmentBytesWritten();\n+            n2 = zipSplitOutputStream.getCurrentSplitSegmentIndex();\n         }\n         this.writeOut(ZipArchiveOutputStream.ZIP64_EOCD_SIG);\n         this.writeOut(ZipEightByteInteger.getBytes(44L));\n         this.writeOut(ZipShort.getBytes(45));\n         this.writeOut(ZipShort.getBytes(45));\n-        int numberOfThisDisk = 0;\n+        int currentSplitSegmentIndex = 0;\n         if (this.isSplitZip) {\n-            numberOfThisDisk = ((ZipSplitOutputStream)this.outputStream).getCurrentSplitSegmentIndex();\n+            currentSplitSegmentIndex = ((ZipSplitOutputStream)this.outputStream).getCurrentSplitSegmentIndex();\n         }\n-        this.writeOut(ZipLong.getBytes((long)numberOfThisDisk));\n+        this.writeOut(ZipLong.getBytes((long)currentSplitSegmentIndex));\n         this.writeOut(ZipLong.getBytes(this.cdDiskNumberStart));\n-        final int numOfEntriesOnThisDisk = this.isSplitZip ? ((this.numberOfCDInDiskData.get(Integer.valueOf(numberOfThisDisk)) == null) ? 0 : ((int)Integer.valueOf(this.numberOfCDInDiskData.get((Object)Integer.valueOf(numberOfThisDisk))))) : this.entries.size();\n-        final byte[] numOfEntriesOnThisDiskData = ZipEightByteInteger.getBytes((long)numOfEntriesOnThisDisk);\n-        this.writeOut(numOfEntriesOnThisDiskData);\n-        final byte[] num = ZipEightByteInteger.getBytes((long)this.entries.size());\n-        this.writeOut(num);\n+        this.writeOut(ZipEightByteInteger.getBytes((long)(this.isSplitZip ? ((this.numberOfCDInDiskData.get(Integer.valueOf(currentSplitSegmentIndex)) == null) ? 0 : ((int)Integer.valueOf(this.numberOfCDInDiskData.get((Object)Integer.valueOf(currentSplitSegmentIndex))))) : this.entries.size())));\n+        this.writeOut(ZipEightByteInteger.getBytes((long)this.entries.size()));\n         this.writeOut(ZipEightByteInteger.getBytes(this.cdLength));\n         this.writeOut(ZipEightByteInteger.getBytes(this.cdOffset));\n         if (this.isSplitZip) {\n-            final int zip64EOCDLOCLength = 20;\n-            final long unsplittableContentSize = 20L + this.eocdLength;\n-            ((ZipSplitOutputStream)this.outputStream).prepareToWriteUnsplittableContent(unsplittableContentSize);\n+            ((ZipSplitOutputStream)this.outputStream).prepareToWriteUnsplittableContent(20L + this.eocdLength);\n         }\n         this.writeOut(ZipArchiveOutputStream.ZIP64_EOCD_LOC_SIG);\n-        this.writeOut(ZipLong.getBytes(diskNumberStart));\n-        this.writeOut(ZipEightByteInteger.getBytes(offset));\n+        this.writeOut(ZipLong.getBytes(n2));\n+        this.writeOut(ZipEightByteInteger.getBytes(n));\n         if (this.isSplitZip) {\n-            final int totalNumberOfDisks = ((ZipSplitOutputStream)this.outputStream).getCurrentSplitSegmentIndex() + 1;\n-            this.writeOut(ZipLong.getBytes((long)totalNumberOfDisks));\n+            this.writeOut(ZipLong.getBytes((long)(((ZipSplitOutputStream)this.outputStream).getCurrentSplitSegmentIndex() + 1)));\n         }\n         else {\n             this.writeOut(ZipArchiveOutputStream.ONE);\n         }\n     }\n     \n     private boolean shouldUseZip64EOCD() {\n-        int numberOfThisDisk = 0;\n+        int currentSplitSegmentIndex = 0;\n         if (this.isSplitZip) {\n-            numberOfThisDisk = ((ZipSplitOutputStream)this.outputStream).getCurrentSplitSegmentIndex();\n+            currentSplitSegmentIndex = ((ZipSplitOutputStream)this.outputStream).getCurrentSplitSegmentIndex();\n         }\n-        final int numOfEntriesOnThisDisk = (this.numberOfCDInDiskData.get(Integer.valueOf(numberOfThisDisk)) == null) ? 0 : ((int)Integer.valueOf(this.numberOfCDInDiskData.get((Object)Integer.valueOf(numberOfThisDisk))));\n-        return numberOfThisDisk >= 65535 || this.cdDiskNumberStart >= 65535L || numOfEntriesOnThisDisk >= 65535 || this.entries.size() >= 65535 || this.cdLength >= 4294967295L || this.cdOffset >= 4294967295L;\n+        final int n = (this.numberOfCDInDiskData.get(Integer.valueOf(currentSplitSegmentIndex)) == null) ? 0 : ((int)Integer.valueOf(this.numberOfCDInDiskData.get((Object)Integer.valueOf(currentSplitSegmentIndex))));\n+        return currentSplitSegmentIndex >= 65535 || this.cdDiskNumberStart >= 65535L || n >= 65535 || this.entries.size() >= 65535 || this.cdLength >= 4294967295L || this.cdOffset >= 4294967295L;\n     }\n     \n-    protected final void writeOut(final byte[] data) throws IOException {\n-        this.streamCompressor.writeOut(data, 0, data.length);\n+    protected final void writeOut(final byte[] array) throws IOException {\n+        this.streamCompressor.writeOut(array, 0, array.length);\n     }\n     \n-    protected final void writeOut(final byte[] data, final int offset, final int length) throws IOException {\n-        this.streamCompressor.writeOut(data, offset, length);\n+    protected final void writeOut(final byte[] array, final int n, final int n2) throws IOException {\n+        this.streamCompressor.writeOut(array, n, n2);\n     }\n     \n-    private GeneralPurposeBit getGeneralPurposeBits(final boolean utfFallback, final boolean usesDataDescriptor) {\n-        final GeneralPurposeBit b = new GeneralPurposeBit();\n-        b.useUTF8ForNames(this.useUTF8Flag || utfFallback);\n-        if (usesDataDescriptor) {\n-            b.useDataDescriptor(true);\n+    private GeneralPurposeBit getGeneralPurposeBits(final boolean b, final boolean b2) {\n+        final GeneralPurposeBit generalPurposeBit = new GeneralPurposeBit();\n+        generalPurposeBit.useUTF8ForNames(this.useUTF8Flag || b);\n+        if (b2) {\n+            generalPurposeBit.useDataDescriptor(true);\n         }\n-        return b;\n+        return generalPurposeBit;\n     }\n     \n-    private int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n-        if (zip64) {\n+    private int versionNeededToExtract(final int n, final boolean b, final boolean b2) {\n+        if (b) {\n             return 45;\n         }\n-        if (usedDataDescriptor) {\n+        if (b2) {\n             return 20;\n         }\n-        return this.versionNeededToExtractMethod(zipMethod);\n+        return this.versionNeededToExtractMethod(n);\n     }\n     \n-    private boolean usesDataDescriptor(final int zipMethod, final boolean phased) {\n-        return !phased && zipMethod == 8 && this.channel == null;\n+    private boolean usesDataDescriptor(final int n, final boolean b) {\n+        return !b && n == 8 && this.channel == null;\n     }\n     \n-    private int versionNeededToExtractMethod(final int zipMethod) {\n-        return (zipMethod == 8) ? 20 : 10;\n+    private int versionNeededToExtractMethod(final int n) {\n+        return (n == 8) ? 20 : 10;\n     }\n     \n-    public ArchiveEntry createArchiveEntry(final File inputFile, final String entryName) throws IOException {\n+    public ArchiveEntry createArchiveEntry(final File file, final String s) throws IOException {\n         if (this.finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n-        return (ArchiveEntry)new ZipArchiveEntry(inputFile, entryName);\n+        return (ArchiveEntry)new ZipArchiveEntry(file, s);\n     }\n     \n-    public ArchiveEntry createArchiveEntry(final Path inputPath, final String entryName, final LinkOption... options) throws IOException {\n+    public ArchiveEntry createArchiveEntry(final Path path, final String s, final LinkOption... array) throws IOException {\n         if (this.finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n-        return (ArchiveEntry)new ZipArchiveEntry(inputPath, entryName, new LinkOption[0]);\n+        return (ArchiveEntry)new ZipArchiveEntry(path, s, new LinkOption[0]);\n     }\n     \n-    private Zip64ExtendedInformationExtraField getZip64Extra(final ZipArchiveEntry ze) {\n+    private Zip64ExtendedInformationExtraField getZip64Extra(final ZipArchiveEntry zipArchiveEntry) {\n         if (this.entry != null) {\n             ZipArchiveOutputStream.CurrentEntry.access$502(this.entry, !this.hasUsedZip64);\n         }\n         this.hasUsedZip64 = true;\n-        final ZipExtraField extra = ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n-        Zip64ExtendedInformationExtraField z64 = (extra instanceof Zip64ExtendedInformationExtraField) ? ((Zip64ExtendedInformationExtraField)extra) : null;\n-        if (z64 == null) {\n-            z64 = new Zip64ExtendedInformationExtraField();\n+        final ZipExtraField extraField = zipArchiveEntry.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n+        Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField = (extraField instanceof Zip64ExtendedInformationExtraField) ? ((Zip64ExtendedInformationExtraField)extraField) : null;\n+        if (zip64ExtendedInformationExtraField == null) {\n+            zip64ExtendedInformationExtraField = new Zip64ExtendedInformationExtraField();\n         }\n-        ze.addAsFirstExtraField((ZipExtraField)z64);\n-        return z64;\n+        zipArchiveEntry.addAsFirstExtraField((ZipExtraField)zip64ExtendedInformationExtraField);\n+        return zip64ExtendedInformationExtraField;\n     }\n     \n-    private boolean hasZip64Extra(final ZipArchiveEntry ze) {\n-        return ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID) instanceof Zip64ExtendedInformationExtraField;\n+    private boolean hasZip64Extra(final ZipArchiveEntry zipArchiveEntry) {\n+        return zipArchiveEntry.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID) instanceof Zip64ExtendedInformationExtraField;\n     }\n     \n-    private Zip64Mode getEffectiveZip64Mode(final ZipArchiveEntry ze) {\n-        if (this.zip64Mode != Zip64Mode.AsNeeded || this.channel != null || ze.getMethod() != 8 || ze.getSize() != -1L) {\n+    private Zip64Mode getEffectiveZip64Mode(final ZipArchiveEntry zipArchiveEntry) {\n+        if (this.zip64Mode != Zip64Mode.AsNeeded || this.channel != null || zipArchiveEntry.getMethod() != 8 || zipArchiveEntry.getSize() != -1L) {\n             return this.zip64Mode;\n         }\n         return Zip64Mode.Never;\n     }\n     \n-    private ZipEncoding getEntryEncoding(final ZipArchiveEntry ze) {\n-        final boolean encodable = this.zipEncoding.canEncode(ze.getName());\n-        return (!encodable && this.fallbackToUTF8) ? ZipEncodingHelper.UTF8_ZIP_ENCODING : this.zipEncoding;\n+    private ZipEncoding getEntryEncoding(final ZipArchiveEntry zipArchiveEntry) {\n+        return (!this.zipEncoding.canEncode(zipArchiveEntry.getName()) && this.fallbackToUTF8) ? ZipEncodingHelper.UTF8_ZIP_ENCODING : this.zipEncoding;\n     }\n     \n-    private ByteBuffer getName(final ZipArchiveEntry ze) throws IOException {\n-        return this.getEntryEncoding(ze).encode(ze.getName());\n+    private ByteBuffer getName(final ZipArchiveEntry zipArchiveEntry) throws IOException {\n+        return this.getEntryEncoding(zipArchiveEntry).encode(zipArchiveEntry.getName());\n     }\n     \n     void destroy() throws IOException {\n         try {\n             if (this.channel != null) {\n                 this.channel.close();\n             }\n"}]}
