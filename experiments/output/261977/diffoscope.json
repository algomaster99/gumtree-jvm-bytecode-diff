{"diffoscope-json-version": 1, "source1": "first/ArrayUtils.class", "source2": "second/ArrayUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,14 +1,14 @@\n \n package org.apache.commons.lang3;\n \n import org.apache.commons.lang3.builder.ToStringBuilder;\n import org.apache.commons.lang3.builder.ToStringStyle;\n-import java.util.Random;\n import java.util.Map;\n+import java.util.Random;\n import org.apache.commons.lang3.mutable.MutableInt;\n import java.util.HashMap;\n import java.util.Comparator;\n import org.apache.commons.lang3.math.NumberUtils;\n import org.apache.commons.lang3.builder.EqualsBuilder;\n import java.util.BitSet;\n import org.apache.commons.lang3.builder.HashCodeBuilder;\n@@ -40,319 +40,318 @@\n     public static final short[] EMPTY_SHORT_ARRAY;\n     public static final Short[] EMPTY_SHORT_OBJECT_ARRAY;\n     public static final String[] EMPTY_STRING_ARRAY;\n     public static final Throwable[] EMPTY_THROWABLE_ARRAY;\n     public static final Type[] EMPTY_TYPE_ARRAY;\n     public static final int INDEX_NOT_FOUND = -1;\n     \n-    public static boolean[] add(final boolean[] array, final boolean element) {\n-        final boolean[] newArray = (boolean[])copyArrayGrow1(array, Boolean.TYPE);\n-        newArray[newArray.length - 1] = element;\n-        return newArray;\n+    public static boolean[] add(final boolean[] array, final boolean b) {\n+        final boolean[] array2 = (boolean[])copyArrayGrow1(array, Boolean.TYPE);\n+        array2[array2.length - 1] = b;\n+        return array2;\n     }\n     \n     @Deprecated\n-    public static boolean[] add(final boolean[] array, final int index, final boolean element) {\n-        return (boolean[])add(array, index, Boolean.valueOf(element), Boolean.TYPE);\n+    public static boolean[] add(final boolean[] array, final int n, final boolean b) {\n+        return (boolean[])add(array, n, Boolean.valueOf(b), Boolean.TYPE);\n     }\n     \n-    public static byte[] add(final byte[] array, final byte element) {\n-        final byte[] newArray = (byte[])copyArrayGrow1(array, Byte.TYPE);\n-        newArray[newArray.length - 1] = element;\n-        return newArray;\n+    public static byte[] add(final byte[] array, final byte b) {\n+        final byte[] array2 = (byte[])copyArrayGrow1(array, Byte.TYPE);\n+        array2[array2.length - 1] = b;\n+        return array2;\n     }\n     \n     @Deprecated\n-    public static byte[] add(final byte[] array, final int index, final byte element) {\n-        return (byte[])add(array, index, Byte.valueOf(element), Byte.TYPE);\n+    public static byte[] add(final byte[] array, final int n, final byte b) {\n+        return (byte[])add(array, n, Byte.valueOf(b), Byte.TYPE);\n     }\n     \n-    public static char[] add(final char[] array, final char element) {\n-        final char[] newArray = (char[])copyArrayGrow1(array, Character.TYPE);\n-        newArray[newArray.length - 1] = element;\n-        return newArray;\n+    public static char[] add(final char[] array, final char c) {\n+        final char[] array2 = (char[])copyArrayGrow1(array, Character.TYPE);\n+        array2[array2.length - 1] = c;\n+        return array2;\n     }\n     \n     @Deprecated\n-    public static char[] add(final char[] array, final int index, final char element) {\n-        return (char[])add(array, index, Character.valueOf(element), Character.TYPE);\n+    public static char[] add(final char[] array, final int n, final char c) {\n+        return (char[])add(array, n, Character.valueOf(c), Character.TYPE);\n     }\n     \n-    public static double[] add(final double[] array, final double element) {\n-        final double[] newArray = (double[])copyArrayGrow1(array, Double.TYPE);\n-        newArray[newArray.length - 1] = element;\n-        return newArray;\n+    public static double[] add(final double[] array, final double n) {\n+        final double[] array2 = (double[])copyArrayGrow1(array, Double.TYPE);\n+        array2[array2.length - 1] = n;\n+        return array2;\n     }\n     \n     @Deprecated\n-    public static double[] add(final double[] array, final int index, final double element) {\n-        return (double[])add(array, index, Double.valueOf(element), Double.TYPE);\n+    public static double[] add(final double[] array, final int n, final double d) {\n+        return (double[])add(array, n, Double.valueOf(d), Double.TYPE);\n     }\n     \n-    public static float[] add(final float[] array, final float element) {\n-        final float[] newArray = (float[])copyArrayGrow1(array, Float.TYPE);\n-        newArray[newArray.length - 1] = element;\n-        return newArray;\n+    public static float[] add(final float[] array, final float n) {\n+        final float[] array2 = (float[])copyArrayGrow1(array, Float.TYPE);\n+        array2[array2.length - 1] = n;\n+        return array2;\n     }\n     \n     @Deprecated\n-    public static float[] add(final float[] array, final int index, final float element) {\n-        return (float[])add(array, index, Float.valueOf(element), Float.TYPE);\n+    public static float[] add(final float[] array, final int n, final float f) {\n+        return (float[])add(array, n, Float.valueOf(f), Float.TYPE);\n     }\n     \n-    public static int[] add(final int[] array, final int element) {\n-        final int[] newArray = (int[])copyArrayGrow1(array, Integer.TYPE);\n-        newArray[newArray.length - 1] = element;\n-        return newArray;\n+    public static int[] add(final int[] array, final int n) {\n+        final int[] array2 = (int[])copyArrayGrow1(array, Integer.TYPE);\n+        array2[array2.length - 1] = n;\n+        return array2;\n     }\n     \n     @Deprecated\n-    public static int[] add(final int[] array, final int index, final int element) {\n-        return (int[])add(array, index, Integer.valueOf(element), Integer.TYPE);\n+    public static int[] add(final int[] array, final int n, final int i) {\n+        return (int[])add(array, n, Integer.valueOf(i), Integer.TYPE);\n     }\n     \n     @Deprecated\n-    public static long[] add(final long[] array, final int index, final long element) {\n-        return (long[])add(array, index, Long.valueOf(element), Long.TYPE);\n+    public static long[] add(final long[] array, final int n, final long l) {\n+        return (long[])add(array, n, Long.valueOf(l), Long.TYPE);\n     }\n     \n-    public static long[] add(final long[] array, final long element) {\n-        final long[] newArray = (long[])copyArrayGrow1(array, Long.TYPE);\n-        newArray[newArray.length - 1] = element;\n-        return newArray;\n+    public static long[] add(final long[] array, final long n) {\n+        final long[] array2 = (long[])copyArrayGrow1(array, Long.TYPE);\n+        array2[array2.length - 1] = n;\n+        return array2;\n     }\n     \n-    private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {\n-        if (array == null) {\n-            if (index != 0) {\n-                throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: 0\");\n+    private static Object add(final Object o, final int n, final Object o2, final Class<?> clazz) {\n+        if (o == null) {\n+            if (n != 0) {\n+                throw new IndexOutOfBoundsException(\"Index: \" + n + \", Length: 0\");\n             }\n-            final Object joinedArray = Array.newInstance(clss, 1);\n-            Array.set(joinedArray, 0, element);\n-            return joinedArray;\n+            final Object instance = Array.newInstance(clazz, 1);\n+            Array.set(instance, 0, o2);\n+            return instance;\n         }\n         else {\n-            final int length = Array.getLength(array);\n-            if (index > length || index < 0) {\n-                throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n-            }\n-            final Object result = Array.newInstance(clss, length + 1);\n-            System.arraycopy(array, 0, result, 0, index);\n-            Array.set(result, index, element);\n-            if (index < length) {\n-                System.arraycopy(array, index, result, index + 1, length - index);\n+            final int length = Array.getLength(o);\n+            if (n > length || n < 0) {\n+                throw new IndexOutOfBoundsException(\"Index: \" + n + \", Length: \" + length);\n+            }\n+            final Object instance2 = Array.newInstance(clazz, length + 1);\n+            System.arraycopy(o, 0, instance2, 0, n);\n+            Array.set(instance2, n, o2);\n+            if (n < length) {\n+                System.arraycopy(o, n, instance2, n + 1, length - n);\n             }\n-            return result;\n+            return instance2;\n         }\n     }\n     \n     @Deprecated\n-    public static short[] add(final short[] array, final int index, final short element) {\n-        return (short[])add(array, index, Short.valueOf(element), Short.TYPE);\n+    public static short[] add(final short[] array, final int n, final short s) {\n+        return (short[])add(array, n, Short.valueOf(s), Short.TYPE);\n     }\n     \n-    public static short[] add(final short[] array, final short element) {\n-        final short[] newArray = (short[])copyArrayGrow1(array, Short.TYPE);\n-        newArray[newArray.length - 1] = element;\n-        return newArray;\n+    public static short[] add(final short[] array, final short n) {\n+        final short[] array2 = (short[])copyArrayGrow1(array, Short.TYPE);\n+        array2[array2.length - 1] = n;\n+        return array2;\n     }\n     \n     @Deprecated\n-    public static <T> T[] add(final T[] array, final int index, final T element) {\n-        Class<?> clss = null;\n+    public static <T> T[] add(final T[] array, final int n, final T t) {\n+        Class<?> clazz;\n         if (array != null) {\n-            clss = array.getClass().getComponentType();\n+            clazz = array.getClass().getComponentType();\n         }\n         else {\n-            if (element == null) {\n+            if (t == null) {\n                 throw new IllegalArgumentException(\"Array and element cannot both be null\");\n             }\n-            clss = element.getClass();\n+            clazz = t.getClass();\n         }\n-        final T[] newArray = (T[])add(array, index, element, clss);\n-        return newArray;\n+        return (T[])add(array, n, t, clazz);\n     }\n     \n-    public static <T> T[] add(final T[] array, final T element) {\n-        Class<?> type;\n+    public static <T> T[] add(final T[] array, final T t) {\n+        Class<?> clazz;\n         if (array != null) {\n-            type = array.getClass().getComponentType();\n+            clazz = array.getClass().getComponentType();\n         }\n         else {\n-            if (element == null) {\n+            if (t == null) {\n                 throw new IllegalArgumentException(\"Arguments cannot both be null\");\n             }\n-            type = element.getClass();\n+            clazz = t.getClass();\n         }\n-        final T[] newArray = (T[])copyArrayGrow1(array, type);\n-        newArray[newArray.length - 1] = element;\n-        return newArray;\n+        final Object[] array2 = (Object[])copyArrayGrow1(array, clazz);\n+        array2[array2.length - 1] = t;\n+        return (T[])array2;\n     }\n     \n-    public static boolean[] addAll(final boolean[] array1, final boolean... array2) {\n-        if (array1 == null) {\n+    public static boolean[] addAll(final boolean[] array, final boolean... array2) {\n+        if (array == null) {\n             return clone(array2);\n         }\n         if (array2 == null) {\n-            return clone(array1);\n+            return clone(array);\n         }\n-        final boolean[] joinedArray = new boolean[array1.length + array2.length];\n-        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n-        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n-        return joinedArray;\n+        final boolean[] array3 = new boolean[array.length + array2.length];\n+        System.arraycopy(array, 0, array3, 0, array.length);\n+        System.arraycopy(array2, 0, array3, array.length, array2.length);\n+        return array3;\n     }\n     \n-    public static byte[] addAll(final byte[] array1, final byte... array2) {\n-        if (array1 == null) {\n+    public static byte[] addAll(final byte[] array, final byte... array2) {\n+        if (array == null) {\n             return clone(array2);\n         }\n         if (array2 == null) {\n-            return clone(array1);\n+            return clone(array);\n         }\n-        final byte[] joinedArray = new byte[array1.length + array2.length];\n-        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n-        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n-        return joinedArray;\n+        final byte[] array3 = new byte[array.length + array2.length];\n+        System.arraycopy(array, 0, array3, 0, array.length);\n+        System.arraycopy(array2, 0, array3, array.length, array2.length);\n+        return array3;\n     }\n     \n-    public static char[] addAll(final char[] array1, final char... array2) {\n-        if (array1 == null) {\n+    public static char[] addAll(final char[] array, final char... array2) {\n+        if (array == null) {\n             return clone(array2);\n         }\n         if (array2 == null) {\n-            return clone(array1);\n+            return clone(array);\n         }\n-        final char[] joinedArray = new char[array1.length + array2.length];\n-        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n-        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n-        return joinedArray;\n+        final char[] array3 = new char[array.length + array2.length];\n+        System.arraycopy(array, 0, array3, 0, array.length);\n+        System.arraycopy(array2, 0, array3, array.length, array2.length);\n+        return array3;\n     }\n     \n-    public static double[] addAll(final double[] array1, final double... array2) {\n-        if (array1 == null) {\n+    public static double[] addAll(final double[] array, final double... array2) {\n+        if (array == null) {\n             return clone(array2);\n         }\n         if (array2 == null) {\n-            return clone(array1);\n+            return clone(array);\n         }\n-        final double[] joinedArray = new double[array1.length + array2.length];\n-        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n-        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n-        return joinedArray;\n+        final double[] array3 = new double[array.length + array2.length];\n+        System.arraycopy(array, 0, array3, 0, array.length);\n+        System.arraycopy(array2, 0, array3, array.length, array2.length);\n+        return array3;\n     }\n     \n-    public static float[] addAll(final float[] array1, final float... array2) {\n-        if (array1 == null) {\n+    public static float[] addAll(final float[] array, final float... array2) {\n+        if (array == null) {\n             return clone(array2);\n         }\n         if (array2 == null) {\n-            return clone(array1);\n+            return clone(array);\n         }\n-        final float[] joinedArray = new float[array1.length + array2.length];\n-        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n-        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n-        return joinedArray;\n+        final float[] array3 = new float[array.length + array2.length];\n+        System.arraycopy(array, 0, array3, 0, array.length);\n+        System.arraycopy(array2, 0, array3, array.length, array2.length);\n+        return array3;\n     }\n     \n-    public static int[] addAll(final int[] array1, final int... array2) {\n-        if (array1 == null) {\n+    public static int[] addAll(final int[] array, final int... array2) {\n+        if (array == null) {\n             return clone(array2);\n         }\n         if (array2 == null) {\n-            return clone(array1);\n+            return clone(array);\n         }\n-        final int[] joinedArray = new int[array1.length + array2.length];\n-        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n-        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n-        return joinedArray;\n+        final int[] array3 = new int[array.length + array2.length];\n+        System.arraycopy(array, 0, array3, 0, array.length);\n+        System.arraycopy(array2, 0, array3, array.length, array2.length);\n+        return array3;\n     }\n     \n-    public static long[] addAll(final long[] array1, final long... array2) {\n-        if (array1 == null) {\n+    public static long[] addAll(final long[] array, final long... array2) {\n+        if (array == null) {\n             return clone(array2);\n         }\n         if (array2 == null) {\n-            return clone(array1);\n+            return clone(array);\n         }\n-        final long[] joinedArray = new long[array1.length + array2.length];\n-        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n-        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n-        return joinedArray;\n+        final long[] array3 = new long[array.length + array2.length];\n+        System.arraycopy(array, 0, array3, 0, array.length);\n+        System.arraycopy(array2, 0, array3, array.length, array2.length);\n+        return array3;\n     }\n     \n-    public static short[] addAll(final short[] array1, final short... array2) {\n-        if (array1 == null) {\n+    public static short[] addAll(final short[] array, final short... array2) {\n+        if (array == null) {\n             return clone(array2);\n         }\n         if (array2 == null) {\n-            return clone(array1);\n+            return clone(array);\n         }\n-        final short[] joinedArray = new short[array1.length + array2.length];\n-        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n-        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n-        return joinedArray;\n+        final short[] array3 = new short[array.length + array2.length];\n+        System.arraycopy(array, 0, array3, 0, array.length);\n+        System.arraycopy(array2, 0, array3, array.length, array2.length);\n+        return array3;\n     }\n     \n-    public static <T> T[] addAll(final T[] array1, final T... array2) {\n-        if (array1 == null) {\n+    public static <T> T[] addAll(final T[] array, final T... array2) {\n+        if (array == null) {\n             return clone(array2);\n         }\n         if (array2 == null) {\n-            return clone(array1);\n+            return clone(array);\n         }\n-        final Class<?> type1 = array1.getClass().getComponentType();\n-        final T[] joinedArray = (T[])Array.newInstance(type1, array1.length + array2.length);\n-        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        final Class<?> componentType = array.getClass().getComponentType();\n+        final Object[] array3 = (Object[])Array.newInstance(componentType, array.length + array2.length);\n+        System.arraycopy(array, 0, array3, 0, array.length);\n         try {\n-            System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+            System.arraycopy(array2, 0, array3, array.length, array2.length);\n         }\n-        catch (final ArrayStoreException ase) {\n-            final Class<?> type2 = array2.getClass().getComponentType();\n-            if (!type1.isAssignableFrom(type2)) {\n-                throw new IllegalArgumentException(\"Cannot store \" + type2.getName() + \" in an array of \" + type1.getName(), ase);\n+        catch (final ArrayStoreException cause) {\n+            final Class<?> componentType2 = array2.getClass().getComponentType();\n+            if (!componentType.isAssignableFrom(componentType2)) {\n+                throw new IllegalArgumentException(\"Cannot store \" + componentType2.getName() + \" in an array of \" + componentType.getName(), cause);\n             }\n-            throw ase;\n+            throw cause;\n         }\n-        return joinedArray;\n+        return (T[])array3;\n     }\n     \n-    public static boolean[] addFirst(final boolean[] array, final boolean element) {\n-        return (array == null) ? add(array, element) : insert(0, array, element);\n+    public static boolean[] addFirst(final boolean[] array, final boolean b) {\n+        return (array == null) ? add(array, b) : insert(0, array, b);\n     }\n     \n-    public static byte[] addFirst(final byte[] array, final byte element) {\n-        return (array == null) ? add(array, element) : insert(0, array, element);\n+    public static byte[] addFirst(final byte[] array, final byte b) {\n+        return (array == null) ? add(array, b) : insert(0, array, b);\n     }\n     \n-    public static char[] addFirst(final char[] array, final char element) {\n-        return (array == null) ? add(array, element) : insert(0, array, element);\n+    public static char[] addFirst(final char[] array, final char c) {\n+        return (array == null) ? add(array, c) : insert(0, array, c);\n     }\n     \n-    public static double[] addFirst(final double[] array, final double element) {\n-        return (array == null) ? add(array, element) : insert(0, array, element);\n+    public static double[] addFirst(final double[] array, final double n) {\n+        return (array == null) ? add(array, n) : insert(0, array, n);\n     }\n     \n-    public static float[] addFirst(final float[] array, final float element) {\n-        return (array == null) ? add(array, element) : insert(0, array, element);\n+    public static float[] addFirst(final float[] array, final float n) {\n+        return (array == null) ? add(array, n) : insert(0, array, n);\n     }\n     \n-    public static int[] addFirst(final int[] array, final int element) {\n-        return (array == null) ? add(array, element) : insert(0, array, element);\n+    public static int[] addFirst(final int[] array, final int n) {\n+        return (array == null) ? add(array, n) : insert(0, array, n);\n     }\n     \n-    public static long[] addFirst(final long[] array, final long element) {\n-        return (array == null) ? add(array, element) : insert(0, array, element);\n+    public static long[] addFirst(final long[] array, final long n) {\n+        return (array == null) ? add(array, n) : insert(0, array, n);\n     }\n     \n-    public static short[] addFirst(final short[] array, final short element) {\n-        return (array == null) ? add(array, element) : insert(0, array, element);\n+    public static short[] addFirst(final short[] array, final short n) {\n+        return (array == null) ? add(array, n) : insert(0, array, n);\n     }\n     \n-    public static <T> T[] addFirst(final T[] array, final T element) {\n-        return (T[])((array == null) ? add(array, (Object)element) : insert(0, array, element));\n+    public static <T> T[] addFirst(final T[] array, final T t) {\n+        return (T[])((array == null) ? add(array, (Object)t) : insert(0, array, t));\n     }\n     \n     public static boolean[] clone(final boolean[] array) {\n         if (array == null) {\n             return null;\n         }\n         return array.clone();\n@@ -410,681 +409,680 @@\n     public static <T> T[] clone(final T[] array) {\n         if (array == null) {\n             return null;\n         }\n         return array.clone();\n     }\n     \n-    public static boolean contains(final boolean[] array, final boolean valueToFind) {\n-        return indexOf(array, valueToFind) != -1;\n+    public static boolean contains(final boolean[] array, final boolean b) {\n+        return indexOf(array, b) != -1;\n     }\n     \n-    public static boolean contains(final byte[] array, final byte valueToFind) {\n-        return indexOf(array, valueToFind) != -1;\n+    public static boolean contains(final byte[] array, final byte b) {\n+        return indexOf(array, b) != -1;\n     }\n     \n-    public static boolean contains(final char[] array, final char valueToFind) {\n-        return indexOf(array, valueToFind) != -1;\n+    public static boolean contains(final char[] array, final char c) {\n+        return indexOf(array, c) != -1;\n     }\n     \n-    public static boolean contains(final double[] array, final double valueToFind) {\n-        return indexOf(array, valueToFind) != -1;\n+    public static boolean contains(final double[] array, final double n) {\n+        return indexOf(array, n) != -1;\n     }\n     \n-    public static boolean contains(final double[] array, final double valueToFind, final double tolerance) {\n-        return indexOf(array, valueToFind, 0, tolerance) != -1;\n+    public static boolean contains(final double[] array, final double n, final double n2) {\n+        return indexOf(array, n, 0, n2) != -1;\n     }\n     \n-    public static boolean contains(final float[] array, final float valueToFind) {\n-        return indexOf(array, valueToFind) != -1;\n+    public static boolean contains(final float[] array, final float n) {\n+        return indexOf(array, n) != -1;\n     }\n     \n-    public static boolean contains(final int[] array, final int valueToFind) {\n-        return indexOf(array, valueToFind) != -1;\n+    public static boolean contains(final int[] array, final int n) {\n+        return indexOf(array, n) != -1;\n     }\n     \n-    public static boolean contains(final long[] array, final long valueToFind) {\n-        return indexOf(array, valueToFind) != -1;\n+    public static boolean contains(final long[] array, final long n) {\n+        return indexOf(array, n) != -1;\n     }\n     \n-    public static boolean contains(final Object[] array, final Object objectToFind) {\n-        return indexOf(array, objectToFind) != -1;\n+    public static boolean contains(final Object[] array, final Object o) {\n+        return indexOf(array, o) != -1;\n     }\n     \n-    public static boolean contains(final short[] array, final short valueToFind) {\n-        return indexOf(array, valueToFind) != -1;\n+    public static boolean contains(final short[] array, final short n) {\n+        return indexOf(array, n) != -1;\n     }\n     \n-    private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n-        if (array != null) {\n-            final int arrayLength = Array.getLength(array);\n-            final Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1);\n-            System.arraycopy(array, 0, newArray, 0, arrayLength);\n-            return newArray;\n+    private static Object copyArrayGrow1(final Object o, final Class<?> componentType) {\n+        if (o != null) {\n+            final int length = Array.getLength(o);\n+            final Object instance = Array.newInstance(o.getClass().getComponentType(), length + 1);\n+            System.arraycopy(o, 0, instance, 0, length);\n+            return instance;\n         }\n-        return Array.newInstance(newArrayComponentType, 1);\n+        return Array.newInstance(componentType, 1);\n     }\n     \n-    public static <T> T get(final T[] array, final int index) {\n-        return get(array, index, (T)null);\n+    public static <T> T get(final T[] array, final int n) {\n+        return get(array, n, (T)null);\n     }\n     \n-    public static <T> T get(final T[] array, final int index, final T defaultValue) {\n-        return isArrayIndexValid(array, index) ? array[index] : defaultValue;\n+    public static <T> T get(final T[] array, final int n, final T t) {\n+        return isArrayIndexValid(array, n) ? array[n] : t;\n     }\n     \n-    public static int getLength(final Object array) {\n-        if (array == null) {\n+    public static int getLength(final Object o) {\n+        if (o == null) {\n             return 0;\n         }\n-        return Array.getLength(array);\n+        return Array.getLength(o);\n     }\n     \n-    public static int hashCode(final Object array) {\n-        return new HashCodeBuilder().append(array).toHashCode();\n+    public static int hashCode(final Object o) {\n+        return new HashCodeBuilder().append(o).toHashCode();\n     }\n     \n-    public static BitSet indexesOf(final boolean[] array, final boolean valueToFind) {\n-        return indexesOf(array, valueToFind, 0);\n+    public static BitSet indexesOf(final boolean[] array, final boolean b) {\n+        return indexesOf(array, b, 0);\n     }\n     \n-    public static BitSet indexesOf(final boolean[] array, final boolean valueToFind, int startIndex) {\n-        final BitSet bitSet = new BitSet();\n+    public static BitSet indexesOf(final boolean[] array, final boolean b, int i) {\n+        final BitSet set = new BitSet();\n         if (array == null) {\n-            return bitSet;\n+            return set;\n         }\n-        while (startIndex < array.length) {\n-            startIndex = indexOf(array, valueToFind, startIndex);\n-            if (startIndex == -1) {\n+        while (i < array.length) {\n+            i = indexOf(array, b, i);\n+            if (i == -1) {\n                 break;\n             }\n-            bitSet.set(startIndex);\n-            ++startIndex;\n+            set.set(i);\n+            ++i;\n         }\n-        return bitSet;\n+        return set;\n     }\n     \n-    public static BitSet indexesOf(final byte[] array, final byte valueToFind) {\n-        return indexesOf(array, valueToFind, 0);\n+    public static BitSet indexesOf(final byte[] array, final byte b) {\n+        return indexesOf(array, b, 0);\n     }\n     \n-    public static BitSet indexesOf(final byte[] array, final byte valueToFind, int startIndex) {\n-        final BitSet bitSet = new BitSet();\n+    public static BitSet indexesOf(final byte[] array, final byte b, int i) {\n+        final BitSet set = new BitSet();\n         if (array == null) {\n-            return bitSet;\n+            return set;\n         }\n-        while (startIndex < array.length) {\n-            startIndex = indexOf(array, valueToFind, startIndex);\n-            if (startIndex == -1) {\n+        while (i < array.length) {\n+            i = indexOf(array, b, i);\n+            if (i == -1) {\n                 break;\n             }\n-            bitSet.set(startIndex);\n-            ++startIndex;\n+            set.set(i);\n+            ++i;\n         }\n-        return bitSet;\n+        return set;\n     }\n     \n-    public static BitSet indexesOf(final char[] array, final char valueToFind) {\n-        return indexesOf(array, valueToFind, 0);\n+    public static BitSet indexesOf(final char[] array, final char c) {\n+        return indexesOf(array, c, 0);\n     }\n     \n-    public static BitSet indexesOf(final char[] array, final char valueToFind, int startIndex) {\n-        final BitSet bitSet = new BitSet();\n+    public static BitSet indexesOf(final char[] array, final char c, int i) {\n+        final BitSet set = new BitSet();\n         if (array == null) {\n-            return bitSet;\n+            return set;\n         }\n-        while (startIndex < array.length) {\n-            startIndex = indexOf(array, valueToFind, startIndex);\n-            if (startIndex == -1) {\n+        while (i < array.length) {\n+            i = indexOf(array, c, i);\n+            if (i == -1) {\n                 break;\n             }\n-            bitSet.set(startIndex);\n-            ++startIndex;\n+            set.set(i);\n+            ++i;\n         }\n-        return bitSet;\n+        return set;\n     }\n     \n-    public static BitSet indexesOf(final double[] array, final double valueToFind) {\n-        return indexesOf(array, valueToFind, 0);\n+    public static BitSet indexesOf(final double[] array, final double n) {\n+        return indexesOf(array, n, 0);\n     }\n     \n-    public static BitSet indexesOf(final double[] array, final double valueToFind, final double tolerance) {\n-        return indexesOf(array, valueToFind, 0, tolerance);\n+    public static BitSet indexesOf(final double[] array, final double n, final double n2) {\n+        return indexesOf(array, n, 0, n2);\n     }\n     \n-    public static BitSet indexesOf(final double[] array, final double valueToFind, int startIndex) {\n-        final BitSet bitSet = new BitSet();\n+    public static BitSet indexesOf(final double[] array, final double n, int i) {\n+        final BitSet set = new BitSet();\n         if (array == null) {\n-            return bitSet;\n+            return set;\n         }\n-        while (startIndex < array.length) {\n-            startIndex = indexOf(array, valueToFind, startIndex);\n-            if (startIndex == -1) {\n+        while (i < array.length) {\n+            i = indexOf(array, n, i);\n+            if (i == -1) {\n                 break;\n             }\n-            bitSet.set(startIndex);\n-            ++startIndex;\n+            set.set(i);\n+            ++i;\n         }\n-        return bitSet;\n+        return set;\n     }\n     \n-    public static BitSet indexesOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) {\n-        final BitSet bitSet = new BitSet();\n+    public static BitSet indexesOf(final double[] array, final double n, int i, final double n2) {\n+        final BitSet set = new BitSet();\n         if (array == null) {\n-            return bitSet;\n+            return set;\n         }\n-        while (startIndex < array.length) {\n-            startIndex = indexOf(array, valueToFind, startIndex, tolerance);\n-            if (startIndex == -1) {\n+        while (i < array.length) {\n+            i = indexOf(array, n, i, n2);\n+            if (i == -1) {\n                 break;\n             }\n-            bitSet.set(startIndex);\n-            ++startIndex;\n+            set.set(i);\n+            ++i;\n         }\n-        return bitSet;\n+        return set;\n     }\n     \n-    public static BitSet indexesOf(final float[] array, final float valueToFind) {\n-        return indexesOf(array, valueToFind, 0);\n+    public static BitSet indexesOf(final float[] array, final float n) {\n+        return indexesOf(array, n, 0);\n     }\n     \n-    public static BitSet indexesOf(final float[] array, final float valueToFind, int startIndex) {\n-        final BitSet bitSet = new BitSet();\n+    public static BitSet indexesOf(final float[] array, final float n, int i) {\n+        final BitSet set = new BitSet();\n         if (array == null) {\n-            return bitSet;\n+            return set;\n         }\n-        while (startIndex < array.length) {\n-            startIndex = indexOf(array, valueToFind, startIndex);\n-            if (startIndex == -1) {\n+        while (i < array.length) {\n+            i = indexOf(array, n, i);\n+            if (i == -1) {\n                 break;\n             }\n-            bitSet.set(startIndex);\n-            ++startIndex;\n+            set.set(i);\n+            ++i;\n         }\n-        return bitSet;\n+        return set;\n     }\n     \n-    public static BitSet indexesOf(final int[] array, final int valueToFind) {\n-        return indexesOf(array, valueToFind, 0);\n+    public static BitSet indexesOf(final int[] array, final int n) {\n+        return indexesOf(array, n, 0);\n     }\n     \n-    public static BitSet indexesOf(final int[] array, final int valueToFind, int startIndex) {\n-        final BitSet bitSet = new BitSet();\n+    public static BitSet indexesOf(final int[] array, final int n, int i) {\n+        final BitSet set = new BitSet();\n         if (array == null) {\n-            return bitSet;\n+            return set;\n         }\n-        while (startIndex < array.length) {\n-            startIndex = indexOf(array, valueToFind, startIndex);\n-            if (startIndex == -1) {\n+        while (i < array.length) {\n+            i = indexOf(array, n, i);\n+            if (i == -1) {\n                 break;\n             }\n-            bitSet.set(startIndex);\n-            ++startIndex;\n+            set.set(i);\n+            ++i;\n         }\n-        return bitSet;\n+        return set;\n     }\n     \n-    public static BitSet indexesOf(final long[] array, final long valueToFind) {\n-        return indexesOf(array, valueToFind, 0);\n+    public static BitSet indexesOf(final long[] array, final long n) {\n+        return indexesOf(array, n, 0);\n     }\n     \n-    public static BitSet indexesOf(final long[] array, final long valueToFind, int startIndex) {\n-        final BitSet bitSet = new BitSet();\n+    public static BitSet indexesOf(final long[] array, final long n, int i) {\n+        final BitSet set = new BitSet();\n         if (array == null) {\n-            return bitSet;\n+            return set;\n         }\n-        while (startIndex < array.length) {\n-            startIndex = indexOf(array, valueToFind, startIndex);\n-            if (startIndex == -1) {\n+        while (i < array.length) {\n+            i = indexOf(array, n, i);\n+            if (i == -1) {\n                 break;\n             }\n-            bitSet.set(startIndex);\n-            ++startIndex;\n+            set.set(i);\n+            ++i;\n         }\n-        return bitSet;\n+        return set;\n     }\n     \n-    public static BitSet indexesOf(final Object[] array, final Object objectToFind) {\n-        return indexesOf(array, objectToFind, 0);\n+    public static BitSet indexesOf(final Object[] array, final Object o) {\n+        return indexesOf(array, o, 0);\n     }\n     \n-    public static BitSet indexesOf(final Object[] array, final Object objectToFind, int startIndex) {\n-        final BitSet bitSet = new BitSet();\n+    public static BitSet indexesOf(final Object[] array, final Object o, int i) {\n+        final BitSet set = new BitSet();\n         if (array == null) {\n-            return bitSet;\n+            return set;\n         }\n-        while (startIndex < array.length) {\n-            startIndex = indexOf(array, objectToFind, startIndex);\n-            if (startIndex == -1) {\n+        while (i < array.length) {\n+            i = indexOf(array, o, i);\n+            if (i == -1) {\n                 break;\n             }\n-            bitSet.set(startIndex);\n-            ++startIndex;\n+            set.set(i);\n+            ++i;\n         }\n-        return bitSet;\n+        return set;\n     }\n     \n-    public static BitSet indexesOf(final short[] array, final short valueToFind) {\n-        return indexesOf(array, valueToFind, 0);\n+    public static BitSet indexesOf(final short[] array, final short n) {\n+        return indexesOf(array, n, 0);\n     }\n     \n-    public static BitSet indexesOf(final short[] array, final short valueToFind, int startIndex) {\n-        final BitSet bitSet = new BitSet();\n+    public static BitSet indexesOf(final short[] array, final short n, int i) {\n+        final BitSet set = new BitSet();\n         if (array == null) {\n-            return bitSet;\n+            return set;\n         }\n-        while (startIndex < array.length) {\n-            startIndex = indexOf(array, valueToFind, startIndex);\n-            if (startIndex == -1) {\n+        while (i < array.length) {\n+            i = indexOf(array, n, i);\n+            if (i == -1) {\n                 break;\n             }\n-            bitSet.set(startIndex);\n-            ++startIndex;\n+            set.set(i);\n+            ++i;\n         }\n-        return bitSet;\n+        return set;\n     }\n     \n-    public static int indexOf(final boolean[] array, final boolean valueToFind) {\n-        return indexOf(array, valueToFind, 0);\n+    public static int indexOf(final boolean[] array, final boolean b) {\n+        return indexOf(array, b, 0);\n     }\n     \n-    public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {\n+    public static int indexOf(final boolean[] array, final boolean b, int n) {\n         if (isEmpty(array)) {\n             return -1;\n         }\n-        if (startIndex < 0) {\n-            startIndex = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        for (int i = startIndex; i < array.length; ++i) {\n-            if (valueToFind == array[i]) {\n+        for (int i = n; i < array.length; ++i) {\n+            if (b == array[i]) {\n                 return i;\n             }\n         }\n         return -1;\n     }\n     \n-    public static int indexOf(final byte[] array, final byte valueToFind) {\n-        return indexOf(array, valueToFind, 0);\n+    public static int indexOf(final byte[] array, final byte b) {\n+        return indexOf(array, b, 0);\n     }\n     \n-    public static int indexOf(final byte[] array, final byte valueToFind, int startIndex) {\n+    public static int indexOf(final byte[] array, final byte b, int n) {\n         if (array == null) {\n             return -1;\n         }\n-        if (startIndex < 0) {\n-            startIndex = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        for (int i = startIndex; i < array.length; ++i) {\n-            if (valueToFind == array[i]) {\n+        for (int i = n; i < array.length; ++i) {\n+            if (b == array[i]) {\n                 return i;\n             }\n         }\n         return -1;\n     }\n     \n-    public static int indexOf(final char[] array, final char valueToFind) {\n-        return indexOf(array, valueToFind, 0);\n+    public static int indexOf(final char[] array, final char c) {\n+        return indexOf(array, c, 0);\n     }\n     \n-    public static int indexOf(final char[] array, final char valueToFind, int startIndex) {\n+    public static int indexOf(final char[] array, final char c, int n) {\n         if (array == null) {\n             return -1;\n         }\n-        if (startIndex < 0) {\n-            startIndex = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        for (int i = startIndex; i < array.length; ++i) {\n-            if (valueToFind == array[i]) {\n+        for (int i = n; i < array.length; ++i) {\n+            if (c == array[i]) {\n                 return i;\n             }\n         }\n         return -1;\n     }\n     \n-    public static int indexOf(final double[] array, final double valueToFind) {\n-        return indexOf(array, valueToFind, 0);\n+    public static int indexOf(final double[] array, final double n) {\n+        return indexOf(array, n, 0);\n     }\n     \n-    public static int indexOf(final double[] array, final double valueToFind, final double tolerance) {\n-        return indexOf(array, valueToFind, 0, tolerance);\n+    public static int indexOf(final double[] array, final double n, final double n2) {\n+        return indexOf(array, n, 0, n2);\n     }\n     \n-    public static int indexOf(final double[] array, final double valueToFind, int startIndex) {\n+    public static int indexOf(final double[] array, final double v, int n) {\n         if (isEmpty(array)) {\n             return -1;\n         }\n-        if (startIndex < 0) {\n-            startIndex = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        final boolean searchNaN = Double.isNaN(valueToFind);\n-        for (int i = startIndex; i < array.length; ++i) {\n-            final double element = array[i];\n-            if (valueToFind == element || (searchNaN && Double.isNaN(element))) {\n+        final boolean naN = Double.isNaN(v);\n+        for (int i = n; i < array.length; ++i) {\n+            final double v2 = array[i];\n+            if (v == v2 || (naN && Double.isNaN(v2))) {\n                 return i;\n             }\n         }\n         return -1;\n     }\n     \n-    public static int indexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) {\n+    public static int indexOf(final double[] array, final double n, int n2, final double n3) {\n         if (isEmpty(array)) {\n             return -1;\n         }\n-        if (startIndex < 0) {\n-            startIndex = 0;\n+        if (n2 < 0) {\n+            n2 = 0;\n         }\n-        final double min = valueToFind - tolerance;\n-        final double max = valueToFind + tolerance;\n-        for (int i = startIndex; i < array.length; ++i) {\n-            if (array[i] >= min && array[i] <= max) {\n+        final double n4 = n - n3;\n+        final double n5 = n + n3;\n+        for (int i = n2; i < array.length; ++i) {\n+            if (array[i] >= n4 && array[i] <= n5) {\n                 return i;\n             }\n         }\n         return -1;\n     }\n     \n-    public static int indexOf(final float[] array, final float valueToFind) {\n-        return indexOf(array, valueToFind, 0);\n+    public static int indexOf(final float[] array, final float n) {\n+        return indexOf(array, n, 0);\n     }\n     \n-    public static int indexOf(final float[] array, final float valueToFind, int startIndex) {\n+    public static int indexOf(final float[] array, final float v, int n) {\n         if (isEmpty(array)) {\n             return -1;\n         }\n-        if (startIndex < 0) {\n-            startIndex = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        final boolean searchNaN = Float.isNaN(valueToFind);\n-        for (int i = startIndex; i < array.length; ++i) {\n-            final float element = array[i];\n-            if (valueToFind == element || (searchNaN && Float.isNaN(element))) {\n+        final boolean naN = Float.isNaN(v);\n+        for (int i = n; i < array.length; ++i) {\n+            final float v2 = array[i];\n+            if (v == v2 || (naN && Float.isNaN(v2))) {\n                 return i;\n             }\n         }\n         return -1;\n     }\n     \n-    public static int indexOf(final int[] array, final int valueToFind) {\n-        return indexOf(array, valueToFind, 0);\n+    public static int indexOf(final int[] array, final int n) {\n+        return indexOf(array, n, 0);\n     }\n     \n-    public static int indexOf(final int[] array, final int valueToFind, int startIndex) {\n+    public static int indexOf(final int[] array, final int n, int n2) {\n         if (array == null) {\n             return -1;\n         }\n-        if (startIndex < 0) {\n-            startIndex = 0;\n+        if (n2 < 0) {\n+            n2 = 0;\n         }\n-        for (int i = startIndex; i < array.length; ++i) {\n-            if (valueToFind == array[i]) {\n+        for (int i = n2; i < array.length; ++i) {\n+            if (n == array[i]) {\n                 return i;\n             }\n         }\n         return -1;\n     }\n     \n-    public static int indexOf(final long[] array, final long valueToFind) {\n-        return indexOf(array, valueToFind, 0);\n+    public static int indexOf(final long[] array, final long n) {\n+        return indexOf(array, n, 0);\n     }\n     \n-    public static int indexOf(final long[] array, final long valueToFind, int startIndex) {\n+    public static int indexOf(final long[] array, final long n, int n2) {\n         if (array == null) {\n             return -1;\n         }\n-        if (startIndex < 0) {\n-            startIndex = 0;\n+        if (n2 < 0) {\n+            n2 = 0;\n         }\n-        for (int i = startIndex; i < array.length; ++i) {\n-            if (valueToFind == array[i]) {\n+        for (int i = n2; i < array.length; ++i) {\n+            if (n == array[i]) {\n                 return i;\n             }\n         }\n         return -1;\n     }\n     \n-    public static int indexOf(final Object[] array, final Object objectToFind) {\n-        return indexOf(array, objectToFind, 0);\n+    public static int indexOf(final Object[] array, final Object o) {\n+        return indexOf(array, o, 0);\n     }\n     \n-    public static int indexOf(final Object[] array, final Object objectToFind, int startIndex) {\n+    public static int indexOf(final Object[] array, final Object o, int n) {\n         if (array == null) {\n             return -1;\n         }\n-        if (startIndex < 0) {\n-            startIndex = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (objectToFind == null) {\n-            for (int i = startIndex; i < array.length; ++i) {\n+        if (o == null) {\n+            for (int i = n; i < array.length; ++i) {\n                 if (array[i] == null) {\n                     return i;\n                 }\n             }\n         }\n         else {\n-            for (int i = startIndex; i < array.length; ++i) {\n-                if (objectToFind.equals(array[i])) {\n-                    return i;\n+            for (int j = n; j < array.length; ++j) {\n+                if (o.equals(array[j])) {\n+                    return j;\n                 }\n             }\n         }\n         return -1;\n     }\n     \n-    public static int indexOf(final short[] array, final short valueToFind) {\n-        return indexOf(array, valueToFind, 0);\n+    public static int indexOf(final short[] array, final short n) {\n+        return indexOf(array, n, 0);\n     }\n     \n-    public static int indexOf(final short[] array, final short valueToFind, int startIndex) {\n+    public static int indexOf(final short[] array, final short n, int n2) {\n         if (array == null) {\n             return -1;\n         }\n-        if (startIndex < 0) {\n-            startIndex = 0;\n+        if (n2 < 0) {\n+            n2 = 0;\n         }\n-        for (int i = startIndex; i < array.length; ++i) {\n-            if (valueToFind == array[i]) {\n+        for (int i = n2; i < array.length; ++i) {\n+            if (n == array[i]) {\n                 return i;\n             }\n         }\n         return -1;\n     }\n     \n-    public static boolean[] insert(final int index, final boolean[] array, final boolean... values) {\n+    public static boolean[] insert(final int i, final boolean[] array, final boolean... array2) {\n         if (array == null) {\n             return null;\n         }\n-        if (isEmpty(values)) {\n+        if (isEmpty(array2)) {\n             return clone(array);\n         }\n-        if (index < 0 || index > array.length) {\n-            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + array.length);\n+        if (i < 0 || i > array.length) {\n+            throw new IndexOutOfBoundsException(\"Index: \" + i + \", Length: \" + array.length);\n         }\n-        final boolean[] result = new boolean[array.length + values.length];\n-        System.arraycopy(values, 0, result, index, values.length);\n-        if (index > 0) {\n-            System.arraycopy(array, 0, result, 0, index);\n+        final boolean[] array3 = new boolean[array.length + array2.length];\n+        System.arraycopy(array2, 0, array3, i, array2.length);\n+        if (i > 0) {\n+            System.arraycopy(array, 0, array3, 0, i);\n         }\n-        if (index < array.length) {\n-            System.arraycopy(array, index, result, index + values.length, array.length - index);\n+        if (i < array.length) {\n+            System.arraycopy(array, i, array3, i + array2.length, array.length - i);\n         }\n-        return result;\n+        return array3;\n     }\n     \n-    public static byte[] insert(final int index, final byte[] array, final byte... values) {\n+    public static byte[] insert(final int i, final byte[] array, final byte... array2) {\n         if (array == null) {\n             return null;\n         }\n-        if (isEmpty(values)) {\n+        if (isEmpty(array2)) {\n             return clone(array);\n         }\n-        if (index < 0 || index > array.length) {\n-            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + array.length);\n+        if (i < 0 || i > array.length) {\n+            throw new IndexOutOfBoundsException(\"Index: \" + i + \", Length: \" + array.length);\n         }\n-        final byte[] result = new byte[array.length + values.length];\n-        System.arraycopy(values, 0, result, index, values.length);\n-        if (index > 0) {\n-            System.arraycopy(array, 0, result, 0, index);\n+        final byte[] array3 = new byte[array.length + array2.length];\n+        System.arraycopy(array2, 0, array3, i, array2.length);\n+        if (i > 0) {\n+            System.arraycopy(array, 0, array3, 0, i);\n         }\n-        if (index < array.length) {\n-            System.arraycopy(array, index, result, index + values.length, array.length - index);\n+        if (i < array.length) {\n+            System.arraycopy(array, i, array3, i + array2.length, array.length - i);\n         }\n-        return result;\n+        return array3;\n     }\n     \n-    public static char[] insert(final int index, final char[] array, final char... values) {\n+    public static char[] insert(final int i, final char[] array, final char... array2) {\n         if (array == null) {\n             return null;\n         }\n-        if (isEmpty(values)) {\n+        if (isEmpty(array2)) {\n             return clone(array);\n         }\n-        if (index < 0 || index > array.length) {\n-            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + array.length);\n+        if (i < 0 || i > array.length) {\n+            throw new IndexOutOfBoundsException(\"Index: \" + i + \", Length: \" + array.length);\n         }\n-        final char[] result = new char[array.length + values.length];\n-        System.arraycopy(values, 0, result, index, values.length);\n-        if (index > 0) {\n-            System.arraycopy(array, 0, result, 0, index);\n+        final char[] array3 = new char[array.length + array2.length];\n+        System.arraycopy(array2, 0, array3, i, array2.length);\n+        if (i > 0) {\n+            System.arraycopy(array, 0, array3, 0, i);\n         }\n-        if (index < array.length) {\n-            System.arraycopy(array, index, result, index + values.length, array.length - index);\n+        if (i < array.length) {\n+            System.arraycopy(array, i, array3, i + array2.length, array.length - i);\n         }\n-        return result;\n+        return array3;\n     }\n     \n-    public static double[] insert(final int index, final double[] array, final double... values) {\n+    public static double[] insert(final int i, final double[] array, final double... array2) {\n         if (array == null) {\n             return null;\n         }\n-        if (isEmpty(values)) {\n+        if (isEmpty(array2)) {\n             return clone(array);\n         }\n-        if (index < 0 || index > array.length) {\n-            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + array.length);\n+        if (i < 0 || i > array.length) {\n+            throw new IndexOutOfBoundsException(\"Index: \" + i + \", Length: \" + array.length);\n         }\n-        final double[] result = new double[array.length + values.length];\n-        System.arraycopy(values, 0, result, index, values.length);\n-        if (index > 0) {\n-            System.arraycopy(array, 0, result, 0, index);\n+        final double[] array3 = new double[array.length + array2.length];\n+        System.arraycopy(array2, 0, array3, i, array2.length);\n+        if (i > 0) {\n+            System.arraycopy(array, 0, array3, 0, i);\n         }\n-        if (index < array.length) {\n-            System.arraycopy(array, index, result, index + values.length, array.length - index);\n+        if (i < array.length) {\n+            System.arraycopy(array, i, array3, i + array2.length, array.length - i);\n         }\n-        return result;\n+        return array3;\n     }\n     \n-    public static float[] insert(final int index, final float[] array, final float... values) {\n+    public static float[] insert(final int i, final float[] array, final float... array2) {\n         if (array == null) {\n             return null;\n         }\n-        if (isEmpty(values)) {\n+        if (isEmpty(array2)) {\n             return clone(array);\n         }\n-        if (index < 0 || index > array.length) {\n-            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + array.length);\n+        if (i < 0 || i > array.length) {\n+            throw new IndexOutOfBoundsException(\"Index: \" + i + \", Length: \" + array.length);\n         }\n-        final float[] result = new float[array.length + values.length];\n-        System.arraycopy(values, 0, result, index, values.length);\n-        if (index > 0) {\n-            System.arraycopy(array, 0, result, 0, index);\n+        final float[] array3 = new float[array.length + array2.length];\n+        System.arraycopy(array2, 0, array3, i, array2.length);\n+        if (i > 0) {\n+            System.arraycopy(array, 0, array3, 0, i);\n         }\n-        if (index < array.length) {\n-            System.arraycopy(array, index, result, index + values.length, array.length - index);\n+        if (i < array.length) {\n+            System.arraycopy(array, i, array3, i + array2.length, array.length - i);\n         }\n-        return result;\n+        return array3;\n     }\n     \n-    public static int[] insert(final int index, final int[] array, final int... values) {\n+    public static int[] insert(final int i, final int[] array, final int... array2) {\n         if (array == null) {\n             return null;\n         }\n-        if (isEmpty(values)) {\n+        if (isEmpty(array2)) {\n             return clone(array);\n         }\n-        if (index < 0 || index > array.length) {\n-            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + array.length);\n+        if (i < 0 || i > array.length) {\n+            throw new IndexOutOfBoundsException(\"Index: \" + i + \", Length: \" + array.length);\n         }\n-        final int[] result = new int[array.length + values.length];\n-        System.arraycopy(values, 0, result, index, values.length);\n-        if (index > 0) {\n-            System.arraycopy(array, 0, result, 0, index);\n+        final int[] array3 = new int[array.length + array2.length];\n+        System.arraycopy(array2, 0, array3, i, array2.length);\n+        if (i > 0) {\n+            System.arraycopy(array, 0, array3, 0, i);\n         }\n-        if (index < array.length) {\n-            System.arraycopy(array, index, result, index + values.length, array.length - index);\n+        if (i < array.length) {\n+            System.arraycopy(array, i, array3, i + array2.length, array.length - i);\n         }\n-        return result;\n+        return array3;\n     }\n     \n-    public static long[] insert(final int index, final long[] array, final long... values) {\n+    public static long[] insert(final int i, final long[] array, final long... array2) {\n         if (array == null) {\n             return null;\n         }\n-        if (isEmpty(values)) {\n+        if (isEmpty(array2)) {\n             return clone(array);\n         }\n-        if (index < 0 || index > array.length) {\n-            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + array.length);\n+        if (i < 0 || i > array.length) {\n+            throw new IndexOutOfBoundsException(\"Index: \" + i + \", Length: \" + array.length);\n         }\n-        final long[] result = new long[array.length + values.length];\n-        System.arraycopy(values, 0, result, index, values.length);\n-        if (index > 0) {\n-            System.arraycopy(array, 0, result, 0, index);\n+        final long[] array3 = new long[array.length + array2.length];\n+        System.arraycopy(array2, 0, array3, i, array2.length);\n+        if (i > 0) {\n+            System.arraycopy(array, 0, array3, 0, i);\n         }\n-        if (index < array.length) {\n-            System.arraycopy(array, index, result, index + values.length, array.length - index);\n+        if (i < array.length) {\n+            System.arraycopy(array, i, array3, i + array2.length, array.length - i);\n         }\n-        return result;\n+        return array3;\n     }\n     \n-    public static short[] insert(final int index, final short[] array, final short... values) {\n+    public static short[] insert(final int i, final short[] array, final short... array2) {\n         if (array == null) {\n             return null;\n         }\n-        if (isEmpty(values)) {\n+        if (isEmpty(array2)) {\n             return clone(array);\n         }\n-        if (index < 0 || index > array.length) {\n-            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + array.length);\n+        if (i < 0 || i > array.length) {\n+            throw new IndexOutOfBoundsException(\"Index: \" + i + \", Length: \" + array.length);\n         }\n-        final short[] result = new short[array.length + values.length];\n-        System.arraycopy(values, 0, result, index, values.length);\n-        if (index > 0) {\n-            System.arraycopy(array, 0, result, 0, index);\n+        final short[] array3 = new short[array.length + array2.length];\n+        System.arraycopy(array2, 0, array3, i, array2.length);\n+        if (i > 0) {\n+            System.arraycopy(array, 0, array3, 0, i);\n         }\n-        if (index < array.length) {\n-            System.arraycopy(array, index, result, index + values.length, array.length - index);\n+        if (i < array.length) {\n+            System.arraycopy(array, i, array3, i + array2.length, array.length - i);\n         }\n-        return result;\n+        return array3;\n     }\n     \n     @SafeVarargs\n-    public static <T> T[] insert(final int index, final T[] array, final T... values) {\n+    public static <T> T[] insert(final int i, final T[] array, final T... array2) {\n         if (array == null) {\n             return null;\n         }\n-        if (isEmpty(values)) {\n+        if (isEmpty(array2)) {\n             return clone(array);\n         }\n-        if (index < 0 || index > array.length) {\n-            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + array.length);\n+        if (i < 0 || i > array.length) {\n+            throw new IndexOutOfBoundsException(\"Index: \" + i + \", Length: \" + array.length);\n         }\n-        final Class<?> type = array.getClass().getComponentType();\n-        final T[] result = (T[])Array.newInstance(type, array.length + values.length);\n-        System.arraycopy(values, 0, result, index, values.length);\n-        if (index > 0) {\n-            System.arraycopy(array, 0, result, 0, index);\n+        final Object[] array3 = (Object[])Array.newInstance(array.getClass().getComponentType(), array.length + array2.length);\n+        System.arraycopy(array2, 0, array3, i, array2.length);\n+        if (i > 0) {\n+            System.arraycopy(array, 0, array3, 0, i);\n         }\n-        if (index < array.length) {\n-            System.arraycopy(array, index, result, index + values.length, array.length - index);\n+        if (i < array.length) {\n+            System.arraycopy(array, i, array3, i + array2.length, array.length - i);\n         }\n-        return result;\n+        return (T[])array3;\n     }\n     \n-    public static <T> boolean isArrayIndexValid(final T[] array, final int index) {\n-        return index >= 0 && getLength(array) > index;\n+    public static <T> boolean isArrayIndexValid(final T[] array, final int n) {\n+        return n >= 0 && getLength(array) > n;\n     }\n     \n     public static boolean isEmpty(final boolean[] array) {\n         return getLength(array) == 0;\n     }\n     \n     public static boolean isEmpty(final byte[] array) {\n@@ -1116,16 +1114,16 @@\n     }\n     \n     public static boolean isEmpty(final short[] array) {\n         return getLength(array) == 0;\n     }\n     \n     @Deprecated\n-    public static boolean isEquals(final Object array1, final Object array2) {\n-        return new EqualsBuilder().append(array1, array2).isEquals();\n+    public static boolean isEquals(final Object o, final Object o2) {\n+        return new EqualsBuilder().append(o, o2).isEquals();\n     }\n     \n     public static boolean isNotEmpty(final boolean[] array) {\n         return !isEmpty(array);\n     }\n     \n     public static boolean isNotEmpty(final byte[] array) {\n@@ -1156,177 +1154,177 @@\n         return !isEmpty(array);\n     }\n     \n     public static <T> boolean isNotEmpty(final T[] array) {\n         return !isEmpty(array);\n     }\n     \n-    public static boolean isSameLength(final boolean[] array1, final boolean[] array2) {\n-        return getLength(array1) == getLength(array2);\n+    public static boolean isSameLength(final boolean[] array, final boolean[] array2) {\n+        return getLength(array) == getLength(array2);\n     }\n     \n-    public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n-        return getLength(array1) == getLength(array2);\n+    public static boolean isSameLength(final byte[] array, final byte[] array2) {\n+        return getLength(array) == getLength(array2);\n     }\n     \n-    public static boolean isSameLength(final char[] array1, final char[] array2) {\n-        return getLength(array1) == getLength(array2);\n+    public static boolean isSameLength(final char[] array, final char[] array2) {\n+        return getLength(array) == getLength(array2);\n     }\n     \n-    public static boolean isSameLength(final double[] array1, final double[] array2) {\n-        return getLength(array1) == getLength(array2);\n+    public static boolean isSameLength(final double[] array, final double[] array2) {\n+        return getLength(array) == getLength(array2);\n     }\n     \n-    public static boolean isSameLength(final float[] array1, final float[] array2) {\n-        return getLength(array1) == getLength(array2);\n+    public static boolean isSameLength(final float[] array, final float[] array2) {\n+        return getLength(array) == getLength(array2);\n     }\n     \n-    public static boolean isSameLength(final int[] array1, final int[] array2) {\n-        return getLength(array1) == getLength(array2);\n+    public static boolean isSameLength(final int[] array, final int[] array2) {\n+        return getLength(array) == getLength(array2);\n     }\n     \n-    public static boolean isSameLength(final long[] array1, final long[] array2) {\n-        return getLength(array1) == getLength(array2);\n+    public static boolean isSameLength(final long[] array, final long[] array2) {\n+        return getLength(array) == getLength(array2);\n     }\n     \n-    public static boolean isSameLength(final Object array1, final Object array2) {\n-        return getLength(array1) == getLength(array2);\n+    public static boolean isSameLength(final Object o, final Object o2) {\n+        return getLength(o) == getLength(o2);\n     }\n     \n-    public static boolean isSameLength(final Object[] array1, final Object[] array2) {\n-        return getLength(array1) == getLength(array2);\n+    public static boolean isSameLength(final Object[] array, final Object[] array2) {\n+        return getLength(array) == getLength(array2);\n     }\n     \n-    public static boolean isSameLength(final short[] array1, final short[] array2) {\n-        return getLength(array1) == getLength(array2);\n+    public static boolean isSameLength(final short[] array, final short[] array2) {\n+        return getLength(array) == getLength(array2);\n     }\n     \n-    public static boolean isSameType(final Object array1, final Object array2) {\n-        if (array1 == null || array2 == null) {\n+    public static boolean isSameType(final Object o, final Object o2) {\n+        if (o == null || o2 == null) {\n             throw new IllegalArgumentException(\"The Array must not be null\");\n         }\n-        return array1.getClass().getName().equals(array2.getClass().getName());\n+        return o.getClass().getName().equals(o2.getClass().getName());\n     }\n     \n     public static boolean isSorted(final boolean[] array) {\n         if (array == null || array.length < 2) {\n             return true;\n         }\n-        boolean previous = array[0];\n-        for (int n = array.length, i = 1; i < n; ++i) {\n-            final boolean current = array[i];\n-            if (BooleanUtils.compare(previous, current) > 0) {\n+        boolean b = array[0];\n+        for (int length = array.length, i = 1; i < length; ++i) {\n+            final boolean b2 = array[i];\n+            if (BooleanUtils.compare(b, b2) > 0) {\n                 return false;\n             }\n-            previous = current;\n+            b = b2;\n         }\n         return true;\n     }\n     \n     public static boolean isSorted(final byte[] array) {\n         if (array == null || array.length < 2) {\n             return true;\n         }\n-        byte previous = array[0];\n-        for (int n = array.length, i = 1; i < n; ++i) {\n-            final byte current = array[i];\n-            if (NumberUtils.compare(previous, current) > 0) {\n+        byte b = array[0];\n+        for (int length = array.length, i = 1; i < length; ++i) {\n+            final byte b2 = array[i];\n+            if (NumberUtils.compare(b, b2) > 0) {\n                 return false;\n             }\n-            previous = current;\n+            b = b2;\n         }\n         return true;\n     }\n     \n     public static boolean isSorted(final char[] array) {\n         if (array == null || array.length < 2) {\n             return true;\n         }\n-        char previous = array[0];\n-        for (int n = array.length, i = 1; i < n; ++i) {\n-            final char current = array[i];\n-            if (CharUtils.compare(previous, current) > 0) {\n+        char c = array[0];\n+        for (int length = array.length, i = 1; i < length; ++i) {\n+            final char c2 = array[i];\n+            if (CharUtils.compare(c, c2) > 0) {\n                 return false;\n             }\n-            previous = current;\n+            c = c2;\n         }\n         return true;\n     }\n     \n     public static boolean isSorted(final double[] array) {\n         if (array == null || array.length < 2) {\n             return true;\n         }\n-        double previous = array[0];\n-        for (int n = array.length, i = 1; i < n; ++i) {\n-            final double current = array[i];\n-            if (Double.compare(previous, current) > 0) {\n+        double d1 = array[0];\n+        for (int length = array.length, i = 1; i < length; ++i) {\n+            final double d2 = array[i];\n+            if (Double.compare(d1, d2) > 0) {\n                 return false;\n             }\n-            previous = current;\n+            d1 = d2;\n         }\n         return true;\n     }\n     \n     public static boolean isSorted(final float[] array) {\n         if (array == null || array.length < 2) {\n             return true;\n         }\n-        float previous = array[0];\n-        for (int n = array.length, i = 1; i < n; ++i) {\n-            final float current = array[i];\n-            if (Float.compare(previous, current) > 0) {\n+        float f1 = array[0];\n+        for (int length = array.length, i = 1; i < length; ++i) {\n+            final float f2 = array[i];\n+            if (Float.compare(f1, f2) > 0) {\n                 return false;\n             }\n-            previous = current;\n+            f1 = f2;\n         }\n         return true;\n     }\n     \n     public static boolean isSorted(final int[] array) {\n         if (array == null || array.length < 2) {\n             return true;\n         }\n-        int previous = array[0];\n-        for (int n = array.length, i = 1; i < n; ++i) {\n-            final int current = array[i];\n-            if (NumberUtils.compare(previous, current) > 0) {\n+        int n = array[0];\n+        for (int length = array.length, i = 1; i < length; ++i) {\n+            final int n2 = array[i];\n+            if (NumberUtils.compare(n, n2) > 0) {\n                 return false;\n             }\n-            previous = current;\n+            n = n2;\n         }\n         return true;\n     }\n     \n     public static boolean isSorted(final long[] array) {\n         if (array == null || array.length < 2) {\n             return true;\n         }\n-        long previous = array[0];\n-        for (int n = array.length, i = 1; i < n; ++i) {\n-            final long current = array[i];\n-            if (NumberUtils.compare(previous, current) > 0) {\n+        long n = array[0];\n+        for (int length = array.length, i = 1; i < length; ++i) {\n+            final long n2 = array[i];\n+            if (NumberUtils.compare(n, n2) > 0) {\n                 return false;\n             }\n-            previous = current;\n+            n = n2;\n         }\n         return true;\n     }\n     \n     public static boolean isSorted(final short[] array) {\n         if (array == null || array.length < 2) {\n             return true;\n         }\n-        short previous = array[0];\n-        for (int n = array.length, i = 1; i < n; ++i) {\n-            final short current = array[i];\n-            if (NumberUtils.compare(previous, current) > 0) {\n+        short n = array[0];\n+        for (int length = array.length, i = 1; i < length; ++i) {\n+            final short n2 = array[i];\n+            if (NumberUtils.compare(n, n2) > 0) {\n                 return false;\n             }\n-            previous = current;\n+            n = n2;\n         }\n         return true;\n     }\n     \n     public static <T extends Comparable<? super T>> boolean isSorted(final T[] array) {\n         return isSorted(array, Comparable::compareTo);\n     }\n@@ -1334,250 +1332,250 @@\n     public static <T> boolean isSorted(final T[] array, final Comparator<T> comparator) {\n         if (comparator == null) {\n             throw new IllegalArgumentException(\"Comparator should not be null.\");\n         }\n         if (array == null || array.length < 2) {\n             return true;\n         }\n-        T previous = array[0];\n-        for (int n = array.length, i = 1; i < n; ++i) {\n-            final T current = array[i];\n-            if (comparator.compare(previous, current) > 0) {\n+        T t = array[0];\n+        for (int length = array.length, i = 1; i < length; ++i) {\n+            final T t2 = array[i];\n+            if (comparator.compare(t, t2) > 0) {\n                 return false;\n             }\n-            previous = current;\n+            t = t2;\n         }\n         return true;\n     }\n     \n-    public static int lastIndexOf(final boolean[] array, final boolean valueToFind) {\n-        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    public static int lastIndexOf(final boolean[] array, final boolean b) {\n+        return lastIndexOf(array, b, Integer.MAX_VALUE);\n     }\n     \n-    public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {\n+    public static int lastIndexOf(final boolean[] array, final boolean b, int n) {\n         if (isEmpty(array)) {\n             return -1;\n         }\n-        if (startIndex < 0) {\n+        if (n < 0) {\n             return -1;\n         }\n-        if (startIndex >= array.length) {\n-            startIndex = array.length - 1;\n+        if (n >= array.length) {\n+            n = array.length - 1;\n         }\n-        for (int i = startIndex; i >= 0; --i) {\n-            if (valueToFind == array[i]) {\n+        for (int i = n; i >= 0; --i) {\n+            if (b == array[i]) {\n                 return i;\n             }\n         }\n         return -1;\n     }\n     \n-    public static int lastIndexOf(final byte[] array, final byte valueToFind) {\n-        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    public static int lastIndexOf(final byte[] array, final byte b) {\n+        return lastIndexOf(array, b, Integer.MAX_VALUE);\n     }\n     \n-    public static int lastIndexOf(final byte[] array, final byte valueToFind, int startIndex) {\n+    public static int lastIndexOf(final byte[] array, final byte b, int n) {\n         if (array == null) {\n             return -1;\n         }\n-        if (startIndex < 0) {\n+        if (n < 0) {\n             return -1;\n         }\n-        if (startIndex >= array.length) {\n-            startIndex = array.length - 1;\n+        if (n >= array.length) {\n+            n = array.length - 1;\n         }\n-        for (int i = startIndex; i >= 0; --i) {\n-            if (valueToFind == array[i]) {\n+        for (int i = n; i >= 0; --i) {\n+            if (b == array[i]) {\n                 return i;\n             }\n         }\n         return -1;\n     }\n     \n-    public static int lastIndexOf(final char[] array, final char valueToFind) {\n-        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    public static int lastIndexOf(final char[] array, final char c) {\n+        return lastIndexOf(array, c, Integer.MAX_VALUE);\n     }\n     \n-    public static int lastIndexOf(final char[] array, final char valueToFind, int startIndex) {\n+    public static int lastIndexOf(final char[] array, final char c, int n) {\n         if (array == null) {\n             return -1;\n         }\n-        if (startIndex < 0) {\n+        if (n < 0) {\n             return -1;\n         }\n-        if (startIndex >= array.length) {\n-            startIndex = array.length - 1;\n+        if (n >= array.length) {\n+            n = array.length - 1;\n         }\n-        for (int i = startIndex; i >= 0; --i) {\n-            if (valueToFind == array[i]) {\n+        for (int i = n; i >= 0; --i) {\n+            if (c == array[i]) {\n                 return i;\n             }\n         }\n         return -1;\n     }\n     \n-    public static int lastIndexOf(final double[] array, final double valueToFind) {\n-        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    public static int lastIndexOf(final double[] array, final double n) {\n+        return lastIndexOf(array, n, Integer.MAX_VALUE);\n     }\n     \n-    public static int lastIndexOf(final double[] array, final double valueToFind, final double tolerance) {\n-        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE, tolerance);\n+    public static int lastIndexOf(final double[] array, final double n, final double n2) {\n+        return lastIndexOf(array, n, Integer.MAX_VALUE, n2);\n     }\n     \n-    public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex) {\n+    public static int lastIndexOf(final double[] array, final double n, int n2) {\n         if (isEmpty(array)) {\n             return -1;\n         }\n-        if (startIndex < 0) {\n+        if (n2 < 0) {\n             return -1;\n         }\n-        if (startIndex >= array.length) {\n-            startIndex = array.length - 1;\n+        if (n2 >= array.length) {\n+            n2 = array.length - 1;\n         }\n-        for (int i = startIndex; i >= 0; --i) {\n-            if (valueToFind == array[i]) {\n+        for (int i = n2; i >= 0; --i) {\n+            if (n == array[i]) {\n                 return i;\n             }\n         }\n         return -1;\n     }\n     \n-    public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) {\n+    public static int lastIndexOf(final double[] array, final double n, int n2, final double n3) {\n         if (isEmpty(array)) {\n             return -1;\n         }\n-        if (startIndex < 0) {\n+        if (n2 < 0) {\n             return -1;\n         }\n-        if (startIndex >= array.length) {\n-            startIndex = array.length - 1;\n+        if (n2 >= array.length) {\n+            n2 = array.length - 1;\n         }\n-        final double min = valueToFind - tolerance;\n-        final double max = valueToFind + tolerance;\n-        for (int i = startIndex; i >= 0; --i) {\n-            if (array[i] >= min && array[i] <= max) {\n+        final double n4 = n - n3;\n+        final double n5 = n + n3;\n+        for (int i = n2; i >= 0; --i) {\n+            if (array[i] >= n4 && array[i] <= n5) {\n                 return i;\n             }\n         }\n         return -1;\n     }\n     \n-    public static int lastIndexOf(final float[] array, final float valueToFind) {\n-        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    public static int lastIndexOf(final float[] array, final float n) {\n+        return lastIndexOf(array, n, Integer.MAX_VALUE);\n     }\n     \n-    public static int lastIndexOf(final float[] array, final float valueToFind, int startIndex) {\n+    public static int lastIndexOf(final float[] array, final float n, int n2) {\n         if (isEmpty(array)) {\n             return -1;\n         }\n-        if (startIndex < 0) {\n+        if (n2 < 0) {\n             return -1;\n         }\n-        if (startIndex >= array.length) {\n-            startIndex = array.length - 1;\n+        if (n2 >= array.length) {\n+            n2 = array.length - 1;\n         }\n-        for (int i = startIndex; i >= 0; --i) {\n-            if (valueToFind == array[i]) {\n+        for (int i = n2; i >= 0; --i) {\n+            if (n == array[i]) {\n                 return i;\n             }\n         }\n         return -1;\n     }\n     \n-    public static int lastIndexOf(final int[] array, final int valueToFind) {\n-        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    public static int lastIndexOf(final int[] array, final int n) {\n+        return lastIndexOf(array, n, Integer.MAX_VALUE);\n     }\n     \n-    public static int lastIndexOf(final int[] array, final int valueToFind, int startIndex) {\n+    public static int lastIndexOf(final int[] array, final int n, int n2) {\n         if (array == null) {\n             return -1;\n         }\n-        if (startIndex < 0) {\n+        if (n2 < 0) {\n             return -1;\n         }\n-        if (startIndex >= array.length) {\n-            startIndex = array.length - 1;\n+        if (n2 >= array.length) {\n+            n2 = array.length - 1;\n         }\n-        for (int i = startIndex; i >= 0; --i) {\n-            if (valueToFind == array[i]) {\n+        for (int i = n2; i >= 0; --i) {\n+            if (n == array[i]) {\n                 return i;\n             }\n         }\n         return -1;\n     }\n     \n-    public static int lastIndexOf(final long[] array, final long valueToFind) {\n-        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    public static int lastIndexOf(final long[] array, final long n) {\n+        return lastIndexOf(array, n, Integer.MAX_VALUE);\n     }\n     \n-    public static int lastIndexOf(final long[] array, final long valueToFind, int startIndex) {\n+    public static int lastIndexOf(final long[] array, final long n, int n2) {\n         if (array == null) {\n             return -1;\n         }\n-        if (startIndex < 0) {\n+        if (n2 < 0) {\n             return -1;\n         }\n-        if (startIndex >= array.length) {\n-            startIndex = array.length - 1;\n+        if (n2 >= array.length) {\n+            n2 = array.length - 1;\n         }\n-        for (int i = startIndex; i >= 0; --i) {\n-            if (valueToFind == array[i]) {\n+        for (int i = n2; i >= 0; --i) {\n+            if (n == array[i]) {\n                 return i;\n             }\n         }\n         return -1;\n     }\n     \n-    public static int lastIndexOf(final Object[] array, final Object objectToFind) {\n-        return lastIndexOf(array, objectToFind, Integer.MAX_VALUE);\n+    public static int lastIndexOf(final Object[] array, final Object o) {\n+        return lastIndexOf(array, o, Integer.MAX_VALUE);\n     }\n     \n-    public static int lastIndexOf(final Object[] array, final Object objectToFind, int startIndex) {\n+    public static int lastIndexOf(final Object[] array, final Object o, int n) {\n         if (array == null) {\n             return -1;\n         }\n-        if (startIndex < 0) {\n+        if (n < 0) {\n             return -1;\n         }\n-        if (startIndex >= array.length) {\n-            startIndex = array.length - 1;\n+        if (n >= array.length) {\n+            n = array.length - 1;\n         }\n-        if (objectToFind == null) {\n-            for (int i = startIndex; i >= 0; --i) {\n+        if (o == null) {\n+            for (int i = n; i >= 0; --i) {\n                 if (array[i] == null) {\n                     return i;\n                 }\n             }\n         }\n-        else if (array.getClass().getComponentType().isInstance(objectToFind)) {\n-            for (int i = startIndex; i >= 0; --i) {\n-                if (objectToFind.equals(array[i])) {\n-                    return i;\n+        else if (array.getClass().getComponentType().isInstance(o)) {\n+            for (int j = n; j >= 0; --j) {\n+                if (o.equals(array[j])) {\n+                    return j;\n                 }\n             }\n         }\n         return -1;\n     }\n     \n-    public static int lastIndexOf(final short[] array, final short valueToFind) {\n-        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    public static int lastIndexOf(final short[] array, final short n) {\n+        return lastIndexOf(array, n, Integer.MAX_VALUE);\n     }\n     \n-    public static int lastIndexOf(final short[] array, final short valueToFind, int startIndex) {\n+    public static int lastIndexOf(final short[] array, final short n, int n2) {\n         if (array == null) {\n             return -1;\n         }\n-        if (startIndex < 0) {\n+        if (n2 < 0) {\n             return -1;\n         }\n-        if (startIndex >= array.length) {\n-            startIndex = array.length - 1;\n+        if (n2 >= array.length) {\n+            n2 = array.length - 1;\n         }\n-        for (int i = startIndex; i >= 0; --i) {\n-            if (valueToFind == array[i]) {\n+        for (int i = n2; i >= 0; --i) {\n+            if (n == array[i]) {\n                 return i;\n             }\n         }\n         return -1;\n     }\n     \n     public static boolean[] nullToEmpty(final boolean[] array) {\n@@ -1709,1169 +1707,1167 @@\n     public static String[] nullToEmpty(final String[] array) {\n         if (isEmpty(array)) {\n             return ArrayUtils.EMPTY_STRING_ARRAY;\n         }\n         return array;\n     }\n     \n-    public static <T> T[] nullToEmpty(final T[] array, final Class<T[]> type) {\n-        if (type == null) {\n+    public static <T> T[] nullToEmpty(final T[] array, final Class<T[]> clazz) {\n+        if (clazz == null) {\n             throw new IllegalArgumentException(\"The type must not be null\");\n         }\n         if (array == null) {\n-            return type.cast(Array.newInstance(type.getComponentType(), 0));\n+            return clazz.cast(Array.newInstance((Class<?>)clazz.getComponentType(), 0));\n         }\n         return array;\n     }\n     \n-    public static boolean[] remove(final boolean[] array, final int index) {\n-        return (boolean[])remove((Object)array, index);\n+    public static boolean[] remove(final boolean[] array, final int n) {\n+        return (boolean[])remove((Object)array, n);\n     }\n     \n-    public static byte[] remove(final byte[] array, final int index) {\n-        return (byte[])remove((Object)array, index);\n+    public static byte[] remove(final byte[] array, final int n) {\n+        return (byte[])remove((Object)array, n);\n     }\n     \n-    public static char[] remove(final char[] array, final int index) {\n-        return (char[])remove((Object)array, index);\n+    public static char[] remove(final char[] array, final int n) {\n+        return (char[])remove((Object)array, n);\n     }\n     \n-    public static double[] remove(final double[] array, final int index) {\n-        return (double[])remove((Object)array, index);\n+    public static double[] remove(final double[] array, final int n) {\n+        return (double[])remove((Object)array, n);\n     }\n     \n-    public static float[] remove(final float[] array, final int index) {\n-        return (float[])remove((Object)array, index);\n+    public static float[] remove(final float[] array, final int n) {\n+        return (float[])remove((Object)array, n);\n     }\n     \n-    public static int[] remove(final int[] array, final int index) {\n-        return (int[])remove((Object)array, index);\n+    public static int[] remove(final int[] array, final int n) {\n+        return (int[])remove((Object)array, n);\n     }\n     \n-    public static long[] remove(final long[] array, final int index) {\n-        return (long[])remove((Object)array, index);\n+    public static long[] remove(final long[] array, final int n) {\n+        return (long[])remove((Object)array, n);\n     }\n     \n-    private static Object remove(final Object array, final int index) {\n-        final int length = getLength(array);\n-        if (index < 0 || index >= length) {\n-            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n+    private static Object remove(final Object o, final int i) {\n+        final int length = getLength(o);\n+        if (i < 0 || i >= length) {\n+            throw new IndexOutOfBoundsException(\"Index: \" + i + \", Length: \" + length);\n         }\n-        final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);\n-        System.arraycopy(array, 0, result, 0, index);\n-        if (index < length - 1) {\n-            System.arraycopy(array, index + 1, result, index, length - index - 1);\n+        final Object instance = Array.newInstance(o.getClass().getComponentType(), length - 1);\n+        System.arraycopy(o, 0, instance, 0, i);\n+        if (i < length - 1) {\n+            System.arraycopy(o, i + 1, instance, i, length - i - 1);\n         }\n-        return result;\n+        return instance;\n     }\n     \n-    public static short[] remove(final short[] array, final int index) {\n-        return (short[])remove((Object)array, index);\n+    public static short[] remove(final short[] array, final int n) {\n+        return (short[])remove((Object)array, n);\n     }\n     \n-    public static <T> T[] remove(final T[] array, final int index) {\n-        return (T[])remove((Object)array, index);\n+    public static <T> T[] remove(final T[] array, final int n) {\n+        return (T[])remove((Object)array, n);\n     }\n     \n-    public static boolean[] removeAll(final boolean[] array, final int... indices) {\n-        return (boolean[])removeAll((Object)array, indices);\n+    public static boolean[] removeAll(final boolean[] array, final int... array2) {\n+        return (boolean[])removeAll((Object)array, array2);\n     }\n     \n-    public static byte[] removeAll(final byte[] array, final int... indices) {\n-        return (byte[])removeAll((Object)array, indices);\n+    public static byte[] removeAll(final byte[] array, final int... array2) {\n+        return (byte[])removeAll((Object)array, array2);\n     }\n     \n-    public static char[] removeAll(final char[] array, final int... indices) {\n-        return (char[])removeAll((Object)array, indices);\n+    public static char[] removeAll(final char[] array, final int... array2) {\n+        return (char[])removeAll((Object)array, array2);\n     }\n     \n-    public static double[] removeAll(final double[] array, final int... indices) {\n-        return (double[])removeAll((Object)array, indices);\n+    public static double[] removeAll(final double[] array, final int... array2) {\n+        return (double[])removeAll((Object)array, array2);\n     }\n     \n-    public static float[] removeAll(final float[] array, final int... indices) {\n-        return (float[])removeAll((Object)array, indices);\n+    public static float[] removeAll(final float[] array, final int... array2) {\n+        return (float[])removeAll((Object)array, array2);\n     }\n     \n-    public static int[] removeAll(final int[] array, final int... indices) {\n-        return (int[])removeAll((Object)array, indices);\n+    public static int[] removeAll(final int[] array, final int... array2) {\n+        return (int[])removeAll((Object)array, array2);\n     }\n     \n-    public static long[] removeAll(final long[] array, final int... indices) {\n-        return (long[])removeAll((Object)array, indices);\n+    public static long[] removeAll(final long[] array, final int... array2) {\n+        return (long[])removeAll((Object)array, array2);\n     }\n     \n-    static Object removeAll(final Object array, final BitSet indices) {\n-        if (array == null) {\n+    static Object removeAll(final Object o, final BitSet set) {\n+        if (o == null) {\n             return null;\n         }\n-        final int srcLength = getLength(array);\n-        final int removals = indices.cardinality();\n-        final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);\n-        int srcIndex = 0;\n-        int destIndex = 0;\n-        int set;\n-        while ((set = indices.nextSetBit(srcIndex)) != -1) {\n-            final int count = set - srcIndex;\n-            if (count > 0) {\n-                System.arraycopy(array, srcIndex, result, destIndex, count);\n-                destIndex += count;\n+        final int length = getLength(o);\n+        final Object instance = Array.newInstance(o.getClass().getComponentType(), length - set.cardinality());\n+        int nextClearBit = 0;\n+        int n = 0;\n+        int nextSetBit;\n+        while ((nextSetBit = set.nextSetBit(nextClearBit)) != -1) {\n+            final int n2 = nextSetBit - nextClearBit;\n+            if (n2 > 0) {\n+                System.arraycopy(o, nextClearBit, instance, n, n2);\n+                n += n2;\n             }\n-            srcIndex = indices.nextClearBit(set);\n+            nextClearBit = set.nextClearBit(nextSetBit);\n         }\n-        final int count = srcLength - srcIndex;\n-        if (count > 0) {\n-            System.arraycopy(array, srcIndex, result, destIndex, count);\n+        final int n3 = length - nextClearBit;\n+        if (n3 > 0) {\n+            System.arraycopy(o, nextClearBit, instance, n, n3);\n         }\n-        return result;\n+        return instance;\n     }\n     \n-    static Object removeAll(final Object array, final int... indices) {\n-        final int length = getLength(array);\n-        int diff = 0;\n-        final int[] clonedIndices = ArraySorter.sort(clone(indices));\n-        if (isNotEmpty(clonedIndices)) {\n-            int i = clonedIndices.length;\n-            int prevIndex = length;\n-            while (--i >= 0) {\n-                final int index = clonedIndices[i];\n-                if (index < 0 || index >= length) {\n-                    throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n+    static Object removeAll(final Object o, final int... array) {\n+        final int length = getLength(o);\n+        int n = 0;\n+        final int[] sort = ArraySorter.sort(clone(array));\n+        if (isNotEmpty(sort)) {\n+            int length2 = sort.length;\n+            int n2 = length;\n+            while (--length2 >= 0) {\n+                final int i = sort[length2];\n+                if (i < 0 || i >= length) {\n+                    throw new IndexOutOfBoundsException(\"Index: \" + i + \", Length: \" + length);\n                 }\n-                if (index >= prevIndex) {\n+                if (i >= n2) {\n                     continue;\n                 }\n-                ++diff;\n-                prevIndex = index;\n+                ++n;\n+                n2 = i;\n             }\n         }\n-        final Object result = Array.newInstance(array.getClass().getComponentType(), length - diff);\n-        if (diff < length) {\n-            int end = length;\n-            int dest = length - diff;\n-            for (int j = clonedIndices.length - 1; j >= 0; --j) {\n-                final int index2 = clonedIndices[j];\n-                if (end - index2 > 1) {\n-                    final int cp = end - index2 - 1;\n-                    dest -= cp;\n-                    System.arraycopy(array, index2 + 1, result, dest, cp);\n+        final Object instance = Array.newInstance(o.getClass().getComponentType(), length - n);\n+        if (n < length) {\n+            int n3 = length;\n+            int n4 = length - n;\n+            for (int j = sort.length - 1; j >= 0; --j) {\n+                final int n5 = sort[j];\n+                if (n3 - n5 > 1) {\n+                    final int n6 = n3 - n5 - 1;\n+                    n4 -= n6;\n+                    System.arraycopy(o, n5 + 1, instance, n4, n6);\n                 }\n-                end = index2;\n+                n3 = n5;\n             }\n-            if (end > 0) {\n-                System.arraycopy(array, 0, result, 0, end);\n+            if (n3 > 0) {\n+                System.arraycopy(o, 0, instance, 0, n3);\n             }\n         }\n-        return result;\n+        return instance;\n     }\n     \n-    public static short[] removeAll(final short[] array, final int... indices) {\n-        return (short[])removeAll((Object)array, indices);\n+    public static short[] removeAll(final short[] array, final int... array2) {\n+        return (short[])removeAll((Object)array, array2);\n     }\n     \n-    public static <T> T[] removeAll(final T[] array, final int... indices) {\n-        return (T[])removeAll((Object)array, indices);\n+    public static <T> T[] removeAll(final T[] array, final int... array2) {\n+        return (T[])removeAll((Object)array, array2);\n     }\n     \n     @Deprecated\n-    public static boolean[] removeAllOccurences(final boolean[] array, final boolean element) {\n-        return (boolean[])removeAll((Object)array, indexesOf(array, element));\n+    public static boolean[] removeAllOccurences(final boolean[] array, final boolean b) {\n+        return (boolean[])removeAll((Object)array, indexesOf(array, b));\n     }\n     \n     @Deprecated\n-    public static byte[] removeAllOccurences(final byte[] array, final byte element) {\n-        return (byte[])removeAll((Object)array, indexesOf(array, element));\n+    public static byte[] removeAllOccurences(final byte[] array, final byte b) {\n+        return (byte[])removeAll((Object)array, indexesOf(array, b));\n     }\n     \n     @Deprecated\n-    public static char[] removeAllOccurences(final char[] array, final char element) {\n-        return (char[])removeAll((Object)array, indexesOf(array, element));\n+    public static char[] removeAllOccurences(final char[] array, final char c) {\n+        return (char[])removeAll((Object)array, indexesOf(array, c));\n     }\n     \n     @Deprecated\n-    public static double[] removeAllOccurences(final double[] array, final double element) {\n-        return (double[])removeAll((Object)array, indexesOf(array, element));\n+    public static double[] removeAllOccurences(final double[] array, final double n) {\n+        return (double[])removeAll((Object)array, indexesOf(array, n));\n     }\n     \n     @Deprecated\n-    public static float[] removeAllOccurences(final float[] array, final float element) {\n-        return (float[])removeAll((Object)array, indexesOf(array, element));\n+    public static float[] removeAllOccurences(final float[] array, final float n) {\n+        return (float[])removeAll((Object)array, indexesOf(array, n));\n     }\n     \n     @Deprecated\n-    public static int[] removeAllOccurences(final int[] array, final int element) {\n-        return (int[])removeAll((Object)array, indexesOf(array, element));\n+    public static int[] removeAllOccurences(final int[] array, final int n) {\n+        return (int[])removeAll((Object)array, indexesOf(array, n));\n     }\n     \n     @Deprecated\n-    public static long[] removeAllOccurences(final long[] array, final long element) {\n-        return (long[])removeAll((Object)array, indexesOf(array, element));\n+    public static long[] removeAllOccurences(final long[] array, final long n) {\n+        return (long[])removeAll((Object)array, indexesOf(array, n));\n     }\n     \n     @Deprecated\n-    public static short[] removeAllOccurences(final short[] array, final short element) {\n-        return (short[])removeAll((Object)array, indexesOf(array, element));\n+    public static short[] removeAllOccurences(final short[] array, final short n) {\n+        return (short[])removeAll((Object)array, indexesOf(array, n));\n     }\n     \n     @Deprecated\n-    public static <T> T[] removeAllOccurences(final T[] array, final T element) {\n-        return (T[])removeAll((Object)array, indexesOf((Object[])array, (Object)element));\n+    public static <T> T[] removeAllOccurences(final T[] array, final T t) {\n+        return (T[])removeAll((Object)array, indexesOf((Object[])array, (Object)t));\n     }\n     \n-    public static boolean[] removeAllOccurrences(final boolean[] array, final boolean element) {\n-        return (boolean[])removeAll((Object)array, indexesOf(array, element));\n+    public static boolean[] removeAllOccurrences(final boolean[] array, final boolean b) {\n+        return (boolean[])removeAll((Object)array, indexesOf(array, b));\n     }\n     \n-    public static byte[] removeAllOccurrences(final byte[] array, final byte element) {\n-        return (byte[])removeAll((Object)array, indexesOf(array, element));\n+    public static byte[] removeAllOccurrences(final byte[] array, final byte b) {\n+        return (byte[])removeAll((Object)array, indexesOf(array, b));\n     }\n     \n-    public static char[] removeAllOccurrences(final char[] array, final char element) {\n-        return (char[])removeAll((Object)array, indexesOf(array, element));\n+    public static char[] removeAllOccurrences(final char[] array, final char c) {\n+        return (char[])removeAll((Object)array, indexesOf(array, c));\n     }\n     \n-    public static double[] removeAllOccurrences(final double[] array, final double element) {\n-        return (double[])removeAll((Object)array, indexesOf(array, element));\n+    public static double[] removeAllOccurrences(final double[] array, final double n) {\n+        return (double[])removeAll((Object)array, indexesOf(array, n));\n     }\n     \n-    public static float[] removeAllOccurrences(final float[] array, final float element) {\n-        return (float[])removeAll((Object)array, indexesOf(array, element));\n+    public static float[] removeAllOccurrences(final float[] array, final float n) {\n+        return (float[])removeAll((Object)array, indexesOf(array, n));\n     }\n     \n-    public static int[] removeAllOccurrences(final int[] array, final int element) {\n-        return (int[])removeAll((Object)array, indexesOf(array, element));\n+    public static int[] removeAllOccurrences(final int[] array, final int n) {\n+        return (int[])removeAll((Object)array, indexesOf(array, n));\n     }\n     \n-    public static long[] removeAllOccurrences(final long[] array, final long element) {\n-        return (long[])removeAll((Object)array, indexesOf(array, element));\n+    public static long[] removeAllOccurrences(final long[] array, final long n) {\n+        return (long[])removeAll((Object)array, indexesOf(array, n));\n     }\n     \n-    public static short[] removeAllOccurrences(final short[] array, final short element) {\n-        return (short[])removeAll((Object)array, indexesOf(array, element));\n+    public static short[] removeAllOccurrences(final short[] array, final short n) {\n+        return (short[])removeAll((Object)array, indexesOf(array, n));\n     }\n     \n-    public static <T> T[] removeAllOccurrences(final T[] array, final T element) {\n-        return (T[])removeAll((Object)array, indexesOf((Object[])array, (Object)element));\n+    public static <T> T[] removeAllOccurrences(final T[] array, final T t) {\n+        return (T[])removeAll((Object)array, indexesOf((Object[])array, (Object)t));\n     }\n     \n-    public static boolean[] removeElement(final boolean[] array, final boolean element) {\n-        final int index = indexOf(array, element);\n+    public static boolean[] removeElement(final boolean[] array, final boolean b) {\n+        final int index = indexOf(array, b);\n         if (index == -1) {\n             return clone(array);\n         }\n         return remove(array, index);\n     }\n     \n-    public static byte[] removeElement(final byte[] array, final byte element) {\n-        final int index = indexOf(array, element);\n+    public static byte[] removeElement(final byte[] array, final byte b) {\n+        final int index = indexOf(array, b);\n         if (index == -1) {\n             return clone(array);\n         }\n         return remove(array, index);\n     }\n     \n-    public static char[] removeElement(final char[] array, final char element) {\n-        final int index = indexOf(array, element);\n+    public static char[] removeElement(final char[] array, final char c) {\n+        final int index = indexOf(array, c);\n         if (index == -1) {\n             return clone(array);\n         }\n         return remove(array, index);\n     }\n     \n-    public static double[] removeElement(final double[] array, final double element) {\n-        final int index = indexOf(array, element);\n+    public static double[] removeElement(final double[] array, final double n) {\n+        final int index = indexOf(array, n);\n         if (index == -1) {\n             return clone(array);\n         }\n         return remove(array, index);\n     }\n     \n-    public static float[] removeElement(final float[] array, final float element) {\n-        final int index = indexOf(array, element);\n+    public static float[] removeElement(final float[] array, final float n) {\n+        final int index = indexOf(array, n);\n         if (index == -1) {\n             return clone(array);\n         }\n         return remove(array, index);\n     }\n     \n-    public static int[] removeElement(final int[] array, final int element) {\n-        final int index = indexOf(array, element);\n+    public static int[] removeElement(final int[] array, final int n) {\n+        final int index = indexOf(array, n);\n         if (index == -1) {\n             return clone(array);\n         }\n         return remove(array, index);\n     }\n     \n-    public static long[] removeElement(final long[] array, final long element) {\n-        final int index = indexOf(array, element);\n+    public static long[] removeElement(final long[] array, final long n) {\n+        final int index = indexOf(array, n);\n         if (index == -1) {\n             return clone(array);\n         }\n         return remove(array, index);\n     }\n     \n-    public static short[] removeElement(final short[] array, final short element) {\n-        final int index = indexOf(array, element);\n+    public static short[] removeElement(final short[] array, final short n) {\n+        final int index = indexOf(array, n);\n         if (index == -1) {\n             return clone(array);\n         }\n         return remove(array, index);\n     }\n     \n-    public static <T> T[] removeElement(final T[] array, final Object element) {\n-        final int index = indexOf(array, element);\n+    public static <T> T[] removeElement(final T[] array, final Object o) {\n+        final int index = indexOf(array, o);\n         if (index == -1) {\n             return clone(array);\n         }\n         return remove(array, index);\n     }\n     \n-    public static boolean[] removeElements(final boolean[] array, final boolean... values) {\n-        if (isEmpty(array) || isEmpty(values)) {\n+    public static boolean[] removeElements(final boolean[] array, final boolean... array2) {\n+        if (isEmpty(array) || isEmpty(array2)) {\n             return clone(array);\n         }\n-        final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2);\n-        for (final boolean v : values) {\n-            final Boolean boxed = Boolean.valueOf(v);\n-            final MutableInt count = (MutableInt)occurrences.get(boxed);\n-            if (count == null) {\n-                occurrences.put(boxed, new MutableInt(1));\n+        final HashMap hashMap = new HashMap(2);\n+        for (int length = array2.length, i = 0; i < length; ++i) {\n+            final Boolean value = Boolean.valueOf(array2[i]);\n+            final MutableInt mutableInt = (MutableInt)hashMap.get(value);\n+            if (mutableInt == null) {\n+                hashMap.put(value, new MutableInt(1));\n             }\n             else {\n-                count.increment();\n+                mutableInt.increment();\n             }\n         }\n-        final BitSet toRemove = new BitSet();\n-        for (int i = 0; i < array.length; ++i) {\n-            final boolean key = array[i];\n-            final MutableInt count2 = (MutableInt)occurrences.get(Boolean.valueOf(key));\n-            if (count2 != null) {\n-                if (count2.decrementAndGet() == 0) {\n-                    occurrences.remove(Boolean.valueOf(key));\n+        final BitSet set = new BitSet();\n+        for (int j = 0; j < array.length; ++j) {\n+            final boolean b = array[j];\n+            final MutableInt mutableInt2 = (MutableInt)hashMap.get(Boolean.valueOf(b));\n+            if (mutableInt2 != null) {\n+                if (mutableInt2.decrementAndGet() == 0) {\n+                    hashMap.remove(Boolean.valueOf(b));\n                 }\n-                toRemove.set(i);\n+                set.set(j);\n             }\n         }\n-        return (boolean[])removeAll((Object)array, toRemove);\n+        return (boolean[])removeAll((Object)array, set);\n     }\n     \n-    public static byte[] removeElements(final byte[] array, final byte... values) {\n-        if (isEmpty(array) || isEmpty(values)) {\n+    public static byte[] removeElements(final byte[] array, final byte... array2) {\n+        if (isEmpty(array) || isEmpty(array2)) {\n             return clone(array);\n         }\n-        final Map<Byte, MutableInt> occurrences = new HashMap<Byte, MutableInt>(values.length);\n-        for (final byte v : values) {\n-            final Byte boxed = Byte.valueOf(v);\n-            final MutableInt count = (MutableInt)occurrences.get(boxed);\n-            if (count == null) {\n-                occurrences.put(boxed, new MutableInt(1));\n+        final HashMap hashMap = new HashMap(array2.length);\n+        for (int length = array2.length, i = 0; i < length; ++i) {\n+            final Byte value = Byte.valueOf(array2[i]);\n+            final MutableInt mutableInt = (MutableInt)hashMap.get(value);\n+            if (mutableInt == null) {\n+                hashMap.put(value, new MutableInt(1));\n             }\n             else {\n-                count.increment();\n+                mutableInt.increment();\n             }\n         }\n-        final BitSet toRemove = new BitSet();\n-        for (int i = 0; i < array.length; ++i) {\n-            final byte key = array[i];\n-            final MutableInt count2 = (MutableInt)occurrences.get(Byte.valueOf(key));\n-            if (count2 != null) {\n-                if (count2.decrementAndGet() == 0) {\n-                    occurrences.remove(Byte.valueOf(key));\n+        final BitSet set = new BitSet();\n+        for (int j = 0; j < array.length; ++j) {\n+            final byte b = array[j];\n+            final MutableInt mutableInt2 = (MutableInt)hashMap.get(Byte.valueOf(b));\n+            if (mutableInt2 != null) {\n+                if (mutableInt2.decrementAndGet() == 0) {\n+                    hashMap.remove(Byte.valueOf(b));\n                 }\n-                toRemove.set(i);\n+                set.set(j);\n             }\n         }\n-        return (byte[])removeAll((Object)array, toRemove);\n+        return (byte[])removeAll((Object)array, set);\n     }\n     \n-    public static char[] removeElements(final char[] array, final char... values) {\n-        if (isEmpty(array) || isEmpty(values)) {\n+    public static char[] removeElements(final char[] array, final char... array2) {\n+        if (isEmpty(array) || isEmpty(array2)) {\n             return clone(array);\n         }\n-        final HashMap<Character, MutableInt> occurrences = new HashMap<Character, MutableInt>(values.length);\n-        for (final char v : values) {\n-            final Character boxed = Character.valueOf(v);\n-            final MutableInt count = (MutableInt)occurrences.get(boxed);\n-            if (count == null) {\n-                occurrences.put(boxed, new MutableInt(1));\n+        final HashMap hashMap = new HashMap(array2.length);\n+        for (int length = array2.length, i = 0; i < length; ++i) {\n+            final Character value = Character.valueOf(array2[i]);\n+            final MutableInt mutableInt = (MutableInt)hashMap.get(value);\n+            if (mutableInt == null) {\n+                hashMap.put(value, new MutableInt(1));\n             }\n             else {\n-                count.increment();\n+                mutableInt.increment();\n             }\n         }\n-        final BitSet toRemove = new BitSet();\n-        for (int i = 0; i < array.length; ++i) {\n-            final char key = array[i];\n-            final MutableInt count2 = (MutableInt)occurrences.get(Character.valueOf(key));\n-            if (count2 != null) {\n-                if (count2.decrementAndGet() == 0) {\n-                    occurrences.remove(Character.valueOf(key));\n+        final BitSet set = new BitSet();\n+        for (int j = 0; j < array.length; ++j) {\n+            final char c = array[j];\n+            final MutableInt mutableInt2 = (MutableInt)hashMap.get(Character.valueOf(c));\n+            if (mutableInt2 != null) {\n+                if (mutableInt2.decrementAndGet() == 0) {\n+                    hashMap.remove(Character.valueOf(c));\n                 }\n-                toRemove.set(i);\n+                set.set(j);\n             }\n         }\n-        return (char[])removeAll((Object)array, toRemove);\n+        return (char[])removeAll((Object)array, set);\n     }\n     \n-    public static double[] removeElements(final double[] array, final double... values) {\n-        if (isEmpty(array) || isEmpty(values)) {\n+    public static double[] removeElements(final double[] array, final double... array2) {\n+        if (isEmpty(array) || isEmpty(array2)) {\n             return clone(array);\n         }\n-        final HashMap<Double, MutableInt> occurrences = new HashMap<Double, MutableInt>(values.length);\n-        for (final double v : values) {\n-            final Double boxed = Double.valueOf(v);\n-            final MutableInt count = (MutableInt)occurrences.get(boxed);\n-            if (count == null) {\n-                occurrences.put(boxed, new MutableInt(1));\n+        final HashMap hashMap = new HashMap(array2.length);\n+        for (int length = array2.length, i = 0; i < length; ++i) {\n+            final Double value = Double.valueOf(array2[i]);\n+            final MutableInt mutableInt = (MutableInt)hashMap.get(value);\n+            if (mutableInt == null) {\n+                hashMap.put(value, new MutableInt(1));\n             }\n             else {\n-                count.increment();\n+                mutableInt.increment();\n             }\n         }\n-        final BitSet toRemove = new BitSet();\n-        for (int i = 0; i < array.length; ++i) {\n-            final double key = array[i];\n-            final MutableInt count2 = (MutableInt)occurrences.get(Double.valueOf(key));\n-            if (count2 != null) {\n-                if (count2.decrementAndGet() == 0) {\n-                    occurrences.remove(Double.valueOf(key));\n+        final BitSet set = new BitSet();\n+        for (int j = 0; j < array.length; ++j) {\n+            final double n = array[j];\n+            final MutableInt mutableInt2 = (MutableInt)hashMap.get(Double.valueOf(n));\n+            if (mutableInt2 != null) {\n+                if (mutableInt2.decrementAndGet() == 0) {\n+                    hashMap.remove(Double.valueOf(n));\n                 }\n-                toRemove.set(i);\n+                set.set(j);\n             }\n         }\n-        return (double[])removeAll((Object)array, toRemove);\n+        return (double[])removeAll((Object)array, set);\n     }\n     \n-    public static float[] removeElements(final float[] array, final float... values) {\n-        if (isEmpty(array) || isEmpty(values)) {\n+    public static float[] removeElements(final float[] array, final float... array2) {\n+        if (isEmpty(array) || isEmpty(array2)) {\n             return clone(array);\n         }\n-        final HashMap<Float, MutableInt> occurrences = new HashMap<Float, MutableInt>(values.length);\n-        for (final float v : values) {\n-            final Float boxed = Float.valueOf(v);\n-            final MutableInt count = (MutableInt)occurrences.get(boxed);\n-            if (count == null) {\n-                occurrences.put(boxed, new MutableInt(1));\n+        final HashMap hashMap = new HashMap(array2.length);\n+        for (int length = array2.length, i = 0; i < length; ++i) {\n+            final Float value = Float.valueOf(array2[i]);\n+            final MutableInt mutableInt = (MutableInt)hashMap.get(value);\n+            if (mutableInt == null) {\n+                hashMap.put(value, new MutableInt(1));\n             }\n             else {\n-                count.increment();\n+                mutableInt.increment();\n             }\n         }\n-        final BitSet toRemove = new BitSet();\n-        for (int i = 0; i < array.length; ++i) {\n-            final float key = array[i];\n-            final MutableInt count2 = (MutableInt)occurrences.get(Float.valueOf(key));\n-            if (count2 != null) {\n-                if (count2.decrementAndGet() == 0) {\n-                    occurrences.remove(Float.valueOf(key));\n+        final BitSet set = new BitSet();\n+        for (int j = 0; j < array.length; ++j) {\n+            final float n = array[j];\n+            final MutableInt mutableInt2 = (MutableInt)hashMap.get(Float.valueOf(n));\n+            if (mutableInt2 != null) {\n+                if (mutableInt2.decrementAndGet() == 0) {\n+                    hashMap.remove(Float.valueOf(n));\n                 }\n-                toRemove.set(i);\n+                set.set(j);\n             }\n         }\n-        return (float[])removeAll((Object)array, toRemove);\n+        return (float[])removeAll((Object)array, set);\n     }\n     \n-    public static int[] removeElements(final int[] array, final int... values) {\n-        if (isEmpty(array) || isEmpty(values)) {\n+    public static int[] removeElements(final int[] array, final int... array2) {\n+        if (isEmpty(array) || isEmpty(array2)) {\n             return clone(array);\n         }\n-        final HashMap<Integer, MutableInt> occurrences = new HashMap<Integer, MutableInt>(values.length);\n-        for (final int v : values) {\n-            final Integer boxed = Integer.valueOf(v);\n-            final MutableInt count = (MutableInt)occurrences.get(boxed);\n-            if (count == null) {\n-                occurrences.put(boxed, new MutableInt(1));\n+        final HashMap hashMap = new HashMap(array2.length);\n+        for (int length = array2.length, i = 0; i < length; ++i) {\n+            final Integer value = Integer.valueOf(array2[i]);\n+            final MutableInt mutableInt = (MutableInt)hashMap.get(value);\n+            if (mutableInt == null) {\n+                hashMap.put(value, new MutableInt(1));\n             }\n             else {\n-                count.increment();\n+                mutableInt.increment();\n             }\n         }\n-        final BitSet toRemove = new BitSet();\n-        for (int i = 0; i < array.length; ++i) {\n-            final int key = array[i];\n-            final MutableInt count2 = (MutableInt)occurrences.get(Integer.valueOf(key));\n-            if (count2 != null) {\n-                if (count2.decrementAndGet() == 0) {\n-                    occurrences.remove(Integer.valueOf(key));\n+        final BitSet set = new BitSet();\n+        for (int j = 0; j < array.length; ++j) {\n+            final int n = array[j];\n+            final MutableInt mutableInt2 = (MutableInt)hashMap.get(Integer.valueOf(n));\n+            if (mutableInt2 != null) {\n+                if (mutableInt2.decrementAndGet() == 0) {\n+                    hashMap.remove(Integer.valueOf(n));\n                 }\n-                toRemove.set(i);\n+                set.set(j);\n             }\n         }\n-        return (int[])removeAll((Object)array, toRemove);\n+        return (int[])removeAll((Object)array, set);\n     }\n     \n-    public static long[] removeElements(final long[] array, final long... values) {\n-        if (isEmpty(array) || isEmpty(values)) {\n+    public static long[] removeElements(final long[] array, final long... array2) {\n+        if (isEmpty(array) || isEmpty(array2)) {\n             return clone(array);\n         }\n-        final HashMap<Long, MutableInt> occurrences = new HashMap<Long, MutableInt>(values.length);\n-        for (final long v : values) {\n-            final Long boxed = Long.valueOf(v);\n-            final MutableInt count = (MutableInt)occurrences.get(boxed);\n-            if (count == null) {\n-                occurrences.put(boxed, new MutableInt(1));\n+        final HashMap hashMap = new HashMap(array2.length);\n+        for (int length = array2.length, i = 0; i < length; ++i) {\n+            final Long value = Long.valueOf(array2[i]);\n+            final MutableInt mutableInt = (MutableInt)hashMap.get(value);\n+            if (mutableInt == null) {\n+                hashMap.put(value, new MutableInt(1));\n             }\n             else {\n-                count.increment();\n+                mutableInt.increment();\n             }\n         }\n-        final BitSet toRemove = new BitSet();\n-        for (int i = 0; i < array.length; ++i) {\n-            final long key = array[i];\n-            final MutableInt count2 = (MutableInt)occurrences.get(Long.valueOf(key));\n-            if (count2 != null) {\n-                if (count2.decrementAndGet() == 0) {\n-                    occurrences.remove(Long.valueOf(key));\n+        final BitSet set = new BitSet();\n+        for (int j = 0; j < array.length; ++j) {\n+            final long n = array[j];\n+            final MutableInt mutableInt2 = (MutableInt)hashMap.get(Long.valueOf(n));\n+            if (mutableInt2 != null) {\n+                if (mutableInt2.decrementAndGet() == 0) {\n+                    hashMap.remove(Long.valueOf(n));\n                 }\n-                toRemove.set(i);\n+                set.set(j);\n             }\n         }\n-        return (long[])removeAll((Object)array, toRemove);\n+        return (long[])removeAll((Object)array, set);\n     }\n     \n-    public static short[] removeElements(final short[] array, final short... values) {\n-        if (isEmpty(array) || isEmpty(values)) {\n+    public static short[] removeElements(final short[] array, final short... array2) {\n+        if (isEmpty(array) || isEmpty(array2)) {\n             return clone(array);\n         }\n-        final HashMap<Short, MutableInt> occurrences = new HashMap<Short, MutableInt>(values.length);\n-        for (final short v : values) {\n-            final Short boxed = Short.valueOf(v);\n-            final MutableInt count = (MutableInt)occurrences.get(boxed);\n-            if (count == null) {\n-                occurrences.put(boxed, new MutableInt(1));\n+        final HashMap hashMap = new HashMap(array2.length);\n+        for (int length = array2.length, i = 0; i < length; ++i) {\n+            final Short value = Short.valueOf(array2[i]);\n+            final MutableInt mutableInt = (MutableInt)hashMap.get(value);\n+            if (mutableInt == null) {\n+                hashMap.put(value, new MutableInt(1));\n             }\n             else {\n-                count.increment();\n+                mutableInt.increment();\n             }\n         }\n-        final BitSet toRemove = new BitSet();\n-        for (int i = 0; i < array.length; ++i) {\n-            final short key = array[i];\n-            final MutableInt count2 = (MutableInt)occurrences.get(Short.valueOf(key));\n-            if (count2 != null) {\n-                if (count2.decrementAndGet() == 0) {\n-                    occurrences.remove(Short.valueOf(key));\n+        final BitSet set = new BitSet();\n+        for (int j = 0; j < array.length; ++j) {\n+            final short n = array[j];\n+            final MutableInt mutableInt2 = (MutableInt)hashMap.get(Short.valueOf(n));\n+            if (mutableInt2 != null) {\n+                if (mutableInt2.decrementAndGet() == 0) {\n+                    hashMap.remove(Short.valueOf(n));\n                 }\n-                toRemove.set(i);\n+                set.set(j);\n             }\n         }\n-        return (short[])removeAll((Object)array, toRemove);\n+        return (short[])removeAll((Object)array, set);\n     }\n     \n     @SafeVarargs\n-    public static <T> T[] removeElements(final T[] array, final T... values) {\n-        if (isEmpty(array) || isEmpty(values)) {\n+    public static <T> T[] removeElements(final T[] array, final T... array2) {\n+        if (isEmpty(array) || isEmpty(array2)) {\n             return clone(array);\n         }\n-        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n-        for (final T v : values) {\n-            final MutableInt count = (MutableInt)occurrences.get(v);\n-            if (count == null) {\n-                occurrences.put(v, new MutableInt(1));\n+        final HashMap hashMap = new HashMap(array2.length);\n+        for (final T t : array2) {\n+            final MutableInt mutableInt = (MutableInt)hashMap.get(t);\n+            if (mutableInt == null) {\n+                hashMap.put(t, new MutableInt(1));\n             }\n             else {\n-                count.increment();\n+                mutableInt.increment();\n             }\n         }\n-        final BitSet toRemove = new BitSet();\n-        for (int i = 0; i < array.length; ++i) {\n-            final T key = array[i];\n-            final MutableInt count2 = (MutableInt)occurrences.get(key);\n-            if (count2 != null) {\n-                if (count2.decrementAndGet() == 0) {\n-                    occurrences.remove(key);\n+        final BitSet set = new BitSet();\n+        for (int j = 0; j < array.length; ++j) {\n+            final T t2 = array[j];\n+            final MutableInt mutableInt2 = (MutableInt)hashMap.get(t2);\n+            if (mutableInt2 != null) {\n+                if (mutableInt2.decrementAndGet() == 0) {\n+                    hashMap.remove(t2);\n                 }\n-                toRemove.set(i);\n+                set.set(j);\n             }\n         }\n-        final T[] result = (T[])removeAll((Object)array, toRemove);\n-        return result;\n+        return (T[])removeAll((Object)array, set);\n     }\n     \n     public static void reverse(final boolean[] array) {\n         if (array == null) {\n             return;\n         }\n         reverse(array, 0, array.length);\n     }\n     \n-    public static void reverse(final boolean[] array, final int startIndexInclusive, final int endIndexExclusive) {\n+    public static void reverse(final boolean[] array, final int a, final int b) {\n         if (array == null) {\n             return;\n         }\n-        for (int i = Math.max(startIndexInclusive, 0), j = Math.min(array.length, endIndexExclusive) - 1; j > i; --j, ++i) {\n-            final boolean tmp = array[j];\n-            array[j] = array[i];\n-            array[i] = tmp;\n+        for (int max = Math.max(a, 0), i = Math.min(array.length, b) - 1; i > max; --i, ++max) {\n+            final boolean b2 = array[i];\n+            array[i] = array[max];\n+            array[max] = b2;\n         }\n     }\n     \n     public static void reverse(final byte[] array) {\n         if (array == null) {\n             return;\n         }\n         reverse(array, 0, array.length);\n     }\n     \n-    public static void reverse(final byte[] array, final int startIndexInclusive, final int endIndexExclusive) {\n+    public static void reverse(final byte[] array, final int a, final int b) {\n         if (array == null) {\n             return;\n         }\n-        for (int i = Math.max(startIndexInclusive, 0), j = Math.min(array.length, endIndexExclusive) - 1; j > i; --j, ++i) {\n-            final byte tmp = array[j];\n-            array[j] = array[i];\n-            array[i] = tmp;\n+        for (int max = Math.max(a, 0), i = Math.min(array.length, b) - 1; i > max; --i, ++max) {\n+            final byte b2 = array[i];\n+            array[i] = array[max];\n+            array[max] = b2;\n         }\n     }\n     \n     public static void reverse(final char[] array) {\n         if (array == null) {\n             return;\n         }\n         reverse(array, 0, array.length);\n     }\n     \n-    public static void reverse(final char[] array, final int startIndexInclusive, final int endIndexExclusive) {\n+    public static void reverse(final char[] array, final int a, final int b) {\n         if (array == null) {\n             return;\n         }\n-        for (int i = Math.max(startIndexInclusive, 0), j = Math.min(array.length, endIndexExclusive) - 1; j > i; --j, ++i) {\n-            final char tmp = array[j];\n-            array[j] = array[i];\n-            array[i] = tmp;\n+        for (int max = Math.max(a, 0), i = Math.min(array.length, b) - 1; i > max; --i, ++max) {\n+            final char c = array[i];\n+            array[i] = array[max];\n+            array[max] = c;\n         }\n     }\n     \n     public static void reverse(final double[] array) {\n         if (array == null) {\n             return;\n         }\n         reverse(array, 0, array.length);\n     }\n     \n-    public static void reverse(final double[] array, final int startIndexInclusive, final int endIndexExclusive) {\n+    public static void reverse(final double[] array, final int a, final int b) {\n         if (array == null) {\n             return;\n         }\n-        for (int i = Math.max(startIndexInclusive, 0), j = Math.min(array.length, endIndexExclusive) - 1; j > i; --j, ++i) {\n-            final double tmp = array[j];\n-            array[j] = array[i];\n-            array[i] = tmp;\n+        for (int max = Math.max(a, 0), i = Math.min(array.length, b) - 1; i > max; --i, ++max) {\n+            final double n = array[i];\n+            array[i] = array[max];\n+            array[max] = n;\n         }\n     }\n     \n     public static void reverse(final float[] array) {\n         if (array == null) {\n             return;\n         }\n         reverse(array, 0, array.length);\n     }\n     \n-    public static void reverse(final float[] array, final int startIndexInclusive, final int endIndexExclusive) {\n+    public static void reverse(final float[] array, final int a, final int b) {\n         if (array == null) {\n             return;\n         }\n-        for (int i = Math.max(startIndexInclusive, 0), j = Math.min(array.length, endIndexExclusive) - 1; j > i; --j, ++i) {\n-            final float tmp = array[j];\n-            array[j] = array[i];\n-            array[i] = tmp;\n+        for (int max = Math.max(a, 0), i = Math.min(array.length, b) - 1; i > max; --i, ++max) {\n+            final float n = array[i];\n+            array[i] = array[max];\n+            array[max] = n;\n         }\n     }\n     \n     public static void reverse(final int[] array) {\n         if (array == null) {\n             return;\n         }\n         reverse(array, 0, array.length);\n     }\n     \n-    public static void reverse(final int[] array, final int startIndexInclusive, final int endIndexExclusive) {\n+    public static void reverse(final int[] array, final int a, final int b) {\n         if (array == null) {\n             return;\n         }\n-        for (int i = Math.max(startIndexInclusive, 0), j = Math.min(array.length, endIndexExclusive) - 1; j > i; --j, ++i) {\n-            final int tmp = array[j];\n-            array[j] = array[i];\n-            array[i] = tmp;\n+        for (int max = Math.max(a, 0), i = Math.min(array.length, b) - 1; i > max; --i, ++max) {\n+            final int n = array[i];\n+            array[i] = array[max];\n+            array[max] = n;\n         }\n     }\n     \n     public static void reverse(final long[] array) {\n         if (array == null) {\n             return;\n         }\n         reverse(array, 0, array.length);\n     }\n     \n-    public static void reverse(final long[] array, final int startIndexInclusive, final int endIndexExclusive) {\n+    public static void reverse(final long[] array, final int a, final int b) {\n         if (array == null) {\n             return;\n         }\n-        for (int i = Math.max(startIndexInclusive, 0), j = Math.min(array.length, endIndexExclusive) - 1; j > i; --j, ++i) {\n-            final long tmp = array[j];\n-            array[j] = array[i];\n-            array[i] = tmp;\n+        for (int max = Math.max(a, 0), i = Math.min(array.length, b) - 1; i > max; --i, ++max) {\n+            final long n = array[i];\n+            array[i] = array[max];\n+            array[max] = n;\n         }\n     }\n     \n     public static void reverse(final Object[] array) {\n         if (array == null) {\n             return;\n         }\n         reverse(array, 0, array.length);\n     }\n     \n-    public static void reverse(final Object[] array, final int startIndexInclusive, final int endIndexExclusive) {\n+    public static void reverse(final Object[] array, final int a, final int b) {\n         if (array == null) {\n             return;\n         }\n-        for (int i = Math.max(startIndexInclusive, 0), j = Math.min(array.length, endIndexExclusive) - 1; j > i; --j, ++i) {\n-            final Object tmp = array[j];\n-            array[j] = array[i];\n-            array[i] = tmp;\n+        for (int max = Math.max(a, 0), i = Math.min(array.length, b) - 1; i > max; --i, ++max) {\n+            final Object o = array[i];\n+            array[i] = array[max];\n+            array[max] = o;\n         }\n     }\n     \n     public static void reverse(final short[] array) {\n         if (array == null) {\n             return;\n         }\n         reverse(array, 0, array.length);\n     }\n     \n-    public static void reverse(final short[] array, final int startIndexInclusive, final int endIndexExclusive) {\n+    public static void reverse(final short[] array, final int a, final int b) {\n         if (array == null) {\n             return;\n         }\n-        for (int i = Math.max(startIndexInclusive, 0), j = Math.min(array.length, endIndexExclusive) - 1; j > i; --j, ++i) {\n-            final short tmp = array[j];\n-            array[j] = array[i];\n-            array[i] = tmp;\n+        for (int max = Math.max(a, 0), i = Math.min(array.length, b) - 1; i > max; --i, ++max) {\n+            final short n = array[i];\n+            array[i] = array[max];\n+            array[max] = n;\n         }\n     }\n     \n-    public static void shift(final boolean[] array, final int offset) {\n+    public static void shift(final boolean[] array, final int n) {\n         if (array == null) {\n             return;\n         }\n-        shift(array, 0, array.length, offset);\n+        shift(array, 0, array.length, n);\n     }\n     \n-    public static void shift(final boolean[] array, int startIndexInclusive, int endIndexExclusive, int offset) {\n+    public static void shift(final boolean[] array, int n, int length, int n2) {\n         if (array == null) {\n             return;\n         }\n-        if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {\n+        if (n >= array.length - 1 || length <= 0) {\n             return;\n         }\n-        if (startIndexInclusive < 0) {\n-            startIndexInclusive = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (endIndexExclusive >= array.length) {\n-            endIndexExclusive = array.length;\n+        if (length >= array.length) {\n+            length = array.length;\n         }\n-        int n = endIndexExclusive - startIndexInclusive;\n-        if (n <= 1) {\n+        int n3 = length - n;\n+        if (n3 <= 1) {\n             return;\n         }\n-        offset %= n;\n-        if (offset < 0) {\n-            offset += n;\n+        n2 %= n3;\n+        if (n2 < 0) {\n+            n2 += n3;\n         }\n-        while (n > 1 && offset > 0) {\n-            final int n_offset = n - offset;\n-            if (offset > n_offset) {\n-                swap(array, startIndexInclusive, startIndexInclusive + n - n_offset, n_offset);\n-                n = offset;\n-                offset -= n_offset;\n+        while (n3 > 1 && n2 > 0) {\n+            final int n4 = n3 - n2;\n+            if (n2 > n4) {\n+                swap(array, n, n + n3 - n4, n4);\n+                n3 = n2;\n+                n2 -= n4;\n             }\n             else {\n-                if (offset >= n_offset) {\n-                    swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);\n+                if (n2 >= n4) {\n+                    swap(array, n, n + n4, n2);\n                     break;\n                 }\n-                swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);\n-                startIndexInclusive += offset;\n-                n = n_offset;\n+                swap(array, n, n + n4, n2);\n+                n += n2;\n+                n3 = n4;\n             }\n         }\n     }\n     \n-    public static void shift(final byte[] array, final int offset) {\n+    public static void shift(final byte[] array, final int n) {\n         if (array == null) {\n             return;\n         }\n-        shift(array, 0, array.length, offset);\n+        shift(array, 0, array.length, n);\n     }\n     \n-    public static void shift(final byte[] array, int startIndexInclusive, int endIndexExclusive, int offset) {\n+    public static void shift(final byte[] array, int n, int length, int n2) {\n         if (array == null) {\n             return;\n         }\n-        if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {\n+        if (n >= array.length - 1 || length <= 0) {\n             return;\n         }\n-        if (startIndexInclusive < 0) {\n-            startIndexInclusive = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (endIndexExclusive >= array.length) {\n-            endIndexExclusive = array.length;\n+        if (length >= array.length) {\n+            length = array.length;\n         }\n-        int n = endIndexExclusive - startIndexInclusive;\n-        if (n <= 1) {\n+        int n3 = length - n;\n+        if (n3 <= 1) {\n             return;\n         }\n-        offset %= n;\n-        if (offset < 0) {\n-            offset += n;\n+        n2 %= n3;\n+        if (n2 < 0) {\n+            n2 += n3;\n         }\n-        while (n > 1 && offset > 0) {\n-            final int n_offset = n - offset;\n-            if (offset > n_offset) {\n-                swap(array, startIndexInclusive, startIndexInclusive + n - n_offset, n_offset);\n-                n = offset;\n-                offset -= n_offset;\n+        while (n3 > 1 && n2 > 0) {\n+            final int n4 = n3 - n2;\n+            if (n2 > n4) {\n+                swap(array, n, n + n3 - n4, n4);\n+                n3 = n2;\n+                n2 -= n4;\n             }\n             else {\n-                if (offset >= n_offset) {\n-                    swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);\n+                if (n2 >= n4) {\n+                    swap(array, n, n + n4, n2);\n                     break;\n                 }\n-                swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);\n-                startIndexInclusive += offset;\n-                n = n_offset;\n+                swap(array, n, n + n4, n2);\n+                n += n2;\n+                n3 = n4;\n             }\n         }\n     }\n     \n-    public static void shift(final char[] array, final int offset) {\n+    public static void shift(final char[] array, final int n) {\n         if (array == null) {\n             return;\n         }\n-        shift(array, 0, array.length, offset);\n+        shift(array, 0, array.length, n);\n     }\n     \n-    public static void shift(final char[] array, int startIndexInclusive, int endIndexExclusive, int offset) {\n+    public static void shift(final char[] array, int n, int length, int n2) {\n         if (array == null) {\n             return;\n         }\n-        if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {\n+        if (n >= array.length - 1 || length <= 0) {\n             return;\n         }\n-        if (startIndexInclusive < 0) {\n-            startIndexInclusive = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (endIndexExclusive >= array.length) {\n-            endIndexExclusive = array.length;\n+        if (length >= array.length) {\n+            length = array.length;\n         }\n-        int n = endIndexExclusive - startIndexInclusive;\n-        if (n <= 1) {\n+        int n3 = length - n;\n+        if (n3 <= 1) {\n             return;\n         }\n-        offset %= n;\n-        if (offset < 0) {\n-            offset += n;\n+        n2 %= n3;\n+        if (n2 < 0) {\n+            n2 += n3;\n         }\n-        while (n > 1 && offset > 0) {\n-            final int n_offset = n - offset;\n-            if (offset > n_offset) {\n-                swap(array, startIndexInclusive, startIndexInclusive + n - n_offset, n_offset);\n-                n = offset;\n-                offset -= n_offset;\n+        while (n3 > 1 && n2 > 0) {\n+            final int n4 = n3 - n2;\n+            if (n2 > n4) {\n+                swap(array, n, n + n3 - n4, n4);\n+                n3 = n2;\n+                n2 -= n4;\n             }\n             else {\n-                if (offset >= n_offset) {\n-                    swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);\n+                if (n2 >= n4) {\n+                    swap(array, n, n + n4, n2);\n                     break;\n                 }\n-                swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);\n-                startIndexInclusive += offset;\n-                n = n_offset;\n+                swap(array, n, n + n4, n2);\n+                n += n2;\n+                n3 = n4;\n             }\n         }\n     }\n     \n-    public static void shift(final double[] array, final int offset) {\n+    public static void shift(final double[] array, final int n) {\n         if (array == null) {\n             return;\n         }\n-        shift(array, 0, array.length, offset);\n+        shift(array, 0, array.length, n);\n     }\n     \n-    public static void shift(final double[] array, int startIndexInclusive, int endIndexExclusive, int offset) {\n+    public static void shift(final double[] array, int n, int length, int n2) {\n         if (array == null) {\n             return;\n         }\n-        if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {\n+        if (n >= array.length - 1 || length <= 0) {\n             return;\n         }\n-        if (startIndexInclusive < 0) {\n-            startIndexInclusive = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (endIndexExclusive >= array.length) {\n-            endIndexExclusive = array.length;\n+        if (length >= array.length) {\n+            length = array.length;\n         }\n-        int n = endIndexExclusive - startIndexInclusive;\n-        if (n <= 1) {\n+        int n3 = length - n;\n+        if (n3 <= 1) {\n             return;\n         }\n-        offset %= n;\n-        if (offset < 0) {\n-            offset += n;\n+        n2 %= n3;\n+        if (n2 < 0) {\n+            n2 += n3;\n         }\n-        while (n > 1 && offset > 0) {\n-            final int n_offset = n - offset;\n-            if (offset > n_offset) {\n-                swap(array, startIndexInclusive, startIndexInclusive + n - n_offset, n_offset);\n-                n = offset;\n-                offset -= n_offset;\n+        while (n3 > 1 && n2 > 0) {\n+            final int n4 = n3 - n2;\n+            if (n2 > n4) {\n+                swap(array, n, n + n3 - n4, n4);\n+                n3 = n2;\n+                n2 -= n4;\n             }\n             else {\n-                if (offset >= n_offset) {\n-                    swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);\n+                if (n2 >= n4) {\n+                    swap(array, n, n + n4, n2);\n                     break;\n                 }\n-                swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);\n-                startIndexInclusive += offset;\n-                n = n_offset;\n+                swap(array, n, n + n4, n2);\n+                n += n2;\n+                n3 = n4;\n             }\n         }\n     }\n     \n-    public static void shift(final float[] array, final int offset) {\n+    public static void shift(final float[] array, final int n) {\n         if (array == null) {\n             return;\n         }\n-        shift(array, 0, array.length, offset);\n+        shift(array, 0, array.length, n);\n     }\n     \n-    public static void shift(final float[] array, int startIndexInclusive, int endIndexExclusive, int offset) {\n+    public static void shift(final float[] array, int n, int length, int n2) {\n         if (array == null) {\n             return;\n         }\n-        if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {\n+        if (n >= array.length - 1 || length <= 0) {\n             return;\n         }\n-        if (startIndexInclusive < 0) {\n-            startIndexInclusive = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (endIndexExclusive >= array.length) {\n-            endIndexExclusive = array.length;\n+        if (length >= array.length) {\n+            length = array.length;\n         }\n-        int n = endIndexExclusive - startIndexInclusive;\n-        if (n <= 1) {\n+        int n3 = length - n;\n+        if (n3 <= 1) {\n             return;\n         }\n-        offset %= n;\n-        if (offset < 0) {\n-            offset += n;\n+        n2 %= n3;\n+        if (n2 < 0) {\n+            n2 += n3;\n         }\n-        while (n > 1 && offset > 0) {\n-            final int n_offset = n - offset;\n-            if (offset > n_offset) {\n-                swap(array, startIndexInclusive, startIndexInclusive + n - n_offset, n_offset);\n-                n = offset;\n-                offset -= n_offset;\n+        while (n3 > 1 && n2 > 0) {\n+            final int n4 = n3 - n2;\n+            if (n2 > n4) {\n+                swap(array, n, n + n3 - n4, n4);\n+                n3 = n2;\n+                n2 -= n4;\n             }\n             else {\n-                if (offset >= n_offset) {\n-                    swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);\n+                if (n2 >= n4) {\n+                    swap(array, n, n + n4, n2);\n                     break;\n                 }\n-                swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);\n-                startIndexInclusive += offset;\n-                n = n_offset;\n+                swap(array, n, n + n4, n2);\n+                n += n2;\n+                n3 = n4;\n             }\n         }\n     }\n     \n-    public static void shift(final int[] array, final int offset) {\n+    public static void shift(final int[] array, final int n) {\n         if (array == null) {\n             return;\n         }\n-        shift(array, 0, array.length, offset);\n+        shift(array, 0, array.length, n);\n     }\n     \n-    public static void shift(final int[] array, int startIndexInclusive, int endIndexExclusive, int offset) {\n+    public static void shift(final int[] array, int n, int length, int n2) {\n         if (array == null) {\n             return;\n         }\n-        if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {\n+        if (n >= array.length - 1 || length <= 0) {\n             return;\n         }\n-        if (startIndexInclusive < 0) {\n-            startIndexInclusive = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (endIndexExclusive >= array.length) {\n-            endIndexExclusive = array.length;\n+        if (length >= array.length) {\n+            length = array.length;\n         }\n-        int n = endIndexExclusive - startIndexInclusive;\n-        if (n <= 1) {\n+        int n3 = length - n;\n+        if (n3 <= 1) {\n             return;\n         }\n-        offset %= n;\n-        if (offset < 0) {\n-            offset += n;\n+        n2 %= n3;\n+        if (n2 < 0) {\n+            n2 += n3;\n         }\n-        while (n > 1 && offset > 0) {\n-            final int n_offset = n - offset;\n-            if (offset > n_offset) {\n-                swap(array, startIndexInclusive, startIndexInclusive + n - n_offset, n_offset);\n-                n = offset;\n-                offset -= n_offset;\n+        while (n3 > 1 && n2 > 0) {\n+            final int n4 = n3 - n2;\n+            if (n2 > n4) {\n+                swap(array, n, n + n3 - n4, n4);\n+                n3 = n2;\n+                n2 -= n4;\n             }\n             else {\n-                if (offset >= n_offset) {\n-                    swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);\n+                if (n2 >= n4) {\n+                    swap(array, n, n + n4, n2);\n                     break;\n                 }\n-                swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);\n-                startIndexInclusive += offset;\n-                n = n_offset;\n+                swap(array, n, n + n4, n2);\n+                n += n2;\n+                n3 = n4;\n             }\n         }\n     }\n     \n-    public static void shift(final long[] array, final int offset) {\n+    public static void shift(final long[] array, final int n) {\n         if (array == null) {\n             return;\n         }\n-        shift(array, 0, array.length, offset);\n+        shift(array, 0, array.length, n);\n     }\n     \n-    public static void shift(final long[] array, int startIndexInclusive, int endIndexExclusive, int offset) {\n+    public static void shift(final long[] array, int n, int length, int n2) {\n         if (array == null) {\n             return;\n         }\n-        if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {\n+        if (n >= array.length - 1 || length <= 0) {\n             return;\n         }\n-        if (startIndexInclusive < 0) {\n-            startIndexInclusive = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (endIndexExclusive >= array.length) {\n-            endIndexExclusive = array.length;\n+        if (length >= array.length) {\n+            length = array.length;\n         }\n-        int n = endIndexExclusive - startIndexInclusive;\n-        if (n <= 1) {\n+        int n3 = length - n;\n+        if (n3 <= 1) {\n             return;\n         }\n-        offset %= n;\n-        if (offset < 0) {\n-            offset += n;\n+        n2 %= n3;\n+        if (n2 < 0) {\n+            n2 += n3;\n         }\n-        while (n > 1 && offset > 0) {\n-            final int n_offset = n - offset;\n-            if (offset > n_offset) {\n-                swap(array, startIndexInclusive, startIndexInclusive + n - n_offset, n_offset);\n-                n = offset;\n-                offset -= n_offset;\n+        while (n3 > 1 && n2 > 0) {\n+            final int n4 = n3 - n2;\n+            if (n2 > n4) {\n+                swap(array, n, n + n3 - n4, n4);\n+                n3 = n2;\n+                n2 -= n4;\n             }\n             else {\n-                if (offset >= n_offset) {\n-                    swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);\n+                if (n2 >= n4) {\n+                    swap(array, n, n + n4, n2);\n                     break;\n                 }\n-                swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);\n-                startIndexInclusive += offset;\n-                n = n_offset;\n+                swap(array, n, n + n4, n2);\n+                n += n2;\n+                n3 = n4;\n             }\n         }\n     }\n     \n-    public static void shift(final Object[] array, final int offset) {\n+    public static void shift(final Object[] array, final int n) {\n         if (array == null) {\n             return;\n         }\n-        shift(array, 0, array.length, offset);\n+        shift(array, 0, array.length, n);\n     }\n     \n-    public static void shift(final Object[] array, int startIndexInclusive, int endIndexExclusive, int offset) {\n+    public static void shift(final Object[] array, int n, int length, int n2) {\n         if (array == null) {\n             return;\n         }\n-        if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {\n+        if (n >= array.length - 1 || length <= 0) {\n             return;\n         }\n-        if (startIndexInclusive < 0) {\n-            startIndexInclusive = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (endIndexExclusive >= array.length) {\n-            endIndexExclusive = array.length;\n+        if (length >= array.length) {\n+            length = array.length;\n         }\n-        int n = endIndexExclusive - startIndexInclusive;\n-        if (n <= 1) {\n+        int n3 = length - n;\n+        if (n3 <= 1) {\n             return;\n         }\n-        offset %= n;\n-        if (offset < 0) {\n-            offset += n;\n+        n2 %= n3;\n+        if (n2 < 0) {\n+            n2 += n3;\n         }\n-        while (n > 1 && offset > 0) {\n-            final int n_offset = n - offset;\n-            if (offset > n_offset) {\n-                swap(array, startIndexInclusive, startIndexInclusive + n - n_offset, n_offset);\n-                n = offset;\n-                offset -= n_offset;\n+        while (n3 > 1 && n2 > 0) {\n+            final int n4 = n3 - n2;\n+            if (n2 > n4) {\n+                swap(array, n, n + n3 - n4, n4);\n+                n3 = n2;\n+                n2 -= n4;\n             }\n             else {\n-                if (offset >= n_offset) {\n-                    swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);\n+                if (n2 >= n4) {\n+                    swap(array, n, n + n4, n2);\n                     break;\n                 }\n-                swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);\n-                startIndexInclusive += offset;\n-                n = n_offset;\n+                swap(array, n, n + n4, n2);\n+                n += n2;\n+                n3 = n4;\n             }\n         }\n     }\n     \n-    public static void shift(final short[] array, final int offset) {\n+    public static void shift(final short[] array, final int n) {\n         if (array == null) {\n             return;\n         }\n-        shift(array, 0, array.length, offset);\n+        shift(array, 0, array.length, n);\n     }\n     \n-    public static void shift(final short[] array, int startIndexInclusive, int endIndexExclusive, int offset) {\n+    public static void shift(final short[] array, int n, int length, int n2) {\n         if (array == null) {\n             return;\n         }\n-        if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {\n+        if (n >= array.length - 1 || length <= 0) {\n             return;\n         }\n-        if (startIndexInclusive < 0) {\n-            startIndexInclusive = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (endIndexExclusive >= array.length) {\n-            endIndexExclusive = array.length;\n+        if (length >= array.length) {\n+            length = array.length;\n         }\n-        int n = endIndexExclusive - startIndexInclusive;\n-        if (n <= 1) {\n+        int n3 = length - n;\n+        if (n3 <= 1) {\n             return;\n         }\n-        offset %= n;\n-        if (offset < 0) {\n-            offset += n;\n+        n2 %= n3;\n+        if (n2 < 0) {\n+            n2 += n3;\n         }\n-        while (n > 1 && offset > 0) {\n-            final int n_offset = n - offset;\n-            if (offset > n_offset) {\n-                swap(array, startIndexInclusive, startIndexInclusive + n - n_offset, n_offset);\n-                n = offset;\n-                offset -= n_offset;\n+        while (n3 > 1 && n2 > 0) {\n+            final int n4 = n3 - n2;\n+            if (n2 > n4) {\n+                swap(array, n, n + n3 - n4, n4);\n+                n3 = n2;\n+                n2 -= n4;\n             }\n             else {\n-                if (offset >= n_offset) {\n-                    swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);\n+                if (n2 >= n4) {\n+                    swap(array, n, n + n4, n2);\n                     break;\n                 }\n-                swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);\n-                startIndexInclusive += offset;\n-                n = n_offset;\n+                swap(array, n, n + n4, n2);\n+                n += n2;\n+                n3 = n4;\n             }\n         }\n     }\n     \n     public static void shuffle(final boolean[] array) {\n         shuffle(array, new Random());\n     }\n@@ -2958,859 +2954,857 @@\n     \n     public static void shuffle(final short[] array, final Random random) {\n         for (int i = array.length; i > 1; --i) {\n             swap(array, i - 1, random.nextInt(i), 1);\n         }\n     }\n     \n-    public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {\n+    public static boolean[] subarray(final boolean[] array, int n, int length) {\n         if (array == null) {\n             return null;\n         }\n-        if (startIndexInclusive < 0) {\n-            startIndexInclusive = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (endIndexExclusive > array.length) {\n-            endIndexExclusive = array.length;\n+        if (length > array.length) {\n+            length = array.length;\n         }\n-        final int newSize = endIndexExclusive - startIndexInclusive;\n-        if (newSize <= 0) {\n+        final int n2 = length - n;\n+        if (n2 <= 0) {\n             return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n         }\n-        final boolean[] subarray = new boolean[newSize];\n-        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n-        return subarray;\n+        final boolean[] array2 = new boolean[n2];\n+        System.arraycopy(array, n, array2, 0, n2);\n+        return array2;\n     }\n     \n-    public static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive) {\n+    public static byte[] subarray(final byte[] array, int n, int length) {\n         if (array == null) {\n             return null;\n         }\n-        if (startIndexInclusive < 0) {\n-            startIndexInclusive = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (endIndexExclusive > array.length) {\n-            endIndexExclusive = array.length;\n+        if (length > array.length) {\n+            length = array.length;\n         }\n-        final int newSize = endIndexExclusive - startIndexInclusive;\n-        if (newSize <= 0) {\n+        final int n2 = length - n;\n+        if (n2 <= 0) {\n             return ArrayUtils.EMPTY_BYTE_ARRAY;\n         }\n-        final byte[] subarray = new byte[newSize];\n-        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n-        return subarray;\n+        final byte[] array2 = new byte[n2];\n+        System.arraycopy(array, n, array2, 0, n2);\n+        return array2;\n     }\n     \n-    public static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive) {\n+    public static char[] subarray(final char[] array, int n, int length) {\n         if (array == null) {\n             return null;\n         }\n-        if (startIndexInclusive < 0) {\n-            startIndexInclusive = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (endIndexExclusive > array.length) {\n-            endIndexExclusive = array.length;\n+        if (length > array.length) {\n+            length = array.length;\n         }\n-        final int newSize = endIndexExclusive - startIndexInclusive;\n-        if (newSize <= 0) {\n+        final int n2 = length - n;\n+        if (n2 <= 0) {\n             return ArrayUtils.EMPTY_CHAR_ARRAY;\n         }\n-        final char[] subarray = new char[newSize];\n-        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n-        return subarray;\n+        final char[] array2 = new char[n2];\n+        System.arraycopy(array, n, array2, 0, n2);\n+        return array2;\n     }\n     \n-    public static double[] subarray(final double[] array, int startIndexInclusive, int endIndexExclusive) {\n+    public static double[] subarray(final double[] array, int n, int length) {\n         if (array == null) {\n             return null;\n         }\n-        if (startIndexInclusive < 0) {\n-            startIndexInclusive = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (endIndexExclusive > array.length) {\n-            endIndexExclusive = array.length;\n+        if (length > array.length) {\n+            length = array.length;\n         }\n-        final int newSize = endIndexExclusive - startIndexInclusive;\n-        if (newSize <= 0) {\n+        final int n2 = length - n;\n+        if (n2 <= 0) {\n             return ArrayUtils.EMPTY_DOUBLE_ARRAY;\n         }\n-        final double[] subarray = new double[newSize];\n-        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n-        return subarray;\n+        final double[] array2 = new double[n2];\n+        System.arraycopy(array, n, array2, 0, n2);\n+        return array2;\n     }\n     \n-    public static float[] subarray(final float[] array, int startIndexInclusive, int endIndexExclusive) {\n+    public static float[] subarray(final float[] array, int n, int length) {\n         if (array == null) {\n             return null;\n         }\n-        if (startIndexInclusive < 0) {\n-            startIndexInclusive = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (endIndexExclusive > array.length) {\n-            endIndexExclusive = array.length;\n+        if (length > array.length) {\n+            length = array.length;\n         }\n-        final int newSize = endIndexExclusive - startIndexInclusive;\n-        if (newSize <= 0) {\n+        final int n2 = length - n;\n+        if (n2 <= 0) {\n             return ArrayUtils.EMPTY_FLOAT_ARRAY;\n         }\n-        final float[] subarray = new float[newSize];\n-        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n-        return subarray;\n+        final float[] array2 = new float[n2];\n+        System.arraycopy(array, n, array2, 0, n2);\n+        return array2;\n     }\n     \n-    public static int[] subarray(final int[] array, int startIndexInclusive, int endIndexExclusive) {\n+    public static int[] subarray(final int[] array, int n, int length) {\n         if (array == null) {\n             return null;\n         }\n-        if (startIndexInclusive < 0) {\n-            startIndexInclusive = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (endIndexExclusive > array.length) {\n-            endIndexExclusive = array.length;\n+        if (length > array.length) {\n+            length = array.length;\n         }\n-        final int newSize = endIndexExclusive - startIndexInclusive;\n-        if (newSize <= 0) {\n+        final int n2 = length - n;\n+        if (n2 <= 0) {\n             return ArrayUtils.EMPTY_INT_ARRAY;\n         }\n-        final int[] subarray = new int[newSize];\n-        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n-        return subarray;\n+        final int[] array2 = new int[n2];\n+        System.arraycopy(array, n, array2, 0, n2);\n+        return array2;\n     }\n     \n-    public static long[] subarray(final long[] array, int startIndexInclusive, int endIndexExclusive) {\n+    public static long[] subarray(final long[] array, int n, int length) {\n         if (array == null) {\n             return null;\n         }\n-        if (startIndexInclusive < 0) {\n-            startIndexInclusive = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (endIndexExclusive > array.length) {\n-            endIndexExclusive = array.length;\n+        if (length > array.length) {\n+            length = array.length;\n         }\n-        final int newSize = endIndexExclusive - startIndexInclusive;\n-        if (newSize <= 0) {\n+        final int n2 = length - n;\n+        if (n2 <= 0) {\n             return ArrayUtils.EMPTY_LONG_ARRAY;\n         }\n-        final long[] subarray = new long[newSize];\n-        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n-        return subarray;\n+        final long[] array2 = new long[n2];\n+        System.arraycopy(array, n, array2, 0, n2);\n+        return array2;\n     }\n     \n-    public static short[] subarray(final short[] array, int startIndexInclusive, int endIndexExclusive) {\n+    public static short[] subarray(final short[] array, int n, int length) {\n         if (array == null) {\n             return null;\n         }\n-        if (startIndexInclusive < 0) {\n-            startIndexInclusive = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (endIndexExclusive > array.length) {\n-            endIndexExclusive = array.length;\n+        if (length > array.length) {\n+            length = array.length;\n         }\n-        final int newSize = endIndexExclusive - startIndexInclusive;\n-        if (newSize <= 0) {\n+        final int n2 = length - n;\n+        if (n2 <= 0) {\n             return ArrayUtils.EMPTY_SHORT_ARRAY;\n         }\n-        final short[] subarray = new short[newSize];\n-        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n-        return subarray;\n+        final short[] array2 = new short[n2];\n+        System.arraycopy(array, n, array2, 0, n2);\n+        return array2;\n     }\n     \n-    public static <T> T[] subarray(final T[] array, int startIndexInclusive, int endIndexExclusive) {\n+    public static <T> T[] subarray(final T[] array, int n, int length) {\n         if (array == null) {\n             return null;\n         }\n-        if (startIndexInclusive < 0) {\n-            startIndexInclusive = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (endIndexExclusive > array.length) {\n-            endIndexExclusive = array.length;\n+        if (length > array.length) {\n+            length = array.length;\n         }\n-        final int newSize = endIndexExclusive - startIndexInclusive;\n-        final Class<?> type = array.getClass().getComponentType();\n-        if (newSize <= 0) {\n-            final T[] emptyArray = (T[])Array.newInstance(type, 0);\n-            return emptyArray;\n+        final int length2 = length - n;\n+        final Class<?> componentType = array.getClass().getComponentType();\n+        if (length2 <= 0) {\n+            return (T[])Array.newInstance(componentType, 0);\n         }\n-        final T[] subarray = (T[])Array.newInstance(type, newSize);\n-        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n-        return subarray;\n+        final Object[] array2 = (Object[])Array.newInstance(componentType, length2);\n+        System.arraycopy(array, n, array2, 0, length2);\n+        return (T[])array2;\n     }\n     \n-    public static void swap(final boolean[] array, final int offset1, final int offset2) {\n+    public static void swap(final boolean[] array, final int n, final int n2) {\n         if (isEmpty(array)) {\n             return;\n         }\n-        swap(array, offset1, offset2, 1);\n+        swap(array, n, n2, 1);\n     }\n     \n-    public static void swap(final boolean[] array, int offset1, int offset2, int len) {\n-        if (isEmpty(array) || offset1 >= array.length || offset2 >= array.length) {\n+    public static void swap(final boolean[] array, int n, int n2, int min) {\n+        if (isEmpty(array) || n >= array.length || n2 >= array.length) {\n             return;\n         }\n-        if (offset1 < 0) {\n-            offset1 = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (offset2 < 0) {\n-            offset2 = 0;\n+        if (n2 < 0) {\n+            n2 = 0;\n         }\n-        len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);\n-        for (int i = 0; i < len; ++i, ++offset1, ++offset2) {\n-            final boolean aux = array[offset1];\n-            array[offset1] = array[offset2];\n-            array[offset2] = aux;\n+        min = Math.min(Math.min(min, array.length - n), array.length - n2);\n+        for (int i = 0; i < min; ++i, ++n, ++n2) {\n+            final boolean b = array[n];\n+            array[n] = array[n2];\n+            array[n2] = b;\n         }\n     }\n     \n-    public static void swap(final byte[] array, final int offset1, final int offset2) {\n+    public static void swap(final byte[] array, final int n, final int n2) {\n         if (isEmpty(array)) {\n             return;\n         }\n-        swap(array, offset1, offset2, 1);\n+        swap(array, n, n2, 1);\n     }\n     \n-    public static void swap(final byte[] array, int offset1, int offset2, int len) {\n-        if (isEmpty(array) || offset1 >= array.length || offset2 >= array.length) {\n+    public static void swap(final byte[] array, int n, int n2, int min) {\n+        if (isEmpty(array) || n >= array.length || n2 >= array.length) {\n             return;\n         }\n-        if (offset1 < 0) {\n-            offset1 = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (offset2 < 0) {\n-            offset2 = 0;\n+        if (n2 < 0) {\n+            n2 = 0;\n         }\n-        len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);\n-        for (int i = 0; i < len; ++i, ++offset1, ++offset2) {\n-            final byte aux = array[offset1];\n-            array[offset1] = array[offset2];\n-            array[offset2] = aux;\n+        min = Math.min(Math.min(min, array.length - n), array.length - n2);\n+        for (int i = 0; i < min; ++i, ++n, ++n2) {\n+            final byte b = array[n];\n+            array[n] = array[n2];\n+            array[n2] = b;\n         }\n     }\n     \n-    public static void swap(final char[] array, final int offset1, final int offset2) {\n+    public static void swap(final char[] array, final int n, final int n2) {\n         if (isEmpty(array)) {\n             return;\n         }\n-        swap(array, offset1, offset2, 1);\n+        swap(array, n, n2, 1);\n     }\n     \n-    public static void swap(final char[] array, int offset1, int offset2, int len) {\n-        if (isEmpty(array) || offset1 >= array.length || offset2 >= array.length) {\n+    public static void swap(final char[] array, int n, int n2, int min) {\n+        if (isEmpty(array) || n >= array.length || n2 >= array.length) {\n             return;\n         }\n-        if (offset1 < 0) {\n-            offset1 = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (offset2 < 0) {\n-            offset2 = 0;\n+        if (n2 < 0) {\n+            n2 = 0;\n         }\n-        len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);\n-        for (int i = 0; i < len; ++i, ++offset1, ++offset2) {\n-            final char aux = array[offset1];\n-            array[offset1] = array[offset2];\n-            array[offset2] = aux;\n+        min = Math.min(Math.min(min, array.length - n), array.length - n2);\n+        for (int i = 0; i < min; ++i, ++n, ++n2) {\n+            final char c = array[n];\n+            array[n] = array[n2];\n+            array[n2] = c;\n         }\n     }\n     \n-    public static void swap(final double[] array, final int offset1, final int offset2) {\n+    public static void swap(final double[] array, final int n, final int n2) {\n         if (isEmpty(array)) {\n             return;\n         }\n-        swap(array, offset1, offset2, 1);\n+        swap(array, n, n2, 1);\n     }\n     \n-    public static void swap(final double[] array, int offset1, int offset2, int len) {\n-        if (isEmpty(array) || offset1 >= array.length || offset2 >= array.length) {\n+    public static void swap(final double[] array, int n, int n2, int min) {\n+        if (isEmpty(array) || n >= array.length || n2 >= array.length) {\n             return;\n         }\n-        if (offset1 < 0) {\n-            offset1 = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (offset2 < 0) {\n-            offset2 = 0;\n+        if (n2 < 0) {\n+            n2 = 0;\n         }\n-        len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);\n-        for (int i = 0; i < len; ++i, ++offset1, ++offset2) {\n-            final double aux = array[offset1];\n-            array[offset1] = array[offset2];\n-            array[offset2] = aux;\n+        min = Math.min(Math.min(min, array.length - n), array.length - n2);\n+        for (int i = 0; i < min; ++i, ++n, ++n2) {\n+            final double n3 = array[n];\n+            array[n] = array[n2];\n+            array[n2] = n3;\n         }\n     }\n     \n-    public static void swap(final float[] array, final int offset1, final int offset2) {\n+    public static void swap(final float[] array, final int n, final int n2) {\n         if (isEmpty(array)) {\n             return;\n         }\n-        swap(array, offset1, offset2, 1);\n+        swap(array, n, n2, 1);\n     }\n     \n-    public static void swap(final float[] array, int offset1, int offset2, int len) {\n-        if (isEmpty(array) || offset1 >= array.length || offset2 >= array.length) {\n+    public static void swap(final float[] array, int n, int n2, int min) {\n+        if (isEmpty(array) || n >= array.length || n2 >= array.length) {\n             return;\n         }\n-        if (offset1 < 0) {\n-            offset1 = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (offset2 < 0) {\n-            offset2 = 0;\n+        if (n2 < 0) {\n+            n2 = 0;\n         }\n-        len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);\n-        for (int i = 0; i < len; ++i, ++offset1, ++offset2) {\n-            final float aux = array[offset1];\n-            array[offset1] = array[offset2];\n-            array[offset2] = aux;\n+        min = Math.min(Math.min(min, array.length - n), array.length - n2);\n+        for (int i = 0; i < min; ++i, ++n, ++n2) {\n+            final float n3 = array[n];\n+            array[n] = array[n2];\n+            array[n2] = n3;\n         }\n     }\n     \n-    public static void swap(final int[] array, final int offset1, final int offset2) {\n+    public static void swap(final int[] array, final int n, final int n2) {\n         if (isEmpty(array)) {\n             return;\n         }\n-        swap(array, offset1, offset2, 1);\n+        swap(array, n, n2, 1);\n     }\n     \n-    public static void swap(final int[] array, int offset1, int offset2, int len) {\n-        if (isEmpty(array) || offset1 >= array.length || offset2 >= array.length) {\n+    public static void swap(final int[] array, int n, int n2, int min) {\n+        if (isEmpty(array) || n >= array.length || n2 >= array.length) {\n             return;\n         }\n-        if (offset1 < 0) {\n-            offset1 = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (offset2 < 0) {\n-            offset2 = 0;\n+        if (n2 < 0) {\n+            n2 = 0;\n         }\n-        len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);\n-        for (int i = 0; i < len; ++i, ++offset1, ++offset2) {\n-            final int aux = array[offset1];\n-            array[offset1] = array[offset2];\n-            array[offset2] = aux;\n+        min = Math.min(Math.min(min, array.length - n), array.length - n2);\n+        for (int i = 0; i < min; ++i, ++n, ++n2) {\n+            final int n3 = array[n];\n+            array[n] = array[n2];\n+            array[n2] = n3;\n         }\n     }\n     \n-    public static void swap(final long[] array, final int offset1, final int offset2) {\n+    public static void swap(final long[] array, final int n, final int n2) {\n         if (isEmpty(array)) {\n             return;\n         }\n-        swap(array, offset1, offset2, 1);\n+        swap(array, n, n2, 1);\n     }\n     \n-    public static void swap(final long[] array, int offset1, int offset2, int len) {\n-        if (isEmpty(array) || offset1 >= array.length || offset2 >= array.length) {\n+    public static void swap(final long[] array, int n, int n2, int min) {\n+        if (isEmpty(array) || n >= array.length || n2 >= array.length) {\n             return;\n         }\n-        if (offset1 < 0) {\n-            offset1 = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (offset2 < 0) {\n-            offset2 = 0;\n+        if (n2 < 0) {\n+            n2 = 0;\n         }\n-        len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);\n-        for (int i = 0; i < len; ++i, ++offset1, ++offset2) {\n-            final long aux = array[offset1];\n-            array[offset1] = array[offset2];\n-            array[offset2] = aux;\n+        min = Math.min(Math.min(min, array.length - n), array.length - n2);\n+        for (int i = 0; i < min; ++i, ++n, ++n2) {\n+            final long n3 = array[n];\n+            array[n] = array[n2];\n+            array[n2] = n3;\n         }\n     }\n     \n-    public static void swap(final Object[] array, final int offset1, final int offset2) {\n+    public static void swap(final Object[] array, final int n, final int n2) {\n         if (isEmpty(array)) {\n             return;\n         }\n-        swap(array, offset1, offset2, 1);\n+        swap(array, n, n2, 1);\n     }\n     \n-    public static void swap(final Object[] array, int offset1, int offset2, int len) {\n-        if (isEmpty(array) || offset1 >= array.length || offset2 >= array.length) {\n+    public static void swap(final Object[] array, int n, int n2, int min) {\n+        if (isEmpty(array) || n >= array.length || n2 >= array.length) {\n             return;\n         }\n-        if (offset1 < 0) {\n-            offset1 = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (offset2 < 0) {\n-            offset2 = 0;\n+        if (n2 < 0) {\n+            n2 = 0;\n         }\n-        len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);\n-        for (int i = 0; i < len; ++i, ++offset1, ++offset2) {\n-            final Object aux = array[offset1];\n-            array[offset1] = array[offset2];\n-            array[offset2] = aux;\n+        min = Math.min(Math.min(min, array.length - n), array.length - n2);\n+        for (int i = 0; i < min; ++i, ++n, ++n2) {\n+            final Object o = array[n];\n+            array[n] = array[n2];\n+            array[n2] = o;\n         }\n     }\n     \n-    public static void swap(final short[] array, final int offset1, final int offset2) {\n+    public static void swap(final short[] array, final int n, final int n2) {\n         if (isEmpty(array)) {\n             return;\n         }\n-        swap(array, offset1, offset2, 1);\n+        swap(array, n, n2, 1);\n     }\n     \n-    public static void swap(final short[] array, int offset1, int offset2, int len) {\n-        if (isEmpty(array) || offset1 >= array.length || offset2 >= array.length) {\n+    public static void swap(final short[] array, int n, int n2, int min) {\n+        if (isEmpty(array) || n >= array.length || n2 >= array.length) {\n             return;\n         }\n-        if (offset1 < 0) {\n-            offset1 = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (offset2 < 0) {\n-            offset2 = 0;\n+        if (n2 < 0) {\n+            n2 = 0;\n         }\n-        if (offset1 == offset2) {\n+        if (n == n2) {\n             return;\n         }\n-        len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);\n-        for (int i = 0; i < len; ++i, ++offset1, ++offset2) {\n-            final short aux = array[offset1];\n-            array[offset1] = array[offset2];\n-            array[offset2] = aux;\n+        min = Math.min(Math.min(min, array.length - n), array.length - n2);\n+        for (int i = 0; i < min; ++i, ++n, ++n2) {\n+            final short n3 = array[n];\n+            array[n] = array[n2];\n+            array[n2] = n3;\n         }\n     }\n     \n-    public static <T> T[] toArray(final T... items) {\n-        return items;\n+    public static <T> T[] toArray(final T... array) {\n+        return array;\n     }\n     \n     public static Map<Object, Object> toMap(final Object[] array) {\n         if (array == null) {\n             return null;\n         }\n-        final Map<Object, Object> map = new HashMap<Object, Object>((int)(array.length * 1.5));\n+        final HashMap hashMap = new HashMap((int)(array.length * 1.5));\n         for (int i = 0; i < array.length; ++i) {\n-            final Object object = array[i];\n-            if (object instanceof Map.Entry) {\n-                final Map.Entry<?, ?> entry = (Map.Entry)object;\n-                map.put(entry.getKey(), entry.getValue());\n+            final Object o = array[i];\n+            if (o instanceof Map.Entry) {\n+                final Map.Entry entry = (Map.Entry)o;\n+                hashMap.put(entry.getKey(), entry.getValue());\n             }\n             else {\n-                if (!(object instanceof Object[])) {\n-                    throw new IllegalArgumentException(\"Array element \" + i + \", '\" + object + \"', is neither of type Map.Entry nor an Array\");\n+                if (!(o instanceof Object[])) {\n+                    throw new IllegalArgumentException(\"Array element \" + i + \", '\" + o + \"', is neither of type Map.Entry nor an Array\");\n                 }\n-                final Object[] entry2 = (Object[])object;\n-                if (entry2.length < 2) {\n-                    throw new IllegalArgumentException(\"Array element \" + i + \", '\" + object + \"', has a length less than 2\");\n+                final Object[] array2 = (Object[])o;\n+                if (array2.length < 2) {\n+                    throw new IllegalArgumentException(\"Array element \" + i + \", '\" + o + \"', has a length less than 2\");\n                 }\n-                map.put(entry2[0], entry2[1]);\n+                hashMap.put(array2[0], array2[1]);\n             }\n         }\n-        return map;\n+        return hashMap;\n     }\n     \n     public static Boolean[] toObject(final boolean[] array) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY;\n         }\n-        final Boolean[] result = new Boolean[array.length];\n+        final Boolean[] array2 = new Boolean[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);\n+            array2[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);\n         }\n-        return result;\n+        return array2;\n     }\n     \n     public static Byte[] toObject(final byte[] array) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY;\n         }\n-        final Byte[] result = new Byte[array.length];\n+        final Byte[] array2 = new Byte[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            result[i] = Byte.valueOf(array[i]);\n+            array2[i] = Byte.valueOf(array[i]);\n         }\n-        return result;\n+        return array2;\n     }\n     \n     public static Character[] toObject(final char[] array) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY;\n         }\n-        final Character[] result = new Character[array.length];\n+        final Character[] array2 = new Character[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            result[i] = Character.valueOf(array[i]);\n+            array2[i] = Character.valueOf(array[i]);\n         }\n-        return result;\n+        return array2;\n     }\n     \n     public static Double[] toObject(final double[] array) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY;\n         }\n-        final Double[] result = new Double[array.length];\n+        final Double[] array2 = new Double[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            result[i] = Double.valueOf(array[i]);\n+            array2[i] = Double.valueOf(array[i]);\n         }\n-        return result;\n+        return array2;\n     }\n     \n     public static Float[] toObject(final float[] array) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY;\n         }\n-        final Float[] result = new Float[array.length];\n+        final Float[] array2 = new Float[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            result[i] = Float.valueOf(array[i]);\n+            array2[i] = Float.valueOf(array[i]);\n         }\n-        return result;\n+        return array2;\n     }\n     \n     public static Integer[] toObject(final int[] array) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY;\n         }\n-        final Integer[] result = new Integer[array.length];\n+        final Integer[] array2 = new Integer[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            result[i] = Integer.valueOf(array[i]);\n+            array2[i] = Integer.valueOf(array[i]);\n         }\n-        return result;\n+        return array2;\n     }\n     \n     public static Long[] toObject(final long[] array) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_LONG_OBJECT_ARRAY;\n         }\n-        final Long[] result = new Long[array.length];\n+        final Long[] array2 = new Long[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            result[i] = Long.valueOf(array[i]);\n+            array2[i] = Long.valueOf(array[i]);\n         }\n-        return result;\n+        return array2;\n     }\n     \n     public static Short[] toObject(final short[] array) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY;\n         }\n-        final Short[] result = new Short[array.length];\n+        final Short[] array2 = new Short[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            result[i] = Short.valueOf(array[i]);\n+            array2[i] = Short.valueOf(array[i]);\n         }\n-        return result;\n+        return array2;\n     }\n     \n     public static boolean[] toPrimitive(final Boolean[] array) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n         }\n-        final boolean[] result = new boolean[array.length];\n+        final boolean[] array2 = new boolean[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            result[i] = array[i];\n+            array2[i] = array[i];\n         }\n-        return result;\n+        return array2;\n     }\n     \n-    public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {\n+    public static boolean[] toPrimitive(final Boolean[] array, final boolean b) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n         }\n-        final boolean[] result = new boolean[array.length];\n+        final boolean[] array2 = new boolean[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            final Boolean b = array[i];\n-            result[i] = ((b == null) ? valueForNull : ((boolean)b));\n+            final Boolean b2 = array[i];\n+            array2[i] = ((b2 == null) ? b : ((boolean)b2));\n         }\n-        return result;\n+        return array2;\n     }\n     \n     public static byte[] toPrimitive(final Byte[] array) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_BYTE_ARRAY;\n         }\n-        final byte[] result = new byte[array.length];\n+        final byte[] array2 = new byte[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            result[i] = array[i];\n+            array2[i] = array[i];\n         }\n-        return result;\n+        return array2;\n     }\n     \n-    public static byte[] toPrimitive(final Byte[] array, final byte valueForNull) {\n+    public static byte[] toPrimitive(final Byte[] array, final byte b) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_BYTE_ARRAY;\n         }\n-        final byte[] result = new byte[array.length];\n+        final byte[] array2 = new byte[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            final Byte b = array[i];\n-            result[i] = ((b == null) ? valueForNull : ((byte)b));\n+            final Byte b2 = array[i];\n+            array2[i] = ((b2 == null) ? b : ((byte)b2));\n         }\n-        return result;\n+        return array2;\n     }\n     \n     public static char[] toPrimitive(final Character[] array) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_CHAR_ARRAY;\n         }\n-        final char[] result = new char[array.length];\n+        final char[] array2 = new char[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            result[i] = array[i];\n+            array2[i] = array[i];\n         }\n-        return result;\n+        return array2;\n     }\n     \n-    public static char[] toPrimitive(final Character[] array, final char valueForNull) {\n+    public static char[] toPrimitive(final Character[] array, final char c) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_CHAR_ARRAY;\n         }\n-        final char[] result = new char[array.length];\n+        final char[] array2 = new char[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            final Character b = array[i];\n-            result[i] = ((b == null) ? valueForNull : ((char)b));\n+            final Character c2 = array[i];\n+            array2[i] = ((c2 == null) ? c : ((char)c2));\n         }\n-        return result;\n+        return array2;\n     }\n     \n     public static double[] toPrimitive(final Double[] array) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_DOUBLE_ARRAY;\n         }\n-        final double[] result = new double[array.length];\n+        final double[] array2 = new double[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            result[i] = array[i];\n+            array2[i] = array[i];\n         }\n-        return result;\n+        return array2;\n     }\n     \n-    public static double[] toPrimitive(final Double[] array, final double valueForNull) {\n+    public static double[] toPrimitive(final Double[] array, final double n) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_DOUBLE_ARRAY;\n         }\n-        final double[] result = new double[array.length];\n+        final double[] array2 = new double[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            final Double b = array[i];\n-            result[i] = ((b == null) ? valueForNull : ((double)b));\n+            final Double n2 = array[i];\n+            array2[i] = ((n2 == null) ? n : ((double)n2));\n         }\n-        return result;\n+        return array2;\n     }\n     \n     public static float[] toPrimitive(final Float[] array) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_FLOAT_ARRAY;\n         }\n-        final float[] result = new float[array.length];\n+        final float[] array2 = new float[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            result[i] = array[i];\n+            array2[i] = array[i];\n         }\n-        return result;\n+        return array2;\n     }\n     \n-    public static float[] toPrimitive(final Float[] array, final float valueForNull) {\n+    public static float[] toPrimitive(final Float[] array, final float n) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_FLOAT_ARRAY;\n         }\n-        final float[] result = new float[array.length];\n+        final float[] array2 = new float[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            final Float b = array[i];\n-            result[i] = ((b == null) ? valueForNull : ((float)b));\n+            final Float n2 = array[i];\n+            array2[i] = ((n2 == null) ? n : ((float)n2));\n         }\n-        return result;\n+        return array2;\n     }\n     \n     public static int[] toPrimitive(final Integer[] array) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_INT_ARRAY;\n         }\n-        final int[] result = new int[array.length];\n+        final int[] array2 = new int[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            result[i] = array[i];\n+            array2[i] = array[i];\n         }\n-        return result;\n+        return array2;\n     }\n     \n-    public static int[] toPrimitive(final Integer[] array, final int valueForNull) {\n+    public static int[] toPrimitive(final Integer[] array, final int n) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_INT_ARRAY;\n         }\n-        final int[] result = new int[array.length];\n+        final int[] array2 = new int[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            final Integer b = array[i];\n-            result[i] = ((b == null) ? valueForNull : ((int)b));\n+            final Integer n2 = array[i];\n+            array2[i] = ((n2 == null) ? n : ((int)n2));\n         }\n-        return result;\n+        return array2;\n     }\n     \n     public static long[] toPrimitive(final Long[] array) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_LONG_ARRAY;\n         }\n-        final long[] result = new long[array.length];\n+        final long[] array2 = new long[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            result[i] = array[i];\n+            array2[i] = array[i];\n         }\n-        return result;\n+        return array2;\n     }\n     \n-    public static long[] toPrimitive(final Long[] array, final long valueForNull) {\n+    public static long[] toPrimitive(final Long[] array, final long n) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_LONG_ARRAY;\n         }\n-        final long[] result = new long[array.length];\n+        final long[] array2 = new long[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            final Long b = array[i];\n-            result[i] = ((b == null) ? valueForNull : ((long)b));\n+            final Long n2 = array[i];\n+            array2[i] = ((n2 == null) ? n : ((long)n2));\n         }\n-        return result;\n+        return array2;\n     }\n     \n-    public static Object toPrimitive(final Object array) {\n-        if (array == null) {\n+    public static Object toPrimitive(final Object o) {\n+        if (o == null) {\n             return null;\n         }\n-        final Class<?> ct = array.getClass().getComponentType();\n-        final Class<?> pt = ClassUtils.wrapperToPrimitive((Class)ct);\n-        if (Boolean.TYPE.equals(pt)) {\n-            return toPrimitive((Boolean[])array);\n+        final Class wrapperToPrimitive = ClassUtils.wrapperToPrimitive((Class)o.getClass().getComponentType());\n+        if (Boolean.TYPE.equals(wrapperToPrimitive)) {\n+            return toPrimitive((Boolean[])o);\n         }\n-        if (Character.TYPE.equals(pt)) {\n-            return toPrimitive((Character[])array);\n+        if (Character.TYPE.equals(wrapperToPrimitive)) {\n+            return toPrimitive((Character[])o);\n         }\n-        if (Byte.TYPE.equals(pt)) {\n-            return toPrimitive((Byte[])array);\n+        if (Byte.TYPE.equals(wrapperToPrimitive)) {\n+            return toPrimitive((Byte[])o);\n         }\n-        if (Integer.TYPE.equals(pt)) {\n-            return toPrimitive((Integer[])array);\n+        if (Integer.TYPE.equals(wrapperToPrimitive)) {\n+            return toPrimitive((Integer[])o);\n         }\n-        if (Long.TYPE.equals(pt)) {\n-            return toPrimitive((Long[])array);\n+        if (Long.TYPE.equals(wrapperToPrimitive)) {\n+            return toPrimitive((Long[])o);\n         }\n-        if (Short.TYPE.equals(pt)) {\n-            return toPrimitive((Short[])array);\n+        if (Short.TYPE.equals(wrapperToPrimitive)) {\n+            return toPrimitive((Short[])o);\n         }\n-        if (Double.TYPE.equals(pt)) {\n-            return toPrimitive((Double[])array);\n+        if (Double.TYPE.equals(wrapperToPrimitive)) {\n+            return toPrimitive((Double[])o);\n         }\n-        if (Float.TYPE.equals(pt)) {\n-            return toPrimitive((Float[])array);\n+        if (Float.TYPE.equals(wrapperToPrimitive)) {\n+            return toPrimitive((Float[])o);\n         }\n-        return array;\n+        return o;\n     }\n     \n     public static short[] toPrimitive(final Short[] array) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_SHORT_ARRAY;\n         }\n-        final short[] result = new short[array.length];\n+        final short[] array2 = new short[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            result[i] = array[i];\n+            array2[i] = array[i];\n         }\n-        return result;\n+        return array2;\n     }\n     \n-    public static short[] toPrimitive(final Short[] array, final short valueForNull) {\n+    public static short[] toPrimitive(final Short[] array, final short n) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_SHORT_ARRAY;\n         }\n-        final short[] result = new short[array.length];\n+        final short[] array2 = new short[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            final Short b = array[i];\n-            result[i] = ((b == null) ? valueForNull : ((short)b));\n+            final Short n2 = array[i];\n+            array2[i] = ((n2 == null) ? n : ((short)n2));\n         }\n-        return result;\n+        return array2;\n     }\n     \n-    public static String toString(final Object array) {\n-        return toString(array, \"{}\");\n+    public static String toString(final Object o) {\n+        return toString(o, \"{}\");\n     }\n     \n-    public static String toString(final Object array, final String stringIfNull) {\n-        if (array == null) {\n-            return stringIfNull;\n+    public static String toString(final Object o, final String s) {\n+        if (o == null) {\n+            return s;\n         }\n-        return new ToStringBuilder(array, ToStringStyle.SIMPLE_STYLE).append(array).toString();\n+        return new ToStringBuilder(o, ToStringStyle.SIMPLE_STYLE).append(o).toString();\n     }\n     \n     public static String[] toStringArray(final Object[] array) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_STRING_ARRAY;\n         }\n-        final String[] result = new String[array.length];\n+        final String[] array2 = new String[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            result[i] = array[i].toString();\n+            array2[i] = array[i].toString();\n         }\n-        return result;\n+        return array2;\n     }\n     \n-    public static String[] toStringArray(final Object[] array, final String valueForNullElements) {\n+    public static String[] toStringArray(final Object[] array, final String s) {\n         if (null == array) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_STRING_ARRAY;\n         }\n-        final String[] result = new String[array.length];\n+        final String[] array2 = new String[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            final Object object = array[i];\n-            result[i] = ((object == null) ? valueForNullElements : object.toString());\n+            final Object o = array[i];\n+            array2[i] = ((o == null) ? s : o.toString());\n         }\n-        return result;\n+        return array2;\n     }\n     \n     static {\n         EMPTY_BOOLEAN_ARRAY = new boolean[0];\n         EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];\n         EMPTY_BYTE_ARRAY = new byte[0];\n         EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];\n"}]}
