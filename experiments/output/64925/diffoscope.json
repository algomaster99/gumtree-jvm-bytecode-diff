{"diffoscope-json-version": 1, "source1": "first/TarArchiveOutputStream.class", "source2": "second/TarArchiveOutputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -8,16 +8,16 @@\n import java.io.UnsupportedEncodingException;\n import java.util.Iterator;\n import java.io.StringWriter;\n import java.util.HashMap;\n import java.util.Map;\n import org.apache.commons.compress.archivers.ArchiveEntry;\n import java.io.IOException;\n-import org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\n import java.io.OutputStream;\n+import org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\n import org.apache.commons.compress.archivers.zip.ZipEncoding;\n import org.apache.commons.compress.utils.CountingOutputStream;\n import org.apache.commons.compress.utils.FixedLengthBlockOutputStream;\n import org.apache.commons.compress.archivers.ArchiveOutputStream;\n \n public class TarArchiveOutputStream extends ArchiveOutputStream\n {\n@@ -44,14 +44,18 @@\n     private final CountingOutputStream countingOut;\n     private final ZipEncoding zipEncoding;\n     final String encoding;\n     private boolean addPaxHeadersForNonAsciiNames;\n     private static final ZipEncoding ASCII;\n     private static final int BLOCK_SIZE_UNSPECIFIED = -511;\n     \n+    static {\n+        ASCII = ZipEncodingHelper.getZipEncoding(\"ASCII\");\n+    }\n+    \n     public TarArchiveOutputStream(final OutputStream os) {\n         this(os, -511);\n     }\n     \n     public TarArchiveOutputStream(final OutputStream os, final String encoding) {\n         this(os, -511, encoding);\n     }\n@@ -140,14 +144,18 @@\n         }\n         finally {\n             if (!this.closed) {\n                 this.out.close();\n                 this.closed = true;\n             }\n         }\n+        if (!this.closed) {\n+            this.out.close();\n+            this.closed = true;\n+        }\n     }\n     \n     @Deprecated\n     public int getRecordSize() {\n         return 512;\n     }\n     \n@@ -222,15 +230,15 @@\n     }\n     \n     public void write(final byte[] wBuf, final int wOffset, final int numToWrite) throws IOException {\n         if (!this.haveUnclosedEntry) {\n             throw new IllegalStateException(\"No current tar entry\");\n         }\n         if (this.currBytes + numToWrite > this.currSize) {\n-            throw new IOException(\"Request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + this.currSize + \"' bytes for entry '\" + this.currName);\n+            throw new IOException(\"Request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + this.currSize + \"' bytes for entry '\" + this.currName + \"'\");\n         }\n         this.out.write(wBuf, wOffset, numToWrite);\n         this.currBytes += numToWrite;\n     }\n     \n     void writePaxHeaders(final TarArchiveEntry entry, final String entryName, final Map<String, String> headers) throws IOException {\n         String name = \"./PaxHeaders.X/\" + this.stripTo7Bits(entryName);\n@@ -244,20 +252,20 @@\n         this.putArchiveEntry((ArchiveEntry)pex);\n         this.write(data);\n         this.closeArchiveEntry();\n     }\n     \n     private byte[] encodeExtendedPaxHeadersContents(final Map<String, String> headers) throws UnsupportedEncodingException {\n         final StringWriter w = new StringWriter();\n-        for (Map.Entry<String, String> h : headers.entrySet()) {\n+        for (final Map.Entry<String, String> h : headers.entrySet()) {\n             final String key = (String)h.getKey();\n             final String value = (String)h.getValue();\n             int len = key.length() + value.length() + 3 + 2;\n-            String line = len + \" \" + key + \"=\" + value;\n-            for (int actualLength = line.getBytes(\"UTF-8\").length; len != actualLength; len = actualLength, line = len + \" \" + key + \"=\" + value, actualLength = line.getBytes(\"UTF-8\").length) {}\n+            String line = String.valueOf(len) + \" \" + key + \"=\" + value + \"\\n\";\n+            for (int actualLength = line.getBytes(\"UTF-8\").length; len != actualLength; len = actualLength, line = String.valueOf(len) + \" \" + key + \"=\" + value + \"\\n\", actualLength = line.getBytes(\"UTF-8\").length) {}\n             w.write(line);\n         }\n         return w.toString().getBytes(\"UTF-8\");\n     }\n     \n     private String stripTo7Bits(final String name) {\n         final int length = name.length();\n@@ -292,15 +300,15 @@\n             throw new IOException(\"Stream has already been finished\");\n         }\n         return (ArchiveEntry)new TarArchiveEntry(inputFile, entryName);\n     }\n     \n     private void writeRecord(final byte[] record) throws IOException {\n         if (record.length != 512) {\n-            throw new IOException(\"Record to write has length '\" + record.length + \"' which is not the record size of '512'\");\n+            throw new IOException(\"Record to write has length '\" + record.length + \"' which is not the record size of '\" + 512 + \"'\");\n         }\n         this.out.write(record);\n         ++this.recordsWritten;\n     }\n     \n     private void padAsNeeded() throws IOException {\n         final int start = this.recordsWritten % this.recordsPerBlock;\n@@ -343,15 +351,15 @@\n     \n     private void failForBigNumberWithPosixMessage(final String field, final long value, final long maxValue) {\n         this.failForBigNumber(field, value, maxValue, \" Use STAR or POSIX extensions to overcome this limit\");\n     }\n     \n     private void failForBigNumber(final String field, final long value, final long maxValue, final String additionalMsg) {\n         if (value < 0L || value > maxValue) {\n-            throw new RuntimeException(field + \" '\" + value + \"' is too big ( > \" + maxValue + \" ).\" + additionalMsg);\n+            throw new RuntimeException(String.valueOf(field) + \" '\" + value + \"' is too big ( > \" + maxValue + \" ).\" + additionalMsg);\n         }\n     }\n     \n     private boolean handleLongName(final TarArchiveEntry entry, final String name, final Map<String, String> paxHeaders, final String paxHeaderName, final byte linkType, final String fieldName) throws IOException {\n         final ByteBuffer encodedName = this.zipEncoding.encode(name);\n         final int len = encodedName.limit() - encodedName.position();\n         if (len >= 100) {\n@@ -365,26 +373,22 @@\n                 this.transferModTime(entry, longLinkEntry);\n                 this.putArchiveEntry((ArchiveEntry)longLinkEntry);\n                 this.write(encodedName.array(), encodedName.arrayOffset(), len);\n                 this.write(0);\n                 this.closeArchiveEntry();\n             }\n             else if (this.longFileMode != 1) {\n-                throw new RuntimeException(fieldName + \" '\" + name + \"' is too long ( > 100 bytes)\");\n+                throw new RuntimeException(String.valueOf(fieldName) + \" '\" + name + \"' is too long ( > \" + 100 + \" bytes)\");\n             }\n         }\n         return false;\n     }\n     \n     private void transferModTime(final TarArchiveEntry from, final TarArchiveEntry to) {\n         Date fromModTime = from.getModTime();\n         final long fromModTimeSeconds = fromModTime.getTime() / 1000L;\n         if (fromModTimeSeconds < 0L || fromModTimeSeconds > 8589934591L) {\n             fromModTime = new Date(0L);\n         }\n         to.setModTime(fromModTime);\n     }\n-    \n-    static {\n-        ASCII = ZipEncodingHelper.getZipEncoding(\"ASCII\");\n-    }\n }\n"}]}
