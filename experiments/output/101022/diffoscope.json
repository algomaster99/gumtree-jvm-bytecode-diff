{"diffoscope-json-version": 1, "source1": "first/AbstractJavadocCheck.class", "source2": "second/AbstractJavadocCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,23 +1,23 @@\n \n package com.puppycrawl.tools.checkstyle.checks.javadoc;\n \n-import java.util.function.Supplier;\n-import java.util.HashMap;\n import com.puppycrawl.tools.checkstyle.api.DetailAST;\n import java.util.Iterator;\n import java.util.Locale;\n import java.util.stream.Collector;\n import java.util.stream.Collectors;\n import java.util.Arrays;\n import java.util.Collection;\n import com.puppycrawl.tools.checkstyle.utils.JavadocUtil;\n import com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n import com.puppycrawl.tools.checkstyle.api.DetailNode;\n import java.util.HashSet;\n+import java.util.function.Supplier;\n+import java.util.HashMap;\n import java.util.Set;\n import com.puppycrawl.tools.checkstyle.JavadocDetailNodeParser;\n import com.puppycrawl.tools.checkstyle.api.LineColumn;\n import java.util.Map;\n import com.puppycrawl.tools.checkstyle.api.AbstractCheck;\n \n public abstract class AbstractJavadocCheck extends AbstractCheck\n@@ -26,14 +26,18 @@\n     public static final String MSG_JAVADOC_WRONG_SINGLETON_TAG = \"javadoc.wrong.singleton.html.tag\";\n     public static final String MSG_JAVADOC_PARSE_RULE_ERROR = \"javadoc.parse.rule.error\";\n     private static final ThreadLocal<Map<LineColumn, JavadocDetailNodeParser.ParseStatus>> TREE_CACHE;\n     private final ThreadLocal<AbstractJavadocCheck.FileContext> context;\n     private final Set<Integer> javadocTokens;\n     private boolean violateExecutionOnNonTightHtml;\n     \n+    static {\n+        TREE_CACHE = ThreadLocal.withInitial((Supplier<? extends Map<LineColumn, JavadocDetailNodeParser.ParseStatus>>)HashMap::new);\n+    }\n+    \n     public AbstractJavadocCheck() {\n         this.context = ThreadLocal.withInitial(() -> new AbstractJavadocCheck.FileContext());\n         this.javadocTokens = new HashSet<Integer>();\n     }\n     \n     public abstract int[] getDefaultJavadocTokens();\n     \n@@ -81,15 +85,17 @@\n         }\n     }\n     \n     private void validateDefaultJavadocTokens() {\n         if (this.getRequiredJavadocTokens().length != 0) {\n             final int[] defaultJavadocTokens = this.getDefaultJavadocTokens();\n             Arrays.sort(defaultJavadocTokens);\n-            for (final int javadocToken : this.getRequiredJavadocTokens()) {\n+            int[] requiredJavadocTokens;\n+            for (int length = (requiredJavadocTokens = this.getRequiredJavadocTokens()).length, i = 0; i < length; ++i) {\n+                final int javadocToken = requiredJavadocTokens[i];\n                 if (Arrays.binarySearch(defaultJavadocTokens, javadocToken) < 0) {\n                     final String message = String.format(Locale.ROOT, \"Javadoc Token \\\"%s\\\" from required javadoc tokens was not found in default javadoc tokens list in check %s\", Integer.valueOf(javadocToken), this.getClass().getName());\n                     throw new IllegalStateException(message);\n                 }\n             }\n         }\n     }\n@@ -126,15 +132,15 @@\n     public final void finishTree(final DetailAST rootAST) {\n     }\n     \n     public final void visitToken(final DetailAST blockCommentNode) {\n         if (JavadocUtil.isJavadocComment(blockCommentNode)) {\n             ((AbstractJavadocCheck.FileContext)this.context.get()).blockCommentAst = blockCommentNode;\n             final LineColumn treeCacheKey = new LineColumn(blockCommentNode.getLineNo(), blockCommentNode.getColumnNo());\n-            final JavadocDetailNodeParser.ParseStatus result = (JavadocDetailNodeParser.ParseStatus)((Map<LineColumn, JavadocDetailNodeParser.ParseStatus>)AbstractJavadocCheck.TREE_CACHE.get()).computeIfAbsent(treeCacheKey, key -> ((AbstractJavadocCheck.FileContext)this.context.get()).parser.parseJavadocAsDetailNode(blockCommentNode));\n+            final JavadocDetailNodeParser.ParseStatus result = (JavadocDetailNodeParser.ParseStatus)((Map<LineColumn, JavadocDetailNodeParser.ParseStatus>)AbstractJavadocCheck.TREE_CACHE.get()).computeIfAbsent(treeCacheKey, key -> ((AbstractJavadocCheck.FileContext)this.context.get()).parser.parseJavadocAsDetailNode(detailAST));\n             if (result.getParseErrorMessage() == null) {\n                 if (this.acceptJavadocWithNonTightHtml() || !result.isNonTight()) {\n                     this.processTree(result.getTree());\n                 }\n                 if (this.violateExecutionOnNonTightHtml && result.isNonTight()) {\n                     this.log(result.getFirstNonTightHtmlTag().getLine(), \"javadoc.unclosedHtml\", new Object[] { result.getFirstNonTightHtmlTag().getText() });\n                 }\n@@ -185,12 +191,8 @@\n     }\n     \n     public void destroy() {\n         super.destroy();\n         this.context.remove();\n         AbstractJavadocCheck.TREE_CACHE.remove();\n     }\n-    \n-    static {\n-        TREE_CACHE = ThreadLocal.withInitial((Supplier<? extends Map<LineColumn, JavadocDetailNodeParser.ParseStatus>>)HashMap::new);\n-    }\n }\n"}]}
