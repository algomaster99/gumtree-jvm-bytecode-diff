{"diffoscope-json-version": 1, "source1": "first/ArArchiveOutputStream.class", "source2": "second/ArArchiveOutputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -18,17 +18,17 @@\n     private final OutputStream out;\n     private long entryOffset;\n     private ArArchiveEntry prevEntry;\n     private boolean haveUnclosedEntry;\n     private int longFileMode;\n     private boolean finished;\n     \n-    public ArArchiveOutputStream(final OutputStream pOut) {\n+    public ArArchiveOutputStream(final OutputStream out) {\n         this.longFileMode = 0;\n-        this.out = pOut;\n+        this.out = out;\n     }\n     \n     public void close() throws IOException {\n         try {\n             if (!this.finished) {\n                 this.finish();\n             }\n@@ -48,135 +48,129 @@\n         }\n         if (this.entryOffset % 2L != 0L) {\n             this.out.write(10);\n         }\n         this.haveUnclosedEntry = false;\n     }\n     \n-    public ArchiveEntry createArchiveEntry(final File inputFile, final String entryName) throws IOException {\n+    public ArchiveEntry createArchiveEntry(final File file, final String s) throws IOException {\n         if (this.finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n-        return (ArchiveEntry)new ArArchiveEntry(inputFile, entryName);\n+        return (ArchiveEntry)new ArArchiveEntry(file, s);\n     }\n     \n-    public ArchiveEntry createArchiveEntry(final Path inputPath, final String entryName, final LinkOption... options) throws IOException {\n+    public ArchiveEntry createArchiveEntry(final Path path, final String s, final LinkOption... array) throws IOException {\n         if (this.finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n-        return (ArchiveEntry)new ArArchiveEntry(inputPath, entryName, options);\n+        return (ArchiveEntry)new ArArchiveEntry(path, s, array);\n     }\n     \n-    private long fill(final long pOffset, final long pNewOffset, final char pFill) throws IOException {\n-        final long diff = pNewOffset - pOffset;\n-        if (diff > 0L) {\n-            for (int i = 0; i < diff; ++i) {\n-                this.write((int)pFill);\n+    private long fill(final long n, final long n2, final char c) throws IOException {\n+        final long n3 = n2 - n;\n+        if (n3 > 0L) {\n+            for (int n4 = 0; n4 < n3; ++n4) {\n+                this.write((int)c);\n             }\n         }\n-        return pNewOffset;\n+        return n2;\n     }\n     \n     public void finish() throws IOException {\n         if (this.haveUnclosedEntry) {\n             throw new IOException(\"This archive contains unclosed entries.\");\n         }\n         if (this.finished) {\n             throw new IOException(\"This archive has already been finished\");\n         }\n         this.finished = true;\n     }\n     \n-    public void putArchiveEntry(final ArchiveEntry pEntry) throws IOException {\n+    public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\n         if (this.finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n-        final ArArchiveEntry pArEntry = (ArArchiveEntry)pEntry;\n+        final ArArchiveEntry prevEntry = (ArArchiveEntry)archiveEntry;\n         if (this.prevEntry == null) {\n             this.writeArchiveHeader();\n         }\n         else {\n             if (this.prevEntry.getLength() != this.entryOffset) {\n                 throw new IOException(\"Length does not match entry (\" + this.prevEntry.getLength() + \" != \" + this.entryOffset);\n             }\n             if (this.haveUnclosedEntry) {\n                 this.closeArchiveEntry();\n             }\n         }\n-        this.writeEntryHeader(this.prevEntry = pArEntry);\n+        this.writeEntryHeader(this.prevEntry = prevEntry);\n         this.entryOffset = 0L;\n         this.haveUnclosedEntry = true;\n     }\n     \n     public void setLongFileMode(final int longFileMode) {\n         this.longFileMode = longFileMode;\n     }\n     \n     public void write(final byte[] b, final int off, final int len) throws IOException {\n         this.out.write(b, off, len);\n         this.count(len);\n         this.entryOffset += len;\n     }\n     \n-    private long write(final String data) throws IOException {\n-        final byte[] bytes = data.getBytes(StandardCharsets.US_ASCII);\n+    private long write(final String s) throws IOException {\n+        final byte[] bytes = s.getBytes(StandardCharsets.US_ASCII);\n         this.write(bytes);\n         return bytes.length;\n     }\n     \n     private void writeArchiveHeader() throws IOException {\n-        final byte[] header = ArchiveUtils.toAsciiBytes(\"!<arch>\\n\");\n-        this.out.write(header);\n+        this.out.write(ArchiveUtils.toAsciiBytes(\"!<arch>\\n\"));\n     }\n     \n-    private void writeEntryHeader(final ArArchiveEntry pEntry) throws IOException {\n-        long offset = 0L;\n-        boolean mustAppendName = false;\n-        final String n = pEntry.getName();\n-        final int nLength = n.length();\n-        if (0 == this.longFileMode && nLength > 16) {\n-            throw new IOException(\"File name too long, > 16 chars: \" + n);\n-        }\n-        if (1 == this.longFileMode && (nLength > 16 || n.contains(\" \"))) {\n-            mustAppendName = true;\n-            offset += this.write(\"#1/\" + nLength);\n+    private void writeEntryHeader(final ArArchiveEntry arArchiveEntry) throws IOException {\n+        final long n = 0L;\n+        boolean b = false;\n+        final String name = arArchiveEntry.getName();\n+        final int length = name.length();\n+        if (0 == this.longFileMode && length > 16) {\n+            throw new IOException(\"File name too long, > 16 chars: \" + name);\n+        }\n+        long n2;\n+        if (1 == this.longFileMode && (length > 16 || name.contains(\" \"))) {\n+            b = true;\n+            n2 = n + this.write(\"#1/\" + length);\n         }\n         else {\n-            offset += this.write(n);\n+            n2 = n + this.write(name);\n         }\n-        offset = this.fill(offset, 16L, ' ');\n-        final String m = \"\" + pEntry.getLastModified();\n-        if (m.length() > 12) {\n+        final long fill = this.fill(n2, 16L, ' ');\n+        final String string = \"\" + arArchiveEntry.getLastModified();\n+        if (string.length() > 12) {\n             throw new IOException(\"Last modified too long\");\n         }\n-        offset += this.write(m);\n-        offset = this.fill(offset, 28L, ' ');\n-        final String u = \"\" + pEntry.getUserId();\n-        if (u.length() > 6) {\n+        final long fill2 = this.fill(fill + this.write(string), 28L, ' ');\n+        final String string2 = \"\" + arArchiveEntry.getUserId();\n+        if (string2.length() > 6) {\n             throw new IOException(\"User id too long\");\n         }\n-        offset += this.write(u);\n-        offset = this.fill(offset, 34L, ' ');\n-        final String g = \"\" + pEntry.getGroupId();\n-        if (g.length() > 6) {\n+        final long fill3 = this.fill(fill2 + this.write(string2), 34L, ' ');\n+        final String string3 = \"\" + arArchiveEntry.getGroupId();\n+        if (string3.length() > 6) {\n             throw new IOException(\"Group id too long\");\n         }\n-        offset += this.write(g);\n-        offset = this.fill(offset, 40L, ' ');\n-        final String fm = \"\" + Integer.toString(pEntry.getMode(), 8);\n-        if (fm.length() > 8) {\n+        final long fill4 = this.fill(fill3 + this.write(string3), 40L, ' ');\n+        final String string4 = \"\" + Integer.toString(arArchiveEntry.getMode(), 8);\n+        if (string4.length() > 8) {\n             throw new IOException(\"Filemode too long\");\n         }\n-        offset += this.write(fm);\n-        offset = this.fill(offset, 48L, ' ');\n-        final String s = String.valueOf(pEntry.getLength() + (long)(mustAppendName ? nLength : 0));\n-        if (s.length() > 10) {\n+        final long fill5 = this.fill(fill4 + this.write(string4), 48L, ' ');\n+        final String value = String.valueOf(arArchiveEntry.getLength() + (long)(b ? length : 0));\n+        if (value.length() > 10) {\n             throw new IOException(\"Size too long\");\n         }\n-        offset += this.write(s);\n-        offset = this.fill(offset, 58L, ' ');\n-        offset += this.write(\"`\\n\");\n-        if (mustAppendName) {\n-            offset += this.write(n);\n+        final long n3 = this.fill(fill5 + this.write(value), 58L, ' ') + this.write(\"`\\n\");\n+        if (b) {\n+            final long n4 = n3 + this.write(name);\n         }\n     }\n }\n"}]}
