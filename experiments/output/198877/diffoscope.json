{"diffoscope-json-version": 1, "source1": "first/Pass2Verifier$CPESSC_Visitor.class", "source2": "second/Pass2Verifier$CPESSC_Visitor.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -8,15 +8,14 @@\n import org.apache.bcel.verifier.exc.LocalVariableInfoInconsistentException;\n import org.apache.bcel.classfile.LocalVariableTable;\n import org.apache.bcel.classfile.LineNumberTable;\n import org.apache.bcel.verifier.exc.AssertionViolatedException;\n import org.apache.bcel.Repository;\n import org.apache.bcel.classfile.InnerClass;\n import java.util.Locale;\n-import org.apache.bcel.verifier.Verifier;\n import org.apache.bcel.classfile.ExceptionTable;\n import org.apache.bcel.classfile.Code;\n import org.apache.bcel.verifier.VerificationResult;\n import org.apache.bcel.verifier.VerifierFactory;\n import org.apache.bcel.generic.ObjectType;\n import org.apache.bcel.generic.ArrayType;\n import org.apache.bcel.classfile.Method;\n@@ -65,617 +64,595 @@\n     private final ConstantPool cp;\n     private final int cplen;\n     private final DescendingVisitor carrier;\n     private final Set<String> field_names;\n     private final Set<String> field_names_and_desc;\n     private final Set<String> method_names_and_desc;\n     \n-    private CPESSC_Visitor(final Pass2Verifier this$0, final JavaClass _jc) {\n+    private CPESSC_Visitor(final Pass2Verifier this$0, final JavaClass jc) {\n         this.this$0 = this$0;\n         this.field_names = new HashSet();\n         this.field_names_and_desc = new HashSet();\n         this.method_names_and_desc = new HashSet();\n-        this.jc = _jc;\n-        this.cp = _jc.getConstantPool();\n+        this.jc = jc;\n+        this.cp = jc.getConstantPool();\n         this.cplen = this.cp.getLength();\n         this.CONST_Class = ConstantClass.class;\n         this.CONST_String = ConstantString.class;\n         this.CONST_Integer = ConstantInteger.class;\n         this.CONST_Float = ConstantFloat.class;\n         this.CONST_Long = ConstantLong.class;\n         this.CONST_Double = ConstantDouble.class;\n         this.CONST_NameAndType = ConstantNameAndType.class;\n         this.CONST_Utf8 = ConstantUtf8.class;\n-        (this.carrier = new DescendingVisitor(_jc, (Visitor)this)).visit();\n+        (this.carrier = new DescendingVisitor(jc, (Visitor)this)).visit();\n     }\n     \n-    private void checkIndex(final Node referrer, final int index, final Class<?> shouldbe) {\n-        if (index < 0 || index >= this.cplen) {\n-            throw new ClassConstraintException(\"Invalid index '\" + index + \"' used by '\" + Pass2Verifier.access$100(referrer) + \"'.\");\n+    private void checkIndex(final Node node, final int n, final Class<?> obj) {\n+        if (n < 0 || n >= this.cplen) {\n+            throw new ClassConstraintException(\"Invalid index '\" + n + \"' used by '\" + Pass2Verifier.access$100(node) + \"'.\");\n         }\n-        final Constant c = this.cp.getConstant(index);\n-        if (!shouldbe.isInstance(c)) {\n-            throw new ClassCastException(\"Illegal constant '\" + Pass2Verifier.access$100((Node)c) + \"' at index '\" + index + \"'. '\" + Pass2Verifier.access$100(referrer) + \"' expects a '\" + shouldbe + \"'.\");\n+        final Constant constant = this.cp.getConstant(n);\n+        if (!obj.isInstance(constant)) {\n+            throw new ClassCastException(\"Illegal constant '\" + Pass2Verifier.access$100((Node)constant) + \"' at index '\" + n + \"'. '\" + Pass2Verifier.access$100(node) + \"' expects a '\" + obj + \"'.\");\n         }\n     }\n     \n-    public void visitJavaClass(final JavaClass obj) {\n-        final Attribute[] atts = obj.getAttributes();\n-        boolean foundSourceFile = false;\n-        boolean foundInnerClasses = false;\n-        final boolean hasInnerClass = new Pass2Verifier.InnerClassDetector(this.jc).innerClassReferenced();\n-        for (final Attribute att : atts) {\n-            if (!(att instanceof SourceFile) && !(att instanceof Deprecated) && !(att instanceof InnerClasses) && !(att instanceof Synthetic)) {\n-                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$100((Node)att) + \"' as an attribute of the ClassFile structure '\" + Pass2Verifier.access$100((Node)obj) + \"' is unknown and will therefore be ignored.\");\n+    public void visitJavaClass(final JavaClass javaClass) {\n+        final Attribute[] attributes = javaClass.getAttributes();\n+        int n = 0;\n+        int n2 = 0;\n+        final boolean innerClassReferenced = new Pass2Verifier.InnerClassDetector(this.jc).innerClassReferenced();\n+        for (final Attribute attribute : attributes) {\n+            if (!(attribute instanceof SourceFile) && !(attribute instanceof Deprecated) && !(attribute instanceof InnerClasses) && !(attribute instanceof Synthetic)) {\n+                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$100((Node)attribute) + \"' as an attribute of the ClassFile structure '\" + Pass2Verifier.access$100((Node)javaClass) + \"' is unknown and will therefore be ignored.\");\n             }\n-            if (att instanceof SourceFile) {\n-                if (foundSourceFile) {\n-                    throw new ClassConstraintException(\"A ClassFile structure (like '\" + Pass2Verifier.access$100((Node)obj) + \"') may have no more than one SourceFile attribute.\");\n+            if (attribute instanceof SourceFile) {\n+                if (n != 0) {\n+                    throw new ClassConstraintException(\"A ClassFile structure (like '\" + Pass2Verifier.access$100((Node)javaClass) + \"') may have no more than one SourceFile attribute.\");\n                 }\n-                foundSourceFile = true;\n+                n = 1;\n             }\n-            if (att instanceof InnerClasses) {\n-                if (!foundInnerClasses) {\n-                    foundInnerClasses = true;\n+            if (attribute instanceof InnerClasses) {\n+                if (n2 == 0) {\n+                    n2 = 1;\n                 }\n-                else if (hasInnerClass) {\n-                    throw new ClassConstraintException(\"A Classfile structure (like '\" + Pass2Verifier.access$100((Node)obj) + \"') must have exactly one InnerClasses attribute if at least one Inner Class is referenced (which is the case). More than one InnerClasses attribute was found.\");\n+                else if (innerClassReferenced) {\n+                    throw new ClassConstraintException(\"A Classfile structure (like '\" + Pass2Verifier.access$100((Node)javaClass) + \"') must have exactly one InnerClasses attribute if at least one Inner Class is referenced (which is the case). More than one InnerClasses attribute was found.\");\n                 }\n-                if (!hasInnerClass) {\n-                    this.this$0.addMessage(\"No referenced Inner Class found, but InnerClasses attribute '\" + Pass2Verifier.access$100((Node)att) + \"' found. Strongly suggest removal of that attribute.\");\n+                if (!innerClassReferenced) {\n+                    this.this$0.addMessage(\"No referenced Inner Class found, but InnerClasses attribute '\" + Pass2Verifier.access$100((Node)attribute) + \"' found. Strongly suggest removal of that attribute.\");\n                 }\n             }\n         }\n-        if (hasInnerClass && !foundInnerClasses) {\n-            this.this$0.addMessage(\"A Classfile structure (like '\" + Pass2Verifier.access$100((Node)obj) + \"') must have exactly one InnerClasses attribute if at least one Inner Class is referenced (which is the case). No InnerClasses attribute was found.\");\n+        if (innerClassReferenced && n2 == 0) {\n+            this.this$0.addMessage(\"A Classfile structure (like '\" + Pass2Verifier.access$100((Node)javaClass) + \"') must have exactly one InnerClasses attribute if at least one Inner Class is referenced (which is the case). No InnerClasses attribute was found.\");\n         }\n     }\n     \n-    public void visitConstantClass(final ConstantClass obj) {\n-        if (obj.getTag() != 7) {\n-            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$100((Node)obj) + \"'.\");\n+    public void visitConstantClass(final ConstantClass constantClass) {\n+        if (constantClass.getTag() != 7) {\n+            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$100((Node)constantClass) + \"'.\");\n         }\n-        this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n+        this.checkIndex((Node)constantClass, constantClass.getNameIndex(), this.CONST_Utf8);\n     }\n     \n-    public void visitConstantFieldref(final ConstantFieldref obj) {\n-        if (obj.getTag() != 9) {\n-            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$100((Node)obj) + \"'.\");\n+    public void visitConstantFieldref(final ConstantFieldref constantFieldref) {\n+        if (constantFieldref.getTag() != 9) {\n+            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$100((Node)constantFieldref) + \"'.\");\n         }\n-        this.checkIndex((Node)obj, obj.getClassIndex(), this.CONST_Class);\n-        this.checkIndex((Node)obj, obj.getNameAndTypeIndex(), this.CONST_NameAndType);\n+        this.checkIndex((Node)constantFieldref, constantFieldref.getClassIndex(), this.CONST_Class);\n+        this.checkIndex((Node)constantFieldref, constantFieldref.getNameAndTypeIndex(), this.CONST_NameAndType);\n     }\n     \n-    public void visitConstantMethodref(final ConstantMethodref obj) {\n-        if (obj.getTag() != 10) {\n-            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$100((Node)obj) + \"'.\");\n+    public void visitConstantMethodref(final ConstantMethodref constantMethodref) {\n+        if (constantMethodref.getTag() != 10) {\n+            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$100((Node)constantMethodref) + \"'.\");\n         }\n-        this.checkIndex((Node)obj, obj.getClassIndex(), this.CONST_Class);\n-        this.checkIndex((Node)obj, obj.getNameAndTypeIndex(), this.CONST_NameAndType);\n+        this.checkIndex((Node)constantMethodref, constantMethodref.getClassIndex(), this.CONST_Class);\n+        this.checkIndex((Node)constantMethodref, constantMethodref.getNameAndTypeIndex(), this.CONST_NameAndType);\n     }\n     \n-    public void visitConstantInterfaceMethodref(final ConstantInterfaceMethodref obj) {\n-        if (obj.getTag() != 11) {\n-            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$100((Node)obj) + \"'.\");\n+    public void visitConstantInterfaceMethodref(final ConstantInterfaceMethodref constantInterfaceMethodref) {\n+        if (constantInterfaceMethodref.getTag() != 11) {\n+            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$100((Node)constantInterfaceMethodref) + \"'.\");\n         }\n-        this.checkIndex((Node)obj, obj.getClassIndex(), this.CONST_Class);\n-        this.checkIndex((Node)obj, obj.getNameAndTypeIndex(), this.CONST_NameAndType);\n+        this.checkIndex((Node)constantInterfaceMethodref, constantInterfaceMethodref.getClassIndex(), this.CONST_Class);\n+        this.checkIndex((Node)constantInterfaceMethodref, constantInterfaceMethodref.getNameAndTypeIndex(), this.CONST_NameAndType);\n     }\n     \n-    public void visitConstantString(final ConstantString obj) {\n-        if (obj.getTag() != 8) {\n-            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$100((Node)obj) + \"'.\");\n+    public void visitConstantString(final ConstantString constantString) {\n+        if (constantString.getTag() != 8) {\n+            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$100((Node)constantString) + \"'.\");\n         }\n-        this.checkIndex((Node)obj, obj.getStringIndex(), this.CONST_Utf8);\n+        this.checkIndex((Node)constantString, constantString.getStringIndex(), this.CONST_Utf8);\n     }\n     \n-    public void visitConstantInteger(final ConstantInteger obj) {\n-        if (obj.getTag() != 3) {\n-            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$100((Node)obj) + \"'.\");\n+    public void visitConstantInteger(final ConstantInteger constantInteger) {\n+        if (constantInteger.getTag() != 3) {\n+            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$100((Node)constantInteger) + \"'.\");\n         }\n     }\n     \n-    public void visitConstantFloat(final ConstantFloat obj) {\n-        if (obj.getTag() != 4) {\n-            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$100((Node)obj) + \"'.\");\n+    public void visitConstantFloat(final ConstantFloat constantFloat) {\n+        if (constantFloat.getTag() != 4) {\n+            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$100((Node)constantFloat) + \"'.\");\n         }\n     }\n     \n-    public void visitConstantLong(final ConstantLong obj) {\n-        if (obj.getTag() != 5) {\n-            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$100((Node)obj) + \"'.\");\n+    public void visitConstantLong(final ConstantLong constantLong) {\n+        if (constantLong.getTag() != 5) {\n+            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$100((Node)constantLong) + \"'.\");\n         }\n     }\n     \n-    public void visitConstantDouble(final ConstantDouble obj) {\n-        if (obj.getTag() != 6) {\n-            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$100((Node)obj) + \"'.\");\n+    public void visitConstantDouble(final ConstantDouble constantDouble) {\n+        if (constantDouble.getTag() != 6) {\n+            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$100((Node)constantDouble) + \"'.\");\n         }\n     }\n     \n-    public void visitConstantNameAndType(final ConstantNameAndType obj) {\n-        if (obj.getTag() != 12) {\n-            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$100((Node)obj) + \"'.\");\n+    public void visitConstantNameAndType(final ConstantNameAndType constantNameAndType) {\n+        if (constantNameAndType.getTag() != 12) {\n+            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$100((Node)constantNameAndType) + \"'.\");\n         }\n-        this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n-        this.checkIndex((Node)obj, obj.getSignatureIndex(), this.CONST_Utf8);\n+        this.checkIndex((Node)constantNameAndType, constantNameAndType.getNameIndex(), this.CONST_Utf8);\n+        this.checkIndex((Node)constantNameAndType, constantNameAndType.getSignatureIndex(), this.CONST_Utf8);\n     }\n     \n-    public void visitConstantUtf8(final ConstantUtf8 obj) {\n-        if (obj.getTag() != 1) {\n-            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$100((Node)obj) + \"'.\");\n+    public void visitConstantUtf8(final ConstantUtf8 constantUtf8) {\n+        if (constantUtf8.getTag() != 1) {\n+            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$100((Node)constantUtf8) + \"'.\");\n         }\n     }\n     \n-    public void visitField(final Field obj) {\n+    public void visitField(final Field field) {\n         if (this.jc.isClass()) {\n-            int maxone = 0;\n-            if (obj.isPrivate()) {\n-                ++maxone;\n+            int n = 0;\n+            if (field.isPrivate()) {\n+                ++n;\n             }\n-            if (obj.isProtected()) {\n-                ++maxone;\n+            if (field.isProtected()) {\n+                ++n;\n             }\n-            if (obj.isPublic()) {\n-                ++maxone;\n+            if (field.isPublic()) {\n+                ++n;\n             }\n-            if (maxone > 1) {\n-                throw new ClassConstraintException(\"Field '\" + Pass2Verifier.access$100((Node)obj) + \"' must only have at most one of its ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC modifiers set.\");\n+            if (n > 1) {\n+                throw new ClassConstraintException(\"Field '\" + Pass2Verifier.access$100((Node)field) + \"' must only have at most one of its ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC modifiers set.\");\n             }\n-            if (obj.isFinal() && obj.isVolatile()) {\n-                throw new ClassConstraintException(\"Field '\" + Pass2Verifier.access$100((Node)obj) + \"' must only have at most one of its ACC_FINAL, ACC_VOLATILE modifiers set.\");\n+            if (field.isFinal() && field.isVolatile()) {\n+                throw new ClassConstraintException(\"Field '\" + Pass2Verifier.access$100((Node)field) + \"' must only have at most one of its ACC_FINAL, ACC_VOLATILE modifiers set.\");\n             }\n         }\n         else {\n-            if (!obj.isPublic()) {\n-                throw new ClassConstraintException(\"Interface field '\" + Pass2Verifier.access$100((Node)obj) + \"' must have the ACC_PUBLIC modifier set but hasn't!\");\n+            if (!field.isPublic()) {\n+                throw new ClassConstraintException(\"Interface field '\" + Pass2Verifier.access$100((Node)field) + \"' must have the ACC_PUBLIC modifier set but hasn't!\");\n             }\n-            if (!obj.isStatic()) {\n-                throw new ClassConstraintException(\"Interface field '\" + Pass2Verifier.access$100((Node)obj) + \"' must have the ACC_STATIC modifier set but hasn't!\");\n+            if (!field.isStatic()) {\n+                throw new ClassConstraintException(\"Interface field '\" + Pass2Verifier.access$100((Node)field) + \"' must have the ACC_STATIC modifier set but hasn't!\");\n             }\n-            if (!obj.isFinal()) {\n-                throw new ClassConstraintException(\"Interface field '\" + Pass2Verifier.access$100((Node)obj) + \"' must have the ACC_FINAL modifier set but hasn't!\");\n+            if (!field.isFinal()) {\n+                throw new ClassConstraintException(\"Interface field '\" + Pass2Verifier.access$100((Node)field) + \"' must have the ACC_FINAL modifier set but hasn't!\");\n             }\n         }\n-        if ((obj.getAccessFlags() & 0xFFFFFF20) > 0) {\n-            this.this$0.addMessage(\"Field '\" + Pass2Verifier.access$100((Node)obj) + \"' has access flag(s) other than ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_VOLATILE, ACC_TRANSIENT set (ignored).\");\n+        if ((field.getAccessFlags() & 0xFFFFFF20) > 0) {\n+            this.this$0.addMessage(\"Field '\" + Pass2Verifier.access$100((Node)field) + \"' has access flag(s) other than ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_VOLATILE, ACC_TRANSIENT set (ignored).\");\n         }\n-        this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n-        final String name = obj.getName();\n+        this.checkIndex((Node)field, field.getNameIndex(), this.CONST_Utf8);\n+        final String name = field.getName();\n         if (!Pass2Verifier.access$200(name)) {\n-            throw new ClassConstraintException(\"Field '\" + Pass2Verifier.access$100((Node)obj) + \"' has illegal name '\" + obj.getName() + \"'.\");\n+            throw new ClassConstraintException(\"Field '\" + Pass2Verifier.access$100((Node)field) + \"' has illegal name '\" + field.getName() + \"'.\");\n         }\n-        this.checkIndex((Node)obj, obj.getSignatureIndex(), this.CONST_Utf8);\n-        final String sig = ((ConstantUtf8)this.cp.getConstant(obj.getSignatureIndex())).getBytes();\n+        this.checkIndex((Node)field, field.getSignatureIndex(), this.CONST_Utf8);\n+        final String bytes = ((ConstantUtf8)this.cp.getConstant(field.getSignatureIndex())).getBytes();\n         try {\n-            Type.getType(sig);\n+            Type.getType(bytes);\n         }\n-        catch (final ClassFormatException cfe) {\n-            throw new ClassConstraintException(\"Illegal descriptor (==signature) '\" + sig + \"' used by '\" + Pass2Verifier.access$100((Node)obj) + \"'.\", (Throwable)cfe);\n+        catch (final ClassFormatException ex) {\n+            throw new ClassConstraintException(\"Illegal descriptor (==signature) '\" + bytes + \"' used by '\" + Pass2Verifier.access$100((Node)field) + \"'.\", (Throwable)ex);\n         }\n-        final String nameanddesc = name + sig;\n-        if (this.field_names_and_desc.contains(nameanddesc)) {\n-            throw new ClassConstraintException(\"No two fields (like '\" + Pass2Verifier.access$100((Node)obj) + \"') are allowed have same names and descriptors!\");\n+        final String string = name + bytes;\n+        if (this.field_names_and_desc.contains(string)) {\n+            throw new ClassConstraintException(\"No two fields (like '\" + Pass2Verifier.access$100((Node)field) + \"') are allowed have same names and descriptors!\");\n         }\n         if (this.field_names.contains(name)) {\n             this.this$0.addMessage(\"More than one field of name '\" + name + \"' detected (but with different type descriptors). This is very unusual.\");\n         }\n-        this.field_names_and_desc.add(nameanddesc);\n+        this.field_names_and_desc.add(string);\n         this.field_names.add(name);\n-        final Attribute[] attributes;\n-        final Attribute[] atts = attributes = obj.getAttributes();\n-        for (final Attribute att : attributes) {\n-            if (!(att instanceof ConstantValue) && !(att instanceof Synthetic) && !(att instanceof Deprecated)) {\n-                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$100((Node)att) + \"' as an attribute of Field '\" + Pass2Verifier.access$100((Node)obj) + \"' is unknown and will therefore be ignored.\");\n+        for (final Attribute attribute : field.getAttributes()) {\n+            if (!(attribute instanceof ConstantValue) && !(attribute instanceof Synthetic) && !(attribute instanceof Deprecated)) {\n+                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$100((Node)attribute) + \"' as an attribute of Field '\" + Pass2Verifier.access$100((Node)field) + \"' is unknown and will therefore be ignored.\");\n             }\n-            if (!(att instanceof ConstantValue)) {\n-                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$100((Node)att) + \"' as an attribute of Field '\" + Pass2Verifier.access$100((Node)obj) + \"' is not a ConstantValue and is therefore only of use for debuggers and such.\");\n+            if (!(attribute instanceof ConstantValue)) {\n+                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$100((Node)attribute) + \"' as an attribute of Field '\" + Pass2Verifier.access$100((Node)field) + \"' is not a ConstantValue and is therefore only of use for debuggers and such.\");\n             }\n         }\n     }\n     \n-    public void visitMethod(final Method obj) {\n-        this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n-        final String name = obj.getName();\n+    public void visitMethod(final Method method) {\n+        this.checkIndex((Node)method, method.getNameIndex(), this.CONST_Utf8);\n+        final String name = method.getName();\n         if (!Pass2Verifier.access$300(name, true)) {\n-            throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$100((Node)obj) + \"' has illegal name '\" + name + \"'.\");\n+            throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$100((Node)method) + \"' has illegal name '\" + name + \"'.\");\n         }\n-        this.checkIndex((Node)obj, obj.getSignatureIndex(), this.CONST_Utf8);\n-        final String sig = ((ConstantUtf8)this.cp.getConstant(obj.getSignatureIndex())).getBytes();\n-        Type t;\n-        Type[] ts;\n+        this.checkIndex((Node)method, method.getSignatureIndex(), this.CONST_Utf8);\n+        final String bytes = ((ConstantUtf8)this.cp.getConstant(method.getSignatureIndex())).getBytes();\n+        Type returnType;\n+        Type[] argumentTypes;\n         try {\n-            t = Type.getReturnType(sig);\n-            ts = Type.getArgumentTypes(sig);\n+            returnType = Type.getReturnType(bytes);\n+            argumentTypes = Type.getArgumentTypes(bytes);\n         }\n-        catch (final ClassFormatException cfe) {\n-            throw new ClassConstraintException(\"Illegal descriptor (==signature) '\" + sig + \"' used by Method '\" + Pass2Verifier.access$100((Node)obj) + \"'.\", (Throwable)cfe);\n+        catch (final ClassFormatException ex) {\n+            throw new ClassConstraintException(\"Illegal descriptor (==signature) '\" + bytes + \"' used by Method '\" + Pass2Verifier.access$100((Node)method) + \"'.\", (Throwable)ex);\n         }\n-        Type act = t;\n-        if (act instanceof ArrayType) {\n-            act = ((ArrayType)act).getBasicType();\n+        Type basicType = returnType;\n+        if (basicType instanceof ArrayType) {\n+            basicType = ((ArrayType)basicType).getBasicType();\n         }\n-        if (act instanceof ObjectType) {\n-            final Verifier v = VerifierFactory.getVerifier(((ObjectType)act).getClassName());\n-            final VerificationResult vr = v.doPass1();\n-            if (vr != VerificationResult.VR_OK) {\n-                throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$100((Node)obj) + \"' has a return type that does not pass verification pass 1: '\" + vr + \"'.\");\n+        if (basicType instanceof ObjectType) {\n+            final VerificationResult doPass1 = VerifierFactory.getVerifier(((ObjectType)basicType).getClassName()).doPass1();\n+            if (doPass1 != VerificationResult.VR_OK) {\n+                throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$100((Node)method) + \"' has a return type that does not pass verification pass 1: '\" + doPass1 + \"'.\");\n             }\n         }\n-        final Type[] array = ts;\n-        for (int length = array.length, i = 0; i < length; ++i) {\n-            final Type element = act = array[i];\n-            if (act instanceof ArrayType) {\n-                act = ((ArrayType)act).getBasicType();\n+        for (Type basicType2 : argumentTypes) {\n+            if (basicType2 instanceof ArrayType) {\n+                basicType2 = ((ArrayType)basicType2).getBasicType();\n             }\n-            if (act instanceof ObjectType) {\n-                final Verifier v2 = VerifierFactory.getVerifier(((ObjectType)act).getClassName());\n-                final VerificationResult vr2 = v2.doPass1();\n-                if (vr2 != VerificationResult.VR_OK) {\n-                    throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$100((Node)obj) + \"' has an argument type that does not pass verification pass 1: '\" + vr2 + \"'.\");\n+            if (basicType2 instanceof ObjectType) {\n+                final VerificationResult doPass2 = VerifierFactory.getVerifier(((ObjectType)basicType2).getClassName()).doPass1();\n+                if (doPass2 != VerificationResult.VR_OK) {\n+                    throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$100((Node)method) + \"' has an argument type that does not pass verification pass 1: '\" + doPass2 + \"'.\");\n                 }\n             }\n         }\n-        if (name.equals(\"<clinit>\") && ts.length != 0) {\n-            throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$100((Node)obj) + \"' has illegal name '\" + name + \"'. Its name resembles the class or interface initialization method which it isn't because of its arguments (==descriptor).\");\n+        if (name.equals(\"<clinit>\") && argumentTypes.length != 0) {\n+            throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$100((Node)method) + \"' has illegal name '\" + name + \"'. Its name resembles the class or interface initialization method which it isn't because of its arguments (==descriptor).\");\n         }\n         if (this.jc.isClass()) {\n-            int maxone = 0;\n-            if (obj.isPrivate()) {\n-                ++maxone;\n+            int n = 0;\n+            if (method.isPrivate()) {\n+                ++n;\n             }\n-            if (obj.isProtected()) {\n-                ++maxone;\n+            if (method.isProtected()) {\n+                ++n;\n             }\n-            if (obj.isPublic()) {\n-                ++maxone;\n+            if (method.isPublic()) {\n+                ++n;\n             }\n-            if (maxone > 1) {\n-                throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$100((Node)obj) + \"' must only have at most one of its ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC modifiers set.\");\n+            if (n > 1) {\n+                throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$100((Node)method) + \"' must only have at most one of its ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC modifiers set.\");\n             }\n-            if (obj.isAbstract()) {\n-                if (obj.isFinal()) {\n-                    throw new ClassConstraintException(\"Abstract method '\" + Pass2Verifier.access$100((Node)obj) + \"' must not have the ACC_FINAL modifier set.\");\n+            if (method.isAbstract()) {\n+                if (method.isFinal()) {\n+                    throw new ClassConstraintException(\"Abstract method '\" + Pass2Verifier.access$100((Node)method) + \"' must not have the ACC_FINAL modifier set.\");\n                 }\n-                if (obj.isNative()) {\n-                    throw new ClassConstraintException(\"Abstract method '\" + Pass2Verifier.access$100((Node)obj) + \"' must not have the ACC_NATIVE modifier set.\");\n+                if (method.isNative()) {\n+                    throw new ClassConstraintException(\"Abstract method '\" + Pass2Verifier.access$100((Node)method) + \"' must not have the ACC_NATIVE modifier set.\");\n                 }\n-                if (obj.isPrivate()) {\n-                    throw new ClassConstraintException(\"Abstract method '\" + Pass2Verifier.access$100((Node)obj) + \"' must not have the ACC_PRIVATE modifier set.\");\n+                if (method.isPrivate()) {\n+                    throw new ClassConstraintException(\"Abstract method '\" + Pass2Verifier.access$100((Node)method) + \"' must not have the ACC_PRIVATE modifier set.\");\n                 }\n-                if (obj.isStatic()) {\n-                    throw new ClassConstraintException(\"Abstract method '\" + Pass2Verifier.access$100((Node)obj) + \"' must not have the ACC_STATIC modifier set.\");\n+                if (method.isStatic()) {\n+                    throw new ClassConstraintException(\"Abstract method '\" + Pass2Verifier.access$100((Node)method) + \"' must not have the ACC_STATIC modifier set.\");\n                 }\n-                if (obj.isStrictfp()) {\n-                    throw new ClassConstraintException(\"Abstract method '\" + Pass2Verifier.access$100((Node)obj) + \"' must not have the ACC_STRICT modifier set.\");\n+                if (method.isStrictfp()) {\n+                    throw new ClassConstraintException(\"Abstract method '\" + Pass2Verifier.access$100((Node)method) + \"' must not have the ACC_STRICT modifier set.\");\n                 }\n-                if (obj.isSynchronized()) {\n-                    throw new ClassConstraintException(\"Abstract method '\" + Pass2Verifier.access$100((Node)obj) + \"' must not have the ACC_SYNCHRONIZED modifier set.\");\n+                if (method.isSynchronized()) {\n+                    throw new ClassConstraintException(\"Abstract method '\" + Pass2Verifier.access$100((Node)method) + \"' must not have the ACC_SYNCHRONIZED modifier set.\");\n                 }\n             }\n-            if (name.equals(\"<init>\") && (obj.isStatic() || obj.isFinal() || obj.isSynchronized() || obj.isNative() || obj.isAbstract())) {\n-                throw new ClassConstraintException(\"Instance initialization method '\" + Pass2Verifier.access$100((Node)obj) + \"' must not have any of the ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT modifiers set.\");\n+            if (name.equals(\"<init>\") && (method.isStatic() || method.isFinal() || method.isSynchronized() || method.isNative() || method.isAbstract())) {\n+                throw new ClassConstraintException(\"Instance initialization method '\" + Pass2Verifier.access$100((Node)method) + \"' must not have any of the ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT modifiers set.\");\n             }\n         }\n         else if (!name.equals(\"<clinit>\")) {\n             if (this.jc.getMajor() >= 52) {\n-                if (!(obj.isPublic() ^ obj.isPrivate())) {\n-                    throw new ClassConstraintException(\"Interface method '\" + Pass2Verifier.access$100((Node)obj) + \"' must have exactly one of its ACC_PUBLIC and ACC_PRIVATE modifiers set.\");\n+                if (!(method.isPublic() ^ method.isPrivate())) {\n+                    throw new ClassConstraintException(\"Interface method '\" + Pass2Verifier.access$100((Node)method) + \"' must have exactly one of its ACC_PUBLIC and ACC_PRIVATE modifiers set.\");\n                 }\n-                if (obj.isProtected() || obj.isFinal() || obj.isSynchronized() || obj.isNative()) {\n-                    throw new ClassConstraintException(\"Interface method '\" + Pass2Verifier.access$100((Node)obj) + \"' must not have any of the ACC_PROTECTED, ACC_FINAL, ACC_SYNCHRONIZED, or ACC_NATIVE modifiers set.\");\n+                if (method.isProtected() || method.isFinal() || method.isSynchronized() || method.isNative()) {\n+                    throw new ClassConstraintException(\"Interface method '\" + Pass2Verifier.access$100((Node)method) + \"' must not have any of the ACC_PROTECTED, ACC_FINAL, ACC_SYNCHRONIZED, or ACC_NATIVE modifiers set.\");\n                 }\n             }\n             else {\n-                if (!obj.isPublic()) {\n-                    throw new ClassConstraintException(\"Interface method '\" + Pass2Verifier.access$100((Node)obj) + \"' must have the ACC_PUBLIC modifier set but hasn't!\");\n+                if (!method.isPublic()) {\n+                    throw new ClassConstraintException(\"Interface method '\" + Pass2Verifier.access$100((Node)method) + \"' must have the ACC_PUBLIC modifier set but hasn't!\");\n                 }\n-                if (!obj.isAbstract()) {\n-                    throw new ClassConstraintException(\"Interface method '\" + Pass2Verifier.access$100((Node)obj) + \"' must have the ACC_ABSTRACT modifier set but hasn't!\");\n+                if (!method.isAbstract()) {\n+                    throw new ClassConstraintException(\"Interface method '\" + Pass2Verifier.access$100((Node)method) + \"' must have the ACC_ABSTRACT modifier set but hasn't!\");\n                 }\n-                if (obj.isPrivate() || obj.isProtected() || obj.isStatic() || obj.isFinal() || obj.isSynchronized() || obj.isNative() || obj.isStrictfp()) {\n-                    throw new ClassConstraintException(\"Interface method '\" + Pass2Verifier.access$100((Node)obj) + \"' must not have any of the ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT, ACC_STRICT modifiers set.\");\n+                if (method.isPrivate() || method.isProtected() || method.isStatic() || method.isFinal() || method.isSynchronized() || method.isNative() || method.isStrictfp()) {\n+                    throw new ClassConstraintException(\"Interface method '\" + Pass2Verifier.access$100((Node)method) + \"' must not have any of the ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT, ACC_STRICT modifiers set.\");\n                 }\n             }\n         }\n-        if ((obj.getAccessFlags() & 0xFFFFF2C0) > 0) {\n-            this.this$0.addMessage(\"Method '\" + Pass2Verifier.access$100((Node)obj) + \"' has access flag(s) other than ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT, ACC_STRICT set (ignored).\");\n+        if ((method.getAccessFlags() & 0xFFFFF2C0) > 0) {\n+            this.this$0.addMessage(\"Method '\" + Pass2Verifier.access$100((Node)method) + \"' has access flag(s) other than ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT, ACC_STRICT set (ignored).\");\n         }\n-        final String nameanddesc = name + sig;\n-        if (this.method_names_and_desc.contains(nameanddesc)) {\n-            throw new ClassConstraintException(\"No two methods (like '\" + Pass2Verifier.access$100((Node)obj) + \"') are allowed have same names and desciptors!\");\n+        final String string = name + bytes;\n+        if (this.method_names_and_desc.contains(string)) {\n+            throw new ClassConstraintException(\"No two methods (like '\" + Pass2Verifier.access$100((Node)method) + \"') are allowed have same names and desciptors!\");\n         }\n-        this.method_names_and_desc.add(nameanddesc);\n-        final Attribute[] atts = obj.getAttributes();\n-        int num_code_atts = 0;\n-        for (final Attribute att : atts) {\n-            if (!(att instanceof Code) && !(att instanceof ExceptionTable) && !(att instanceof Synthetic) && !(att instanceof Deprecated)) {\n-                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$100((Node)att) + \"' as an attribute of Method '\" + Pass2Verifier.access$100((Node)obj) + \"' is unknown and will therefore be ignored.\");\n+        this.method_names_and_desc.add(string);\n+        final Attribute[] attributes = method.getAttributes();\n+        int j = 0;\n+        for (final Attribute attribute : attributes) {\n+            if (!(attribute instanceof Code) && !(attribute instanceof ExceptionTable) && !(attribute instanceof Synthetic) && !(attribute instanceof Deprecated)) {\n+                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$100((Node)attribute) + \"' as an attribute of Method '\" + Pass2Verifier.access$100((Node)method) + \"' is unknown and will therefore be ignored.\");\n             }\n-            if (!(att instanceof Code) && !(att instanceof ExceptionTable)) {\n-                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$100((Node)att) + \"' as an attribute of Method '\" + Pass2Verifier.access$100((Node)obj) + \"' is neither Code nor Exceptions and is therefore only of use for debuggers and such.\");\n+            if (!(attribute instanceof Code) && !(attribute instanceof ExceptionTable)) {\n+                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$100((Node)attribute) + \"' as an attribute of Method '\" + Pass2Verifier.access$100((Node)method) + \"' is neither Code nor Exceptions and is therefore only of use for debuggers and such.\");\n             }\n-            if (att instanceof Code && (obj.isNative() || obj.isAbstract())) {\n-                throw new ClassConstraintException(\"Native or abstract methods like '\" + Pass2Verifier.access$100((Node)obj) + \"' must not have a Code attribute like '\" + Pass2Verifier.access$100((Node)att) + \"'.\");\n+            if (attribute instanceof Code && (method.isNative() || method.isAbstract())) {\n+                throw new ClassConstraintException(\"Native or abstract methods like '\" + Pass2Verifier.access$100((Node)method) + \"' must not have a Code attribute like '\" + Pass2Verifier.access$100((Node)attribute) + \"'.\");\n             }\n-            if (att instanceof Code) {\n-                ++num_code_atts;\n+            if (attribute instanceof Code) {\n+                ++j;\n             }\n         }\n-        if (!obj.isNative() && !obj.isAbstract() && num_code_atts != 1) {\n-            throw new ClassConstraintException(\"Non-native, non-abstract methods like '\" + Pass2Verifier.access$100((Node)obj) + \"' must have exactly one Code attribute (found: \" + num_code_atts + \").\");\n+        if (!method.isNative() && !method.isAbstract() && j != 1) {\n+            throw new ClassConstraintException(\"Non-native, non-abstract methods like '\" + Pass2Verifier.access$100((Node)method) + \"' must have exactly one Code attribute (found: \" + j + \").\");\n         }\n     }\n     \n-    public void visitSourceFile(final SourceFile obj) {\n-        this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n-        final String name = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n-        if (!name.equals(\"SourceFile\")) {\n-            throw new ClassConstraintException(\"The SourceFile attribute '\" + Pass2Verifier.access$100((Node)obj) + \"' is not correctly named 'SourceFile' but '\" + name + \"'.\");\n+    public void visitSourceFile(final SourceFile sourceFile) {\n+        this.checkIndex((Node)sourceFile, sourceFile.getNameIndex(), this.CONST_Utf8);\n+        final String bytes = ((ConstantUtf8)this.cp.getConstant(sourceFile.getNameIndex())).getBytes();\n+        if (!bytes.equals(\"SourceFile\")) {\n+            throw new ClassConstraintException(\"The SourceFile attribute '\" + Pass2Verifier.access$100((Node)sourceFile) + \"' is not correctly named 'SourceFile' but '\" + bytes + \"'.\");\n         }\n-        this.checkIndex((Node)obj, obj.getSourceFileIndex(), this.CONST_Utf8);\n-        final String sourceFileName = ((ConstantUtf8)this.cp.getConstant(obj.getSourceFileIndex())).getBytes();\n-        final String sourceFileNameLc = sourceFileName.toLowerCase(Locale.ENGLISH);\n-        if (sourceFileName.indexOf(47) != -1 || sourceFileName.indexOf(92) != -1 || sourceFileName.indexOf(58) != -1 || sourceFileNameLc.lastIndexOf(\".java\") == -1) {\n-            this.this$0.addMessage(\"SourceFile attribute '\" + Pass2Verifier.access$100((Node)obj) + \"' has a funny name: remember not to confuse certain parsers working on javap's output. Also, this name ('\" + sourceFileName + \"') is considered an unqualified (simple) file name only.\");\n+        this.checkIndex((Node)sourceFile, sourceFile.getSourceFileIndex(), this.CONST_Utf8);\n+        final String bytes2 = ((ConstantUtf8)this.cp.getConstant(sourceFile.getSourceFileIndex())).getBytes();\n+        final String lowerCase = bytes2.toLowerCase(Locale.ENGLISH);\n+        if (bytes2.indexOf(47) != -1 || bytes2.indexOf(92) != -1 || bytes2.indexOf(58) != -1 || lowerCase.lastIndexOf(\".java\") == -1) {\n+            this.this$0.addMessage(\"SourceFile attribute '\" + Pass2Verifier.access$100((Node)sourceFile) + \"' has a funny name: remember not to confuse certain parsers working on javap's output. Also, this name ('\" + bytes2 + \"') is considered an unqualified (simple) file name only.\");\n         }\n     }\n     \n-    public void visitDeprecated(final Deprecated obj) {\n-        this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n-        final String name = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n-        if (!name.equals(\"Deprecated\")) {\n-            throw new ClassConstraintException(\"The Deprecated attribute '\" + Pass2Verifier.access$100((Node)obj) + \"' is not correctly named 'Deprecated' but '\" + name + \"'.\");\n+    public void visitDeprecated(final Deprecated deprecated) {\n+        this.checkIndex((Node)deprecated, deprecated.getNameIndex(), this.CONST_Utf8);\n+        final String bytes = ((ConstantUtf8)this.cp.getConstant(deprecated.getNameIndex())).getBytes();\n+        if (!bytes.equals(\"Deprecated\")) {\n+            throw new ClassConstraintException(\"The Deprecated attribute '\" + Pass2Verifier.access$100((Node)deprecated) + \"' is not correctly named 'Deprecated' but '\" + bytes + \"'.\");\n         }\n     }\n     \n-    public void visitSynthetic(final Synthetic obj) {\n-        this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n-        final String name = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n-        if (!name.equals(\"Synthetic\")) {\n-            throw new ClassConstraintException(\"The Synthetic attribute '\" + Pass2Verifier.access$100((Node)obj) + \"' is not correctly named 'Synthetic' but '\" + name + \"'.\");\n+    public void visitSynthetic(final Synthetic synthetic) {\n+        this.checkIndex((Node)synthetic, synthetic.getNameIndex(), this.CONST_Utf8);\n+        final String bytes = ((ConstantUtf8)this.cp.getConstant(synthetic.getNameIndex())).getBytes();\n+        if (!bytes.equals(\"Synthetic\")) {\n+            throw new ClassConstraintException(\"The Synthetic attribute '\" + Pass2Verifier.access$100((Node)synthetic) + \"' is not correctly named 'Synthetic' but '\" + bytes + \"'.\");\n         }\n     }\n     \n-    public void visitInnerClasses(final InnerClasses obj) {\n-        this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n-        final String name = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n-        if (!name.equals(\"InnerClasses\")) {\n-            throw new ClassConstraintException(\"The InnerClasses attribute '\" + Pass2Verifier.access$100((Node)obj) + \"' is not correctly named 'InnerClasses' but '\" + name + \"'.\");\n-        }\n-        final InnerClass[] innerClasses;\n-        final InnerClass[] ics = innerClasses = obj.getInnerClasses();\n-        for (final InnerClass ic : innerClasses) {\n-            this.checkIndex((Node)obj, ic.getInnerClassIndex(), this.CONST_Class);\n-            final int outer_idx = ic.getOuterClassIndex();\n-            if (outer_idx != 0) {\n-                this.checkIndex((Node)obj, outer_idx, this.CONST_Class);\n-            }\n-            final int innername_idx = ic.getInnerNameIndex();\n-            if (innername_idx != 0) {\n-                this.checkIndex((Node)obj, innername_idx, this.CONST_Utf8);\n-            }\n-            int acc = ic.getInnerAccessFlags();\n-            acc &= 0xFFFFF9E0;\n-            if (acc != 0) {\n-                this.this$0.addMessage(\"Unknown access flag for inner class '\" + Pass2Verifier.access$100((Node)ic) + \"' set (InnerClasses attribute '\" + Pass2Verifier.access$100((Node)obj) + \"').\");\n+    public void visitInnerClasses(final InnerClasses innerClasses) {\n+        this.checkIndex((Node)innerClasses, innerClasses.getNameIndex(), this.CONST_Utf8);\n+        final String bytes = ((ConstantUtf8)this.cp.getConstant(innerClasses.getNameIndex())).getBytes();\n+        if (!bytes.equals(\"InnerClasses\")) {\n+            throw new ClassConstraintException(\"The InnerClasses attribute '\" + Pass2Verifier.access$100((Node)innerClasses) + \"' is not correctly named 'InnerClasses' but '\" + bytes + \"'.\");\n+        }\n+        for (final InnerClass innerClass : innerClasses.getInnerClasses()) {\n+            this.checkIndex((Node)innerClasses, innerClass.getInnerClassIndex(), this.CONST_Class);\n+            final int outerClassIndex = innerClass.getOuterClassIndex();\n+            if (outerClassIndex != 0) {\n+                this.checkIndex((Node)innerClasses, outerClassIndex, this.CONST_Class);\n+            }\n+            final int innerNameIndex = innerClass.getInnerNameIndex();\n+            if (innerNameIndex != 0) {\n+                this.checkIndex((Node)innerClasses, innerNameIndex, this.CONST_Utf8);\n+            }\n+            if ((innerClass.getInnerAccessFlags() & 0xFFFFF9E0) != 0x0) {\n+                this.this$0.addMessage(\"Unknown access flag for inner class '\" + Pass2Verifier.access$100((Node)innerClass) + \"' set (InnerClasses attribute '\" + Pass2Verifier.access$100((Node)innerClasses) + \"').\");\n             }\n         }\n     }\n     \n     public void visitConstantValue(final ConstantValue obj) {\n         this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n-        final String name = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n-        if (!name.equals(\"ConstantValue\")) {\n-            throw new ClassConstraintException(\"The ConstantValue attribute '\" + Pass2Verifier.access$100((Node)obj) + \"' is not correctly named 'ConstantValue' but '\" + name + \"'.\");\n+        final String bytes = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n+        if (!bytes.equals(\"ConstantValue\")) {\n+            throw new ClassConstraintException(\"The ConstantValue attribute '\" + Pass2Verifier.access$100((Node)obj) + \"' is not correctly named 'ConstantValue' but '\" + bytes + \"'.\");\n         }\n-        final Object pred = this.carrier.predecessor();\n-        if (!(pred instanceof Field)) {\n+        final Object predecessor = this.carrier.predecessor();\n+        if (!(predecessor instanceof Field)) {\n             return;\n         }\n-        final Field f = (Field)pred;\n-        final Type field_type = Type.getType(((ConstantUtf8)this.cp.getConstant(f.getSignatureIndex())).getBytes());\n-        final int index = obj.getConstantValueIndex();\n-        if (index < 0 || index >= this.cplen) {\n-            throw new ClassConstraintException(\"Invalid index '\" + index + \"' used by '\" + Pass2Verifier.access$100((Node)obj) + \"'.\");\n+        final Field field = (Field)predecessor;\n+        final Type type = Type.getType(((ConstantUtf8)this.cp.getConstant(field.getSignatureIndex())).getBytes());\n+        final int constantValueIndex = obj.getConstantValueIndex();\n+        if (constantValueIndex < 0 || constantValueIndex >= this.cplen) {\n+            throw new ClassConstraintException(\"Invalid index '\" + constantValueIndex + \"' used by '\" + Pass2Verifier.access$100((Node)obj) + \"'.\");\n         }\n-        final Constant c = this.cp.getConstant(index);\n-        if (this.CONST_Long.isInstance(c) && field_type.equals((Object)Type.LONG)) {\n+        final Constant constant = this.cp.getConstant(constantValueIndex);\n+        if (this.CONST_Long.isInstance(constant) && type.equals((Object)Type.LONG)) {\n             return;\n         }\n-        if (this.CONST_Float.isInstance(c) && field_type.equals((Object)Type.FLOAT)) {\n+        if (this.CONST_Float.isInstance(constant) && type.equals((Object)Type.FLOAT)) {\n             return;\n         }\n-        if (this.CONST_Double.isInstance(c) && field_type.equals((Object)Type.DOUBLE)) {\n+        if (this.CONST_Double.isInstance(constant) && type.equals((Object)Type.DOUBLE)) {\n             return;\n         }\n-        if (this.CONST_Integer.isInstance(c) && (field_type.equals((Object)Type.INT) || field_type.equals((Object)Type.SHORT) || field_type.equals((Object)Type.CHAR) || field_type.equals((Object)Type.BYTE) || field_type.equals((Object)Type.BOOLEAN))) {\n+        if (this.CONST_Integer.isInstance(constant) && (type.equals((Object)Type.INT) || type.equals((Object)Type.SHORT) || type.equals((Object)Type.CHAR) || type.equals((Object)Type.BYTE) || type.equals((Object)Type.BOOLEAN))) {\n             return;\n         }\n-        if (this.CONST_String.isInstance(c) && field_type.equals((Object)Type.STRING)) {\n+        if (this.CONST_String.isInstance(constant) && type.equals((Object)Type.STRING)) {\n             return;\n         }\n-        throw new ClassConstraintException(\"Illegal type of ConstantValue '\" + obj + \"' embedding Constant '\" + c + \"'. It is referenced by field '\" + Pass2Verifier.access$100((Node)f) + \"' expecting a different type: '\" + field_type + \"'.\");\n+        throw new ClassConstraintException(\"Illegal type of ConstantValue '\" + obj + \"' embedding Constant '\" + constant + \"'. It is referenced by field '\" + Pass2Verifier.access$100((Node)field) + \"' expecting a different type: '\" + type + \"'.\");\n     }\n     \n-    public void visitCode(final Code obj) {\n+    public void visitCode(final Code code) {\n         try {\n-            this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n-            final String name = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n-            if (!name.equals(\"Code\")) {\n-                throw new ClassConstraintException(\"The Code attribute '\" + Pass2Verifier.access$100((Node)obj) + \"' is not correctly named 'Code' but '\" + name + \"'.\");\n+            this.checkIndex((Node)code, code.getNameIndex(), this.CONST_Utf8);\n+            final String bytes = ((ConstantUtf8)this.cp.getConstant(code.getNameIndex())).getBytes();\n+            if (!bytes.equals(\"Code\")) {\n+                throw new ClassConstraintException(\"The Code attribute '\" + Pass2Verifier.access$100((Node)code) + \"' is not correctly named 'Code' but '\" + bytes + \"'.\");\n             }\n-            Method m = null;\n             if (!(this.carrier.predecessor() instanceof Method)) {\n-                this.this$0.addMessage(\"Code attribute '\" + Pass2Verifier.access$100((Node)obj) + \"' is not declared in a method_info structure but in '\" + this.carrier.predecessor() + \"'. Ignored.\");\n+                this.this$0.addMessage(\"Code attribute '\" + Pass2Verifier.access$100((Node)code) + \"' is not declared in a method_info structure but in '\" + this.carrier.predecessor() + \"'. Ignored.\");\n                 return;\n             }\n-            m = (Method)this.carrier.predecessor();\n-            if (obj.getCode().length == 0) {\n-                throw new ClassConstraintException(\"Code array of Code attribute '\" + Pass2Verifier.access$100((Node)obj) + \"' (method '\" + m + \"') must not be empty.\");\n-            }\n-            final CodeException[] exceptionTable;\n-            final CodeException[] exc_table = exceptionTable = obj.getExceptionTable();\n-            for (final CodeException element : exceptionTable) {\n-                final int exc_index = element.getCatchType();\n-                if (exc_index != 0) {\n-                    this.checkIndex((Node)obj, exc_index, this.CONST_Class);\n-                    final ConstantClass cc = (ConstantClass)this.cp.getConstant(exc_index);\n-                    this.checkIndex((Node)cc, cc.getNameIndex(), this.CONST_Utf8);\n-                    final String cname = ((ConstantUtf8)this.cp.getConstant(cc.getNameIndex())).getBytes().replace('/', '.');\n-                    Verifier v = VerifierFactory.getVerifier(cname);\n-                    VerificationResult vr = v.doPass1();\n-                    if (vr != VerificationResult.VR_OK) {\n-                        throw new ClassConstraintException(\"Code attribute '\" + Pass2Verifier.access$100((Node)obj) + \"' (method '\" + m + \"') has an exception_table entry '\" + Pass2Verifier.access$100((Node)element) + \"' that references '\" + cname + \"' as an Exception but it does not pass verification pass 1: \" + vr);\n+            final Method method = (Method)this.carrier.predecessor();\n+            if (code.getCode().length == 0) {\n+                throw new ClassConstraintException(\"Code array of Code attribute '\" + Pass2Verifier.access$100((Node)code) + \"' (method '\" + method + \"') must not be empty.\");\n+            }\n+            for (final CodeException ex : code.getExceptionTable()) {\n+                final int catchType = ex.getCatchType();\n+                if (catchType != 0) {\n+                    this.checkIndex((Node)code, catchType, this.CONST_Class);\n+                    final ConstantClass constantClass = (ConstantClass)this.cp.getConstant(catchType);\n+                    this.checkIndex((Node)constantClass, constantClass.getNameIndex(), this.CONST_Utf8);\n+                    final String replace = ((ConstantUtf8)this.cp.getConstant(constantClass.getNameIndex())).getBytes().replace('/', '.');\n+                    final VerificationResult doPass1 = VerifierFactory.getVerifier(replace).doPass1();\n+                    if (doPass1 != VerificationResult.VR_OK) {\n+                        throw new ClassConstraintException(\"Code attribute '\" + Pass2Verifier.access$100((Node)code) + \"' (method '\" + method + \"') has an exception_table entry '\" + Pass2Verifier.access$100((Node)ex) + \"' that references '\" + replace + \"' as an Exception but it does not pass verification pass 1: \" + doPass1);\n                     }\n-                    JavaClass e = Repository.lookupClass(cname);\n-                    final JavaClass t = Repository.lookupClass(Type.THROWABLE.getClassName());\n-                    for (JavaClass o = Repository.lookupClass(Type.OBJECT.getClassName()); e != o && e != t; e = Repository.lookupClass(e.getSuperclassName())) {\n-                        v = VerifierFactory.getVerifier(e.getSuperclassName());\n-                        vr = v.doPass1();\n-                        if (vr != VerificationResult.VR_OK) {\n-                            throw new ClassConstraintException(\"Code attribute '\" + Pass2Verifier.access$100((Node)obj) + \"' (method '\" + m + \"') has an exception_table entry '\" + Pass2Verifier.access$100((Node)element) + \"' that references '\" + cname + \"' as an Exception but '\" + e.getSuperclassName() + \"' in the ancestor hierachy does not pass verification pass 1: \" + vr);\n+                    JavaClass javaClass;\n+                    JavaClass lookupClass;\n+                    for (javaClass = Repository.lookupClass(replace), lookupClass = Repository.lookupClass(Type.THROWABLE.getClassName()); javaClass != Repository.lookupClass(Type.OBJECT.getClassName()) && javaClass != lookupClass; javaClass = Repository.lookupClass(javaClass.getSuperclassName())) {\n+                        final VerificationResult doPass2 = VerifierFactory.getVerifier(javaClass.getSuperclassName()).doPass1();\n+                        if (doPass2 != VerificationResult.VR_OK) {\n+                            throw new ClassConstraintException(\"Code attribute '\" + Pass2Verifier.access$100((Node)code) + \"' (method '\" + method + \"') has an exception_table entry '\" + Pass2Verifier.access$100((Node)ex) + \"' that references '\" + replace + \"' as an Exception but '\" + javaClass.getSuperclassName() + \"' in the ancestor hierachy does not pass verification pass 1: \" + doPass2);\n                         }\n                     }\n-                    if (e != t) {\n-                        throw new ClassConstraintException(\"Code attribute '\" + Pass2Verifier.access$100((Node)obj) + \"' (method '\" + m + \"') has an exception_table entry '\" + Pass2Verifier.access$100((Node)element) + \"' that references '\" + cname + \"' as an Exception but it is not a subclass of '\" + t.getClassName() + \"'.\");\n+                    if (javaClass != lookupClass) {\n+                        throw new ClassConstraintException(\"Code attribute '\" + Pass2Verifier.access$100((Node)code) + \"' (method '\" + method + \"') has an exception_table entry '\" + Pass2Verifier.access$100((Node)ex) + \"' that references '\" + replace + \"' as an Exception but it is not a subclass of '\" + lookupClass.getClassName() + \"'.\");\n                     }\n                 }\n             }\n-            int method_number = -1;\n-            final Method[] ms = Repository.lookupClass(Pass2Verifier.access$400(this.this$0).getClassName()).getMethods();\n-            for (int mn = 0; mn < ms.length; ++mn) {\n-                if (m == ms[mn]) {\n-                    method_number = mn;\n+            int n = -1;\n+            final Method[] methods = Repository.lookupClass(Pass2Verifier.access$400(this.this$0).getClassName()).getMethods();\n+            for (int j = 0; j < methods.length; ++j) {\n+                if (method == methods[j]) {\n+                    n = j;\n                     break;\n                 }\n             }\n-            if (method_number < 0) {\n+            if (n < 0) {\n                 throw new AssertionViolatedException(\"Could not find a known BCEL Method object in the corresponding BCEL JavaClass object.\");\n             }\n-            Pass2Verifier.access$500(this.this$0)[method_number] = new LocalVariablesInfo(obj.getMaxLocals());\n-            int num_of_lvt_attribs = 0;\n-            final Attribute[] atts = obj.getAttributes();\n-            for (int a = 0; a < atts.length; ++a) {\n-                if (!(atts[a] instanceof LineNumberTable) && !(atts[a] instanceof LocalVariableTable)) {\n-                    this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$100((Node)atts[a]) + \"' as an attribute of Code attribute '\" + Pass2Verifier.access$100((Node)obj) + \"' (method '\" + m + \"') is unknown and will therefore be ignored.\");\n+            Pass2Verifier.access$500(this.this$0)[n] = new LocalVariablesInfo(code.getMaxLocals());\n+            int n2 = 0;\n+            final Attribute[] attributes = code.getAttributes();\n+            for (int k = 0; k < attributes.length; ++k) {\n+                if (!(attributes[k] instanceof LineNumberTable) && !(attributes[k] instanceof LocalVariableTable)) {\n+                    this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$100((Node)attributes[k]) + \"' as an attribute of Code attribute '\" + Pass2Verifier.access$100((Node)code) + \"' (method '\" + method + \"') is unknown and will therefore be ignored.\");\n                 }\n                 else {\n-                    this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$100((Node)atts[a]) + \"' as an attribute of Code attribute '\" + Pass2Verifier.access$100((Node)obj) + \"' (method '\" + m + \"') will effectively be ignored and is only useful for debuggers and such.\");\n+                    this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$100((Node)attributes[k]) + \"' as an attribute of Code attribute '\" + Pass2Verifier.access$100((Node)code) + \"' (method '\" + method + \"') will effectively be ignored and is only useful for debuggers and such.\");\n                 }\n-                if (atts[a] instanceof LocalVariableTable) {\n-                    final LocalVariableTable lvt = (LocalVariableTable)atts[a];\n-                    this.checkIndex((Node)lvt, lvt.getNameIndex(), this.CONST_Utf8);\n-                    final String lvtname = ((ConstantUtf8)this.cp.getConstant(lvt.getNameIndex())).getBytes();\n-                    if (!lvtname.equals(\"LocalVariableTable\")) {\n-                        throw new ClassConstraintException(\"The LocalVariableTable attribute '\" + Pass2Verifier.access$100((Node)lvt) + \"' is not correctly named 'LocalVariableTable' but '\" + lvtname + \"'.\");\n+                if (attributes[k] instanceof LocalVariableTable) {\n+                    final LocalVariableTable localVariableTable = (LocalVariableTable)attributes[k];\n+                    this.checkIndex((Node)localVariableTable, localVariableTable.getNameIndex(), this.CONST_Utf8);\n+                    final String bytes2 = ((ConstantUtf8)this.cp.getConstant(localVariableTable.getNameIndex())).getBytes();\n+                    if (!bytes2.equals(\"LocalVariableTable\")) {\n+                        throw new ClassConstraintException(\"The LocalVariableTable attribute '\" + Pass2Verifier.access$100((Node)localVariableTable) + \"' is not correctly named 'LocalVariableTable' but '\" + bytes2 + \"'.\");\n                     }\n-                    final Code code = obj;\n-                    final LocalVariable[] localVariableTable;\n-                    final LocalVariable[] localvariables = localVariableTable = lvt.getLocalVariableTable();\n-                    for (final LocalVariable localvariable : localVariableTable) {\n-                        this.checkIndex((Node)lvt, localvariable.getNameIndex(), this.CONST_Utf8);\n-                        final String localname = ((ConstantUtf8)this.cp.getConstant(localvariable.getNameIndex())).getBytes();\n-                        if (!Pass2Verifier.access$600(localname)) {\n-                            throw new ClassConstraintException(\"LocalVariableTable '\" + Pass2Verifier.access$100((Node)lvt) + \"' references a local variable by the name '\" + localname + \"' which is not a legal Java simple name.\");\n+                    for (final LocalVariable localVariable : localVariableTable.getLocalVariableTable()) {\n+                        this.checkIndex((Node)localVariableTable, localVariable.getNameIndex(), this.CONST_Utf8);\n+                        final String bytes3 = ((ConstantUtf8)this.cp.getConstant(localVariable.getNameIndex())).getBytes();\n+                        if (!Pass2Verifier.access$600(bytes3)) {\n+                            throw new ClassConstraintException(\"LocalVariableTable '\" + Pass2Verifier.access$100((Node)localVariableTable) + \"' references a local variable by the name '\" + bytes3 + \"' which is not a legal Java simple name.\");\n                         }\n-                        this.checkIndex((Node)lvt, localvariable.getSignatureIndex(), this.CONST_Utf8);\n-                        final String localsig = ((ConstantUtf8)this.cp.getConstant(localvariable.getSignatureIndex())).getBytes();\n-                        Type t2;\n+                        this.checkIndex((Node)localVariableTable, localVariable.getSignatureIndex(), this.CONST_Utf8);\n+                        final String bytes4 = ((ConstantUtf8)this.cp.getConstant(localVariable.getSignatureIndex())).getBytes();\n+                        Type type;\n                         try {\n-                            t2 = Type.getType(localsig);\n+                            type = Type.getType(bytes4);\n                         }\n-                        catch (final ClassFormatException cfe) {\n-                            throw new ClassConstraintException(\"Illegal descriptor (==signature) '\" + localsig + \"' used by LocalVariable '\" + Pass2Verifier.access$100((Node)localvariable) + \"' referenced by '\" + Pass2Verifier.access$100((Node)lvt) + \"'.\", (Throwable)cfe);\n+                        catch (final ClassFormatException ex2) {\n+                            throw new ClassConstraintException(\"Illegal descriptor (==signature) '\" + bytes4 + \"' used by LocalVariable '\" + Pass2Verifier.access$100((Node)localVariable) + \"' referenced by '\" + Pass2Verifier.access$100((Node)localVariableTable) + \"'.\", (Throwable)ex2);\n                         }\n-                        final int localindex = localvariable.getIndex();\n-                        if (((t2 == Type.LONG || t2 == Type.DOUBLE) ? (localindex + 1) : localindex) >= code.getMaxLocals()) {\n-                            throw new ClassConstraintException(\"LocalVariableTable attribute '\" + Pass2Verifier.access$100((Node)lvt) + \"' references a LocalVariable '\" + Pass2Verifier.access$100((Node)localvariable) + \"' with an index that exceeds the surrounding Code attribute's max_locals value of '\" + code.getMaxLocals() + \"'.\");\n+                        final int index = localVariable.getIndex();\n+                        if (((type == Type.LONG || type == Type.DOUBLE) ? (index + 1) : index) >= code.getMaxLocals()) {\n+                            throw new ClassConstraintException(\"LocalVariableTable attribute '\" + Pass2Verifier.access$100((Node)localVariableTable) + \"' references a LocalVariable '\" + Pass2Verifier.access$100((Node)localVariable) + \"' with an index that exceeds the surrounding Code attribute's max_locals value of '\" + code.getMaxLocals() + \"'.\");\n                         }\n                         try {\n-                            Pass2Verifier.access$500(this.this$0)[method_number].add(localindex, localname, localvariable.getStartPC(), localvariable.getLength(), t2);\n+                            Pass2Verifier.access$500(this.this$0)[n].add(index, bytes3, localVariable.getStartPC(), localVariable.getLength(), type);\n                         }\n-                        catch (final LocalVariableInfoInconsistentException lviie) {\n-                            throw new ClassConstraintException(\"Conflicting information in LocalVariableTable '\" + Pass2Verifier.access$100((Node)lvt) + \"' found in Code attribute '\" + Pass2Verifier.access$100((Node)obj) + \"' (method '\" + Pass2Verifier.access$100((Node)m) + \"'). \" + lviie.getMessage(), (Throwable)lviie);\n+                        catch (final LocalVariableInfoInconsistentException ex3) {\n+                            throw new ClassConstraintException(\"Conflicting information in LocalVariableTable '\" + Pass2Verifier.access$100((Node)localVariableTable) + \"' found in Code attribute '\" + Pass2Verifier.access$100((Node)code) + \"' (method '\" + Pass2Verifier.access$100((Node)method) + \"'). \" + ex3.getMessage(), (Throwable)ex3);\n                         }\n                     }\n-                    ++num_of_lvt_attribs;\n-                    if (!m.isStatic() && num_of_lvt_attribs > obj.getMaxLocals()) {\n-                        throw new ClassConstraintException(\"Number of LocalVariableTable attributes of Code attribute '\" + Pass2Verifier.access$100((Node)obj) + \"' (method '\" + Pass2Verifier.access$100((Node)m) + \"') exceeds number of local variable slots '\" + obj.getMaxLocals() + \"' ('There may be at most one LocalVariableTable attribute per local variable in the Code attribute.').\");\n+                    ++n2;\n+                    if (!method.isStatic() && n2 > code.getMaxLocals()) {\n+                        throw new ClassConstraintException(\"Number of LocalVariableTable attributes of Code attribute '\" + Pass2Verifier.access$100((Node)code) + \"' (method '\" + Pass2Verifier.access$100((Node)method) + \"') exceeds number of local variable slots '\" + code.getMaxLocals() + \"' ('There may be at most one LocalVariableTable attribute per local variable in the Code attribute.').\");\n                     }\n                 }\n             }\n         }\n-        catch (final ClassNotFoundException e2) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e2, (Throwable)e2);\n+        catch (final ClassNotFoundException obj) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj, (Throwable)obj);\n         }\n     }\n     \n-    public void visitExceptionTable(final ExceptionTable obj) {\n+    public void visitExceptionTable(final ExceptionTable exceptionTable) {\n         try {\n-            this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n-            final String name = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n-            if (!name.equals(\"Exceptions\")) {\n-                throw new ClassConstraintException(\"The Exceptions attribute '\" + Pass2Verifier.access$100((Node)obj) + \"' is not correctly named 'Exceptions' but '\" + name + \"'.\");\n-            }\n-            final int[] exceptionIndexTable;\n-            final int[] exc_indices = exceptionIndexTable = obj.getExceptionIndexTable();\n-            for (final int exc_indice : exceptionIndexTable) {\n-                this.checkIndex((Node)obj, exc_indice, this.CONST_Class);\n-                final ConstantClass cc = (ConstantClass)this.cp.getConstant(exc_indice);\n-                this.checkIndex((Node)cc, cc.getNameIndex(), this.CONST_Utf8);\n-                final String cname = ((ConstantUtf8)this.cp.getConstant(cc.getNameIndex())).getBytes().replace('/', '.');\n-                Verifier v = VerifierFactory.getVerifier(cname);\n-                VerificationResult vr = v.doPass1();\n-                if (vr != VerificationResult.VR_OK) {\n-                    throw new ClassConstraintException(\"Exceptions attribute '\" + Pass2Verifier.access$100((Node)obj) + \"' references '\" + cname + \"' as an Exception but it does not pass verification pass 1: \" + vr);\n-                }\n-                JavaClass e = Repository.lookupClass(cname);\n-                final JavaClass t = Repository.lookupClass(Type.THROWABLE.getClassName());\n-                for (JavaClass o = Repository.lookupClass(Type.OBJECT.getClassName()); e != o && e != t; e = Repository.lookupClass(e.getSuperclassName())) {\n-                    v = VerifierFactory.getVerifier(e.getSuperclassName());\n-                    vr = v.doPass1();\n-                    if (vr != VerificationResult.VR_OK) {\n-                        throw new ClassConstraintException(\"Exceptions attribute '\" + Pass2Verifier.access$100((Node)obj) + \"' references '\" + cname + \"' as an Exception but '\" + e.getSuperclassName() + \"' in the ancestor hierachy does not pass verification pass 1: \" + vr);\n+            this.checkIndex((Node)exceptionTable, exceptionTable.getNameIndex(), this.CONST_Utf8);\n+            final String bytes = ((ConstantUtf8)this.cp.getConstant(exceptionTable.getNameIndex())).getBytes();\n+            if (!bytes.equals(\"Exceptions\")) {\n+                throw new ClassConstraintException(\"The Exceptions attribute '\" + Pass2Verifier.access$100((Node)exceptionTable) + \"' is not correctly named 'Exceptions' but '\" + bytes + \"'.\");\n+            }\n+            for (final int n : exceptionTable.getExceptionIndexTable()) {\n+                this.checkIndex((Node)exceptionTable, n, this.CONST_Class);\n+                final ConstantClass constantClass = (ConstantClass)this.cp.getConstant(n);\n+                this.checkIndex((Node)constantClass, constantClass.getNameIndex(), this.CONST_Utf8);\n+                final String replace = ((ConstantUtf8)this.cp.getConstant(constantClass.getNameIndex())).getBytes().replace('/', '.');\n+                final VerificationResult doPass1 = VerifierFactory.getVerifier(replace).doPass1();\n+                if (doPass1 != VerificationResult.VR_OK) {\n+                    throw new ClassConstraintException(\"Exceptions attribute '\" + Pass2Verifier.access$100((Node)exceptionTable) + \"' references '\" + replace + \"' as an Exception but it does not pass verification pass 1: \" + doPass1);\n+                }\n+                JavaClass javaClass;\n+                JavaClass lookupClass;\n+                for (javaClass = Repository.lookupClass(replace), lookupClass = Repository.lookupClass(Type.THROWABLE.getClassName()); javaClass != Repository.lookupClass(Type.OBJECT.getClassName()) && javaClass != lookupClass; javaClass = Repository.lookupClass(javaClass.getSuperclassName())) {\n+                    final VerificationResult doPass2 = VerifierFactory.getVerifier(javaClass.getSuperclassName()).doPass1();\n+                    if (doPass2 != VerificationResult.VR_OK) {\n+                        throw new ClassConstraintException(\"Exceptions attribute '\" + Pass2Verifier.access$100((Node)exceptionTable) + \"' references '\" + replace + \"' as an Exception but '\" + javaClass.getSuperclassName() + \"' in the ancestor hierachy does not pass verification pass 1: \" + doPass2);\n                     }\n                 }\n-                if (e != t) {\n-                    throw new ClassConstraintException(\"Exceptions attribute '\" + Pass2Verifier.access$100((Node)obj) + \"' references '\" + cname + \"' as an Exception but it is not a subclass of '\" + t.getClassName() + \"'.\");\n+                if (javaClass != lookupClass) {\n+                    throw new ClassConstraintException(\"Exceptions attribute '\" + Pass2Verifier.access$100((Node)exceptionTable) + \"' references '\" + replace + \"' as an Exception but it is not a subclass of '\" + lookupClass.getClassName() + \"'.\");\n                 }\n             }\n         }\n-        catch (final ClassNotFoundException e2) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e2, (Throwable)e2);\n+        catch (final ClassNotFoundException obj) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj, (Throwable)obj);\n         }\n     }\n     \n-    public void visitLineNumberTable(final LineNumberTable obj) {\n-        this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n-        final String name = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n-        if (!name.equals(\"LineNumberTable\")) {\n-            throw new ClassConstraintException(\"The LineNumberTable attribute '\" + Pass2Verifier.access$100((Node)obj) + \"' is not correctly named 'LineNumberTable' but '\" + name + \"'.\");\n+    public void visitLineNumberTable(final LineNumberTable lineNumberTable) {\n+        this.checkIndex((Node)lineNumberTable, lineNumberTable.getNameIndex(), this.CONST_Utf8);\n+        final String bytes = ((ConstantUtf8)this.cp.getConstant(lineNumberTable.getNameIndex())).getBytes();\n+        if (!bytes.equals(\"LineNumberTable\")) {\n+            throw new ClassConstraintException(\"The LineNumberTable attribute '\" + Pass2Verifier.access$100((Node)lineNumberTable) + \"' is not correctly named 'LineNumberTable' but '\" + bytes + \"'.\");\n         }\n     }\n     \n-    public void visitLocalVariableTable(final LocalVariableTable obj) {\n+    public void visitLocalVariableTable(final LocalVariableTable localVariableTable) {\n     }\n     \n-    public void visitUnknown(final Unknown obj) {\n-        this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n-        this.this$0.addMessage(\"Unknown attribute '\" + Pass2Verifier.access$100((Node)obj) + \"'. This attribute is not known in any context!\");\n+    public void visitUnknown(final Unknown unknown) {\n+        this.checkIndex((Node)unknown, unknown.getNameIndex(), this.CONST_Utf8);\n+        this.this$0.addMessage(\"Unknown attribute '\" + Pass2Verifier.access$100((Node)unknown) + \"'. This attribute is not known in any context!\");\n     }\n     \n-    public void visitLocalVariable(final LocalVariable obj) {\n+    public void visitLocalVariable(final LocalVariable localVariable) {\n     }\n     \n-    public void visitCodeException(final CodeException obj) {\n+    public void visitCodeException(final CodeException ex) {\n     }\n     \n-    public void visitConstantPool(final ConstantPool obj) {\n+    public void visitConstantPool(final ConstantPool constantPool) {\n     }\n     \n-    public void visitInnerClass(final InnerClass obj) {\n+    public void visitInnerClass(final InnerClass innerClass) {\n     }\n     \n-    public void visitLineNumber(final LineNumber obj) {\n+    public void visitLineNumber(final LineNumber lineNumber) {\n     }\n }\n"}]}
