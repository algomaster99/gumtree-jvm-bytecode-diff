{"diffoscope-json-version": 1, "source1": "first/InMemoryNodeModel.class", "source2": "second/InMemoryNodeModel.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,16 +1,16 @@\n \n package org.apache.commons.configuration2.tree;\n \n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.Iterator;\n import org.apache.commons.configuration2.ex.ConfigurationRuntimeException;\n-import org.apache.commons.lang3.mutable.Mutable;\n import java.util.Collections;\n+import org.apache.commons.lang3.mutable.Mutable;\n import org.apache.commons.lang3.mutable.MutableObject;\n import java.util.Map;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Collection;\n import java.util.concurrent.atomic.AtomicReference;\n \n@@ -19,475 +19,449 @@\n     private static final NodeHandler<ImmutableNode> DUMMY_HANDLER;\n     private final AtomicReference<TreeData> structure;\n     \n     public InMemoryNodeModel() {\n         this(null);\n     }\n     \n-    public InMemoryNodeModel(final ImmutableNode root) {\n-        this.structure = new AtomicReference<TreeData>(this.createTreeData(initialRootNode(root), null));\n+    public InMemoryNodeModel(final ImmutableNode immutableNode) {\n+        this.structure = new AtomicReference<TreeData>(this.createTreeData(initialRootNode(immutableNode), null));\n     }\n     \n     public ImmutableNode getRootNode() {\n         return this.getTreeData().getRootNode();\n     }\n     \n     public NodeHandler<ImmutableNode> getNodeHandler() {\n         return (NodeHandler<ImmutableNode>)this.getReferenceNodeHandler();\n     }\n     \n-    public void addProperty(final String key, final Iterable<?> values, final NodeKeyResolver<ImmutableNode> resolver) {\n-        this.addProperty(key, null, values, resolver);\n+    public void addProperty(final String s, final Iterable<?> iterable, final NodeKeyResolver<ImmutableNode> nodeKeyResolver) {\n+        this.addProperty(s, null, iterable, nodeKeyResolver);\n     }\n     \n-    public void addProperty(final String key, final NodeSelector selector, final Iterable<?> values, final NodeKeyResolver<ImmutableNode> resolver) {\n-        if (valuesNotEmpty(values)) {\n-            this.updateModel(tx -> {\n-                this.initializeAddTransaction(tx, key, values, resolver);\n+    public void addProperty(final String s, final NodeSelector nodeSelector, final Iterable<?> iterable, final NodeKeyResolver<ImmutableNode> nodeKeyResolver) {\n+        if (valuesNotEmpty(iterable)) {\n+            this.updateModel(modelTransaction -> {\n+                this.initializeAddTransaction(modelTransaction, s, iterable, nodeKeyResolver);\n                 return true;\n-            }, selector, resolver);\n+            }, nodeSelector, nodeKeyResolver);\n         }\n     }\n     \n-    public void addNodes(final String key, final Collection<? extends ImmutableNode> nodes, final NodeKeyResolver<ImmutableNode> resolver) {\n-        this.addNodes(key, null, nodes, resolver);\n+    public void addNodes(final String s, final Collection<? extends ImmutableNode> collection, final NodeKeyResolver<ImmutableNode> nodeKeyResolver) {\n+        this.addNodes(s, null, collection, nodeKeyResolver);\n     }\n     \n-    public void addNodes(final String key, final NodeSelector selector, final Collection<? extends ImmutableNode> nodes, final NodeKeyResolver<ImmutableNode> resolver) {\n-        if (nodes != null && !nodes.isEmpty()) {\n-            this.updateModel(tx -> {\n-                final List<QueryResult<ImmutableNode>> results = resolver.resolveKey((Object)tx.getQueryRoot(), key, (NodeHandler)tx.getCurrentData());\n-                if (results.size() == 1) {\n-                    if (((QueryResult)results.get(0)).isAttributeResult()) {\n-                        throw attributeKeyException(key);\n+    public void addNodes(final String s, final NodeSelector nodeSelector, final Collection<? extends ImmutableNode> collection, final NodeKeyResolver<ImmutableNode> nodeKeyResolver) {\n+        if (collection != null && !collection.isEmpty()) {\n+            this.updateModel(modelTransaction -> {\n+                final List resolveKey = nodeKeyResolver.resolveKey((Object)modelTransaction.getQueryRoot(), s, (NodeHandler)modelTransaction.getCurrentData());\n+                if (resolveKey.size() == 1) {\n+                    if (((QueryResult)resolveKey.get(0)).isAttributeResult()) {\n+                        throw attributeKeyException(s);\n                     }\n-                    tx.addAddNodesOperation((ImmutableNode)((QueryResult)results.get(0)).getNode(), nodes);\n+                    modelTransaction.addAddNodesOperation((ImmutableNode)((QueryResult)resolveKey.get(0)).getNode(), collection);\n                 }\n                 else {\n-                    final NodeAddData<ImmutableNode> addData = (NodeAddData<ImmutableNode>)resolver.resolveAddKey((Object)tx.getQueryRoot(), key, (NodeHandler)tx.getCurrentData());\n-                    if (addData.isAttribute()) {\n-                        throw attributeKeyException(key);\n+                    final NodeAddData resolveAddKey = nodeKeyResolver.resolveAddKey((Object)modelTransaction.getQueryRoot(), s, (NodeHandler)modelTransaction.getCurrentData());\n+                    if (resolveAddKey.isAttribute()) {\n+                        throw attributeKeyException(s);\n                     }\n-                    final ImmutableNode newNode = new ImmutableNode.Builder(nodes.size()).name(addData.getNewNodeName()).addChildren(nodes).create();\n-                    addNodesByAddData(tx, addData, Collections.singleton(newNode));\n+                    addNodesByAddData(modelTransaction, resolveAddKey, (Collection<ImmutableNode>)Collections.singleton(new ImmutableNode.Builder(collection.size()).name(resolveAddKey.getNewNodeName()).addChildren(collection).create()));\n                 }\n                 return true;\n-            }, selector, resolver);\n+            }, nodeSelector, nodeKeyResolver);\n         }\n     }\n     \n-    public void setProperty(final String key, final Object value, final NodeKeyResolver<ImmutableNode> resolver) {\n-        this.setProperty(key, null, value, resolver);\n+    public void setProperty(final String s, final Object o, final NodeKeyResolver<ImmutableNode> nodeKeyResolver) {\n+        this.setProperty(s, null, o, nodeKeyResolver);\n     }\n     \n-    public void setProperty(final String key, final NodeSelector selector, final Object value, final NodeKeyResolver<ImmutableNode> resolver) {\n-        this.updateModel(tx -> {\n-            boolean added = false;\n-            final NodeUpdateData<ImmutableNode> updateData = (NodeUpdateData<ImmutableNode>)resolver.resolveUpdateKey((Object)tx.getQueryRoot(), key, value, (NodeHandler)tx.getCurrentData());\n-            if (!updateData.getNewValues().isEmpty()) {\n-                this.initializeAddTransaction(tx, key, updateData.getNewValues(), resolver);\n-                added = true;\n+    public void setProperty(final String s, final NodeSelector nodeSelector, final Object o, final NodeKeyResolver<ImmutableNode> nodeKeyResolver) {\n+        this.updateModel(modelTransaction -> {\n+            boolean b = false;\n+            final NodeUpdateData resolveUpdateKey = nodeKeyResolver.resolveUpdateKey((Object)modelTransaction.getQueryRoot(), s, o, (NodeHandler)modelTransaction.getCurrentData());\n+            if (!resolveUpdateKey.getNewValues().isEmpty()) {\n+                this.initializeAddTransaction(modelTransaction, s, resolveUpdateKey.getNewValues(), nodeKeyResolver);\n+                b = true;\n             }\n-            final boolean cleared = initializeClearTransaction(tx, updateData.getRemovedNodes());\n-            final boolean updated = initializeUpdateTransaction(tx, updateData.getChangedValues());\n-            return added || cleared || updated;\n-        }, selector, resolver);\n+            final boolean initializeClearTransaction = initializeClearTransaction(modelTransaction, resolveUpdateKey.getRemovedNodes());\n+            final boolean initializeUpdateTransaction = initializeUpdateTransaction(modelTransaction, resolveUpdateKey.getChangedValues());\n+            return b || initializeClearTransaction || initializeUpdateTransaction;\n+        }, nodeSelector, nodeKeyResolver);\n     }\n     \n-    public List<QueryResult<ImmutableNode>> clearTree(final String key, final NodeKeyResolver<ImmutableNode> resolver) {\n-        return this.clearTree(key, null, resolver);\n+    public List<QueryResult<ImmutableNode>> clearTree(final String s, final NodeKeyResolver<ImmutableNode> nodeKeyResolver) {\n+        return this.clearTree(s, null, nodeKeyResolver);\n     }\n     \n-    public List<QueryResult<ImmutableNode>> clearTree(final String key, final NodeSelector selector, final NodeKeyResolver<ImmutableNode> resolver) {\n-        final List<QueryResult<ImmutableNode>> removedElements = new LinkedList<QueryResult<ImmutableNode>>();\n-        this.updateModel(tx -> {\n-            boolean changes = false;\n-            final TreeData currentStructure = tx.getCurrentData();\n-            final List<QueryResult<ImmutableNode>> results = resolver.resolveKey((Object)tx.getQueryRoot(), key, (NodeHandler)currentStructure);\n-            removedElements.clear();\n-            removedElements.addAll(results);\n-            for (final QueryResult<ImmutableNode> result : results) {\n-                if (result.isAttributeResult()) {\n-                    tx.addRemoveAttributeOperation((ImmutableNode)result.getNode(), result.getAttributeName());\n+    public List<QueryResult<ImmutableNode>> clearTree(final String s, final NodeSelector nodeSelector, final NodeKeyResolver<ImmutableNode> nodeKeyResolver) {\n+        final LinkedList list = new LinkedList();\n+        this.updateModel(modelTransaction -> {\n+            boolean b = false;\n+            final TreeData currentData = modelTransaction.getCurrentData();\n+            final List resolveKey = nodeKeyResolver.resolveKey((Object)modelTransaction.getQueryRoot(), s, (NodeHandler)currentData);\n+            list.clear();\n+            list.addAll(resolveKey);\n+            for (final QueryResult queryResult : resolveKey) {\n+                if (queryResult.isAttributeResult()) {\n+                    modelTransaction.addRemoveAttributeOperation((ImmutableNode)queryResult.getNode(), queryResult.getAttributeName());\n                 }\n                 else {\n-                    if (result.getNode() == currentStructure.getRootNode()) {\n-                        this.clear(resolver);\n+                    if (queryResult.getNode() == currentData.getRootNode()) {\n+                        this.clear(nodeKeyResolver);\n                         return false;\n                     }\n-                    tx.addRemoveNodeOperation(currentStructure.getParent((ImmutableNode)result.getNode()), (ImmutableNode)result.getNode());\n+                    modelTransaction.addRemoveNodeOperation(currentData.getParent((ImmutableNode)queryResult.getNode()), (ImmutableNode)queryResult.getNode());\n                 }\n-                changes = true;\n+                b = true;\n             }\n-            return changes;\n-        }, selector, resolver);\n-        return removedElements;\n+            return b;\n+        }, nodeSelector, nodeKeyResolver);\n+        return list;\n     }\n     \n-    public void clearProperty(final String key, final NodeKeyResolver<ImmutableNode> resolver) {\n-        this.clearProperty(key, null, resolver);\n+    public void clearProperty(final String s, final NodeKeyResolver<ImmutableNode> nodeKeyResolver) {\n+        this.clearProperty(s, null, nodeKeyResolver);\n     }\n     \n-    public void clearProperty(final String key, final NodeSelector selector, final NodeKeyResolver<ImmutableNode> resolver) {\n-        this.updateModel(tx -> {\n-            final List<QueryResult<ImmutableNode>> results = resolver.resolveKey((Object)tx.getQueryRoot(), key, (NodeHandler)tx.getCurrentData());\n-            return initializeClearTransaction(tx, results);\n-        }, selector, resolver);\n+    public void clearProperty(final String s, final NodeSelector nodeSelector, final NodeKeyResolver<ImmutableNode> nodeKeyResolver) {\n+        this.updateModel(modelTransaction -> initializeClearTransaction(modelTransaction, nodeKeyResolver.resolveKey((Object)modelTransaction.getQueryRoot(), s, (NodeHandler)modelTransaction.getCurrentData())), nodeSelector, nodeKeyResolver);\n     }\n     \n-    public void clear(final NodeKeyResolver<ImmutableNode> resolver) {\n-        final ImmutableNode newRoot = new ImmutableNode.Builder().name(this.getRootNode().getNodeName()).create();\n-        this.setRootNode(newRoot);\n+    public void clear(final NodeKeyResolver<ImmutableNode> nodeKeyResolver) {\n+        this.setRootNode(new ImmutableNode.Builder().name(this.getRootNode().getNodeName()).create());\n     }\n     \n     public ImmutableNode getInMemoryRepresentation() {\n         return this.getTreeData().getRootNode();\n     }\n     \n-    public void setRootNode(final ImmutableNode newRoot) {\n-        this.structure.set(this.createTreeData(initialRootNode(newRoot), (TreeData)this.structure.get()));\n+    public void setRootNode(final ImmutableNode immutableNode) {\n+        this.structure.set(this.createTreeData(initialRootNode(immutableNode), (TreeData)this.structure.get()));\n     }\n     \n-    public void replaceRoot(final ImmutableNode newRoot, final NodeKeyResolver<ImmutableNode> resolver) {\n-        if (newRoot == null) {\n+    public void replaceRoot(final ImmutableNode immutableNode, final NodeKeyResolver<ImmutableNode> nodeKeyResolver) {\n+        if (immutableNode == null) {\n             throw new IllegalArgumentException(\"Replaced root node must not be null!\");\n         }\n-        final TreeData current = (TreeData)this.structure.get();\n-        final TreeData temp = this.createTreeDataForRootAndTracker(newRoot, current.getNodeTracker());\n-        this.structure.set(temp.updateNodeTracker(temp.getNodeTracker().update(newRoot, (NodeSelector)null, (NodeKeyResolver)resolver, (NodeHandler)temp)));\n-    }\n-    \n-    public void mergeRoot(final ImmutableNode node, final String rootName, final Map<ImmutableNode, ?> references, final Object rootRef, final NodeKeyResolver<ImmutableNode> resolver) {\n-        this.updateModel(tx -> {\n-            final TreeData current = tx.getCurrentData();\n-            final String newRootName = determineRootName(current.getRootNode(), node, rootName);\n-            if (newRootName != null) {\n-                tx.addChangeNodeNameOperation(current.getRootNode(), newRootName);\n-            }\n-            tx.addAddNodesOperation(current.getRootNode(), (Collection)node.getChildren());\n-            tx.addAttributesOperation(current.getRootNode(), node.getAttributes());\n-            if (node.getValue() != null) {\n-                tx.addChangeNodeValueOperation(current.getRootNode(), node.getValue());\n+        final TreeData treeDataForRootAndTracker = this.createTreeDataForRootAndTracker(immutableNode, ((TreeData)this.structure.get()).getNodeTracker());\n+        this.structure.set(treeDataForRootAndTracker.updateNodeTracker(treeDataForRootAndTracker.getNodeTracker().update(immutableNode, (NodeSelector)null, (NodeKeyResolver)nodeKeyResolver, (NodeHandler)treeDataForRootAndTracker)));\n+    }\n+    \n+    public void mergeRoot(final ImmutableNode immutableNode, final String s, final Map<ImmutableNode, ?> map, final Object o, final NodeKeyResolver<ImmutableNode> nodeKeyResolver) {\n+        this.updateModel(modelTransaction -> {\n+            final TreeData currentData = modelTransaction.getCurrentData();\n+            final String determineRootName = determineRootName(currentData.getRootNode(), immutableNode, s);\n+            if (determineRootName != null) {\n+                modelTransaction.addChangeNodeNameOperation(currentData.getRootNode(), determineRootName);\n+            }\n+            modelTransaction.addAddNodesOperation(currentData.getRootNode(), (Collection)immutableNode.getChildren());\n+            modelTransaction.addAttributesOperation(currentData.getRootNode(), immutableNode.getAttributes());\n+            if (immutableNode.getValue() != null) {\n+                modelTransaction.addChangeNodeValueOperation(currentData.getRootNode(), immutableNode.getValue());\n             }\n-            if (references != null) {\n-                tx.addNewReferences(references);\n+            if (map != null) {\n+                modelTransaction.addNewReferences(map);\n             }\n-            if (rootRef != null) {\n-                tx.addNewReference(current.getRootNode(), rootRef);\n+            if (o != null) {\n+                modelTransaction.addNewReference(currentData.getRootNode(), o);\n             }\n             return true;\n-        }, null, resolver);\n+        }, null, nodeKeyResolver);\n     }\n     \n-    public void trackNode(final NodeSelector selector, final NodeKeyResolver<ImmutableNode> resolver) {\n-        boolean done;\n+    public void trackNode(final NodeSelector nodeSelector, final NodeKeyResolver<ImmutableNode> nodeKeyResolver) {\n+        TreeData expectedValue;\n         do {\n-            final TreeData current = (TreeData)this.structure.get();\n-            final NodeTracker newTracker = current.getNodeTracker().trackNode(current.getRootNode(), selector, (NodeKeyResolver)resolver, (NodeHandler)current);\n-            done = this.structure.compareAndSet(current, current.updateNodeTracker(newTracker));\n-        } while (!done);\n+            expectedValue = this.structure.get();\n+        } while (!this.structure.compareAndSet(expectedValue, expectedValue.updateNodeTracker(expectedValue.getNodeTracker().trackNode(expectedValue.getRootNode(), nodeSelector, (NodeKeyResolver)nodeKeyResolver, (NodeHandler)expectedValue))));\n     }\n     \n-    public Collection<NodeSelector> selectAndTrackNodes(final String key, final NodeKeyResolver<ImmutableNode> resolver) {\n-        final Mutable<Collection<NodeSelector>> refSelectors = (Mutable<Collection<NodeSelector>>)new MutableObject();\n-        boolean done;\n+    public Collection<NodeSelector> selectAndTrackNodes(final String s, final NodeKeyResolver<ImmutableNode> nodeKeyResolver) {\n+        final MutableObject mutableObject = new MutableObject();\n+        TreeData expectedValue;\n+        List resolveNodeKey;\n         do {\n-            final TreeData current = (TreeData)this.structure.get();\n-            final List<ImmutableNode> nodes = resolver.resolveNodeKey((Object)current.getRootNode(), key, (NodeHandler)current);\n-            if (nodes.isEmpty()) {\n+            expectedValue = this.structure.get();\n+            resolveNodeKey = nodeKeyResolver.resolveNodeKey((Object)expectedValue.getRootNode(), s, (NodeHandler)expectedValue);\n+            if (resolveNodeKey.isEmpty()) {\n                 return (Collection<NodeSelector>)Collections.emptyList();\n             }\n-            done = this.structure.compareAndSet(current, createSelectorsForTrackedNodes(refSelectors, nodes, current, resolver));\n-        } while (!done);\n-        return (Collection)refSelectors.getValue();\n+        } while (!this.structure.compareAndSet(expectedValue, createSelectorsForTrackedNodes((Mutable<Collection<NodeSelector>>)mutableObject, (List<ImmutableNode>)resolveNodeKey, expectedValue, nodeKeyResolver)));\n+        return (Collection)((Mutable)mutableObject).getValue();\n     }\n     \n-    public Collection<NodeSelector> trackChildNodes(final String key, final NodeKeyResolver<ImmutableNode> resolver) {\n-        final Mutable<Collection<NodeSelector>> refSelectors = (Mutable<Collection<NodeSelector>>)new MutableObject();\n-        boolean done;\n+    public Collection<NodeSelector> trackChildNodes(final String s, final NodeKeyResolver<ImmutableNode> nodeKeyResolver) {\n+        final MutableObject mutableObject = new MutableObject();\n+        boolean b;\n         do {\n-            refSelectors.setValue((Object)Collections.emptyList());\n-            final TreeData current = (TreeData)this.structure.get();\n-            final List<ImmutableNode> nodes = resolver.resolveNodeKey((Object)current.getRootNode(), key, (NodeHandler)current);\n-            if (nodes.size() == 1) {\n-                final ImmutableNode node = (ImmutableNode)nodes.get(0);\n-                done = (node.getChildren().isEmpty() || this.structure.compareAndSet(current, createSelectorsForTrackedNodes(refSelectors, (List<ImmutableNode>)node.getChildren(), current, resolver)));\n+            ((Mutable)mutableObject).setValue((Object)Collections.emptyList());\n+            final TreeData expectedValue = (TreeData)this.structure.get();\n+            final List resolveNodeKey = nodeKeyResolver.resolveNodeKey((Object)expectedValue.getRootNode(), s, (NodeHandler)expectedValue);\n+            if (resolveNodeKey.size() == 1) {\n+                final ImmutableNode immutableNode = (ImmutableNode)resolveNodeKey.get(0);\n+                b = (immutableNode.getChildren().isEmpty() || this.structure.compareAndSet(expectedValue, createSelectorsForTrackedNodes((Mutable<Collection<NodeSelector>>)mutableObject, (List<ImmutableNode>)immutableNode.getChildren(), expectedValue, nodeKeyResolver)));\n             }\n             else {\n-                done = true;\n+                b = true;\n             }\n-        } while (!done);\n-        return (Collection)refSelectors.getValue();\n+        } while (!b);\n+        return (Collection)((Mutable)mutableObject).getValue();\n     }\n     \n-    public NodeSelector trackChildNodeWithCreation(final String key, final String childName, final NodeKeyResolver<ImmutableNode> resolver) {\n-        final MutableObject<NodeSelector> refSelector = (MutableObject<NodeSelector>)new MutableObject();\n-        boolean done;\n+    public NodeSelector trackChildNodeWithCreation(final String str, final String s, final NodeKeyResolver<ImmutableNode> nodeKeyResolver) {\n+        final MutableObject mutableObject = new MutableObject();\n+        TreeData expectedValue;\n+        List resolveNodeKey;\n         do {\n-            final TreeData current = (TreeData)this.structure.get();\n-            final List<ImmutableNode> nodes = resolver.resolveNodeKey((Object)current.getRootNode(), key, (NodeHandler)current);\n-            if (nodes.size() != 1) {\n-                throw new ConfigurationRuntimeException(\"Key does not select a single node: \" + key);\n+            expectedValue = this.structure.get();\n+            resolveNodeKey = nodeKeyResolver.resolveNodeKey((Object)expectedValue.getRootNode(), str, (NodeHandler)expectedValue);\n+            if (resolveNodeKey.size() != 1) {\n+                throw new ConfigurationRuntimeException(\"Key does not select a single node: \" + str);\n             }\n-            final ImmutableNode parent = (ImmutableNode)nodes.get(0);\n-            final TreeData newData = createDataWithTrackedChildNode(current, parent, childName, resolver, refSelector);\n-            done = this.structure.compareAndSet(current, newData);\n-        } while (!done);\n-        return (NodeSelector)refSelector.getValue();\n+        } while (!this.structure.compareAndSet(expectedValue, createDataWithTrackedChildNode(expectedValue, (ImmutableNode)resolveNodeKey.get(0), s, nodeKeyResolver, (MutableObject<NodeSelector>)mutableObject)));\n+        return (NodeSelector)mutableObject.getValue();\n     }\n     \n-    public ImmutableNode getTrackedNode(final NodeSelector selector) {\n-        return ((TreeData)this.structure.get()).getNodeTracker().getTrackedNode(selector);\n+    public ImmutableNode getTrackedNode(final NodeSelector nodeSelector) {\n+        return ((TreeData)this.structure.get()).getNodeTracker().getTrackedNode(nodeSelector);\n     }\n     \n-    public void replaceTrackedNode(final NodeSelector selector, final ImmutableNode newNode) {\n-        if (newNode == null) {\n+    public void replaceTrackedNode(final NodeSelector nodeSelector, final ImmutableNode immutableNode) {\n+        if (immutableNode == null) {\n             throw new IllegalArgumentException(\"Replacement node must not be null!\");\n         }\n-        boolean done;\n+        TreeData treeData;\n         do {\n-            final TreeData currentData = (TreeData)this.structure.get();\n-            done = (this.replaceDetachedTrackedNode(currentData, selector, newNode) || this.replaceActiveTrackedNode(currentData, selector, newNode));\n-        } while (!done);\n+            treeData = this.structure.get();\n+        } while (!this.replaceDetachedTrackedNode(treeData, nodeSelector, immutableNode) && !this.replaceActiveTrackedNode(treeData, nodeSelector, immutableNode));\n     }\n     \n-    public NodeHandler<ImmutableNode> getTrackedNodeHandler(final NodeSelector selector) {\n-        final TreeData currentData = (TreeData)this.structure.get();\n-        final InMemoryNodeModel detachedNodeModel = currentData.getNodeTracker().getDetachedNodeModel(selector);\n-        return (NodeHandler<ImmutableNode>)((detachedNodeModel != null) ? detachedNodeModel.getNodeHandler() : new TrackedNodeHandler(currentData.getNodeTracker().getTrackedNode(selector), (NodeHandler)currentData));\n+    public NodeHandler<ImmutableNode> getTrackedNodeHandler(final NodeSelector nodeSelector) {\n+        final TreeData treeData = (TreeData)this.structure.get();\n+        final InMemoryNodeModel detachedNodeModel = treeData.getNodeTracker().getDetachedNodeModel(nodeSelector);\n+        return (NodeHandler<ImmutableNode>)((detachedNodeModel != null) ? detachedNodeModel.getNodeHandler() : new TrackedNodeHandler(treeData.getNodeTracker().getTrackedNode(nodeSelector), (NodeHandler)treeData));\n     }\n     \n-    public boolean isTrackedNodeDetached(final NodeSelector selector) {\n-        return ((TreeData)this.structure.get()).getNodeTracker().isTrackedNodeDetached(selector);\n+    public boolean isTrackedNodeDetached(final NodeSelector nodeSelector) {\n+        return ((TreeData)this.structure.get()).getNodeTracker().isTrackedNodeDetached(nodeSelector);\n     }\n     \n-    public void untrackNode(final NodeSelector selector) {\n-        boolean done;\n+    public void untrackNode(final NodeSelector nodeSelector) {\n+        TreeData expectedValue;\n         do {\n-            final TreeData current = (TreeData)this.structure.get();\n-            final NodeTracker newTracker = current.getNodeTracker().untrackNode(selector);\n-            done = this.structure.compareAndSet(current, current.updateNodeTracker(newTracker));\n-        } while (!done);\n+            expectedValue = this.structure.get();\n+        } while (!this.structure.compareAndSet(expectedValue, expectedValue.updateNodeTracker(expectedValue.getNodeTracker().untrackNode(nodeSelector))));\n     }\n     \n     public ReferenceNodeHandler getReferenceNodeHandler() {\n         return (ReferenceNodeHandler)this.getTreeData();\n     }\n     \n     TreeData getTreeData() {\n         return this.structure.get();\n     }\n     \n-    static void updateParentMapping(final Map<ImmutableNode, ImmutableNode> parents, final ImmutableNode root) {\n-        NodeTreeWalker.INSTANCE.walkBFS((Object)root, (ConfigurationNodeVisitor)new InMemoryNodeModel.InMemoryNodeModel$1((Map)parents), (NodeHandler)InMemoryNodeModel.DUMMY_HANDLER);\n+    static void updateParentMapping(final Map<ImmutableNode, ImmutableNode> map, final ImmutableNode immutableNode) {\n+        NodeTreeWalker.INSTANCE.walkBFS((Object)immutableNode, (ConfigurationNodeVisitor)new InMemoryNodeModel.InMemoryNodeModel$1((Map)map), (NodeHandler)InMemoryNodeModel.DUMMY_HANDLER);\n     }\n     \n-    static boolean checkIfNodeDefined(final ImmutableNode node) {\n-        return node.getValue() != null || !node.getChildren().isEmpty() || !node.getAttributes().isEmpty();\n+    static boolean checkIfNodeDefined(final ImmutableNode immutableNode) {\n+        return immutableNode.getValue() != null || !immutableNode.getChildren().isEmpty() || !immutableNode.getAttributes().isEmpty();\n     }\n     \n-    private void initializeAddTransaction(final ModelTransaction tx, final String key, final Iterable<?> values, final NodeKeyResolver<ImmutableNode> resolver) {\n-        final NodeAddData<ImmutableNode> addData = (NodeAddData<ImmutableNode>)resolver.resolveAddKey((Object)tx.getQueryRoot(), key, (NodeHandler)tx.getCurrentData());\n-        if (addData.isAttribute()) {\n-            addAttributeProperty(tx, addData, values);\n+    private void initializeAddTransaction(final ModelTransaction modelTransaction, final String s, final Iterable<?> iterable, final NodeKeyResolver<ImmutableNode> nodeKeyResolver) {\n+        final NodeAddData resolveAddKey = nodeKeyResolver.resolveAddKey((Object)modelTransaction.getQueryRoot(), s, (NodeHandler)modelTransaction.getCurrentData());\n+        if (resolveAddKey.isAttribute()) {\n+            addAttributeProperty(modelTransaction, (NodeAddData<ImmutableNode>)resolveAddKey, iterable);\n         }\n         else {\n-            addNodeProperty(tx, addData, values);\n+            addNodeProperty(modelTransaction, (NodeAddData<ImmutableNode>)resolveAddKey, iterable);\n         }\n     }\n     \n-    private TreeData createTreeData(final ImmutableNode root, final TreeData current) {\n-        final NodeTracker newTracker = (current != null) ? current.getNodeTracker().detachAllTrackedNodes() : new NodeTracker();\n-        return this.createTreeDataForRootAndTracker(root, newTracker);\n+    private TreeData createTreeData(final ImmutableNode immutableNode, final TreeData treeData) {\n+        return this.createTreeDataForRootAndTracker(immutableNode, (treeData != null) ? treeData.getNodeTracker().detachAllTrackedNodes() : new NodeTracker());\n     }\n     \n-    private TreeData createTreeDataForRootAndTracker(final ImmutableNode root, final NodeTracker newTracker) {\n-        return new TreeData(root, (Map)this.createParentMapping(root), (Map)Collections.emptyMap(), newTracker, new ReferenceTracker());\n+    private TreeData createTreeDataForRootAndTracker(final ImmutableNode immutableNode, final NodeTracker nodeTracker) {\n+        return new TreeData(immutableNode, (Map)this.createParentMapping(immutableNode), (Map)Collections.emptyMap(), nodeTracker, new ReferenceTracker());\n     }\n     \n-    private static void addNodeProperty(final ModelTransaction tx, final NodeAddData<ImmutableNode> addData, final Iterable<?> values) {\n-        final Collection<ImmutableNode> newNodes = createNodesToAdd(addData.getNewNodeName(), values);\n-        addNodesByAddData(tx, addData, newNodes);\n+    private static void addNodeProperty(final ModelTransaction modelTransaction, final NodeAddData<ImmutableNode> nodeAddData, final Iterable<?> iterable) {\n+        addNodesByAddData(modelTransaction, nodeAddData, createNodesToAdd(nodeAddData.getNewNodeName(), iterable));\n     }\n     \n-    private static void addNodesByAddData(final ModelTransaction tx, final NodeAddData<ImmutableNode> addData, final Collection<ImmutableNode> newNodes) {\n-        if (addData.getPathNodes().isEmpty()) {\n-            tx.addAddNodesOperation((ImmutableNode)addData.getParent(), (Collection)newNodes);\n+    private static void addNodesByAddData(final ModelTransaction modelTransaction, final NodeAddData<ImmutableNode> nodeAddData, final Collection<ImmutableNode> collection) {\n+        if (nodeAddData.getPathNodes().isEmpty()) {\n+            modelTransaction.addAddNodesOperation((ImmutableNode)nodeAddData.getParent(), (Collection)collection);\n         }\n         else {\n-            final ImmutableNode newChild = createNodeToAddWithPath(addData, newNodes);\n-            tx.addAddNodeOperation((ImmutableNode)addData.getParent(), newChild);\n+            modelTransaction.addAddNodeOperation((ImmutableNode)nodeAddData.getParent(), createNodeToAddWithPath(nodeAddData, collection));\n         }\n     }\n     \n-    private static void addAttributeProperty(final ModelTransaction tx, final NodeAddData<ImmutableNode> addData, final Iterable<?> values) {\n-        if (addData.getPathNodes().isEmpty()) {\n-            tx.addAttributeOperation((ImmutableNode)addData.getParent(), addData.getNewNodeName(), (Object)values.iterator().next());\n+    private static void addAttributeProperty(final ModelTransaction modelTransaction, final NodeAddData<ImmutableNode> nodeAddData, final Iterable<?> iterable) {\n+        if (nodeAddData.getPathNodes().isEmpty()) {\n+            modelTransaction.addAttributeOperation((ImmutableNode)nodeAddData.getParent(), nodeAddData.getNewNodeName(), (Object)iterable.iterator().next());\n         }\n         else {\n-            final int pathNodeCount = addData.getPathNodes().size();\n-            final ImmutableNode childWithAttribute = new ImmutableNode.Builder().name((String)addData.getPathNodes().get(pathNodeCount - 1)).addAttribute(addData.getNewNodeName(), (Object)values.iterator().next()).create();\n-            final ImmutableNode newChild = (pathNodeCount > 1) ? createNodeOnPath(addData.getPathNodes().subList(0, pathNodeCount - 1).iterator(), Collections.singleton(childWithAttribute)) : childWithAttribute;\n-            tx.addAddNodeOperation((ImmutableNode)addData.getParent(), newChild);\n+            final int size = nodeAddData.getPathNodes().size();\n+            final ImmutableNode create = new ImmutableNode.Builder().name((String)nodeAddData.getPathNodes().get(size - 1)).addAttribute(nodeAddData.getNewNodeName(), (Object)iterable.iterator().next()).create();\n+            modelTransaction.addAddNodeOperation((ImmutableNode)nodeAddData.getParent(), (size > 1) ? createNodeOnPath(nodeAddData.getPathNodes().subList(0, size - 1).iterator(), Collections.singleton(create)) : create);\n         }\n     }\n     \n-    private static Collection<ImmutableNode> createNodesToAdd(final String newNodeName, final Iterable<?> values) {\n-        final Collection<ImmutableNode> nodes = new LinkedList<ImmutableNode>();\n-        values.forEach(value -> nodes.add(new ImmutableNode.Builder().name(newNodeName).value(value).create()));\n-        return nodes;\n+    private static Collection<ImmutableNode> createNodesToAdd(final String s, final Iterable<?> iterable) {\n+        final LinkedList list = new LinkedList();\n+        iterable.forEach(o -> collection.add(new ImmutableNode.Builder().name(s2).value(o).create()));\n+        return list;\n     }\n     \n-    private static ImmutableNode createNodeToAddWithPath(final NodeAddData<ImmutableNode> addData, final Collection<ImmutableNode> newNodes) {\n-        return createNodeOnPath(addData.getPathNodes().iterator(), newNodes);\n+    private static ImmutableNode createNodeToAddWithPath(final NodeAddData<ImmutableNode> nodeAddData, final Collection<ImmutableNode> collection) {\n+        return createNodeOnPath(nodeAddData.getPathNodes().iterator(), collection);\n     }\n     \n-    private static ImmutableNode createNodeOnPath(final Iterator<String> it, final Collection<ImmutableNode> newNodes) {\n-        final String nodeName = (String)it.next();\n+    private static ImmutableNode createNodeOnPath(final Iterator<String> iterator, final Collection<ImmutableNode> collection) {\n+        final String s = (String)iterator.next();\n         ImmutableNode.Builder builder;\n-        if (it.hasNext()) {\n+        if (iterator.hasNext()) {\n             builder = new ImmutableNode.Builder(1);\n-            builder.addChild(createNodeOnPath(it, newNodes));\n+            builder.addChild(createNodeOnPath(iterator, collection));\n         }\n         else {\n-            builder = new ImmutableNode.Builder(newNodes.size());\n-            builder.addChildren((Collection)newNodes);\n+            builder = new ImmutableNode.Builder(collection.size());\n+            builder.addChildren((Collection)collection);\n         }\n-        return builder.name(nodeName).create();\n+        return builder.name(s).create();\n     }\n     \n-    private static boolean initializeClearTransaction(final ModelTransaction tx, final Collection<QueryResult<ImmutableNode>> results) {\n-        results.forEach(result -> {\n-            if (result.isAttributeResult()) {\n-                tx.addRemoveAttributeOperation((ImmutableNode)result.getNode(), result.getAttributeName());\n+    private static boolean initializeClearTransaction(final ModelTransaction modelTransaction, final Collection<QueryResult<ImmutableNode>> collection) {\n+        collection.forEach(queryResult -> {\n+            if (queryResult.isAttributeResult()) {\n+                modelTransaction2.addRemoveAttributeOperation((ImmutableNode)queryResult.getNode(), queryResult.getAttributeName());\n             }\n             else {\n-                tx.addClearNodeValueOperation((ImmutableNode)result.getNode());\n+                modelTransaction2.addClearNodeValueOperation((ImmutableNode)queryResult.getNode());\n             }\n             return;\n         });\n-        return !results.isEmpty();\n+        return !collection.isEmpty();\n     }\n     \n-    private static boolean initializeUpdateTransaction(final ModelTransaction tx, final Map<QueryResult<ImmutableNode>, Object> changedValues) {\n-        changedValues.forEach((k, v) -> {\n-            final ImmutableNode node = (ImmutableNode)k.getNode();\n-            if (k.isAttributeResult()) {\n-                tx.addAttributeOperation(node, k.getAttributeName(), v);\n+    private static boolean initializeUpdateTransaction(final ModelTransaction modelTransaction, final Map<QueryResult<ImmutableNode>, Object> map) {\n+        map.forEach((queryResult, o) -> {\n+            final ImmutableNode immutableNode = (ImmutableNode)queryResult.getNode();\n+            if (queryResult.isAttributeResult()) {\n+                modelTransaction2.addAttributeOperation(immutableNode, queryResult.getAttributeName(), o);\n             }\n             else {\n-                tx.addChangeNodeValueOperation(node, v);\n+                modelTransaction2.addChangeNodeValueOperation(immutableNode, o);\n             }\n             return;\n         });\n-        return !changedValues.isEmpty();\n+        return !map.isEmpty();\n     }\n     \n-    private static ImmutableNode initialRootNode(final ImmutableNode providedRoot) {\n-        return (providedRoot != null) ? providedRoot : new ImmutableNode.Builder().create();\n+    private static ImmutableNode initialRootNode(final ImmutableNode immutableNode) {\n+        return (immutableNode != null) ? immutableNode : new ImmutableNode.Builder().create();\n     }\n     \n-    private static String determineRootName(final ImmutableNode rootNode, final ImmutableNode node, final String rootName) {\n-        if (rootName != null) {\n-            return rootName;\n+    private static String determineRootName(final ImmutableNode immutableNode, final ImmutableNode immutableNode2, final String s) {\n+        if (s != null) {\n+            return s;\n         }\n-        if (rootNode.getNodeName() == null) {\n-            return node.getNodeName();\n+        if (immutableNode.getNodeName() == null) {\n+            return immutableNode2.getNodeName();\n         }\n         return null;\n     }\n     \n-    private Map<ImmutableNode, ImmutableNode> createParentMapping(final ImmutableNode root) {\n-        final Map<ImmutableNode, ImmutableNode> parents = new HashMap<ImmutableNode, ImmutableNode>();\n-        updateParentMapping(parents, root);\n-        return parents;\n+    private Map<ImmutableNode, ImmutableNode> createParentMapping(final ImmutableNode immutableNode) {\n+        final HashMap hashMap = new HashMap();\n+        updateParentMapping(hashMap, immutableNode);\n+        return hashMap;\n     }\n     \n-    private void updateModel(final InMemoryNodeModel.TransactionInitializer txInit, final NodeSelector selector, final NodeKeyResolver<ImmutableNode> resolver) {\n-        boolean done;\n+    private void updateModel(final InMemoryNodeModel.TransactionInitializer transactionInitializer, final NodeSelector nodeSelector, final NodeKeyResolver<ImmutableNode> nodeKeyResolver) {\n+        TreeData treeData;\n         do {\n-            final TreeData currentData = this.getTreeData();\n-            done = (this.executeTransactionOnDetachedTrackedNode(txInit, selector, currentData, resolver) || this.executeTransactionOnCurrentStructure(txInit, selector, currentData, resolver));\n-        } while (!done);\n+            treeData = this.getTreeData();\n+        } while (!this.executeTransactionOnDetachedTrackedNode(transactionInitializer, nodeSelector, treeData, nodeKeyResolver) && !this.executeTransactionOnCurrentStructure(transactionInitializer, nodeSelector, treeData, nodeKeyResolver));\n     }\n     \n-    private boolean executeTransactionOnCurrentStructure(final InMemoryNodeModel.TransactionInitializer txInit, final NodeSelector selector, final TreeData currentData, final NodeKeyResolver<ImmutableNode> resolver) {\n-        final ModelTransaction tx = new ModelTransaction(currentData, selector, (NodeKeyResolver)resolver);\n-        boolean done;\n-        if (!txInit.initTransaction(tx)) {\n-            done = true;\n-        }\n-        else {\n-            final TreeData newData = tx.execute();\n-            done = this.structure.compareAndSet(tx.getCurrentData(), newData);\n-        }\n-        return done;\n+    private boolean executeTransactionOnCurrentStructure(final InMemoryNodeModel.TransactionInitializer transactionInitializer, final NodeSelector nodeSelector, final TreeData treeData, final NodeKeyResolver<ImmutableNode> nodeKeyResolver) {\n+        final ModelTransaction modelTransaction = new ModelTransaction(treeData, nodeSelector, (NodeKeyResolver)nodeKeyResolver);\n+        return !transactionInitializer.initTransaction(modelTransaction) || this.structure.compareAndSet(modelTransaction.getCurrentData(), modelTransaction.execute());\n     }\n     \n-    private boolean executeTransactionOnDetachedTrackedNode(final InMemoryNodeModel.TransactionInitializer txInit, final NodeSelector selector, final TreeData currentData, final NodeKeyResolver<ImmutableNode> resolver) {\n-        if (selector != null) {\n-            final InMemoryNodeModel detachedNodeModel = currentData.getNodeTracker().getDetachedNodeModel(selector);\n+    private boolean executeTransactionOnDetachedTrackedNode(final InMemoryNodeModel.TransactionInitializer transactionInitializer, final NodeSelector nodeSelector, final TreeData treeData, final NodeKeyResolver<ImmutableNode> nodeKeyResolver) {\n+        if (nodeSelector != null) {\n+            final InMemoryNodeModel detachedNodeModel = treeData.getNodeTracker().getDetachedNodeModel(nodeSelector);\n             if (detachedNodeModel != null) {\n-                detachedNodeModel.updateModel(txInit, null, resolver);\n+                detachedNodeModel.updateModel(transactionInitializer, null, nodeKeyResolver);\n                 return true;\n             }\n         }\n         return false;\n     }\n     \n-    private boolean replaceDetachedTrackedNode(final TreeData currentData, final NodeSelector selector, final ImmutableNode newNode) {\n-        final InMemoryNodeModel detachedNodeModel = currentData.getNodeTracker().getDetachedNodeModel(selector);\n+    private boolean replaceDetachedTrackedNode(final TreeData treeData, final NodeSelector nodeSelector, final ImmutableNode rootNode) {\n+        final InMemoryNodeModel detachedNodeModel = treeData.getNodeTracker().getDetachedNodeModel(nodeSelector);\n         if (detachedNodeModel != null) {\n-            detachedNodeModel.setRootNode(newNode);\n+            detachedNodeModel.setRootNode(rootNode);\n             return true;\n         }\n         return false;\n     }\n     \n-    private boolean replaceActiveTrackedNode(final TreeData currentData, final NodeSelector selector, final ImmutableNode newNode) {\n-        final NodeTracker newTracker = currentData.getNodeTracker().replaceAndDetachTrackedNode(selector, newNode);\n-        return this.structure.compareAndSet(currentData, currentData.updateNodeTracker(newTracker));\n-    }\n-    \n-    private static TreeData createSelectorsForTrackedNodes(final Mutable<Collection<NodeSelector>> refSelectors, final List<ImmutableNode> nodes, final TreeData current, final NodeKeyResolver<ImmutableNode> resolver) {\n-        final List<NodeSelector> selectors = new ArrayList<NodeSelector>(nodes.size());\n-        final Map<ImmutableNode, String> cache = new HashMap<ImmutableNode, String>();\n-        nodes.forEach(node -> selectors.add(new NodeSelector(resolver.nodeKey((Object)node, cache, (NodeHandler)current))));\n-        refSelectors.setValue((Object)selectors);\n-        final NodeTracker newTracker = current.getNodeTracker().trackNodes((Collection)selectors, (Collection)nodes);\n-        return current.updateNodeTracker(newTracker);\n-    }\n-    \n-    private static TreeData updateDataWithNewTrackedNode(final TreeData current, final ImmutableNode node, final NodeKeyResolver<ImmutableNode> resolver, final MutableObject<NodeSelector> refSelector) {\n-        final NodeSelector selector = new NodeSelector(resolver.nodeKey((Object)node, (Map)new HashMap(), (NodeHandler)current));\n-        refSelector.setValue((Object)selector);\n-        final NodeTracker newTracker = current.getNodeTracker().trackNodes((Collection)Collections.singleton(selector), (Collection)Collections.singleton(node));\n-        return current.updateNodeTracker(newTracker);\n-    }\n-    \n-    private static TreeData createDataWithTrackedChildNode(final TreeData current, final ImmutableNode parent, final String childName, final NodeKeyResolver<ImmutableNode> resolver, final MutableObject<NodeSelector> refSelector) {\n-        final List<ImmutableNode> namedChildren = current.getChildren(parent, childName);\n-        TreeData newData;\n-        if (!namedChildren.isEmpty()) {\n-            newData = updateDataWithNewTrackedNode(current, namedChildren.get(0), resolver, refSelector);\n+    private boolean replaceActiveTrackedNode(final TreeData expectedValue, final NodeSelector nodeSelector, final ImmutableNode immutableNode) {\n+        return this.structure.compareAndSet(expectedValue, expectedValue.updateNodeTracker(expectedValue.getNodeTracker().replaceAndDetachTrackedNode(nodeSelector, immutableNode)));\n+    }\n+    \n+    private static TreeData createSelectorsForTrackedNodes(final Mutable<Collection<NodeSelector>> mutable, final List<ImmutableNode> list, final TreeData treeData, final NodeKeyResolver<ImmutableNode> nodeKeyResolver) {\n+        final ArrayList value = new ArrayList(list.size());\n+        list.forEach(immutableNode -> {\n+            final Object o = new HashMap();\n+            list2.add(new NodeSelector(nodeKeyResolver2.nodeKey((Object)immutableNode, map, (NodeHandler)treeData2)));\n+            return;\n+        });\n+        mutable.setValue((Object)value);\n+        return treeData.updateNodeTracker(treeData.getNodeTracker().trackNodes((Collection)value, (Collection)list));\n+    }\n+    \n+    private static TreeData updateDataWithNewTrackedNode(final TreeData treeData, final ImmutableNode o, final NodeKeyResolver<ImmutableNode> nodeKeyResolver, final MutableObject<NodeSelector> mutableObject) {\n+        final NodeSelector nodeSelector = new NodeSelector(nodeKeyResolver.nodeKey((Object)o, (Map)new HashMap(), (NodeHandler)treeData));\n+        mutableObject.setValue((Object)nodeSelector);\n+        return treeData.updateNodeTracker(treeData.getNodeTracker().trackNodes((Collection)Collections.singleton(nodeSelector), (Collection)Collections.singleton(o)));\n+    }\n+    \n+    private static TreeData createDataWithTrackedChildNode(final TreeData treeData, final ImmutableNode immutableNode, final String s, final NodeKeyResolver<ImmutableNode> nodeKeyResolver, final MutableObject<NodeSelector> mutableObject) {\n+        final List children = treeData.getChildren(immutableNode, s);\n+        TreeData treeData2;\n+        if (!children.isEmpty()) {\n+            treeData2 = updateDataWithNewTrackedNode(treeData, children.get(0), nodeKeyResolver, mutableObject);\n         }\n         else {\n-            final ImmutableNode child = new ImmutableNode.Builder().name(childName).create();\n-            final ModelTransaction tx = new ModelTransaction(current, (NodeSelector)null, (NodeKeyResolver)resolver);\n-            tx.addAddNodeOperation(parent, child);\n-            newData = updateDataWithNewTrackedNode(tx.execute(), child, resolver, refSelector);\n+            final ImmutableNode create = new ImmutableNode.Builder().name(s).create();\n+            final ModelTransaction modelTransaction = new ModelTransaction(treeData, (NodeSelector)null, (NodeKeyResolver)nodeKeyResolver);\n+            modelTransaction.addAddNodeOperation(immutableNode, create);\n+            treeData2 = updateDataWithNewTrackedNode(modelTransaction.execute(), create, nodeKeyResolver, mutableObject);\n         }\n-        return newData;\n+        return treeData2;\n     }\n     \n-    private static boolean valuesNotEmpty(final Iterable<?> values) {\n-        return values.iterator().hasNext();\n+    private static boolean valuesNotEmpty(final Iterable<?> iterable) {\n+        return iterable.iterator().hasNext();\n     }\n     \n-    private static IllegalArgumentException attributeKeyException(final String key) {\n-        return new IllegalArgumentException(\"New nodes cannot be added to an attribute key: \" + key);\n+    private static IllegalArgumentException attributeKeyException(final String str) {\n+        return new IllegalArgumentException(\"New nodes cannot be added to an attribute key: \" + str);\n     }\n     \n     static {\n         DUMMY_HANDLER = (NodeHandler)new TreeData((ImmutableNode)null, (Map)Collections.emptyMap(), (Map)Collections.emptyMap(), (NodeTracker)null, new ReferenceTracker());\n     }\n }\n"}]}
