{"diffoscope-json-version": 1, "source1": "first/DefaultExpressionEngine.class", "source2": "second/DefaultExpressionEngine.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -8,14 +8,18 @@\n \n public class DefaultExpressionEngine implements ExpressionEngine\n {\n     public static final DefaultExpressionEngine INSTANCE;\n     private final DefaultExpressionEngineSymbols symbols;\n     private final NodeMatcher<String> nameMatcher;\n     \n+    static {\n+        INSTANCE = new DefaultExpressionEngine(DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS);\n+    }\n+    \n     public DefaultExpressionEngine(final DefaultExpressionEngineSymbols syms) {\n         this(syms, null);\n     }\n     \n     public DefaultExpressionEngine(final DefaultExpressionEngineSymbols syms, final NodeMatcher<String> nodeNameMatcher) {\n         if (syms == null) {\n             throw new IllegalArgumentException(\"Symbols must not be null!\");\n@@ -110,23 +114,19 @@\n     private <T> void processSubNodes(final DefaultConfigurationKey.KeyIterator keyPart, final List<T> subNodes, final Collection<QueryResult<T>> nodes, final NodeHandler<T> handler) {\n         if (keyPart.hasIndex()) {\n             if (keyPart.getIndex() >= 0 && keyPart.getIndex() < subNodes.size()) {\n                 this.findNodesForKey((DefaultConfigurationKey.KeyIterator)keyPart.clone(), subNodes.get(keyPart.getIndex()), nodes, handler);\n             }\n         }\n         else {\n-            subNodes.forEach(node -> this.findNodesForKey(keyPart.clone(), node, (Collection<org.apache.commons.configuration2.tree.QueryResult<Object>>)nodes, (org.apache.commons.configuration2.tree.NodeHandler<Object>)handler));\n+            subNodes.forEach(node -> this.findNodesForKey(keyIterator.clone(), node, (Collection<org.apache.commons.configuration2.tree.QueryResult<Object>>)results, (org.apache.commons.configuration2.tree.NodeHandler<Object>)handler2));\n         }\n     }\n     \n     private <T> int determineIndex(final T node, final T parent, final String nodeName, final NodeHandler<T> handler) {\n         return this.findChildNodesByName(handler, parent, nodeName).indexOf(node);\n     }\n     \n     private <T> List<T> findChildNodesByName(final NodeHandler<T> handler, final T parent, final String nodeName) {\n         return handler.getMatchingChildren((Object)parent, (NodeMatcher)this.nameMatcher, (Object)nodeName);\n     }\n-    \n-    static {\n-        INSTANCE = new DefaultExpressionEngine(DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS);\n-    }\n }\n"}]}
