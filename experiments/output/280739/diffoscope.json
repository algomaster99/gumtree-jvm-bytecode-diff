{"diffoscope-json-version": 1, "source1": "first/CSVParser.class", "source2": "second/CSVParser.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -34,149 +34,149 @@\n     private final Lexer lexer;\n     private final CSVParser.CSVRecordIterator csvRecordIterator;\n     private final List<String> recordList;\n     private long recordNumber;\n     private final long characterOffset;\n     private final Token reusableToken;\n     \n-    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n-        Objects.requireNonNull(file, \"file\");\n-        return parse(file.toPath(), charset, format);\n+    public static CSVParser parse(final File obj, final Charset charset, final CSVFormat csvFormat) throws IOException {\n+        Objects.requireNonNull(obj, \"file\");\n+        return parse(obj.toPath(), charset, csvFormat);\n     }\n     \n-    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format) throws IOException {\n+    public static CSVParser parse(final InputStream inputStream, final Charset cs, final CSVFormat obj) throws IOException {\n         Objects.requireNonNull(inputStream, \"inputStream\");\n-        Objects.requireNonNull(format, \"format\");\n-        return parse(new InputStreamReader(inputStream, charset), format);\n+        Objects.requireNonNull(obj, \"format\");\n+        return parse(new InputStreamReader(inputStream, cs), obj);\n     }\n     \n-    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n+    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat obj) throws IOException {\n         Objects.requireNonNull(path, \"path\");\n-        Objects.requireNonNull(format, \"format\");\n-        return parse(Files.newInputStream(path, new OpenOption[0]), charset, format);\n+        Objects.requireNonNull(obj, \"format\");\n+        return parse(Files.newInputStream(path, new OpenOption[0]), charset, obj);\n     }\n     \n-    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n-        return new CSVParser(reader, format);\n+    public static CSVParser parse(final Reader reader, final CSVFormat csvFormat) throws IOException {\n+        return new CSVParser(reader, csvFormat);\n     }\n     \n-    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n-        Objects.requireNonNull(string, \"string\");\n-        Objects.requireNonNull(format, \"format\");\n-        return new CSVParser(new StringReader(string), format);\n+    public static CSVParser parse(final String s, final CSVFormat obj) throws IOException {\n+        Objects.requireNonNull(s, \"string\");\n+        Objects.requireNonNull(obj, \"format\");\n+        return new CSVParser(new StringReader(s), obj);\n     }\n     \n-    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n-        Objects.requireNonNull(url, \"url\");\n+    public static CSVParser parse(final URL obj, final Charset charset, final CSVFormat obj2) throws IOException {\n+        Objects.requireNonNull(obj, \"url\");\n         Objects.requireNonNull(charset, \"charset\");\n-        Objects.requireNonNull(format, \"format\");\n-        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n+        Objects.requireNonNull(obj2, \"format\");\n+        return new CSVParser(new InputStreamReader(obj.openStream(), charset), obj2);\n     }\n     \n-    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n-        this(reader, format, 0L, 1L);\n+    public CSVParser(final Reader reader, final CSVFormat csvFormat) throws IOException {\n+        this(reader, csvFormat, 0L, 1L);\n     }\n     \n-    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber) throws IOException {\n+    public CSVParser(final Reader obj, final CSVFormat obj2, final long characterOffset, final long n) throws IOException {\n         this.recordList = new ArrayList<String>();\n         this.reusableToken = new Token();\n-        Objects.requireNonNull(reader, \"reader\");\n-        Objects.requireNonNull(format, \"format\");\n-        this.format = format.copy();\n-        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n+        Objects.requireNonNull(obj, \"reader\");\n+        Objects.requireNonNull(obj2, \"format\");\n+        this.format = obj2.copy();\n+        this.lexer = new Lexer(obj2, new ExtendedBufferedReader(obj));\n         this.csvRecordIterator = new CSVParser.CSVRecordIterator(this);\n         this.headers = this.createHeaders();\n         this.characterOffset = characterOffset;\n-        this.recordNumber = recordNumber - 1L;\n+        this.recordNumber = n - 1L;\n     }\n     \n-    private void addRecordValue(final boolean lastRecord) {\n-        final String input = this.reusableToken.content.toString();\n-        final String inputClean = this.format.getTrim() ? input.trim() : input;\n-        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {\n+    private void addRecordValue(final boolean b) {\n+        final String string = this.reusableToken.content.toString();\n+        final String s = this.format.getTrim() ? string.trim() : string;\n+        if (b && s.isEmpty() && this.format.getTrailingDelimiter()) {\n             return;\n         }\n-        this.recordList.add(this.handleNull(inputClean));\n+        this.recordList.add(this.handleNull(s));\n     }\n     \n     @Override\n     public void close() throws IOException {\n         if (this.lexer != null) {\n             this.lexer.close();\n         }\n     }\n     \n     private Map<String, Integer> createEmptyHeaderMap() {\n         return (Map<String, Integer>)(this.format.getIgnoreHeaderCase() ? new TreeMap<Object, Object>(String.CASE_INSENSITIVE_ORDER) : new LinkedHashMap<Object, Object>());\n     }\n     \n     private CSVParser.Headers createHeaders() throws IOException {\n-        Map<String, Integer> hdrMap = null;\n-        List<String> headerNames = null;\n-        final String[] formatHeader = this.format.getHeader();\n-        if (formatHeader != null) {\n-            hdrMap = this.createEmptyHeaderMap();\n-            String[] headerRecord = null;\n-            if (formatHeader.length == 0) {\n+        Map<String, Integer> emptyHeaderMap = null;\n+        Object list = null;\n+        final String[] header = this.format.getHeader();\n+        if (header != null) {\n+            emptyHeaderMap = this.createEmptyHeaderMap();\n+            Object[] values = null;\n+            if (header.length == 0) {\n                 final CSVRecord nextRecord = this.nextRecord();\n                 if (nextRecord != null) {\n-                    headerRecord = nextRecord.values();\n+                    values = nextRecord.values();\n                 }\n             }\n             else {\n                 if (this.format.getSkipHeaderRecord()) {\n                     this.nextRecord();\n                 }\n-                headerRecord = formatHeader;\n+                values = header;\n             }\n-            if (headerRecord != null) {\n-                for (int i = 0; i < headerRecord.length; ++i) {\n-                    final String header = headerRecord[i];\n-                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n-                    if (emptyHeader && !this.format.getAllowMissingColumnNames()) {\n-                        throw new IllegalArgumentException(\"A header name is missing in \" + Arrays.toString((Object[])headerRecord));\n-                    }\n-                    final boolean containsHeader = header != null && hdrMap.containsKey(header);\n-                    if (containsHeader && !emptyHeader && !this.format.getAllowDuplicateHeaderNames()) {\n-                        throw new IllegalArgumentException(String.format(\"The header contains a duplicate name: \\\"%s\\\" in %s. If this is valid then use CSVFormat.withAllowDuplicateHeaderNames().\", header, Arrays.toString(headerRecord)));\n-                    }\n-                    if (header != null) {\n-                        hdrMap.put(header, Integer.valueOf(i));\n-                        if (headerNames == null) {\n-                            headerNames = new ArrayList<String>(headerRecord.length);\n+            if (values != null) {\n+                for (int i = 0; i < values.length; ++i) {\n+                    final Object o = values[i];\n+                    final boolean b = o == null || ((String)o).trim().isEmpty();\n+                    if (b && !this.format.getAllowMissingColumnNames()) {\n+                        throw new IllegalArgumentException(\"A header name is missing in \" + Arrays.toString(values));\n+                    }\n+                    if (o != null && emptyHeaderMap.containsKey(o) && !b && !this.format.getAllowDuplicateHeaderNames()) {\n+                        throw new IllegalArgumentException(String.format(\"The header contains a duplicate name: \\\"%s\\\" in %s. If this is valid then use CSVFormat.withAllowDuplicateHeaderNames().\", o, Arrays.toString(values)));\n+                    }\n+                    if (o != null) {\n+                        emptyHeaderMap.put((String)o, Integer.valueOf(i));\n+                        if (list == null) {\n+                            list = new ArrayList<String>(values.length);\n                         }\n-                        headerNames.add(header);\n+                        ((List<String>)list).add((String)o);\n                     }\n                 }\n             }\n         }\n-        if (headerNames == null) {\n-            headerNames = Collections.emptyList();\n+        List<Object> list2;\n+        if (list == null) {\n+            list2 = Collections.emptyList();\n         }\n         else {\n-            headerNames = Collections.unmodifiableList((List<? extends String>)headerNames);\n+            list2 = Collections.unmodifiableList((List<?>)list);\n         }\n-        return new CSVParser.Headers((Map)hdrMap, (List)headerNames);\n+        return new CSVParser.Headers((Map)emptyHeaderMap, (List)list2);\n     }\n     \n     public long getCurrentLineNumber() {\n         return this.lexer.getCurrentLineNumber();\n     }\n     \n     public String getFirstEndOfLine() {\n         return this.lexer.getFirstEol();\n     }\n     \n     public Map<String, Integer> getHeaderMap() {\n         if (this.headers.headerMap == null) {\n             return null;\n         }\n-        final Map<String, Integer> map = this.createEmptyHeaderMap();\n-        map.putAll(this.headers.headerMap);\n-        return map;\n+        final Map<String, Integer> emptyHeaderMap = this.createEmptyHeaderMap();\n+        emptyHeaderMap.putAll(this.headers.headerMap);\n+        return emptyHeaderMap;\n     }\n     \n     Map<String, Integer> getHeaderMapRaw() {\n         return this.headers.headerMap;\n     }\n     \n     public List<String> getHeaderNames() {\n@@ -184,30 +184,30 @@\n     }\n     \n     public long getRecordNumber() {\n         return this.recordNumber;\n     }\n     \n     public List<CSVRecord> getRecords() throws IOException {\n-        final List<CSVRecord> records = new ArrayList<CSVRecord>();\n-        CSVRecord rec;\n-        while ((rec = this.nextRecord()) != null) {\n-            records.add(rec);\n+        final ArrayList list = new ArrayList();\n+        CSVRecord nextRecord;\n+        while ((nextRecord = this.nextRecord()) != null) {\n+            list.add(nextRecord);\n         }\n-        return records;\n+        return list;\n     }\n     \n-    private String handleNull(final String input) {\n+    private String handleNull(final String s) {\n         final boolean isQuoted = this.reusableToken.isQuoted;\n         final String nullString = this.format.getNullString();\n         final boolean strictQuoteMode = this.isStrictQuoteMode();\n-        if (input.equals(nullString)) {\n-            return (strictQuoteMode && isQuoted) ? input : null;\n+        if (s.equals(nullString)) {\n+            return (strictQuoteMode && isQuoted) ? s : null;\n         }\n-        return (strictQuoteMode && nullString == null && input.isEmpty() && !isQuoted) ? null : input;\n+        return (strictQuoteMode && nullString == null && s.isEmpty() && !isQuoted) ? null : s;\n     }\n     \n     public boolean isClosed() {\n         return this.lexer.isClosed();\n     }\n     \n     private boolean isStrictQuoteMode() {\n@@ -216,18 +216,18 @@\n     \n     @Override\n     public Iterator<CSVRecord> iterator() {\n         return (Iterator<CSVRecord>)this.csvRecordIterator;\n     }\n     \n     CSVRecord nextRecord() throws IOException {\n-        CSVRecord result = null;\n+        CSVRecord csvRecord = null;\n         this.recordList.clear();\n         StringBuilder sb = null;\n-        final long startCharPosition = this.lexer.getCharacterPosition() + this.characterOffset;\n+        final long n = this.lexer.getCharacterPosition() + this.characterOffset;\n         do {\n             this.reusableToken.reset();\n             this.lexer.nextToken(this.reusableToken);\n             switch (CSVParser.CSVParser$1.$SwitchMap$org$apache$commons$csv$Token$Type[this.reusableToken.type.ordinal()]) {\n                 case 1: {\n                     this.addRecordValue(false);\n                     continue;\n@@ -260,17 +260,16 @@\n                 default: {\n                     throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n                 }\n             }\n         } while (this.reusableToken.type == Token.Type.TOKEN);\n         if (!this.recordList.isEmpty()) {\n             ++this.recordNumber;\n-            final String comment = (sb == null) ? null : sb.toString();\n-            result = new CSVRecord(this, (String[])this.recordList.toArray(Constants.EMPTY_STRING_ARRAY), comment, this.recordNumber, startCharPosition);\n+            csvRecord = new CSVRecord(this, (String[])this.recordList.toArray(Constants.EMPTY_STRING_ARRAY), (sb == null) ? null : sb.toString(), this.recordNumber, n);\n         }\n-        return result;\n+        return csvRecord;\n     }\n     \n     public Stream<CSVRecord> stream() {\n         return StreamSupport.stream(Spliterators.spliteratorUnknownSize((Iterator<? extends CSVRecord>)this.iterator(), 16), false);\n     }\n }\n"}]}
