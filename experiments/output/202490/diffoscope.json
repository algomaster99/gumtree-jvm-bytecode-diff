{"diffoscope-json-version": 1, "source1": "first/BinaryTree.class", "source2": "second/BinaryTree.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -9,113 +9,111 @@\n \n class BinaryTree\n {\n     private static final int UNDEFINED = -1;\n     private static final int NODE = -2;\n     private final int[] tree;\n     \n-    public BinaryTree(final int depth) {\n-        if (depth < 0 || depth > 30) {\n-            throw new IllegalArgumentException(\"depth must be bigger than 0 and not bigger than 30 but is \" + depth);\n+    public BinaryTree(final int i) {\n+        if (i < 0 || i > 30) {\n+            throw new IllegalArgumentException(\"depth must be bigger than 0 and not bigger than 30 but is \" + i);\n         }\n-        Arrays.fill(this.tree = new int[(int)((1L << depth + 1) - 1L)], -1);\n+        Arrays.fill(this.tree = new int[(int)((1L << i + 1) - 1L)], -1);\n     }\n     \n-    public void addLeaf(final int node, final int path, final int depth, final int value) {\n-        if (depth == 0) {\n-            if (this.tree[node] != -1) {\n-                throw new IllegalArgumentException(\"Tree value at index \" + node + \" has already been assigned (\" + this.tree[node] + \")\");\n+    public void addLeaf(final int i, final int n, final int n2, final int n3) {\n+        if (n2 == 0) {\n+            if (this.tree[i] != -1) {\n+                throw new IllegalArgumentException(\"Tree value at index \" + i + \" has already been assigned (\" + this.tree[i] + \")\");\n             }\n-            this.tree[node] = value;\n+            this.tree[i] = n3;\n         }\n         else {\n-            this.tree[node] = -2;\n-            final int nextChild = 2 * node + 1 + (path & 0x1);\n-            this.addLeaf(nextChild, path >>> 1, depth - 1, value);\n+            this.tree[i] = -2;\n+            this.addLeaf(2 * i + 1 + (n & 0x1), n >>> 1, n2 - 1, n3);\n         }\n     }\n     \n-    public int read(final BitStream stream) throws IOException {\n-        int currentIndex = 0;\n+    public int read(final BitStream bitStream) throws IOException {\n+        int i = 0;\n         while (true) {\n-            final int bit = stream.nextBit();\n-            if (bit == -1) {\n+            final int nextBit = bitStream.nextBit();\n+            if (nextBit == -1) {\n                 return -1;\n             }\n-            final int childIndex = 2 * currentIndex + 1 + bit;\n-            final int value = this.tree[childIndex];\n-            if (value == -2) {\n-                currentIndex = childIndex;\n+            final int n = 2 * i + 1 + nextBit;\n+            final int n2 = this.tree[n];\n+            if (n2 == -2) {\n+                i = n;\n             }\n             else {\n-                if (value != -1) {\n-                    return value;\n+                if (n2 != -1) {\n+                    return n2;\n                 }\n-                throw new IOException(\"The child \" + bit + \" of node at index \" + currentIndex + \" is not defined\");\n+                throw new IOException(\"The child \" + nextBit + \" of node at index \" + i + \" is not defined\");\n             }\n         }\n     }\n     \n-    static BinaryTree decode(final InputStream inputStream, final int totalNumberOfValues) throws IOException {\n-        if (totalNumberOfValues < 0) {\n-            throw new IllegalArgumentException(\"totalNumberOfValues must be bigger than 0, is \" + totalNumberOfValues);\n+    static BinaryTree decode(final InputStream inputStream, final int i) throws IOException {\n+        if (i < 0) {\n+            throw new IllegalArgumentException(\"totalNumberOfValues must be bigger than 0, is \" + i);\n         }\n-        final int size = inputStream.read() + 1;\n-        if (size == 0) {\n+        final int n = inputStream.read() + 1;\n+        if (n == 0) {\n             throw new IOException(\"Cannot read the size of the encoded tree, unexpected end of stream\");\n         }\n-        final byte[] encodedTree = new byte[size];\n-        final int read = IOUtils.readFully(inputStream, encodedTree);\n-        if (read != size) {\n+        final byte[] array = new byte[n];\n+        if (IOUtils.readFully(inputStream, array) != n) {\n             throw new EOFException();\n         }\n-        int maxLength = 0;\n-        final int[] originalBitLengths = new int[totalNumberOfValues];\n-        int pos = 0;\n-        for (final byte b : encodedTree) {\n-            final int numberOfValues = ((b & 0xF0) >> 4) + 1;\n-            if (pos + numberOfValues > totalNumberOfValues) {\n+        int max = 0;\n+        final int[] array2 = new int[i];\n+        int n2 = 0;\n+        for (final byte b : array) {\n+            final int n3 = ((b & 0xF0) >> 4) + 1;\n+            if (n2 + n3 > i) {\n                 throw new IOException(\"Number of values exceeds given total number of values\");\n             }\n-            final int bitLength = (b & 0xF) + 1;\n-            for (int j = 0; j < numberOfValues; ++j) {\n-                originalBitLengths[pos++] = bitLength;\n-            }\n-            maxLength = Math.max(maxLength, bitLength);\n-        }\n-        final int[] permutation = new int[originalBitLengths.length];\n-        for (int k = 0; k < permutation.length; ++k) {\n-            permutation[k] = k;\n-        }\n-        int c = 0;\n-        final int[] sortedBitLengths = new int[originalBitLengths.length];\n-        for (int i = 0; i < originalBitLengths.length; ++i) {\n-            for (int l = 0; l < originalBitLengths.length; ++l) {\n-                if (originalBitLengths[l] == i) {\n-                    sortedBitLengths[c] = i;\n-                    permutation[c] = l;\n-                    ++c;\n+            final int b2 = (b & 0xF) + 1;\n+            for (int k = 0; k < n3; ++k) {\n+                array2[n2++] = b2;\n+            }\n+            max = Math.max(max, b2);\n+        }\n+        final int[] array4 = new int[array2.length];\n+        for (int l = 0; l < array4.length; ++l) {\n+            array4[l] = l;\n+        }\n+        int n4 = 0;\n+        final int[] array5 = new int[array2.length];\n+        for (int n5 = 0; n5 < array2.length; ++n5) {\n+            for (int n6 = 0; n6 < array2.length; ++n6) {\n+                if (array2[n6] == n5) {\n+                    array5[n4] = n5;\n+                    array4[n4] = n6;\n+                    ++n4;\n                 }\n             }\n         }\n-        int code = 0;\n-        int codeIncrement = 0;\n-        int lastBitLength = 0;\n-        final int[] codes = new int[totalNumberOfValues];\n-        for (int m = totalNumberOfValues - 1; m >= 0; --m) {\n-            code += codeIncrement;\n-            if (sortedBitLengths[m] != lastBitLength) {\n-                lastBitLength = sortedBitLengths[m];\n-                codeIncrement = 1 << 16 - lastBitLength;\n-            }\n-            codes[permutation[m]] = code;\n-        }\n-        final BinaryTree tree = new BinaryTree(maxLength);\n-        for (int k2 = 0; k2 < codes.length; ++k2) {\n-            final int bitLength2 = originalBitLengths[k2];\n-            if (bitLength2 > 0) {\n-                tree.addLeaf(0, Integer.reverse(codes[k2] << 16), bitLength2, k2);\n+        int n7 = 0;\n+        int n8 = 0;\n+        int n9 = 0;\n+        final int[] array6 = new int[i];\n+        for (int n10 = i - 1; n10 >= 0; --n10) {\n+            n7 += n8;\n+            if (array5[n10] != n9) {\n+                n9 = array5[n10];\n+                n8 = 1 << 16 - n9;\n+            }\n+            array6[array4[n10]] = n7;\n+        }\n+        final BinaryTree binaryTree = new BinaryTree(max);\n+        for (int n11 = 0; n11 < array6.length; ++n11) {\n+            final int n12 = array2[n11];\n+            if (n12 > 0) {\n+                binaryTree.addLeaf(0, Integer.reverse(array6[n11] << 16), n12, n11);\n             }\n         }\n-        return tree;\n+        return binaryTree;\n     }\n }\n"}]}
