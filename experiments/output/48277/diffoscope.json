{"diffoscope-json-version": 1, "source1": "first/ClassUtils.class", "source2": "second/ClassUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,34 +1,80 @@\n \n package org.apache.commons.lang3;\n \n-import java.util.Collections;\n-import java.util.HashMap;\n import java.lang.reflect.Modifier;\n import java.lang.reflect.Method;\n-import java.util.Iterator;\n import java.util.Collection;\n import java.util.HashSet;\n import java.util.LinkedHashSet;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Iterator;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.Map;\n \n public class ClassUtils\n {\n     public static final char PACKAGE_SEPARATOR_CHAR = '.';\n     public static final String PACKAGE_SEPARATOR;\n     public static final char INNER_CLASS_SEPARATOR_CHAR = '$';\n     public static final String INNER_CLASS_SEPARATOR;\n     private static final Map<String, Class<?>> namePrimitiveMap;\n     private static final Map<Class<?>, Class<?>> primitiveWrapperMap;\n     private static final Map<Class<?>, Class<?>> wrapperPrimitiveMap;\n     private static final Map<String, String> abbreviationMap;\n     private static final Map<String, String> reverseAbbreviationMap;\n     \n+    static {\n+        PACKAGE_SEPARATOR = String.valueOf('.');\n+        INNER_CLASS_SEPARATOR = String.valueOf('$');\n+        (namePrimitiveMap = new HashMap<String, Class<?>>()).put(\"boolean\", Boolean.TYPE);\n+        ClassUtils.namePrimitiveMap.put(\"byte\", Byte.TYPE);\n+        ClassUtils.namePrimitiveMap.put(\"char\", Character.TYPE);\n+        ClassUtils.namePrimitiveMap.put(\"short\", Short.TYPE);\n+        ClassUtils.namePrimitiveMap.put(\"int\", Integer.TYPE);\n+        ClassUtils.namePrimitiveMap.put(\"long\", Long.TYPE);\n+        ClassUtils.namePrimitiveMap.put(\"double\", Double.TYPE);\n+        ClassUtils.namePrimitiveMap.put(\"float\", Float.TYPE);\n+        ClassUtils.namePrimitiveMap.put(\"void\", Void.TYPE);\n+        (primitiveWrapperMap = new HashMap<Class<?>, Class<?>>()).put(Boolean.TYPE, Boolean.class);\n+        ClassUtils.primitiveWrapperMap.put(Byte.TYPE, Byte.class);\n+        ClassUtils.primitiveWrapperMap.put(Character.TYPE, Character.class);\n+        ClassUtils.primitiveWrapperMap.put(Short.TYPE, Short.class);\n+        ClassUtils.primitiveWrapperMap.put(Integer.TYPE, Integer.class);\n+        ClassUtils.primitiveWrapperMap.put(Long.TYPE, Long.class);\n+        ClassUtils.primitiveWrapperMap.put(Double.TYPE, Double.class);\n+        ClassUtils.primitiveWrapperMap.put(Float.TYPE, Float.class);\n+        ClassUtils.primitiveWrapperMap.put(Void.TYPE, Void.TYPE);\n+        wrapperPrimitiveMap = new HashMap<Class<?>, Class<?>>();\n+        for (final Map.Entry<Class<?>, Class<?>> entry : ClassUtils.primitiveWrapperMap.entrySet()) {\n+            final Class<?> primitiveClass = (Class<?>)entry.getKey();\n+            final Class<?> wrapperClass = (Class<?>)entry.getValue();\n+            if (!primitiveClass.equals(wrapperClass)) {\n+                ClassUtils.wrapperPrimitiveMap.put(wrapperClass, primitiveClass);\n+            }\n+        }\n+        final Map<String, String> m = new HashMap<String, String>();\n+        m.put(\"int\", \"I\");\n+        m.put(\"boolean\", \"Z\");\n+        m.put(\"float\", \"F\");\n+        m.put(\"long\", \"J\");\n+        m.put(\"short\", \"S\");\n+        m.put(\"byte\", \"B\");\n+        m.put(\"double\", \"D\");\n+        m.put(\"char\", \"C\");\n+        final Map<String, String> r = new HashMap<String, String>();\n+        for (final Map.Entry<String, String> e : m.entrySet()) {\n+            r.put(e.getValue(), e.getKey());\n+        }\n+        abbreviationMap = Collections.unmodifiableMap((Map<? extends String, ? extends String>)m);\n+        reverseAbbreviationMap = Collections.unmodifiableMap((Map<? extends String, ? extends String>)r);\n+    }\n+    \n     public static String getShortClassName(final Object object, final String valueIfNull) {\n         if (object == null) {\n             return valueIfNull;\n         }\n         return getShortClassName(object.getClass());\n     }\n     \n@@ -58,15 +104,15 @@\n         }\n         final int lastDotIdx = className.lastIndexOf(46);\n         final int innerIdx = className.indexOf(36, (lastDotIdx == -1) ? 0 : (lastDotIdx + 1));\n         String out = className.substring(lastDotIdx + 1);\n         if (innerIdx != -1) {\n             out = out.replace('$', '.');\n         }\n-        return out + (Object)arrayPrefix;\n+        return String.valueOf(out) + (Object)arrayPrefix;\n     }\n     \n     public static String getSimpleName(final Class<?> cls) {\n         return getSimpleName(cls, \"\");\n     }\n     \n     public static String getSimpleName(final Class<?> cls, final String valueIfNull) {\n@@ -185,17 +231,18 @@\n         final LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<Class<?>>();\n         getAllInterfaces(cls, interfacesFound);\n         return new ArrayList<Class<?>>(interfacesFound);\n     }\n     \n     private static void getAllInterfaces(Class<?> cls, final HashSet<Class<?>> interfacesFound) {\n         while (cls != null) {\n-            final Class<?>[] interfaces2;\n-            final Class<?>[] interfaces = interfaces2 = cls.getInterfaces();\n-            for (final Class<?> i : interfaces2) {\n+            final Class[] interfaces = cls.getInterfaces();\n+            Class[] array;\n+            for (int length = (array = interfaces).length, j = 0; j < length; ++j) {\n+                final Class<?> i = array[j];\n                 if (interfacesFound.add(i)) {\n                     getAllInterfaces(i, interfacesFound);\n                 }\n             }\n             cls = cls.getSuperclass();\n         }\n     }\n@@ -331,15 +378,15 @@\n     public static Class<?>[] primitivesToWrappers(final Class<?>... classes) {\n         if (classes == null) {\n             return null;\n         }\n         if (classes.length == 0) {\n             return classes;\n         }\n-        final Class<?>[] convertedClasses = new Class[classes.length];\n+        final Class[] convertedClasses = new Class[classes.length];\n         for (int i = 0; i < classes.length; ++i) {\n             convertedClasses[i] = primitiveToWrapper(classes[i]);\n         }\n         return convertedClasses;\n     }\n     \n     public static Class<?> wrapperToPrimitive(final Class<?> cls) {\n@@ -349,15 +396,15 @@\n     public static Class<?>[] wrappersToPrimitives(final Class<?>... classes) {\n         if (classes == null) {\n             return null;\n         }\n         if (classes.length == 0) {\n             return classes;\n         }\n-        final Class<?>[] convertedClasses = new Class[classes.length];\n+        final Class[] convertedClasses = new Class[classes.length];\n         for (int i = 0; i < classes.length; ++i) {\n             convertedClasses[i] = wrapperToPrimitive(classes[i]);\n         }\n         return convertedClasses;\n     }\n     \n     public static boolean isInnerClass(final Class<?> cls) {\n@@ -375,15 +422,15 @@\n             }\n             return clazz;\n         }\n         catch (final ClassNotFoundException ex) {\n             final int lastDotIndex = className.lastIndexOf(46);\n             if (lastDotIndex != -1) {\n                 try {\n-                    return getClass(classLoader, className.substring(0, lastDotIndex) + '$' + className.substring(lastDotIndex + 1), initialize);\n+                    return getClass(classLoader, String.valueOf(className.substring(0, lastDotIndex)) + '$' + className.substring(lastDotIndex + 1), initialize);\n                 }\n                 catch (final ClassNotFoundException ex2) {}\n             }\n             throw ex;\n         }\n     }\n     \n@@ -451,15 +498,15 @@\n     public static Class<?>[] toClass(final Object... array) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n-        final Class<?>[] classes = new Class[array.length];\n+        final Class[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; ++i) {\n             classes[i] = ((array[i] == null) ? null : array[i].getClass());\n         }\n         return classes;\n     }\n     \n     public static String getShortCanonicalName(final Object object, final String valueIfNull) {\n@@ -555,54 +602,8 @@\n     public static Iterable<Class<?>> hierarchy(final Class<?> type, final ClassUtils.Interfaces interfacesBehavior) {\n         final Iterable<Class<?>> classes = (Iterable<Class<?>>)new ClassUtils.ClassUtils$1((Class)type);\n         if (interfacesBehavior != ClassUtils.Interfaces.INCLUDE) {\n             return classes;\n         }\n         return (Iterable<Class<?>>)new ClassUtils.ClassUtils$2((Iterable)classes);\n     }\n-    \n-    static {\n-        PACKAGE_SEPARATOR = String.valueOf('.');\n-        INNER_CLASS_SEPARATOR = String.valueOf('$');\n-        (namePrimitiveMap = new HashMap<String, Class<?>>()).put(\"boolean\", Boolean.TYPE);\n-        ClassUtils.namePrimitiveMap.put(\"byte\", Byte.TYPE);\n-        ClassUtils.namePrimitiveMap.put(\"char\", Character.TYPE);\n-        ClassUtils.namePrimitiveMap.put(\"short\", Short.TYPE);\n-        ClassUtils.namePrimitiveMap.put(\"int\", Integer.TYPE);\n-        ClassUtils.namePrimitiveMap.put(\"long\", Long.TYPE);\n-        ClassUtils.namePrimitiveMap.put(\"double\", Double.TYPE);\n-        ClassUtils.namePrimitiveMap.put(\"float\", Float.TYPE);\n-        ClassUtils.namePrimitiveMap.put(\"void\", Void.TYPE);\n-        (primitiveWrapperMap = new HashMap<Class<?>, Class<?>>()).put(Boolean.TYPE, Boolean.class);\n-        ClassUtils.primitiveWrapperMap.put(Byte.TYPE, Byte.class);\n-        ClassUtils.primitiveWrapperMap.put(Character.TYPE, Character.class);\n-        ClassUtils.primitiveWrapperMap.put(Short.TYPE, Short.class);\n-        ClassUtils.primitiveWrapperMap.put(Integer.TYPE, Integer.class);\n-        ClassUtils.primitiveWrapperMap.put(Long.TYPE, Long.class);\n-        ClassUtils.primitiveWrapperMap.put(Double.TYPE, Double.class);\n-        ClassUtils.primitiveWrapperMap.put(Float.TYPE, Float.class);\n-        ClassUtils.primitiveWrapperMap.put(Void.TYPE, Void.TYPE);\n-        wrapperPrimitiveMap = new HashMap<Class<?>, Class<?>>();\n-        for (final Map.Entry<Class<?>, Class<?>> entry : ClassUtils.primitiveWrapperMap.entrySet()) {\n-            final Class<?> primitiveClass = (Class<?>)entry.getKey();\n-            final Class<?> wrapperClass = (Class<?>)entry.getValue();\n-            if (!primitiveClass.equals(wrapperClass)) {\n-                ClassUtils.wrapperPrimitiveMap.put(wrapperClass, primitiveClass);\n-            }\n-        }\n-        final Map<String, String> m = new HashMap<String, String>();\n-        m.put(\"int\", \"I\");\n-        m.put(\"boolean\", \"Z\");\n-        m.put(\"float\", \"F\");\n-        m.put(\"long\", \"J\");\n-        m.put(\"short\", \"S\");\n-        m.put(\"byte\", \"B\");\n-        m.put(\"double\", \"D\");\n-        m.put(\"char\", \"C\");\n-        final Map<String, String> r = new HashMap<String, String>();\n-        for (final Map.Entry<String, String> e : m.entrySet()) {\n-            r.put(e.getValue(), e.getKey());\n-        }\n-        abbreviationMap = Collections.unmodifiableMap((Map<? extends String, ? extends String>)m);\n-        reverseAbbreviationMap = Collections.unmodifiableMap((Map<? extends String, ? extends String>)r);\n-    }\n }\n"}]}
