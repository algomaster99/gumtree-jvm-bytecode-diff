{"diffoscope-json-version": 1, "source1": "first/BOMInputStream.class", "source2": "second/BOMInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -25,49 +25,48 @@\n     private int markFbIndex;\n     \n     public static BOMInputStream.Builder builder() {\n         return new BOMInputStream.Builder();\n     }\n     \n     @Deprecated\n-    public BOMInputStream(final InputStream delegate) {\n-        this(delegate, false, BOMInputStream.Builder.access$000());\n+    public BOMInputStream(final InputStream inputStream) {\n+        this(inputStream, false, BOMInputStream.Builder.access$000());\n     }\n     \n     @Deprecated\n-    public BOMInputStream(final InputStream delegate, final boolean include) {\n-        this(delegate, include, BOMInputStream.Builder.access$000());\n+    public BOMInputStream(final InputStream inputStream, final boolean b) {\n+        this(inputStream, b, BOMInputStream.Builder.access$000());\n     }\n     \n     @Deprecated\n-    public BOMInputStream(final InputStream delegate, final boolean include, final ByteOrderMark... boms) {\n-        super(delegate);\n-        if (IOUtils.length((Object[])boms) == 0) {\n+    public BOMInputStream(final InputStream inputStream, final boolean include, final ByteOrderMark... a) {\n+        super(inputStream);\n+        if (IOUtils.length((Object[])a) == 0) {\n             throw new IllegalArgumentException(\"No BOMs specified\");\n         }\n         this.include = include;\n-        final List<ByteOrderMark> list = Arrays.asList(boms);\n+        final List<ByteOrderMark> list = Arrays.asList(a);\n         list.sort(BOMInputStream.ByteOrderMarkLengthComparator);\n         this.boms = list;\n     }\n     \n     @Deprecated\n-    public BOMInputStream(final InputStream delegate, final ByteOrderMark... boms) {\n-        this(delegate, false, boms);\n+    public BOMInputStream(final InputStream inputStream, final ByteOrderMark... array) {\n+        this(inputStream, false, array);\n     }\n     \n     private ByteOrderMark find() {\n         return this.boms.stream().filter(this::matches).findFirst().orElse(null);\n     }\n     \n     public ByteOrderMark getBOM() throws IOException {\n         if (this.firstBytes == null) {\n             this.fbLength = 0;\n-            final int maxBomSize = ((ByteOrderMark)this.boms.get(0)).length();\n-            this.firstBytes = new int[maxBomSize];\n+            this.firstBytes = new int[((ByteOrderMark)this.boms.get(0)).length()];\n             for (int i = 0; i < this.firstBytes.length; ++i) {\n                 this.firstBytes[i] = this.in.read();\n                 ++this.fbLength;\n                 if (this.firstBytes[i] < 0) {\n                     break;\n                 }\n             }\n@@ -89,55 +88,55 @@\n         return (this.byteOrderMark == null) ? null : this.byteOrderMark.getCharsetName();\n     }\n     \n     public boolean hasBOM() throws IOException {\n         return this.getBOM() != null;\n     }\n     \n-    public boolean hasBOM(final ByteOrderMark bom) throws IOException {\n-        if (!this.boms.contains(bom)) {\n-            throw new IllegalArgumentException(\"Stream not configured to detect \" + bom);\n+    public boolean hasBOM(final ByteOrderMark byteOrderMark) throws IOException {\n+        if (!this.boms.contains(byteOrderMark)) {\n+            throw new IllegalArgumentException(\"Stream not configured to detect \" + byteOrderMark);\n         }\n-        return Objects.equals(this.getBOM(), bom);\n+        return Objects.equals(this.getBOM(), byteOrderMark);\n     }\n     \n     public synchronized void mark(final int readlimit) {\n         this.markFbIndex = this.fbIndex;\n         this.markedAtStart = (this.firstBytes == null);\n         this.in.mark(readlimit);\n     }\n     \n-    private boolean matches(final ByteOrderMark bom) {\n-        for (int i = 0; i < bom.length(); ++i) {\n-            if (bom.get(i) != this.firstBytes[i]) {\n+    private boolean matches(final ByteOrderMark byteOrderMark) {\n+        for (int i = 0; i < byteOrderMark.length(); ++i) {\n+            if (byteOrderMark.get(i) != this.firstBytes[i]) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n     public int read() throws IOException {\n-        final int b = this.readFirstBytes();\n-        return (b >= 0) ? b : this.in.read();\n+        final int firstBytes = this.readFirstBytes();\n+        return (firstBytes >= 0) ? firstBytes : this.in.read();\n     }\n     \n-    public int read(final byte[] buf) throws IOException {\n-        return this.read(buf, 0, buf.length);\n+    public int read(final byte[] array) throws IOException {\n+        return this.read(array, 0, array.length);\n     }\n     \n-    public int read(final byte[] buf, int off, int len) throws IOException {\n-        int firstCount = 0;\n-        for (int b = 0; len > 0 && b >= 0; --len, ++firstCount) {\n-            b = this.readFirstBytes();\n-            if (b >= 0) {\n-                buf[off++] = (byte)(b & 0xFF);\n+    public int read(final byte[] b, int off, int len) throws IOException {\n+        int n = 0;\n+        for (int firstBytes = 0; len > 0 && firstBytes >= 0; --len, ++n) {\n+            firstBytes = this.readFirstBytes();\n+            if (firstBytes >= 0) {\n+                b[off++] = (byte)(firstBytes & 0xFF);\n             }\n         }\n-        final int secondCount = this.in.read(buf, off, len);\n-        return (secondCount < 0) ? ((firstCount > 0) ? firstCount : -1) : (firstCount + secondCount);\n+        final int read = this.in.read(b, off, len);\n+        return (read < 0) ? ((n > 0) ? n : -1) : (n + read);\n     }\n     \n     private int readFirstBytes() throws IOException {\n         this.getBOM();\n         return (this.fbIndex < this.fbLength) ? this.firstBytes[this.fbIndex++] : -1;\n     }\n     \n@@ -146,16 +145,16 @@\n         if (this.markedAtStart) {\n             this.firstBytes = null;\n         }\n         this.in.reset();\n     }\n     \n     public long skip(final long n) throws IOException {\n-        int skipped;\n-        for (skipped = 0; n > skipped && this.readFirstBytes() >= 0; ++skipped) {}\n-        return this.in.skip(n - (long)skipped) + skipped;\n+        int n2;\n+        for (n2 = 0; n > n2 && this.readFirstBytes() >= 0; ++n2) {}\n+        return this.in.skip(n - (long)n2) + n2;\n     }\n     \n     static {\n         ByteOrderMarkLengthComparator = Comparator.comparing((Function<? super ByteOrderMark, ? extends Comparable>)ByteOrderMark::length).reversed();\n     }\n }\n"}]}
