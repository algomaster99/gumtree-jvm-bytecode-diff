{"diffoscope-json-version": 1, "source1": "first/ArjArchiveInputStream.class", "source2": "second/ArjArchiveInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -66,23 +66,44 @@\n     private int read32(final DataInputStream dataIn) throws IOException {\n         final int value = dataIn.readInt();\n         this.count(4);\n         return Integer.reverseBytes(value);\n     }\n     \n     private String readString(final DataInputStream dataIn) throws IOException {\n-        try (final ByteArrayOutputStream buffer = new ByteArrayOutputStream()) {\n-            int nextByte;\n-            while ((nextByte = dataIn.readUnsignedByte()) != 0) {\n-                buffer.write(nextByte);\n+        Throwable t = null;\n+        try {\n+            final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+            try {\n+                int nextByte;\n+                while ((nextByte = dataIn.readUnsignedByte()) != 0) {\n+                    buffer.write(nextByte);\n+                }\n+                if (this.charsetName != null) {\n+                    return buffer.toString(this.charsetName);\n+                }\n+                return buffer.toString();\n             }\n-            if (this.charsetName != null) {\n-                return buffer.toString(this.charsetName);\n+            finally {\n+                if (buffer != null) {\n+                    buffer.close();\n+                }\n+            }\n+        }\n+        finally {\n+            if (t == null) {\n+                final Throwable exception;\n+                t = exception;\n+            }\n+            else {\n+                final Throwable exception;\n+                if (t != exception) {\n+                    t.addSuppressed(exception);\n+                }\n             }\n-            return buffer.toString();\n         }\n     }\n     \n     private byte[] readRange(final InputStream in, final int len) throws IOException {\n         final byte[] b = IOUtils.readRange(in, len);\n         this.count(b.length);\n         if (b.length < len) {\n@@ -169,53 +190,85 @@\n     }\n     \n     private LocalFileHeader readLocalFileHeader() throws IOException {\n         final byte[] basicHeaderBytes = this.readHeader();\n         if (basicHeaderBytes == null) {\n             return null;\n         }\n-        try (final DataInputStream basicHeader = new DataInputStream(new ByteArrayInputStream(basicHeaderBytes))) {\n-            final int firstHeaderSize = basicHeader.readUnsignedByte();\n-            final byte[] firstHeaderBytes = this.readRange(basicHeader, firstHeaderSize - 1);\n-            this.pushedBackBytes((long)firstHeaderBytes.length);\n-            try (final DataInputStream firstHeader = new DataInputStream(new ByteArrayInputStream(firstHeaderBytes))) {\n-                final LocalFileHeader localFileHeader = new LocalFileHeader();\n-                localFileHeader.archiverVersionNumber = firstHeader.readUnsignedByte();\n-                localFileHeader.minVersionToExtract = firstHeader.readUnsignedByte();\n-                localFileHeader.hostOS = firstHeader.readUnsignedByte();\n-                localFileHeader.arjFlags = firstHeader.readUnsignedByte();\n-                localFileHeader.method = firstHeader.readUnsignedByte();\n-                localFileHeader.fileType = firstHeader.readUnsignedByte();\n-                localFileHeader.reserved = firstHeader.readUnsignedByte();\n-                localFileHeader.dateTimeModified = this.read32(firstHeader);\n-                localFileHeader.compressedSize = (0xFFFFFFFFL & (long)this.read32(firstHeader));\n-                localFileHeader.originalSize = (0xFFFFFFFFL & (long)this.read32(firstHeader));\n-                localFileHeader.originalCrc32 = (0xFFFFFFFFL & (long)this.read32(firstHeader));\n-                localFileHeader.fileSpecPosition = this.read16(firstHeader);\n-                localFileHeader.fileAccessMode = this.read16(firstHeader);\n-                this.pushedBackBytes(20L);\n-                localFileHeader.firstChapter = firstHeader.readUnsignedByte();\n-                localFileHeader.lastChapter = firstHeader.readUnsignedByte();\n-                this.readExtraData(firstHeaderSize, firstHeader, localFileHeader);\n-                localFileHeader.name = this.readString(basicHeader);\n-                localFileHeader.comment = this.readString(basicHeader);\n-                final ArrayList<byte[]> extendedHeaders = new ArrayList<byte[]>();\n-                int extendedHeaderSize;\n-                while ((extendedHeaderSize = this.read16(this.in)) > 0) {\n-                    final byte[] extendedHeaderBytes = this.readRange(this.in, extendedHeaderSize);\n-                    final long extendedHeaderCrc32 = 0xFFFFFFFFL & (long)this.read32(this.in);\n-                    final CRC32 crc32 = new CRC32();\n-                    crc32.update(extendedHeaderBytes);\n-                    if (extendedHeaderCrc32 != crc32.getValue()) {\n-                        throw new IOException(\"Extended header CRC32 verification failure\");\n+        Throwable t = null;\n+        try {\n+            final DataInputStream basicHeader = new DataInputStream(new ByteArrayInputStream(basicHeaderBytes));\n+            try {\n+                final int firstHeaderSize = basicHeader.readUnsignedByte();\n+                final byte[] firstHeaderBytes = this.readRange(basicHeader, firstHeaderSize - 1);\n+                this.pushedBackBytes((long)firstHeaderBytes.length);\n+                try {\n+                    final DataInputStream firstHeader = new DataInputStream(new ByteArrayInputStream(firstHeaderBytes));\n+                    try {\n+                        final LocalFileHeader localFileHeader = new LocalFileHeader();\n+                        localFileHeader.archiverVersionNumber = firstHeader.readUnsignedByte();\n+                        localFileHeader.minVersionToExtract = firstHeader.readUnsignedByte();\n+                        localFileHeader.hostOS = firstHeader.readUnsignedByte();\n+                        localFileHeader.arjFlags = firstHeader.readUnsignedByte();\n+                        localFileHeader.method = firstHeader.readUnsignedByte();\n+                        localFileHeader.fileType = firstHeader.readUnsignedByte();\n+                        localFileHeader.reserved = firstHeader.readUnsignedByte();\n+                        localFileHeader.dateTimeModified = this.read32(firstHeader);\n+                        localFileHeader.compressedSize = (0xFFFFFFFFL & (long)this.read32(firstHeader));\n+                        localFileHeader.originalSize = (0xFFFFFFFFL & (long)this.read32(firstHeader));\n+                        localFileHeader.originalCrc32 = (0xFFFFFFFFL & (long)this.read32(firstHeader));\n+                        localFileHeader.fileSpecPosition = this.read16(firstHeader);\n+                        localFileHeader.fileAccessMode = this.read16(firstHeader);\n+                        this.pushedBackBytes(20L);\n+                        localFileHeader.firstChapter = firstHeader.readUnsignedByte();\n+                        localFileHeader.lastChapter = firstHeader.readUnsignedByte();\n+                        this.readExtraData(firstHeaderSize, firstHeader, localFileHeader);\n+                        localFileHeader.name = this.readString(basicHeader);\n+                        localFileHeader.comment = this.readString(basicHeader);\n+                        final ArrayList<byte[]> extendedHeaders = new ArrayList<byte[]>();\n+                        int extendedHeaderSize;\n+                        while ((extendedHeaderSize = this.read16(this.in)) > 0) {\n+                            final byte[] extendedHeaderBytes = this.readRange(this.in, extendedHeaderSize);\n+                            final long extendedHeaderCrc32 = 0xFFFFFFFFL & (long)this.read32(this.in);\n+                            final CRC32 crc32 = new CRC32();\n+                            crc32.update(extendedHeaderBytes);\n+                            if (extendedHeaderCrc32 != crc32.getValue()) {\n+                                throw new IOException(\"Extended header CRC32 verification failure\");\n+                            }\n+                            extendedHeaders.add(extendedHeaderBytes);\n+                        }\n+                        localFileHeader.extendedHeaders = extendedHeaders.toArray(new byte[0][]);\n+                        return localFileHeader;\n+                    }\n+                    finally {\n+                        if (firstHeader != null) {\n+                            firstHeader.close();\n+                        }\n                     }\n-                    extendedHeaders.add(extendedHeaderBytes);\n                 }\n-                localFileHeader.extendedHeaders = extendedHeaders.toArray(new byte[0][]);\n-                return localFileHeader;\n+                finally {\n+                    return;\n+                }\n+            }\n+            finally {\n+                if (basicHeader != null) {\n+                    basicHeader.close();\n+                }\n+            }\n+        }\n+        finally {\n+            if (t == null) {\n+                final Throwable exception;\n+                t = exception;\n+            }\n+            else {\n+                final Throwable exception;\n+                if (t != exception) {\n+                    t.addSuppressed(exception);\n+                }\n             }\n         }\n     }\n     \n     private void readExtraData(final int firstHeaderSize, final DataInputStream firstHeader, final LocalFileHeader localFileHeader) throws IOException {\n         if (firstHeaderSize >= 33) {\n             localFileHeader.extendedFilePosition = this.read32(firstHeader);\n"}]}
