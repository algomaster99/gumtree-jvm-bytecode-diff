{"diffoscope-json-version": 1, "source1": "first/TreeData.class", "source2": "second/TreeData.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -12,80 +12,79 @@\n     private final ImmutableNode root;\n     private final Map<ImmutableNode, ImmutableNode> parentMapping;\n     private final Map<ImmutableNode, ImmutableNode> replacementMapping;\n     private final Map<ImmutableNode, ImmutableNode> inverseReplacementMapping;\n     private final NodeTracker nodeTracker;\n     private final ReferenceTracker referenceTracker;\n     \n-    public TreeData(final ImmutableNode root, final Map<ImmutableNode, ImmutableNode> parentMapping, final Map<ImmutableNode, ImmutableNode> replacements, final NodeTracker tracker, final ReferenceTracker refTracker) {\n+    public TreeData(final ImmutableNode root, final Map<ImmutableNode, ImmutableNode> parentMapping, final Map<ImmutableNode, ImmutableNode> replacementMapping, final NodeTracker nodeTracker, final ReferenceTracker referenceTracker) {\n         this.root = root;\n         this.parentMapping = parentMapping;\n-        this.replacementMapping = replacements;\n-        this.inverseReplacementMapping = this.createInverseMapping(replacements);\n-        this.nodeTracker = tracker;\n-        this.referenceTracker = refTracker;\n+        this.replacementMapping = replacementMapping;\n+        this.inverseReplacementMapping = this.createInverseMapping(replacementMapping);\n+        this.nodeTracker = nodeTracker;\n+        this.referenceTracker = referenceTracker;\n     }\n     \n     public ImmutableNode getRootNode() {\n         return this.root;\n     }\n     \n     public NodeTracker getNodeTracker() {\n         return this.nodeTracker;\n     }\n     \n     public ReferenceTracker getReferenceTracker() {\n         return this.referenceTracker;\n     }\n     \n-    public ImmutableNode getParent(final ImmutableNode node) {\n-        if (node == this.getRootNode()) {\n+    public ImmutableNode getParent(final ImmutableNode obj) {\n+        if (obj == this.getRootNode()) {\n             return null;\n         }\n-        final ImmutableNode org = handleReplacements(node, this.inverseReplacementMapping);\n-        final ImmutableNode parent = (ImmutableNode)this.parentMapping.get(org);\n-        if (parent == null) {\n-            throw new IllegalArgumentException(\"Cannot determine parent! \" + node + \" is not part of this model.\");\n+        final ImmutableNode immutableNode = (ImmutableNode)this.parentMapping.get(handleReplacements(obj, this.inverseReplacementMapping));\n+        if (immutableNode == null) {\n+            throw new IllegalArgumentException(\"Cannot determine parent! \" + obj + \" is not part of this model.\");\n         }\n-        return handleReplacements(parent, this.replacementMapping);\n+        return handleReplacements(immutableNode, this.replacementMapping);\n     }\n     \n     public Map<ImmutableNode, ImmutableNode> copyParentMapping() {\n         return new HashMap<ImmutableNode, ImmutableNode>(this.parentMapping);\n     }\n     \n     public Map<ImmutableNode, ImmutableNode> copyReplacementMapping() {\n         return new HashMap<ImmutableNode, ImmutableNode>(this.replacementMapping);\n     }\n     \n-    public TreeData updateNodeTracker(final NodeTracker newTracker) {\n-        return new TreeData(this.root, this.parentMapping, this.replacementMapping, newTracker, this.referenceTracker);\n+    public TreeData updateNodeTracker(final NodeTracker nodeTracker) {\n+        return new TreeData(this.root, this.parentMapping, this.replacementMapping, nodeTracker, this.referenceTracker);\n     }\n     \n-    public TreeData updateReferenceTracker(final ReferenceTracker newTracker) {\n-        return new TreeData(this.root, this.parentMapping, this.replacementMapping, this.nodeTracker, newTracker);\n+    public TreeData updateReferenceTracker(final ReferenceTracker referenceTracker) {\n+        return new TreeData(this.root, this.parentMapping, this.replacementMapping, this.nodeTracker, referenceTracker);\n     }\n     \n-    public Object getReference(final ImmutableNode node) {\n-        return this.getReferenceTracker().getReference(node);\n+    public Object getReference(final ImmutableNode immutableNode) {\n+        return this.getReferenceTracker().getReference(immutableNode);\n     }\n     \n     public List<Object> removedReferences() {\n         return this.getReferenceTracker().getRemovedReferences();\n     }\n     \n-    private static ImmutableNode handleReplacements(final ImmutableNode replace, final Map<ImmutableNode, ImmutableNode> mapping) {\n-        ImmutableNode node = replace;\n-        ImmutableNode org;\n+    private static ImmutableNode handleReplacements(final ImmutableNode immutableNode, final Map<ImmutableNode, ImmutableNode> map) {\n+        ImmutableNode immutableNode2 = immutableNode;\n+        ImmutableNode immutableNode3;\n         do {\n-            org = mapping.get(node);\n-            if (org != null) {\n-                node = org;\n+            immutableNode3 = map.get(immutableNode2);\n+            if (immutableNode3 != null) {\n+                immutableNode2 = immutableNode3;\n             }\n-        } while (org != null);\n-        return node;\n+        } while (immutableNode3 != null);\n+        return immutableNode2;\n     }\n     \n-    private Map<ImmutableNode, ImmutableNode> createInverseMapping(final Map<ImmutableNode, ImmutableNode> replacements) {\n-        return replacements.entrySet().stream().collect(Collectors.toMap((Function<? super Object, ? extends ImmutableNode>)Map.Entry::getValue, (Function<? super Object, ? extends ImmutableNode>)Map.Entry::getKey));\n+    private Map<ImmutableNode, ImmutableNode> createInverseMapping(final Map<ImmutableNode, ImmutableNode> map) {\n+        return map.entrySet().stream().collect(Collectors.toMap((Function<? super Object, ? extends ImmutableNode>)Map.Entry::getValue, (Function<? super Object, ? extends ImmutableNode>)Map.Entry::getKey));\n     }\n }\n"}]}
