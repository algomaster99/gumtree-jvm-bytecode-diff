{"diffoscope-json-version": 1, "source1": "first/UniquePropertiesCheck.class", "source2": "second/UniquePropertiesCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -23,48 +23,45 @@\n     private static final Pattern SPACE_PATTERN;\n     \n     public UniquePropertiesCheck() {\n         this.setFileExtensions(new String[] { \"properties\" });\n     }\n     \n     protected void processFiltered(final File file, final FileText fileText) {\n-        final UniquePropertiesCheck.UniqueProperties properties = new UniquePropertiesCheck.UniqueProperties();\n+        final UniquePropertiesCheck.UniqueProperties uniqueProperties = new UniquePropertiesCheck.UniqueProperties();\n         try (final InputStream inputStream = Files.newInputStream(file.toPath(), new OpenOption[0])) {\n-            properties.load(inputStream);\n+            uniqueProperties.load(inputStream);\n         }\n         catch (final IOException ex) {\n             this.log(1, \"unable.open.cause\", new Object[] { file.getPath(), ex.getLocalizedMessage() });\n         }\n-        for (final Map.Entry<String, AtomicInteger> duplication : properties.getDuplicatedKeys().entrySet()) {\n-            final String keyName = (String)duplication.getKey();\n-            final int lineNumber = getLineNumber(fileText, keyName);\n-            this.log(lineNumber, \"properties.duplicate.property\", new Object[] { keyName, Integer.valueOf(((AtomicInteger)duplication.getValue()).get() + 1) });\n+        for (final Map.Entry entry : uniqueProperties.getDuplicatedKeys().entrySet()) {\n+            final String s = (String)entry.getKey();\n+            this.log(getLineNumber(fileText, s), \"properties.duplicate.property\", new Object[] { s, Integer.valueOf(((AtomicInteger)entry.getValue()).get() + 1) });\n         }\n     }\n     \n-    private static int getLineNumber(final FileText fileText, final String keyName) {\n-        final Pattern keyPattern = getKeyPattern(keyName);\n-        int lineNumber = 1;\n+    private static int getLineNumber(final FileText fileText, final String s) {\n+        final Pattern keyPattern = getKeyPattern(s);\n+        int n = 1;\n         final Matcher matcher = keyPattern.matcher(\"\");\n-        for (int index = 0; index < fileText.size(); ++index) {\n-            final String line = fileText.get(index);\n-            matcher.reset(line);\n+        for (int i = 0; i < fileText.size(); ++i) {\n+            matcher.reset(fileText.get(i));\n             if (matcher.matches()) {\n                 break;\n             }\n-            ++lineNumber;\n+            ++n;\n         }\n-        if (lineNumber > fileText.size() - 1) {\n-            lineNumber = 1;\n+        if (n > fileText.size() - 1) {\n+            n = 1;\n         }\n-        return lineNumber;\n+        return n;\n     }\n     \n-    private static Pattern getKeyPattern(final String keyName) {\n-        final String keyPatternString = \"^\" + UniquePropertiesCheck.SPACE_PATTERN.matcher(keyName).replaceAll(Matcher.quoteReplacement(\"\\\\\\\\ \")) + \"[\\\\s:=].*$\";\n-        return Pattern.compile(keyPatternString);\n+    private static Pattern getKeyPattern(final String input) {\n+        return Pattern.compile(\"^\" + UniquePropertiesCheck.SPACE_PATTERN.matcher(input).replaceAll(Matcher.quoteReplacement(\"\\\\\\\\ \")) + \"[\\\\s:=].*$\");\n     }\n     \n     static {\n         SPACE_PATTERN = Pattern.compile(\" \");\n     }\n }\n"}]}
