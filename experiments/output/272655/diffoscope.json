{"diffoscope-json-version": 1, "source1": "first/UnusedLocalVariableCheck.class", "source2": "second/UnusedLocalVariableCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -58,300 +58,290 @@\n         return this.getDefaultTokens();\n     }\n     \n     public int[] getRequiredTokens() {\n         return this.getDefaultTokens();\n     }\n     \n-    public void beginTree(final DetailAST root) {\n+    public void beginTree(final DetailAST detailAST) {\n         this.variables.clear();\n         this.typeDeclarations.clear();\n         this.typeDeclAstToTypeDeclDesc.clear();\n         this.anonInnerAstToTypeDeclDesc.clear();\n         this.anonInnerClassHolders.clear();\n         this.packageName = null;\n         this.depth = 0;\n     }\n     \n-    public void visitToken(final DetailAST ast) {\n-        final int type = ast.getType();\n+    public void visitToken(final DetailAST detailAST) {\n+        final int type = detailAST.getType();\n         if (type == 59) {\n-            visitDotToken(ast, this.variables);\n+            visitDotToken(detailAST, this.variables);\n         }\n         else if (type == 10) {\n-            this.visitVariableDefToken(ast);\n+            this.visitVariableDefToken(detailAST);\n         }\n         else if (type == 58) {\n-            visitIdentToken(ast, this.variables);\n+            visitIdentToken(detailAST, this.variables);\n         }\n-        else if (isInsideLocalAnonInnerClass(ast)) {\n-            this.visitLocalAnonInnerClass(ast);\n+        else if (isInsideLocalAnonInnerClass(detailAST)) {\n+            this.visitLocalAnonInnerClass(detailAST);\n         }\n         else if (TokenUtil.isTypeDeclaration(type)) {\n-            this.visitTypeDeclarationToken(ast);\n+            this.visitTypeDeclarationToken(detailAST);\n         }\n         else if (type == 16) {\n-            this.packageName = CheckUtil.extractQualifiedName(ast.getFirstChild().getNextSibling());\n+            this.packageName = CheckUtil.extractQualifiedName(detailAST.getFirstChild().getNextSibling());\n         }\n     }\n     \n-    public void leaveToken(final DetailAST ast) {\n-        if (TokenUtil.isOfType(ast, UnusedLocalVariableCheck.SCOPES)) {\n-            this.logViolations(ast, this.variables);\n+    public void leaveToken(final DetailAST detailAST) {\n+        if (TokenUtil.isOfType(detailAST, UnusedLocalVariableCheck.SCOPES)) {\n+            this.logViolations(detailAST, this.variables);\n         }\n-        else if (ast.getType() == 1) {\n+        else if (detailAST.getType() == 1) {\n             this.leaveCompilationUnit();\n         }\n-        else if (isNonLocalTypeDeclaration(ast)) {\n+        else if (isNonLocalTypeDeclaration(detailAST)) {\n             --this.depth;\n             this.typeDeclarations.pop();\n         }\n     }\n     \n-    private static void visitDotToken(final DetailAST dotAst, final Deque<UnusedLocalVariableCheck.VariableDesc> variablesStack) {\n-        if (dotAst.getParent().getType() != 136 && shouldCheckIdentTokenNestedUnderDot(dotAst)) {\n-            checkIdentifierAst(dotAst.findFirstToken(58), variablesStack);\n+    private static void visitDotToken(final DetailAST detailAST, final Deque<UnusedLocalVariableCheck.VariableDesc> deque) {\n+        if (detailAST.getParent().getType() != 136 && shouldCheckIdentTokenNestedUnderDot(detailAST)) {\n+            checkIdentifierAst(detailAST.findFirstToken(58), deque);\n         }\n     }\n     \n-    private void visitVariableDefToken(final DetailAST varDefAst) {\n-        addLocalVariables(varDefAst, this.variables);\n-        this.addInstanceOrClassVar(varDefAst);\n+    private void visitVariableDefToken(final DetailAST detailAST) {\n+        addLocalVariables(detailAST, this.variables);\n+        this.addInstanceOrClassVar(detailAST);\n     }\n     \n-    private static void visitIdentToken(final DetailAST identAst, final Deque<UnusedLocalVariableCheck.VariableDesc> variablesStack) {\n-        final DetailAST parent = identAst.getParent();\n-        final boolean isMethodReferenceMethodName = parent.getType() == 180 && parent.getFirstChild() != identAst;\n-        final boolean isConstructorReference = parent.getType() == 180 && parent.getLastChild().getType() == 136;\n-        final boolean isNestedClassInitialization = TokenUtil.isOfType(identAst.getNextSibling(), new int[] { 136 }) && parent.getType() == 59;\n-        if (isNestedClassInitialization || (!isMethodReferenceMethodName && !isConstructorReference && !TokenUtil.isOfType(parent, UnusedLocalVariableCheck.UNACCEPTABLE_PARENT_OF_IDENT))) {\n-            checkIdentifierAst(identAst, variablesStack);\n+    private static void visitIdentToken(final DetailAST detailAST, final Deque<UnusedLocalVariableCheck.VariableDesc> deque) {\n+        final DetailAST parent = detailAST.getParent();\n+        final boolean b = parent.getType() == 180 && parent.getFirstChild() != detailAST;\n+        final boolean b2 = parent.getType() == 180 && parent.getLastChild().getType() == 136;\n+        if ((TokenUtil.isOfType(detailAST.getNextSibling(), new int[] { 136 }) && parent.getType() == 59) || (!b && !b2 && !TokenUtil.isOfType(parent, UnusedLocalVariableCheck.UNACCEPTABLE_PARENT_OF_IDENT))) {\n+            checkIdentifierAst(detailAST, deque);\n         }\n     }\n     \n-    private void visitTypeDeclarationToken(final DetailAST typeDeclAst) {\n-        if (isNonLocalTypeDeclaration(typeDeclAst)) {\n-            final String qualifiedName = this.getQualifiedTypeDeclarationName(typeDeclAst);\n-            final UnusedLocalVariableCheck.TypeDeclDesc currTypeDecl = new UnusedLocalVariableCheck.TypeDeclDesc(qualifiedName, this.depth, typeDeclAst);\n+    private void visitTypeDeclarationToken(final DetailAST detailAST) {\n+        if (isNonLocalTypeDeclaration(detailAST)) {\n+            final UnusedLocalVariableCheck.TypeDeclDesc typeDeclDesc = new UnusedLocalVariableCheck.TypeDeclDesc(this.getQualifiedTypeDeclarationName(detailAST), this.depth, detailAST);\n             ++this.depth;\n-            this.typeDeclarations.push(currTypeDecl);\n-            this.typeDeclAstToTypeDeclDesc.put(typeDeclAst, currTypeDecl);\n+            this.typeDeclarations.push(typeDeclDesc);\n+            this.typeDeclAstToTypeDeclDesc.put(detailAST, typeDeclDesc);\n         }\n     }\n     \n-    private void visitLocalAnonInnerClass(final DetailAST literalNewAst) {\n-        this.anonInnerAstToTypeDeclDesc.put(literalNewAst, this.typeDeclarations.peek());\n-        this.anonInnerClassHolders.add(getBlockContainingLocalAnonInnerClass(literalNewAst));\n+    private void visitLocalAnonInnerClass(final DetailAST detailAST) {\n+        this.anonInnerAstToTypeDeclDesc.put(detailAST, this.typeDeclarations.peek());\n+        this.anonInnerClassHolders.add(getBlockContainingLocalAnonInnerClass(detailAST));\n     }\n     \n-    private static boolean isInsideLocalAnonInnerClass(final DetailAST literalNewAst) {\n-        boolean result = false;\n-        final DetailAST lastChild = literalNewAst.getLastChild();\n+    private static boolean isInsideLocalAnonInnerClass(final DetailAST detailAST) {\n+        boolean b = false;\n+        final DetailAST lastChild = detailAST.getLastChild();\n         if (lastChild != null && lastChild.getType() == 6) {\n-            for (DetailAST currentAst = literalNewAst; !TokenUtil.isTypeDeclaration(currentAst.getType()); currentAst = currentAst.getParent()) {\n-                if (currentAst.getType() == 7) {\n-                    result = true;\n+            for (DetailAST parent = detailAST; !TokenUtil.isTypeDeclaration(parent.getType()); parent = parent.getParent()) {\n+                if (parent.getType() == 7) {\n+                    b = true;\n                     break;\n                 }\n             }\n         }\n-        return result;\n+        return b;\n     }\n     \n-    private void logViolations(final DetailAST scopeAst, final Deque<UnusedLocalVariableCheck.VariableDesc> variablesStack) {\n-        while (!variablesStack.isEmpty() && ((UnusedLocalVariableCheck.VariableDesc)variablesStack.peek()).getScope() == scopeAst) {\n-            final UnusedLocalVariableCheck.VariableDesc variableDesc = (UnusedLocalVariableCheck.VariableDesc)variablesStack.pop();\n+    private void logViolations(final DetailAST detailAST, final Deque<UnusedLocalVariableCheck.VariableDesc> deque) {\n+        while (!deque.isEmpty() && ((UnusedLocalVariableCheck.VariableDesc)deque.peek()).getScope() == detailAST) {\n+            final UnusedLocalVariableCheck.VariableDesc variableDesc = (UnusedLocalVariableCheck.VariableDesc)deque.pop();\n             if (!variableDesc.isUsed() && !variableDesc.isInstVarOrClassVar()) {\n-                final DetailAST typeAst = variableDesc.getTypeAst();\n-                this.log(typeAst, \"unused.local.var\", new Object[] { variableDesc.getName() });\n+                this.log(variableDesc.getTypeAst(), \"unused.local.var\", new Object[] { variableDesc.getName() });\n             }\n         }\n     }\n     \n     private void leaveCompilationUnit() {\n-        this.anonInnerClassHolders.forEach(holder -> this.iterateOverBlockContainingLocalAnonInnerClass(holder, new ArrayDeque<UnusedLocalVariableCheck.VariableDesc>()));\n+        this.anonInnerClassHolders.forEach(detailAST -> this.iterateOverBlockContainingLocalAnonInnerClass(detailAST, new ArrayDeque<UnusedLocalVariableCheck.VariableDesc>()));\n     }\n     \n-    private static boolean isNonLocalTypeDeclaration(final DetailAST typeDeclAst) {\n-        return TokenUtil.isTypeDeclaration(typeDeclAst.getType()) && typeDeclAst.getParent().getType() != 7;\n+    private static boolean isNonLocalTypeDeclaration(final DetailAST detailAST) {\n+        return TokenUtil.isTypeDeclaration(detailAST.getType()) && detailAST.getParent().getType() != 7;\n     }\n     \n-    private static DetailAST getBlockContainingLocalAnonInnerClass(final DetailAST literalNewAst) {\n-        DetailAST currentAst = literalNewAst;\n-        DetailAST result = null;\n-        while (!TokenUtil.isOfType(currentAst, UnusedLocalVariableCheck.CONTAINERS_FOR_ANON_INNERS)) {\n-            if (currentAst.getType() == 181 && currentAst.getParent().getParent().getParent().getType() == 6) {\n-                result = currentAst;\n+    private static DetailAST getBlockContainingLocalAnonInnerClass(final DetailAST detailAST) {\n+        DetailAST detailAST2 = detailAST;\n+        DetailAST parent = null;\n+        while (!TokenUtil.isOfType(detailAST2, UnusedLocalVariableCheck.CONTAINERS_FOR_ANON_INNERS)) {\n+            if (detailAST2.getType() == 181 && detailAST2.getParent().getParent().getParent().getType() == 6) {\n+                parent = detailAST2;\n                 break;\n             }\n-            currentAst = (result = currentAst.getParent());\n+            detailAST2 = (parent = detailAST2.getParent());\n         }\n-        return result;\n+        return parent;\n     }\n     \n-    private static void addLocalVariables(final DetailAST varDefAst, final Deque<UnusedLocalVariableCheck.VariableDesc> variablesStack) {\n-        final DetailAST parentAst = varDefAst.getParent();\n-        final DetailAST grandParent = parentAst.getParent();\n-        final boolean isInstanceVarInAnonymousInnerClass = grandParent.getType() == 136;\n-        if (isInstanceVarInAnonymousInnerClass || parentAst.getType() != 6) {\n-            final DetailAST ident = varDefAst.findFirstToken(58);\n-            final UnusedLocalVariableCheck.VariableDesc desc = new UnusedLocalVariableCheck.VariableDesc(ident.getText(), varDefAst.findFirstToken(13), findScopeOfVariable(varDefAst));\n-            if (isInstanceVarInAnonymousInnerClass) {\n-                desc.registerAsInstOrClassVar();\n+    private static void addLocalVariables(final DetailAST detailAST, final Deque<UnusedLocalVariableCheck.VariableDesc> deque) {\n+        final DetailAST parent = detailAST.getParent();\n+        final boolean b = parent.getParent().getType() == 136;\n+        if (b || parent.getType() != 6) {\n+            final UnusedLocalVariableCheck.VariableDesc variableDesc = new UnusedLocalVariableCheck.VariableDesc(detailAST.findFirstToken(58).getText(), detailAST.findFirstToken(13), findScopeOfVariable(detailAST));\n+            if (b) {\n+                variableDesc.registerAsInstOrClassVar();\n             }\n-            variablesStack.push(desc);\n+            deque.push(variableDesc);\n         }\n     }\n     \n-    private void addInstanceOrClassVar(final DetailAST varDefAst) {\n-        final DetailAST parentAst = varDefAst.getParent();\n-        if (isNonLocalTypeDeclaration(parentAst.getParent()) && !isPrivateInstanceVariable(varDefAst)) {\n-            final DetailAST ident = varDefAst.findFirstToken(58);\n-            final UnusedLocalVariableCheck.VariableDesc desc = new UnusedLocalVariableCheck.VariableDesc(ident.getText());\n-            ((UnusedLocalVariableCheck.TypeDeclDesc)this.typeDeclAstToTypeDeclDesc.get(parentAst.getParent())).addInstOrClassVar(desc);\n+    private void addInstanceOrClassVar(final DetailAST detailAST) {\n+        final DetailAST parent = detailAST.getParent();\n+        if (isNonLocalTypeDeclaration(parent.getParent()) && !isPrivateInstanceVariable(detailAST)) {\n+            ((UnusedLocalVariableCheck.TypeDeclDesc)this.typeDeclAstToTypeDeclDesc.get(parent.getParent())).addInstOrClassVar(new UnusedLocalVariableCheck.VariableDesc(detailAST.findFirstToken(58).getText()));\n         }\n     }\n     \n-    private static boolean isPrivateInstanceVariable(final DetailAST varDefAst) {\n-        final AccessModifierOption varAccessModifier = CheckUtil.getAccessModifierFromModifiersToken(varDefAst);\n-        return varAccessModifier == AccessModifierOption.PRIVATE;\n+    private static boolean isPrivateInstanceVariable(final DetailAST detailAST) {\n+        return CheckUtil.getAccessModifierFromModifiersToken(detailAST) == AccessModifierOption.PRIVATE;\n     }\n     \n-    private UnusedLocalVariableCheck.TypeDeclDesc getSuperClassOfAnonInnerClass(final DetailAST literalNewAst) {\n-        UnusedLocalVariableCheck.TypeDeclDesc obtainedClass = null;\n-        final String shortNameOfClass = CheckUtil.getShortNameOfAnonInnerClass(literalNewAst);\n-        if (this.packageName != null && shortNameOfClass.startsWith(this.packageName)) {\n-            final Optional<UnusedLocalVariableCheck.TypeDeclDesc> classWithCompletePackageName = this.typeDeclAstToTypeDeclDesc.values().stream().filter(typeDeclDesc -> typeDeclDesc.getQualifiedName().equals(shortNameOfClass)).findFirst();\n-            if (classWithCompletePackageName.isPresent()) {\n-                obtainedClass = classWithCompletePackageName.get();\n+    private UnusedLocalVariableCheck.TypeDeclDesc getSuperClassOfAnonInnerClass(final DetailAST detailAST) {\n+        UnusedLocalVariableCheck.TypeDeclDesc theNearestClass = null;\n+        final String shortNameOfAnonInnerClass = CheckUtil.getShortNameOfAnonInnerClass(detailAST);\n+        if (this.packageName != null && shortNameOfAnonInnerClass.startsWith(this.packageName)) {\n+            final Optional<UnusedLocalVariableCheck.TypeDeclDesc> first = this.typeDeclAstToTypeDeclDesc.values().stream().filter(typeDeclDesc -> typeDeclDesc.getQualifiedName().equals(anObject)).findFirst();\n+            if (first.isPresent()) {\n+                theNearestClass = first.get();\n             }\n         }\n         else {\n-            final List<UnusedLocalVariableCheck.TypeDeclDesc> typeDeclWithSameName = this.typeDeclWithSameName(shortNameOfClass);\n+            final List<UnusedLocalVariableCheck.TypeDeclDesc> typeDeclWithSameName = this.typeDeclWithSameName(shortNameOfAnonInnerClass);\n             if (!typeDeclWithSameName.isEmpty()) {\n-                obtainedClass = getTheNearestClass(((UnusedLocalVariableCheck.TypeDeclDesc)this.anonInnerAstToTypeDeclDesc.get(literalNewAst)).getQualifiedName(), typeDeclWithSameName);\n+                theNearestClass = getTheNearestClass(((UnusedLocalVariableCheck.TypeDeclDesc)this.anonInnerAstToTypeDeclDesc.get(detailAST)).getQualifiedName(), typeDeclWithSameName);\n             }\n         }\n-        return obtainedClass;\n+        return theNearestClass;\n     }\n     \n-    private void modifyVariablesStack(final UnusedLocalVariableCheck.TypeDeclDesc obtainedClass, final Deque<UnusedLocalVariableCheck.VariableDesc> variablesStack, final DetailAST literalNewAst) {\n-        if (obtainedClass != null) {\n-            final Deque updatedCopyOfVarStack;\n-            final Deque<UnusedLocalVariableCheck.VariableDesc> instAndClassVarDeque = updatedCopyOfVarStack = ((UnusedLocalVariableCheck.TypeDeclDesc)this.typeDeclAstToTypeDeclDesc.get(obtainedClass.getTypeDeclAst())).getUpdatedCopyOfVarStack(literalNewAst);\n-            Objects.requireNonNull(variablesStack);\n-            updatedCopyOfVarStack.forEach(variablesStack::push);\n+    private void modifyVariablesStack(final UnusedLocalVariableCheck.TypeDeclDesc typeDeclDesc, final Deque<UnusedLocalVariableCheck.VariableDesc> obj, final DetailAST detailAST) {\n+        if (typeDeclDesc != null) {\n+            final Deque updatedCopyOfVarStack = ((UnusedLocalVariableCheck.TypeDeclDesc)this.typeDeclAstToTypeDeclDesc.get(typeDeclDesc.getTypeDeclAst())).getUpdatedCopyOfVarStack(detailAST);\n+            Objects.requireNonNull(obj);\n+            updatedCopyOfVarStack.forEach(obj::push);\n         }\n     }\n     \n-    private List<UnusedLocalVariableCheck.TypeDeclDesc> typeDeclWithSameName(final String superClassName) {\n-        return this.typeDeclAstToTypeDeclDesc.values().stream().filter(typeDeclDesc -> this.hasSameNameAsSuperClass(superClassName, typeDeclDesc)).collect((Collector<? super UnusedLocalVariableCheck.TypeDeclDesc, ?, List<UnusedLocalVariableCheck.TypeDeclDesc>>)Collectors.toList());\n+    private List<UnusedLocalVariableCheck.TypeDeclDesc> typeDeclWithSameName(final String s) {\n+        return this.typeDeclAstToTypeDeclDesc.values().stream().filter(typeDeclDesc -> this.hasSameNameAsSuperClass(s2, typeDeclDesc)).collect((Collector<? super UnusedLocalVariableCheck.TypeDeclDesc, ?, List<UnusedLocalVariableCheck.TypeDeclDesc>>)Collectors.toList());\n     }\n     \n-    private boolean hasSameNameAsSuperClass(final String superClassName, final UnusedLocalVariableCheck.TypeDeclDesc typeDeclDesc) {\n-        boolean result;\n+    private boolean hasSameNameAsSuperClass(final String anObject, final UnusedLocalVariableCheck.TypeDeclDesc typeDeclDesc) {\n+        boolean b;\n         if (this.packageName == null && typeDeclDesc.getDepth() == 0) {\n-            result = typeDeclDesc.getQualifiedName().equals(superClassName);\n+            b = typeDeclDesc.getQualifiedName().equals(anObject);\n         }\n         else {\n-            result = typeDeclDesc.getQualifiedName().endsWith(\".\" + superClassName);\n+            b = typeDeclDesc.getQualifiedName().endsWith(\".\" + anObject);\n         }\n-        return result;\n+        return b;\n     }\n     \n-    private static UnusedLocalVariableCheck.TypeDeclDesc getTheNearestClass(final String outerTypeDeclName, final List<UnusedLocalVariableCheck.TypeDeclDesc> typeDeclWithSameName) {\n-        return Collections.min((Collection<? extends UnusedLocalVariableCheck.TypeDeclDesc>)typeDeclWithSameName, (first, second) -> getTypeDeclarationNameMatchingCountDiff(outerTypeDeclName, first, second));\n+    private static UnusedLocalVariableCheck.TypeDeclDesc getTheNearestClass(final String s, final List<UnusedLocalVariableCheck.TypeDeclDesc> coll) {\n+        return Collections.min((Collection<? extends UnusedLocalVariableCheck.TypeDeclDesc>)coll, (typeDeclDesc, typeDeclDesc2) -> getTypeDeclarationNameMatchingCountDiff(s2, typeDeclDesc, typeDeclDesc2));\n     }\n     \n-    private static int getTypeDeclarationNameMatchingCountDiff(final String outerTypeDeclName, final UnusedLocalVariableCheck.TypeDeclDesc firstTypeDecl, final UnusedLocalVariableCheck.TypeDeclDesc secondTypeDecl) {\n-        int diff = Integer.compare(CheckUtil.typeDeclarationNameMatchingCount(outerTypeDeclName, secondTypeDecl.getQualifiedName()), CheckUtil.typeDeclarationNameMatchingCount(outerTypeDeclName, firstTypeDecl.getQualifiedName()));\n-        if (diff == 0) {\n-            diff = Integer.compare(firstTypeDecl.getDepth(), secondTypeDecl.getDepth());\n+    private static int getTypeDeclarationNameMatchingCountDiff(final String s, final UnusedLocalVariableCheck.TypeDeclDesc typeDeclDesc, final UnusedLocalVariableCheck.TypeDeclDesc typeDeclDesc2) {\n+        int n = Integer.compare(CheckUtil.typeDeclarationNameMatchingCount(s, typeDeclDesc2.getQualifiedName()), CheckUtil.typeDeclarationNameMatchingCount(s, typeDeclDesc.getQualifiedName()));\n+        if (n == 0) {\n+            n = Integer.compare(typeDeclDesc.getDepth(), typeDeclDesc2.getDepth());\n         }\n-        return diff;\n+        return n;\n     }\n     \n-    private String getQualifiedTypeDeclarationName(final DetailAST typeDeclAst) {\n-        final String className = typeDeclAst.findFirstToken(58).getText();\n-        String outerClassQualifiedName = null;\n+    private String getQualifiedTypeDeclarationName(final DetailAST detailAST) {\n+        final String text = detailAST.findFirstToken(58).getText();\n+        String qualifiedName = null;\n         if (!this.typeDeclarations.isEmpty()) {\n-            outerClassQualifiedName = ((UnusedLocalVariableCheck.TypeDeclDesc)this.typeDeclarations.peek()).getQualifiedName();\n+            qualifiedName = ((UnusedLocalVariableCheck.TypeDeclDesc)this.typeDeclarations.peek()).getQualifiedName();\n         }\n-        return CheckUtil.getQualifiedTypeDeclarationName(this.packageName, outerClassQualifiedName, className);\n+        return CheckUtil.getQualifiedTypeDeclarationName(this.packageName, qualifiedName, text);\n     }\n     \n-    private void iterateOverBlockContainingLocalAnonInnerClass(final DetailAST ast, final Deque<UnusedLocalVariableCheck.VariableDesc> variablesStack) {\n-        DetailAST toVisit;\n-        for (DetailAST currNode = ast; currNode != null; currNode = toVisit) {\n-            this.customVisitToken(currNode, variablesStack);\n-            for (toVisit = currNode.getFirstChild(); currNode != ast && toVisit == null; toVisit = currNode.getNextSibling(), currNode = currNode.getParent()) {\n-                this.customLeaveToken(currNode, variablesStack);\n+    private void iterateOverBlockContainingLocalAnonInnerClass(final DetailAST detailAST, final Deque<UnusedLocalVariableCheck.VariableDesc> deque) {\n+        DetailAST detailAST2;\n+        for (DetailAST parent = detailAST; parent != null; parent = detailAST2) {\n+            this.customVisitToken(parent, deque);\n+            for (detailAST2 = parent.getFirstChild(); parent != detailAST && detailAST2 == null; detailAST2 = parent.getNextSibling(), parent = parent.getParent()) {\n+                this.customLeaveToken(parent, deque);\n             }\n         }\n     }\n     \n-    private void customVisitToken(final DetailAST ast, final Deque<UnusedLocalVariableCheck.VariableDesc> variablesStack) {\n-        final int type = ast.getType();\n+    private void customVisitToken(final DetailAST detailAST, final Deque<UnusedLocalVariableCheck.VariableDesc> deque) {\n+        final int type = detailAST.getType();\n         if (type == 59) {\n-            visitDotToken(ast, variablesStack);\n+            visitDotToken(detailAST, deque);\n         }\n         else if (type == 10) {\n-            addLocalVariables(ast, variablesStack);\n+            addLocalVariables(detailAST, deque);\n         }\n         else if (type == 58) {\n-            visitIdentToken(ast, variablesStack);\n+            visitIdentToken(detailAST, deque);\n         }\n-        else if (isInsideLocalAnonInnerClass(ast)) {\n-            final UnusedLocalVariableCheck.TypeDeclDesc obtainedClass = this.getSuperClassOfAnonInnerClass(ast);\n-            this.modifyVariablesStack(obtainedClass, variablesStack, ast);\n+        else if (isInsideLocalAnonInnerClass(detailAST)) {\n+            this.modifyVariablesStack(this.getSuperClassOfAnonInnerClass(detailAST), deque, detailAST);\n         }\n     }\n     \n-    private void customLeaveToken(final DetailAST ast, final Deque<UnusedLocalVariableCheck.VariableDesc> variablesStack) {\n-        this.logViolations(ast, variablesStack);\n+    private void customLeaveToken(final DetailAST detailAST, final Deque<UnusedLocalVariableCheck.VariableDesc> deque) {\n+        this.logViolations(detailAST, deque);\n     }\n     \n-    private static boolean shouldCheckIdentTokenNestedUnderDot(final DetailAST dotAst) {\n-        return TokenUtil.findFirstTokenByPredicate(dotAst, childAst -> TokenUtil.isOfType(childAst, UnusedLocalVariableCheck.UNACCEPTABLE_CHILD_OF_DOT)).isEmpty();\n+    private static boolean shouldCheckIdentTokenNestedUnderDot(final DetailAST detailAST) {\n+        return TokenUtil.findFirstTokenByPredicate(detailAST, detailAST2 -> TokenUtil.isOfType(detailAST2, UnusedLocalVariableCheck.UNACCEPTABLE_CHILD_OF_DOT)).isEmpty();\n     }\n     \n-    private static void checkIdentifierAst(final DetailAST identAst, final Deque<UnusedLocalVariableCheck.VariableDesc> variablesStack) {\n-        for (final UnusedLocalVariableCheck.VariableDesc variableDesc : variablesStack) {\n-            if (identAst.getText().equals(variableDesc.getName()) && !isLeftHandSideValue(identAst)) {\n+    private static void checkIdentifierAst(final DetailAST detailAST, final Deque<UnusedLocalVariableCheck.VariableDesc> deque) {\n+        for (final UnusedLocalVariableCheck.VariableDesc variableDesc : deque) {\n+            if (detailAST.getText().equals(variableDesc.getName()) && !isLeftHandSideValue(detailAST)) {\n                 variableDesc.registerAsUsed();\n                 break;\n             }\n         }\n     }\n     \n-    private static DetailAST findScopeOfVariable(final DetailAST variableDef) {\n-        final DetailAST parentAst = variableDef.getParent();\n-        DetailAST result;\n-        if (TokenUtil.isOfType(parentAst, new int[] { 7, 6 })) {\n-            result = parentAst;\n+    private static DetailAST findScopeOfVariable(final DetailAST detailAST) {\n+        final DetailAST parent = detailAST.getParent();\n+        DetailAST parent2;\n+        if (TokenUtil.isOfType(parent, new int[] { 7, 6 })) {\n+            parent2 = parent;\n         }\n         else {\n-            result = parentAst.getParent();\n+            parent2 = parent.getParent();\n         }\n-        return result;\n+        return parent2;\n     }\n     \n-    private static boolean isLeftHandSideValue(final DetailAST identAst) {\n-        final DetailAST parent = identAst.getParent();\n-        return isStandAloneIncrementOrDecrement(identAst) || (parent.getType() == 80 && identAst != parent.getLastChild());\n+    private static boolean isLeftHandSideValue(final DetailAST detailAST) {\n+        final DetailAST parent = detailAST.getParent();\n+        return isStandAloneIncrementOrDecrement(detailAST) || (parent.getType() == 80 && detailAST != parent.getLastChild());\n     }\n     \n-    private static boolean isStandAloneIncrementOrDecrement(final DetailAST identAst) {\n-        final DetailAST parent = identAst.getParent();\n-        final DetailAST grandParent = parent.getParent();\n-        return TokenUtil.isOfType(parent, UnusedLocalVariableCheck.INCREMENT_AND_DECREMENT_TOKENS) && TokenUtil.isOfType(grandParent, new int[] { 28 }) && !isIncrementOrDecrementVariableUsed(grandParent);\n+    private static boolean isStandAloneIncrementOrDecrement(final DetailAST detailAST) {\n+        final DetailAST parent = detailAST.getParent();\n+        final DetailAST parent2 = parent.getParent();\n+        return TokenUtil.isOfType(parent, UnusedLocalVariableCheck.INCREMENT_AND_DECREMENT_TOKENS) && TokenUtil.isOfType(parent2, new int[] { 28 }) && !isIncrementOrDecrementVariableUsed(parent2);\n     }\n     \n-    private static boolean isIncrementOrDecrementVariableUsed(final DetailAST exprAst) {\n-        return TokenUtil.isOfType(exprAst.getParent(), new int[] { 34, 24, 80 }) && exprAst.getParent().getParent().getType() != 37;\n+    private static boolean isIncrementOrDecrementVariableUsed(final DetailAST detailAST) {\n+        return TokenUtil.isOfType(detailAST.getParent(), new int[] { 34, 24, 80 }) && detailAST.getParent().getParent().getType() != 37;\n     }\n     \n     static {\n         INCREMENT_AND_DECREMENT_TOKENS = new int[] { 25, 26, 129, 130 };\n         SCOPES = new int[] { 7, 91, 6 };\n         UNACCEPTABLE_CHILD_OF_DOT = new int[] { 59, 27, 136, 79, 69, 78 };\n         UNACCEPTABLE_PARENT_OF_IDENT = new int[] { 10, 59, 136, 198, 27, 13 };\n"}]}
