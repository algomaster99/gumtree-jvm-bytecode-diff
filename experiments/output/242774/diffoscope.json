{"diffoscope-json-version": 1, "source1": "first/Select.class", "source2": "second/Select.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -19,176 +19,178 @@\n     protected int match_length;\n     @Deprecated\n     protected int padding;\n     \n     Select() {\n     }\n     \n-    Select(final short opcode, final int[] match, final InstructionHandle[] targets, final InstructionHandle defaultTarget) {\n-        super(opcode, (InstructionHandle)null);\n+    Select(final short n, final int[] match, final InstructionHandle[] targets, final InstructionHandle target) {\n+        super(n, (InstructionHandle)null);\n         this.match = match;\n         this.targets = targets;\n-        this.setTarget(defaultTarget);\n-        for (final InstructionHandle target2 : targets) {\n-            notifyTarget((InstructionHandle)null, target2, (InstructionTargeter)this);\n+        this.setTarget(target);\n+        for (int length = targets.length, i = 0; i < length; ++i) {\n+            notifyTarget((InstructionHandle)null, targets[i], (InstructionTargeter)this);\n         }\n         if ((this.match_length = match.length) != targets.length) {\n             throw new ClassGenException(\"Match and target array have not the same length: Match length: \" + match.length + \" Target length: \" + targets.length);\n         }\n         this.indices = new int[this.match_length];\n     }\n     \n     protected Object clone() throws CloneNotSupportedException {\n-        final Select copy = (Select)super.clone();\n-        copy.match = this.match.clone();\n-        copy.indices = this.indices.clone();\n-        copy.targets = this.targets.clone();\n-        return copy;\n+        final Select select = (Select)super.clone();\n+        select.match = this.match.clone();\n+        select.indices = this.indices.clone();\n+        select.targets = this.targets.clone();\n+        return select;\n     }\n     \n-    public boolean containsTarget(final InstructionHandle ih) {\n-        if (super.getTarget() == ih) {\n+    public boolean containsTarget(final InstructionHandle instructionHandle) {\n+        if (super.getTarget() == instructionHandle) {\n             return true;\n         }\n-        for (final InstructionHandle target2 : this.targets) {\n-            if (target2 == ih) {\n+        final InstructionHandle[] targets = this.targets;\n+        for (int length = targets.length, i = 0; i < length; ++i) {\n+            if (targets[i] == instructionHandle) {\n                 return true;\n             }\n         }\n         return false;\n     }\n     \n     void dispose() {\n         super.dispose();\n-        for (final InstructionHandle target2 : this.targets) {\n-            target2.removeTargeter((InstructionTargeter)this);\n+        final InstructionHandle[] targets = this.targets;\n+        for (int length = targets.length, i = 0; i < length; ++i) {\n+            targets[i].removeTargeter((InstructionTargeter)this);\n         }\n     }\n     \n-    public void dump(final DataOutputStream out) throws IOException {\n-        out.writeByte(super.getOpcode());\n+    public void dump(final DataOutputStream dataOutputStream) throws IOException {\n+        dataOutputStream.writeByte(super.getOpcode());\n         for (int i = 0; i < this.padding; ++i) {\n-            out.writeByte(0);\n+            dataOutputStream.writeByte(0);\n         }\n         super.setIndex(this.getTargetOffset());\n-        out.writeInt(super.getIndex());\n+        dataOutputStream.writeInt(super.getIndex());\n     }\n     \n     final int getFixedLength() {\n         return this.fixed_length;\n     }\n     \n     public int[] getIndices() {\n         return this.indices;\n     }\n     \n-    final int getIndices(final int index) {\n-        return this.indices[index];\n+    final int getIndices(final int n) {\n+        return this.indices[n];\n     }\n     \n-    final int getMatch(final int index) {\n-        return this.match[index];\n+    final int getMatch(final int n) {\n+        return this.match[n];\n     }\n     \n     final int getMatchLength() {\n         return this.match_length;\n     }\n     \n     public int[] getMatchs() {\n         return this.match;\n     }\n     \n     final int getPadding() {\n         return this.padding;\n     }\n     \n-    final InstructionHandle getTarget(final int index) {\n-        return this.targets[index];\n+    final InstructionHandle getTarget(final int n) {\n+        return this.targets[n];\n     }\n     \n     public InstructionHandle[] getTargets() {\n         return this.targets;\n     }\n     \n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n-        this.padding = (4 - bytes.getIndex() % 4) % 4;\n+    protected void initFromFile(final ByteSequence byteSequence, final boolean b) throws IOException {\n+        this.padding = (4 - byteSequence.getIndex() % 4) % 4;\n         for (int i = 0; i < this.padding; ++i) {\n-            bytes.readByte();\n+            byteSequence.readByte();\n         }\n-        super.setIndex(bytes.readInt());\n+        super.setIndex(byteSequence.readInt());\n     }\n     \n-    final void setFixedLength(final int fixedLength) {\n-        this.fixed_length = fixedLength;\n+    final void setFixedLength(final int fixed_length) {\n+        this.fixed_length = fixed_length;\n     }\n     \n-    final int setIndices(final int i, final int value) {\n-        return this.indices[i] = value;\n+    final int setIndices(final int n, final int n2) {\n+        return this.indices[n] = n2;\n     }\n     \n-    final void setIndices(final int[] array) {\n-        this.indices = array;\n+    final void setIndices(final int[] indices) {\n+        this.indices = indices;\n     }\n     \n-    final void setMatch(final int index, final int value) {\n-        this.match[index] = value;\n+    final void setMatch(final int n, final int n2) {\n+        this.match[n] = n2;\n     }\n     \n-    final int setMatchLength(final int matchLength) {\n-        return this.match_length = matchLength;\n+    final int setMatchLength(final int match_length) {\n+        return this.match_length = match_length;\n     }\n     \n-    final void setMatches(final int[] array) {\n-        this.match = array;\n+    final void setMatches(final int[] match) {\n+        this.match = match;\n     }\n     \n-    public void setTarget(final int i, final InstructionHandle target) {\n-        notifyTarget(this.targets[i], target, (InstructionTargeter)this);\n-        this.targets[i] = target;\n+    public void setTarget(final int n, final InstructionHandle instructionHandle) {\n+        notifyTarget(this.targets[n], instructionHandle, (InstructionTargeter)this);\n+        this.targets[n] = instructionHandle;\n     }\n     \n-    final void setTargets(final InstructionHandle[] array) {\n-        this.targets = array;\n+    final void setTargets(final InstructionHandle[] targets) {\n+        this.targets = targets;\n     }\n     \n-    public String toString(final boolean verbose) {\n-        final StringBuilder buf = new StringBuilder(super.toString(verbose));\n-        if (verbose) {\n+    public String toString(final boolean b) {\n+        final StringBuilder sb = new StringBuilder(super.toString(b));\n+        if (b) {\n             for (int i = 0; i < this.match_length; ++i) {\n-                String s = \"null\";\n+                String string = \"null\";\n                 if (this.targets[i] != null) {\n-                    s = this.targets[i].getInstruction().toString();\n+                    string = this.targets[i].getInstruction().toString();\n                 }\n-                buf.append(\"(\").append(this.match[i]).append(\", \").append(s).append(\" = {\").append(this.indices[i]).append(\"})\");\n+                sb.append(\"(\").append(this.match[i]).append(\", \").append(string).append(\" = {\").append(this.indices[i]).append(\"})\");\n             }\n         }\n         else {\n-            buf.append(\" ...\");\n+            sb.append(\" ...\");\n         }\n-        return buf.toString();\n+        return sb.toString();\n     }\n     \n-    protected int updatePosition(final int offset, final int maxOffset) {\n-        this.setPosition(this.getPosition() + offset);\n-        final short oldLength = (short)super.getLength();\n+    protected int updatePosition(final int n, final int n2) {\n+        this.setPosition(this.getPosition() + n);\n+        final short n3 = (short)super.getLength();\n         this.padding = (4 - (this.getPosition() + 1) % 4) % 4;\n         super.setLength((int)(short)(this.fixed_length + this.padding));\n-        return super.getLength() - oldLength;\n+        return super.getLength() - n3;\n     }\n     \n-    public void updateTarget(final InstructionHandle oldIh, final InstructionHandle newIh) {\n-        boolean targeted = false;\n-        if (super.getTarget() == oldIh) {\n-            targeted = true;\n-            this.setTarget(newIh);\n+    public void updateTarget(final InstructionHandle obj, final InstructionHandle target) {\n+        boolean b = false;\n+        if (super.getTarget() == obj) {\n+            b = true;\n+            this.setTarget(target);\n         }\n         for (int i = 0; i < this.targets.length; ++i) {\n-            if (this.targets[i] == oldIh) {\n-                targeted = true;\n-                this.setTarget(i, newIh);\n+            if (this.targets[i] == obj) {\n+                b = true;\n+                this.setTarget(i, target);\n             }\n         }\n-        if (!targeted) {\n-            throw new ClassGenException(\"Not targeting \" + oldIh);\n+        if (!b) {\n+            throw new ClassGenException(\"Not targeting \" + obj);\n         }\n     }\n }\n"}]}
