{"diffoscope-json-version": 1, "source1": "first/BOMInputStream.class", "source2": "second/BOMInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -19,54 +19,53 @@\n     private int[] firstBytes;\n     private int fbLength;\n     private int fbIndex;\n     private int markFbIndex;\n     private boolean markedAtStart;\n     private static final Comparator<ByteOrderMark> ByteOrderMarkLengthComparator;\n     \n-    public BOMInputStream(final InputStream delegate) {\n-        this(delegate, false, new ByteOrderMark[] { ByteOrderMark.UTF_8 });\n+    public BOMInputStream(final InputStream inputStream) {\n+        this(inputStream, false, new ByteOrderMark[] { ByteOrderMark.UTF_8 });\n     }\n     \n-    public BOMInputStream(final InputStream delegate, final boolean include) {\n-        this(delegate, include, new ByteOrderMark[] { ByteOrderMark.UTF_8 });\n+    public BOMInputStream(final InputStream inputStream, final boolean b) {\n+        this(inputStream, b, new ByteOrderMark[] { ByteOrderMark.UTF_8 });\n     }\n     \n-    public BOMInputStream(final InputStream delegate, final ByteOrderMark... boms) {\n-        this(delegate, false, boms);\n+    public BOMInputStream(final InputStream inputStream, final ByteOrderMark... array) {\n+        this(inputStream, false, array);\n     }\n     \n-    public BOMInputStream(final InputStream delegate, final boolean include, final ByteOrderMark... boms) {\n-        super(delegate);\n-        if (IOUtils.length((Object[])boms) == 0) {\n+    public BOMInputStream(final InputStream inputStream, final boolean include, final ByteOrderMark... a) {\n+        super(inputStream);\n+        if (IOUtils.length((Object[])a) == 0) {\n             throw new IllegalArgumentException(\"No BOMs specified\");\n         }\n         this.include = include;\n-        final List<ByteOrderMark> list = Arrays.asList(boms);\n-        Collections.sort(list, BOMInputStream.ByteOrderMarkLengthComparator);\n+        final List<ByteOrderMark> list = Arrays.asList(a);\n+        Collections.sort((List<Object>)list, (Comparator<? super Object>)BOMInputStream.ByteOrderMarkLengthComparator);\n         this.boms = list;\n     }\n     \n     public boolean hasBOM() throws IOException {\n         return this.getBOM() != null;\n     }\n     \n-    public boolean hasBOM(final ByteOrderMark bom) throws IOException {\n-        if (!this.boms.contains(bom)) {\n-            throw new IllegalArgumentException(\"Stream not configure to detect \" + bom);\n+    public boolean hasBOM(final ByteOrderMark obj) throws IOException {\n+        if (!this.boms.contains(obj)) {\n+            throw new IllegalArgumentException(\"Stream not configure to detect \" + obj);\n         }\n         this.getBOM();\n-        return this.byteOrderMark != null && this.byteOrderMark.equals((Object)bom);\n+        return this.byteOrderMark != null && this.byteOrderMark.equals((Object)obj);\n     }\n     \n     public ByteOrderMark getBOM() throws IOException {\n         if (this.firstBytes == null) {\n             this.fbLength = 0;\n-            final int maxBomSize = ((ByteOrderMark)this.boms.get(0)).length();\n-            this.firstBytes = new int[maxBomSize];\n+            this.firstBytes = new int[((ByteOrderMark)this.boms.get(0)).length()];\n             for (int i = 0; i < this.firstBytes.length; ++i) {\n                 this.firstBytes[i] = this.in.read();\n                 ++this.fbLength;\n                 if (this.firstBytes[i] < 0) {\n                     break;\n                 }\n             }\n@@ -90,50 +89,50 @@\n     \n     private int readFirstBytes() throws IOException {\n         this.getBOM();\n         return (this.fbIndex < this.fbLength) ? this.firstBytes[this.fbIndex++] : -1;\n     }\n     \n     private ByteOrderMark find() {\n-        for (final ByteOrderMark bom : this.boms) {\n-            if (this.matches(bom)) {\n-                return bom;\n+        for (final ByteOrderMark byteOrderMark : this.boms) {\n+            if (this.matches(byteOrderMark)) {\n+                return byteOrderMark;\n             }\n         }\n         return null;\n     }\n     \n-    private boolean matches(final ByteOrderMark bom) {\n-        for (int i = 0; i < bom.length(); ++i) {\n-            if (bom.get(i) != this.firstBytes[i]) {\n+    private boolean matches(final ByteOrderMark byteOrderMark) {\n+        for (int i = 0; i < byteOrderMark.length(); ++i) {\n+            if (byteOrderMark.get(i) != this.firstBytes[i]) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n     public int read() throws IOException {\n-        final int b = this.readFirstBytes();\n-        return (b >= 0) ? b : this.in.read();\n+        final int firstBytes = this.readFirstBytes();\n+        return (firstBytes >= 0) ? firstBytes : this.in.read();\n     }\n     \n-    public int read(final byte[] buf, int off, int len) throws IOException {\n-        int firstCount = 0;\n-        for (int b = 0; len > 0 && b >= 0; --len, ++firstCount) {\n-            b = this.readFirstBytes();\n-            if (b >= 0) {\n-                buf[off++] = (byte)(b & 0xFF);\n+    public int read(final byte[] b, int off, int len) throws IOException {\n+        int n = 0;\n+        for (int firstBytes = 0; len > 0 && firstBytes >= 0; --len, ++n) {\n+            firstBytes = this.readFirstBytes();\n+            if (firstBytes >= 0) {\n+                b[off++] = (byte)(firstBytes & 0xFF);\n             }\n         }\n-        final int secondCount = this.in.read(buf, off, len);\n-        return (secondCount < 0) ? ((firstCount > 0) ? firstCount : -1) : (firstCount + secondCount);\n+        final int read = this.in.read(b, off, len);\n+        return (read < 0) ? ((n > 0) ? n : -1) : (n + read);\n     }\n     \n-    public int read(final byte[] buf) throws IOException {\n-        return this.read(buf, 0, buf.length);\n+    public int read(final byte[] array) throws IOException {\n+        return this.read(array, 0, array.length);\n     }\n     \n     public synchronized void mark(final int readlimit) {\n         this.markFbIndex = this.fbIndex;\n         this.markedAtStart = (this.firstBytes == null);\n         this.in.mark(readlimit);\n     }\n@@ -143,27 +142,29 @@\n         if (this.markedAtStart) {\n             this.firstBytes = null;\n         }\n         this.in.reset();\n     }\n     \n     public long skip(final long n) throws IOException {\n-        int skipped;\n-        for (skipped = 0; n > skipped && this.readFirstBytes() >= 0; ++skipped) {}\n-        return this.in.skip(n - (long)skipped) + skipped;\n+        int n2;\n+        for (n2 = 0; n > n2 && this.readFirstBytes() >= 0; ++n2) {}\n+        return this.in.skip(n - (long)n2) + n2;\n     }\n     \n     static {\n-        ByteOrderMarkLengthComparator = ((bom1, bom2) -> {\n-            final int len1 = bom1.length();\n-            final int len2 = bom2.length();\n-            if (len1 > len2) {\n+        ByteOrderMarkLengthComparator = ((byteOrderMark, byteOrderMark2) -> {\n+            byteOrderMark.length();\n+            byteOrderMark2.length();\n+            final int n;\n+            final int n2;\n+            if (n > n2) {\n                 return -1;\n             }\n-            else if (len2 > len1) {\n+            else if (n2 > n) {\n                 return 1;\n             }\n             else {\n                 return 0;\n             }\n         });\n     }\n"}]}
