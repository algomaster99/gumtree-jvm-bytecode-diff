{"diffoscope-json-version": 1, "source1": "first/IOUtils.class", "source2": "second/IOUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -17,150 +17,151 @@\n public final class IOUtils\n {\n     private static final int COPY_BUF_SIZE = 8024;\n     private static final int SKIP_BUF_SIZE = 4096;\n     public static final LinkOption[] EMPTY_LINK_OPTIONS;\n     private static final byte[] SKIP_BUF;\n     \n-    public static void closeQuietly(final Closeable c) {\n-        if (c != null) {\n+    public static void closeQuietly(final Closeable closeable) {\n+        if (closeable != null) {\n             try {\n-                c.close();\n+                closeable.close();\n             }\n             catch (final IOException ex) {}\n         }\n     }\n     \n-    public static void copy(final File sourceFile, final OutputStream outputStream) throws IOException {\n-        Files.copy(sourceFile.toPath(), outputStream);\n+    public static void copy(final File file, final OutputStream out) throws IOException {\n+        Files.copy(file.toPath(), out);\n     }\n     \n-    public static long copy(final InputStream input, final OutputStream output) throws IOException {\n-        return copy(input, output, 8024);\n+    public static long copy(final InputStream inputStream, final OutputStream outputStream) throws IOException {\n+        return copy(inputStream, outputStream, 8024);\n     }\n     \n-    public static long copy(final InputStream input, final OutputStream output, final int buffersize) throws IOException {\n-        if (buffersize < 1) {\n+    public static long copy(final InputStream inputStream, final OutputStream outputStream, final int n) throws IOException {\n+        if (n < 1) {\n             throw new IllegalArgumentException(\"buffersize must be bigger than 0\");\n         }\n-        final byte[] buffer = new byte[buffersize];\n-        int n = 0;\n-        long count = 0L;\n-        while (-1 != (n = input.read(buffer))) {\n-            if (output != null) {\n-                output.write(buffer, 0, n);\n+        final byte[] array = new byte[n];\n+        long n2 = 0L;\n+        int read;\n+        while (-1 != (read = inputStream.read(array))) {\n+            if (outputStream != null) {\n+                outputStream.write(array, 0, read);\n             }\n-            count += n;\n+            n2 += read;\n         }\n-        return count;\n+        return n2;\n     }\n     \n-    public static long copyRange(final InputStream input, final long len, final OutputStream output) throws IOException {\n-        return copyRange(input, len, output, 8024);\n+    public static long copyRange(final InputStream inputStream, final long n, final OutputStream outputStream) throws IOException {\n+        return copyRange(inputStream, n, outputStream, 8024);\n     }\n     \n-    public static long copyRange(final InputStream input, final long len, final OutputStream output, final int buffersize) throws IOException {\n-        if (buffersize < 1) {\n+    public static long copyRange(final InputStream inputStream, final long b, final OutputStream outputStream, final int n) throws IOException {\n+        if (n < 1) {\n             throw new IllegalArgumentException(\"buffersize must be bigger than 0\");\n         }\n-        byte[] buffer;\n-        int n;\n-        long count;\n-        for (buffer = new byte[(int)Math.min(buffersize, len)], n = 0, count = 0L; count < len && -1 != (n = input.read(buffer, 0, (int)Math.min(len - count, buffer.length))); count += n) {\n-            if (output != null) {\n-                output.write(buffer, 0, n);\n+        byte[] array;\n+        long n2;\n+        int read;\n+        for (array = new byte[(int)Math.min(n, b)], n2 = 0L; n2 < b && -1 != (read = inputStream.read(array, 0, (int)Math.min(b - n2, array.length))); n2 += read) {\n+            if (outputStream != null) {\n+                outputStream.write(array, 0, read);\n             }\n         }\n-        return count;\n+        return n2;\n     }\n     \n     public static int read(final File file, final byte[] array) throws IOException {\n         try (final InputStream inputStream = Files.newInputStream(file.toPath(), new OpenOption[0])) {\n             return readFully(inputStream, array, 0, array.length);\n         }\n     }\n     \n-    public static int readFully(final InputStream input, final byte[] array) throws IOException {\n-        return readFully(input, array, 0, array.length);\n+    public static int readFully(final InputStream inputStream, final byte[] array) throws IOException {\n+        return readFully(inputStream, array, 0, array.length);\n     }\n     \n-    public static int readFully(final InputStream input, final byte[] array, final int offset, final int len) throws IOException {\n-        if (len < 0 || offset < 0 || len + offset > array.length || len + offset < 0) {\n+    public static int readFully(final InputStream inputStream, final byte[] b, final int n, final int n2) throws IOException {\n+        if (n2 < 0 || n < 0 || n2 + n > b.length || n2 + n < 0) {\n             throw new IndexOutOfBoundsException();\n         }\n-        int count = 0;\n-        for (int x = 0; count != len; count += x) {\n-            x = input.read(array, offset + count, len - count);\n-            if (x == -1) {\n+        int i;\n+        int read;\n+        for (i = 0; i != n2; i += read) {\n+            read = inputStream.read(b, n + i, n2 - i);\n+            if (read == -1) {\n                 break;\n             }\n         }\n-        return count;\n+        return i;\n     }\n     \n-    public static void readFully(final ReadableByteChannel channel, final ByteBuffer byteBuffer) throws IOException {\n-        int expectedLength;\n+    public static void readFully(final ReadableByteChannel readableByteChannel, final ByteBuffer byteBuffer) throws IOException {\n+        int remaining;\n+        int i;\n         int read;\n-        int readNow;\n-        for (expectedLength = byteBuffer.remaining(), read = 0; read < expectedLength; read += readNow) {\n-            readNow = channel.read(byteBuffer);\n-            if (readNow <= 0) {\n+        for (remaining = byteBuffer.remaining(), i = 0; i < remaining; i += read) {\n+            read = readableByteChannel.read(byteBuffer);\n+            if (read <= 0) {\n                 break;\n             }\n         }\n-        if (read < expectedLength) {\n+        if (i < remaining) {\n             throw new EOFException();\n         }\n     }\n     \n-    public static byte[] readRange(final InputStream input, final int len) throws IOException {\n-        final ByteArrayOutputStream output = new ByteArrayOutputStream();\n-        copyRange(input, len, output);\n-        return output.toByteArray();\n+    public static byte[] readRange(final InputStream inputStream, final int n) throws IOException {\n+        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+        copyRange(inputStream, n, byteArrayOutputStream);\n+        return byteArrayOutputStream.toByteArray();\n     }\n     \n-    public static byte[] readRange(final ReadableByteChannel input, final int len) throws IOException {\n-        final ByteArrayOutputStream output = new ByteArrayOutputStream();\n-        final ByteBuffer b = ByteBuffer.allocate(Math.min(len, 8024));\n-        int readNow;\n-        for (int read = 0; read < len; read += readNow) {\n-            b.limit();\n-            readNow = input.read(b);\n-            if (readNow <= 0) {\n+    public static byte[] readRange(final ReadableByteChannel readableByteChannel, final int a) throws IOException {\n+        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+        final ByteBuffer allocate = ByteBuffer.allocate(Math.min(a, 8024));\n+        int read;\n+        for (int i = 0; i < a; i += read) {\n+            allocate.limit();\n+            read = readableByteChannel.read(allocate);\n+            if (read <= 0) {\n                 break;\n             }\n-            output.write(b.array(), 0, readNow);\n-            b.rewind();\n+            byteArrayOutputStream.write(allocate.array(), 0, read);\n+            allocate.rewind();\n         }\n-        return output.toByteArray();\n+        return byteArrayOutputStream.toByteArray();\n     }\n     \n-    public static long skip(final InputStream input, long numToSkip) throws IOException {\n-        final long available = numToSkip;\n-        while (numToSkip > 0L) {\n-            final long skipped = input.skip(numToSkip);\n-            if (skipped == 0L) {\n+    public static long skip(final InputStream inputStream, long n) throws IOException {\n+        final long n2 = n;\n+        while (n > 0L) {\n+            final long skip = inputStream.skip(n);\n+            if (skip == 0L) {\n                 break;\n             }\n-            numToSkip -= skipped;\n+            n -= skip;\n         }\n-        while (numToSkip > 0L) {\n-            final int read = readFully(input, IOUtils.SKIP_BUF, 0, (int)Math.min(numToSkip, 4096L));\n-            if (read < 1) {\n+        while (n > 0L) {\n+            final int fully = readFully(inputStream, IOUtils.SKIP_BUF, 0, (int)Math.min(n, 4096L));\n+            if (fully < 1) {\n                 break;\n             }\n-            numToSkip -= read;\n+            n -= fully;\n         }\n-        return available - numToSkip;\n+        return n2 - n;\n     }\n     \n-    public static byte[] toByteArray(final InputStream input) throws IOException {\n-        final ByteArrayOutputStream output = new ByteArrayOutputStream();\n-        copy(input, output);\n-        return output.toByteArray();\n+    public static byte[] toByteArray(final InputStream inputStream) throws IOException {\n+        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+        copy(inputStream, byteArrayOutputStream);\n+        return byteArrayOutputStream.toByteArray();\n     }\n     \n     private IOUtils() {\n     }\n     \n     static {\n         EMPTY_LINK_OPTIONS = new LinkOption[0];\n"}]}
