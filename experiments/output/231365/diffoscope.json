{"diffoscope-json-version": 1, "source1": "first/ZipSplitReadOnlySeekableByteChannelTest.class", "source2": "second/ZipSplitReadOnlySeekableByteChannelTest.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,161 +1,142 @@\n \n package org.apache.commons.compress.utils;\n \n import java.util.Random;\n import java.nio.file.Path;\n+import java.io.File;\n import java.nio.file.Files;\n import java.nio.file.StandardOpenOption;\n import java.nio.file.OpenOption;\n import java.util.ArrayList;\n import java.util.Iterator;\n import java.nio.channels.SeekableByteChannel;\n import java.util.List;\n import org.apache.commons.compress.archivers.zip.ZipSplitReadOnlySeekableByteChannel;\n import org.junit.jupiter.api.Test;\n import java.io.IOException;\n-import java.io.File;\n import org.junit.jupiter.api.Assertions;\n import org.apache.commons.compress.AbstractTestCase;\n \n public class ZipSplitReadOnlySeekableByteChannelTest\n {\n     @Test\n     public void buildFromLastSplitSegmentThrowsOnNotZipFile() throws IOException {\n-        final File lastFile = AbstractTestCase.getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z01\");\n-        Assertions.assertThrows((Class)IllegalArgumentException.class, () -> ZipSplitReadOnlySeekableByteChannel.buildFromLastSplitSegment(lastFile));\n+        Assertions.assertThrows((Class)IllegalArgumentException.class, () -> ZipSplitReadOnlySeekableByteChannel.buildFromLastSplitSegment(file));\n     }\n     \n     @Test\n     public void channelsPositionIsZeroAfterConstructor() throws IOException {\n-        final List<SeekableByteChannel> channels = this.getSplitZipChannels();\n-        new ZipSplitReadOnlySeekableByteChannel((List)channels);\n-        for (final SeekableByteChannel channel : channels) {\n-            Assertions.assertEquals(0L, channel.position());\n+        final List<SeekableByteChannel> splitZipChannels = this.getSplitZipChannels();\n+        new ZipSplitReadOnlySeekableByteChannel((List)splitZipChannels);\n+        final Iterator<SeekableByteChannel> iterator = splitZipChannels.iterator();\n+        while (iterator.hasNext()) {\n+            Assertions.assertEquals(0L, ((SeekableByteChannel)iterator.next()).position());\n         }\n     }\n     \n     @Test\n     public void constructorThrowsOnNonSplitZipFiles() throws IOException {\n-        final List<SeekableByteChannel> channels = new ArrayList<SeekableByteChannel>();\n-        final File file = AbstractTestCase.getFile(\"COMPRESS-189.zip\");\n-        channels.add(Files.newByteChannel(file.toPath(), StandardOpenOption.READ));\n-        Assertions.assertThrows((Class)IOException.class, () -> new ZipSplitReadOnlySeekableByteChannel(channels));\n+        final ArrayList list = new ArrayList();\n+        list.add(Files.newByteChannel(AbstractTestCase.getFile(\"COMPRESS-189.zip\").toPath(), StandardOpenOption.READ));\n+        Assertions.assertThrows((Class)IOException.class, () -> new ZipSplitReadOnlySeekableByteChannel(list));\n     }\n     \n     @Test\n     public void constructorThrowsOnNullArg() {\n         Assertions.assertThrows((Class)NullPointerException.class, () -> new ZipSplitReadOnlySeekableByteChannel((List)null));\n     }\n     \n     @Test\n     public void forFilesOfTwoParametersThrowsOnNullArg() {\n         Assertions.assertThrows((Class)NullPointerException.class, () -> ZipSplitReadOnlySeekableByteChannel.forFiles((File)null, (Iterable)null));\n     }\n     \n     @Test\n     public void forFilesReturnCorrectClass() throws IOException {\n-        final File firstFile = AbstractTestCase.getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z01\");\n-        final File secondFile = AbstractTestCase.getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z02\");\n-        final File lastFile = AbstractTestCase.getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z01\");\n-        final ArrayList<File> list = new ArrayList<File>();\n-        list.add(firstFile);\n-        list.add(secondFile);\n-        SeekableByteChannel channel = ZipSplitReadOnlySeekableByteChannel.forFiles(lastFile, (Iterable)list);\n-        Assertions.assertTrue(channel instanceof ZipSplitReadOnlySeekableByteChannel);\n-        channel = ZipSplitReadOnlySeekableByteChannel.forFiles(new File[] { firstFile, secondFile, lastFile });\n-        Assertions.assertTrue(channel instanceof ZipSplitReadOnlySeekableByteChannel);\n+        final File file = AbstractTestCase.getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z01\");\n+        final File file2 = AbstractTestCase.getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z02\");\n+        final File file3 = AbstractTestCase.getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z01\");\n+        final ArrayList list = new ArrayList();\n+        list.add(file);\n+        list.add(file2);\n+        Assertions.assertTrue(ZipSplitReadOnlySeekableByteChannel.forFiles(file3, (Iterable)list) instanceof ZipSplitReadOnlySeekableByteChannel);\n+        Assertions.assertTrue(ZipSplitReadOnlySeekableByteChannel.forFiles(new File[] { file, file2, file3 }) instanceof ZipSplitReadOnlySeekableByteChannel);\n     }\n     \n     @Test\n     public void forFilesThrowsOnNullArg() {\n         Assertions.assertThrows((Class)NullPointerException.class, () -> ZipSplitReadOnlySeekableByteChannel.forFiles((File[])null));\n     }\n     \n     @Test\n     public void forOrderedSeekableByteChannelsOfTwoParametersThrowsOnNullArg() {\n         Assertions.assertThrows((Class)NullPointerException.class, () -> ZipSplitReadOnlySeekableByteChannel.forOrderedSeekableByteChannels((SeekableByteChannel)null, (Iterable)null));\n     }\n     \n     @Test\n     public void forOrderedSeekableByteChannelsReturnCorrectClass() throws IOException {\n-        final File file1 = AbstractTestCase.getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z01\");\n-        final SeekableByteChannel firstChannel = Files.newByteChannel(file1.toPath(), StandardOpenOption.READ);\n-        final File file2 = AbstractTestCase.getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z02\");\n-        final SeekableByteChannel secondChannel = Files.newByteChannel(file2.toPath(), StandardOpenOption.READ);\n-        final File lastFile = AbstractTestCase.getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.zip\");\n-        final SeekableByteChannel lastChannel = Files.newByteChannel(lastFile.toPath(), StandardOpenOption.READ);\n-        final List<SeekableByteChannel> channels = new ArrayList<SeekableByteChannel>();\n-        channels.add(firstChannel);\n-        channels.add(secondChannel);\n-        SeekableByteChannel channel = ZipSplitReadOnlySeekableByteChannel.forOrderedSeekableByteChannels(lastChannel, (Iterable)channels);\n-        Assertions.assertTrue(channel instanceof ZipSplitReadOnlySeekableByteChannel);\n-        channel = ZipSplitReadOnlySeekableByteChannel.forOrderedSeekableByteChannels(new SeekableByteChannel[] { firstChannel, secondChannel, lastChannel });\n-        Assertions.assertTrue(channel instanceof ZipSplitReadOnlySeekableByteChannel);\n+        final SeekableByteChannel byteChannel = Files.newByteChannel(AbstractTestCase.getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z01\").toPath(), StandardOpenOption.READ);\n+        final SeekableByteChannel byteChannel2 = Files.newByteChannel(AbstractTestCase.getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z02\").toPath(), StandardOpenOption.READ);\n+        final SeekableByteChannel byteChannel3 = Files.newByteChannel(AbstractTestCase.getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.zip\").toPath(), StandardOpenOption.READ);\n+        final ArrayList list = new ArrayList();\n+        list.add(byteChannel);\n+        list.add(byteChannel2);\n+        Assertions.assertTrue(ZipSplitReadOnlySeekableByteChannel.forOrderedSeekableByteChannels(byteChannel3, (Iterable)list) instanceof ZipSplitReadOnlySeekableByteChannel);\n+        Assertions.assertTrue(ZipSplitReadOnlySeekableByteChannel.forOrderedSeekableByteChannels(new SeekableByteChannel[] { byteChannel, byteChannel2, byteChannel3 }) instanceof ZipSplitReadOnlySeekableByteChannel);\n     }\n     \n     @Test\n     public void forOrderedSeekableByteChannelsReturnsIdentityForSingleElement() throws IOException {\n-        final SeekableByteChannel emptyChannel = (SeekableByteChannel)new SeekableInMemoryByteChannel(ByteUtils.EMPTY_BYTE_ARRAY);\n-        final SeekableByteChannel channel = ZipSplitReadOnlySeekableByteChannel.forOrderedSeekableByteChannels(new SeekableByteChannel[] { emptyChannel });\n-        Assertions.assertSame((Object)emptyChannel, (Object)channel);\n+        final SeekableInMemoryByteChannel seekableInMemoryByteChannel = new SeekableInMemoryByteChannel(ByteUtils.EMPTY_BYTE_ARRAY);\n+        Assertions.assertSame((Object)seekableInMemoryByteChannel, (Object)ZipSplitReadOnlySeekableByteChannel.forOrderedSeekableByteChannels(new SeekableByteChannel[] { (SeekableByteChannel)seekableInMemoryByteChannel }));\n     }\n     \n     @Test\n     public void forOrderedSeekableByteChannelsThrowsOnNullArg() {\n         Assertions.assertThrows((Class)NullPointerException.class, () -> ZipSplitReadOnlySeekableByteChannel.forOrderedSeekableByteChannels((SeekableByteChannel[])null));\n     }\n     \n     @Test\n     public void forPathsOfTwoParametersThrowsOnNullArg() {\n         Assertions.assertThrows((Class)NullPointerException.class, () -> ZipSplitReadOnlySeekableByteChannel.forPaths((Path)null, (Iterable)null));\n     }\n     \n     @Test\n     public void forPathsReturnCorrectClass() throws IOException {\n-        final Path firstFile = AbstractTestCase.getPath(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z01\");\n-        final Path secondFile = AbstractTestCase.getPath(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z02\");\n-        final Path lastFile = AbstractTestCase.getPath(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.zip\");\n-        final ArrayList<Path> list = new ArrayList<Path>();\n-        list.add(firstFile);\n-        list.add(secondFile);\n-        SeekableByteChannel channel = ZipSplitReadOnlySeekableByteChannel.forPaths(lastFile, (Iterable)list);\n-        Assertions.assertTrue(channel instanceof ZipSplitReadOnlySeekableByteChannel);\n-        channel = ZipSplitReadOnlySeekableByteChannel.forPaths(new Path[] { firstFile, secondFile, lastFile });\n-        Assertions.assertTrue(channel instanceof ZipSplitReadOnlySeekableByteChannel);\n+        final Path path = AbstractTestCase.getPath(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z01\");\n+        final Path path2 = AbstractTestCase.getPath(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z02\");\n+        final Path path3 = AbstractTestCase.getPath(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.zip\");\n+        final ArrayList list = new ArrayList();\n+        list.add(path);\n+        list.add(path2);\n+        Assertions.assertTrue(ZipSplitReadOnlySeekableByteChannel.forPaths(path3, (Iterable)list) instanceof ZipSplitReadOnlySeekableByteChannel);\n+        Assertions.assertTrue(ZipSplitReadOnlySeekableByteChannel.forPaths(new Path[] { path, path2, path3 }) instanceof ZipSplitReadOnlySeekableByteChannel);\n     }\n     \n     @Test\n     public void forPathsThrowsOnNullArg() {\n         Assertions.assertThrows((Class)NullPointerException.class, () -> ZipSplitReadOnlySeekableByteChannel.forPaths((Path[])null));\n     }\n     \n     private List<SeekableByteChannel> getSplitZipChannels() throws IOException {\n-        final List<SeekableByteChannel> channels = new ArrayList<SeekableByteChannel>();\n-        final File file1 = AbstractTestCase.getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z01\");\n-        channels.add(Files.newByteChannel(file1.toPath(), StandardOpenOption.READ));\n-        final File file2 = AbstractTestCase.getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z02\");\n-        channels.add(Files.newByteChannel(file2.toPath(), StandardOpenOption.READ));\n-        final File lastFile = AbstractTestCase.getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.zip\");\n-        channels.add(Files.newByteChannel(lastFile.toPath(), StandardOpenOption.READ));\n-        return channels;\n+        final ArrayList list = new ArrayList();\n+        list.add(Files.newByteChannel(AbstractTestCase.getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z01\").toPath(), StandardOpenOption.READ));\n+        list.add(Files.newByteChannel(AbstractTestCase.getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z02\").toPath(), StandardOpenOption.READ));\n+        list.add(Files.newByteChannel(AbstractTestCase.getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.zip\").toPath(), StandardOpenOption.READ));\n+        return list;\n     }\n     \n     @Test\n     public void positionToSomeZipSplitSegment() throws IOException {\n-        final File firstFile = AbstractTestCase.getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z01\");\n-        final int firstFileSize = (int)firstFile.length();\n-        final File secondFile = AbstractTestCase.getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z02\");\n-        final int secondFileSize = (int)secondFile.length();\n-        final File lastFile = AbstractTestCase.getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.zip\");\n-        final int lastFileSize = (int)lastFile.length();\n+        final int bound = (int)AbstractTestCase.getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z01\").length();\n+        final int n = (int)AbstractTestCase.getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.z02\").length();\n+        final File file = AbstractTestCase.getFile(\"COMPRESS-477/split_zip_created_by_zip/split_zip_created_by_zip.zip\");\n+        final int bound2 = (int)file.length();\n         final Random random = new Random();\n-        final int randomDiskNumber = random.nextInt(3);\n-        final int randomOffset = (randomDiskNumber < 2) ? random.nextInt(firstFileSize) : random.nextInt(lastFileSize);\n-        final ZipSplitReadOnlySeekableByteChannel channel = (ZipSplitReadOnlySeekableByteChannel)ZipSplitReadOnlySeekableByteChannel.buildFromLastSplitSegment(lastFile);\n-        channel.position((long)randomDiskNumber, (long)randomOffset);\n-        long expectedPosition = (long)randomOffset;\n-        expectedPosition += ((randomDiskNumber > 0) ? ((long)firstFileSize) : 0L);\n-        expectedPosition += ((randomDiskNumber > 1) ? ((long)secondFileSize) : 0L);\n-        Assertions.assertEquals(expectedPosition, channel.position());\n+        final int nextInt = random.nextInt(3);\n+        final int n2 = (nextInt < 2) ? random.nextInt(bound) : random.nextInt(bound2);\n+        final ZipSplitReadOnlySeekableByteChannel zipSplitReadOnlySeekableByteChannel = (ZipSplitReadOnlySeekableByteChannel)ZipSplitReadOnlySeekableByteChannel.buildFromLastSplitSegment(file);\n+        zipSplitReadOnlySeekableByteChannel.position((long)nextInt, (long)n2);\n+        Assertions.assertEquals(n2 + ((nextInt > 0) ? ((long)bound) : 0L) + ((nextInt > 1) ? ((long)n) : 0L), zipSplitReadOnlySeekableByteChannel.position());\n     }\n }\n"}]}
