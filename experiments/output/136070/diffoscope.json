{"diffoscope-json-version": 1, "source1": "first/Pass2Verifier$CPESSC_Visitor.class", "source2": "second/Pass2Verifier$CPESSC_Visitor.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -87,67 +87,68 @@\n         this.CONST_NameAndType = ConstantNameAndType.class;\n         this.CONST_Utf8 = ConstantUtf8.class;\n         (this.carrier = new DescendingVisitor(jc, (Visitor)this)).visit();\n     }\n     \n     private void checkIndex(final Node referrer, final int index, final Class<?> shouldbe) {\n         if (index < 0 || index >= this.cplen) {\n-            throw new ClassConstraintException(\"Invalid index '\" + index + \"' used by '\" + Pass2Verifier.access$000(referrer) + \"'.\");\n+            throw new ClassConstraintException(\"Invalid index '\" + index + \"' used by '\" + Pass2Verifier.access$0(referrer) + \"'.\");\n         }\n         final Constant c = this.cp.getConstant(index);\n         if (!shouldbe.isInstance(c)) {\n-            throw new ClassConstraintException(\"Illegal constant '\" + Pass2Verifier.access$000((Node)c) + \"' at index '\" + index + \"'. '\" + Pass2Verifier.access$000(referrer) + \"' expects a '\" + shouldbe + \"'.\");\n+            throw new ClassConstraintException(\"Illegal constant '\" + Pass2Verifier.access$0((Node)c) + \"' at index '\" + index + \"'. '\" + Pass2Verifier.access$0(referrer) + \"' expects a '\" + shouldbe + \"'.\");\n         }\n     }\n     \n     public void visitCode(final Code obj) {\n         try {\n             this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n             final String name = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n             if (!name.equals(\"Code\")) {\n-                throw new ClassConstraintException(\"The Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' is not correctly named 'Code' but '\" + name + \"'.\");\n+                throw new ClassConstraintException(\"The Code attribute '\" + Pass2Verifier.access$0((Node)obj) + \"' is not correctly named 'Code' but '\" + name + \"'.\");\n             }\n             if (!(this.carrier.predecessor() instanceof Method)) {\n-                this.this$0.addMessage(\"Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' is not declared in a method_info structure but in '\" + this.carrier.predecessor() + \"'. Ignored.\");\n+                this.this$0.addMessage(\"Code attribute '\" + Pass2Verifier.access$0((Node)obj) + \"' is not declared in a method_info structure but in '\" + this.carrier.predecessor() + \"'. Ignored.\");\n                 return;\n             }\n             final Method m = (Method)this.carrier.predecessor();\n             if (obj.getCode().length == 0) {\n-                throw new ClassConstraintException(\"Code array of Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' (method '\" + m + \"') must not be empty.\");\n+                throw new ClassConstraintException(\"Code array of Code attribute '\" + Pass2Verifier.access$0((Node)obj) + \"' (method '\" + m + \"') must not be empty.\");\n             }\n-            final CodeException[] exceptionTable;\n-            final CodeException[] excTable = exceptionTable = obj.getExceptionTable();\n-            for (final CodeException element : exceptionTable) {\n+            final CodeException[] excTable = obj.getExceptionTable();\n+            CodeException[] array;\n+            for (int length = (array = excTable).length, i = 0; i < length; ++i) {\n+                final CodeException element = array[i];\n                 final int excIndex = element.getCatchType();\n                 if (excIndex != 0) {\n                     this.checkIndex((Node)obj, excIndex, this.CONST_Class);\n                     final ConstantClass cc = (ConstantClass)this.cp.getConstant(excIndex);\n                     this.checkIndex((Node)cc, cc.getNameIndex(), this.CONST_Utf8);\n                     final String cname = Utility.pathToPackage(((ConstantUtf8)this.cp.getConstant(cc.getNameIndex())).getBytes());\n                     Verifier v = VerifierFactory.getVerifier(cname);\n                     VerificationResult vr = v.doPass1();\n                     if (vr != VerificationResult.VR_OK) {\n-                        throw new ClassConstraintException(\"Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' (method '\" + m + \"') has an exception_table entry '\" + Pass2Verifier.access$000((Node)element) + \"' that references '\" + cname + \"' as an Exception but it does not pass verification pass 1: \" + vr);\n+                        throw new ClassConstraintException(\"Code attribute '\" + Pass2Verifier.access$0((Node)obj) + \"' (method '\" + m + \"') has an exception_table entry '\" + Pass2Verifier.access$0((Node)element) + \"' that references '\" + cname + \"' as an Exception but it does not pass verification pass 1: \" + vr);\n                     }\n                     JavaClass e = Repository.lookupClass(cname);\n                     final JavaClass t = Repository.lookupClass(Type.THROWABLE.getClassName());\n                     for (JavaClass o = Repository.lookupClass(Type.OBJECT.getClassName()); e != o && e != t; e = Repository.lookupClass(e.getSuperclassName())) {\n                         v = VerifierFactory.getVerifier(e.getSuperclassName());\n                         vr = v.doPass1();\n                         if (vr != VerificationResult.VR_OK) {\n-                            throw new ClassConstraintException(\"Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' (method '\" + m + \"') has an exception_table entry '\" + Pass2Verifier.access$000((Node)element) + \"' that references '\" + cname + \"' as an Exception but '\" + e.getSuperclassName() + \"' in the ancestor hierachy does not pass verification pass 1: \" + vr);\n+                            throw new ClassConstraintException(\"Code attribute '\" + Pass2Verifier.access$0((Node)obj) + \"' (method '\" + m + \"') has an exception_table entry '\" + Pass2Verifier.access$0((Node)element) + \"' that references '\" + cname + \"' as an Exception but '\" + e.getSuperclassName() + \"' in the ancestor hierachy does not pass verification pass 1: \" + vr);\n                         }\n                     }\n                     if (e != t) {\n-                        throw new ClassConstraintException(\"Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' (method '\" + m + \"') has an exception_table entry '\" + Pass2Verifier.access$000((Node)element) + \"' that references '\" + cname + \"' as an Exception but it is not a subclass of '\" + t.getClassName() + \"'.\");\n+                        throw new ClassConstraintException(\"Code attribute '\" + Pass2Verifier.access$0((Node)obj) + \"' (method '\" + m + \"') has an exception_table entry '\" + Pass2Verifier.access$0((Node)element) + \"' that references '\" + cname + \"' as an Exception but it is not a subclass of '\" + t.getClassName() + \"'.\");\n                     }\n                 }\n             }\n             int methodNumber = -1;\n-            final Method[] ms = Repository.lookupClass(Pass2Verifier.access$100(this.this$0).getClassName()).getMethods();\n+            final Method[] ms = Repository.lookupClass(Pass2Verifier.access$1(this.this$0).getClassName()).getMethods();\n             for (int mn = 0; mn < ms.length; ++mn) {\n                 if (m == ms[mn]) {\n                     methodNumber = mn;\n                     break;\n                 }\n             }\n             if (methodNumber < 0) {\n@@ -157,222 +158,226 @@\n                         break;\n                     }\n                 }\n             }\n             if (methodNumber < 0) {\n                 throw new AssertionViolatedException(\"Could not find a known BCEL Method object in the corresponding BCEL JavaClass object.\");\n             }\n-            Pass2Verifier.access$200(this.this$0)[methodNumber] = new LocalVariablesInfo(obj.getMaxLocals());\n+            Pass2Verifier.access$2(this.this$0)[methodNumber] = new LocalVariablesInfo(obj.getMaxLocals());\n             int numOfLvtAttribs = 0;\n-            final Attribute[] attributes;\n-            final Attribute[] atts = attributes = obj.getAttributes();\n-            for (final Attribute att : attributes) {\n+            final Attribute[] atts = obj.getAttributes();\n+            Attribute[] array2;\n+            for (int length2 = (array2 = atts).length, j = 0; j < length2; ++j) {\n+                final Attribute att = array2[j];\n                 if (!(att instanceof LineNumberTable) && !(att instanceof LocalVariableTable)) {\n-                    this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$000((Node)att) + \"' as an attribute of Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' (method '\" + m + \"') is unknown and will therefore be ignored.\");\n+                    this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$0((Node)att) + \"' as an attribute of Code attribute '\" + Pass2Verifier.access$0((Node)obj) + \"' (method '\" + m + \"') is unknown and will therefore be ignored.\");\n                 }\n                 else {\n-                    this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$000((Node)att) + \"' as an attribute of Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' (method '\" + m + \"') will effectively be ignored and is only useful for debuggers and such.\");\n+                    this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$0((Node)att) + \"' as an attribute of Code attribute '\" + Pass2Verifier.access$0((Node)obj) + \"' (method '\" + m + \"') will effectively be ignored and is only useful for debuggers and such.\");\n                 }\n                 if (att instanceof LocalVariableTable) {\n                     final LocalVariableTable lvt = (LocalVariableTable)att;\n                     this.checkIndex((Node)lvt, lvt.getNameIndex(), this.CONST_Utf8);\n                     final String lvtname = ((ConstantUtf8)this.cp.getConstant(lvt.getNameIndex())).getBytes();\n                     if (!lvtname.equals(\"LocalVariableTable\")) {\n-                        throw new ClassConstraintException(\"The LocalVariableTable attribute '\" + Pass2Verifier.access$000((Node)lvt) + \"' is not correctly named 'LocalVariableTable' but '\" + lvtname + \"'.\");\n+                        throw new ClassConstraintException(\"The LocalVariableTable attribute '\" + Pass2Verifier.access$0((Node)lvt) + \"' is not correctly named 'LocalVariableTable' but '\" + lvtname + \"'.\");\n                     }\n-                    for (final LocalVariable localvariable : lvt.getLocalVariableTable()) {\n+                    LocalVariable[] localVariableTable;\n+                    for (int length3 = (localVariableTable = lvt.getLocalVariableTable()).length, k = 0; k < length3; ++k) {\n+                        final LocalVariable localvariable = localVariableTable[k];\n                         this.checkIndex((Node)lvt, localvariable.getNameIndex(), this.CONST_Utf8);\n                         final String localname = ((ConstantUtf8)this.cp.getConstant(localvariable.getNameIndex())).getBytes();\n-                        if (!Pass2Verifier.access$300(localname)) {\n-                            throw new ClassConstraintException(\"LocalVariableTable '\" + Pass2Verifier.access$000((Node)lvt) + \"' references a local variable by the name '\" + localname + \"' which is not a legal Java simple name.\");\n+                        if (!Pass2Verifier.access$3(localname)) {\n+                            throw new ClassConstraintException(\"LocalVariableTable '\" + Pass2Verifier.access$0((Node)lvt) + \"' references a local variable by the name '\" + localname + \"' which is not a legal Java simple name.\");\n                         }\n                         this.checkIndex((Node)lvt, localvariable.getSignatureIndex(), this.CONST_Utf8);\n                         final String localsig = ((ConstantUtf8)this.cp.getConstant(localvariable.getSignatureIndex())).getBytes();\n                         Type t2;\n                         try {\n                             t2 = Type.getType(localsig);\n                         }\n                         catch (final ClassFormatException cfe) {\n-                            throw new ClassConstraintException(\"Illegal descriptor (==signature) '\" + localsig + \"' used by LocalVariable '\" + Pass2Verifier.access$000((Node)localvariable) + \"' referenced by '\" + Pass2Verifier.access$000((Node)lvt) + \"'.\", (Throwable)cfe);\n+                            throw new ClassConstraintException(\"Illegal descriptor (==signature) '\" + localsig + \"' used by LocalVariable '\" + Pass2Verifier.access$0((Node)localvariable) + \"' referenced by '\" + Pass2Verifier.access$0((Node)lvt) + \"'.\", (Throwable)cfe);\n                         }\n                         final int localindex = localvariable.getIndex();\n                         if (((t2 == Type.LONG || t2 == Type.DOUBLE) ? (localindex + 1) : localindex) >= obj.getMaxLocals()) {\n-                            throw new ClassConstraintException(\"LocalVariableTable attribute '\" + Pass2Verifier.access$000((Node)lvt) + \"' references a LocalVariable '\" + Pass2Verifier.access$000((Node)localvariable) + \"' with an index that exceeds the surrounding Code attribute's max_locals value of '\" + obj.getMaxLocals() + \"'.\");\n+                            throw new ClassConstraintException(\"LocalVariableTable attribute '\" + Pass2Verifier.access$0((Node)lvt) + \"' references a LocalVariable '\" + Pass2Verifier.access$0((Node)localvariable) + \"' with an index that exceeds the surrounding Code attribute's max_locals value of '\" + obj.getMaxLocals() + \"'.\");\n                         }\n                         try {\n-                            Pass2Verifier.access$200(this.this$0)[methodNumber].add(localindex, localname, localvariable.getStartPC(), localvariable.getLength(), t2);\n+                            Pass2Verifier.access$2(this.this$0)[methodNumber].add(localindex, localname, localvariable.getStartPC(), localvariable.getLength(), t2);\n                         }\n                         catch (final LocalVariableInfoInconsistentException lviie) {\n-                            throw new ClassConstraintException(\"Conflicting information in LocalVariableTable '\" + Pass2Verifier.access$000((Node)lvt) + \"' found in Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' (method '\" + Pass2Verifier.access$000((Node)m) + \"'). \" + lviie.getMessage(), (Throwable)lviie);\n+                            throw new ClassConstraintException(\"Conflicting information in LocalVariableTable '\" + Pass2Verifier.access$0((Node)lvt) + \"' found in Code attribute '\" + Pass2Verifier.access$0((Node)obj) + \"' (method '\" + Pass2Verifier.access$0((Node)m) + \"'). \" + lviie.getMessage(), (Throwable)lviie);\n                         }\n                     }\n                     ++numOfLvtAttribs;\n                     if (!m.isStatic() && numOfLvtAttribs > obj.getMaxLocals()) {\n-                        throw new ClassConstraintException(\"Number of LocalVariableTable attributes of Code attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' (method '\" + Pass2Verifier.access$000((Node)m) + \"') exceeds number of local variable slots '\" + obj.getMaxLocals() + \"' ('There may be at most one LocalVariableTable attribute per local variable in the Code attribute.').\");\n+                        throw new ClassConstraintException(\"Number of LocalVariableTable attributes of Code attribute '\" + Pass2Verifier.access$0((Node)obj) + \"' (method '\" + Pass2Verifier.access$0((Node)m) + \"') exceeds number of local variable slots '\" + obj.getMaxLocals() + \"' ('There may be at most one LocalVariableTable attribute per local variable in the Code attribute.').\");\n                     }\n                 }\n             }\n         }\n         catch (final ClassNotFoundException e2) {\n             throw new AssertionViolatedException(\"Missing class: \" + e2, (Throwable)e2);\n         }\n     }\n     \n     public void visitCodeException(final CodeException obj) {\n     }\n     \n     public void visitConstantClass(final ConstantClass obj) {\n         if (obj.getTag() != 7) {\n-            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n+            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$0((Node)obj) + \"'.\");\n         }\n         this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n     }\n     \n     public void visitConstantDouble(final ConstantDouble obj) {\n         if (obj.getTag() != 6) {\n-            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n+            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$0((Node)obj) + \"'.\");\n         }\n     }\n     \n     public void visitConstantFieldref(final ConstantFieldref obj) {\n         if (obj.getTag() != 9) {\n-            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n+            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$0((Node)obj) + \"'.\");\n         }\n         this.checkIndex((Node)obj, obj.getClassIndex(), this.CONST_Class);\n         this.checkIndex((Node)obj, obj.getNameAndTypeIndex(), this.CONST_NameAndType);\n     }\n     \n     public void visitConstantFloat(final ConstantFloat obj) {\n         if (obj.getTag() != 4) {\n-            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n+            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$0((Node)obj) + \"'.\");\n         }\n     }\n     \n     public void visitConstantInteger(final ConstantInteger obj) {\n         if (obj.getTag() != 3) {\n-            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n+            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$0((Node)obj) + \"'.\");\n         }\n     }\n     \n     public void visitConstantInterfaceMethodref(final ConstantInterfaceMethodref obj) {\n         if (obj.getTag() != 11) {\n-            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n+            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$0((Node)obj) + \"'.\");\n         }\n         this.checkIndex((Node)obj, obj.getClassIndex(), this.CONST_Class);\n         this.checkIndex((Node)obj, obj.getNameAndTypeIndex(), this.CONST_NameAndType);\n     }\n     \n     public void visitConstantLong(final ConstantLong obj) {\n         if (obj.getTag() != 5) {\n-            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n+            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$0((Node)obj) + \"'.\");\n         }\n     }\n     \n     public void visitConstantMethodref(final ConstantMethodref obj) {\n         if (obj.getTag() != 10) {\n-            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n+            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$0((Node)obj) + \"'.\");\n         }\n         this.checkIndex((Node)obj, obj.getClassIndex(), this.CONST_Class);\n         this.checkIndex((Node)obj, obj.getNameAndTypeIndex(), this.CONST_NameAndType);\n     }\n     \n     public void visitConstantNameAndType(final ConstantNameAndType obj) {\n         if (obj.getTag() != 12) {\n-            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n+            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$0((Node)obj) + \"'.\");\n         }\n         this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n         this.checkIndex((Node)obj, obj.getSignatureIndex(), this.CONST_Utf8);\n     }\n     \n     public void visitConstantPool(final ConstantPool obj) {\n     }\n     \n     public void visitConstantString(final ConstantString obj) {\n         if (obj.getTag() != 8) {\n-            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n+            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$0((Node)obj) + \"'.\");\n         }\n         this.checkIndex((Node)obj, obj.getStringIndex(), this.CONST_Utf8);\n     }\n     \n     public void visitConstantUtf8(final ConstantUtf8 obj) {\n         if (obj.getTag() != 1) {\n-            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n+            throw new ClassConstraintException(\"Wrong constant tag in '\" + Pass2Verifier.access$0((Node)obj) + \"'.\");\n         }\n     }\n     \n     public void visitConstantValue(final ConstantValue obj) {\n         this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n         final String name = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n         if (!name.equals(\"ConstantValue\")) {\n-            throw new ClassConstraintException(\"The ConstantValue attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' is not correctly named 'ConstantValue' but '\" + name + \"'.\");\n+            throw new ClassConstraintException(\"The ConstantValue attribute '\" + Pass2Verifier.access$0((Node)obj) + \"' is not correctly named 'ConstantValue' but '\" + name + \"'.\");\n         }\n         final Object pred = this.carrier.predecessor();\n         if (!(pred instanceof Field)) {\n             return;\n         }\n         final Field f = (Field)pred;\n         final Type fieldType = Type.getType(((ConstantUtf8)this.cp.getConstant(f.getSignatureIndex())).getBytes());\n         final int index = obj.getConstantValueIndex();\n         if (index < 0 || index >= this.cplen) {\n-            throw new ClassConstraintException(\"Invalid index '\" + index + \"' used by '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n+            throw new ClassConstraintException(\"Invalid index '\" + index + \"' used by '\" + Pass2Verifier.access$0((Node)obj) + \"'.\");\n         }\n         final Constant c = this.cp.getConstant(index);\n         if ((this.CONST_Long.isInstance(c) && fieldType.equals((Object)Type.LONG)) || (this.CONST_Float.isInstance(c) && fieldType.equals((Object)Type.FLOAT))) {\n             return;\n         }\n         if (this.CONST_Double.isInstance(c) && fieldType.equals((Object)Type.DOUBLE)) {\n             return;\n         }\n         if (this.CONST_Integer.isInstance(c) && (fieldType.equals((Object)Type.INT) || fieldType.equals((Object)Type.SHORT) || fieldType.equals((Object)Type.CHAR) || fieldType.equals((Object)Type.BYTE) || fieldType.equals((Object)Type.BOOLEAN))) {\n             return;\n         }\n         if (this.CONST_String.isInstance(c) && fieldType.equals((Object)Type.STRING)) {\n             return;\n         }\n-        throw new ClassConstraintException(\"Illegal type of ConstantValue '\" + obj + \"' embedding Constant '\" + c + \"'. It is referenced by field '\" + Pass2Verifier.access$000((Node)f) + \"' expecting a different type: '\" + fieldType + \"'.\");\n+        throw new ClassConstraintException(\"Illegal type of ConstantValue '\" + obj + \"' embedding Constant '\" + c + \"'. It is referenced by field '\" + Pass2Verifier.access$0((Node)f) + \"' expecting a different type: '\" + fieldType + \"'.\");\n     }\n     \n     public void visitDeprecated(final Deprecated obj) {\n         this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n         final String name = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n         if (!name.equals(\"Deprecated\")) {\n-            throw new ClassConstraintException(\"The Deprecated attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' is not correctly named 'Deprecated' but '\" + name + \"'.\");\n+            throw new ClassConstraintException(\"The Deprecated attribute '\" + Pass2Verifier.access$0((Node)obj) + \"' is not correctly named 'Deprecated' but '\" + name + \"'.\");\n         }\n     }\n     \n     public void visitExceptionTable(final ExceptionTable obj) {\n         try {\n             this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n             final String name = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n             if (!name.equals(\"Exceptions\")) {\n-                throw new ClassConstraintException(\"The Exceptions attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' is not correctly named 'Exceptions' but '\" + name + \"'.\");\n+                throw new ClassConstraintException(\"The Exceptions attribute '\" + Pass2Verifier.access$0((Node)obj) + \"' is not correctly named 'Exceptions' but '\" + name + \"'.\");\n             }\n-            final int[] exceptionIndexTable;\n-            final int[] excIndices = exceptionIndexTable = obj.getExceptionIndexTable();\n-            for (final int excIndice : exceptionIndexTable) {\n+            final int[] excIndices = obj.getExceptionIndexTable();\n+            int[] array;\n+            for (int length = (array = excIndices).length, i = 0; i < length; ++i) {\n+                final int excIndice = array[i];\n                 this.checkIndex((Node)obj, excIndice, this.CONST_Class);\n                 final ConstantClass cc = (ConstantClass)this.cp.getConstant(excIndice);\n                 this.checkIndex((Node)cc, cc.getNameIndex(), this.CONST_Utf8);\n                 final String cname = Utility.pathToPackage(((ConstantUtf8)this.cp.getConstant(cc.getNameIndex())).getBytes());\n                 Verifier v = VerifierFactory.getVerifier(cname);\n                 VerificationResult vr = v.doPass1();\n                 if (vr != VerificationResult.VR_OK) {\n-                    throw new ClassConstraintException(\"Exceptions attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' references '\" + cname + \"' as an Exception but it does not pass verification pass 1: \" + vr);\n+                    throw new ClassConstraintException(\"Exceptions attribute '\" + Pass2Verifier.access$0((Node)obj) + \"' references '\" + cname + \"' as an Exception but it does not pass verification pass 1: \" + vr);\n                 }\n                 JavaClass e = Repository.lookupClass(cname);\n                 final JavaClass t = Repository.lookupClass(Type.THROWABLE.getClassName());\n                 for (JavaClass o = Repository.lookupClass(Type.OBJECT.getClassName()); e != o && e != t; e = Repository.lookupClass(e.getSuperclassName())) {\n                     v = VerifierFactory.getVerifier(e.getSuperclassName());\n                     vr = v.doPass1();\n                     if (vr != VerificationResult.VR_OK) {\n-                        throw new ClassConstraintException(\"Exceptions attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' references '\" + cname + \"' as an Exception but '\" + e.getSuperclassName() + \"' in the ancestor hierachy does not pass verification pass 1: \" + vr);\n+                        throw new ClassConstraintException(\"Exceptions attribute '\" + Pass2Verifier.access$0((Node)obj) + \"' references '\" + cname + \"' as an Exception but '\" + e.getSuperclassName() + \"' in the ancestor hierachy does not pass verification pass 1: \" + vr);\n                     }\n                 }\n                 if (e != t) {\n-                    throw new ClassConstraintException(\"Exceptions attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' references '\" + cname + \"' as an Exception but it is not a subclass of '\" + t.getClassName() + \"'.\");\n+                    throw new ClassConstraintException(\"Exceptions attribute '\" + Pass2Verifier.access$0((Node)obj) + \"' references '\" + cname + \"' as an Exception but it is not a subclass of '\" + t.getClassName() + \"'.\");\n                 }\n             }\n         }\n         catch (final ClassNotFoundException e2) {\n             throw new AssertionViolatedException(\"Missing class: \" + e2, (Throwable)e2);\n         }\n     }\n@@ -386,282 +391,287 @@\n             if (obj.isProtected()) {\n                 ++maxone;\n             }\n             if (obj.isPublic()) {\n                 ++maxone;\n             }\n             if (maxone > 1) {\n-                throw new ClassConstraintException(\"Field '\" + Pass2Verifier.access$000((Node)obj) + \"' must only have at most one of its ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC modifiers set.\");\n+                throw new ClassConstraintException(\"Field '\" + Pass2Verifier.access$0((Node)obj) + \"' must only have at most one of its ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC modifiers set.\");\n             }\n             if (obj.isFinal() && obj.isVolatile()) {\n-                throw new ClassConstraintException(\"Field '\" + Pass2Verifier.access$000((Node)obj) + \"' must only have at most one of its ACC_FINAL, ACC_VOLATILE modifiers set.\");\n+                throw new ClassConstraintException(\"Field '\" + Pass2Verifier.access$0((Node)obj) + \"' must only have at most one of its ACC_FINAL, ACC_VOLATILE modifiers set.\");\n             }\n         }\n         else {\n             if (!obj.isPublic()) {\n-                throw new ClassConstraintException(\"Interface field '\" + Pass2Verifier.access$000((Node)obj) + \"' must have the ACC_PUBLIC modifier set but hasn't!\");\n+                throw new ClassConstraintException(\"Interface field '\" + Pass2Verifier.access$0((Node)obj) + \"' must have the ACC_PUBLIC modifier set but hasn't!\");\n             }\n             if (!obj.isStatic()) {\n-                throw new ClassConstraintException(\"Interface field '\" + Pass2Verifier.access$000((Node)obj) + \"' must have the ACC_STATIC modifier set but hasn't!\");\n+                throw new ClassConstraintException(\"Interface field '\" + Pass2Verifier.access$0((Node)obj) + \"' must have the ACC_STATIC modifier set but hasn't!\");\n             }\n             if (!obj.isFinal()) {\n-                throw new ClassConstraintException(\"Interface field '\" + Pass2Verifier.access$000((Node)obj) + \"' must have the ACC_FINAL modifier set but hasn't!\");\n+                throw new ClassConstraintException(\"Interface field '\" + Pass2Verifier.access$0((Node)obj) + \"' must have the ACC_FINAL modifier set but hasn't!\");\n             }\n         }\n         if ((obj.getAccessFlags() & 0xFFFFFF20) > 0) {\n-            this.this$0.addMessage(\"Field '\" + Pass2Verifier.access$000((Node)obj) + \"' has access flag(s) other than ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_VOLATILE, ACC_TRANSIENT set (ignored).\");\n+            this.this$0.addMessage(\"Field '\" + Pass2Verifier.access$0((Node)obj) + \"' has access flag(s) other than ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED,\" + \" ACC_STATIC, ACC_FINAL, ACC_VOLATILE, ACC_TRANSIENT set (ignored).\");\n         }\n         this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n         final String name = obj.getName();\n-        if (!Pass2Verifier.access$400(name)) {\n-            throw new ClassConstraintException(\"Field '\" + Pass2Verifier.access$000((Node)obj) + \"' has illegal name '\" + obj.getName() + \"'.\");\n+        if (!Pass2Verifier.access$4(name)) {\n+            throw new ClassConstraintException(\"Field '\" + Pass2Verifier.access$0((Node)obj) + \"' has illegal name '\" + obj.getName() + \"'.\");\n         }\n         this.checkIndex((Node)obj, obj.getSignatureIndex(), this.CONST_Utf8);\n         final String sig = ((ConstantUtf8)this.cp.getConstant(obj.getSignatureIndex())).getBytes();\n         try {\n             Type.getType(sig);\n         }\n         catch (final ClassFormatException cfe) {\n-            throw new ClassConstraintException(\"Illegal descriptor (==signature) '\" + sig + \"' used by '\" + Pass2Verifier.access$000((Node)obj) + \"'.\", (Throwable)cfe);\n+            throw new ClassConstraintException(\"Illegal descriptor (==signature) '\" + sig + \"' used by '\" + Pass2Verifier.access$0((Node)obj) + \"'.\", (Throwable)cfe);\n         }\n-        final String nameanddesc = name + sig;\n+        final String nameanddesc = String.valueOf(name) + sig;\n         if (this.fieldNamesAndDesc.contains(nameanddesc)) {\n-            throw new ClassConstraintException(\"No two fields (like '\" + Pass2Verifier.access$000((Node)obj) + \"') are allowed have same names and descriptors!\");\n+            throw new ClassConstraintException(\"No two fields (like '\" + Pass2Verifier.access$0((Node)obj) + \"') are allowed have same names and descriptors!\");\n         }\n         if (this.fieldNames.contains(name)) {\n             this.this$0.addMessage(\"More than one field of name '\" + name + \"' detected (but with different type descriptors). This is very unusual.\");\n         }\n         this.fieldNamesAndDesc.add(nameanddesc);\n         this.fieldNames.add(name);\n-        final Attribute[] attributes;\n-        final Attribute[] atts = attributes = obj.getAttributes();\n-        for (final Attribute att : attributes) {\n+        final Attribute[] atts = obj.getAttributes();\n+        Attribute[] array;\n+        for (int length = (array = atts).length, i = 0; i < length; ++i) {\n+            final Attribute att = array[i];\n             if (!(att instanceof ConstantValue) && !(att instanceof Synthetic) && !(att instanceof Deprecated)) {\n-                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$000((Node)att) + \"' as an attribute of Field '\" + Pass2Verifier.access$000((Node)obj) + \"' is unknown and will therefore be ignored.\");\n+                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$0((Node)att) + \"' as an attribute of Field '\" + Pass2Verifier.access$0((Node)obj) + \"' is unknown and will therefore be ignored.\");\n             }\n             if (!(att instanceof ConstantValue)) {\n-                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$000((Node)att) + \"' as an attribute of Field '\" + Pass2Verifier.access$000((Node)obj) + \"' is not a ConstantValue and is therefore only of use for debuggers and such.\");\n+                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$0((Node)att) + \"' as an attribute of Field '\" + Pass2Verifier.access$0((Node)obj) + \"' is not a ConstantValue and is therefore only of use for debuggers and such.\");\n             }\n         }\n     }\n     \n     public void visitInnerClass(final InnerClass obj) {\n     }\n     \n     public void visitInnerClasses(final InnerClasses innerClasses) {\n         this.checkIndex((Node)innerClasses, innerClasses.getNameIndex(), this.CONST_Utf8);\n         final String name = ((ConstantUtf8)this.cp.getConstant(innerClasses.getNameIndex())).getBytes();\n         if (!name.equals(\"InnerClasses\")) {\n-            throw new ClassConstraintException(\"The InnerClasses attribute '\" + Pass2Verifier.access$000((Node)innerClasses) + \"' is not correctly named 'InnerClasses' but '\" + name + \"'.\");\n+            throw new ClassConstraintException(\"The InnerClasses attribute '\" + Pass2Verifier.access$0((Node)innerClasses) + \"' is not correctly named 'InnerClasses' but '\" + name + \"'.\");\n         }\n-        innerClasses.forEach(this::lambda$visitInnerClasses$0);\n+        innerClasses.forEach(this::lambda$0);\n     }\n     \n     public void visitJavaClass(final JavaClass obj) {\n         final Attribute[] atts = obj.getAttributes();\n         boolean foundSourceFile = false;\n         boolean foundInnerClasses = false;\n         final boolean hasInnerClass = new Pass2Verifier.InnerClassDetector(this.jc).innerClassReferenced();\n-        for (final Attribute att : atts) {\n+        Attribute[] array;\n+        for (int length = (array = atts).length, i = 0; i < length; ++i) {\n+            final Attribute att = array[i];\n             if (!(att instanceof SourceFile) && !(att instanceof Deprecated) && !(att instanceof InnerClasses) && !(att instanceof Synthetic)) {\n-                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$000((Node)att) + \"' as an attribute of the ClassFile structure '\" + Pass2Verifier.access$000((Node)obj) + \"' is unknown and will therefore be ignored.\");\n+                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$0((Node)att) + \"' as an attribute of the ClassFile structure '\" + Pass2Verifier.access$0((Node)obj) + \"' is unknown and will therefore be ignored.\");\n             }\n             if (att instanceof SourceFile) {\n                 if (foundSourceFile) {\n-                    throw new ClassConstraintException(\"A ClassFile structure (like '\" + Pass2Verifier.access$000((Node)obj) + \"') may have no more than one SourceFile attribute.\");\n+                    throw new ClassConstraintException(\"A ClassFile structure (like '\" + Pass2Verifier.access$0((Node)obj) + \"') may have no more than one SourceFile attribute.\");\n                 }\n                 foundSourceFile = true;\n             }\n             if (att instanceof InnerClasses) {\n                 if (!foundInnerClasses) {\n                     foundInnerClasses = true;\n                 }\n                 else if (hasInnerClass) {\n-                    throw new ClassConstraintException(\"A Classfile structure (like '\" + Pass2Verifier.access$000((Node)obj) + \"') must have exactly one InnerClasses attribute if at least one Inner Class is referenced (which is the case). More than one InnerClasses attribute was found.\");\n+                    throw new ClassConstraintException(\"A Classfile structure (like '\" + Pass2Verifier.access$0((Node)obj) + \"') must have exactly one InnerClasses attribute\" + \" if at least one Inner Class is referenced (which is the case).\" + \" More than one InnerClasses attribute was found.\");\n                 }\n                 if (!hasInnerClass) {\n-                    this.this$0.addMessage(\"No referenced Inner Class found, but InnerClasses attribute '\" + Pass2Verifier.access$000((Node)att) + \"' found. Strongly suggest removal of that attribute.\");\n+                    this.this$0.addMessage(\"No referenced Inner Class found, but InnerClasses attribute '\" + Pass2Verifier.access$0((Node)att) + \"' found. Strongly suggest removal of that attribute.\");\n                 }\n             }\n         }\n         if (hasInnerClass && !foundInnerClasses) {\n-            this.this$0.addMessage(\"A Classfile structure (like '\" + Pass2Verifier.access$000((Node)obj) + \"') must have exactly one InnerClasses attribute if at least one Inner Class is referenced (which is the case). No InnerClasses attribute was found.\");\n+            this.this$0.addMessage(\"A Classfile structure (like '\" + Pass2Verifier.access$0((Node)obj) + \"') must have exactly one InnerClasses attribute if at least one Inner Class is referenced (which is the case).\" + \" No InnerClasses attribute was found.\");\n         }\n     }\n     \n     public void visitLineNumber(final LineNumber obj) {\n     }\n     \n     public void visitLineNumberTable(final LineNumberTable obj) {\n         this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n         final String name = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n         if (!name.equals(\"LineNumberTable\")) {\n-            throw new ClassConstraintException(\"The LineNumberTable attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' is not correctly named 'LineNumberTable' but '\" + name + \"'.\");\n+            throw new ClassConstraintException(\"The LineNumberTable attribute '\" + Pass2Verifier.access$0((Node)obj) + \"' is not correctly named 'LineNumberTable' but '\" + name + \"'.\");\n         }\n     }\n     \n     public void visitLocalVariable(final LocalVariable obj) {\n     }\n     \n     public void visitLocalVariableTable(final LocalVariableTable obj) {\n     }\n     \n     public void visitMethod(final Method obj) {\n         this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n         final String name = obj.getName();\n-        if (!Pass2Verifier.access$500(name, true)) {\n-            throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$000((Node)obj) + \"' has illegal name '\" + name + \"'.\");\n+        if (!Pass2Verifier.access$5(name, true)) {\n+            throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$0((Node)obj) + \"' has illegal name '\" + name + \"'.\");\n         }\n         this.checkIndex((Node)obj, obj.getSignatureIndex(), this.CONST_Utf8);\n         final String sig = ((ConstantUtf8)this.cp.getConstant(obj.getSignatureIndex())).getBytes();\n         Type t;\n         Type[] ts;\n         try {\n             t = Type.getReturnType(sig);\n             ts = Type.getArgumentTypes(sig);\n         }\n         catch (final ClassFormatException cfe) {\n-            throw new ClassConstraintException(\"Illegal descriptor (==signature) '\" + sig + \"' used by Method '\" + Pass2Verifier.access$000((Node)obj) + \"'.\", (Throwable)cfe);\n+            throw new ClassConstraintException(\"Illegal descriptor (==signature) '\" + sig + \"' used by Method '\" + Pass2Verifier.access$0((Node)obj) + \"'.\", (Throwable)cfe);\n         }\n         Type act = t;\n         if (act instanceof ArrayType) {\n             act = ((ArrayType)act).getBasicType();\n         }\n         if (act instanceof ObjectType) {\n             final Verifier v = VerifierFactory.getVerifier(((ObjectType)act).getClassName());\n             final VerificationResult vr = v.doPass1();\n             if (vr != VerificationResult.VR_OK) {\n-                throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$000((Node)obj) + \"' has a return type that does not pass verification pass 1: '\" + vr + \"'.\");\n+                throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$0((Node)obj) + \"' has a return type that does not pass verification pass 1: '\" + vr + \"'.\");\n             }\n         }\n-        final Type[] array = ts;\n-        for (int length = array.length, i = 0; i < length; ++i) {\n+        Type[] array;\n+        for (int length = (array = ts).length, i = 0; i < length; ++i) {\n             final Type element = act = array[i];\n             if (act instanceof ArrayType) {\n                 act = ((ArrayType)act).getBasicType();\n             }\n             if (act instanceof ObjectType) {\n                 final Verifier v2 = VerifierFactory.getVerifier(((ObjectType)act).getClassName());\n                 final VerificationResult vr2 = v2.doPass1();\n                 if (vr2 != VerificationResult.VR_OK) {\n-                    throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$000((Node)obj) + \"' has an argument type that does not pass verification pass 1: '\" + vr2 + \"'.\");\n+                    throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$0((Node)obj) + \"' has an argument type that does not pass verification pass 1: '\" + vr2 + \"'.\");\n                 }\n             }\n         }\n         if (name.equals(\"<clinit>\") && ts.length != 0) {\n-            throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$000((Node)obj) + \"' has illegal name '\" + name + \"'. Its name resembles the class or interface initialization method which it isn't because of its arguments (==descriptor).\");\n+            throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$0((Node)obj) + \"' has illegal name '\" + name + \"'.\" + \" Its name resembles the class or interface initialization method\" + \" which it isn't because of its arguments (==descriptor).\");\n         }\n         if (this.jc.isClass()) {\n             int maxone = 0;\n             if (obj.isPrivate()) {\n                 ++maxone;\n             }\n             if (obj.isProtected()) {\n                 ++maxone;\n             }\n             if (obj.isPublic()) {\n                 ++maxone;\n             }\n             if (maxone > 1) {\n-                throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$000((Node)obj) + \"' must only have at most one of its ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC modifiers set.\");\n+                throw new ClassConstraintException(\"Method '\" + Pass2Verifier.access$0((Node)obj) + \"' must only have at most one of its ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC modifiers set.\");\n             }\n             if (obj.isAbstract()) {\n                 if (obj.isFinal()) {\n-                    throw new ClassConstraintException(\"Abstract method '\" + Pass2Verifier.access$000((Node)obj) + \"' must not have the ACC_FINAL modifier set.\");\n+                    throw new ClassConstraintException(\"Abstract method '\" + Pass2Verifier.access$0((Node)obj) + \"' must not have the ACC_FINAL modifier set.\");\n                 }\n                 if (obj.isNative()) {\n-                    throw new ClassConstraintException(\"Abstract method '\" + Pass2Verifier.access$000((Node)obj) + \"' must not have the ACC_NATIVE modifier set.\");\n+                    throw new ClassConstraintException(\"Abstract method '\" + Pass2Verifier.access$0((Node)obj) + \"' must not have the ACC_NATIVE modifier set.\");\n                 }\n                 if (obj.isPrivate()) {\n-                    throw new ClassConstraintException(\"Abstract method '\" + Pass2Verifier.access$000((Node)obj) + \"' must not have the ACC_PRIVATE modifier set.\");\n+                    throw new ClassConstraintException(\"Abstract method '\" + Pass2Verifier.access$0((Node)obj) + \"' must not have the ACC_PRIVATE modifier set.\");\n                 }\n                 if (obj.isStatic()) {\n-                    throw new ClassConstraintException(\"Abstract method '\" + Pass2Verifier.access$000((Node)obj) + \"' must not have the ACC_STATIC modifier set.\");\n+                    throw new ClassConstraintException(\"Abstract method '\" + Pass2Verifier.access$0((Node)obj) + \"' must not have the ACC_STATIC modifier set.\");\n                 }\n                 if (obj.isStrictfp()) {\n-                    throw new ClassConstraintException(\"Abstract method '\" + Pass2Verifier.access$000((Node)obj) + \"' must not have the ACC_STRICT modifier set.\");\n+                    throw new ClassConstraintException(\"Abstract method '\" + Pass2Verifier.access$0((Node)obj) + \"' must not have the ACC_STRICT modifier set.\");\n                 }\n                 if (obj.isSynchronized()) {\n-                    throw new ClassConstraintException(\"Abstract method '\" + Pass2Verifier.access$000((Node)obj) + \"' must not have the ACC_SYNCHRONIZED modifier set.\");\n+                    throw new ClassConstraintException(\"Abstract method '\" + Pass2Verifier.access$0((Node)obj) + \"' must not have the ACC_SYNCHRONIZED modifier set.\");\n                 }\n             }\n             if (name.equals(\"<init>\") && (obj.isStatic() || obj.isFinal() || obj.isSynchronized() || obj.isNative() || obj.isAbstract())) {\n-                throw new ClassConstraintException(\"Instance initialization method '\" + Pass2Verifier.access$000((Node)obj) + \"' must not have any of the ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT modifiers set.\");\n+                throw new ClassConstraintException(\"Instance initialization method '\" + Pass2Verifier.access$0((Node)obj) + \"' must not have\" + \" any of the ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT modifiers set.\");\n             }\n         }\n         else if (!name.equals(\"<clinit>\")) {\n             if (this.jc.getMajor() >= 52) {\n                 if (obj.isPublic() == obj.isPrivate()) {\n-                    throw new ClassConstraintException(\"Interface method '\" + Pass2Verifier.access$000((Node)obj) + \"' must have exactly one of its ACC_PUBLIC and ACC_PRIVATE modifiers set.\");\n+                    throw new ClassConstraintException(\"Interface method '\" + Pass2Verifier.access$0((Node)obj) + \"' must have\" + \" exactly one of its ACC_PUBLIC and ACC_PRIVATE modifiers set.\");\n                 }\n                 if (obj.isProtected() || obj.isFinal() || obj.isSynchronized() || obj.isNative()) {\n-                    throw new ClassConstraintException(\"Interface method '\" + Pass2Verifier.access$000((Node)obj) + \"' must not have any of the ACC_PROTECTED, ACC_FINAL, ACC_SYNCHRONIZED, or ACC_NATIVE modifiers set.\");\n+                    throw new ClassConstraintException(\"Interface method '\" + Pass2Verifier.access$0((Node)obj) + \"' must not have\" + \" any of the ACC_PROTECTED, ACC_FINAL, ACC_SYNCHRONIZED, or ACC_NATIVE modifiers set.\");\n                 }\n             }\n             else {\n                 if (!obj.isPublic()) {\n-                    throw new ClassConstraintException(\"Interface method '\" + Pass2Verifier.access$000((Node)obj) + \"' must have the ACC_PUBLIC modifier set but hasn't!\");\n+                    throw new ClassConstraintException(\"Interface method '\" + Pass2Verifier.access$0((Node)obj) + \"' must have the ACC_PUBLIC modifier set but hasn't!\");\n                 }\n                 if (!obj.isAbstract()) {\n-                    throw new ClassConstraintException(\"Interface method '\" + Pass2Verifier.access$000((Node)obj) + \"' must have the ACC_ABSTRACT modifier set but hasn't!\");\n+                    throw new ClassConstraintException(\"Interface method '\" + Pass2Verifier.access$0((Node)obj) + \"' must have the ACC_ABSTRACT modifier set but hasn't!\");\n                 }\n                 if (obj.isPrivate() || obj.isProtected() || obj.isStatic() || obj.isFinal() || obj.isSynchronized() || obj.isNative() || obj.isStrictfp()) {\n-                    throw new ClassConstraintException(\"Interface method '\" + Pass2Verifier.access$000((Node)obj) + \"' must not have any of the ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT, ACC_STRICT modifiers set.\");\n+                    throw new ClassConstraintException(\"Interface method '\" + Pass2Verifier.access$0((Node)obj) + \"' must not have\" + \" any of the ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED,\" + \" ACC_NATIVE, ACC_ABSTRACT, ACC_STRICT modifiers set.\");\n                 }\n             }\n         }\n         if ((obj.getAccessFlags() & 0xFFFFF2C0) > 0) {\n-            this.this$0.addMessage(\"Method '\" + Pass2Verifier.access$000((Node)obj) + \"' has access flag(s) other than ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT, ACC_STRICT set (ignored).\");\n+            this.this$0.addMessage(\"Method '\" + Pass2Verifier.access$0((Node)obj) + \"' has access flag(s) other than\" + \" ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL,\" + \" ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT, ACC_STRICT set (ignored).\");\n         }\n-        final String nameanddesc = name + sig;\n+        final String nameanddesc = String.valueOf(name) + sig;\n         if (this.methodNamesAndDesc.contains(nameanddesc)) {\n-            throw new ClassConstraintException(\"No two methods (like '\" + Pass2Verifier.access$000((Node)obj) + \"') are allowed have same names and desciptors!\");\n+            throw new ClassConstraintException(\"No two methods (like '\" + Pass2Verifier.access$0((Node)obj) + \"') are allowed have same names and desciptors!\");\n         }\n         this.methodNamesAndDesc.add(nameanddesc);\n         final Attribute[] atts = obj.getAttributes();\n         int numCodeAtts = 0;\n-        for (final Attribute att : atts) {\n+        Attribute[] array2;\n+        for (int length2 = (array2 = atts).length, j = 0; j < length2; ++j) {\n+            final Attribute att = array2[j];\n             if (!(att instanceof Code) && !(att instanceof ExceptionTable) && !(att instanceof Synthetic) && !(att instanceof Deprecated)) {\n-                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$000((Node)att) + \"' as an attribute of Method '\" + Pass2Verifier.access$000((Node)obj) + \"' is unknown and will therefore be ignored.\");\n+                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$0((Node)att) + \"' as an attribute of Method '\" + Pass2Verifier.access$0((Node)obj) + \"' is unknown and will therefore be ignored.\");\n             }\n             if (!(att instanceof Code) && !(att instanceof ExceptionTable)) {\n-                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$000((Node)att) + \"' as an attribute of Method '\" + Pass2Verifier.access$000((Node)obj) + \"' is neither Code nor Exceptions and is therefore only of use for debuggers and such.\");\n+                this.this$0.addMessage(\"Attribute '\" + Pass2Verifier.access$0((Node)att) + \"' as an attribute of Method '\" + Pass2Verifier.access$0((Node)obj) + \"' is neither Code nor Exceptions and is therefore only of use for debuggers and such.\");\n             }\n             if (att instanceof Code && (obj.isNative() || obj.isAbstract())) {\n-                throw new ClassConstraintException(\"Native or abstract methods like '\" + Pass2Verifier.access$000((Node)obj) + \"' must not have a Code attribute like '\" + Pass2Verifier.access$000((Node)att) + \"'.\");\n+                throw new ClassConstraintException(\"Native or abstract methods like '\" + Pass2Verifier.access$0((Node)obj) + \"' must not have a Code attribute like '\" + Pass2Verifier.access$0((Node)att) + \"'.\");\n             }\n             if (att instanceof Code) {\n                 ++numCodeAtts;\n             }\n         }\n         if (!obj.isNative() && !obj.isAbstract() && numCodeAtts != 1) {\n-            throw new ClassConstraintException(\"Non-native, non-abstract methods like '\" + Pass2Verifier.access$000((Node)obj) + \"' must have exactly one Code attribute (found: \" + numCodeAtts + \").\");\n+            throw new ClassConstraintException(\"Non-native, non-abstract methods like '\" + Pass2Verifier.access$0((Node)obj) + \"' must have exactly one Code attribute (found: \" + numCodeAtts + \").\");\n         }\n     }\n     \n     public void visitSourceFile(final SourceFile obj) {\n         this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n         final String name = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n         if (!name.equals(\"SourceFile\")) {\n-            throw new ClassConstraintException(\"The SourceFile attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' is not correctly named 'SourceFile' but '\" + name + \"'.\");\n+            throw new ClassConstraintException(\"The SourceFile attribute '\" + Pass2Verifier.access$0((Node)obj) + \"' is not correctly named 'SourceFile' but '\" + name + \"'.\");\n         }\n         this.checkIndex((Node)obj, obj.getSourceFileIndex(), this.CONST_Utf8);\n         final String sourceFileName = ((ConstantUtf8)this.cp.getConstant(obj.getSourceFileIndex())).getBytes();\n         final String sourceFileNameLc = sourceFileName.toLowerCase(Locale.ENGLISH);\n         if (sourceFileName.indexOf(47) != -1 || sourceFileName.indexOf(92) != -1 || sourceFileName.indexOf(58) != -1 || sourceFileNameLc.lastIndexOf(\".java\") == -1) {\n-            this.this$0.addMessage(\"SourceFile attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' has a funny name: remember not to confuse certain parsers working on javap's output. Also, this name ('\" + sourceFileName + \"') is considered an unqualified (simple) file name only.\");\n+            this.this$0.addMessage(\"SourceFile attribute '\" + Pass2Verifier.access$0((Node)obj) + \"' has a funny name: remember not to confuse certain parsers working on javap's output. Also, this name ('\" + sourceFileName + \"') is considered an unqualified (simple) file name only.\");\n         }\n     }\n     \n     public void visitSynthetic(final Synthetic obj) {\n         this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n         final String name = ((ConstantUtf8)this.cp.getConstant(obj.getNameIndex())).getBytes();\n         if (!name.equals(\"Synthetic\")) {\n-            throw new ClassConstraintException(\"The Synthetic attribute '\" + Pass2Verifier.access$000((Node)obj) + \"' is not correctly named 'Synthetic' but '\" + name + \"'.\");\n+            throw new ClassConstraintException(\"The Synthetic attribute '\" + Pass2Verifier.access$0((Node)obj) + \"' is not correctly named 'Synthetic' but '\" + name + \"'.\");\n         }\n     }\n     \n     public void visitUnknown(final Unknown obj) {\n         this.checkIndex((Node)obj, obj.getNameIndex(), this.CONST_Utf8);\n-        this.this$0.addMessage(\"Unknown attribute '\" + Pass2Verifier.access$000((Node)obj) + \"'. This attribute is not known in any context!\");\n+        this.this$0.addMessage(\"Unknown attribute '\" + Pass2Verifier.access$0((Node)obj) + \"'. This attribute is not known in any context!\");\n     }\n }\n"}]}
