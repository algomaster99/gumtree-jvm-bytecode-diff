{"diffoscope-json-version": 1, "source1": "first/OrderedPropertiesCheck.class", "source2": "second/OrderedPropertiesCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -21,57 +21,54 @@\n     private static final Pattern SPACE_PATTERN;\n     \n     public OrderedPropertiesCheck() {\n         this.setFileExtensions(new String[] { \"properties\" });\n     }\n     \n     protected void processFiltered(final File file, final FileText fileText) {\n-        final OrderedPropertiesCheck.SequencedProperties properties = new OrderedPropertiesCheck.SequencedProperties();\n+        final OrderedPropertiesCheck.SequencedProperties sequencedProperties = new OrderedPropertiesCheck.SequencedProperties();\n         try (final InputStream inputStream = Files.newInputStream(file.toPath(), new OpenOption[0])) {\n-            properties.load(inputStream);\n+            sequencedProperties.load(inputStream);\n         }\n         catch (final IOException | IllegalArgumentException ex) {\n-            this.log(1, \"unable.open.cause\", new Object[] { file.getPath(), ex.getLocalizedMessage() });\n+            this.log(1, \"unable.open.cause\", new Object[] { file.getPath(), ((Throwable)ex).getLocalizedMessage() });\n         }\n-        String previousProp = \"\";\n-        int startLineNo = 0;\n-        final Iterator<Object> propertyIterator = properties.keys().asIterator();\n-        while (propertyIterator.hasNext()) {\n-            final String propKey = (String)propertyIterator.next();\n-            if (String.CASE_INSENSITIVE_ORDER.compare(previousProp, propKey) > 0) {\n-                final int lineNo = getLineNumber(startLineNo, fileText, previousProp, propKey);\n-                this.log(lineNo + 1, \"properties.notSorted.property\", new Object[] { propKey, previousProp });\n-                startLineNo = lineNo;\n+        String s = \"\";\n+        int n = 0;\n+        final Iterator iterator = sequencedProperties.keys().asIterator();\n+        while (iterator.hasNext()) {\n+            final String s2 = (String)iterator.next();\n+            if (String.CASE_INSENSITIVE_ORDER.compare(s, s2) > 0) {\n+                final int lineNumber = getLineNumber(n, fileText, s, s2);\n+                this.log(lineNumber + 1, \"properties.notSorted.property\", new Object[] { s2, s });\n+                n = lineNumber;\n             }\n-            previousProp = propKey;\n+            s = s2;\n         }\n     }\n     \n-    private static int getLineNumber(final int startLineNo, final FileText fileText, final String previousProp, final String propKey) {\n-        final int indexOfPreviousProp = getIndex(startLineNo, fileText, previousProp);\n-        return getIndex(indexOfPreviousProp, fileText, propKey);\n+    private static int getLineNumber(final int n, final FileText fileText, final String s, final String s2) {\n+        return getIndex(getIndex(n, fileText, s), fileText, s2);\n     }\n     \n-    private static int getIndex(final int startLineNo, final FileText fileText, final String keyName) {\n-        final Pattern keyPattern = getKeyPattern(keyName);\n-        int indexNumber = 0;\n+    private static int getIndex(final int n, final FileText fileText, final String s) {\n+        final Pattern keyPattern = getKeyPattern(s);\n+        int n2 = 0;\n         final Matcher matcher = keyPattern.matcher(\"\");\n-        for (int index = startLineNo; index < fileText.size(); ++index) {\n-            final String line = fileText.get(index);\n-            matcher.reset(line);\n+        for (int i = n; i < fileText.size(); ++i) {\n+            matcher.reset(fileText.get(i));\n             if (matcher.matches()) {\n-                indexNumber = index;\n+                n2 = i;\n                 break;\n             }\n         }\n-        return indexNumber;\n+        return n2;\n     }\n     \n-    private static Pattern getKeyPattern(final String keyName) {\n-        final String keyPatternString = \"^\" + OrderedPropertiesCheck.SPACE_PATTERN.matcher(keyName).replaceAll(Matcher.quoteReplacement(\"\\\\\\\\ \")) + \"[\\\\s:=].*\";\n-        return Pattern.compile(keyPatternString);\n+    private static Pattern getKeyPattern(final String input) {\n+        return Pattern.compile(\"^\" + OrderedPropertiesCheck.SPACE_PATTERN.matcher(input).replaceAll(Matcher.quoteReplacement(\"\\\\\\\\ \")) + \"[\\\\s:=].*\");\n     }\n     \n     static {\n         SPACE_PATTERN = Pattern.compile(\" \");\n     }\n }\n"}]}
