{"diffoscope-json-version": 1, "source1": "first/EventListenerList.class", "source2": "second/EventListenerList.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,96 +1,94 @@\n \n package org.apache.commons.configuration2.event;\n \n-import java.util.Map;\n-import java.util.LinkedList;\n import java.util.Set;\n+import java.util.LinkedList;\n import java.util.HashMap;\n import java.util.Collections;\n import java.util.Iterator;\n import java.util.concurrent.CopyOnWriteArrayList;\n import java.util.List;\n \n public class EventListenerList\n {\n     private final List<EventListenerRegistrationData<?>> listeners;\n     \n     public EventListenerList() {\n         this.listeners = new CopyOnWriteArrayList<EventListenerRegistrationData<?>>();\n     }\n     \n-    public <T extends Event> void addEventListener(final EventType<T> type, final EventListener<? super T> listener) {\n-        this.listeners.add((EventListenerRegistrationData<?>)new EventListenerRegistrationData((EventType)type, (EventListener)listener));\n+    public <T extends Event> void addEventListener(final EventType<T> eventType, final EventListener<? super T> eventListener) {\n+        this.listeners.add((EventListenerRegistrationData<?>)new EventListenerRegistrationData((EventType)eventType, (EventListener)eventListener));\n     }\n     \n-    public <T extends Event> void addEventListener(final EventListenerRegistrationData<T> regData) {\n-        if (regData == null) {\n+    public <T extends Event> void addEventListener(final EventListenerRegistrationData<T> eventListenerRegistrationData) {\n+        if (eventListenerRegistrationData == null) {\n             throw new IllegalArgumentException(\"EventListenerRegistrationData must not be null!\");\n         }\n-        this.listeners.add(regData);\n+        this.listeners.add(eventListenerRegistrationData);\n     }\n     \n-    public <T extends Event> boolean removeEventListener(final EventType<T> eventType, final EventListener<? super T> listener) {\n-        return listener != null && eventType != null && this.removeEventListener((org.apache.commons.configuration2.event.EventListenerRegistrationData<Event>)new EventListenerRegistrationData((EventType)eventType, (EventListener)listener));\n+    public <T extends Event> boolean removeEventListener(final EventType<T> eventType, final EventListener<? super T> eventListener) {\n+        return eventListener != null && eventType != null && this.removeEventListener((org.apache.commons.configuration2.event.EventListenerRegistrationData<Event>)new EventListenerRegistrationData((EventType)eventType, (EventListener)eventListener));\n     }\n     \n-    public <T extends Event> boolean removeEventListener(final EventListenerRegistrationData<T> regData) {\n-        return this.listeners.remove(regData);\n+    public <T extends Event> boolean removeEventListener(final EventListenerRegistrationData<T> eventListenerRegistrationData) {\n+        return this.listeners.remove(eventListenerRegistrationData);\n     }\n     \n     public void fire(final Event event) {\n         if (event == null) {\n             throw new IllegalArgumentException(\"Event to be fired must not be null!\");\n         }\n-        final EventListenerList.EventListenerIterator<? extends Event> iterator = this.getEventListenerIterator((org.apache.commons.configuration2.event.EventType<? extends Event>)event.getEventType());\n-        while (iterator.hasNext()) {\n-            EventListenerList.EventListenerIterator.access$000((EventListenerList.EventListenerIterator)iterator, event);\n+        final EventListenerList.EventListenerIterator<Event> eventListenerIterator = this.getEventListenerIterator((org.apache.commons.configuration2.event.EventType<Event>)event.getEventType());\n+        while (eventListenerIterator.hasNext()) {\n+            EventListenerList.EventListenerIterator.access$000((EventListenerList.EventListenerIterator)eventListenerIterator, event);\n         }\n     }\n     \n     public <T extends Event> Iterable<EventListener<? super T>> getEventListeners(final EventType<T> eventType) {\n-        return () -> this.getEventListenerIterator((org.apache.commons.configuration2.event.EventType<Event>)eventType);\n+        return () -> this.getEventListenerIterator((org.apache.commons.configuration2.event.EventType<Event>)eventType2);\n     }\n     \n     public <T extends Event> EventListenerList.EventListenerIterator<T> getEventListenerIterator(final EventType<T> eventType) {\n         return (EventListenerList.EventListenerIterator<T>)new EventListenerList.EventListenerIterator((Iterator)this.listeners.iterator(), (EventType)eventType, (EventListenerList.EventListenerList$1)null);\n     }\n     \n     public List<EventListenerRegistrationData<?>> getRegistrations() {\n         return Collections.unmodifiableList((List<? extends EventListenerRegistrationData<?>>)this.listeners);\n     }\n     \n     public <T extends Event> List<EventListenerRegistrationData<? extends T>> getRegistrationsForSuperType(final EventType<T> eventType) {\n-        final Map<EventType<?>, Set<EventType<?>>> superTypes = new HashMap<EventType<?>, Set<EventType<?>>>();\n-        final List<EventListenerRegistrationData<? extends T>> results = new LinkedList<EventListenerRegistrationData<? extends T>>();\n-        for (final EventListenerRegistrationData<?> reg : this.listeners) {\n-            Set<EventType<?>> base = (Set<EventType<?>>)superTypes.get(reg.getEventType());\n-            if (base == null) {\n-                base = EventType.fetchSuperEventTypes(reg.getEventType());\n-                superTypes.put((EventType<?>)reg.getEventType(), base);\n+        final HashMap hashMap = new HashMap();\n+        final LinkedList list = new LinkedList();\n+        for (final EventListenerRegistrationData eventListenerRegistrationData : this.listeners) {\n+            Set fetchSuperEventTypes = (Set)hashMap.get(eventListenerRegistrationData.getEventType());\n+            if (fetchSuperEventTypes == null) {\n+                fetchSuperEventTypes = EventType.fetchSuperEventTypes(eventListenerRegistrationData.getEventType());\n+                hashMap.put(eventListenerRegistrationData.getEventType(), fetchSuperEventTypes);\n             }\n-            if (base.contains(eventType)) {\n-                final EventListenerRegistrationData<? extends T> result = (EventListenerRegistrationData<? extends T>)reg;\n-                results.add(result);\n+            if (fetchSuperEventTypes.contains(eventType)) {\n+                list.add(eventListenerRegistrationData);\n             }\n         }\n-        return results;\n+        return list;\n     }\n     \n     public void clear() {\n         this.listeners.clear();\n     }\n     \n-    public void addAll(final EventListenerList c) {\n-        if (c == null) {\n+    public void addAll(final EventListenerList list) {\n+        if (list == null) {\n             throw new IllegalArgumentException(\"List to be copied must not be null!\");\n         }\n-        for (final EventListenerRegistrationData<?> regData : c.getRegistrations()) {\n-            this.addEventListener(regData);\n+        final Iterator<EventListenerRegistrationData<?>> iterator = list.getRegistrations().iterator();\n+        while (iterator.hasNext()) {\n+            this.addEventListener((org.apache.commons.configuration2.event.EventListenerRegistrationData<Event>)(EventListenerRegistrationData)iterator.next());\n         }\n     }\n     \n-    private static void callListener(final EventListener<?> listener, final Event event) {\n-        final EventListener rowListener = listener;\n-        rowListener.onEvent(event);\n+    private static void callListener(final EventListener<?> eventListener, final Event event) {\n+        eventListener.onEvent(event);\n     }\n }\n"}]}
