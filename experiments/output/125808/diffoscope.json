{"diffoscope-json-version": 1, "source1": "first/SevenZFile.class", "source2": "second/SevenZFile.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -55,14 +55,18 @@\n     private byte[] password;\n     private final SevenZFileOptions options;\n     private long compressedBytesReadFromCurrentEntry;\n     private long uncompressedBytesReadFromCurrentEntry;\n     private final ArrayList<InputStream> deferredBlockStreams;\n     static final byte[] sevenZSignature;\n     \n+    static {\n+        sevenZSignature = new byte[] { 55, 122, -68, -81, 39, 28 };\n+    }\n+    \n     public SevenZFile(final File fileName, final char[] password) throws IOException {\n         this(fileName, password, SevenZFileOptions.DEFAULT);\n     }\n     \n     public SevenZFile(final File fileName, final char[] password, final SevenZFileOptions options) throws IOException {\n         this(Files.newByteChannel(fileName.toPath(), (Set<? extends OpenOption>)EnumSet.of(StandardOpenOption.READ), (FileAttribute<?>[])new FileAttribute[0]), fileName.getAbsolutePath(), utf16Decode(password), true, options);\n     }\n@@ -133,14 +137,17 @@\n             succeeded = true;\n         }\n         finally {\n             if (!succeeded && closeOnError) {\n                 this.channel.close();\n             }\n         }\n+        if (!succeeded && closeOnError) {\n+            this.channel.close();\n+        }\n     }\n     \n     public SevenZFile(final File fileName) throws IOException {\n         this(fileName, SevenZFileOptions.DEFAULT);\n     }\n     \n     public SevenZFile(final File fileName, final SevenZFileOptions options) throws IOException {\n@@ -156,14 +163,19 @@\n             finally {\n                 this.channel = null;\n                 if (this.password != null) {\n                     Arrays.fill(this.password, (byte)0);\n                 }\n                 this.password = null;\n             }\n+            this.channel = null;\n+            if (this.password != null) {\n+                Arrays.fill(this.password, (byte)0);\n+            }\n+            this.password = null;\n         }\n     }\n     \n     public SevenZArchiveEntry getNextEntry() throws IOException {\n         if (this.currentEntryIndex >= this.archive.files.length - 1) {\n             return null;\n         }\n@@ -292,26 +304,47 @@\n         this.readHeader(buf, archive);\n         archive.subStreamsInfo = null;\n         return archive;\n     }\n     \n     private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\n         final StartHeader startHeader = new StartHeader();\n-        try (final DataInputStream dataInputStream = new DataInputStream((InputStream)new CRC32VerifyingInputStream((InputStream)new BoundedSeekableByteChannelInputStream(this.channel, 20L), 20L, startHeaderCrc))) {\n-            startHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\n-            if (startHeader.nextHeaderOffset < 0L || startHeader.nextHeaderOffset + 32L > this.channel.size()) {\n-                throw new IOException(\"nextHeaderOffset is out of bounds\");\n-            }\n-            startHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\n-            final long nextHeaderEnd = startHeader.nextHeaderOffset + startHeader.nextHeaderSize;\n-            if (nextHeaderEnd < startHeader.nextHeaderOffset || nextHeaderEnd + 32L > this.channel.size()) {\n-                throw new IOException(\"nextHeaderSize is out of bounds\");\n+        Throwable t = null;\n+        try {\n+            final DataInputStream dataInputStream = new DataInputStream((InputStream)new CRC32VerifyingInputStream((InputStream)new BoundedSeekableByteChannelInputStream(this.channel, 20L), 20L, startHeaderCrc));\n+            try {\n+                startHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\n+                if (startHeader.nextHeaderOffset < 0L || startHeader.nextHeaderOffset + 32L > this.channel.size()) {\n+                    throw new IOException(\"nextHeaderOffset is out of bounds\");\n+                }\n+                startHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\n+                final long nextHeaderEnd = startHeader.nextHeaderOffset + startHeader.nextHeaderSize;\n+                if (nextHeaderEnd < startHeader.nextHeaderOffset || nextHeaderEnd + 32L > this.channel.size()) {\n+                    throw new IOException(\"nextHeaderSize is out of bounds\");\n+                }\n+                startHeader.nextHeaderCrc = (0xFFFFFFFFL & (long)Integer.reverseBytes(dataInputStream.readInt()));\n+                return startHeader;\n+            }\n+            finally {\n+                if (dataInputStream != null) {\n+                    dataInputStream.close();\n+                }\n+            }\n+        }\n+        finally {\n+            if (t == null) {\n+                final Throwable exception;\n+                t = exception;\n+            }\n+            else {\n+                final Throwable exception;\n+                if (t != exception) {\n+                    t.addSuppressed(exception);\n+                }\n             }\n-            startHeader.nextHeaderCrc = (0xFFFFFFFFL & (long)Integer.reverseBytes(dataInputStream.readInt()));\n-            return startHeader;\n         }\n     }\n     \n     private void readHeader(final ByteBuffer header, final Archive archive) throws IOException {\n         final int pos = header.position();\n         final SevenZFile.ArchiveStatistics stats = this.sanityCheckAndCollectStatistics(header);\n         stats.assertValidity(this.options.getMaxMemoryLimitInKb());\n@@ -331,15 +364,15 @@\n         if (nid == 5) {\n             this.readFilesInfo(header, archive);\n             nid = getUnsignedByte(header);\n         }\n     }\n     \n     private SevenZFile.ArchiveStatistics sanityCheckAndCollectStatistics(final ByteBuffer header) throws IOException {\n-        final SevenZFile.ArchiveStatistics stats = new SevenZFile.ArchiveStatistics((SevenZFile.SevenZFile$1)null);\n+        final SevenZFile.ArchiveStatistics stats = new SevenZFile.ArchiveStatistics((SevenZFile.ArchiveStatistics)null);\n         int nid = getUnsignedByte(header);\n         if (nid == 2) {\n             this.sanityCheckArchiveProperties(header);\n             nid = getUnsignedByte(header);\n         }\n         if (nid == 3) {\n             throw new IOException(\"Additional streams unsupported\");\n@@ -373,15 +406,15 @@\n                 throw new IOException(\"invalid property size\");\n             }\n         }\n     }\n     \n     private ByteBuffer readEncodedHeader(final ByteBuffer header, final Archive archive, final byte[] password) throws IOException {\n         final int pos = header.position();\n-        final SevenZFile.ArchiveStatistics stats = new SevenZFile.ArchiveStatistics((SevenZFile.SevenZFile$1)null);\n+        final SevenZFile.ArchiveStatistics stats = new SevenZFile.ArchiveStatistics((SevenZFile.ArchiveStatistics)null);\n         this.sanityCheckStreamsInfo(header, stats);\n         stats.assertValidity(this.options.getMaxMemoryLimitInKb());\n         header.position();\n         this.readStreamsInfo(header, archive);\n         if (archive.folders == null || archive.folders.length == 0) {\n             throw new IOException(\"no folders, can't read encoded header\");\n         }\n@@ -451,30 +484,30 @@\n     \n     private void sanityCheckPackInfo(final ByteBuffer header, final SevenZFile.ArchiveStatistics stats) throws IOException {\n         final long packPos = readUint64(header);\n         if (packPos < 0L || 32L + packPos > this.channel.size() || 32L + packPos < 0L) {\n             throw new IOException(\"packPos (\" + packPos + \") is out of range\");\n         }\n         final long numPackStreams = readUint64(header);\n-        SevenZFile.ArchiveStatistics.access$102(stats, assertFitsIntoNonNegativeInt(\"numPackStreams\", numPackStreams));\n+        SevenZFile.ArchiveStatistics.access$1(stats, assertFitsIntoNonNegativeInt(\"numPackStreams\", numPackStreams));\n         int nid = getUnsignedByte(header);\n         if (nid == 9) {\n             long totalPackSizes = 0L;\n-            for (int i = 0; i < SevenZFile.ArchiveStatistics.access$100(stats); ++i) {\n+            for (int i = 0; i < SevenZFile.ArchiveStatistics.access$2(stats); ++i) {\n                 final long packSize = readUint64(header);\n                 totalPackSizes += packSize;\n                 final long endOfPackStreams = 32L + packPos + totalPackSizes;\n                 if (packSize < 0L || endOfPackStreams > this.channel.size() || endOfPackStreams < packPos) {\n                     throw new IOException(\"packSize (\" + packSize + \") is out of range\");\n                 }\n             }\n             nid = getUnsignedByte(header);\n         }\n         if (nid == 10) {\n-            final int crcsDefined = this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$100(stats)).cardinality();\n+            final int crcsDefined = this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$2(stats)).cardinality();\n             if (skipBytesFully(header, 4 * crcsDefined) < 4 * crcsDefined) {\n                 throw new IOException(\"invalid number of CRCs in PackInfo\");\n             }\n             nid = getUnsignedByte(header);\n         }\n         if (nid != 0) {\n             throw new IOException(\"Badly terminated PackInfo (\" + nid + \")\");\n@@ -506,26 +539,26 @@\n     \n     private void sanityCheckUnpackInfo(final ByteBuffer header, final SevenZFile.ArchiveStatistics stats) throws IOException {\n         int nid = getUnsignedByte(header);\n         if (nid != 11) {\n             throw new IOException(\"Expected kFolder, got \" + nid);\n         }\n         final long numFolders = readUint64(header);\n-        SevenZFile.ArchiveStatistics.access$202(stats, assertFitsIntoNonNegativeInt(\"numFolders\", numFolders));\n+        SevenZFile.ArchiveStatistics.access$3(stats, assertFitsIntoNonNegativeInt(\"numFolders\", numFolders));\n         final int external = getUnsignedByte(header);\n         if (external != 0) {\n             throw new IOException(\"External unsupported\");\n         }\n         final List<Integer> numberOfOutputStreamsPerFolder = new LinkedList<Integer>();\n-        for (int i = 0; i < SevenZFile.ArchiveStatistics.access$200(stats); ++i) {\n+        for (int i = 0; i < SevenZFile.ArchiveStatistics.access$4(stats); ++i) {\n             numberOfOutputStreamsPerFolder.add(Integer.valueOf(this.sanityCheckFolder(header, stats)));\n         }\n-        final long totalNumberOfBindPairs = SevenZFile.ArchiveStatistics.access$300(stats) - SevenZFile.ArchiveStatistics.access$200(stats);\n-        final long packedStreamsRequiredByFolders = SevenZFile.ArchiveStatistics.access$400(stats) - totalNumberOfBindPairs;\n-        if (packedStreamsRequiredByFolders < SevenZFile.ArchiveStatistics.access$100(stats)) {\n+        final long totalNumberOfBindPairs = SevenZFile.ArchiveStatistics.access$5(stats) - SevenZFile.ArchiveStatistics.access$4(stats);\n+        final long packedStreamsRequiredByFolders = SevenZFile.ArchiveStatistics.access$6(stats) - totalNumberOfBindPairs;\n+        if (packedStreamsRequiredByFolders < SevenZFile.ArchiveStatistics.access$2(stats)) {\n             throw new IOException(\"archive doesn't contain enough packed streams\");\n         }\n         nid = getUnsignedByte(header);\n         if (nid != 12) {\n             throw new IOException(\"Expected kCodersUnpackSize, got \" + nid);\n         }\n         final Iterator<Integer> iterator = numberOfOutputStreamsPerFolder.iterator();\n@@ -535,16 +568,16 @@\n                 if (unpackSize < 0L) {\n                     throw new IllegalArgumentException(\"negative unpackSize\");\n                 }\n             }\n         }\n         nid = getUnsignedByte(header);\n         if (nid == 10) {\n-            SevenZFile.ArchiveStatistics.access$502(stats, this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$200(stats)));\n-            final int crcsDefined = SevenZFile.ArchiveStatistics.access$500(stats).cardinality();\n+            SevenZFile.ArchiveStatistics.access$7(stats, this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$4(stats)));\n+            final int crcsDefined = SevenZFile.ArchiveStatistics.access$8(stats).cardinality();\n             if (skipBytesFully(header, 4 * crcsDefined) < 4 * crcsDefined) {\n                 throw new IOException(\"invalid number of CRCs in UnpackInfo\");\n             }\n             nid = getUnsignedByte(header);\n         }\n         if (nid != 0) {\n             throw new IOException(\"Badly terminated UnpackInfo\");\n@@ -557,15 +590,17 @@\n         final Folder[] folders = new Folder[numFoldersInt];\n         archive.folders = folders;\n         getUnsignedByte(header);\n         for (int i = 0; i < numFoldersInt; ++i) {\n             folders[i] = this.readFolder(header);\n         }\n         nid = getUnsignedByte(header);\n-        for (final Folder folder : folders) {\n+        Folder[] array;\n+        for (int length = (array = folders).length, l = 0; l < length; ++l) {\n+            final Folder folder = array[l];\n             assertFitsIntoNonNegativeInt(\"totalOutputStreams\", folder.totalOutputStreams);\n             folder.unpackSizes = new long[(int)folder.totalOutputStreams];\n             for (int j = 0; j < folder.totalOutputStreams; ++j) {\n                 folder.unpackSizes[j] = readUint64(header);\n             }\n         }\n         nid = getUnsignedByte(header);\n@@ -584,24 +619,24 @@\n         }\n     }\n     \n     private void sanityCheckSubStreamsInfo(final ByteBuffer header, final SevenZFile.ArchiveStatistics stats) throws IOException {\n         int nid = getUnsignedByte(header);\n         final List<Integer> numUnpackSubStreamsPerFolder = new LinkedList<Integer>();\n         if (nid == 13) {\n-            for (int i = 0; i < SevenZFile.ArchiveStatistics.access$200(stats); ++i) {\n+            for (int i = 0; i < SevenZFile.ArchiveStatistics.access$4(stats); ++i) {\n                 numUnpackSubStreamsPerFolder.add(Integer.valueOf(assertFitsIntoNonNegativeInt(\"numStreams\", readUint64(header))));\n             }\n-            SevenZFile.ArchiveStatistics.access$602(stats, numUnpackSubStreamsPerFolder.stream().mapToLong(Integer::longValue).sum());\n+            SevenZFile.ArchiveStatistics.access$9(stats, numUnpackSubStreamsPerFolder.stream().mapToLong(Integer::longValue).sum());\n             nid = getUnsignedByte(header);\n         }\n         else {\n-            SevenZFile.ArchiveStatistics.access$602(stats, (long)SevenZFile.ArchiveStatistics.access$200(stats));\n+            SevenZFile.ArchiveStatistics.access$9(stats, (long)SevenZFile.ArchiveStatistics.access$4(stats));\n         }\n-        assertFitsIntoNonNegativeInt(\"totalUnpackStreams\", SevenZFile.ArchiveStatistics.access$600(stats));\n+        assertFitsIntoNonNegativeInt(\"totalUnpackStreams\", SevenZFile.ArchiveStatistics.access$10(stats));\n         if (nid == 9) {\n             final Iterator<Integer> iterator = numUnpackSubStreamsPerFolder.iterator();\n             while (iterator.hasNext()) {\n                 final int numUnpackSubStreams = (int)Integer.valueOf(iterator.next());\n                 if (numUnpackSubStreams == 0) {\n                     continue;\n                 }\n@@ -612,22 +647,22 @@\n                     }\n                 }\n             }\n             nid = getUnsignedByte(header);\n         }\n         int numDigests = 0;\n         if (numUnpackSubStreamsPerFolder.isEmpty()) {\n-            numDigests = ((SevenZFile.ArchiveStatistics.access$500(stats) == null) ? SevenZFile.ArchiveStatistics.access$200(stats) : (SevenZFile.ArchiveStatistics.access$200(stats) - SevenZFile.ArchiveStatistics.access$500(stats).cardinality()));\n+            numDigests = ((SevenZFile.ArchiveStatistics.access$8(stats) == null) ? SevenZFile.ArchiveStatistics.access$4(stats) : (SevenZFile.ArchiveStatistics.access$4(stats) - SevenZFile.ArchiveStatistics.access$8(stats).cardinality()));\n         }\n         else {\n             int folderIdx = 0;\n             final Iterator<Integer> iterator2 = numUnpackSubStreamsPerFolder.iterator();\n             while (iterator2.hasNext()) {\n                 final int numUnpackSubStreams2 = (int)Integer.valueOf(iterator2.next());\n-                if (numUnpackSubStreams2 != 1 || SevenZFile.ArchiveStatistics.access$500(stats) == null || !SevenZFile.ArchiveStatistics.access$500(stats).get(folderIdx++)) {\n+                if (numUnpackSubStreams2 != 1 || SevenZFile.ArchiveStatistics.access$8(stats) == null || !SevenZFile.ArchiveStatistics.access$8(stats).get(folderIdx++)) {\n                     numDigests += numUnpackSubStreams2;\n                 }\n             }\n         }\n         if (nid == 10) {\n             assertFitsIntoNonNegativeInt(\"numDigests\", numDigests);\n             final int missingCrcs = this.readAllOrBits(header, numDigests).cardinality();\n@@ -638,35 +673,41 @@\n         }\n         if (nid != 0) {\n             throw new IOException(\"Badly terminated SubStreamsInfo\");\n         }\n     }\n     \n     private void readSubStreamsInfo(final ByteBuffer header, final Archive archive) throws IOException {\n-        for (final Folder folder : archive.folders) {\n+        Folder[] folders;\n+        for (int length = (folders = archive.folders).length, l = 0; l < length; ++l) {\n+            final Folder folder = folders[l];\n             folder.numUnpackSubStreams = 1;\n         }\n         long unpackStreamsCount = (long)archive.folders.length;\n         int nid = getUnsignedByte(header);\n         if (nid == 13) {\n             unpackStreamsCount = 0L;\n-            for (final Folder folder2 : archive.folders) {\n+            Folder[] folders2;\n+            for (int length2 = (folders2 = archive.folders).length, n = 0; n < length2; ++n) {\n+                final Folder folder2 = folders2[n];\n                 final long numStreams = readUint64(header);\n                 folder2.numUnpackSubStreams = (int)numStreams;\n                 unpackStreamsCount += numStreams;\n             }\n             nid = getUnsignedByte(header);\n         }\n         final int totalUnpackStreams = (int)unpackStreamsCount;\n         final SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\n         subStreamsInfo.unpackSizes = new long[totalUnpackStreams];\n         subStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\n         subStreamsInfo.crcs = new long[totalUnpackStreams];\n         int nextUnpackStream = 0;\n-        for (final Folder folder3 : archive.folders) {\n+        Folder[] folders3;\n+        for (int length3 = (folders3 = archive.folders).length, n2 = 0; n2 < length3; ++n2) {\n+            final Folder folder3 = folders3[n2];\n             if (folder3.numUnpackSubStreams != 0) {\n                 long sum = 0L;\n                 if (nid == 9) {\n                     for (int i = 0; i < folder3.numUnpackSubStreams - 1; ++i) {\n                         final long size = readUint64(header);\n                         subStreamsInfo.unpackSizes[nextUnpackStream++] = size;\n                         sum += size;\n@@ -678,30 +719,34 @@\n                 subStreamsInfo.unpackSizes[nextUnpackStream++] = folder3.getUnpackSize() - sum;\n             }\n         }\n         if (nid == 9) {\n             nid = getUnsignedByte(header);\n         }\n         int numDigests = 0;\n-        for (final Folder folder4 : archive.folders) {\n+        Folder[] folders4;\n+        for (int length4 = (folders4 = archive.folders).length, n3 = 0; n3 < length4; ++n3) {\n+            final Folder folder4 = folders4[n3];\n             if (folder4.numUnpackSubStreams != 1 || !folder4.hasCrc) {\n                 numDigests += folder4.numUnpackSubStreams;\n             }\n         }\n         if (nid == 10) {\n             final BitSet hasMissingCrc = this.readAllOrBits(header, numDigests);\n             final long[] missingCrcs = new long[numDigests];\n             for (int j = 0; j < numDigests; ++j) {\n                 if (hasMissingCrc.get(j)) {\n                     missingCrcs[j] = (0xFFFFFFFFL & (long)getInt(header));\n                 }\n             }\n             int nextCrc = 0;\n             int nextMissingCrc = 0;\n-            for (final Folder folder5 : archive.folders) {\n+            Folder[] folders5;\n+            for (int length5 = (folders5 = archive.folders).length, n4 = 0; n4 < length5; ++n4) {\n+                final Folder folder5 = folders5[n4];\n                 if (folder5.numUnpackSubStreams == 1 && folder5.hasCrc) {\n                     subStreamsInfo.hasCrc.set(nextCrc, true);\n                     subStreamsInfo.crcs[nextCrc] = folder5.crc;\n                     ++nextCrc;\n                 }\n                 else {\n                     for (int k = 0; k < folder5.numUnpackSubStreams; ++k) {\n@@ -718,15 +763,15 @@\n     }\n     \n     private int sanityCheckFolder(final ByteBuffer header, final SevenZFile.ArchiveStatistics stats) throws IOException {\n         final int numCoders = assertFitsIntoNonNegativeInt(\"numCoders\", readUint64(header));\n         if (numCoders == 0) {\n             throw new IOException(\"Folder without coders\");\n         }\n-        SevenZFile.ArchiveStatistics.access$714(stats, (long)numCoders);\n+        SevenZFile.ArchiveStatistics.access$12(stats, SevenZFile.ArchiveStatistics.access$11(stats) + (long)numCoders);\n         long totalOutStreams = 0L;\n         long totalInStreams = 0L;\n         for (int i = 0; i < numCoders; ++i) {\n             final int bits = getUnsignedByte(header);\n             final int idSize = bits & 0xF;\n             get(header, new byte[idSize]);\n             final boolean isSimple = (bits & 0x10) == 0x0;\n@@ -748,16 +793,16 @@\n                 if (skipBytesFully(header, propertiesSize) < propertiesSize) {\n                     throw new IOException(\"invalid propertiesSize in folder\");\n                 }\n             }\n         }\n         assertFitsIntoNonNegativeInt(\"totalInStreams\", totalInStreams);\n         assertFitsIntoNonNegativeInt(\"totalOutStreams\", totalOutStreams);\n-        SevenZFile.ArchiveStatistics.access$314(stats, totalOutStreams);\n-        SevenZFile.ArchiveStatistics.access$414(stats, totalInStreams);\n+        SevenZFile.ArchiveStatistics.access$13(stats, SevenZFile.ArchiveStatistics.access$5(stats) + totalOutStreams);\n+        SevenZFile.ArchiveStatistics.access$14(stats, SevenZFile.ArchiveStatistics.access$6(stats) + totalInStreams);\n         if (totalOutStreams == 0L) {\n             throw new IOException(\"Total output streams can't be 0\");\n         }\n         final int numBindPairs = assertFitsIntoNonNegativeInt(\"numBindPairs\", totalOutStreams - 1L);\n         if (totalInStreams < numBindPairs) {\n             throw new IOException(\"Total input streams can't be less than the number of bind pairs\");\n         }\n@@ -876,26 +921,26 @@\n             bits.set(i, (cache & mask) != 0x0);\n             mask >>>= 1;\n         }\n         return bits;\n     }\n     \n     private void sanityCheckFilesInfo(final ByteBuffer header, final SevenZFile.ArchiveStatistics stats) throws IOException {\n-        SevenZFile.ArchiveStatistics.access$802(stats, assertFitsIntoNonNegativeInt(\"numFiles\", readUint64(header)));\n+        SevenZFile.ArchiveStatistics.access$15(stats, assertFitsIntoNonNegativeInt(\"numFiles\", readUint64(header)));\n         int emptyStreams = -1;\n         while (true) {\n             final int propertyType = getUnsignedByte(header);\n             if (propertyType == 0) {\n-                SevenZFile.ArchiveStatistics.access$902(stats, SevenZFile.ArchiveStatistics.access$800(stats) - Math.max(emptyStreams, 0));\n+                SevenZFile.ArchiveStatistics.access$17(stats, SevenZFile.ArchiveStatistics.access$16(stats) - Math.max(emptyStreams, 0));\n                 return;\n             }\n             final long size = readUint64(header);\n             switch (propertyType) {\n                 case 14: {\n-                    emptyStreams = this.readBits(header, SevenZFile.ArchiveStatistics.access$800(stats)).cardinality();\n+                    emptyStreams = this.readBits(header, SevenZFile.ArchiveStatistics.access$16(stats)).cardinality();\n                     continue;\n                 }\n                 case 15: {\n                     if (emptyStreams == -1) {\n                         throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n                     }\n                     this.readBits(header, emptyStreams);\n@@ -920,54 +965,54 @@\n                     int filesSeen = 0;\n                     for (int i = 0; i < namesLength; i += 2) {\n                         final char c = getChar(header);\n                         if (c == '\\0') {\n                             ++filesSeen;\n                         }\n                     }\n-                    if (filesSeen != SevenZFile.ArchiveStatistics.access$800(stats)) {\n-                        throw new IOException(\"Invalid number of file names (\" + filesSeen + \" instead of \" + SevenZFile.ArchiveStatistics.access$800(stats) + \")\");\n+                    if (filesSeen != SevenZFile.ArchiveStatistics.access$16(stats)) {\n+                        throw new IOException(\"Invalid number of file names (\" + filesSeen + \" instead of \" + SevenZFile.ArchiveStatistics.access$16(stats) + \")\");\n                     }\n                     continue;\n                 }\n                 case 18: {\n-                    final int timesDefined = this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$800(stats)).cardinality();\n+                    final int timesDefined = this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$16(stats)).cardinality();\n                     final int external2 = getUnsignedByte(header);\n                     if (external2 != 0) {\n                         throw new IOException(\"Not implemented\");\n                     }\n                     if (skipBytesFully(header, 8 * timesDefined) < 8 * timesDefined) {\n                         throw new IOException(\"invalid creation dates size\");\n                     }\n                     continue;\n                 }\n                 case 19: {\n-                    final int timesDefined = this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$800(stats)).cardinality();\n+                    final int timesDefined = this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$16(stats)).cardinality();\n                     final int external2 = getUnsignedByte(header);\n                     if (external2 != 0) {\n                         throw new IOException(\"Not implemented\");\n                     }\n                     if (skipBytesFully(header, 8 * timesDefined) < 8 * timesDefined) {\n                         throw new IOException(\"invalid access dates size\");\n                     }\n                     continue;\n                 }\n                 case 20: {\n-                    final int timesDefined = this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$800(stats)).cardinality();\n+                    final int timesDefined = this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$16(stats)).cardinality();\n                     final int external2 = getUnsignedByte(header);\n                     if (external2 != 0) {\n                         throw new IOException(\"Not implemented\");\n                     }\n                     if (skipBytesFully(header, 8 * timesDefined) < 8 * timesDefined) {\n                         throw new IOException(\"invalid modification dates size\");\n                     }\n                     continue;\n                 }\n                 case 21: {\n-                    final int attributesDefined = this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$800(stats)).cardinality();\n+                    final int attributesDefined = this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$16(stats)).cardinality();\n                     final int external2 = getUnsignedByte(header);\n                     if (external2 != 0) {\n                         throw new IOException(\"Not implemented\");\n                     }\n                     if (skipBytesFully(header, 4 * attributesDefined) < 4 * attributesDefined) {\n                         throw new IOException(\"invalid windows attributes size\");\n                     }\n@@ -1309,16 +1354,37 @@\n         if (this.archive.files[this.currentEntryIndex].getSize() == 0L) {\n             return new ByteArrayInputStream(ByteUtils.EMPTY_BYTE_ARRAY);\n         }\n         if (this.deferredBlockStreams.isEmpty()) {\n             throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n         }\n         while (this.deferredBlockStreams.size() > 1) {\n-            try (final InputStream stream = (InputStream)this.deferredBlockStreams.remove(0)) {\n-                IOUtils.skip(stream, Long.MAX_VALUE);\n+            Throwable t = null;\n+            try {\n+                final InputStream stream = (InputStream)this.deferredBlockStreams.remove(0);\n+                try {\n+                    IOUtils.skip(stream, Long.MAX_VALUE);\n+                }\n+                finally {\n+                    if (stream != null) {\n+                        stream.close();\n+                    }\n+                }\n+            }\n+            finally {\n+                if (t == null) {\n+                    final Throwable exception;\n+                    t = exception;\n+                }\n+                else {\n+                    final Throwable exception;\n+                    if (t != exception) {\n+                        t.addSuppressed(exception);\n+                    }\n+                }\n             }\n             this.compressedBytesReadFromCurrentEntry = 0L;\n         }\n         return this.deferredBlockStreams.get(0);\n     }\n     \n     public InputStream getInputStream(final SevenZArchiveEntry entry) throws IOException {\n@@ -1448,15 +1514,15 @@\n             return null;\n         }\n         final String lastSegment = new File(this.fileName).getName();\n         final int dotPos = lastSegment.lastIndexOf(\".\");\n         if (dotPos > 0) {\n             return lastSegment.substring(0, dotPos);\n         }\n-        return lastSegment + \"~\";\n+        return String.valueOf(lastSegment) + \"~\";\n     }\n     \n     private static byte[] utf16Decode(final char[] chars) {\n         if (chars == null) {\n             return null;\n         }\n         final ByteBuffer encoded = StandardCharsets.UTF_16LE.encode(CharBuffer.wrap(chars));\n@@ -1470,12 +1536,8 @@\n     \n     private static int assertFitsIntoNonNegativeInt(final String what, final long value) throws IOException {\n         if (value > 2147483647L || value < 0L) {\n             throw new IOException(\"Cannot handle \" + what + \" \" + value);\n         }\n         return (int)value;\n     }\n-    \n-    static {\n-        sevenZSignature = new byte[] { 55, 122, -68, -81, 39, 28 };\n-    }\n }\n"}]}
