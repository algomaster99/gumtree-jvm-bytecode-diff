{"diffoscope-json-version": 1, "source1": "first/JavadocMetadataScraper.class", "source2": "second/JavadocMetadataScraper.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,28 +1,27 @@\n \n package com.puppycrawl.tools.checkstyle.meta;\n \n import java.util.HashMap;\n import java.util.Objects;\n import com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n import java.util.Collections;\n+import com.puppycrawl.tools.checkstyle.api.DetailAST;\n import java.util.stream.Collector;\n import java.util.stream.Collectors;\n import java.util.Arrays;\n import java.util.function.Function;\n-import java.util.Deque;\n import java.util.HashSet;\n import java.util.ArrayDeque;\n import java.util.LinkedHashSet;\n import java.util.Optional;\n import java.util.regex.Matcher;\n import java.util.Locale;\n import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.TransformerException;\n-import com.puppycrawl.tools.checkstyle.api.DetailAST;\n import com.puppycrawl.tools.checkstyle.api.DetailNode;\n import java.util.Set;\n import java.util.regex.Pattern;\n import java.util.Map;\n import com.puppycrawl.tools.checkstyle.FileStatefulCheck;\n import com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\n \n@@ -67,314 +66,305 @@\n         return new int[] { 10000, 10008, 10011, 16 };\n     }\n     \n     public int[] getRequiredJavadocTokens() {\n         return this.getAcceptableJavadocTokens();\n     }\n     \n-    public void beginJavadocTree(final DetailNode rootAst) {\n+    public void beginJavadocTree(final DetailNode detailNode) {\n         if (this.isTopLevelClassJavadoc()) {\n             this.moduleDetails = new ModuleDetails();\n             this.toScan = false;\n             this.scrapingViolationMessageList = false;\n             this.propertySectionStartIdx = -1;\n             this.exampleSectionStartIdx = -1;\n             this.parentSectionStartIdx = -1;\n-            String moduleName = this.getModuleSimpleName();\n-            final String checkModuleExtension = \"Check\";\n-            if (moduleName.endsWith(\"Check\")) {\n-                moduleName = moduleName.substring(0, moduleName.length() - \"Check\".length());\n+            String name = this.getModuleSimpleName();\n+            if (name.endsWith(\"Check\")) {\n+                name = name.substring(0, name.length() - \"Check\".length());\n             }\n-            this.moduleDetails.setName(moduleName);\n+            this.moduleDetails.setName(name);\n             this.moduleDetails.setFullQualifiedName(getPackageName(this.getFilePath()));\n             this.moduleDetails.setModuleType(this.getModuleType());\n         }\n     }\n     \n-    public void visitJavadocToken(final DetailNode ast) {\n+    public void visitJavadocToken(final DetailNode rootNode) {\n         if (this.toScan) {\n-            this.scrapeContent(ast);\n+            this.scrapeContent(rootNode);\n         }\n-        if (ast.getType() == 10000) {\n-            final DetailAST parent = getParent(this.getBlockCommentAst());\n-            if (parent.getType() == 14) {\n-                this.rootNode = ast;\n+        if (rootNode.getType() == 10000) {\n+            if (getParent(this.getBlockCommentAst()).getType() == 14) {\n+                this.rootNode = rootNode;\n                 this.toScan = true;\n             }\n         }\n-        else if (ast.getType() == 16) {\n+        else if (rootNode.getType() == 16) {\n             this.toScan = false;\n         }\n     }\n     \n-    public void finishJavadocTree(final DetailNode rootAst) {\n+    public void finishJavadocTree(final DetailNode detailNode) {\n         this.moduleDetails.setDescription(this.getDescriptionText());\n         if (this.isTopLevelClassJavadoc()) {\n             if (this.moduleDetails.getDescription().isEmpty()) {\n                 final String fullQualifiedName = this.moduleDetails.getFullQualifiedName();\n-                this.log(rootAst.getLineNumber(), \"javadocmetadatascraper.description.missing\", new Object[] { fullQualifiedName.substring(fullQualifiedName.lastIndexOf(46) + 1) });\n+                this.log(detailNode.getLineNumber(), \"javadocmetadatascraper.description.missing\", new Object[] { fullQualifiedName.substring(fullQualifiedName.lastIndexOf(46) + 1) });\n             }\n             else if (this.writeXmlOutput) {\n                 try {\n                     XmlMetaWriter.write(this.moduleDetails);\n                 }\n-                catch (final TransformerException | ParserConfigurationException ex) {\n-                    throw new IllegalStateException(\"Failed to write metadata into XML file for module: \" + this.getModuleSimpleName(), (Throwable)ex);\n+                catch (final TransformerException | ParserConfigurationException cause) {\n+                    throw new IllegalStateException(\"Failed to write metadata into XML file for module: \" + this.getModuleSimpleName(), (Throwable)cause);\n                 }\n             }\n             if (!this.writeXmlOutput) {\n                 JavadocMetadataScraper.MODULE_DETAILS_STORE.put(this.moduleDetails.getFullQualifiedName(), this.moduleDetails);\n             }\n         }\n     }\n     \n-    private void scrapeContent(final DetailNode ast) {\n-        if (ast.getType() == 10008) {\n-            if (isParentText(ast)) {\n-                this.parentSectionStartIdx = getParentIndexOf(ast);\n-                this.moduleDetails.setParent(getParentText(ast));\n+    private void scrapeContent(final DetailNode detailNode) {\n+        if (detailNode.getType() == 10008) {\n+            if (isParentText(detailNode)) {\n+                this.parentSectionStartIdx = getParentIndexOf(detailNode);\n+                this.moduleDetails.setParent(getParentText(detailNode));\n             }\n-            else if (isViolationMessagesText(ast)) {\n+            else if (isViolationMessagesText(detailNode)) {\n                 this.scrapingViolationMessageList = true;\n             }\n-            else if (this.exampleSectionStartIdx == -1 && isExamplesText(ast)) {\n-                this.exampleSectionStartIdx = getParentIndexOf(ast);\n+            else if (this.exampleSectionStartIdx == -1 && isExamplesText(detailNode)) {\n+                this.exampleSectionStartIdx = getParentIndexOf(detailNode);\n             }\n         }\n-        else if (ast.getType() == 10011) {\n-            if (isPropertyList(ast)) {\n+        else if (detailNode.getType() == 10011) {\n+            if (isPropertyList(detailNode)) {\n                 if (this.propertySectionStartIdx == -1) {\n-                    this.propertySectionStartIdx = getParentIndexOf(ast);\n+                    this.propertySectionStartIdx = getParentIndexOf(detailNode);\n                 }\n-                this.moduleDetails.addToProperties(createProperties(ast));\n+                this.moduleDetails.addToProperties(createProperties(detailNode));\n             }\n             else if (this.scrapingViolationMessageList) {\n-                this.moduleDetails.addToViolationMessages(getViolationMessages(ast));\n+                this.moduleDetails.addToViolationMessages(getViolationMessages(detailNode));\n             }\n         }\n     }\n     \n-    private static ModulePropertyDetails createProperties(final DetailNode nodeLi) {\n+    private static ModulePropertyDetails createProperties(final DetailNode detailNode) {\n         final ModulePropertyDetails modulePropertyDetails = new ModulePropertyDetails();\n-        final Optional<DetailNode> propertyNameNode = getFirstChildOfType(nodeLi, 10072, 0);\n-        if (propertyNameNode.isPresent()) {\n-            final DetailNode propertyNameTag = (DetailNode)propertyNameNode.get();\n-            final String propertyName = getTextFromTag(propertyNameTag);\n-            final DetailNode propertyType = (DetailNode)getFirstChildOfMatchingText(nodeLi, JavadocMetadataScraper.TYPE_TAG).orElseThrow(() -> {\n-                new MetadataGenerationException(String.format(Locale.ROOT, \"Type for property '%s' is missing\", propertyName));\n+        final Optional<DetailNode> firstChildOfType = getFirstChildOfType(detailNode, 10072, 0);\n+        if (firstChildOfType.isPresent()) {\n+            final DetailNode detailNode2 = (DetailNode)firstChildOfType.get();\n+            final String textFromTag = getTextFromTag(detailNode2);\n+            final DetailNode detailNode3 = (DetailNode)getFirstChildOfMatchingText(detailNode, JavadocMetadataScraper.TYPE_TAG).orElseThrow(() -> {\n+                new MetadataGenerationException(String.format(Locale.ROOT, \"Type for property '%s' is missing\", s));\n                 return;\n             });\n-            final String propertyDesc = JavadocMetadataScraper.DESC_CLEAN.matcher(constructSubTreeText(nodeLi, propertyNameTag.getIndex() + 1, propertyType.getIndex() - 1)).replaceAll(Matcher.quoteReplacement(\"\"));\n-            modulePropertyDetails.setDescription(propertyDesc.trim());\n-            modulePropertyDetails.setName(propertyName);\n-            modulePropertyDetails.setType(getTagTextFromProperty(nodeLi, propertyType));\n-            final Optional<DetailNode> validationTypeNodeOpt = getFirstChildOfMatchingText(nodeLi, JavadocMetadataScraper.VALIDATION_TYPE_TAG);\n-            if (validationTypeNodeOpt.isPresent()) {\n-                final DetailNode validationTypeNode = (DetailNode)validationTypeNodeOpt.get();\n-                modulePropertyDetails.setValidationType(getTagTextFromProperty(nodeLi, validationTypeNode));\n+            modulePropertyDetails.setDescription(JavadocMetadataScraper.DESC_CLEAN.matcher(constructSubTreeText(detailNode, detailNode2.getIndex() + 1, detailNode3.getIndex() - 1)).replaceAll(Matcher.quoteReplacement(\"\")).trim());\n+            modulePropertyDetails.setName(textFromTag);\n+            modulePropertyDetails.setType(getTagTextFromProperty(detailNode, detailNode3));\n+            final Optional<DetailNode> firstChildOfMatchingText = getFirstChildOfMatchingText(detailNode, JavadocMetadataScraper.VALIDATION_TYPE_TAG);\n+            if (firstChildOfMatchingText.isPresent()) {\n+                modulePropertyDetails.setValidationType(getTagTextFromProperty(detailNode, (DetailNode)firstChildOfMatchingText.get()));\n             }\n-            final String defaultValue = (String)getFirstChildOfMatchingText(nodeLi, JavadocMetadataScraper.DEFAULT_VALUE_TAG).map(defaultValueNode -> getPropertyDefaultText(nodeLi, defaultValueNode)).orElseThrow(() -> {\n-                new MetadataGenerationException(String.format(Locale.ROOT, \"Default value for property '%s' is missing\", propertyName));\n+            final String defaultValue = (String)getFirstChildOfMatchingText(detailNode, JavadocMetadataScraper.DEFAULT_VALUE_TAG).map(detailNode5 -> getPropertyDefaultText(detailNode4, detailNode5)).orElseThrow(() -> {\n+                new MetadataGenerationException(String.format(Locale.ROOT, \"Default value for property '%s' is missing\", s2));\n                 return;\n             });\n             if (!JavadocMetadataScraper.PROPERTIES_TO_NOT_WRITE.contains(defaultValue)) {\n                 modulePropertyDetails.setDefaultValue(defaultValue);\n             }\n         }\n         return modulePropertyDetails;\n     }\n     \n-    private static String getTagTextFromProperty(final DetailNode nodeLi, final DetailNode propertyMeta) {\n-        final Optional<DetailNode> tagNodeOpt = getFirstChildOfType(nodeLi, 10072, propertyMeta.getIndex() + 1);\n-        DetailNode tagNode = null;\n-        if (tagNodeOpt.isPresent()) {\n-            tagNode = tagNodeOpt.get();\n-        }\n-        return getTextFromTag(tagNode);\n+    private static String getTagTextFromProperty(final DetailNode detailNode, final DetailNode detailNode2) {\n+        final Optional<DetailNode> firstChildOfType = getFirstChildOfType(detailNode, 10072, detailNode2.getIndex() + 1);\n+        DetailNode detailNode3 = null;\n+        if (firstChildOfType.isPresent()) {\n+            detailNode3 = firstChildOfType.get();\n+        }\n+        return getTextFromTag(detailNode3);\n     }\n     \n-    private static String cleanDefaultTokensText(final String initialText) {\n-        final Set<String> tokens = new LinkedHashSet<String>();\n-        final Matcher matcher = JavadocMetadataScraper.TOKEN_TEXT_PATTERN.matcher(initialText);\n+    private static String cleanDefaultTokensText(final String input) {\n+        final LinkedHashSet elements = new LinkedHashSet();\n+        final Matcher matcher = JavadocMetadataScraper.TOKEN_TEXT_PATTERN.matcher(input);\n         while (matcher.find()) {\n-            tokens.add(matcher.group(0));\n+            elements.add(matcher.group(0));\n         }\n-        return String.join(\",\", tokens);\n+        return String.join(\",\", elements);\n     }\n     \n-    private static String constructSubTreeText(final DetailNode node, final int childLeftLimit, final int childRightLimit) {\n-        DetailNode detailNode = node;\n-        final Deque<DetailNode> stack = new ArrayDeque<DetailNode>();\n-        stack.addFirst(detailNode);\n-        final Set<DetailNode> visited = new HashSet<DetailNode>();\n-        final StringBuilder result = new StringBuilder(1024);\n-        while (!stack.isEmpty()) {\n-            detailNode = stack.removeFirst();\n-            if (visited.add(detailNode)) {\n-                final String childText = detailNode.getText();\n-                if (detailNode.getType() != 1 && !JavadocMetadataScraper.TOKEN_TEXT_PATTERN.matcher(childText).matches()) {\n-                    result.insert(0, childText);\n+    private static String constructSubTreeText(final DetailNode detailNode, final int n, final int n2) {\n+        final ArrayDeque arrayDeque = new ArrayDeque();\n+        arrayDeque.addFirst(detailNode);\n+        final HashSet set = new HashSet();\n+        final StringBuilder sb = new StringBuilder(1024);\n+        while (!arrayDeque.isEmpty()) {\n+            final DetailNode detailNode2 = (DetailNode)arrayDeque.removeFirst();\n+            if (set.add(detailNode2)) {\n+                final String text = detailNode2.getText();\n+                if (detailNode2.getType() != 1 && !JavadocMetadataScraper.TOKEN_TEXT_PATTERN.matcher(text).matches()) {\n+                    sb.insert(0, text);\n                 }\n             }\n-            for (final DetailNode child : detailNode.getChildren()) {\n+            for (final DetailNode detailNode3 : detailNode2.getChildren()) {\n                 Label_0205: {\n-                    if (child.getParent().equals((Object)node)) {\n-                        if (child.getIndex() < childLeftLimit) {\n+                    if (detailNode3.getParent().equals((Object)detailNode)) {\n+                        if (detailNode3.getIndex() < n) {\n                             break Label_0205;\n                         }\n-                        if (child.getIndex() > childRightLimit) {\n+                        if (detailNode3.getIndex() > n2) {\n                             break Label_0205;\n                         }\n                     }\n-                    if (!visited.contains(child)) {\n-                        stack.addFirst(child);\n+                    if (!set.contains(detailNode3)) {\n+                        arrayDeque.addFirst(detailNode3);\n                     }\n                 }\n             }\n         }\n-        return result.toString().trim();\n+        return sb.toString().trim();\n     }\n     \n     private String getDescriptionText() {\n-        int descriptionEndIdx;\n+        int n;\n         if (this.propertySectionStartIdx > -1) {\n-            descriptionEndIdx = this.propertySectionStartIdx;\n+            n = this.propertySectionStartIdx;\n         }\n         else if (this.exampleSectionStartIdx > -1) {\n-            descriptionEndIdx = this.exampleSectionStartIdx;\n+            n = this.exampleSectionStartIdx;\n         }\n         else {\n-            descriptionEndIdx = this.parentSectionStartIdx;\n+            n = this.parentSectionStartIdx;\n         }\n-        return constructSubTreeText(this.rootNode, 0, descriptionEndIdx - 1);\n+        return constructSubTreeText(this.rootNode, 0, n - 1);\n     }\n     \n-    private static String getPropertyDefaultText(final DetailNode nodeLi, final DetailNode defaultValueNode) {\n-        final Optional<DetailNode> propertyDefaultValueTag = getFirstChildOfType(nodeLi, 10072, defaultValueNode.getIndex() + 1);\n-        String result;\n-        if (propertyDefaultValueTag.isPresent()) {\n-            result = getTextFromTag(propertyDefaultValueTag.get());\n+    private static String getPropertyDefaultText(final DetailNode detailNode, final DetailNode detailNode2) {\n+        final Optional<DetailNode> firstChildOfType = getFirstChildOfType(detailNode, 10072, detailNode2.getIndex() + 1);\n+        String s;\n+        if (firstChildOfType.isPresent()) {\n+            s = getTextFromTag(firstChildOfType.get());\n         }\n         else {\n-            final String tokenText = constructSubTreeText(nodeLi, defaultValueNode.getIndex(), nodeLi.getChildren().length);\n-            result = cleanDefaultTokensText(tokenText);\n+            s = cleanDefaultTokensText(constructSubTreeText(detailNode, detailNode2.getIndex(), detailNode.getChildren().length));\n         }\n-        return result;\n+        return s;\n     }\n     \n-    private static String getViolationMessages(final DetailNode nodeLi) {\n-        final Optional<DetailNode> resultNode = getFirstChildOfType(nodeLi, 10072, 0);\n-        return resultNode.map((Function<? super DetailNode, ? extends String>)JavadocMetadataScraper::getTextFromTag).orElse(\"\");\n+    private static String getViolationMessages(final DetailNode detailNode) {\n+        return getFirstChildOfType(detailNode, 10072, 0).map((Function<? super DetailNode, ? extends String>)JavadocMetadataScraper::getTextFromTag).orElse(\"\");\n     }\n     \n-    private static String getTextFromTag(final DetailNode nodeTag) {\n-        return Optional.ofNullable(nodeTag).map((Function<? super DetailNode, ? extends String>)JavadocMetadataScraper::getText).orElse(\"\");\n+    private static String getTextFromTag(final DetailNode value) {\n+        return Optional.ofNullable(value).map((Function<? super DetailNode, ? extends String>)JavadocMetadataScraper::getText).orElse(\"\");\n     }\n     \n-    private static Optional<DetailNode> getFirstChildOfType(final DetailNode node, final int tokenType, final int offset) {\n-        return Arrays.stream(node.getChildren()).filter(child -> child.getIndex() >= offset && child.getType() == tokenType).findFirst();\n+    private static Optional<DetailNode> getFirstChildOfType(final DetailNode detailNode, final int n, final int n2) {\n+        return Arrays.stream(detailNode.getChildren()).filter(detailNode2 -> detailNode2.getIndex() >= n3 && detailNode2.getType() == n4).findFirst();\n     }\n     \n-    private static String getText(final DetailNode parentNode) {\n-        return Arrays.stream(parentNode.getChildren()).filter(child -> child.getType() == 10074).map(node -> JavadocMetadataScraper.QUOTE_PATTERN.matcher(node.getText().trim()).replaceAll(\"\")).collect((Collector<? super Object, ?, String>)Collectors.joining(\" \"));\n+    private static String getText(final DetailNode detailNode) {\n+        return Arrays.stream(detailNode.getChildren()).filter(detailNode2 -> detailNode2.getType() == 10074).map(detailNode3 -> JavadocMetadataScraper.QUOTE_PATTERN.matcher(detailNode3.getText().trim()).replaceAll(\"\")).collect((Collector<? super Object, ?, String>)Collectors.joining(\" \"));\n     }\n     \n-    private static Optional<DetailNode> getFirstChildOfMatchingText(final DetailNode node, final Pattern pattern) {\n-        return Arrays.stream(node.getChildren()).filter(child -> pattern.matcher(child.getText()).matches()).findFirst();\n+    private static Optional<DetailNode> getFirstChildOfMatchingText(final DetailNode detailNode, final Pattern pattern) {\n+        return Arrays.stream(detailNode.getChildren()).filter(detailNode2 -> pattern2.matcher(detailNode2.getText()).matches()).findFirst();\n     }\n     \n-    private static DetailAST getParent(final DetailAST commentBlock) {\n-        DetailAST result;\n-        final DetailAST parentNode = result = commentBlock.getParent();\n-        if (result.getType() == 159) {\n-            result = parentNode.getParent().getParent();\n+    private static DetailAST getParent(final DetailAST detailAST) {\n+        DetailAST detailAST3;\n+        final DetailAST detailAST2 = detailAST3 = detailAST.getParent();\n+        if (detailAST3.getType() == 159) {\n+            detailAST3 = detailAST2.getParent().getParent();\n         }\n-        else if (result.getType() == 5) {\n-            result = parentNode.getParent();\n+        else if (detailAST3.getType() == 5) {\n+            detailAST3 = detailAST2.getParent();\n         }\n-        return result;\n+        return detailAST3;\n     }\n     \n-    private static int getParentIndexOf(final DetailNode node) {\n-        DetailNode currNode;\n-        for (currNode = node; currNode.getParent().getIndex() != -1; currNode = currNode.getParent()) {}\n-        return currNode.getIndex();\n+    private static int getParentIndexOf(final DetailNode detailNode) {\n+        DetailNode parent;\n+        for (parent = detailNode; parent.getParent().getIndex() != -1; parent = parent.getParent()) {}\n+        return parent.getIndex();\n     }\n     \n-    private static String getParentText(final DetailNode nodeParagraph) {\n-        return getFirstChildOfType(nodeParagraph, 10072, 0).map((Function<? super DetailNode, ? extends String>)JavadocMetadataScraper::getTextFromTag).orElse(null);\n+    private static String getParentText(final DetailNode detailNode) {\n+        return getFirstChildOfType(detailNode, 10072, 0).map((Function<? super DetailNode, ? extends String>)JavadocMetadataScraper::getTextFromTag).orElse(null);\n     }\n     \n     private ModuleType getModuleType() {\n-        final String simpleModuleName = this.getModuleSimpleName();\n-        ModuleType result;\n-        if (simpleModuleName.endsWith(\"FileFilter\")) {\n-            result = ModuleType.FILEFILTER;\n+        final String moduleSimpleName = this.getModuleSimpleName();\n+        ModuleType moduleType;\n+        if (moduleSimpleName.endsWith(\"FileFilter\")) {\n+            moduleType = ModuleType.FILEFILTER;\n         }\n-        else if (simpleModuleName.endsWith(\"Filter\")) {\n-            result = ModuleType.FILTER;\n+        else if (moduleSimpleName.endsWith(\"Filter\")) {\n+            moduleType = ModuleType.FILTER;\n         }\n         else {\n-            result = ModuleType.CHECK;\n+            moduleType = ModuleType.CHECK;\n         }\n-        return result;\n+        return moduleType;\n     }\n     \n     private String getModuleSimpleName() {\n-        final String fullFileName = this.getFilePath();\n-        final String[] pathTokens = JavadocMetadataScraper.FILE_SEPARATOR_PATTERN.split(fullFileName);\n-        final String fileName = pathTokens[pathTokens.length - 1];\n-        return fileName.substring(0, fileName.length() - \".java\".length());\n+        final String[] split = JavadocMetadataScraper.FILE_SEPARATOR_PATTERN.split(this.getFilePath());\n+        final String s = split[split.length - 1];\n+        return s.substring(0, s.length() - \".java\".length());\n     }\n     \n-    private static String getPackageName(final String filePath) {\n-        final Deque<String> result = new ArrayDeque<String>();\n-        final String[] filePathTokens = JavadocMetadataScraper.FILE_SEPARATOR_PATTERN.split(filePath);\n-        for (int i = filePathTokens.length - 1; i >= 0 && !\"java\".equals(filePathTokens[i]) && !\"resources\".equals(filePathTokens[i]); --i) {\n-            result.addFirst(filePathTokens[i]);\n-        }\n-        final String fileName = (String)result.removeLast();\n-        result.addLast(fileName.substring(0, fileName.length() - \".java\".length()));\n-        return String.join(\".\", result);\n+    private static String getPackageName(final String input) {\n+        final ArrayDeque elements = new ArrayDeque();\n+        final String[] split = JavadocMetadataScraper.FILE_SEPARATOR_PATTERN.split(input);\n+        for (int n = split.length - 1; n >= 0 && !\"java\".equals(split[n]) && !\"resources\".equals(split[n]); --n) {\n+            elements.addFirst(split[n]);\n+        }\n+        final String s = (String)elements.removeLast();\n+        elements.addLast(s.substring(0, s.length() - \".java\".length()));\n+        return String.join(\".\", elements);\n     }\n     \n     public static Map<String, ModuleDetails> getModuleDetailsStore() {\n         return Collections.unmodifiableMap((Map<? extends String, ? extends ModuleDetails>)JavadocMetadataScraper.MODULE_DETAILS_STORE);\n     }\n     \n     public static void resetModuleDetailsStore() {\n         JavadocMetadataScraper.MODULE_DETAILS_STORE.clear();\n     }\n     \n     private boolean isTopLevelClassJavadoc() {\n-        final DetailAST parent = getParent(this.getBlockCommentAst());\n-        final Optional<DetailAST> className = TokenUtil.findFirstTokenByPredicate(parent, child -> parent.getType() == 14 && child.getType() == 58);\n-        return className.isPresent() && this.getModuleSimpleName().equals(((DetailAST)className.get()).getText());\n+        final Optional firstTokenByPredicate = TokenUtil.findFirstTokenByPredicate(getParent(this.getBlockCommentAst()), detailAST2 -> detailAST.getType() == 14 && detailAST2.getType() == 58);\n+        return firstTokenByPredicate.isPresent() && this.getModuleSimpleName().equals(((DetailAST)firstTokenByPredicate.get()).getText());\n     }\n     \n-    private static boolean isExamplesText(final DetailNode ast) {\n-        return isChildNodeTextMatches(ast, JavadocMetadataScraper.EXAMPLES_TAG);\n+    private static boolean isExamplesText(final DetailNode detailNode) {\n+        return isChildNodeTextMatches(detailNode, JavadocMetadataScraper.EXAMPLES_TAG);\n     }\n     \n-    private static boolean isPropertyList(final DetailNode nodeLi) {\n-        return isChildNodeTextMatches(nodeLi, JavadocMetadataScraper.PROPERTY_TAG);\n+    private static boolean isPropertyList(final DetailNode detailNode) {\n+        return isChildNodeTextMatches(detailNode, JavadocMetadataScraper.PROPERTY_TAG);\n     }\n     \n-    private static boolean isViolationMessagesText(final DetailNode nodeParagraph) {\n-        return isChildNodeTextMatches(nodeParagraph, JavadocMetadataScraper.VIOLATION_MESSAGES_TAG);\n+    private static boolean isViolationMessagesText(final DetailNode detailNode) {\n+        return isChildNodeTextMatches(detailNode, JavadocMetadataScraper.VIOLATION_MESSAGES_TAG);\n     }\n     \n-    private static boolean isParentText(final DetailNode nodeParagraph) {\n-        return isChildNodeTextMatches(nodeParagraph, JavadocMetadataScraper.PARENT_TAG);\n+    private static boolean isParentText(final DetailNode detailNode) {\n+        return isChildNodeTextMatches(detailNode, JavadocMetadataScraper.PARENT_TAG);\n     }\n     \n-    private static boolean isChildNodeTextMatches(final DetailNode ast, final Pattern pattern) {\n-        final Optional<Object> map = getFirstChildOfType(ast, 10074, 0).map((Function<? super DetailNode, ?>)DetailNode::getText);\n-        Objects.requireNonNull(pattern);\n-        return Boolean.valueOf(map.map((Function<? super Object, ?>)pattern::matcher).map((Function<? super Object, ?>)Matcher::matches).orElse(Boolean.FALSE));\n+    private static boolean isChildNodeTextMatches(final DetailNode detailNode, final Pattern obj) {\n+        final Optional<Object> map = getFirstChildOfType(detailNode, 10074, 0).map((Function<? super DetailNode, ?>)DetailNode::getText);\n+        Objects.requireNonNull(obj);\n+        return Boolean.valueOf(map.map((Function<? super Object, ?>)obj::matcher).map((Function<? super Object, ?>)Matcher::matches).orElse(Boolean.FALSE));\n     }\n     \n     static {\n         MODULE_DETAILS_STORE = new HashMap<String, ModuleDetails>();\n         PROPERTY_TAG = Pattern.compile(\"\\\\s*Property\\\\s*\");\n         TYPE_TAG = Pattern.compile(\"^ Type is\\\\s.*\");\n         VALIDATION_TYPE_TAG = Pattern.compile(\"\\\\s.*Validation type is\\\\s.*\");\n"}]}
