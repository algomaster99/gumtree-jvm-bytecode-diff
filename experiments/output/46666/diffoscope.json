{"diffoscope-json-version": 1, "source1": "first/EqualsBuilder.class", "source2": "second/EqualsBuilder.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -20,28 +20,32 @@\n     private boolean isEquals;\n     private boolean testTransients;\n     private boolean testRecursive;\n     private List<Class<?>> bypassReflectionClasses;\n     private Class<?> reflectUpToClass;\n     private String[] excludeFields;\n     \n+    static {\n+        REGISTRY = new ThreadLocal<Set<Pair<IDKey, IDKey>>>();\n+    }\n+    \n     static Set<Pair<IDKey, IDKey>> getRegistry() {\n         return EqualsBuilder.REGISTRY.get();\n     }\n     \n     static Pair<IDKey, IDKey> getRegisterPair(final Object lhs, final Object rhs) {\n         final IDKey left = new IDKey(lhs);\n         final IDKey right = new IDKey(rhs);\n         return (Pair<IDKey, IDKey>)Pair.of((Object)left, (Object)right);\n     }\n     \n     static boolean isRegistered(final Object lhs, final Object rhs) {\n         final Set<Pair<IDKey, IDKey>> registry = getRegistry();\n         final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\n-        final Pair<IDKey, IDKey> swappedPair = (Pair<IDKey, IDKey>)Pair.of(pair.getRight(), pair.getLeft());\n+        final Pair<IDKey, IDKey> swappedPair = (Pair<IDKey, IDKey>)Pair.of((Object)pair.getRight(), (Object)pair.getLeft());\n         return registry != null && (registry.contains(pair) || registry.contains(swappedPair));\n     }\n     \n     private static void register(final Object lhs, final Object rhs) {\n         Set<Pair<IDKey, IDKey>> registry = getRegistry();\n         if (registry == null) {\n             registry = new HashSet<Pair<IDKey, IDKey>>();\n@@ -151,50 +155,57 @@\n                 this.append(lhs, rhs);\n             }\n             else if (this.bypassReflectionClasses != null && (this.bypassReflectionClasses.contains(lhsClass) || this.bypassReflectionClasses.contains(rhsClass))) {\n                 this.isEquals = lhs.equals(rhs);\n             }\n             else {\n                 this.reflectionAppend(lhs, rhs, testClass);\n-                while (testClass.getSuperclass() != null && testClass != this.reflectUpToClass) {\n+                while (testClass.getSuperclass() != null) {\n+                    if (testClass == this.reflectUpToClass) {\n+                        break;\n+                    }\n                     testClass = testClass.getSuperclass();\n                     this.reflectionAppend(lhs, rhs, testClass);\n                 }\n             }\n         }\n-        catch (final IllegalArgumentException e) {\n+        catch (final IllegalArgumentException ex) {\n             this.isEquals = false;\n             return this;\n         }\n         return this;\n     }\n     \n     private void reflectionAppend(final Object lhs, final Object rhs, final Class<?> clazz) {\n         if (isRegistered(lhs, rhs)) {\n             return;\n         }\n         try {\n             register(lhs, rhs);\n             final Field[] fields = clazz.getDeclaredFields();\n             AccessibleObject.setAccessible(fields, true);\n-            for (int i = 0; i < fields.length && this.isEquals; ++i) {\n+            for (int i = 0; i < fields.length; ++i) {\n+                if (!this.isEquals) {\n+                    break;\n+                }\n                 final Field f = fields[i];\n                 if (!ArrayUtils.contains((Object[])this.excludeFields, (Object)f.getName()) && !f.getName().contains(\"$\") && (this.testTransients || !Modifier.isTransient(f.getModifiers())) && !Modifier.isStatic(f.getModifiers()) && !f.isAnnotationPresent((Class<? extends Annotation>)EqualsExclude.class)) {\n                     try {\n                         this.append(f.get(lhs), f.get(rhs));\n                     }\n-                    catch (final IllegalAccessException e) {\n+                    catch (final IllegalAccessException ex) {\n                         throw new InternalError(\"Unexpected IllegalAccessException\");\n                     }\n                 }\n             }\n         }\n         finally {\n             unregister(lhs, rhs);\n         }\n+        unregister(lhs, rhs);\n     }\n     \n     public EqualsBuilder appendSuper(final boolean superEquals) {\n         if (!this.isEquals) {\n             return this;\n         }\n         this.isEquals = superEquals;\n@@ -226,39 +237,39 @@\n     }\n     \n     private void appendArray(final Object lhs, final Object rhs) {\n         if (lhs.getClass() != rhs.getClass()) {\n             this.setEquals(false);\n         }\n         else if (lhs instanceof long[]) {\n-            this.append(lhs, (long[])(long[])rhs);\n+            this.append((long[])lhs, (long[])rhs);\n         }\n         else if (lhs instanceof int[]) {\n-            this.append(lhs, (int[])(int[])rhs);\n+            this.append((int[])lhs, (int[])rhs);\n         }\n         else if (lhs instanceof short[]) {\n-            this.append(lhs, (short[])(short[])rhs);\n+            this.append((short[])lhs, (short[])rhs);\n         }\n         else if (lhs instanceof char[]) {\n-            this.append(lhs, (char[])(char[])rhs);\n+            this.append((char[])lhs, (char[])rhs);\n         }\n         else if (lhs instanceof byte[]) {\n-            this.append(lhs, (byte[])(byte[])rhs);\n+            this.append((byte[])lhs, (byte[])rhs);\n         }\n         else if (lhs instanceof double[]) {\n-            this.append(lhs, (double[])(double[])rhs);\n+            this.append((double[])lhs, (double[])rhs);\n         }\n         else if (lhs instanceof float[]) {\n-            this.append(lhs, (float[])(float[])rhs);\n+            this.append((float[])lhs, (float[])rhs);\n         }\n         else if (lhs instanceof boolean[]) {\n-            this.append(lhs, (boolean[])(boolean[])rhs);\n+            this.append((boolean[])lhs, (boolean[])rhs);\n         }\n         else {\n-            this.append(lhs, (Object[])(Object[])rhs);\n+            this.append((Object[])lhs, (Object[])rhs);\n         }\n     }\n     \n     public EqualsBuilder append(final long lhs, final long rhs) {\n         if (!this.isEquals) {\n             return this;\n         }\n@@ -520,12 +531,8 @@\n     protected void setEquals(final boolean isEquals) {\n         this.isEquals = isEquals;\n     }\n     \n     public void reset() {\n         this.isEquals = true;\n     }\n-    \n-    static {\n-        REGISTRY = new ThreadLocal<Set<Pair<IDKey, IDKey>>>();\n-    }\n }\n"}]}
