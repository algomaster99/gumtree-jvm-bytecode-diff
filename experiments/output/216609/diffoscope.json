{"diffoscope-json-version": 1, "source1": "first/Type.class", "source2": "second/Type.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,15 +1,14 @@\n \n package org.apache.bcel.generic;\n \n import java.util.Arrays;\n import org.apache.bcel.classfile.Utility;\n import java.util.Objects;\n import java.lang.reflect.Method;\n-import java.util.List;\n import org.apache.bcel.classfile.ClassFormatException;\n import java.util.ArrayList;\n \n public abstract class Type\n {\n     public static final BasicType VOID;\n     public static final BasicType BOOLEAN;\n@@ -30,207 +29,202 @@\n     public static final Type UNKNOWN;\n     private static final ThreadLocal<Integer> CONSUMED_CHARS;\n     @Deprecated\n     protected byte type;\n     @Deprecated\n     protected String signature;\n     \n-    static int consumed(final int coded) {\n-        return coded >> 2;\n+    static int consumed(final int n) {\n+        return n >> 2;\n     }\n     \n-    static int encode(final int size, final int consumed) {\n-        return consumed << 2 | size;\n+    static int encode(final int n, final int n2) {\n+        return n2 << 2 | n;\n     }\n     \n-    public static Type[] getArgumentTypes(final String signature) {\n-        final List<Type> vec = new ArrayList<Type>();\n+    public static Type[] getArgumentTypes(final String s) {\n+        final ArrayList list = new ArrayList();\n         try {\n-            int index = signature.indexOf(40) + 1;\n-            if (index <= 0) {\n-                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n+            int n = s.indexOf(40) + 1;\n+            if (n <= 0) {\n+                throw new ClassFormatException(\"Invalid method signature: \" + s);\n             }\n-            while (signature.charAt(index) != ')') {\n-                vec.add(getType(signature.substring(index)));\n-                index += unwrap(Type.CONSUMED_CHARS);\n+            while (s.charAt(n) != ')') {\n+                list.add(getType(s.substring(n)));\n+                n += unwrap(Type.CONSUMED_CHARS);\n             }\n         }\n-        catch (final StringIndexOutOfBoundsException e) {\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)e);\n+        catch (final StringIndexOutOfBoundsException ex) {\n+            throw new ClassFormatException(\"Invalid method signature: \" + s, (Throwable)ex);\n         }\n-        final Type[] types = new Type[vec.size()];\n-        vec.toArray(types);\n-        return types;\n+        final Type[] array = new Type[list.size()];\n+        list.toArray(array);\n+        return array;\n     }\n     \n-    static int getArgumentTypesSize(final String signature) {\n-        int res = 0;\n+    static int getArgumentTypesSize(final String s) {\n+        int n = 0;\n         try {\n-            int index = signature.indexOf(40) + 1;\n-            if (index <= 0) {\n-                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n+            int n2 = s.indexOf(40) + 1;\n+            if (n2 <= 0) {\n+                throw new ClassFormatException(\"Invalid method signature: \" + s);\n             }\n-            while (signature.charAt(index) != ')') {\n-                final int coded = getTypeSize(signature.substring(index));\n-                res += size(coded);\n-                index += consumed(coded);\n+            while (s.charAt(n2) != ')') {\n+                final int typeSize = getTypeSize(s.substring(n2));\n+                n += size(typeSize);\n+                n2 += consumed(typeSize);\n             }\n         }\n-        catch (final StringIndexOutOfBoundsException e) {\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)e);\n+        catch (final StringIndexOutOfBoundsException ex) {\n+            throw new ClassFormatException(\"Invalid method signature: \" + s, (Throwable)ex);\n         }\n-        return res;\n+        return n;\n     }\n     \n-    public static String getMethodSignature(final Type returnType, final Type[] argTypes) {\n-        final StringBuilder buf = new StringBuilder(\"(\");\n-        if (argTypes != null) {\n-            for (final Type argType : argTypes) {\n-                buf.append(argType.getSignature());\n+    public static String getMethodSignature(final Type type, final Type[] array) {\n+        final StringBuilder sb = new StringBuilder(\"(\");\n+        if (array != null) {\n+            for (int length = array.length, i = 0; i < length; ++i) {\n+                sb.append(array[i].getSignature());\n             }\n         }\n-        buf.append(')');\n-        buf.append(returnType.getSignature());\n-        return buf.toString();\n+        sb.append(')');\n+        sb.append(type.getSignature());\n+        return sb.toString();\n     }\n     \n-    public static Type getReturnType(final String signature) {\n+    public static Type getReturnType(final String str) {\n         try {\n-            final int index = signature.lastIndexOf(41) + 1;\n-            return getType(signature.substring(index));\n+            return getType(str.substring(str.lastIndexOf(41) + 1));\n         }\n-        catch (final StringIndexOutOfBoundsException e) {\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)e);\n+        catch (final StringIndexOutOfBoundsException ex) {\n+            throw new ClassFormatException(\"Invalid method signature: \" + str, (Throwable)ex);\n         }\n     }\n     \n-    static int getReturnTypeSize(final String signature) {\n-        final int index = signature.lastIndexOf(41) + 1;\n-        return size(getTypeSize(signature.substring(index)));\n+    static int getReturnTypeSize(final String s) {\n+        return size(getTypeSize(s.substring(s.lastIndexOf(41) + 1)));\n     }\n     \n-    public static String getSignature(final Method meth) {\n+    public static String getSignature(final Method method) {\n         final StringBuilder sb = new StringBuilder(\"(\");\n-        final Class<?>[] parameterTypes;\n-        final Class<?>[] params = parameterTypes = meth.getParameterTypes();\n-        for (final Class<?> param : parameterTypes) {\n-            sb.append(getType(param).getSignature());\n+        final Class<?>[] parameterTypes = method.getParameterTypes();\n+        for (int length = parameterTypes.length, i = 0; i < length; ++i) {\n+            sb.append(getType(parameterTypes[i]).getSignature());\n         }\n         sb.append(\")\");\n-        sb.append(getType(meth.getReturnType()).getSignature());\n+        sb.append(getType(method.getReturnType()).getSignature());\n         return sb.toString();\n     }\n     \n-    public static Type getType(final Class<?> cls) {\n-        Objects.requireNonNull(cls, \"cls\");\n-        if (cls.isArray()) {\n-            return getType(cls.getName());\n+    public static Type getType(final Class<?> clazz) {\n+        Objects.requireNonNull(clazz, \"cls\");\n+        if (clazz.isArray()) {\n+            return getType(clazz.getName());\n         }\n-        if (!cls.isPrimitive()) {\n-            return (Type)ObjectType.getInstance(cls.getName());\n+        if (!clazz.isPrimitive()) {\n+            return (Type)ObjectType.getInstance(clazz.getName());\n         }\n-        if (cls == Integer.TYPE) {\n+        if (clazz == Integer.TYPE) {\n             return (Type)Type.INT;\n         }\n-        if (cls == Void.TYPE) {\n+        if (clazz == Void.TYPE) {\n             return (Type)Type.VOID;\n         }\n-        if (cls == Double.TYPE) {\n+        if (clazz == Double.TYPE) {\n             return (Type)Type.DOUBLE;\n         }\n-        if (cls == Float.TYPE) {\n+        if (clazz == Float.TYPE) {\n             return (Type)Type.FLOAT;\n         }\n-        if (cls == Boolean.TYPE) {\n+        if (clazz == Boolean.TYPE) {\n             return (Type)Type.BOOLEAN;\n         }\n-        if (cls == Byte.TYPE) {\n+        if (clazz == Byte.TYPE) {\n             return (Type)Type.BYTE;\n         }\n-        if (cls == Short.TYPE) {\n+        if (clazz == Short.TYPE) {\n             return (Type)Type.SHORT;\n         }\n-        if (cls == Long.TYPE) {\n+        if (clazz == Long.TYPE) {\n             return (Type)Type.LONG;\n         }\n-        if (cls == Character.TYPE) {\n+        if (clazz == Character.TYPE) {\n             return (Type)Type.CHAR;\n         }\n-        throw new IllegalStateException(\"Unknown primitive type \" + cls);\n+        throw new IllegalStateException(\"Unknown primitive type \" + clazz);\n     }\n     \n-    public static Type getType(final String signature) throws StringIndexOutOfBoundsException {\n-        final byte type = Utility.typeOfSignature(signature);\n-        if (type <= 12) {\n+    public static Type getType(final String s) throws StringIndexOutOfBoundsException {\n+        final byte typeOfSignature = Utility.typeOfSignature(s);\n+        if (typeOfSignature <= 12) {\n             wrap(Type.CONSUMED_CHARS, 1);\n-            return (Type)BasicType.getType(type);\n+            return (Type)BasicType.getType(typeOfSignature);\n         }\n-        if (type != 13) {\n-            final String parsedSignature = Utility.typeSignatureToString(signature, false);\n-            wrap(Type.CONSUMED_CHARS, parsedSignature.length() + 2);\n-            return (Type)ObjectType.getInstance(Utility.pathToPackage(parsedSignature));\n+        if (typeOfSignature != 13) {\n+            final String typeSignatureToString = Utility.typeSignatureToString(s, false);\n+            wrap(Type.CONSUMED_CHARS, typeSignatureToString.length() + 2);\n+            return (Type)ObjectType.getInstance(Utility.pathToPackage(typeSignatureToString));\n         }\n-        int dim = 0;\n+        int n = 0;\n         do {\n-            ++dim;\n-        } while (signature.charAt(dim) == '[');\n-        final Type t = getType(signature.substring(dim));\n-        final int temp = unwrap(Type.CONSUMED_CHARS) + dim;\n-        wrap(Type.CONSUMED_CHARS, temp);\n-        return (Type)new ArrayType(t, dim);\n-    }\n-    \n-    public static Type[] getTypes(final Class<?>[] classes) {\n-        final Type[] ret = new Type[classes.length];\n-        Arrays.setAll(ret, i -> getType(classes[i]));\n-        return ret;\n-    }\n-    \n-    static int getTypeSize(final String signature) throws StringIndexOutOfBoundsException {\n-        final byte type = Utility.typeOfSignature(signature);\n-        if (type <= 12) {\n-            return encode(BasicType.getType(type).getSize(), 1);\n+            ++n;\n+        } while (s.charAt(n) == '[');\n+        final Type type = getType(s.substring(n));\n+        wrap(Type.CONSUMED_CHARS, unwrap(Type.CONSUMED_CHARS) + n);\n+        return (Type)new ArrayType(type, n);\n+    }\n+    \n+    public static Type[] getTypes(final Class<?>[] array) {\n+        final Type[] array2 = new Type[array.length];\n+        Arrays.setAll(array2, n2 -> getType(array3[n2]));\n+        return array2;\n+    }\n+    \n+    static int getTypeSize(final String str) throws StringIndexOutOfBoundsException {\n+        final byte typeOfSignature = Utility.typeOfSignature(str);\n+        if (typeOfSignature <= 12) {\n+            return encode(BasicType.getType(typeOfSignature).getSize(), 1);\n         }\n-        if (type == 13) {\n-            int dim = 0;\n+        if (typeOfSignature == 13) {\n+            int n = 0;\n             do {\n-                ++dim;\n-            } while (signature.charAt(dim) == '[');\n-            final int consumed = consumed(getTypeSize(signature.substring(dim)));\n-            return encode(1, dim + consumed);\n+                ++n;\n+            } while (str.charAt(n) == '[');\n+            return encode(1, n + consumed(getTypeSize(str.substring(n))));\n         }\n-        final int index = signature.indexOf(59);\n+        final int index = str.indexOf(59);\n         if (index < 0) {\n-            throw new ClassFormatException(\"Invalid signature: \" + signature);\n+            throw new ClassFormatException(\"Invalid signature: \" + str);\n         }\n         return encode(1, index + 1);\n     }\n     \n-    static int size(final int coded) {\n-        return coded & 0x3;\n+    static int size(final int n) {\n+        return n & 0x3;\n     }\n     \n-    private static int unwrap(final ThreadLocal<Integer> tl) {\n-        return Integer.valueOf(tl.get());\n+    private static int unwrap(final ThreadLocal<Integer> threadLocal) {\n+        return Integer.valueOf(threadLocal.get());\n     }\n     \n-    private static void wrap(final ThreadLocal<Integer> tl, final int value) {\n-        tl.set(Integer.valueOf(value));\n+    private static void wrap(final ThreadLocal<Integer> threadLocal, final int i) {\n+        threadLocal.set(Integer.valueOf(i));\n     }\n     \n-    protected Type(final byte t, final String s) {\n-        this.type = t;\n-        this.signature = s;\n+    protected Type(final byte type, final String signature) {\n+        this.type = type;\n+        this.signature = signature;\n     }\n     \n     @Override\n     public boolean equals(final Object o) {\n         if (o instanceof Type) {\n-            final Type t = (Type)o;\n-            return this.type == t.type && this.signature.equals(t.signature);\n+            final Type type = (Type)o;\n+            return this.type == type.type && this.signature.equals(type.signature);\n         }\n         return false;\n     }\n     \n     public String getSignature() {\n         return this.signature;\n     }\n"}]}
