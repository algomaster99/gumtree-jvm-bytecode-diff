{"diffoscope-json-version": 1, "source1": "first/NioZipEncoding.class", "source2": "second/NioZipEncoding.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -15,14 +15,20 @@\n     private final Charset charset;\n     private final boolean useReplacement;\n     private static final char REPLACEMENT = '?';\n     private static final byte[] REPLACEMENT_BYTES;\n     private static final String REPLACEMENT_STRING;\n     private static final char[] HEX_CHARS;\n     \n+    static {\n+        REPLACEMENT_BYTES = new byte[] { 63 };\n+        REPLACEMENT_STRING = String.valueOf('?');\n+        HEX_CHARS = new char[] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n+    }\n+    \n     NioZipEncoding(final Charset charset, final boolean useReplacement) {\n         this.charset = charset;\n         this.useReplacement = useReplacement;\n     }\n     \n     public Charset getCharset() {\n         return this.charset;\n@@ -62,15 +68,15 @@\n                     continue;\n                 }\n                 final int increment = estimateIncrementalEncodingSize(enc, cb.remaining());\n                 out = ZipEncodingHelper.growBufferBy(out, increment);\n             }\n         }\n         enc.encode(cb, out, true);\n-        out.limit();\n+        out.limit(out.position());\n         out.rewind();\n         return out;\n     }\n     \n     public String decode(final byte[] data) throws IOException {\n         return this.newDecoder().decode(ByteBuffer.wrap(data)).toString();\n     }\n@@ -84,15 +90,15 @@\n                 o = ZipEncodingHelper.growBufferBy(o, increment);\n             }\n         }\n         return o;\n     }\n     \n     private static CharBuffer encodeSurrogate(final CharBuffer cb, final char c) {\n-        cb.position().limit(6);\n+        cb.position(0).limit(6);\n         cb.put('%');\n         cb.put('U');\n         cb.put(NioZipEncoding.HEX_CHARS[c >> 12 & 0xF]);\n         cb.put(NioZipEncoding.HEX_CHARS[c >> 8 & 0xF]);\n         cb.put(NioZipEncoding.HEX_CHARS[c >> 4 & 0xF]);\n         cb.put(NioZipEncoding.HEX_CHARS[c & '\\u000f']);\n         cb.flip();\n@@ -118,14 +124,8 @@\n         final float rest = (charChount - 1) * enc.averageBytesPerChar();\n         return (int)Math.ceil(first + rest);\n     }\n     \n     private static int estimateIncrementalEncodingSize(final CharsetEncoder enc, final int charCount) {\n         return (int)Math.ceil(charCount * enc.averageBytesPerChar());\n     }\n-    \n-    static {\n-        REPLACEMENT_BYTES = new byte[] { 63 };\n-        REPLACEMENT_STRING = String.valueOf('?');\n-        HEX_CHARS = new char[] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n-    }\n }\n"}]}
