{"diffoscope-json-version": 1, "source1": "first/ModelTransaction$ChildrenUpdateOperation.class", "source2": "second/ModelTransaction$ChildrenUpdateOperation.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,13 +1,12 @@\n \n package org.apache.commons.configuration2.tree;\n \n import java.util.Collections;\n import java.util.Iterator;\n-import java.util.List;\n import java.util.LinkedList;\n import java.util.Map;\n import java.util.Set;\n import java.util.Collection;\n \n private class ChildrenUpdateOperation extends ModelTransaction.Operation\n {\n@@ -16,56 +15,56 @@\n     private Map<ImmutableNode, ImmutableNode> nodesToReplace;\n     \n     private ChildrenUpdateOperation(final ModelTransaction this$0) {\n         this.this$0 = this$0;\n         super((ModelTransaction.ModelTransaction$1)null);\n     }\n     \n-    public void combine(final ChildrenUpdateOperation op) {\n-        this.newNodes = ModelTransaction.access$600(this.newNodes, op.newNodes);\n-        this.nodesToReplace = ModelTransaction.access$700(this.nodesToReplace, op.nodesToReplace);\n-        this.nodesToRemove = ModelTransaction.access$800(this.nodesToRemove, op.nodesToRemove);\n+    public void combine(final ChildrenUpdateOperation childrenUpdateOperation) {\n+        this.newNodes = ModelTransaction.access$600(this.newNodes, childrenUpdateOperation.newNodes);\n+        this.nodesToReplace = ModelTransaction.access$700(this.nodesToReplace, childrenUpdateOperation.nodesToReplace);\n+        this.nodesToRemove = ModelTransaction.access$800(this.nodesToRemove, childrenUpdateOperation.nodesToRemove);\n     }\n     \n-    public void addNewNode(final ImmutableNode node) {\n-        this.newNodes = ModelTransaction.access$900(this.newNodes, (Object)node);\n+    public void addNewNode(final ImmutableNode immutableNode) {\n+        this.newNodes = ModelTransaction.access$900(this.newNodes, (Object)immutableNode);\n     }\n     \n-    public void addNewNodes(final Collection<? extends ImmutableNode> nodes) {\n-        this.newNodes = ModelTransaction.access$600(this.newNodes, (Collection)nodes);\n+    public void addNewNodes(final Collection<? extends ImmutableNode> collection) {\n+        this.newNodes = ModelTransaction.access$600(this.newNodes, (Collection)collection);\n     }\n     \n-    public void addNodeToReplace(final ImmutableNode org, final ImmutableNode replacement) {\n-        this.nodesToReplace = ModelTransaction.access$1000(this.nodesToReplace, (Object)org, (Object)replacement);\n+    public void addNodeToReplace(final ImmutableNode immutableNode, final ImmutableNode immutableNode2) {\n+        this.nodesToReplace = ModelTransaction.access$1000(this.nodesToReplace, (Object)immutableNode, (Object)immutableNode2);\n     }\n     \n-    public void addNodeToRemove(final ImmutableNode node) {\n-        this.nodesToRemove = ModelTransaction.access$1100(this.nodesToRemove, (Object)node);\n+    public void addNodeToRemove(final ImmutableNode immutableNode) {\n+        this.nodesToRemove = ModelTransaction.access$1100(this.nodesToRemove, (Object)immutableNode);\n     }\n     \n-    protected ImmutableNode apply(final ImmutableNode target, final ModelTransaction.Operations operations) {\n-        final Map<ImmutableNode, ImmutableNode> replacements = this.fetchReplacementMap();\n-        final Set<ImmutableNode> removals = this.fetchRemovalSet();\n-        final List<ImmutableNode> resultNodes = new LinkedList<ImmutableNode>();\n-        for (final ImmutableNode nd : target) {\n-            final ImmutableNode repl = (ImmutableNode)replacements.get(nd);\n-            if (repl != null) {\n-                resultNodes.add(repl);\n-                ModelTransaction.access$1200(this.this$0).put(nd, repl);\n+    protected ImmutableNode apply(final ImmutableNode immutableNode, final ModelTransaction.Operations operations) {\n+        final Map fetchReplacementMap = this.fetchReplacementMap();\n+        final Set fetchRemovalSet = this.fetchRemovalSet();\n+        final LinkedList list = new LinkedList();\n+        for (final ImmutableNode immutableNode2 : immutableNode) {\n+            final ImmutableNode immutableNode3 = (ImmutableNode)fetchReplacementMap.get(immutableNode2);\n+            if (immutableNode3 != null) {\n+                list.add(immutableNode3);\n+                ModelTransaction.access$1200(this.this$0).put(immutableNode2, immutableNode3);\n             }\n-            else if (removals.contains(nd)) {\n-                ModelTransaction.access$1300(this.this$0).add(nd);\n+            else if (fetchRemovalSet.contains(immutableNode2)) {\n+                ModelTransaction.access$1300(this.this$0).add(immutableNode2);\n             }\n             else {\n-                resultNodes.add(nd);\n+                list.add(immutableNode2);\n             }\n         }\n-        ModelTransaction.access$600((Collection)resultNodes, this.newNodes);\n+        ModelTransaction.access$600((Collection)list, this.newNodes);\n         operations.newNodesAdded(this.newNodes);\n-        return target.replaceChildren((Collection)resultNodes);\n+        return immutableNode.replaceChildren((Collection)list);\n     }\n     \n     private Map<ImmutableNode, ImmutableNode> fetchReplacementMap() {\n         return (this.nodesToReplace != null) ? this.nodesToReplace : Collections.emptyMap();\n     }\n     \n     private Set<ImmutableNode> fetchRemovalSet() {\n"}]}
