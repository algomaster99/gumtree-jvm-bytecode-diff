{"diffoscope-json-version": 1, "source1": "first/Segment.class", "source2": "second/Segment.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -30,15 +30,15 @@\n     private Attribute[] nonStandardAttributePrototypes;\n     \n     public Segment() {\n         this.fieldVisitor = new Segment.SegmentFieldVisitor(this);\n         this.methodVisitor = new Segment.SegmentMethodVisitor(this);\n     }\n     \n-    public void pack(final Archive.SegmentUnit segmentUnit, final OutputStream out, final PackingOptions options) throws IOException, Pack200Exception {\n+    public void pack(final Archive.SegmentUnit segmentUnit, final OutputStream outputStream, final PackingOptions options) throws IOException, Pack200Exception {\n         this.options = options;\n         this.stripDebug = options.isStripDebug();\n         final int effort = options.getEffort();\n         this.nonStandardAttributePrototypes = options.getUnknownAttributePrototypes();\n         PackingUtils.log(\"Start to pack a new segment with \" + segmentUnit.fileListSize() + \" files including \" + segmentUnit.classListSize() + \" classes\");\n         PackingUtils.log(\"Initialize a header for the segment\");\n         (this.segmentHeader = new SegmentHeader()).setFile_count(segmentUnit.fileListSize());\n@@ -61,178 +61,178 @@\n         this.processClasses(segmentUnit, this.nonStandardAttributePrototypes);\n         this.cpBands.finaliseBands();\n         this.attributeDefinitionBands.finaliseBands();\n         this.icBands.finaliseBands();\n         this.classBands.finaliseBands();\n         this.bcBands.finaliseBands();\n         this.fileBands.finaliseBands();\n-        final ByteArrayOutputStream bandsOutputStream = new ByteArrayOutputStream();\n+        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n         PackingUtils.log(\"Packing...\");\n-        final int finalNumberOfClasses = this.classBands.numClassesProcessed();\n-        this.segmentHeader.setClass_count(finalNumberOfClasses);\n-        this.cpBands.pack((OutputStream)bandsOutputStream);\n-        if (finalNumberOfClasses > 0) {\n-            this.attributeDefinitionBands.pack((OutputStream)bandsOutputStream);\n-            this.icBands.pack((OutputStream)bandsOutputStream);\n-            this.classBands.pack((OutputStream)bandsOutputStream);\n-            this.bcBands.pack((OutputStream)bandsOutputStream);\n-        }\n-        this.fileBands.pack((OutputStream)bandsOutputStream);\n-        final ByteArrayOutputStream headerOutputStream = new ByteArrayOutputStream();\n-        this.segmentHeader.pack((OutputStream)headerOutputStream);\n-        headerOutputStream.writeTo(out);\n-        bandsOutputStream.writeTo(out);\n-        segmentUnit.addPackedByteAmount(headerOutputStream.size());\n-        segmentUnit.addPackedByteAmount(bandsOutputStream.size());\n+        final int numClassesProcessed = this.classBands.numClassesProcessed();\n+        this.segmentHeader.setClass_count(numClassesProcessed);\n+        this.cpBands.pack((OutputStream)byteArrayOutputStream);\n+        if (numClassesProcessed > 0) {\n+            this.attributeDefinitionBands.pack((OutputStream)byteArrayOutputStream);\n+            this.icBands.pack((OutputStream)byteArrayOutputStream);\n+            this.classBands.pack((OutputStream)byteArrayOutputStream);\n+            this.bcBands.pack((OutputStream)byteArrayOutputStream);\n+        }\n+        this.fileBands.pack((OutputStream)byteArrayOutputStream);\n+        final ByteArrayOutputStream byteArrayOutputStream2 = new ByteArrayOutputStream();\n+        this.segmentHeader.pack((OutputStream)byteArrayOutputStream2);\n+        byteArrayOutputStream2.writeTo(outputStream);\n+        byteArrayOutputStream.writeTo(outputStream);\n+        segmentUnit.addPackedByteAmount(byteArrayOutputStream2.size());\n+        segmentUnit.addPackedByteAmount(byteArrayOutputStream.size());\n         PackingUtils.log(\"Wrote total of \" + segmentUnit.getPackedByteAmount() + \" bytes\");\n         PackingUtils.log(\"Transmitted \" + segmentUnit.fileListSize() + \" files of \" + segmentUnit.getByteAmount() + \" input bytes in a segment of \" + segmentUnit.getPackedByteAmount() + \" bytes\");\n     }\n     \n-    private void processClasses(final Archive.SegmentUnit segmentUnit, final Attribute[] attributes) throws Pack200Exception {\n+    private void processClasses(final Archive.SegmentUnit segmentUnit, final Attribute[] array) throws Pack200Exception {\n         this.segmentHeader.setClass_count(segmentUnit.classListSize());\n-        for (final Pack200ClassReader classReader : segmentUnit.getClassList()) {\n-            this.currentClassReader = classReader;\n-            int flags = 0;\n+        for (final Pack200ClassReader currentClassReader : segmentUnit.getClassList()) {\n+            this.currentClassReader = currentClassReader;\n+            int n = 0;\n             if (this.stripDebug) {\n-                flags |= 0x2;\n+                n |= 0x2;\n             }\n             try {\n-                classReader.accept((ClassVisitor)this, attributes, flags);\n+                currentClassReader.accept((ClassVisitor)this, array, n);\n             }\n-            catch (final Segment.PassException pe) {\n+            catch (final Segment.PassException ex) {\n                 this.classBands.removeCurrentClass();\n-                final String name = classReader.getFileName();\n-                this.options.addPassFile(name);\n-                this.cpBands.addCPUtf8(name);\n-                boolean found = false;\n-                for (final Archive.PackingFile file : segmentUnit.getFileList()) {\n-                    if (file.getName().equals(name)) {\n-                        found = true;\n-                        file.setContents(classReader.b);\n+                final String fileName = currentClassReader.getFileName();\n+                this.options.addPassFile(fileName);\n+                this.cpBands.addCPUtf8(fileName);\n+                boolean b = false;\n+                for (final Archive.PackingFile packingFile : segmentUnit.getFileList()) {\n+                    if (packingFile.getName().equals(fileName)) {\n+                        b = true;\n+                        packingFile.setContents(currentClassReader.b);\n                         break;\n                     }\n                 }\n-                if (!found) {\n-                    throw new Pack200Exception(\"Error passing file \" + name);\n+                if (!b) {\n+                    throw new Pack200Exception(\"Error passing file \" + fileName);\n                 }\n                 continue;\n             }\n         }\n     }\n     \n-    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\n-        this.bcBands.setCurrentClass(name, superName);\n-        this.segmentHeader.addMajorVersion(version);\n-        this.classBands.addClass(version, access, name, signature, superName, interfaces);\n+    public void visit(final int n, final int n2, final String s, final String s2, final String s3, final String[] array) {\n+        this.bcBands.setCurrentClass(s, s3);\n+        this.segmentHeader.addMajorVersion(n);\n+        this.classBands.addClass(n, n2, s, s2, s3, array);\n     }\n     \n-    public void visitSource(final String source, final String debug) {\n+    public void visitSource(final String s, final String s2) {\n         if (!this.stripDebug) {\n-            this.classBands.addSourceFile(source);\n+            this.classBands.addSourceFile(s);\n         }\n     }\n     \n-    public void visitOuterClass(final String owner, final String name, final String desc) {\n-        this.classBands.addEnclosingMethod(owner, name, desc);\n+    public void visitOuterClass(final String s, final String s2, final String s3) {\n+        this.classBands.addEnclosingMethod(s, s2, s3);\n     }\n     \n-    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n-        return (AnnotationVisitor)new Segment.SegmentAnnotationVisitor(this, 0, desc, visible);\n+    public AnnotationVisitor visitAnnotation(final String s, final boolean b) {\n+        return (AnnotationVisitor)new Segment.SegmentAnnotationVisitor(this, 0, s, b);\n     }\n     \n     public void visitAttribute(final Attribute attribute) {\n         if (attribute.isUnknown()) {\n-            final String action = this.options.getUnknownAttributeAction();\n-            if (action.equals(\"pass\")) {\n+            final String unknownAttributeAction = this.options.getUnknownAttributeAction();\n+            if (unknownAttributeAction.equals(\"pass\")) {\n                 this.passCurrentClass();\n             }\n-            else if (action.equals(\"error\")) {\n+            else if (unknownAttributeAction.equals(\"error\")) {\n                 throw new Error(\"Unknown attribute encountered\");\n             }\n         }\n         else {\n             if (!(attribute instanceof NewAttribute)) {\n                 throw new RuntimeException(\"Unexpected attribute encountered: \" + attribute.type);\n             }\n             final NewAttribute newAttribute = (NewAttribute)attribute;\n             if (newAttribute.isUnknown(0)) {\n-                final String action2 = this.options.getUnknownClassAttributeAction(newAttribute.type);\n-                if (action2.equals(\"pass\")) {\n+                final String unknownClassAttributeAction = this.options.getUnknownClassAttributeAction(newAttribute.type);\n+                if (unknownClassAttributeAction.equals(\"pass\")) {\n                     this.passCurrentClass();\n                 }\n-                else if (action2.equals(\"error\")) {\n+                else if (unknownClassAttributeAction.equals(\"error\")) {\n                     throw new Error(\"Unknown attribute encountered\");\n                 }\n             }\n             this.classBands.addClassAttribute(newAttribute);\n         }\n     }\n     \n-    public void visitInnerClass(final String name, final String outerName, final String innerName, final int flags) {\n-        this.icBands.addInnerClass(name, outerName, innerName, flags);\n+    public void visitInnerClass(final String s, final String s2, final String s3, final int n) {\n+        this.icBands.addInnerClass(s, s2, s3, n);\n     }\n     \n-    public FieldVisitor visitField(final int flags, final String name, final String desc, final String signature, final Object value) {\n-        this.classBands.addField(flags, name, desc, signature, value);\n+    public FieldVisitor visitField(final int n, final String s, final String s2, final String s3, final Object o) {\n+        this.classBands.addField(n, s, s2, s3, o);\n         return (FieldVisitor)this.fieldVisitor;\n     }\n     \n-    public MethodVisitor visitMethod(final int flags, final String name, final String desc, final String signature, final String[] exceptions) {\n-        this.classBands.addMethod(flags, name, desc, signature, exceptions);\n+    public MethodVisitor visitMethod(final int n, final String s, final String s2, final String s3, final String[] array) {\n+        this.classBands.addMethod(n, s, s2, s3, array);\n         return (MethodVisitor)this.methodVisitor;\n     }\n     \n     public void visitEnd() {\n         this.classBands.endOfClass();\n     }\n     \n     public ClassBands getClassBands() {\n         return this.classBands;\n     }\n     \n-    private void addValueAndTag(final Object value, final List T, final List values) {\n-        if (value instanceof Integer) {\n-            T.add(\"I\");\n-            values.add(value);\n-        }\n-        else if (value instanceof Double) {\n-            T.add(\"D\");\n-            values.add(value);\n-        }\n-        else if (value instanceof Float) {\n-            T.add(\"F\");\n-            values.add(value);\n-        }\n-        else if (value instanceof Long) {\n-            T.add(\"J\");\n-            values.add(value);\n-        }\n-        else if (value instanceof Byte) {\n-            T.add(\"B\");\n-            values.add(Integer.valueOf((int)value));\n-        }\n-        else if (value instanceof Character) {\n-            T.add(\"C\");\n-            values.add(Integer.valueOf((int)value));\n-        }\n-        else if (value instanceof Short) {\n-            T.add(\"S\");\n-            values.add(Integer.valueOf((int)value));\n-        }\n-        else if (value instanceof Boolean) {\n-            T.add(\"Z\");\n-            values.add(Integer.valueOf((int)(((boolean)value) ? 1 : 0)));\n-        }\n-        else if (value instanceof String) {\n-            T.add(\"s\");\n-            values.add(value);\n-        }\n-        else if (value instanceof Type) {\n-            T.add(\"c\");\n-            values.add(((Type)value).toString());\n+    private void addValueAndTag(final Object o, final List list, final List list2) {\n+        if (o instanceof Integer) {\n+            list.add(\"I\");\n+            list2.add(o);\n+        }\n+        else if (o instanceof Double) {\n+            list.add(\"D\");\n+            list2.add(o);\n+        }\n+        else if (o instanceof Float) {\n+            list.add(\"F\");\n+            list2.add(o);\n+        }\n+        else if (o instanceof Long) {\n+            list.add(\"J\");\n+            list2.add(o);\n+        }\n+        else if (o instanceof Byte) {\n+            list.add(\"B\");\n+            list2.add(Integer.valueOf((int)o));\n+        }\n+        else if (o instanceof Character) {\n+            list.add(\"C\");\n+            list2.add(Integer.valueOf((int)o));\n+        }\n+        else if (o instanceof Short) {\n+            list.add(\"S\");\n+            list2.add(Integer.valueOf((int)o));\n+        }\n+        else if (o instanceof Boolean) {\n+            list.add(\"Z\");\n+            list2.add(Integer.valueOf((int)(((boolean)o) ? 1 : 0)));\n+        }\n+        else if (o instanceof String) {\n+            list.add(\"s\");\n+            list2.add(o);\n+        }\n+        else if (o instanceof Type) {\n+            list.add(\"c\");\n+            list2.add(((Type)o).toString());\n         }\n     }\n     \n     public boolean lastConstantHadWideIndex() {\n         return this.currentClassReader.lastConstantHadWideIndex();\n     }\n     \n"}]}
