{"diffoscope-json-version": 1, "source1": "first/SummaryJavadocCheck.class", "source2": "second/SummaryJavadocCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,18 +1,18 @@\n \n package com.puppycrawl.tools.checkstyle.checks.javadoc;\n \n-import com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n import com.puppycrawl.tools.checkstyle.utils.JavadocUtil;\n import java.util.function.Function;\n import java.util.function.Predicate;\n import java.util.Arrays;\n import java.util.Optional;\n import com.puppycrawl.tools.checkstyle.api.DetailNode;\n import com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n+import com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n import java.util.BitSet;\n import java.util.regex.Pattern;\n import com.puppycrawl.tools.checkstyle.StatelessCheck;\n \n @StatelessCheck\n public class SummaryJavadocCheck extends AbstractJavadocCheck\n {\n@@ -25,14 +25,20 @@\n     private static final String DEFAULT_PERIOD = \".\";\n     private static final String SUMMARY_TEXT = \"@summary\";\n     private static final String RETURN_TEXT = \"@return\";\n     private static final BitSet ALLOWED_TYPES;\n     private Pattern forbiddenSummaryFragments;\n     private String period;\n     \n+    static {\n+        JAVADOC_MULTILINE_TO_SINGLELINE_PATTERN = Pattern.compile(\"\\n +(\\\\*)|^ +(\\\\*)\");\n+        HTML_ELEMENTS = Pattern.compile(\"<[^>]*>\");\n+        ALLOWED_TYPES = TokenUtil.asBitSet(new int[] { 4, 10068, 10074 });\n+    }\n+    \n     public SummaryJavadocCheck() {\n         this.forbiddenSummaryFragments = CommonUtil.createPattern(\"^$\");\n         this.period = \".\";\n     }\n     \n     public void setForbiddenSummaryFragments(final Pattern pattern) {\n         this.forbiddenSummaryFragments = pattern;\n@@ -200,15 +206,17 @@\n     \n     private static void extractInlineTagContent(final DetailNode node, final StringBuilder customTagContent) {\n         final DetailNode[] children = node.getChildren();\n         if (children.length == 0) {\n             customTagContent.append(node.getText());\n         }\n         else {\n-            for (final DetailNode child : children) {\n+            DetailNode[] array;\n+            for (int length = (array = children).length, i = 0; i < length; ++i) {\n+                final DetailNode child = array[i];\n                 if (child.getType() != 1) {\n                     extractInlineTagContent(child, customTagContent);\n                 }\n             }\n         }\n     }\n     \n@@ -221,50 +229,54 @@\n         final String javadocText = SummaryJavadocCheck.JAVADOC_MULTILINE_TO_SINGLELINE_PATTERN.matcher(firstSentence).replaceAll(\" \").trim();\n         return this.forbiddenSummaryFragments.matcher(trimExcessWhitespaces(javadocText)).find();\n     }\n     \n     private static String trimExcessWhitespaces(final String text) {\n         final StringBuilder result = new StringBuilder(256);\n         boolean previousWhitespace = true;\n-        for (final char letter : text.toCharArray()) {\n-            Label_0075: {\n-                char print;\n-                if (Character.isWhitespace(letter)) {\n-                    if (previousWhitespace) {\n-                        break Label_0075;\n-                    }\n-                    previousWhitespace = true;\n-                    print = ' ';\n-                }\n-                else {\n-                    previousWhitespace = false;\n-                    print = letter;\n+        char[] charArray;\n+        for (int length = (charArray = text.toCharArray()).length, i = 0; i < length; ++i) {\n+            final char letter = charArray[i];\n+            char print;\n+            if (Character.isWhitespace(letter)) {\n+                if (previousWhitespace) {\n+                    continue;\n                 }\n-                result.append(print);\n+                previousWhitespace = true;\n+                print = ' ';\n             }\n+            else {\n+                previousWhitespace = false;\n+                print = letter;\n+            }\n+            result.append(print);\n         }\n         return result.toString();\n     }\n     \n     private static boolean startsWithInheritDoc(final DetailNode root) {\n         boolean found = false;\n-        for (final DetailNode child : root.getChildren()) {\n+        DetailNode[] children;\n+        for (int length = (children = root.getChildren()).length, i = 0; i < length; ++i) {\n+            final DetailNode child = children[i];\n             if (child.getType() == 10072 && child.getChildren()[1].getType() == 47) {\n                 found = true;\n             }\n             if ((child.getType() == 10074 || child.getType() == 10001) && !CommonUtil.isBlank(child.getText())) {\n                 break;\n             }\n         }\n         return found;\n     }\n     \n     private static String getSummarySentence(final DetailNode ast) {\n         final StringBuilder result = new StringBuilder(256);\n-        for (final DetailNode child : ast.getChildren()) {\n+        DetailNode[] children;\n+        for (int length = (children = ast.getChildren()).length, i = 0; i < length; ++i) {\n+            final DetailNode child = children[i];\n             if (child.getType() != -1 && SummaryJavadocCheck.ALLOWED_TYPES.get(child.getType())) {\n                 result.append(child.getText());\n             }\n             else {\n                 final String summary = result.toString();\n                 if (child.getType() == 10001 && CommonUtil.isBlank(summary)) {\n                     result.append(getStringInsideTag(summary, child.getChildren()[0].getChildren()[0]));\n@@ -283,15 +295,17 @@\n         }\n         return contents.toString();\n     }\n     \n     private static String getFirstSentence(final DetailNode ast) {\n         final StringBuilder result = new StringBuilder(256);\n         final String periodSuffix = \". \";\n-        for (final DetailNode child : ast.getChildren()) {\n+        DetailNode[] children;\n+        for (int length = (children = ast.getChildren()).length, i = 0; i < length; ++i) {\n+            final DetailNode child = children[i];\n             String text;\n             if (child.getChildren().length == 0) {\n                 text = child.getText();\n             }\n             else {\n                 text = getFirstSentence(child);\n             }\n@@ -299,14 +313,8 @@\n                 result.append(text, 0, text.indexOf(\". \") + 1);\n                 break;\n             }\n             result.append(text);\n         }\n         return result.toString();\n     }\n-    \n-    static {\n-        JAVADOC_MULTILINE_TO_SINGLELINE_PATTERN = Pattern.compile(\"\\n +(\\\\*)|^ +(\\\\*)\");\n-        HTML_ELEMENTS = Pattern.compile(\"<[^>]*>\");\n-        ALLOWED_TYPES = TokenUtil.asBitSet(new int[] { 4, 10068, 10074 });\n-    }\n }\n"}]}
