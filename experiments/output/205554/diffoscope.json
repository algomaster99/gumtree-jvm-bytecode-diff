{"diffoscope-json-version": 1, "source1": "first/XMLConfiguration$XMLBuilderVisitor.class", "source2": "second/XMLConfiguration$XMLBuilderVisitor.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,11 +1,10 @@\n \n package org.apache.commons.configuration2;\n \n-import java.util.Collection;\n import org.w3c.dom.NodeList;\n import org.w3c.dom.CDATASection;\n import java.util.ArrayList;\n import org.w3c.dom.NamedNodeMap;\n import org.w3c.dom.Text;\n import java.util.Iterator;\n import org.apache.commons.configuration2.tree.NodeHandler;\n@@ -23,162 +22,159 @@\n static class XMLBuilderVisitor extends BaseHierarchicalConfiguration.BuilderVisitor\n {\n     private final Document document;\n     private final Map<Node, Node> elementMapping;\n     private final Map<ImmutableNode, Element> newElements;\n     private final ListDelimiterHandler listDelimiterHandler;\n     \n-    public XMLBuilderVisitor(final XMLDocumentHelper docHelper, final ListDelimiterHandler handler) {\n-        this.document = docHelper.getDocument();\n-        this.elementMapping = docHelper.getElementMapping();\n-        this.listDelimiterHandler = handler;\n+    public XMLBuilderVisitor(final XMLDocumentHelper xmlDocumentHelper, final ListDelimiterHandler listDelimiterHandler) {\n+        this.document = xmlDocumentHelper.getDocument();\n+        this.elementMapping = xmlDocumentHelper.getElementMapping();\n+        this.listDelimiterHandler = listDelimiterHandler;\n         this.newElements = new HashMap();\n     }\n     \n-    public void processDocument(final ReferenceNodeHandler refHandler) {\n-        updateAttributes((ImmutableNode)refHandler.getRootNode(), this.document.getDocumentElement());\n-        NodeTreeWalker.INSTANCE.walkDFS(refHandler.getRootNode(), (ConfigurationNodeVisitor)this, (NodeHandler)refHandler);\n+    public void processDocument(final ReferenceNodeHandler referenceNodeHandler) {\n+        updateAttributes((ImmutableNode)referenceNodeHandler.getRootNode(), this.document.getDocumentElement());\n+        NodeTreeWalker.INSTANCE.walkDFS(referenceNodeHandler.getRootNode(), (ConfigurationNodeVisitor)this, (NodeHandler)referenceNodeHandler);\n     }\n     \n-    public void handleRemovedNodes(final ReferenceNodeHandler refHandler) {\n-        for (final Object ref : refHandler.removedReferences()) {\n-            if (ref instanceof Node) {\n-                final Node removedElem = (Node)ref;\n-                this.removeReference(this.elementMapping.get(removedElem));\n+    public void handleRemovedNodes(final ReferenceNodeHandler referenceNodeHandler) {\n+        for (final Object next : referenceNodeHandler.removedReferences()) {\n+            if (next instanceof Node) {\n+                this.removeReference((Element)this.elementMapping.get(next));\n             }\n         }\n     }\n     \n-    protected void insert(final ImmutableNode newNode, final ImmutableNode parent, final ImmutableNode sibling1, final ImmutableNode sibling2, final ReferenceNodeHandler refHandler) {\n-        if (XMLListReference.isListNode(newNode, refHandler)) {\n+    protected void insert(final ImmutableNode immutableNode, final ImmutableNode immutableNode2, final ImmutableNode immutableNode3, final ImmutableNode immutableNode4, final ReferenceNodeHandler referenceNodeHandler) {\n+        if (XMLListReference.isListNode(immutableNode, referenceNodeHandler)) {\n             return;\n         }\n-        final Element elem = this.document.createElement(newNode.getNodeName());\n-        this.newElements.put(newNode, elem);\n-        updateAttributes(newNode, elem);\n-        if (newNode.getValue() != null) {\n-            final String txt = String.valueOf(this.listDelimiterHandler.escape(newNode.getValue(), ListDelimiterHandler.NOOP_TRANSFORMER));\n-            elem.appendChild(this.document.createTextNode(txt));\n+        final Element element = this.document.createElement(immutableNode.getNodeName());\n+        this.newElements.put(immutableNode, element);\n+        updateAttributes(immutableNode, element);\n+        if (immutableNode.getValue() != null) {\n+            element.appendChild(this.document.createTextNode(String.valueOf(this.listDelimiterHandler.escape(immutableNode.getValue(), ListDelimiterHandler.NOOP_TRANSFORMER))));\n         }\n-        if (sibling2 == null) {\n-            this.getElement(parent, refHandler).appendChild(elem);\n+        if (immutableNode4 == null) {\n+            this.getElement(immutableNode2, referenceNodeHandler).appendChild(element);\n         }\n-        else if (sibling1 != null) {\n-            this.getElement(parent, refHandler).insertBefore(elem, this.getElement(sibling1, refHandler).getNextSibling());\n+        else if (immutableNode3 != null) {\n+            this.getElement(immutableNode2, referenceNodeHandler).insertBefore(element, this.getElement(immutableNode3, referenceNodeHandler).getNextSibling());\n         }\n         else {\n-            this.getElement(parent, refHandler).insertBefore(elem, this.getElement(parent, refHandler).getFirstChild());\n+            this.getElement(immutableNode2, referenceNodeHandler).insertBefore(element, this.getElement(immutableNode2, referenceNodeHandler).getFirstChild());\n         }\n     }\n     \n-    protected void update(final ImmutableNode node, final Object reference, final ReferenceNodeHandler refHandler) {\n-        if (XMLListReference.isListNode(node, refHandler)) {\n-            if (XMLListReference.isFirstListItem(node, refHandler)) {\n-                final String value = XMLListReference.listValue(node, refHandler, this.listDelimiterHandler);\n-                this.updateElement(node, refHandler, value);\n+    protected void update(final ImmutableNode immutableNode, final Object o, final ReferenceNodeHandler referenceNodeHandler) {\n+        if (XMLListReference.isListNode(immutableNode, referenceNodeHandler)) {\n+            if (XMLListReference.isFirstListItem(immutableNode, referenceNodeHandler)) {\n+                this.updateElement(immutableNode, referenceNodeHandler, XMLListReference.listValue(immutableNode, referenceNodeHandler, this.listDelimiterHandler));\n             }\n         }\n         else {\n-            final Object value2 = this.listDelimiterHandler.escape(refHandler.getValue((Object)node), ListDelimiterHandler.NOOP_TRANSFORMER);\n-            this.updateElement(node, refHandler, value2);\n+            this.updateElement(immutableNode, referenceNodeHandler, this.listDelimiterHandler.escape(referenceNodeHandler.getValue((Object)immutableNode), ListDelimiterHandler.NOOP_TRANSFORMER));\n         }\n     }\n     \n-    private void updateElement(final ImmutableNode node, final ReferenceNodeHandler refHandler, final Object value) {\n-        final Element element = this.getElement(node, refHandler);\n-        this.updateElement(element, value);\n-        updateAttributes(node, element);\n+    private void updateElement(final ImmutableNode immutableNode, final ReferenceNodeHandler referenceNodeHandler, final Object o) {\n+        final Element element = this.getElement(immutableNode, referenceNodeHandler);\n+        this.updateElement(element, o);\n+        updateAttributes(immutableNode, element);\n     }\n     \n-    private void updateElement(final Element element, final Object value) {\n-        Text txtNode = findTextNodeForUpdate(element);\n-        if (value == null) {\n-            if (txtNode != null) {\n-                element.removeChild(txtNode);\n+    private void updateElement(final Element element, final Object obj) {\n+        final Text textNodeForUpdate = findTextNodeForUpdate(element);\n+        if (obj == null) {\n+            if (textNodeForUpdate != null) {\n+                element.removeChild(textNodeForUpdate);\n             }\n         }\n         else {\n-            final String newValue = String.valueOf(value);\n-            if (txtNode == null) {\n-                txtNode = this.document.createTextNode(newValue);\n+            final String value = String.valueOf(obj);\n+            if (textNodeForUpdate == null) {\n+                final Text textNode = this.document.createTextNode(value);\n                 if (element.getFirstChild() != null) {\n-                    element.insertBefore(txtNode, element.getFirstChild());\n+                    element.insertBefore(textNode, element.getFirstChild());\n                 }\n                 else {\n-                    element.appendChild(txtNode);\n+                    element.appendChild(textNode);\n                 }\n             }\n             else {\n-                txtNode.setNodeValue(newValue);\n+                textNodeForUpdate.setNodeValue(value);\n             }\n         }\n     }\n     \n     private void removeReference(final Element element) {\n-        final Node parentElem = element.getParentNode();\n-        if (parentElem != null) {\n-            parentElem.removeChild(element);\n+        final Node parentNode = element.getParentNode();\n+        if (parentNode != null) {\n+            parentNode.removeChild(element);\n         }\n     }\n     \n-    private Element getElement(final ImmutableNode node, final ReferenceNodeHandler refHandler) {\n-        final Element elementNew = (Element)this.newElements.get(node);\n-        if (elementNew != null) {\n-            return elementNew;\n+    private Element getElement(final ImmutableNode immutableNode, final ReferenceNodeHandler referenceNodeHandler) {\n+        final Element element = (Element)this.newElements.get(immutableNode);\n+        if (element != null) {\n+            return element;\n         }\n-        final Object reference = refHandler.getReference(node);\n-        Node element;\n+        final Object reference = referenceNodeHandler.getReference(immutableNode);\n+        Node node;\n         if (reference instanceof XMLDocumentHelper) {\n-            element = ((XMLDocumentHelper)reference).getDocument().getDocumentElement();\n+            node = ((XMLDocumentHelper)reference).getDocument().getDocumentElement();\n         }\n         else if (reference instanceof XMLListReference) {\n-            element = ((XMLListReference)reference).getElement();\n+            node = ((XMLListReference)reference).getElement();\n         }\n         else {\n-            element = (Node)reference;\n+            node = (Node)reference;\n         }\n-        return (element != null) ? ((Element)this.elementMapping.get(element)) : this.document.getDocumentElement();\n+        return (node != null) ? ((Element)this.elementMapping.get(node)) : this.document.getDocumentElement();\n     }\n     \n-    private static void updateAttributes(final ImmutableNode node, final Element elem) {\n-        if (node != null && elem != null) {\n-            clearAttributes(elem);\n-            for (final Map.Entry<String, Object> e : node.getAttributes().entrySet()) {\n-                if (e.getValue() != null) {\n-                    elem.setAttribute(e.getKey(), e.getValue().toString());\n+    private static void updateAttributes(final ImmutableNode immutableNode, final Element element) {\n+        if (immutableNode != null && element != null) {\n+            clearAttributes(element);\n+            for (final Map.Entry entry : immutableNode.getAttributes().entrySet()) {\n+                if (entry.getValue() != null) {\n+                    element.setAttribute((String)entry.getKey(), entry.getValue().toString());\n                 }\n             }\n         }\n     }\n     \n-    private static void clearAttributes(final Element elem) {\n-        final NamedNodeMap attributes = elem.getAttributes();\n+    private static void clearAttributes(final Element element) {\n+        final NamedNodeMap attributes = element.getAttributes();\n         for (int i = 0; i < attributes.getLength(); ++i) {\n-            elem.removeAttribute(attributes.item(i).getNodeName());\n+            element.removeAttribute(attributes.item(i).getNodeName());\n         }\n     }\n     \n-    private static Text findTextNodeForUpdate(final Element elem) {\n-        Text result = null;\n-        final NodeList children = elem.getChildNodes();\n-        final Collection<Node> textNodes = new ArrayList<Node>();\n-        for (int i = 0; i < children.getLength(); ++i) {\n-            final Node nd = children.item(i);\n-            if (nd instanceof Text) {\n-                if (result == null) {\n-                    result = (Text)nd;\n+    private static Text findTextNodeForUpdate(final Element element) {\n+        Object o = null;\n+        final NodeList childNodes = element.getChildNodes();\n+        final ArrayList list = new ArrayList();\n+        for (int i = 0; i < childNodes.getLength(); ++i) {\n+            final Node item = childNodes.item(i);\n+            if (item instanceof Text) {\n+                if (o == null) {\n+                    o = item;\n                 }\n                 else {\n-                    textNodes.add(nd);\n+                    list.add(item);\n                 }\n             }\n         }\n-        if (result instanceof CDATASection) {\n-            textNodes.add(result);\n-            result = null;\n+        if (o instanceof CDATASection) {\n+            list.add(o);\n+            o = null;\n+        }\n+        final Iterator iterator = list.iterator();\n+        while (iterator.hasNext()) {\n+            element.removeChild((Node)iterator.next());\n         }\n-        for (final Node tn : textNodes) {\n-            elem.removeChild(tn);\n-        }\n-        return result;\n+        return (Text)o;\n     }\n }\n"}]}
