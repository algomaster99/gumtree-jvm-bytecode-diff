{"diffoscope-json-version": 1, "source1": "first/BcBands.class", "source2": "second/BcBands.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -48,20 +48,20 @@\n     private int[][] bcEscByte;\n     private List<Integer> wideByteCodes;\n     \n     public BcBands(final Segment segment) {\n         super(segment);\n     }\n     \n-    private boolean endsWithLoad(final int codePacked) {\n-        return codePacked >= 21 && codePacked <= 25;\n+    private boolean endsWithLoad(final int n) {\n+        return n >= 21 && n <= 25;\n     }\n     \n-    private boolean endsWithStore(final int codePacked) {\n-        return codePacked >= 54 && codePacked <= 58;\n+    private boolean endsWithStore(final int n) {\n+        return n >= 54 && n <= 58;\n     }\n     \n     public int[] getBcByte() {\n         return this.bcByte;\n     }\n     \n     public int[] getBcCaseCount() {\n@@ -140,365 +140,363 @@\n         return this.bcThisMethod;\n     }\n     \n     public byte[][][] getMethodByteCodePacked() {\n         return this.methodByteCodePacked;\n     }\n     \n-    public void read(final InputStream in) throws IOException, Pack200Exception {\n+    public void read(final InputStream inputStream) throws IOException, Pack200Exception {\n         final AttributeLayoutMap attributeDefinitionMap = this.segment.getAttrDefinitionBands().getAttributeDefinitionMap();\n         final int classCount = this.header.getClassCount();\n         final long[][] methodFlags = this.segment.getClassBands().getMethodFlags();\n-        int bcCaseCountCount = 0;\n-        int bcByteCount = 0;\n-        int bcShortCount = 0;\n-        int bcLocalCount = 0;\n-        int bcLabelCount = 0;\n-        int bcIntRefCount = 0;\n-        int bcFloatRefCount = 0;\n-        int bcLongRefCount = 0;\n-        int bcDoubleRefCount = 0;\n-        int bcStringRefCount = 0;\n-        int bcClassRefCount = 0;\n-        int bcFieldRefCount = 0;\n-        int bcMethodRefCount = 0;\n-        int bcIMethodRefCount = 0;\n-        int bcThisFieldCount = 0;\n-        int bcSuperFieldCount = 0;\n-        int bcThisMethodCount = 0;\n-        int bcSuperMethodCount = 0;\n-        int bcInitRefCount = 0;\n-        int bcEscCount = 0;\n-        int bcEscRefCount = 0;\n-        final AttributeLayout abstractModifier = attributeDefinitionMap.getAttributeLayout(\"ACC_ABSTRACT\", 2);\n-        final AttributeLayout nativeModifier = attributeDefinitionMap.getAttributeLayout(\"ACC_NATIVE\", 2);\n+        int n = 0;\n+        int n2 = 0;\n+        int n3 = 0;\n+        int n4 = 0;\n+        int n5 = 0;\n+        int n6 = 0;\n+        int n7 = 0;\n+        int n8 = 0;\n+        int n9 = 0;\n+        int n10 = 0;\n+        int n11 = 0;\n+        int n12 = 0;\n+        int n13 = 0;\n+        int n14 = 0;\n+        int n15 = 0;\n+        int n16 = 0;\n+        int n17 = 0;\n+        int n18 = 0;\n+        int n19 = 0;\n+        int n20 = 0;\n+        int n21 = 0;\n+        final AttributeLayout attributeLayout = attributeDefinitionMap.getAttributeLayout(\"ACC_ABSTRACT\", 2);\n+        final AttributeLayout attributeLayout2 = attributeDefinitionMap.getAttributeLayout(\"ACC_NATIVE\", 2);\n         this.methodByteCodePacked = new byte[classCount][][];\n-        int bcParsed = 0;\n-        final List<Boolean> switchIsTableSwitch = new ArrayList<Boolean>();\n+        int n22 = 0;\n+        final ArrayList list = new ArrayList();\n         this.wideByteCodes = new ArrayList<Integer>();\n-        for (int c = 0; c < classCount; ++c) {\n-            final int numberOfMethods = methodFlags[c].length;\n-            this.methodByteCodePacked[c] = new byte[numberOfMethods][];\n-            for (int m = 0; m < numberOfMethods; ++m) {\n-                final long methodFlag = methodFlags[c][m];\n-                if (!abstractModifier.matches(methodFlag) && !nativeModifier.matches(methodFlag)) {\n-                    final ByteArrayOutputStream codeBytes = new ByteArrayOutputStream();\n-                    byte code;\n-                    while ((code = (byte)(0xFF & in.read())) != -1) {\n-                        codeBytes.write(code);\n+        for (int i = 0; i < classCount; ++i) {\n+            final int length = methodFlags[i].length;\n+            this.methodByteCodePacked[i] = new byte[length][];\n+            for (int j = 0; j < length; ++j) {\n+                final long n23 = methodFlags[i][j];\n+                if (!attributeLayout.matches(n23) && !attributeLayout2.matches(n23)) {\n+                    final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+                    byte b;\n+                    while ((b = (byte)(0xFF & inputStream.read())) != -1) {\n+                        byteArrayOutputStream.write(b);\n                     }\n-                    this.methodByteCodePacked[c][m] = codeBytes.toByteArray();\n-                    bcParsed += this.methodByteCodePacked[c][m].length;\n-                    final int[] codes = new int[this.methodByteCodePacked[c][m].length];\n-                    for (int i = 0; i < codes.length; ++i) {\n-                        codes[i] = (this.methodByteCodePacked[c][m][i] & 0xFF);\n+                    this.methodByteCodePacked[i][j] = byteArrayOutputStream.toByteArray();\n+                    n22 += this.methodByteCodePacked[i][j].length;\n+                    final int[] array = new int[this.methodByteCodePacked[i][j].length];\n+                    for (int k = 0; k < array.length; ++k) {\n+                        array[k] = (this.methodByteCodePacked[i][j][k] & 0xFF);\n                     }\n-                    for (int i = 0; i < this.methodByteCodePacked[c][m].length; ++i) {\n-                        final int codePacked = 0xFF & this.methodByteCodePacked[c][m][i];\n-                        switch (codePacked) {\n+                    for (int l = 0; l < this.methodByteCodePacked[i][j].length; ++l) {\n+                        final int n24 = 0xFF & this.methodByteCodePacked[i][j][l];\n+                        switch (n24) {\n                             case 16:\n                             case 188: {\n-                                ++bcByteCount;\n+                                ++n2;\n                                 break;\n                             }\n                             case 17: {\n-                                ++bcShortCount;\n+                                ++n3;\n                                 break;\n                             }\n                             case 18:\n                             case 19: {\n-                                ++bcStringRefCount;\n+                                ++n10;\n                                 break;\n                             }\n                             case 234:\n                             case 237: {\n-                                ++bcIntRefCount;\n+                                ++n6;\n                                 break;\n                             }\n                             case 235:\n                             case 238: {\n-                                ++bcFloatRefCount;\n+                                ++n7;\n                                 break;\n                             }\n                             case 197: {\n-                                ++bcByteCount;\n+                                ++n2;\n                             }\n                             case 187:\n                             case 189:\n                             case 192:\n                             case 193:\n                             case 233:\n                             case 236: {\n-                                ++bcClassRefCount;\n+                                ++n11;\n                                 break;\n                             }\n                             case 20: {\n-                                ++bcLongRefCount;\n+                                ++n8;\n                                 break;\n                             }\n                             case 239: {\n-                                ++bcDoubleRefCount;\n+                                ++n9;\n                                 break;\n                             }\n                             case 169: {\n-                                ++bcLocalCount;\n+                                ++n4;\n                                 break;\n                             }\n                             case 167:\n                             case 168:\n                             case 200:\n                             case 201: {\n-                                ++bcLabelCount;\n+                                ++n5;\n                                 break;\n                             }\n                             case 170: {\n-                                switchIsTableSwitch.add(Boolean.TRUE);\n-                                ++bcCaseCountCount;\n-                                ++bcLabelCount;\n+                                list.add(Boolean.TRUE);\n+                                ++n;\n+                                ++n5;\n                                 break;\n                             }\n                             case 171: {\n-                                switchIsTableSwitch.add(Boolean.FALSE);\n-                                ++bcCaseCountCount;\n-                                ++bcLabelCount;\n+                                list.add(Boolean.FALSE);\n+                                ++n;\n+                                ++n5;\n                                 break;\n                             }\n                             case 178:\n                             case 179:\n                             case 180:\n                             case 181: {\n-                                ++bcFieldRefCount;\n+                                ++n12;\n                                 break;\n                             }\n                             case 182:\n                             case 183:\n                             case 184: {\n-                                ++bcMethodRefCount;\n+                                ++n13;\n                                 break;\n                             }\n                             case 185: {\n-                                ++bcIMethodRefCount;\n+                                ++n14;\n                                 break;\n                             }\n                             case 202:\n                             case 203:\n                             case 204:\n                             case 205:\n                             case 209:\n                             case 210:\n                             case 211:\n                             case 212: {\n-                                ++bcThisFieldCount;\n+                                ++n15;\n                                 break;\n                             }\n                             case 206:\n                             case 207:\n                             case 208:\n                             case 213:\n                             case 214:\n                             case 215: {\n-                                ++bcThisMethodCount;\n+                                ++n17;\n                                 break;\n                             }\n                             case 216:\n                             case 217:\n                             case 218:\n                             case 219:\n                             case 223:\n                             case 224:\n                             case 225:\n                             case 226: {\n-                                ++bcSuperFieldCount;\n+                                ++n16;\n                                 break;\n                             }\n                             case 220:\n                             case 221:\n                             case 222:\n                             case 227:\n                             case 228:\n                             case 229: {\n-                                ++bcSuperMethodCount;\n+                                ++n18;\n                                 break;\n                             }\n                             case 132: {\n-                                ++bcLocalCount;\n-                                ++bcByteCount;\n+                                ++n4;\n+                                ++n2;\n                                 break;\n                             }\n                             case 196: {\n-                                final int nextInstruction = 0xFF & this.methodByteCodePacked[c][m][i + 1];\n-                                this.wideByteCodes.add(Integer.valueOf(nextInstruction));\n-                                if (nextInstruction == 132) {\n-                                    ++bcLocalCount;\n-                                    ++bcShortCount;\n+                                final int m = 0xFF & this.methodByteCodePacked[i][j][l + 1];\n+                                this.wideByteCodes.add(Integer.valueOf(m));\n+                                if (m == 132) {\n+                                    ++n4;\n+                                    ++n3;\n                                 }\n-                                else if (this.endsWithLoad(nextInstruction) || this.endsWithStore(nextInstruction) || nextInstruction == 169) {\n-                                    ++bcLocalCount;\n+                                else if (this.endsWithLoad(m) || this.endsWithStore(m) || m == 169) {\n+                                    ++n4;\n                                 }\n                                 else {\n-                                    this.segment.log(2, \"Found unhandled \" + ByteCode.getByteCode(nextInstruction));\n+                                    this.segment.log(2, \"Found unhandled \" + ByteCode.getByteCode(m));\n                                 }\n-                                ++i;\n+                                ++l;\n                                 break;\n                             }\n                             case 230:\n                             case 231:\n                             case 232: {\n-                                ++bcInitRefCount;\n+                                ++n19;\n                                 break;\n                             }\n                             case 253: {\n-                                ++bcEscRefCount;\n+                                ++n21;\n                                 break;\n                             }\n                             case 254: {\n-                                ++bcEscCount;\n+                                ++n20;\n                                 break;\n                             }\n                             default: {\n-                                if (this.endsWithLoad(codePacked) || this.endsWithStore(codePacked)) {\n-                                    ++bcLocalCount;\n+                                if (this.endsWithLoad(n24) || this.endsWithStore(n24)) {\n+                                    ++n4;\n                                     break;\n                                 }\n-                                if (this.startsWithIf(codePacked)) {\n-                                    ++bcLabelCount;\n+                                if (this.startsWithIf(n24)) {\n+                                    ++n5;\n                                     break;\n                                 }\n                                 break;\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n-        this.bcCaseCount = this.decodeBandInt(\"bc_case_count\", in, Codec.UNSIGNED5, bcCaseCountCount);\n-        int bcCaseValueCount = 0;\n-        for (int j = 0; j < this.bcCaseCount.length; ++j) {\n-            final boolean isTableSwitch = (boolean)Boolean.valueOf(switchIsTableSwitch.get(j));\n-            if (isTableSwitch) {\n-                ++bcCaseValueCount;\n+        this.bcCaseCount = this.decodeBandInt(\"bc_case_count\", inputStream, Codec.UNSIGNED5, n);\n+        int n25 = 0;\n+        for (int n26 = 0; n26 < this.bcCaseCount.length; ++n26) {\n+            if ((boolean)list.get(n26)) {\n+                ++n25;\n             }\n             else {\n-                bcCaseValueCount += this.bcCaseCount[j];\n+                n25 += this.bcCaseCount[n26];\n             }\n         }\n-        this.bcCaseValue = this.decodeBandInt(\"bc_case_value\", in, Codec.DELTA5, bcCaseValueCount);\n-        for (int index = 0; index < bcCaseCountCount; ++index) {\n-            bcLabelCount += this.bcCaseCount[index];\n+        this.bcCaseValue = this.decodeBandInt(\"bc_case_value\", inputStream, Codec.DELTA5, n25);\n+        for (int n27 = 0; n27 < n; ++n27) {\n+            n5 += this.bcCaseCount[n27];\n         }\n-        this.bcByte = this.decodeBandInt(\"bc_byte\", in, Codec.BYTE1, bcByteCount);\n-        this.bcShort = this.decodeBandInt(\"bc_short\", in, Codec.DELTA5, bcShortCount);\n-        this.bcLocal = this.decodeBandInt(\"bc_local\", in, Codec.UNSIGNED5, bcLocalCount);\n-        this.bcLabel = this.decodeBandInt(\"bc_label\", in, Codec.BRANCH5, bcLabelCount);\n-        this.bcIntRef = this.decodeBandInt(\"bc_intref\", in, Codec.DELTA5, bcIntRefCount);\n-        this.bcFloatRef = this.decodeBandInt(\"bc_floatref\", in, Codec.DELTA5, bcFloatRefCount);\n-        this.bcLongRef = this.decodeBandInt(\"bc_longref\", in, Codec.DELTA5, bcLongRefCount);\n-        this.bcDoubleRef = this.decodeBandInt(\"bc_doubleref\", in, Codec.DELTA5, bcDoubleRefCount);\n-        this.bcStringRef = this.decodeBandInt(\"bc_stringref\", in, Codec.DELTA5, bcStringRefCount);\n-        this.bcClassRef = this.decodeBandInt(\"bc_classref\", in, Codec.UNSIGNED5, bcClassRefCount);\n-        this.bcFieldRef = this.decodeBandInt(\"bc_fieldref\", in, Codec.DELTA5, bcFieldRefCount);\n-        this.bcMethodRef = this.decodeBandInt(\"bc_methodref\", in, Codec.UNSIGNED5, bcMethodRefCount);\n-        this.bcIMethodRef = this.decodeBandInt(\"bc_imethodref\", in, Codec.DELTA5, bcIMethodRefCount);\n-        this.bcThisField = this.decodeBandInt(\"bc_thisfield\", in, Codec.UNSIGNED5, bcThisFieldCount);\n-        this.bcSuperField = this.decodeBandInt(\"bc_superfield\", in, Codec.UNSIGNED5, bcSuperFieldCount);\n-        this.bcThisMethod = this.decodeBandInt(\"bc_thismethod\", in, Codec.UNSIGNED5, bcThisMethodCount);\n-        this.bcSuperMethod = this.decodeBandInt(\"bc_supermethod\", in, Codec.UNSIGNED5, bcSuperMethodCount);\n-        this.bcInitRef = this.decodeBandInt(\"bc_initref\", in, Codec.UNSIGNED5, bcInitRefCount);\n-        this.bcEscRef = this.decodeBandInt(\"bc_escref\", in, Codec.UNSIGNED5, bcEscRefCount);\n-        this.bcEscRefSize = this.decodeBandInt(\"bc_escrefsize\", in, Codec.UNSIGNED5, bcEscRefCount);\n-        this.bcEscSize = this.decodeBandInt(\"bc_escsize\", in, Codec.UNSIGNED5, bcEscCount);\n-        this.bcEscByte = this.decodeBandInt(\"bc_escbyte\", in, Codec.BYTE1, this.bcEscSize);\n+        this.bcByte = this.decodeBandInt(\"bc_byte\", inputStream, Codec.BYTE1, n2);\n+        this.bcShort = this.decodeBandInt(\"bc_short\", inputStream, Codec.DELTA5, n3);\n+        this.bcLocal = this.decodeBandInt(\"bc_local\", inputStream, Codec.UNSIGNED5, n4);\n+        this.bcLabel = this.decodeBandInt(\"bc_label\", inputStream, Codec.BRANCH5, n5);\n+        this.bcIntRef = this.decodeBandInt(\"bc_intref\", inputStream, Codec.DELTA5, n6);\n+        this.bcFloatRef = this.decodeBandInt(\"bc_floatref\", inputStream, Codec.DELTA5, n7);\n+        this.bcLongRef = this.decodeBandInt(\"bc_longref\", inputStream, Codec.DELTA5, n8);\n+        this.bcDoubleRef = this.decodeBandInt(\"bc_doubleref\", inputStream, Codec.DELTA5, n9);\n+        this.bcStringRef = this.decodeBandInt(\"bc_stringref\", inputStream, Codec.DELTA5, n10);\n+        this.bcClassRef = this.decodeBandInt(\"bc_classref\", inputStream, Codec.UNSIGNED5, n11);\n+        this.bcFieldRef = this.decodeBandInt(\"bc_fieldref\", inputStream, Codec.DELTA5, n12);\n+        this.bcMethodRef = this.decodeBandInt(\"bc_methodref\", inputStream, Codec.UNSIGNED5, n13);\n+        this.bcIMethodRef = this.decodeBandInt(\"bc_imethodref\", inputStream, Codec.DELTA5, n14);\n+        this.bcThisField = this.decodeBandInt(\"bc_thisfield\", inputStream, Codec.UNSIGNED5, n15);\n+        this.bcSuperField = this.decodeBandInt(\"bc_superfield\", inputStream, Codec.UNSIGNED5, n16);\n+        this.bcThisMethod = this.decodeBandInt(\"bc_thismethod\", inputStream, Codec.UNSIGNED5, n17);\n+        this.bcSuperMethod = this.decodeBandInt(\"bc_supermethod\", inputStream, Codec.UNSIGNED5, n18);\n+        this.bcInitRef = this.decodeBandInt(\"bc_initref\", inputStream, Codec.UNSIGNED5, n19);\n+        this.bcEscRef = this.decodeBandInt(\"bc_escref\", inputStream, Codec.UNSIGNED5, n21);\n+        this.bcEscRefSize = this.decodeBandInt(\"bc_escrefsize\", inputStream, Codec.UNSIGNED5, n21);\n+        this.bcEscSize = this.decodeBandInt(\"bc_escsize\", inputStream, Codec.UNSIGNED5, n20);\n+        this.bcEscByte = this.decodeBandInt(\"bc_escbyte\", inputStream, Codec.BYTE1, this.bcEscSize);\n     }\n     \n-    private boolean startsWithIf(final int codePacked) {\n-        return (codePacked >= 153 && codePacked <= 166) || codePacked == 198 || codePacked == 199;\n+    private boolean startsWithIf(final int n) {\n+        return (n >= 153 && n <= 166) || n == 198 || n == 199;\n     }\n     \n     public void unpack() throws Pack200Exception {\n         final int classCount = this.header.getClassCount();\n         final long[][] methodFlags = this.segment.getClassBands().getMethodFlags();\n         final int[] codeMaxNALocals = this.segment.getClassBands().getCodeMaxNALocals();\n         final int[] codeMaxStack = this.segment.getClassBands().getCodeMaxStack();\n-        final ArrayList<Attribute>[][] methodAttributes = this.segment.getClassBands().getMethodAttributes();\n+        final ArrayList[][] methodAttributes = this.segment.getClassBands().getMethodAttributes();\n         final String[][] methodDescr = this.segment.getClassBands().getMethodDescr();\n         final AttributeLayoutMap attributeDefinitionMap = this.segment.getAttrDefinitionBands().getAttributeDefinitionMap();\n-        final AttributeLayout abstractModifier = attributeDefinitionMap.getAttributeLayout(\"ACC_ABSTRACT\", 2);\n-        final AttributeLayout nativeModifier = attributeDefinitionMap.getAttributeLayout(\"ACC_NATIVE\", 2);\n-        final AttributeLayout staticModifier = attributeDefinitionMap.getAttributeLayout(\"ACC_STATIC\", 2);\n-        final int[] wideByteCodeArray = new int[this.wideByteCodes.size()];\n-        for (int index = 0; index < wideByteCodeArray.length; ++index) {\n-            wideByteCodeArray[index] = Integer.valueOf(this.wideByteCodes.get(index));\n+        final AttributeLayout attributeLayout = attributeDefinitionMap.getAttributeLayout(\"ACC_ABSTRACT\", 2);\n+        final AttributeLayout attributeLayout2 = attributeDefinitionMap.getAttributeLayout(\"ACC_NATIVE\", 2);\n+        final AttributeLayout attributeLayout3 = attributeDefinitionMap.getAttributeLayout(\"ACC_STATIC\", 2);\n+        final int[] array = new int[this.wideByteCodes.size()];\n+        for (int i = 0; i < array.length; ++i) {\n+            array[i] = Integer.valueOf(this.wideByteCodes.get(i));\n         }\n-        final OperandManager operandManager = new OperandManager(this.bcCaseCount, this.bcCaseValue, this.bcByte, this.bcShort, this.bcLocal, this.bcLabel, this.bcIntRef, this.bcFloatRef, this.bcLongRef, this.bcDoubleRef, this.bcStringRef, this.bcClassRef, this.bcFieldRef, this.bcMethodRef, this.bcIMethodRef, this.bcThisField, this.bcSuperField, this.bcThisMethod, this.bcSuperMethod, this.bcInitRef, wideByteCodeArray);\n+        final OperandManager operandManager = new OperandManager(this.bcCaseCount, this.bcCaseValue, this.bcByte, this.bcShort, this.bcLocal, this.bcLabel, this.bcIntRef, this.bcFloatRef, this.bcLongRef, this.bcDoubleRef, this.bcStringRef, this.bcClassRef, this.bcFieldRef, this.bcMethodRef, this.bcIMethodRef, this.bcThisField, this.bcSuperField, this.bcThisMethod, this.bcSuperMethod, this.bcInitRef, array);\n         operandManager.setSegment(this.segment);\n-        int i = 0;\n-        final ArrayList<List<Attribute>> orderedCodeAttributes = this.segment.getClassBands().getOrderedCodeAttributes();\n-        int codeAttributeIndex = 0;\n-        final int[] handlerCount = this.segment.getClassBands().getCodeHandlerCount();\n-        final int[][] handlerStartPCs = this.segment.getClassBands().getCodeHandlerStartP();\n-        final int[][] handlerEndPCs = this.segment.getClassBands().getCodeHandlerEndPO();\n-        final int[][] handlerCatchPCs = this.segment.getClassBands().getCodeHandlerCatchPO();\n-        final int[][] handlerClassTypes = this.segment.getClassBands().getCodeHandlerClassRCN();\n-        final boolean allCodeHasFlags = this.segment.getSegmentHeader().getOptions().hasAllCodeFlags();\n-        final boolean[] codeHasFlags = this.segment.getClassBands().getCodeHasAttributes();\n-        for (int c = 0; c < classCount; ++c) {\n-            for (int numberOfMethods = methodFlags[c].length, m = 0; m < numberOfMethods; ++m) {\n-                final long methodFlag = methodFlags[c][m];\n-                if (!abstractModifier.matches(methodFlag) && !nativeModifier.matches(methodFlag)) {\n-                    final int maxStack = codeMaxStack[i];\n-                    int maxLocal = codeMaxNALocals[i];\n-                    if (!staticModifier.matches(methodFlag)) {\n-                        ++maxLocal;\n+        int index = 0;\n+        final ArrayList orderedCodeAttributes = this.segment.getClassBands().getOrderedCodeAttributes();\n+        int index2 = 0;\n+        final int[] codeHandlerCount = this.segment.getClassBands().getCodeHandlerCount();\n+        final int[][] codeHandlerStartP = this.segment.getClassBands().getCodeHandlerStartP();\n+        final int[][] codeHandlerEndPO = this.segment.getClassBands().getCodeHandlerEndPO();\n+        final int[][] codeHandlerCatchPO = this.segment.getClassBands().getCodeHandlerCatchPO();\n+        final int[][] codeHandlerClassRCN = this.segment.getClassBands().getCodeHandlerClassRCN();\n+        final boolean hasAllCodeFlags = this.segment.getSegmentHeader().getOptions().hasAllCodeFlags();\n+        final boolean[] codeHasAttributes = this.segment.getClassBands().getCodeHasAttributes();\n+        for (int j = 0; j < classCount; ++j) {\n+            for (int length = methodFlags[j].length, k = 0; k < length; ++k) {\n+                final long n = methodFlags[j][k];\n+                if (!attributeLayout.matches(n) && !attributeLayout2.matches(n)) {\n+                    final int n2 = codeMaxStack[index];\n+                    int n3 = codeMaxNALocals[index];\n+                    if (!attributeLayout3.matches(n)) {\n+                        ++n3;\n                     }\n-                    maxLocal += SegmentUtils.countInvokeInterfaceArgs(methodDescr[c][m]);\n+                    final int n4 = n3 + SegmentUtils.countInvokeInterfaceArgs(methodDescr[j][k]);\n                     final String[] cpClass = this.segment.getCpBands().getCpClass();\n-                    operandManager.setCurrentClass(cpClass[this.segment.getClassBands().getClassThisInts()[c]]);\n-                    operandManager.setSuperClass(cpClass[this.segment.getClassBands().getClassSuperInts()[c]]);\n-                    final List<ExceptionTableEntry> exceptionTable = new ArrayList<ExceptionTableEntry>();\n-                    if (handlerCount != null) {\n-                        for (int j = 0; j < handlerCount[i]; ++j) {\n-                            final int handlerClass = handlerClassTypes[i][j] - 1;\n-                            CPClass cpHandlerClass = null;\n-                            if (handlerClass != -1) {\n-                                cpHandlerClass = this.segment.getCpBands().cpClassValue(handlerClass);\n+                    operandManager.setCurrentClass(cpClass[this.segment.getClassBands().getClassThisInts()[j]]);\n+                    operandManager.setSuperClass(cpClass[this.segment.getClassBands().getClassSuperInts()[j]]);\n+                    final ArrayList list = new ArrayList();\n+                    if (codeHandlerCount != null) {\n+                        for (int l = 0; l < codeHandlerCount[index]; ++l) {\n+                            final int n5 = codeHandlerClassRCN[index][l] - 1;\n+                            CPClass cpClassValue = null;\n+                            if (n5 != -1) {\n+                                cpClassValue = this.segment.getCpBands().cpClassValue(n5);\n                             }\n-                            final ExceptionTableEntry entry = new ExceptionTableEntry(handlerStartPCs[i][j], handlerEndPCs[i][j], handlerCatchPCs[i][j], cpHandlerClass);\n-                            exceptionTable.add(entry);\n+                            list.add(new ExceptionTableEntry(codeHandlerStartP[index][l], codeHandlerEndPO[index][l], codeHandlerCatchPO[index][l], cpClassValue));\n                         }\n                     }\n-                    final CodeAttribute codeAttr = new CodeAttribute(maxStack, maxLocal, this.methodByteCodePacked[c][m], this.segment, operandManager, (List)exceptionTable);\n-                    final List<Attribute> methodAttributesList = methodAttributes[c][m];\n-                    int indexForCodeAttr = 0;\n-                    for (final Attribute attribute : methodAttributesList) {\n+                    final CodeAttribute codeAttribute = new CodeAttribute(n2, n4, this.methodByteCodePacked[j][k], this.segment, operandManager, (List)list);\n+                    final ArrayList list2 = methodAttributes[j][k];\n+                    int n6 = 0;\n+                    for (final Attribute attribute : list2) {\n                         if (!(attribute instanceof NewAttribute)) {\n                             break;\n                         }\n                         if (((NewAttribute)attribute).getLayoutIndex() >= 15) {\n                             break;\n                         }\n-                        ++indexForCodeAttr;\n+                        ++n6;\n                     }\n-                    methodAttributesList.add(indexForCodeAttr, (Attribute)codeAttr);\n-                    codeAttr.renumber(codeAttr.byteCodeOffsets);\n-                    List<Attribute> currentAttributes;\n-                    if (allCodeHasFlags) {\n-                        currentAttributes = orderedCodeAttributes.get(i);\n+                    list2.add(n6, codeAttribute);\n+                    codeAttribute.renumber(codeAttribute.byteCodeOffsets);\n+                    List empty_LIST;\n+                    if (hasAllCodeFlags) {\n+                        empty_LIST = orderedCodeAttributes.get(index);\n                     }\n-                    else if (codeHasFlags[i]) {\n-                        currentAttributes = orderedCodeAttributes.get(codeAttributeIndex);\n-                        ++codeAttributeIndex;\n+                    else if (codeHasAttributes[index]) {\n+                        empty_LIST = orderedCodeAttributes.get(index2);\n+                        ++index2;\n                     }\n                     else {\n-                        currentAttributes = Collections.EMPTY_LIST;\n+                        empty_LIST = Collections.EMPTY_LIST;\n                     }\n-                    for (final Attribute currentAttribute : currentAttributes) {\n-                        codeAttr.addAttribute(currentAttribute);\n-                        if (currentAttribute.hasBCIRenumbering()) {\n-                            ((BCIRenumberedAttribute)currentAttribute).renumber(codeAttr.byteCodeOffsets);\n+                    for (final Attribute attribute2 : empty_LIST) {\n+                        codeAttribute.addAttribute(attribute2);\n+                        if (attribute2.hasBCIRenumbering()) {\n+                            ((BCIRenumberedAttribute)attribute2).renumber(codeAttribute.byteCodeOffsets);\n                         }\n                     }\n-                    ++i;\n+                    ++index;\n                 }\n             }\n         }\n     }\n }\n"}]}
