{"diffoscope-json-version": 1, "source1": "first/ZipSplitOutputStream.class", "source2": "second/ZipSplitOutputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -21,126 +21,124 @@\n     private Path zipFile;\n     private final long splitSize;\n     private int currentSplitSegmentIndex;\n     private long currentSplitSegmentBytesWritten;\n     private boolean finished;\n     private final byte[] singleByte;\n     \n-    public ZipSplitOutputStream(final File zipFile, final long splitSize) throws IllegalArgumentException, IOException {\n-        this(zipFile.toPath(), splitSize);\n+    public ZipSplitOutputStream(final File file, final long n) throws IllegalArgumentException, IOException {\n+        this(file.toPath(), n);\n     }\n     \n-    public ZipSplitOutputStream(final Path zipFile, final long splitSize) throws IllegalArgumentException, IOException {\n+    public ZipSplitOutputStream(final Path path, final long splitSize) throws IllegalArgumentException, IOException {\n         this.singleByte = new byte[1];\n         if (splitSize < 65536L || splitSize > 4294967295L) {\n             throw new IllegalArgumentException(\"Zip split segment size should between 64K and 4,294,967,295\");\n         }\n-        this.zipFile = zipFile;\n+        this.zipFile = path;\n         this.splitSize = splitSize;\n-        this.outputStream = Files.newOutputStream(zipFile, new OpenOption[0]);\n+        this.outputStream = Files.newOutputStream(path, new OpenOption[0]);\n         this.writeZipSplitSignature();\n     }\n     \n     @Override\n     public void close() throws IOException {\n         if (!this.finished) {\n             this.finish();\n         }\n     }\n     \n-    private Path createNewSplitSegmentFile(final Integer zipSplitSegmentSuffixIndex) throws IOException {\n-        final int newZipSplitSegmentSuffixIndex = (zipSplitSegmentSuffixIndex == null) ? (this.currentSplitSegmentIndex + 2) : ((int)zipSplitSegmentSuffixIndex);\n+    private Path createNewSplitSegmentFile(final Integer n) throws IOException {\n+        final int n2 = (n == null) ? (this.currentSplitSegmentIndex + 2) : ((int)n);\n         final String baseName = FileNameUtils.getBaseName(this.zipFile);\n-        String extension = \".z\";\n-        if (newZipSplitSegmentSuffixIndex <= 9) {\n-            extension = extension + \"0\" + newZipSplitSegmentSuffixIndex;\n+        final String s = \".z\";\n+        String s2;\n+        if (n2 <= 9) {\n+            s2 = s + \"0\" + n2;\n         }\n         else {\n-            extension += newZipSplitSegmentSuffixIndex;\n+            s2 = s + n2;\n         }\n         final Path parent = this.zipFile.getParent();\n-        final String dir = Objects.nonNull(parent) ? parent.toAbsolutePath().toString() : \".\";\n-        final Path newFile = this.zipFile.getFileSystem().getPath(dir, baseName + extension);\n-        if (Files.exists(newFile, new LinkOption[0])) {\n-            throw new IOException(\"split ZIP segment \" + baseName + extension + \" already exists\");\n+        final Path path = this.zipFile.getFileSystem().getPath(Objects.nonNull(parent) ? parent.toAbsolutePath().toString() : \".\", baseName + s2);\n+        if (Files.exists(path, new LinkOption[0])) {\n+            throw new IOException(\"split ZIP segment \" + baseName + s2 + \" already exists\");\n         }\n-        return newFile;\n+        return path;\n     }\n     \n     private void finish() throws IOException {\n         if (this.finished) {\n             throw new IOException(\"This archive has already been finished\");\n         }\n-        final String zipFileBaseName = FileNameUtils.getBaseName(this.zipFile);\n+        final String baseName = FileNameUtils.getBaseName(this.zipFile);\n         this.outputStream.close();\n-        Files.move(this.zipFile, this.zipFile.resolveSibling(zipFileBaseName + \".zip\"), StandardCopyOption.ATOMIC_MOVE);\n+        Files.move(this.zipFile, this.zipFile.resolveSibling(baseName + \".zip\"), StandardCopyOption.ATOMIC_MOVE);\n         this.finished = true;\n     }\n     \n     public long getCurrentSplitSegmentBytesWritten() {\n         return this.currentSplitSegmentBytesWritten;\n     }\n     \n     public int getCurrentSplitSegmentIndex() {\n         return this.currentSplitSegmentIndex;\n     }\n     \n     private void openNewSplitSegment() throws IOException {\n         if (this.currentSplitSegmentIndex == 0) {\n             this.outputStream.close();\n-            final Path newFile = this.createNewSplitSegmentFile(Integer.valueOf(1));\n-            Files.move(this.zipFile, newFile, StandardCopyOption.ATOMIC_MOVE);\n+            Files.move(this.zipFile, this.createNewSplitSegmentFile(Integer.valueOf(1)), StandardCopyOption.ATOMIC_MOVE);\n         }\n-        final Path newFile = this.createNewSplitSegmentFile(null);\n+        final Path newSplitSegmentFile = this.createNewSplitSegmentFile(null);\n         this.outputStream.close();\n-        this.outputStream = Files.newOutputStream(newFile, new OpenOption[0]);\n+        this.outputStream = Files.newOutputStream(newSplitSegmentFile, new OpenOption[0]);\n         this.currentSplitSegmentBytesWritten = 0L;\n-        this.zipFile = newFile;\n+        this.zipFile = newSplitSegmentFile;\n         ++this.currentSplitSegmentIndex;\n     }\n     \n-    public void prepareToWriteUnsplittableContent(final long unsplittableContentSize) throws IllegalArgumentException, IOException {\n-        if (unsplittableContentSize > this.splitSize) {\n+    public void prepareToWriteUnsplittableContent(final long n) throws IllegalArgumentException, IOException {\n+        if (n > this.splitSize) {\n             throw new IllegalArgumentException(\"The unsplittable content size is bigger than the split segment size\");\n         }\n-        final long bytesRemainingInThisSegment = this.splitSize - this.currentSplitSegmentBytesWritten;\n-        if (bytesRemainingInThisSegment < unsplittableContentSize) {\n+        if (this.splitSize - this.currentSplitSegmentBytesWritten < n) {\n             this.openNewSplitSegment();\n         }\n     }\n     \n     @Override\n-    public void write(final byte[] b) throws IOException {\n-        this.write(b, 0, b.length);\n+    public void write(final byte[] array) throws IOException {\n+        this.write(array, 0, array.length);\n     }\n     \n     @Override\n     public void write(final byte[] b, final int off, final int len) throws IOException {\n         if (len <= 0) {\n             return;\n         }\n         if (this.currentSplitSegmentBytesWritten >= this.splitSize) {\n             this.openNewSplitSegment();\n             this.write(b, off, len);\n         }\n         else if (this.currentSplitSegmentBytesWritten + len > this.splitSize) {\n-            final int bytesToWriteForThisSegment = (int)this.splitSize - (int)this.currentSplitSegmentBytesWritten;\n-            this.write(b, off, bytesToWriteForThisSegment);\n+            final int n = (int)this.splitSize - (int)this.currentSplitSegmentBytesWritten;\n+            this.write(b, off, n);\n             this.openNewSplitSegment();\n-            this.write(b, off + bytesToWriteForThisSegment, len - bytesToWriteForThisSegment);\n+            this.write(b, off + n, len - n);\n         }\n         else {\n             this.outputStream.write(b, off, len);\n             this.currentSplitSegmentBytesWritten += len;\n         }\n     }\n     \n     @Override\n-    public void write(final int i) throws IOException {\n-        this.singleByte[0] = (byte)(i & 0xFF);\n+    public void write(final int n) throws IOException {\n+        this.singleByte[0] = (byte)(n & 0xFF);\n         this.write(this.singleByte);\n     }\n     \n     private void writeZipSplitSignature() throws IOException {\n         this.outputStream.write(ZipArchiveOutputStream.DD_SIG);\n         this.currentSplitSegmentBytesWritten += ZipArchiveOutputStream.DD_SIG.length;\n     }\n"}]}
