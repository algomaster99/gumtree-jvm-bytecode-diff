{"diffoscope-json-version": 1, "source1": "first/LZMADecoder.class", "source2": "second/LZMADecoder.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -13,77 +13,76 @@\n \n class LZMADecoder extends CoderBase\n {\n     LZMADecoder() {\n         super(new Class[] { LZMA2Options.class, Number.class });\n     }\n     \n-    InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength, final Coder coder, final byte[] password, final int maxMemoryLimitInKb) throws IOException {\n+    InputStream decode(final String s, final InputStream inputStream, final long n, final Coder coder, final byte[] array, final int n2) throws IOException {\n         if (coder.properties == null) {\n             throw new IOException(\"Missing LZMA properties\");\n         }\n         if (coder.properties.length < 1) {\n             throw new IOException(\"LZMA properties too short\");\n         }\n-        final byte propsByte = coder.properties[0];\n-        final int dictSize = this.getDictionarySize(coder);\n-        if (dictSize > 2147483632) {\n-            throw new IOException(\"Dictionary larger than 4GiB maximum size used in \" + archiveName);\n+        final byte b = coder.properties[0];\n+        final int dictionarySize = this.getDictionarySize(coder);\n+        if (dictionarySize > 2147483632) {\n+            throw new IOException(\"Dictionary larger than 4GiB maximum size used in \" + s);\n         }\n-        final int memoryUsageInKb = LZMAInputStream.getMemoryUsage(dictSize, propsByte);\n-        if (memoryUsageInKb > maxMemoryLimitInKb) {\n-            throw new MemoryLimitException((long)memoryUsageInKb, maxMemoryLimitInKb);\n+        final int memoryUsage = LZMAInputStream.getMemoryUsage(dictionarySize, b);\n+        if (memoryUsage > n2) {\n+            throw new MemoryLimitException((long)memoryUsage, n2);\n         }\n-        return (InputStream)new LZMAInputStream(in, uncompressedLength, propsByte, dictSize);\n+        return (InputStream)new LZMAInputStream(inputStream, n, b, dictionarySize);\n     }\n     \n-    OutputStream encode(final OutputStream out, final Object opts) throws IOException {\n-        return (OutputStream)new FlushShieldFilterOutputStream((OutputStream)new LZMAOutputStream(out, this.getOptions(opts), false));\n+    OutputStream encode(final OutputStream outputStream, final Object o) throws IOException {\n+        return (OutputStream)new FlushShieldFilterOutputStream((OutputStream)new LZMAOutputStream(outputStream, this.getOptions(o), false));\n     }\n     \n-    byte[] getOptionsAsProperties(final Object opts) throws IOException {\n-        final LZMA2Options options = this.getOptions(opts);\n-        final byte props = (byte)((options.getPb() * 5 + options.getLp()) * 9 + options.getLc());\n+    byte[] getOptionsAsProperties(final Object o) throws IOException {\n+        final LZMA2Options options = this.getOptions(o);\n+        final byte b = (byte)((options.getPb() * 5 + options.getLp()) * 9 + options.getLc());\n         final int dictSize = options.getDictSize();\n-        final byte[] o = new byte[5];\n-        o[0] = props;\n-        ByteUtils.toLittleEndian(o, (long)dictSize, 1, 4);\n-        return o;\n+        final byte[] array = new byte[5];\n+        array[0] = b;\n+        ByteUtils.toLittleEndian(array, (long)dictSize, 1, 4);\n+        return array;\n     }\n     \n-    Object getOptionsFromCoder(final Coder coder, final InputStream in) throws IOException {\n+    Object getOptionsFromCoder(final Coder coder, final InputStream inputStream) throws IOException {\n         if (coder.properties == null) {\n             throw new IOException(\"Missing LZMA properties\");\n         }\n         if (coder.properties.length < 1) {\n             throw new IOException(\"LZMA properties too short\");\n         }\n-        final byte propsByte = coder.properties[0];\n-        int props = propsByte & 0xFF;\n-        final int pb = props / 45;\n-        props -= pb * 9 * 5;\n-        final int lp = props / 9;\n-        final int lc = props - lp * 9;\n-        final LZMA2Options opts = new LZMA2Options();\n-        opts.setPb(pb);\n-        opts.setLcLp(lc, lp);\n-        opts.setDictSize(this.getDictionarySize(coder));\n-        return opts;\n+        final int n = coder.properties[0] & 0xFF;\n+        final int pb = n / 45;\n+        final int n2 = n - pb * 9 * 5;\n+        final int n3 = n2 / 9;\n+        final int n4 = n2 - n3 * 9;\n+        final LZMA2Options lzma2Options = new LZMA2Options();\n+        lzma2Options.setPb(pb);\n+        lzma2Options.setLcLp(n4, n3);\n+        lzma2Options.setDictSize(this.getDictionarySize(coder));\n+        return lzma2Options;\n     }\n     \n     private int getDictionarySize(final Coder coder) throws IllegalArgumentException {\n         return (int)ByteUtils.fromLittleEndian(coder.properties, 1, 4);\n     }\n     \n-    private LZMA2Options getOptions(final Object opts) throws IOException {\n-        if (opts instanceof LZMA2Options) {\n-            return (LZMA2Options)opts;\n+    private LZMA2Options getOptions(final Object o) throws IOException {\n+        if (o instanceof LZMA2Options) {\n+            return (LZMA2Options)o;\n         }\n-        final LZMA2Options options = new LZMA2Options();\n-        options.setDictSize(this.numberOptionOrDefault(opts));\n-        return options;\n+        final LZMA2Options lzma2Options = new LZMA2Options();\n+        lzma2Options.setDictSize(this.numberOptionOrDefault(o));\n+        return lzma2Options;\n     }\n     \n-    private int numberOptionOrDefault(final Object opts) {\n-        return numberOptionOrDefault(opts, 8388608);\n+    private int numberOptionOrDefault(final Object o) {\n+        return numberOptionOrDefault(o, 8388608);\n     }\n }\n"}]}
