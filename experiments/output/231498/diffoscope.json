{"diffoscope-json-version": 1, "source1": "first/X0017_StrongEncryptionHeader.class", "source2": "second/X0017_StrongEncryptionHeader.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -20,17 +20,17 @@\n     private byte[] vData;\n     private byte[] vCRC32;\n     \n     public X0017_StrongEncryptionHeader() {\n         super(new ZipShort(23));\n     }\n     \n-    private void assertDynamicLengthFits(final String what, final int dynamicLength, final int prefixLength, final int length) throws ZipException {\n-        if (prefixLength + dynamicLength > length) {\n-            throw new ZipException(\"Invalid X0017_StrongEncryptionHeader: \" + what + \" \" + dynamicLength + \" doesn't fit into \" + length + \" bytes of data at position \" + prefixLength);\n+    private void assertDynamicLengthFits(final String str, final int i, final int j, final int k) throws ZipException {\n+        if (j + i > k) {\n+            throw new ZipException(\"Invalid X0017_StrongEncryptionHeader: \" + str + \" \" + i + \" doesn't fit into \" + k + \" bytes of data at position \" + j);\n         }\n     }\n     \n     public PKWareExtraHeader.EncryptionAlgorithm getEncryptionAlgorithm() {\n         return this.algId;\n     }\n     \n@@ -38,82 +38,82 @@\n         return this.hashAlg;\n     }\n     \n     public long getRecordCount() {\n         return this.rcount;\n     }\n     \n-    public void parseCentralDirectoryFormat(final byte[] data, final int offset, final int length) throws ZipException {\n-        this.assertMinimalLength(12, length);\n-        this.format = ZipShort.getValue(data, offset);\n-        this.algId = PKWareExtraHeader.EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2));\n-        this.bitlen = ZipShort.getValue(data, offset + 4);\n-        this.flags = ZipShort.getValue(data, offset + 6);\n-        this.rcount = ZipLong.getValue(data, offset + 8);\n+    public void parseCentralDirectoryFormat(final byte[] array, final int n, final int n2) throws ZipException {\n+        this.assertMinimalLength(12, n2);\n+        this.format = ZipShort.getValue(array, n);\n+        this.algId = PKWareExtraHeader.EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(array, n + 2));\n+        this.bitlen = ZipShort.getValue(array, n + 4);\n+        this.flags = ZipShort.getValue(array, n + 6);\n+        this.rcount = ZipLong.getValue(array, n + 8);\n         if (this.rcount > 0L) {\n-            this.assertMinimalLength(16, length);\n-            this.hashAlg = PKWareExtraHeader.HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12));\n-            this.hashSize = ZipShort.getValue(data, offset + 14);\n+            this.assertMinimalLength(16, n2);\n+            this.hashAlg = PKWareExtraHeader.HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(array, n + 12));\n+            this.hashSize = ZipShort.getValue(array, n + 14);\n         }\n     }\n     \n-    public void parseFileFormat(final byte[] data, final int offset, final int length) throws ZipException {\n-        this.assertMinimalLength(4, length);\n-        final int ivSize = ZipShort.getValue(data, offset);\n-        this.assertDynamicLengthFits(\"ivSize\", ivSize, 4, length);\n-        this.assertMinimalLength(offset + 4, ivSize);\n-        this.ivData = Arrays.copyOfRange(data, offset + 4, ivSize);\n-        this.assertMinimalLength(16 + ivSize, length);\n-        this.format = ZipShort.getValue(data, offset + ivSize + 6);\n-        this.algId = PKWareExtraHeader.EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + ivSize + 8));\n-        this.bitlen = ZipShort.getValue(data, offset + ivSize + 10);\n-        this.flags = ZipShort.getValue(data, offset + ivSize + 12);\n-        final int erdSize = ZipShort.getValue(data, offset + ivSize + 14);\n-        this.assertDynamicLengthFits(\"erdSize\", erdSize, ivSize + 16, length);\n-        this.assertMinimalLength(offset + ivSize + 16, erdSize);\n-        this.erdData = Arrays.copyOfRange(data, offset + ivSize + 16, erdSize);\n-        this.assertMinimalLength(20 + ivSize + erdSize, length);\n-        this.rcount = ZipLong.getValue(data, offset + ivSize + 16 + erdSize);\n+    public void parseFileFormat(final byte[] array, final int n, final int n2) throws ZipException {\n+        this.assertMinimalLength(4, n2);\n+        final int value = ZipShort.getValue(array, n);\n+        this.assertDynamicLengthFits(\"ivSize\", value, 4, n2);\n+        this.assertMinimalLength(n + 4, value);\n+        this.ivData = Arrays.copyOfRange(array, n + 4, value);\n+        this.assertMinimalLength(16 + value, n2);\n+        this.format = ZipShort.getValue(array, n + value + 6);\n+        this.algId = PKWareExtraHeader.EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(array, n + value + 8));\n+        this.bitlen = ZipShort.getValue(array, n + value + 10);\n+        this.flags = ZipShort.getValue(array, n + value + 12);\n+        final int value2 = ZipShort.getValue(array, n + value + 14);\n+        this.assertDynamicLengthFits(\"erdSize\", value2, value + 16, n2);\n+        this.assertMinimalLength(n + value + 16, value2);\n+        this.erdData = Arrays.copyOfRange(array, n + value + 16, value2);\n+        this.assertMinimalLength(20 + value + value2, n2);\n+        this.rcount = ZipLong.getValue(array, n + value + 16 + value2);\n         if (this.rcount == 0L) {\n-            this.assertMinimalLength(ivSize + 20 + erdSize + 2, length);\n-            final int vSize = ZipShort.getValue(data, offset + ivSize + 20 + erdSize);\n-            this.assertDynamicLengthFits(\"vSize\", vSize, ivSize + 22 + erdSize, length);\n-            if (vSize < 4) {\n-                throw new ZipException(\"Invalid X0017_StrongEncryptionHeader: vSize \" + vSize + \" is too small to hold CRC\");\n+            this.assertMinimalLength(value + 20 + value2 + 2, n2);\n+            final int value3 = ZipShort.getValue(array, n + value + 20 + value2);\n+            this.assertDynamicLengthFits(\"vSize\", value3, value + 22 + value2, n2);\n+            if (value3 < 4) {\n+                throw new ZipException(\"Invalid X0017_StrongEncryptionHeader: vSize \" + value3 + \" is too small to hold CRC\");\n             }\n-            this.assertMinimalLength(offset + ivSize + 22 + erdSize, vSize - 4);\n-            this.vData = Arrays.copyOfRange(data, offset + ivSize + 22 + erdSize, vSize - 4);\n-            this.assertMinimalLength(offset + ivSize + 22 + erdSize + vSize - 4, 4);\n-            this.vCRC32 = Arrays.copyOfRange(data, offset + ivSize + 22 + erdSize + vSize - 4, 4);\n+            this.assertMinimalLength(n + value + 22 + value2, value3 - 4);\n+            this.vData = Arrays.copyOfRange(array, n + value + 22 + value2, value3 - 4);\n+            this.assertMinimalLength(n + value + 22 + value2 + value3 - 4, 4);\n+            this.vCRC32 = Arrays.copyOfRange(array, n + value + 22 + value2 + value3 - 4, 4);\n         }\n         else {\n-            this.assertMinimalLength(ivSize + 20 + erdSize + 6, length);\n-            this.hashAlg = PKWareExtraHeader.HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + ivSize + 20 + erdSize));\n-            this.hashSize = ZipShort.getValue(data, offset + ivSize + 22 + erdSize);\n-            final int resize = ZipShort.getValue(data, offset + ivSize + 24 + erdSize);\n-            if (resize < this.hashSize) {\n-                throw new ZipException(\"Invalid X0017_StrongEncryptionHeader: resize \" + resize + \" is too small to hold hashSize\" + this.hashSize);\n+            this.assertMinimalLength(value + 20 + value2 + 6, n2);\n+            this.hashAlg = PKWareExtraHeader.HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(array, n + value + 20 + value2));\n+            this.hashSize = ZipShort.getValue(array, n + value + 22 + value2);\n+            final int value4 = ZipShort.getValue(array, n + value + 24 + value2);\n+            if (value4 < this.hashSize) {\n+                throw new ZipException(\"Invalid X0017_StrongEncryptionHeader: resize \" + value4 + \" is too small to hold hashSize\" + this.hashSize);\n             }\n-            this.assertDynamicLengthFits(\"resize\", resize, ivSize + 24 + erdSize, length);\n-            this.recipientKeyHash = Arrays.copyOfRange(data, offset + ivSize + 24 + erdSize, this.hashSize);\n-            this.keyBlob = Arrays.copyOfRange(data, offset + ivSize + 24 + erdSize + this.hashSize, resize - this.hashSize);\n-            this.assertMinimalLength(ivSize + 26 + erdSize + resize + 2, length);\n-            final int vSize2 = ZipShort.getValue(data, offset + ivSize + 26 + erdSize + resize);\n-            if (vSize2 < 4) {\n-                throw new ZipException(\"Invalid X0017_StrongEncryptionHeader: vSize \" + vSize2 + \" is too small to hold CRC\");\n+            this.assertDynamicLengthFits(\"resize\", value4, value + 24 + value2, n2);\n+            this.recipientKeyHash = Arrays.copyOfRange(array, n + value + 24 + value2, this.hashSize);\n+            this.keyBlob = Arrays.copyOfRange(array, n + value + 24 + value2 + this.hashSize, value4 - this.hashSize);\n+            this.assertMinimalLength(value + 26 + value2 + value4 + 2, n2);\n+            final int value5 = ZipShort.getValue(array, n + value + 26 + value2 + value4);\n+            if (value5 < 4) {\n+                throw new ZipException(\"Invalid X0017_StrongEncryptionHeader: vSize \" + value5 + \" is too small to hold CRC\");\n             }\n-            this.assertDynamicLengthFits(\"vSize\", vSize2, ivSize + 22 + erdSize + resize, length);\n-            this.vData = Arrays.copyOfRange(data, offset + ivSize + 22 + erdSize + resize, vSize2 - 4);\n-            this.vCRC32 = Arrays.copyOfRange(data, offset + ivSize + 22 + erdSize + resize + vSize2 - 4, 4);\n+            this.assertDynamicLengthFits(\"vSize\", value5, value + 22 + value2 + value4, n2);\n+            this.vData = Arrays.copyOfRange(array, n + value + 22 + value2 + value4, value5 - 4);\n+            this.vCRC32 = Arrays.copyOfRange(array, n + value + 22 + value2 + value4 + value5 - 4, 4);\n         }\n     }\n     \n-    public void parseFromCentralDirectoryData(final byte[] data, final int offset, final int length) throws ZipException {\n-        super.parseFromCentralDirectoryData(data, offset, length);\n-        this.parseCentralDirectoryFormat(data, offset, length);\n+    public void parseFromCentralDirectoryData(final byte[] array, final int n, final int n2) throws ZipException {\n+        super.parseFromCentralDirectoryData(array, n, n2);\n+        this.parseCentralDirectoryFormat(array, n, n2);\n     }\n     \n-    public void parseFromLocalFileData(final byte[] data, final int offset, final int length) throws ZipException {\n-        super.parseFromLocalFileData(data, offset, length);\n-        this.parseFileFormat(data, offset, length);\n+    public void parseFromLocalFileData(final byte[] array, final int n, final int n2) throws ZipException {\n+        super.parseFromLocalFileData(array, n, n2);\n+        this.parseFileFormat(array, n, n2);\n     }\n }\n"}]}
