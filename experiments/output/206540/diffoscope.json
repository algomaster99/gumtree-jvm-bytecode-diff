{"diffoscope-json-version": 1, "source1": "first/AbstractConfiguration.class", "source2": "second/AbstractConfiguration.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -85,231 +85,230 @@\n         return this.throwExceptionOnMissing;\n     }\n     \n     public ConfigurationInterpolator getInterpolator() {\n         return this.interpolator.get();\n     }\n     \n-    public final void setInterpolator(final ConfigurationInterpolator ci) {\n-        this.interpolator.set(ci);\n+    public final void setInterpolator(final ConfigurationInterpolator newValue) {\n+        this.interpolator.set(newValue);\n     }\n     \n-    public final void installInterpolator(final Map<String, ? extends Lookup> prefixLookups, final Collection<? extends Lookup> defLookups) {\n-        final InterpolatorSpecification spec = new InterpolatorSpecification.Builder().withPrefixLookups((Map)prefixLookups).withDefaultLookups((Collection)defLookups).withDefaultLookup((Lookup)new ConfigurationLookup((ImmutableConfiguration)this)).create();\n-        this.setInterpolator(ConfigurationInterpolator.fromSpecification(spec));\n+    public final void installInterpolator(final Map<String, ? extends Lookup> map, final Collection<? extends Lookup> collection) {\n+        this.setInterpolator(ConfigurationInterpolator.fromSpecification(new InterpolatorSpecification.Builder().withPrefixLookups((Map)map).withDefaultLookups((Collection)collection).withDefaultLookup((Lookup)new ConfigurationLookup((ImmutableConfiguration)this)).create()));\n     }\n     \n-    public void setPrefixLookups(final Map<String, ? extends Lookup> lookups) {\n-        boolean success;\n+    public void setPrefixLookups(final Map<String, ? extends Lookup> map) {\n+        ConfigurationInterpolator interpolator;\n+        ConfigurationInterpolator newValue;\n         do {\n-            final ConfigurationInterpolator ciOld = this.getInterpolator();\n-            final ConfigurationInterpolator ciNew = (ciOld != null) ? ciOld : new ConfigurationInterpolator();\n-            ciNew.registerLookups((Map)lookups);\n-            success = this.interpolator.compareAndSet(ciOld, ciNew);\n-        } while (!success);\n+            interpolator = this.getInterpolator();\n+            newValue = ((interpolator != null) ? interpolator : new ConfigurationInterpolator());\n+            newValue.registerLookups((Map)map);\n+        } while (!this.interpolator.compareAndSet(interpolator, newValue));\n     }\n     \n-    public void setDefaultLookups(final Collection<? extends Lookup> lookups) {\n-        boolean success;\n+    public void setDefaultLookups(final Collection<? extends Lookup> collection) {\n+        ConfigurationInterpolator interpolator;\n+        ConfigurationInterpolator newValue;\n         do {\n-            final ConfigurationInterpolator ciOld = this.getInterpolator();\n-            final ConfigurationInterpolator ciNew = (ciOld != null) ? ciOld : new ConfigurationInterpolator();\n-            Lookup confLookup = this.findConfigurationLookup(ciNew);\n-            if (confLookup == null) {\n-                confLookup = (Lookup)new ConfigurationLookup((ImmutableConfiguration)this);\n+            interpolator = this.getInterpolator();\n+            newValue = ((interpolator != null) ? interpolator : new ConfigurationInterpolator());\n+            Object configurationLookup = this.findConfigurationLookup(newValue);\n+            if (configurationLookup == null) {\n+                configurationLookup = new ConfigurationLookup((ImmutableConfiguration)this);\n             }\n             else {\n-                ciNew.removeDefaultLookup(confLookup);\n+                newValue.removeDefaultLookup((Lookup)configurationLookup);\n             }\n-            ciNew.addDefaultLookups((Collection)lookups);\n-            ciNew.addDefaultLookup(confLookup);\n-            success = this.interpolator.compareAndSet(ciOld, ciNew);\n-        } while (!success);\n+            newValue.addDefaultLookups((Collection)collection);\n+            newValue.addDefaultLookup((Lookup)configurationLookup);\n+        } while (!this.interpolator.compareAndSet(interpolator, newValue));\n     }\n     \n-    public void setParentInterpolator(final ConfigurationInterpolator parent) {\n-        boolean success;\n+    public void setParentInterpolator(final ConfigurationInterpolator parentInterpolator) {\n+        ConfigurationInterpolator interpolator;\n+        ConfigurationInterpolator newValue;\n         do {\n-            final ConfigurationInterpolator ciOld = this.getInterpolator();\n-            final ConfigurationInterpolator ciNew = (ciOld != null) ? ciOld : new ConfigurationInterpolator();\n-            ciNew.setParentInterpolator(parent);\n-            success = this.interpolator.compareAndSet(ciOld, ciNew);\n-        } while (!success);\n+            interpolator = this.getInterpolator();\n+            newValue = ((interpolator != null) ? interpolator : new ConfigurationInterpolator());\n+            newValue.setParentInterpolator(parentInterpolator);\n+        } while (!this.interpolator.compareAndSet(interpolator, newValue));\n     }\n     \n     public void setConfigurationDecoder(final ConfigurationDecoder configurationDecoder) {\n         this.configurationDecoder = configurationDecoder;\n     }\n     \n     public ConfigurationDecoder getConfigurationDecoder() {\n         return this.configurationDecoder;\n     }\n     \n-    protected void cloneInterpolator(final AbstractConfiguration orgConfig) {\n+    protected void cloneInterpolator(final AbstractConfiguration abstractConfiguration) {\n         this.interpolator = new AtomicReference<ConfigurationInterpolator>();\n-        final ConfigurationInterpolator orgInterpolator = orgConfig.getInterpolator();\n-        final List<Lookup> defaultLookups = orgInterpolator.getDefaultLookups();\n-        final Lookup lookup = findConfigurationLookup(orgInterpolator, (ImmutableConfiguration)orgConfig);\n-        if (lookup != null) {\n-            defaultLookups.remove(lookup);\n+        final ConfigurationInterpolator interpolator = abstractConfiguration.getInterpolator();\n+        final List defaultLookups = interpolator.getDefaultLookups();\n+        final Lookup configurationLookup = findConfigurationLookup(interpolator, (ImmutableConfiguration)abstractConfiguration);\n+        if (configurationLookup != null) {\n+            defaultLookups.remove(configurationLookup);\n         }\n-        this.installInterpolator(orgInterpolator.getLookups(), defaultLookups);\n+        this.installInterpolator(interpolator.getLookups(), defaultLookups);\n     }\n     \n     private void installDefaultInterpolator() {\n         this.installInterpolator(ConfigurationInterpolator.getDefaultPrefixLookups(), null);\n     }\n     \n-    private Lookup findConfigurationLookup(final ConfigurationInterpolator ci) {\n-        return findConfigurationLookup(ci, (ImmutableConfiguration)this);\n+    private Lookup findConfigurationLookup(final ConfigurationInterpolator configurationInterpolator) {\n+        return findConfigurationLookup(configurationInterpolator, (ImmutableConfiguration)this);\n     }\n     \n-    private static Lookup findConfigurationLookup(final ConfigurationInterpolator ci, final ImmutableConfiguration targetConf) {\n-        for (final Lookup l : ci.getDefaultLookups()) {\n-            if (l instanceof ConfigurationLookup && targetConf == ((ConfigurationLookup)l).getConfiguration()) {\n-                return l;\n+    private static Lookup findConfigurationLookup(final ConfigurationInterpolator configurationInterpolator, final ImmutableConfiguration immutableConfiguration) {\n+        for (final Lookup lookup : configurationInterpolator.getDefaultLookups()) {\n+            if (lookup instanceof ConfigurationLookup && immutableConfiguration == ((ConfigurationLookup)lookup).getConfiguration()) {\n+                return lookup;\n             }\n         }\n         return null;\n     }\n     \n     public ConfigurationLogger getLogger() {\n         return this.log;\n     }\n     \n-    public void setLogger(final ConfigurationLogger log) {\n-        this.initLogger(log);\n+    public void setLogger(final ConfigurationLogger configurationLogger) {\n+        this.initLogger(configurationLogger);\n     }\n     \n     public final void addErrorLogListener() {\n-        this.addEventListener(ConfigurationErrorEvent.ANY, event -> this.getLogger().warn(\"Internal error\", event.getCause()));\n+        this.addEventListener(ConfigurationErrorEvent.ANY, configurationErrorEvent -> this.getLogger().warn(\"Internal error\", configurationErrorEvent.getCause()));\n     }\n     \n     public final Synchronizer getSynchronizer() {\n-        final Synchronizer sync = this.synchronizer;\n-        return (Synchronizer)((sync != null) ? sync : NoOpSynchronizer.INSTANCE);\n+        final Synchronizer synchronizer = this.synchronizer;\n+        return (Synchronizer)((synchronizer != null) ? synchronizer : NoOpSynchronizer.INSTANCE);\n     }\n     \n     public final void setSynchronizer(final Synchronizer synchronizer) {\n         this.synchronizer = synchronizer;\n     }\n     \n-    public final void lock(final LockMode mode) {\n-        switch (AbstractConfiguration.AbstractConfiguration$1.$SwitchMap$org$apache$commons$configuration2$sync$LockMode[mode.ordinal()]) {\n+    public final void lock(final LockMode obj) {\n+        switch (AbstractConfiguration.AbstractConfiguration$1.$SwitchMap$org$apache$commons$configuration2$sync$LockMode[obj.ordinal()]) {\n             case 1: {\n                 this.beginRead(false);\n                 break;\n             }\n             case 2: {\n                 this.beginWrite(false);\n                 break;\n             }\n             default: {\n-                throw new IllegalArgumentException(\"Unsupported LockMode: \" + mode);\n+                throw new IllegalArgumentException(\"Unsupported LockMode: \" + obj);\n             }\n         }\n     }\n     \n-    public final void unlock(final LockMode mode) {\n-        switch (AbstractConfiguration.AbstractConfiguration$1.$SwitchMap$org$apache$commons$configuration2$sync$LockMode[mode.ordinal()]) {\n+    public final void unlock(final LockMode obj) {\n+        switch (AbstractConfiguration.AbstractConfiguration$1.$SwitchMap$org$apache$commons$configuration2$sync$LockMode[obj.ordinal()]) {\n             case 1: {\n                 this.endRead();\n                 break;\n             }\n             case 2: {\n                 this.endWrite();\n                 break;\n             }\n             default: {\n-                throw new IllegalArgumentException(\"Unsupported LockMode: \" + mode);\n+                throw new IllegalArgumentException(\"Unsupported LockMode: \" + obj);\n             }\n         }\n     }\n     \n-    protected void beginRead(final boolean optimize) {\n+    protected void beginRead(final boolean b) {\n         this.getSynchronizer().beginRead();\n     }\n     \n     protected void endRead() {\n         this.getSynchronizer().endRead();\n     }\n     \n-    protected void beginWrite(final boolean optimize) {\n+    protected void beginWrite(final boolean b) {\n         this.getSynchronizer().beginWrite();\n     }\n     \n     protected void endWrite() {\n         this.getSynchronizer().endWrite();\n     }\n     \n-    public final void addProperty(final String key, final Object value) {\n+    public final void addProperty(final String s, final Object o) {\n         this.beginWrite(false);\n         try {\n-            this.fireEvent(ConfigurationEvent.ADD_PROPERTY, key, value, true);\n-            this.addPropertyInternal(key, value);\n-            this.fireEvent(ConfigurationEvent.ADD_PROPERTY, key, value, false);\n+            this.fireEvent(ConfigurationEvent.ADD_PROPERTY, s, o, true);\n+            this.addPropertyInternal(s, o);\n+            this.fireEvent(ConfigurationEvent.ADD_PROPERTY, s, o, false);\n         }\n         finally {\n             this.endWrite();\n         }\n     }\n     \n-    protected void addPropertyInternal(final String key, final Object value) {\n-        this.getListDelimiterHandler().parse(value).forEach(obj -> this.addPropertyDirect(key, obj));\n+    protected void addPropertyInternal(final String s, final Object o) {\n+        this.getListDelimiterHandler().parse(o).forEach(o2 -> this.addPropertyDirect(s2, o2));\n     }\n     \n     protected abstract void addPropertyDirect(final String p0, final Object p1);\n     \n-    protected String interpolate(final String base) {\n-        final Object result = this.interpolate((Object)base);\n-        return (result == null) ? null : result.toString();\n+    protected String interpolate(final String s) {\n+        final Object interpolate = this.interpolate((Object)s);\n+        return (interpolate == null) ? null : interpolate.toString();\n     }\n     \n-    protected Object interpolate(final Object value) {\n-        final ConfigurationInterpolator ci = this.getInterpolator();\n-        return (ci != null) ? ci.interpolate(value) : value;\n+    protected Object interpolate(final Object o) {\n+        final ConfigurationInterpolator interpolator = this.getInterpolator();\n+        return (interpolator != null) ? interpolator.interpolate(o) : o;\n     }\n     \n-    public Configuration subset(final String prefix) {\n-        return (Configuration)new SubsetConfiguration((Configuration)this, prefix, \".\");\n+    public Configuration subset(final String s) {\n+        return (Configuration)new SubsetConfiguration((Configuration)this, s, \".\");\n     }\n     \n-    public ImmutableConfiguration immutableSubset(final String prefix) {\n-        return ConfigurationUtils.unmodifiableConfiguration(this.subset(prefix));\n+    public ImmutableConfiguration immutableSubset(final String s) {\n+        return ConfigurationUtils.unmodifiableConfiguration(this.subset(s));\n     }\n     \n-    public final void setProperty(final String key, final Object value) {\n+    public final void setProperty(final String s, final Object o) {\n         this.beginWrite(false);\n         try {\n-            this.fireEvent(ConfigurationEvent.SET_PROPERTY, key, value, true);\n-            this.setPropertyInternal(key, value);\n-            this.fireEvent(ConfigurationEvent.SET_PROPERTY, key, value, false);\n+            this.fireEvent(ConfigurationEvent.SET_PROPERTY, s, o, true);\n+            this.setPropertyInternal(s, o);\n+            this.fireEvent(ConfigurationEvent.SET_PROPERTY, s, o, false);\n         }\n         finally {\n             this.endWrite();\n         }\n     }\n     \n-    protected void setPropertyInternal(final String key, final Object value) {\n+    protected void setPropertyInternal(final String s, final Object o) {\n         this.setDetailEvents(false);\n         try {\n-            this.clearProperty(key);\n-            this.addProperty(key, value);\n+            this.clearProperty(s);\n+            this.addProperty(s, o);\n         }\n         finally {\n             this.setDetailEvents(true);\n         }\n     }\n     \n-    public final void clearProperty(final String key) {\n+    public final void clearProperty(final String s) {\n         this.beginWrite(false);\n         try {\n-            this.fireEvent(ConfigurationEvent.CLEAR_PROPERTY, key, (Object)null, true);\n-            this.clearPropertyDirect(key);\n-            this.fireEvent(ConfigurationEvent.CLEAR_PROPERTY, key, (Object)null, false);\n+            this.fireEvent(ConfigurationEvent.CLEAR_PROPERTY, s, (Object)null, true);\n+            this.clearPropertyDirect(s);\n+            this.fireEvent(ConfigurationEvent.CLEAR_PROPERTY, s, (Object)null, false);\n         }\n         finally {\n             this.endWrite();\n         }\n     }\n     \n     protected abstract void clearPropertyDirect(final String p0);\n@@ -324,32 +323,32 @@\n         finally {\n             this.endWrite();\n         }\n     }\n     \n     protected void clearInternal() {\n         this.setDetailEvents(false);\n-        boolean useIterator = true;\n+        int n = 1;\n         try {\n-            final Iterator<String> it = this.getKeys();\n-            while (it.hasNext()) {\n-                final String key = (String)it.next();\n-                if (useIterator) {\n+            final Iterator<String> keys = this.getKeys();\n+            while (keys.hasNext()) {\n+                final String s = (String)keys.next();\n+                if (n != 0) {\n                     try {\n-                        it.remove();\n+                        keys.remove();\n                     }\n-                    catch (final UnsupportedOperationException usoex) {\n-                        useIterator = false;\n+                    catch (final UnsupportedOperationException ex) {\n+                        n = 0;\n                     }\n                 }\n-                if (useIterator && this.containsKey(key)) {\n-                    useIterator = false;\n+                if (n != 0 && this.containsKey(s)) {\n+                    n = 0;\n                 }\n-                if (!useIterator) {\n-                    this.clearProperty(key);\n+                if (n == 0) {\n+                    this.clearProperty(s);\n                 }\n             }\n         }\n         finally {\n             this.setDetailEvents(true);\n         }\n     }\n@@ -360,34 +359,34 @@\n             return this.getKeysInternal();\n         }\n         finally {\n             this.endRead();\n         }\n     }\n     \n-    public final Iterator<String> getKeys(final String prefix) {\n+    public final Iterator<String> getKeys(final String s) {\n         this.beginRead(false);\n         try {\n-            return this.getKeysInternal(prefix);\n+            return this.getKeysInternal(s);\n         }\n         finally {\n             this.endRead();\n         }\n     }\n     \n     protected abstract Iterator<String> getKeysInternal();\n     \n-    protected Iterator<String> getKeysInternal(final String prefix) {\n-        return (Iterator<String>)new PrefixedKeysIterator((Iterator)this.getKeysInternal(), prefix);\n+    protected Iterator<String> getKeysInternal(final String s) {\n+        return (Iterator<String>)new PrefixedKeysIterator((Iterator)this.getKeysInternal(), s);\n     }\n     \n-    public final Object getProperty(final String key) {\n+    public final Object getProperty(final String s) {\n         this.beginRead(false);\n         try {\n-            return this.getPropertyInternal(key);\n+            return this.getPropertyInternal(s);\n         }\n         finally {\n             this.endRead();\n         }\n     }\n     \n     protected abstract Object getPropertyInternal(final String p0);\n@@ -411,387 +410,377 @@\n         }\n         finally {\n             this.endRead();\n         }\n     }\n     \n     protected int sizeInternal() {\n-        int size = 0;\n-        final Iterator<String> keyIt = this.getKeysInternal();\n-        while (keyIt.hasNext()) {\n-            keyIt.next();\n-            ++size;\n+        int n = 0;\n+        final Iterator<String> keysInternal = this.getKeysInternal();\n+        while (keysInternal.hasNext()) {\n+            keysInternal.next();\n+            ++n;\n         }\n-        return size;\n+        return n;\n     }\n     \n-    public final boolean containsKey(final String key) {\n+    public final boolean containsKey(final String s) {\n         this.beginRead(false);\n         try {\n-            return this.containsKeyInternal(key);\n+            return this.containsKeyInternal(s);\n         }\n         finally {\n             this.endRead();\n         }\n     }\n     \n     protected abstract boolean containsKeyInternal(final String p0);\n     \n-    public Properties getProperties(final String key) {\n-        return this.getProperties(key, null);\n+    public Properties getProperties(final String s) {\n+        return this.getProperties(s, null);\n     }\n     \n-    public Properties getProperties(final String key, final Properties defaults) {\n-        final String[] tokens = this.getStringArray(key);\n-        final Properties props = (defaults == null) ? new Properties() : new Properties(defaults);\n-        final String[] array = tokens;\n+    public Properties getProperties(final String s, final Properties defaults) {\n+        final String[] stringArray = this.getStringArray(s);\n+        final Properties properties = (defaults == null) ? new Properties() : new Properties(defaults);\n+        final String[] array = stringArray;\n         final int length = array.length;\n         int i = 0;\n         while (i < length) {\n-            final String token = array[i];\n-            final int equalSign = token.indexOf(61);\n-            if (equalSign > 0) {\n-                final String pkey = token.substring(0, equalSign).trim();\n-                final String pvalue = token.substring(equalSign + 1).trim();\n-                props.put(pkey, pvalue);\n+            final String str = array[i];\n+            final int index = str.indexOf(61);\n+            if (index > 0) {\n+                properties.put(str.substring(0, index).trim(), str.substring(index + 1).trim());\n                 ++i;\n             }\n             else {\n-                if (tokens.length == 1 && StringUtils.isEmpty((CharSequence)key)) {\n+                if (stringArray.length == 1 && StringUtils.isEmpty((CharSequence)s)) {\n                     break;\n                 }\n-                throw new IllegalArgumentException('\\'' + token + \"' does not contain an equals sign\");\n+                throw new IllegalArgumentException('\\'' + str + \"' does not contain an equals sign\");\n             }\n         }\n-        return props;\n+        return properties;\n     }\n     \n-    public boolean getBoolean(final String key) {\n-        final Boolean b = Boolean.valueOf(this.convert(Boolean.class, key, (Boolean)null, true));\n-        return Boolean.valueOf(checkNonNullValue(key, b));\n+    public boolean getBoolean(final String s) {\n+        return Boolean.valueOf(checkNonNullValue(s, Boolean.valueOf(this.convert(Boolean.class, s, (Boolean)null, true))));\n     }\n     \n-    public boolean getBoolean(final String key, final boolean defaultValue) {\n-        return this.getBoolean(key, Boolean.valueOf(defaultValue));\n+    public boolean getBoolean(final String s, final boolean b) {\n+        return this.getBoolean(s, Boolean.valueOf(b));\n     }\n     \n-    public Boolean getBoolean(final String key, final Boolean defaultValue) {\n-        return Boolean.valueOf(this.convert(Boolean.class, key, defaultValue, false));\n+    public Boolean getBoolean(final String s, final Boolean b) {\n+        return Boolean.valueOf(this.convert(Boolean.class, s, b, false));\n     }\n     \n-    public byte getByte(final String key) {\n-        final Byte b = Byte.valueOf(this.convert(Byte.class, key, (Byte)null, true));\n-        return Byte.valueOf(checkNonNullValue(key, b));\n+    public byte getByte(final String s) {\n+        return Byte.valueOf(checkNonNullValue(s, Byte.valueOf(this.convert(Byte.class, s, (Byte)null, true))));\n     }\n     \n-    public byte getByte(final String key, final byte defaultValue) {\n-        return this.getByte(key, Byte.valueOf(defaultValue));\n+    public byte getByte(final String s, final byte b) {\n+        return this.getByte(s, Byte.valueOf(b));\n     }\n     \n-    public Byte getByte(final String key, final Byte defaultValue) {\n-        return Byte.valueOf(this.convert(Byte.class, key, defaultValue, false));\n+    public Byte getByte(final String s, final Byte b) {\n+        return Byte.valueOf(this.convert(Byte.class, s, b, false));\n     }\n     \n-    public double getDouble(final String key) {\n-        final Double d = Double.valueOf(this.convert(Double.class, key, (Double)null, true));\n-        return Double.valueOf(checkNonNullValue(key, d));\n+    public double getDouble(final String s) {\n+        return Double.valueOf(checkNonNullValue(s, Double.valueOf(this.convert(Double.class, s, (Double)null, true))));\n     }\n     \n-    public double getDouble(final String key, final double defaultValue) {\n-        return this.getDouble(key, Double.valueOf(defaultValue));\n+    public double getDouble(final String s, final double d) {\n+        return this.getDouble(s, Double.valueOf(d));\n     }\n     \n-    public Double getDouble(final String key, final Double defaultValue) {\n-        return Double.valueOf(this.convert(Double.class, key, defaultValue, false));\n+    public Double getDouble(final String s, final Double n) {\n+        return Double.valueOf(this.convert(Double.class, s, n, false));\n     }\n     \n-    public Duration getDuration(final String key) {\n-        return checkNonNullValue(key, (Duration)this.convert((Class<T>)Duration.class, key, (T)null, true));\n+    public Duration getDuration(final String s) {\n+        return checkNonNullValue(s, (Duration)this.convert((Class<T>)Duration.class, s, (T)null, true));\n     }\n     \n-    public Duration getDuration(final String key, final Duration defaultValue) {\n-        return this.convert(Duration.class, key, defaultValue, false);\n+    public Duration getDuration(final String s, final Duration duration) {\n+        return this.convert(Duration.class, s, duration, false);\n     }\n     \n-    public float getFloat(final String key) {\n-        final Float f = Float.valueOf(this.convert(Float.class, key, (Float)null, true));\n-        return Float.valueOf(checkNonNullValue(key, f));\n+    public float getFloat(final String s) {\n+        return Float.valueOf(checkNonNullValue(s, Float.valueOf(this.convert(Float.class, s, (Float)null, true))));\n     }\n     \n-    public float getFloat(final String key, final float defaultValue) {\n-        return this.getFloat(key, Float.valueOf(defaultValue));\n+    public float getFloat(final String s, final float f) {\n+        return this.getFloat(s, Float.valueOf(f));\n     }\n     \n-    public Float getFloat(final String key, final Float defaultValue) {\n-        return Float.valueOf(this.convert(Float.class, key, defaultValue, false));\n+    public Float getFloat(final String s, final Float n) {\n+        return Float.valueOf(this.convert(Float.class, s, n, false));\n     }\n     \n-    public int getInt(final String key) {\n-        final Integer i = Integer.valueOf(this.convert(Integer.class, key, (Integer)null, true));\n-        return Integer.valueOf(checkNonNullValue(key, i));\n+    public int getInt(final String s) {\n+        return Integer.valueOf(checkNonNullValue(s, Integer.valueOf(this.convert(Integer.class, s, (Integer)null, true))));\n     }\n     \n-    public int getInt(final String key, final int defaultValue) {\n-        return this.getInteger(key, Integer.valueOf(defaultValue));\n+    public int getInt(final String s, final int i) {\n+        return this.getInteger(s, Integer.valueOf(i));\n     }\n     \n-    public Integer getInteger(final String key, final Integer defaultValue) {\n-        return Integer.valueOf(this.convert(Integer.class, key, defaultValue, false));\n+    public Integer getInteger(final String s, final Integer n) {\n+        return Integer.valueOf(this.convert(Integer.class, s, n, false));\n     }\n     \n-    public long getLong(final String key) {\n-        final Long l = Long.valueOf(this.convert(Long.class, key, (Long)null, true));\n-        return Long.valueOf(checkNonNullValue(key, l));\n+    public long getLong(final String s) {\n+        return Long.valueOf(checkNonNullValue(s, Long.valueOf(this.convert(Long.class, s, (Long)null, true))));\n     }\n     \n-    public long getLong(final String key, final long defaultValue) {\n-        return this.getLong(key, Long.valueOf(defaultValue));\n+    public long getLong(final String s, final long l) {\n+        return this.getLong(s, Long.valueOf(l));\n     }\n     \n-    public Long getLong(final String key, final Long defaultValue) {\n-        return Long.valueOf(this.convert(Long.class, key, defaultValue, false));\n+    public Long getLong(final String s, final Long n) {\n+        return Long.valueOf(this.convert(Long.class, s, n, false));\n     }\n     \n-    public short getShort(final String key) {\n-        final Short s = Short.valueOf(this.convert(Short.class, key, (Short)null, true));\n-        return Short.valueOf(checkNonNullValue(key, s));\n+    public short getShort(final String s) {\n+        return Short.valueOf(checkNonNullValue(s, Short.valueOf(this.convert(Short.class, s, (Short)null, true))));\n     }\n     \n-    public short getShort(final String key, final short defaultValue) {\n-        return this.getShort(key, Short.valueOf(defaultValue));\n+    public short getShort(final String s, final short s2) {\n+        return this.getShort(s, Short.valueOf(s2));\n     }\n     \n-    public Short getShort(final String key, final Short defaultValue) {\n-        return Short.valueOf(this.convert(Short.class, key, defaultValue, false));\n+    public Short getShort(final String s, final Short n) {\n+        return Short.valueOf(this.convert(Short.class, s, n, false));\n     }\n     \n-    public BigDecimal getBigDecimal(final String key) {\n-        return this.convert(BigDecimal.class, key, null, true);\n+    public BigDecimal getBigDecimal(final String s) {\n+        return this.convert(BigDecimal.class, s, null, true);\n     }\n     \n-    public BigDecimal getBigDecimal(final String key, final BigDecimal defaultValue) {\n-        return this.convert(BigDecimal.class, key, defaultValue, false);\n+    public BigDecimal getBigDecimal(final String s, final BigDecimal bigDecimal) {\n+        return this.convert(BigDecimal.class, s, bigDecimal, false);\n     }\n     \n-    public BigInteger getBigInteger(final String key) {\n-        return this.convert(BigInteger.class, key, null, true);\n+    public BigInteger getBigInteger(final String s) {\n+        return this.convert(BigInteger.class, s, null, true);\n     }\n     \n-    public BigInteger getBigInteger(final String key, final BigInteger defaultValue) {\n-        return this.convert(BigInteger.class, key, defaultValue, false);\n+    public BigInteger getBigInteger(final String s, final BigInteger bigInteger) {\n+        return this.convert(BigInteger.class, s, bigInteger, false);\n     }\n     \n-    public String getString(final String key) {\n-        return this.convert(String.class, key, null, true);\n+    public String getString(final String s) {\n+        return this.convert(String.class, s, null, true);\n     }\n     \n-    public String getString(final String key, final String defaultValue) {\n-        final String result = (String)this.convert(String.class, key, null, false);\n-        return (result != null) ? result : this.interpolate(defaultValue);\n+    public String getString(final String s, final String s2) {\n+        final String s3 = (String)this.convert(String.class, s, null, false);\n+        return (s3 != null) ? s3 : this.interpolate(s2);\n     }\n     \n-    public String getEncodedString(final String key, final ConfigurationDecoder decoder) {\n-        if (decoder == null) {\n+    public String getEncodedString(final String s, final ConfigurationDecoder configurationDecoder) {\n+        if (configurationDecoder == null) {\n             throw new IllegalArgumentException(\"ConfigurationDecoder must not be null!\");\n         }\n-        final String value = this.getString(key);\n-        return (value != null) ? decoder.decode(value) : null;\n+        final String string = this.getString(s);\n+        return (string != null) ? configurationDecoder.decode(string) : null;\n     }\n     \n-    public String getEncodedString(final String key) {\n-        final ConfigurationDecoder decoder = this.getConfigurationDecoder();\n-        if (decoder == null) {\n+    public String getEncodedString(final String s) {\n+        final ConfigurationDecoder configurationDecoder = this.getConfigurationDecoder();\n+        if (configurationDecoder == null) {\n             throw new IllegalStateException(\"No default ConfigurationDecoder defined!\");\n         }\n-        return this.getEncodedString(key, decoder);\n+        return this.getEncodedString(s, configurationDecoder);\n     }\n     \n-    public String[] getStringArray(final String key) {\n-        final String[] result = (String[])this.getArray(String.class, key);\n-        return (result == null) ? ArrayUtils.EMPTY_STRING_ARRAY : result;\n+    public String[] getStringArray(final String s) {\n+        final String[] array = (String[])this.getArray(String.class, s);\n+        return (array == null) ? ArrayUtils.EMPTY_STRING_ARRAY : array;\n     }\n     \n-    public List<Object> getList(final String key) {\n-        return this.getList(key, new ArrayList<Object>());\n+    public List<Object> getList(final String s) {\n+        return this.getList(s, new ArrayList<Object>());\n     }\n     \n-    public List<Object> getList(final String key, final List<?> defaultValue) {\n-        final Object value = this.getProperty(key);\n-        List<Object> list;\n-        if (value instanceof String) {\n-            list = new ArrayList<Object>(1);\n-            list.add(this.interpolate((String)value));\n+    public List<Object> getList(final String str, final List<?> list) {\n+        final Object property = this.getProperty(str);\n+        ArrayList list2;\n+        if (property instanceof String) {\n+            list2 = new ArrayList(1);\n+            list2.add(this.interpolate((String)property));\n         }\n-        else if (value instanceof List) {\n-            list = new ArrayList<Object>();\n-            final List<?> l = (List)value;\n-            l.forEach(elem -> list.add(this.interpolate(elem)));\n+        else if (property instanceof List) {\n+            list2 = new ArrayList();\n+            ((List)property).forEach(o -> list3.add(this.interpolate(o)));\n         }\n-        else if (value == null) {\n-            final List<Object> resultList = list = (List<Object>)defaultValue;\n+        else if (property == null) {\n+            list2 = (ArrayList)list;\n         }\n         else {\n-            if (value.getClass().isArray()) {\n-                return Arrays.asList((Object[])(Object[])value);\n+            if (((List)property).getClass().isArray()) {\n+                return Arrays.asList((Object[])(T[])property);\n             }\n-            if (this.isScalarValue(value)) {\n-                return (List<Object>)Collections.singletonList(value.toString());\n+            if (this.isScalarValue(property)) {\n+                return (List<Object>)Collections.singletonList(property.toString());\n             }\n-            throw new ConversionException('\\'' + key + \"' doesn't map to a List object: \" + value + \", a \" + value.getClass().getName());\n+            throw new ConversionException('\\'' + str + \"' doesn't map to a List object: \" + property + \", a \" + ((T[])property).getClass().getName());\n         }\n-        return list;\n+        return list2;\n     }\n     \n-    public <T> T get(final Class<T> cls, final String key) {\n-        return this.convert(cls, key, (T)null, true);\n+    public <T> T get(final Class<T> clazz, final String s) {\n+        return this.convert(clazz, s, (T)null, true);\n     }\n     \n-    public <T> T get(final Class<T> cls, final String key, final T defaultValue) {\n-        return this.convert(cls, key, defaultValue, false);\n+    public <T> T get(final Class<T> clazz, final String s, final T t) {\n+        return this.convert(clazz, s, t, false);\n     }\n     \n-    public Object getArray(final Class<?> cls, final String key) {\n-        return this.getArray(cls, key, null);\n+    public Object getArray(final Class<?> clazz, final String s) {\n+        return this.getArray(clazz, s, null);\n     }\n     \n-    public Object getArray(final Class<?> cls, final String key, final Object defaultValue) {\n-        return this.convertToArray(cls, key, defaultValue);\n+    public Object getArray(final Class<?> clazz, final String s, final Object o) {\n+        return this.convertToArray(clazz, s, o);\n     }\n     \n-    public <T> List<T> getList(final Class<T> cls, final String key) {\n-        return this.getList(cls, key, null);\n+    public <T> List<T> getList(final Class<T> clazz, final String s) {\n+        return this.getList(clazz, s, null);\n     }\n     \n-    public <T> List<T> getList(final Class<T> cls, final String key, final List<T> defaultValue) {\n-        final List<T> result = new ArrayList<T>();\n-        if (this.getCollection(cls, key, result, defaultValue) == null) {\n+    public <T> List<T> getList(final Class<T> clazz, final String s, final List<T> list) {\n+        final ArrayList list2 = new ArrayList();\n+        if (this.getCollection(clazz, s, list2, list) == null) {\n             return null;\n         }\n-        return result;\n+        return list2;\n     }\n     \n-    public <T> Collection<T> getCollection(final Class<T> cls, final String key, final Collection<T> target) {\n-        return this.getCollection(cls, key, target, null);\n+    public <T> Collection<T> getCollection(final Class<T> clazz, final String s, final Collection<T> collection) {\n+        return this.getCollection(clazz, s, collection, null);\n     }\n     \n-    public <T> Collection<T> getCollection(final Class<T> cls, final String key, final Collection<T> target, final Collection<T> defaultValue) {\n-        final Object src = this.getProperty(key);\n-        if (src == null) {\n-            return handleDefaultCollection(target, defaultValue);\n+    public <T> Collection<T> getCollection(final Class<T> clazz, final String s, final Collection<T> collection, final Collection<T> collection2) {\n+        final Object property = this.getProperty(s);\n+        if (property == null) {\n+            return handleDefaultCollection(collection, collection2);\n         }\n-        final Collection<T> targetCol = (target != null) ? target : new ArrayList<T>();\n-        this.getConversionHandler().toCollection(src, (Class)cls, this.getInterpolator(), (Collection)targetCol);\n-        return targetCol;\n+        final ArrayList<T> list = (ArrayList<T>)((collection != null) ? collection : new ArrayList<T>());\n+        this.getConversionHandler().toCollection(property, (Class)clazz, this.getInterpolator(), (Collection)list);\n+        return list;\n     }\n     \n-    protected boolean isScalarValue(final Object value) {\n-        return ClassUtils.wrapperToPrimitive((Class)value.getClass()) != null;\n+    protected boolean isScalarValue(final Object o) {\n+        return ClassUtils.wrapperToPrimitive((Class)o.getClass()) != null;\n     }\n     \n-    public void copy(final Configuration c) {\n-        if (c != null) {\n-            c.lock(LockMode.READ);\n+    public void copy(final Configuration configuration) {\n+        if (configuration != null) {\n+            configuration.lock(LockMode.READ);\n             try {\n-                c.getKeys().forEachRemaining(key -> this.setProperty(key, this.encodeForCopy(c.getProperty(key))));\n+                configuration.getKeys().forEachRemaining(s -> this.setProperty(s, this.encodeForCopy(configuration2.getProperty(s))));\n             }\n             finally {\n-                c.unlock(LockMode.READ);\n+                configuration.unlock(LockMode.READ);\n             }\n         }\n     }\n     \n-    public void append(final Configuration c) {\n-        if (c != null) {\n-            c.lock(LockMode.READ);\n+    public void append(final Configuration configuration) {\n+        if (configuration != null) {\n+            configuration.lock(LockMode.READ);\n             try {\n-                c.getKeys().forEachRemaining(key -> this.addProperty(key, this.encodeForCopy(c.getProperty(key))));\n+                configuration.getKeys().forEachRemaining(s -> this.addProperty(s, this.encodeForCopy(configuration2.getProperty(s))));\n             }\n             finally {\n-                c.unlock(LockMode.READ);\n+                configuration.unlock(LockMode.READ);\n             }\n         }\n     }\n     \n     public Configuration interpolatedConfiguration() {\n-        final AbstractConfiguration c = (AbstractConfiguration)ConfigurationUtils.cloneConfiguration((Configuration)this);\n-        c.setListDelimiterHandler((ListDelimiterHandler)new DisabledListDelimiterHandler());\n-        this.getKeys().forEachRemaining(key -> c.setProperty(key, this.getList(key)));\n-        c.setListDelimiterHandler(this.getListDelimiterHandler());\n-        return (Configuration)c;\n+        final AbstractConfiguration abstractConfiguration = (AbstractConfiguration)ConfigurationUtils.cloneConfiguration((Configuration)this);\n+        abstractConfiguration.setListDelimiterHandler((ListDelimiterHandler)new DisabledListDelimiterHandler());\n+        this.getKeys().forEachRemaining(s -> abstractConfiguration2.setProperty(s, this.getList(s)));\n+        abstractConfiguration.setListDelimiterHandler(this.getListDelimiterHandler());\n+        return (Configuration)abstractConfiguration;\n     }\n     \n-    protected final void initLogger(final ConfigurationLogger log) {\n-        this.log = ((log != null) ? log : ConfigurationLogger.newDummyLogger());\n+    protected final void initLogger(final ConfigurationLogger configurationLogger) {\n+        this.log = ((configurationLogger != null) ? configurationLogger : ConfigurationLogger.newDummyLogger());\n     }\n     \n-    private Object encodeForCopy(final Object value) {\n-        if (value instanceof Collection) {\n-            return this.encodeListForCopy((Collection<?>)value);\n+    private Object encodeForCopy(final Object o) {\n+        if (o instanceof Collection) {\n+            return this.encodeListForCopy((Collection<?>)o);\n         }\n-        return this.getListDelimiterHandler().escape(value, ListDelimiterHandler.NOOP_TRANSFORMER);\n+        return this.getListDelimiterHandler().escape(o, ListDelimiterHandler.NOOP_TRANSFORMER);\n     }\n     \n-    private Object encodeListForCopy(final Collection<?> values) {\n-        return values.stream().map((Function<?, ?>)this::encodeForCopy).collect((Collector<? super Object, ?, List<? super Object>>)Collectors.toList());\n+    private Object encodeListForCopy(final Collection<?> collection) {\n+        return collection.stream().map((Function<?, ?>)this::encodeForCopy).collect((Collector<? super Object, ?, List<? super Object>>)Collectors.toList());\n     }\n     \n-    private <T> T getAndConvertProperty(final Class<T> cls, final String key, final T defaultValue) {\n-        final Object value = this.getProperty(key);\n+    private <T> T getAndConvertProperty(final Class<T> clazz, final String s, final T t) {\n+        final Object property = this.getProperty(s);\n         try {\n-            return (T)ObjectUtils.defaultIfNull(this.getConversionHandler().to(value, (Class)cls, this.getInterpolator()), (Object)defaultValue);\n+            return (T)ObjectUtils.defaultIfNull(this.getConversionHandler().to(property, (Class)clazz, this.getInterpolator()), (Object)t);\n         }\n-        catch (final ConversionException cex) {\n-            throw new ConversionException(String.format(\"Key '%s' cannot be converted to class %s. Value is: '%s'.\", key, cls.getName(), String.valueOf(value)), cex.getCause());\n+        catch (final ConversionException ex) {\n+            throw new ConversionException(String.format(\"Key '%s' cannot be converted to class %s. Value is: '%s'.\", s, clazz.getName(), String.valueOf(property)), ex.getCause());\n         }\n     }\n     \n-    private <T> T convert(final Class<T> cls, final String key, final T defValue, final boolean throwOnMissing) {\n-        if (cls.isArray()) {\n-            return cls.cast(this.convertToArray(cls.getComponentType(), key, (Object)defValue));\n+    private <T> T convert(final Class<T> clazz, final String s, final T t, final boolean b) {\n+        if (clazz.isArray()) {\n+            return clazz.cast(this.convertToArray((Class<?>)clazz.getComponentType(), s, (Object)t));\n         }\n-        final T result = this.getAndConvertProperty(cls, key, defValue);\n-        if (result == null) {\n-            if (throwOnMissing && this.isThrowExceptionOnMissing()) {\n-                throwMissingPropertyException(key);\n+        final T andConvertProperty = this.getAndConvertProperty(clazz, s, t);\n+        if (andConvertProperty == null) {\n+            if (b && this.isThrowExceptionOnMissing()) {\n+                throwMissingPropertyException(s);\n             }\n-            return defValue;\n+            return t;\n         }\n-        return result;\n+        return andConvertProperty;\n     }\n     \n-    private Object convertToArray(final Class<?> cls, final String key, final Object defaultValue) {\n-        checkDefaultValueArray(cls, defaultValue);\n-        return ObjectUtils.defaultIfNull(this.getConversionHandler().toArray(this.getProperty(key), (Class)cls, this.getInterpolator()), defaultValue);\n+    private Object convertToArray(final Class<?> clazz, final String s, final Object o) {\n+        checkDefaultValueArray(clazz, o);\n+        return ObjectUtils.defaultIfNull(this.getConversionHandler().toArray(this.getProperty(s), (Class)clazz, this.getInterpolator()), o);\n     }\n     \n-    private static void checkDefaultValueArray(final Class<?> cls, final Object defaultValue) {\n-        if (defaultValue != null && (!defaultValue.getClass().isArray() || !cls.isAssignableFrom(defaultValue.getClass().getComponentType()))) {\n-            throw new IllegalArgumentException(\"The type of the default value (\" + defaultValue.getClass() + \") is not an array of the specified class (\" + cls + \")\");\n+    private static void checkDefaultValueArray(final Class<?> obj, final Object o) {\n+        if (o != null && (!o.getClass().isArray() || !obj.isAssignableFrom(o.getClass().getComponentType()))) {\n+            throw new IllegalArgumentException(\"The type of the default value (\" + o.getClass() + \") is not an array of the specified class (\" + obj + \")\");\n         }\n     }\n     \n-    private static <T> Collection<T> handleDefaultCollection(final Collection<T> target, final Collection<T> defaultValue) {\n-        if (defaultValue == null) {\n+    private static <T> Collection<T> handleDefaultCollection(final Collection<T> collection, final Collection<T> c) {\n+        if (c == null) {\n             return null;\n         }\n-        Collection<T> result;\n-        if (target == null) {\n-            result = new ArrayList<T>((Collection<? extends T>)defaultValue);\n+        ArrayList list;\n+        if (collection == null) {\n+            list = new ArrayList((Collection<? extends E>)c);\n         }\n         else {\n-            target.addAll((Collection<? extends T>)defaultValue);\n-            result = target;\n+            collection.addAll((Collection)c);\n+            list = (ArrayList)collection;\n         }\n-        return result;\n+        return list;\n     }\n     \n-    private static <T> T checkNonNullValue(final String key, final T value) {\n-        if (value == null) {\n-            throwMissingPropertyException(key);\n+    private static <T> T checkNonNullValue(final String s, final T t) {\n+        if (t == null) {\n+            throwMissingPropertyException(s);\n         }\n-        return value;\n+        return t;\n     }\n     \n-    private static void throwMissingPropertyException(final String key) {\n-        throw new NoSuchElementException(String.format(\"Key '%s' does not map to an existing object!\", key));\n+    private static void throwMissingPropertyException(final String s) {\n+        throw new NoSuchElementException(String.format(\"Key '%s' does not map to an existing object!\", s));\n     }\n }\n"}]}
