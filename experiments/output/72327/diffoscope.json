{"diffoscope-json-version": 1, "source1": "first/ParallelScatterZipCreator.class", "source2": "second/ParallelScatterZipCreator.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -34,15 +34,15 @@\n     }\n     \n     public ParallelScatterZipCreator() {\n         this(Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()));\n     }\n     \n     public ParallelScatterZipCreator(final ExecutorService executorService) {\n-        this(executorService, (ScatterGatherBackingStoreSupplier)new ParallelScatterZipCreator.DefaultBackingStoreSupplier((ParallelScatterZipCreator.ParallelScatterZipCreator$1)null));\n+        this(executorService, (ScatterGatherBackingStoreSupplier)new ParallelScatterZipCreator.DefaultBackingStoreSupplier((ParallelScatterZipCreator.DefaultBackingStoreSupplier)null));\n     }\n     \n     public ParallelScatterZipCreator(final ExecutorService executorService, final ScatterGatherBackingStoreSupplier backingStoreSupplier) {\n         this(executorService, backingStoreSupplier, -1);\n     }\n     \n     public ParallelScatterZipCreator(final ExecutorService executorService, final ScatterGatherBackingStoreSupplier backingStoreSupplier, final int compressionLevel) throws IllegalArgumentException {\n@@ -64,15 +64,15 @@\n     \n     public void addArchiveEntry(final ZipArchiveEntryRequestSupplier zipArchiveEntryRequestSupplier) {\n         this.submitStreamAwareCallable(this.createCallable(zipArchiveEntryRequestSupplier));\n     }\n     \n     public final void submit(final Callable<?> callable) {\n         this.submitStreamAwareCallable(() -> {\n-            callable.call();\n+            callable2.call();\n             return (ScatterZipOutputStream)this.tlScatterStreams.get();\n         });\n     }\n     \n     public final void submitStreamAwareCallable(final Callable<? extends ScatterZipOutputStream> callable) {\n         this.futures.add(this.es.submit(callable));\n     }\n@@ -81,51 +81,53 @@\n         final int method = zipArchiveEntry.getMethod();\n         if (method == -1) {\n             throw new IllegalArgumentException(\"Method must be set on zipArchiveEntry: \" + zipArchiveEntry);\n         }\n         final ZipArchiveEntryRequest zipArchiveEntryRequest = ZipArchiveEntryRequest.createZipArchiveEntryRequest(zipArchiveEntry, source);\n         return () -> {\n             final ScatterZipOutputStream scatterStream = (ScatterZipOutputStream)this.tlScatterStreams.get();\n-            scatterStream.addArchiveEntry(zipArchiveEntryRequest);\n+            scatterStream.addArchiveEntry(zipArchiveEntryRequest2);\n             return scatterStream;\n         };\n     }\n     \n     public final Callable<ScatterZipOutputStream> createCallable(final ZipArchiveEntryRequestSupplier zipArchiveEntryRequestSupplier) {\n         return () -> {\n             final ScatterZipOutputStream scatterStream = (ScatterZipOutputStream)this.tlScatterStreams.get();\n-            scatterStream.addArchiveEntry(zipArchiveEntryRequestSupplier.get());\n+            scatterStream.addArchiveEntry(zipArchiveEntryRequestSupplier2.get());\n             return scatterStream;\n         };\n     }\n     \n     public void writeTo(final ZipArchiveOutputStream targetStream) throws IOException, InterruptedException, ExecutionException {\n         try {\n             try {\n                 for (final Future<?> future : this.futures) {\n                     future.get();\n                 }\n             }\n             finally {\n                 this.es.shutdown();\n             }\n+            this.es.shutdown();\n             this.es.awaitTermination(60000L, TimeUnit.SECONDS);\n             this.compressionDoneAt = System.currentTimeMillis();\n             for (final Future<? extends ScatterZipOutputStream> future2 : this.futures) {\n                 final ScatterZipOutputStream scatterStream = (ScatterZipOutputStream)future2.get();\n                 scatterStream.zipEntryWriter().writeNextZipEntry(targetStream);\n             }\n             for (final ScatterZipOutputStream scatterStream2 : this.streams) {\n                 scatterStream2.close();\n             }\n             this.scatterDoneAt = System.currentTimeMillis();\n         }\n         finally {\n             this.closeAll();\n         }\n+        this.closeAll();\n     }\n     \n     public ScatterStatistics getStatisticsMessage() {\n         return new ScatterStatistics(this.compressionDoneAt - this.startedAt, this.scatterDoneAt - this.compressionDoneAt);\n     }\n     \n     private void closeAll() {\n"}]}
