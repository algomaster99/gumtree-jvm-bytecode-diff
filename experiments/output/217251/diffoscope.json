{"diffoscope-json-version": 1, "source1": "first/InstConstraintVisitor.class", "source2": "second/InstConstraintVisitor.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -120,15 +120,14 @@\n import org.apache.bcel.generic.FNEG;\n import org.apache.bcel.generic.FMUL;\n import org.apache.bcel.generic.FLOAD;\n import org.apache.bcel.classfile.JavaClass;\n import org.apache.bcel.Repository;\n import org.apache.bcel.classfile.Field;\n import org.apache.bcel.verifier.VerificationResult;\n-import org.apache.bcel.verifier.Verifier;\n import org.apache.bcel.verifier.VerifierFactory;\n import org.apache.bcel.classfile.ConstantFieldref;\n import org.apache.bcel.generic.FDIV;\n import org.apache.bcel.generic.FCONST;\n import org.apache.bcel.generic.FCMPL;\n import org.apache.bcel.generic.FCMPG;\n import org.apache.bcel.generic.FASTORE;\n@@ -203,24 +202,24 @@\n         if (!(arrayref instanceof ArrayType) && !arrayref.equals((Object)Type.NULL)) {\n             this.constraintViolated(o, \"The 'arrayref' does not refer to an array but is of type \" + arrayref + \".\");\n         }\n         return arrayref instanceof ArrayType;\n     }\n     \n     private void constraintViolated(final Instruction violator, final String description) {\n-        final String fqClassName = violator.getClass().getName();\n-        throw new StructuralCodeConstraintException(\"Instruction \" + fqClassName.substring(fqClassName.lastIndexOf(46) + 1) + \" constraint violated: \" + description);\n+        final String name = violator.getClass().getName();\n+        throw new StructuralCodeConstraintException(\"Instruction \" + name.substring(name.lastIndexOf(46) + 1) + \" constraint violated: \" + description);\n     }\n     \n     private ObjectType getObjectType(final FieldInstruction o) {\n-        final ReferenceType rt = o.getReferenceType(this.cpg);\n-        if (rt instanceof ObjectType) {\n-            return (ObjectType)rt;\n+        final ReferenceType referenceType = o.getReferenceType(this.cpg);\n+        if (referenceType instanceof ObjectType) {\n+            return (ObjectType)referenceType;\n         }\n-        this.constraintViolated((Instruction)o, \"expecting ObjectType but got \" + rt);\n+        this.constraintViolated((Instruction)o, \"expecting ObjectType but got \" + referenceType);\n         return null;\n     }\n     \n     private void indexOfInt(final Instruction o, final Type index) {\n         if (!index.equals((Object)Type.INT)) {\n             this.constraintViolated(o, \"The 'index' is not of type int but of type \" + index + \".\");\n         }\n@@ -255,32 +254,31 @@\n     private void valueOfInt(final Instruction o, final Type value) {\n         if (!value.equals((Object)Type.INT)) {\n             this.constraintViolated(o, \"The 'value' is not of type int but of type \" + value + \".\");\n         }\n     }\n     \n     public void visitAALOAD(final AALOAD o) {\n-        final Type arrayref = this.stack().peek(1);\n-        final Type index = this.stack().peek(0);\n-        this.indexOfInt((Instruction)o, index);\n-        if (this.arrayrefOfArrayType((Instruction)o, arrayref) && !(((ArrayType)arrayref).getElementType() instanceof ReferenceType)) {\n-            this.constraintViolated((Instruction)o, \"The 'arrayref' does not refer to an array with elements of a ReferenceType but to an array of \" + ((ArrayType)arrayref).getElementType() + \".\");\n+        final Type peek = this.stack().peek(1);\n+        this.indexOfInt((Instruction)o, this.stack().peek(0));\n+        if (this.arrayrefOfArrayType((Instruction)o, peek) && !(((ArrayType)peek).getElementType() instanceof ReferenceType)) {\n+            this.constraintViolated((Instruction)o, \"The 'arrayref' does not refer to an array with elements of a ReferenceType but to an array of \" + ((ArrayType)peek).getElementType() + \".\");\n         }\n     }\n     \n     public void visitAASTORE(final AASTORE o) {\n-        final Type arrayref = this.stack().peek(2);\n-        final Type index = this.stack().peek(1);\n-        final Type value = this.stack().peek(0);\n-        this.indexOfInt((Instruction)o, index);\n-        if (!(value instanceof ReferenceType)) {\n-            this.constraintViolated((Instruction)o, \"The 'value' is not of a ReferenceType but of type \" + value + \".\");\n+        final Type peek = this.stack().peek(2);\n+        final Type peek2 = this.stack().peek(1);\n+        final Type peek3 = this.stack().peek(0);\n+        this.indexOfInt((Instruction)o, peek2);\n+        if (!(peek3 instanceof ReferenceType)) {\n+            this.constraintViolated((Instruction)o, \"The 'value' is not of a ReferenceType but of type \" + peek3 + \".\");\n         }\n-        if (this.arrayrefOfArrayType((Instruction)o, arrayref) && !(((ArrayType)arrayref).getElementType() instanceof ReferenceType)) {\n-            this.constraintViolated((Instruction)o, \"The 'arrayref' does not refer to an array with elements of a ReferenceType but to an array of \" + ((ArrayType)arrayref).getElementType() + \".\");\n+        if (this.arrayrefOfArrayType((Instruction)o, peek) && !(((ArrayType)peek).getElementType() instanceof ReferenceType)) {\n+            this.constraintViolated((Instruction)o, \"The 'arrayref' does not refer to an array with elements of a ReferenceType but to an array of \" + ((ArrayType)peek).getElementType() + \".\");\n         }\n     }\n     \n     public void visitACONST_NULL(final ACONST_NULL o) {\n     }\n     \n     public void visitALOAD(final ALOAD o) {\n@@ -292,21 +290,19 @@\n         }\n     }\n     \n     public void visitARETURN(final ARETURN o) {\n         if (!(this.stack().peek() instanceof ReferenceType)) {\n             this.constraintViolated((Instruction)o, \"The 'objectref' at the stack top is not of a ReferenceType but of type '\" + this.stack().peek() + \"'.\");\n         }\n-        final ReferenceType objectref = (ReferenceType)this.stack().peek();\n-        this.referenceTypeIsInitialized((Instruction)o, objectref);\n+        this.referenceTypeIsInitialized((Instruction)o, (ReferenceType)this.stack().peek());\n     }\n     \n     public void visitARRAYLENGTH(final ARRAYLENGTH o) {\n-        final Type arrayref = this.stack().peek(0);\n-        this.arrayrefOfArrayType((Instruction)o, arrayref);\n+        this.arrayrefOfArrayType((Instruction)o, this.stack().peek(0));\n     }\n     \n     public void visitASTORE(final ASTORE o) {\n         if (!(this.stack().peek() instanceof ReferenceType) && !(this.stack().peek() instanceof ReturnaddressType)) {\n             this.constraintViolated((Instruction)o, \"The 'objectref' is not of a ReferenceType or of ReturnaddressType but of \" + this.stack().peek() + \".\");\n         }\n     }\n@@ -315,84 +311,82 @@\n         try {\n             if (!(this.stack().peek() instanceof ObjectType) && !this.stack().peek().equals((Object)Type.NULL)) {\n                 this.constraintViolated((Instruction)o, \"The 'objectref' is not of an (initialized) ObjectType but of type \" + this.stack().peek() + \".\");\n             }\n             if (this.stack().peek().equals((Object)Type.NULL)) {\n                 return;\n             }\n-            final ObjectType exc = (ObjectType)this.stack().peek();\n-            final ObjectType throwable = (ObjectType)Type.getType(\"Ljava/lang/Throwable;\");\n-            if (!exc.subclassOf(throwable) && !exc.equals((Object)throwable)) {\n+            final ObjectType objectType = (ObjectType)this.stack().peek();\n+            final ObjectType objectType2 = (ObjectType)Type.getType(\"Ljava/lang/Throwable;\");\n+            if (!objectType.subclassOf(objectType2) && !objectType.equals((Object)objectType2)) {\n                 this.constraintViolated((Instruction)o, \"The 'objectref' is not of class Throwable or of a subclass of Throwable, but of '\" + this.stack().peek() + \"'.\");\n             }\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj, (Throwable)obj);\n         }\n     }\n     \n     public void visitBALOAD(final BALOAD o) {\n-        final Type arrayref = this.stack().peek(1);\n-        final Type index = this.stack().peek(0);\n-        this.indexOfInt((Instruction)o, index);\n-        if (this.arrayrefOfArrayType((Instruction)o, arrayref) && !((ArrayType)arrayref).getElementType().equals((Object)Type.BOOLEAN) && !((ArrayType)arrayref).getElementType().equals((Object)Type.BYTE)) {\n-            this.constraintViolated((Instruction)o, \"The 'arrayref' does not refer to an array with elements of a Type.BYTE or Type.BOOLEAN but to an array of '\" + ((ArrayType)arrayref).getElementType() + \"'.\");\n+        final Type peek = this.stack().peek(1);\n+        this.indexOfInt((Instruction)o, this.stack().peek(0));\n+        if (this.arrayrefOfArrayType((Instruction)o, peek) && !((ArrayType)peek).getElementType().equals((Object)Type.BOOLEAN) && !((ArrayType)peek).getElementType().equals((Object)Type.BYTE)) {\n+            this.constraintViolated((Instruction)o, \"The 'arrayref' does not refer to an array with elements of a Type.BYTE or Type.BOOLEAN but to an array of '\" + ((ArrayType)peek).getElementType() + \"'.\");\n         }\n     }\n     \n     public void visitBASTORE(final BASTORE o) {\n-        final Type arrayref = this.stack().peek(2);\n-        final Type index = this.stack().peek(1);\n-        final Type value = this.stack().peek(0);\n-        this.indexOfInt((Instruction)o, index);\n-        this.valueOfInt((Instruction)o, value);\n-        if (this.arrayrefOfArrayType((Instruction)o, arrayref) && !((ArrayType)arrayref).getElementType().equals((Object)Type.BOOLEAN) && !((ArrayType)arrayref).getElementType().equals((Object)Type.BYTE)) {\n-            this.constraintViolated((Instruction)o, \"The 'arrayref' does not refer to an array with elements of a Type.BYTE or Type.BOOLEAN but to an array of '\" + ((ArrayType)arrayref).getElementType() + \"'.\");\n+        final Type peek = this.stack().peek(2);\n+        final Type peek2 = this.stack().peek(1);\n+        final Type peek3 = this.stack().peek(0);\n+        this.indexOfInt((Instruction)o, peek2);\n+        this.valueOfInt((Instruction)o, peek3);\n+        if (this.arrayrefOfArrayType((Instruction)o, peek) && !((ArrayType)peek).getElementType().equals((Object)Type.BOOLEAN) && !((ArrayType)peek).getElementType().equals((Object)Type.BYTE)) {\n+            this.constraintViolated((Instruction)o, \"The 'arrayref' does not refer to an array with elements of a Type.BYTE or Type.BOOLEAN but to an array of '\" + ((ArrayType)peek).getElementType() + \"'.\");\n         }\n     }\n     \n     public void visitBIPUSH(final BIPUSH o) {\n     }\n     \n     public void visitBREAKPOINT(final BREAKPOINT o) {\n         throw new AssertionViolatedException(\"In this JustIce verification pass there should not occur an illegal instruction such as BREAKPOINT.\");\n     }\n     \n     public void visitCALOAD(final CALOAD o) {\n-        final Type arrayref = this.stack().peek(1);\n-        final Type index = this.stack().peek(0);\n-        this.indexOfInt((Instruction)o, index);\n-        this.arrayrefOfArrayType((Instruction)o, arrayref);\n+        final Type peek = this.stack().peek(1);\n+        this.indexOfInt((Instruction)o, this.stack().peek(0));\n+        this.arrayrefOfArrayType((Instruction)o, peek);\n     }\n     \n     public void visitCASTORE(final CASTORE o) {\n-        final Type arrayref = this.stack().peek(2);\n-        final Type index = this.stack().peek(1);\n-        final Type value = this.stack().peek(0);\n-        this.indexOfInt((Instruction)o, index);\n-        this.valueOfInt((Instruction)o, value);\n-        if (this.arrayrefOfArrayType((Instruction)o, arrayref) && !((ArrayType)arrayref).getElementType().equals((Object)Type.CHAR)) {\n-            this.constraintViolated((Instruction)o, \"The 'arrayref' does not refer to an array with elements of type char but to an array of type \" + ((ArrayType)arrayref).getElementType() + \".\");\n+        final Type peek = this.stack().peek(2);\n+        final Type peek2 = this.stack().peek(1);\n+        final Type peek3 = this.stack().peek(0);\n+        this.indexOfInt((Instruction)o, peek2);\n+        this.valueOfInt((Instruction)o, peek3);\n+        if (this.arrayrefOfArrayType((Instruction)o, peek) && !((ArrayType)peek).getElementType().equals((Object)Type.CHAR)) {\n+            this.constraintViolated((Instruction)o, \"The 'arrayref' does not refer to an array with elements of type char but to an array of type \" + ((ArrayType)peek).getElementType() + \".\");\n         }\n     }\n     \n     public void visitCHECKCAST(final CHECKCAST o) {\n-        final Type objectref = this.stack().peek(0);\n-        if (!(objectref instanceof ReferenceType)) {\n-            this.constraintViolated((Instruction)o, \"The 'objectref' is not of a ReferenceType but of type \" + objectref + \".\");\n-        }\n-        final Constant c = this.cpg.getConstant(o.getIndex());\n-        if (!(c instanceof ConstantClass)) {\n-            this.constraintViolated((Instruction)o, \"The Constant at 'index' is not a ConstantClass, but '\" + c + \"'.\");\n+        final Type peek = this.stack().peek(0);\n+        if (!(peek instanceof ReferenceType)) {\n+            this.constraintViolated((Instruction)o, \"The 'objectref' is not of a ReferenceType but of type \" + peek + \".\");\n+        }\n+        final Constant constant = this.cpg.getConstant(o.getIndex());\n+        if (!(constant instanceof ConstantClass)) {\n+            this.constraintViolated((Instruction)o, \"The Constant at 'index' is not a ConstantClass, but '\" + constant + \"'.\");\n         }\n     }\n     \n     public void visitCPInstruction(final CPInstruction o) {\n-        final int idx = o.getIndex();\n-        if (idx < 0 || idx >= this.cpg.getSize()) {\n+        final int index = o.getIndex();\n+        if (index < 0 || index >= this.cpg.getSize()) {\n             throw new AssertionViolatedException(\"Huh?! Constant pool index of instruction '\" + o + \"' illegal? Pass 3a should have checked this!\");\n         }\n     }\n     \n     public void visitD2F(final D2F o) {\n         if (this.stack().peek() != Type.DOUBLE) {\n             this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n@@ -424,16 +418,15 @@\n         this.indexOfInt((Instruction)o, this.stack().peek());\n         if (this.stack().peek(1) == Type.NULL) {\n             return;\n         }\n         if (!(this.stack().peek(1) instanceof ArrayType)) {\n             this.constraintViolated((Instruction)o, \"Stack next-to-top must be of type double[] but is '\" + this.stack().peek(1) + \"'.\");\n         }\n-        final Type t = ((ArrayType)this.stack().peek(1)).getBasicType();\n-        if (t != Type.DOUBLE) {\n+        if (((ArrayType)this.stack().peek(1)).getBasicType() != Type.DOUBLE) {\n             this.constraintViolated((Instruction)o, \"Stack next-to-top must be of type double[] but is '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n     public void visitDASTORE(final DASTORE o) {\n         if (this.stack().peek() != Type.DOUBLE) {\n             this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n@@ -441,16 +434,15 @@\n         this.indexOfInt((Instruction)o, this.stack().peek(1));\n         if (this.stack().peek(2) == Type.NULL) {\n             return;\n         }\n         if (!(this.stack().peek(2) instanceof ArrayType)) {\n             this.constraintViolated((Instruction)o, \"Stack next-to-next-to-top must be of type double[] but is '\" + this.stack().peek(2) + \"'.\");\n         }\n-        final Type t = ((ArrayType)this.stack().peek(2)).getBasicType();\n-        if (t != Type.DOUBLE) {\n+        if (((ArrayType)this.stack().peek(2)).getBasicType() != Type.DOUBLE) {\n             this.constraintViolated((Instruction)o, \"Stack next-to-next-to-top must be of type double[] but is '\" + this.stack().peek(2) + \"'.\");\n         }\n     }\n     \n     public void visitDCMPG(final DCMPG o) {\n         if (this.stack().peek() != Type.DOUBLE) {\n             this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n@@ -622,16 +614,15 @@\n         this.indexOfInt((Instruction)o, this.stack().peek());\n         if (this.stack().peek(1) == Type.NULL) {\n             return;\n         }\n         if (!(this.stack().peek(1) instanceof ArrayType)) {\n             this.constraintViolated((Instruction)o, \"Stack next-to-top must be of type float[] but is '\" + this.stack().peek(1) + \"'.\");\n         }\n-        final Type t = ((ArrayType)this.stack().peek(1)).getBasicType();\n-        if (t != Type.FLOAT) {\n+        if (((ArrayType)this.stack().peek(1)).getBasicType() != Type.FLOAT) {\n             this.constraintViolated((Instruction)o, \"Stack next-to-top must be of type float[] but is '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n     public void visitFASTORE(final FASTORE o) {\n         if (this.stack().peek() != Type.FLOAT) {\n             this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n@@ -639,16 +630,15 @@\n         this.indexOfInt((Instruction)o, this.stack().peek(1));\n         if (this.stack().peek(2) == Type.NULL) {\n             return;\n         }\n         if (!(this.stack().peek(2) instanceof ArrayType)) {\n             this.constraintViolated((Instruction)o, \"Stack next-to-next-to-top must be of type float[] but is '\" + this.stack().peek(2) + \"'.\");\n         }\n-        final Type t = ((ArrayType)this.stack().peek(2)).getBasicType();\n-        if (t != Type.FLOAT) {\n+        if (((ArrayType)this.stack().peek(2)).getBasicType() != Type.FLOAT) {\n             this.constraintViolated((Instruction)o, \"Stack next-to-next-to-top must be of type float[] but is '\" + this.stack().peek(2) + \"'.\");\n         }\n     }\n     \n     public void visitFCMPG(final FCMPG o) {\n         if (this.stack().peek() != Type.FLOAT) {\n             this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n@@ -676,69 +666,64 @@\n         }\n         if (this.stack().peek(1) != Type.FLOAT) {\n             this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'float', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n     public void visitFieldInstruction(final FieldInstruction o) {\n-        final Constant c = this.cpg.getConstant(o.getIndex());\n-        if (!(c instanceof ConstantFieldref)) {\n-            this.constraintViolated((Instruction)o, \"Index '\" + o.getIndex() + \"' should refer to a CONSTANT_Fieldref_info structure, but refers to '\" + c + \"'.\");\n-        }\n-        final Type t = o.getType(this.cpg);\n-        if (t instanceof ObjectType) {\n-            final String name = ((ObjectType)t).getClassName();\n-            final Verifier v = VerifierFactory.getVerifier(name);\n-            final VerificationResult vr = v.doPass2();\n-            if (vr.getStatus() != 1) {\n-                this.constraintViolated((Instruction)o, \"Class '\" + name + \"' is referenced, but cannot be loaded and resolved: '\" + vr + \"'.\");\n+        final Constant constant = this.cpg.getConstant(o.getIndex());\n+        if (!(constant instanceof ConstantFieldref)) {\n+            this.constraintViolated((Instruction)o, \"Index '\" + o.getIndex() + \"' should refer to a CONSTANT_Fieldref_info structure, but refers to '\" + constant + \"'.\");\n+        }\n+        final Type type = o.getType(this.cpg);\n+        if (type instanceof ObjectType) {\n+            final String className = ((ObjectType)type).getClassName();\n+            final VerificationResult doPass2 = VerifierFactory.getVerifier(className).doPass2();\n+            if (doPass2.getStatus() != 1) {\n+                this.constraintViolated((Instruction)o, \"Class '\" + className + \"' is referenced, but cannot be loaded and resolved: '\" + doPass2 + \"'.\");\n             }\n         }\n     }\n     \n     private Field visitFieldInstructionInternals(final FieldInstruction o) throws ClassNotFoundException {\n         final String fieldName = o.getFieldName(this.cpg);\n-        final JavaClass jc = Repository.lookupClass(this.getObjectType(o).getClassName());\n-        final Field[] fields = jc.getFields();\n-        Field f = null;\n-        for (final Field field : fields) {\n-            if (field.getName().equals(fieldName)) {\n-                final Type fType = Type.getType(field.getSignature());\n-                final Type oType = o.getType(this.cpg);\n-                if (fType.equals((Object)oType)) {\n-                    f = field;\n-                    break;\n-                }\n-            }\n-        }\n-        if (f == null) {\n-            throw new AssertionViolatedException(\"Field '\" + fieldName + \"' not found in \" + jc.getClassName());\n-        }\n-        final Type value = this.stack().peek();\n-        Type shouldBe;\n-        final Type t = shouldBe = Type.getType(f.getSignature());\n-        if (shouldBe == Type.BOOLEAN || shouldBe == Type.BYTE || shouldBe == Type.CHAR || shouldBe == Type.SHORT) {\n-            shouldBe = (Type)Type.INT;\n-        }\n-        if (t instanceof ReferenceType) {\n-            if (value instanceof ReferenceType) {\n-                final ReferenceType rValue = (ReferenceType)value;\n-                this.referenceTypeIsInitialized((Instruction)o, rValue);\n-                if (!rValue.isAssignmentCompatibleWith(shouldBe)) {\n-                    this.constraintViolated((Instruction)o, \"The stack top type '\" + value + \"' is not assignment compatible with '\" + shouldBe + \"'.\");\n+        final JavaClass lookupClass = Repository.lookupClass(this.getObjectType(o).getClassName());\n+        final Field[] fields = lookupClass.getFields();\n+        Field field = null;\n+        for (final Field field2 : fields) {\n+            if (field2.getName().equals(fieldName) && Type.getType(field2.getSignature()).equals((Object)o.getType(this.cpg))) {\n+                field = field2;\n+                break;\n+            }\n+        }\n+        if (field == null) {\n+            throw new AssertionViolatedException(\"Field '\" + fieldName + \"' not found in \" + lookupClass.getClassName());\n+        }\n+        final Type peek = this.stack().peek();\n+        Object o2;\n+        final Type type = (Type)(o2 = Type.getType(field.getSignature()));\n+        if (o2 == Type.BOOLEAN || o2 == Type.BYTE || o2 == Type.CHAR || o2 == Type.SHORT) {\n+            o2 = Type.INT;\n+        }\n+        if (type instanceof ReferenceType) {\n+            if (peek instanceof ReferenceType) {\n+                final ReferenceType r = (ReferenceType)peek;\n+                this.referenceTypeIsInitialized((Instruction)o, r);\n+                if (!r.isAssignmentCompatibleWith((Type)o2)) {\n+                    this.constraintViolated((Instruction)o, \"The stack top type '\" + peek + \"' is not assignment compatible with '\" + o2 + \"'.\");\n                 }\n             }\n             else {\n-                this.constraintViolated((Instruction)o, \"The stack top type '\" + value + \"' is not of a reference type as expected.\");\n+                this.constraintViolated((Instruction)o, \"The stack top type '\" + peek + \"' is not of a reference type as expected.\");\n             }\n         }\n-        else if (shouldBe != value) {\n-            this.constraintViolated((Instruction)o, \"The stack top type '\" + value + \"' is not of type '\" + shouldBe + \"' as expected.\");\n+        else if (o2 != peek) {\n+            this.constraintViolated((Instruction)o, \"The stack top type '\" + peek + \"' is not of type '\" + o2 + \"' as expected.\");\n         }\n-        return f;\n+        return field;\n     }\n     \n     public void visitFLOAD(final FLOAD o) {\n     }\n     \n     public void visitFMUL(final FMUL o) {\n         if (this.stack().peek() != Type.FLOAT) {\n@@ -780,77 +765,73 @@\n         if (this.stack().peek(1) != Type.FLOAT) {\n             this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'float', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n     public void visitGETFIELD(final GETFIELD o) {\n         try {\n-            final Type objectref = this.stack().peek();\n-            if (!(objectref instanceof ObjectType) && objectref != Type.NULL) {\n-                this.constraintViolated((Instruction)o, \"Stack top should be an object reference that's not an array reference, but is '\" + objectref + \"'.\");\n+            final Type peek = this.stack().peek();\n+            if (!(peek instanceof ObjectType) && peek != Type.NULL) {\n+                this.constraintViolated((Instruction)o, \"Stack top should be an object reference that's not an array reference, but is '\" + peek + \"'.\");\n             }\n             final String fieldName = o.getFieldName(this.cpg);\n-            final JavaClass jc = Repository.lookupClass(this.getObjectType((FieldInstruction)o).getClassName());\n-            Field[] fields = jc.getFields();\n-            Field f = null;\n+            final JavaClass lookupClass = Repository.lookupClass(this.getObjectType((FieldInstruction)o).getClassName());\n+            final Field[] fields = lookupClass.getFields();\n+            Field obj = null;\n             for (final Field field : fields) {\n-                if (field.getName().equals(fieldName)) {\n-                    final Type fType = Type.getType(field.getSignature());\n-                    final Type oType = o.getType(this.cpg);\n-                    if (fType.equals((Object)oType)) {\n-                        f = field;\n-                        break;\n-                    }\n+                if (field.getName().equals(fieldName) && Type.getType(field.getSignature()).equals((Object)o.getType(this.cpg))) {\n+                    obj = field;\n+                    break;\n                 }\n             }\n-            if (f == null) {\n-                final JavaClass[] superClasses;\n-                final JavaClass[] superclasses = superClasses = jc.getSuperClasses();\n+            if (obj == null) {\n+                final JavaClass[] superClasses = lookupClass.getSuperClasses();\n             Label_0309:\n-                for (final JavaClass superclass : superClasses) {\n-                    final Field[] fields2;\n-                    fields = (fields2 = superclass.getFields());\n-                    for (final Field field2 : fields2) {\n-                        if (field2.getName().equals(fieldName)) {\n-                            final Type fType2 = Type.getType(field2.getSignature());\n-                            final Type oType2 = o.getType(this.cpg);\n-                            if (fType2.equals((Object)oType2)) {\n-                                f = field2;\n-                                if ((f.getAccessFlags() & 0x5) == 0x0) {\n-                                    f = null;\n-                                    break Label_0309;\n-                                }\n+                for (int length2 = superClasses.length, j = 0; j < length2; ++j) {\n+                    final Field[] fields2 = superClasses[j].getFields();\n+                    final int length3 = fields2.length;\n+                    int k = 0;\n+                    while (k < length3) {\n+                        final Field field2 = fields2[k];\n+                        if (field2.getName().equals(fieldName) && Type.getType(field2.getSignature()).equals((Object)o.getType(this.cpg))) {\n+                            obj = field2;\n+                            if ((obj.getAccessFlags() & 0x5) == 0x0) {\n+                                obj = null;\n                                 break Label_0309;\n                             }\n+                            break Label_0309;\n+                        }\n+                        else {\n+                            ++k;\n                         }\n                     }\n                 }\n-                if (f == null) {\n-                    throw new AssertionViolatedException(\"Field '\" + fieldName + \"' not found in \" + jc.getClassName());\n+                if (obj == null) {\n+                    throw new AssertionViolatedException(\"Field '\" + fieldName + \"' not found in \" + lookupClass.getClassName());\n                 }\n             }\n-            if (f.isProtected()) {\n-                final ObjectType classtype = this.getObjectType((FieldInstruction)o);\n-                final ObjectType curr = ObjectType.getInstance(this.mg.getClassName());\n-                if (classtype.equals((Object)curr) || curr.subclassOf(classtype)) {\n-                    final Type t = this.stack().peek();\n-                    if (t == Type.NULL) {\n+            if (obj.isProtected()) {\n+                final ObjectType objectType = this.getObjectType((FieldInstruction)o);\n+                final ObjectType instance = ObjectType.getInstance(this.mg.getClassName());\n+                if (objectType.equals((Object)instance) || instance.subclassOf(objectType)) {\n+                    final Type peek2 = this.stack().peek();\n+                    if (peek2 == Type.NULL) {\n                         return;\n                     }\n-                    if (!(t instanceof ObjectType)) {\n-                        this.constraintViolated((Instruction)o, \"The 'objectref' must refer to an object that's not an array. Found instead: '\" + t + \"'.\");\n+                    if (!(peek2 instanceof ObjectType)) {\n+                        this.constraintViolated((Instruction)o, \"The 'objectref' must refer to an object that's not an array. Found instead: '\" + peek2 + \"'.\");\n                     }\n                 }\n             }\n-            if (f.isStatic()) {\n-                this.constraintViolated((Instruction)o, \"Referenced field '\" + f + \"' is static which it shouldn't be.\");\n+            if (obj.isStatic()) {\n+                this.constraintViolated((Instruction)o, \"Referenced field '\" + obj + \"' is static which it shouldn't be.\");\n             }\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj2) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj2, (Throwable)obj2);\n         }\n     }\n     \n     public void visitGETSTATIC(final GETSTATIC o) {\n     }\n     \n     public void visitGOTO(final GOTO o) {\n@@ -908,16 +889,15 @@\n         this.indexOfInt((Instruction)o, this.stack().peek());\n         if (this.stack().peek(1) == Type.NULL) {\n             return;\n         }\n         if (!(this.stack().peek(1) instanceof ArrayType)) {\n             this.constraintViolated((Instruction)o, \"Stack next-to-top must be of type int[] but is '\" + this.stack().peek(1) + \"'.\");\n         }\n-        final Type t = ((ArrayType)this.stack().peek(1)).getBasicType();\n-        if (t != Type.INT) {\n+        if (((ArrayType)this.stack().peek(1)).getBasicType() != Type.INT) {\n             this.constraintViolated((Instruction)o, \"Stack next-to-top must be of type int[] but is '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n     public void visitIAND(final IAND o) {\n         if (this.stack().peek() != Type.INT) {\n             this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n@@ -934,16 +914,15 @@\n         this.indexOfInt((Instruction)o, this.stack().peek(1));\n         if (this.stack().peek(2) == Type.NULL) {\n             return;\n         }\n         if (!(this.stack().peek(2) instanceof ArrayType)) {\n             this.constraintViolated((Instruction)o, \"Stack next-to-next-to-top must be of type int[] but is '\" + this.stack().peek(2) + \"'.\");\n         }\n-        final Type t = ((ArrayType)this.stack().peek(2)).getBasicType();\n-        if (t != Type.INT) {\n+        if (((ArrayType)this.stack().peek(2)).getBasicType() != Type.INT) {\n             this.constraintViolated((Instruction)o, \"Stack next-to-next-to-top must be of type int[] but is '\" + this.stack().peek(2) + \"'.\");\n         }\n     }\n     \n     public void visitICONST(final ICONST o) {\n     }\n     \n@@ -1108,21 +1087,21 @@\n     public void visitINEG(final INEG o) {\n         if (this.stack().peek() != Type.INT) {\n             this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n     public void visitINSTANCEOF(final INSTANCEOF o) {\n-        final Type objectref = this.stack().peek(0);\n-        if (!(objectref instanceof ReferenceType)) {\n-            this.constraintViolated((Instruction)o, \"The 'objectref' is not of a ReferenceType but of type \" + objectref + \".\");\n-        }\n-        final Constant c = this.cpg.getConstant(o.getIndex());\n-        if (!(c instanceof ConstantClass)) {\n-            this.constraintViolated((Instruction)o, \"The Constant at 'index' is not a ConstantClass, but '\" + c + \"'.\");\n+        final Type peek = this.stack().peek(0);\n+        if (!(peek instanceof ReferenceType)) {\n+            this.constraintViolated((Instruction)o, \"The 'objectref' is not of a ReferenceType but of type \" + peek + \".\");\n+        }\n+        final Constant constant = this.cpg.getConstant(o.getIndex());\n+        if (!(constant instanceof ConstantClass)) {\n+            this.constraintViolated((Instruction)o, \"The Constant at 'index' is not a ConstantClass, but '\" + constant + \"'.\");\n         }\n     }\n     \n     public void visitINVOKEDYNAMIC(final INVOKEDYNAMIC o) {\n         throw new UnsupportedOperationException(\"INVOKEDYNAMIC instruction is not supported at this time\");\n     }\n     \n@@ -1130,179 +1109,173 @@\n     }\n     \n     public void visitINVOKEINTERFACE(final INVOKEINTERFACE o) {\n         final int count = o.getCount();\n         if (count == 0) {\n             this.constraintViolated((Instruction)o, \"The 'count' argument must not be 0.\");\n         }\n-        final Type t = o.getType(this.cpg);\n-        if (t instanceof ObjectType) {\n-            final String name = ((ObjectType)t).getClassName();\n-            final Verifier v = VerifierFactory.getVerifier(name);\n-            final VerificationResult vr = v.doPass2();\n-            if (vr.getStatus() != 1) {\n-                this.constraintViolated((Instruction)o, \"Class '\" + name + \"' is referenced, but cannot be loaded and resolved: '\" + vr + \"'.\");\n-            }\n-        }\n-        final Type[] argtypes = o.getArgumentTypes(this.cpg);\n-        final int nargs = argtypes.length;\n-        for (int i = nargs - 1; i >= 0; --i) {\n-            final Type fromStack = this.stack().peek(nargs - 1 - i);\n-            Type fromDesc = argtypes[i];\n-            if (fromDesc == Type.BOOLEAN || fromDesc == Type.BYTE || fromDesc == Type.CHAR || fromDesc == Type.SHORT) {\n-                fromDesc = (Type)Type.INT;\n-            }\n-            if (!fromStack.equals((Object)fromDesc)) {\n-                if (fromStack instanceof ReferenceType && fromDesc instanceof ReferenceType) {\n-                    final ReferenceType rFromStack = (ReferenceType)fromStack;\n-                    this.referenceTypeIsInitialized((Instruction)o, rFromStack);\n+        final Type type = o.getType(this.cpg);\n+        if (type instanceof ObjectType) {\n+            final String className = ((ObjectType)type).getClassName();\n+            final VerificationResult doPass2 = VerifierFactory.getVerifier(className).doPass2();\n+            if (doPass2.getStatus() != 1) {\n+                this.constraintViolated((Instruction)o, \"Class '\" + className + \"' is referenced, but cannot be loaded and resolved: '\" + doPass2 + \"'.\");\n+            }\n+        }\n+        final Type[] argumentTypes = o.getArgumentTypes(this.cpg);\n+        final int length = argumentTypes.length;\n+        for (int i = length - 1; i >= 0; --i) {\n+            final Type peek = this.stack().peek(length - 1 - i);\n+            Object int1 = argumentTypes[i];\n+            if (int1 == Type.BOOLEAN || int1 == Type.BYTE || int1 == Type.CHAR || int1 == Type.SHORT) {\n+                int1 = Type.INT;\n+            }\n+            if (!peek.equals(int1)) {\n+                if (peek instanceof ReferenceType && int1 instanceof ReferenceType) {\n+                    this.referenceTypeIsInitialized((Instruction)o, (ReferenceType)peek);\n                 }\n                 else {\n-                    this.constraintViolated((Instruction)o, \"Expecting a '\" + fromDesc + \"' but found a '\" + fromStack + \"' on the stack.\");\n+                    this.constraintViolated((Instruction)o, \"Expecting a '\" + int1 + \"' but found a '\" + peek + \"' on the stack.\");\n                 }\n             }\n         }\n-        Type objref = this.stack().peek(nargs);\n-        if (objref == Type.NULL) {\n+        final Type peek2 = this.stack().peek(length);\n+        if (peek2 == Type.NULL) {\n             return;\n         }\n-        if (!(objref instanceof ReferenceType)) {\n-            this.constraintViolated((Instruction)o, \"Expecting a reference type as 'objectref' on the stack, not a '\" + objref + \"'.\");\n+        if (!(peek2 instanceof ReferenceType)) {\n+            this.constraintViolated((Instruction)o, \"Expecting a reference type as 'objectref' on the stack, not a '\" + peek2 + \"'.\");\n         }\n-        this.referenceTypeIsInitialized((Instruction)o, (ReferenceType)objref);\n-        if (!(objref instanceof ObjectType)) {\n-            if (!(objref instanceof ArrayType)) {\n-                this.constraintViolated((Instruction)o, \"Expecting an ObjectType as 'objectref' on the stack, not a '\" + objref + \"'.\");\n+        this.referenceTypeIsInitialized((Instruction)o, (ReferenceType)peek2);\n+        if (!(peek2 instanceof ObjectType)) {\n+            if (!(peek2 instanceof ArrayType)) {\n+                this.constraintViolated((Instruction)o, \"Expecting an ObjectType as 'objectref' on the stack, not a '\" + peek2 + \"'.\");\n             }\n             else {\n-                objref = (Type)InstConstraintVisitor.GENERIC_ARRAY;\n+                final ObjectType generic_ARRAY = InstConstraintVisitor.GENERIC_ARRAY;\n             }\n         }\n-        int countedCount = 1;\n-        for (int j = 0; j < nargs; ++j) {\n-            countedCount += argtypes[j].getSize();\n+        int j = 1;\n+        for (int k = 0; k < length; ++k) {\n+            j += argumentTypes[k].getSize();\n         }\n-        if (count != countedCount) {\n-            this.constraintViolated((Instruction)o, \"The 'count' argument should probably read '\" + countedCount + \"' but is '\" + count + \"'.\");\n+        if (count != j) {\n+            this.constraintViolated((Instruction)o, \"The 'count' argument should probably read '\" + j + \"' but is '\" + count + \"'.\");\n         }\n     }\n     \n     private int visitInvokeInternals(final InvokeInstruction o) throws ClassNotFoundException {\n-        final Type t = o.getType(this.cpg);\n-        if (t instanceof ObjectType) {\n-            final String name = ((ObjectType)t).getClassName();\n-            final Verifier v = VerifierFactory.getVerifier(name);\n-            final VerificationResult vr = v.doPass2();\n-            if (vr.getStatus() != 1) {\n-                this.constraintViolated((Instruction)o, \"Class '\" + name + \"' is referenced, but cannot be loaded and resolved: '\" + vr + \"'.\");\n-            }\n-        }\n-        final Type[] argtypes = o.getArgumentTypes(this.cpg);\n-        final int nargs = argtypes.length;\n-        for (int i = nargs - 1; i >= 0; --i) {\n-            final Type fromStack = this.stack().peek(nargs - 1 - i);\n-            Type fromDesc = argtypes[i];\n-            if (fromDesc == Type.BOOLEAN || fromDesc == Type.BYTE || fromDesc == Type.CHAR || fromDesc == Type.SHORT) {\n-                fromDesc = (Type)Type.INT;\n-            }\n-            if (!fromStack.equals((Object)fromDesc)) {\n-                if (fromStack instanceof ReferenceType && fromDesc instanceof ReferenceType) {\n-                    final ReferenceType rFromStack = (ReferenceType)fromStack;\n-                    final ReferenceType rFromDesc = (ReferenceType)fromDesc;\n-                    if (!rFromStack.isAssignmentCompatibleWith((Type)rFromDesc)) {\n-                        this.constraintViolated((Instruction)o, \"Expecting a '\" + fromDesc + \"' but found a '\" + fromStack + \"' on the stack (which is not assignment compatible).\");\n+        final Type type = o.getType(this.cpg);\n+        if (type instanceof ObjectType) {\n+            final String className = ((ObjectType)type).getClassName();\n+            final VerificationResult doPass2 = VerifierFactory.getVerifier(className).doPass2();\n+            if (doPass2.getStatus() != 1) {\n+                this.constraintViolated((Instruction)o, \"Class '\" + className + \"' is referenced, but cannot be loaded and resolved: '\" + doPass2 + \"'.\");\n+            }\n+        }\n+        final Type[] argumentTypes = o.getArgumentTypes(this.cpg);\n+        final int length = argumentTypes.length;\n+        for (int i = length - 1; i >= 0; --i) {\n+            final Type peek = this.stack().peek(length - 1 - i);\n+            Object int1 = argumentTypes[i];\n+            if (int1 == Type.BOOLEAN || int1 == Type.BYTE || int1 == Type.CHAR || int1 == Type.SHORT) {\n+                int1 = Type.INT;\n+            }\n+            if (!peek.equals(int1)) {\n+                if (peek instanceof ReferenceType && int1 instanceof ReferenceType) {\n+                    final ReferenceType r = (ReferenceType)peek;\n+                    if (!r.isAssignmentCompatibleWith((Type)(ReferenceType)int1)) {\n+                        this.constraintViolated((Instruction)o, \"Expecting a '\" + int1 + \"' but found a '\" + peek + \"' on the stack (which is not assignment compatible).\");\n                     }\n-                    this.referenceTypeIsInitialized((Instruction)o, rFromStack);\n+                    this.referenceTypeIsInitialized((Instruction)o, r);\n                 }\n                 else {\n-                    this.constraintViolated((Instruction)o, \"Expecting a '\" + fromDesc + \"' but found a '\" + fromStack + \"' on the stack.\");\n+                    this.constraintViolated((Instruction)o, \"Expecting a '\" + int1 + \"' but found a '\" + peek + \"' on the stack.\");\n                 }\n             }\n         }\n-        return nargs;\n+        return length;\n     }\n     \n     public void visitINVOKESPECIAL(final INVOKESPECIAL o) {\n         try {\n             if (o.getMethodName(this.cpg).equals(\"<init>\") && !(this.stack().peek(o.getArgumentTypes(this.cpg).length) instanceof UninitializedObjectType)) {\n                 this.constraintViolated((Instruction)o, \"Possibly initializing object twice. A valid instruction sequence must not have an uninitialized object on the operand stack or in a local variable during a backwards branch, or in a local variable in code protected by an exception handler. Please see The Java Virtual Machine Specification, Second Edition, 4.9.4 (pages 147 and 148) for details.\");\n             }\n-            final int nargs = this.visitInvokeInternals((InvokeInstruction)o);\n-            Type objref = this.stack().peek(nargs);\n-            if (objref == Type.NULL) {\n+            Object o2 = this.stack().peek(this.visitInvokeInternals((InvokeInstruction)o));\n+            if (o2 == Type.NULL) {\n                 return;\n             }\n-            if (!(objref instanceof ReferenceType)) {\n-                this.constraintViolated((Instruction)o, \"Expecting a reference type as 'objectref' on the stack, not a '\" + objref + \"'.\");\n+            if (!(o2 instanceof ReferenceType)) {\n+                this.constraintViolated((Instruction)o, \"Expecting a reference type as 'objectref' on the stack, not a '\" + o2 + \"'.\");\n             }\n-            String objRefClassName = null;\n+            String s;\n             if (!o.getMethodName(this.cpg).equals(\"<init>\")) {\n-                this.referenceTypeIsInitialized((Instruction)o, (ReferenceType)objref);\n-                if (!(objref instanceof ObjectType)) {\n-                    if (!(objref instanceof ArrayType)) {\n-                        this.constraintViolated((Instruction)o, \"Expecting an ObjectType as 'objectref' on the stack, not a '\" + objref + \"'.\");\n+                this.referenceTypeIsInitialized((Instruction)o, (ReferenceType)o2);\n+                if (!(o2 instanceof ObjectType)) {\n+                    if (!(o2 instanceof ArrayType)) {\n+                        this.constraintViolated((Instruction)o, \"Expecting an ObjectType as 'objectref' on the stack, not a '\" + o2 + \"'.\");\n                     }\n                     else {\n-                        objref = (Type)InstConstraintVisitor.GENERIC_ARRAY;\n+                        o2 = InstConstraintVisitor.GENERIC_ARRAY;\n                     }\n                 }\n-                objRefClassName = ((ObjectType)objref).getClassName();\n+                s = ((ObjectType)o2).getClassName();\n             }\n             else {\n-                if (!(objref instanceof UninitializedObjectType)) {\n-                    this.constraintViolated((Instruction)o, \"Expecting an UninitializedObjectType as 'objectref' on the stack, not a '\" + objref + \"'. Otherwise, you couldn't invoke a method since an array has no methods (not to speak of a return address).\");\n+                if (!(o2 instanceof UninitializedObjectType)) {\n+                    this.constraintViolated((Instruction)o, \"Expecting an UninitializedObjectType as 'objectref' on the stack, not a '\" + o2 + \"'. Otherwise, you couldn't invoke a method since an array has no methods (not to speak of a return address).\");\n                 }\n-                objRefClassName = ((UninitializedObjectType)objref).getInitialized().getClassName();\n+                s = ((UninitializedObjectType)o2).getInitialized().getClassName();\n             }\n-            final String theClass = o.getClassName(this.cpg);\n-            if (!Repository.instanceOf(objRefClassName, theClass)) {\n-                this.constraintViolated((Instruction)o, \"The 'objref' item '\" + objref + \"' does not implement '\" + theClass + \"' as expected.\");\n+            final String className = o.getClassName(this.cpg);\n+            if (!Repository.instanceOf(s, className)) {\n+                this.constraintViolated((Instruction)o, \"The 'objref' item '\" + o2 + \"' does not implement '\" + className + \"' as expected.\");\n             }\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj, (Throwable)obj);\n         }\n     }\n     \n     public void visitINVOKESTATIC(final INVOKESTATIC o) {\n         try {\n             this.visitInvokeInternals((InvokeInstruction)o);\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj, (Throwable)obj);\n         }\n     }\n     \n     public void visitINVOKEVIRTUAL(final INVOKEVIRTUAL o) {\n         try {\n-            final int nargs = this.visitInvokeInternals((InvokeInstruction)o);\n-            Type objref = this.stack().peek(nargs);\n-            if (objref == Type.NULL) {\n+            Object obj = this.stack().peek(this.visitInvokeInternals((InvokeInstruction)o));\n+            if (obj == Type.NULL) {\n                 return;\n             }\n-            if (!(objref instanceof ReferenceType)) {\n-                this.constraintViolated((Instruction)o, \"Expecting a reference type as 'objectref' on the stack, not a '\" + objref + \"'.\");\n+            if (!(obj instanceof ReferenceType)) {\n+                this.constraintViolated((Instruction)o, \"Expecting a reference type as 'objectref' on the stack, not a '\" + obj + \"'.\");\n             }\n-            this.referenceTypeIsInitialized((Instruction)o, (ReferenceType)objref);\n-            if (!(objref instanceof ObjectType)) {\n-                if (!(objref instanceof ArrayType)) {\n-                    this.constraintViolated((Instruction)o, \"Expecting an ObjectType as 'objectref' on the stack, not a '\" + objref + \"'.\");\n+            this.referenceTypeIsInitialized((Instruction)o, (ReferenceType)obj);\n+            if (!(obj instanceof ObjectType)) {\n+                if (!(obj instanceof ArrayType)) {\n+                    this.constraintViolated((Instruction)o, \"Expecting an ObjectType as 'objectref' on the stack, not a '\" + obj + \"'.\");\n                 }\n                 else {\n-                    objref = (Type)InstConstraintVisitor.GENERIC_ARRAY;\n+                    obj = InstConstraintVisitor.GENERIC_ARRAY;\n                 }\n             }\n-            final String objRefClassName = ((ObjectType)objref).getClassName();\n-            final String theClass = o.getClassName(this.cpg);\n-            if (!Repository.instanceOf(objRefClassName, theClass)) {\n-                this.constraintViolated((Instruction)o, \"The 'objref' item '\" + objref + \"' does not implement '\" + theClass + \"' as expected.\");\n+            final String className = ((ObjectType)obj).getClassName();\n+            final String className2 = o.getClassName(this.cpg);\n+            if (!Repository.instanceOf(className, className2)) {\n+                this.constraintViolated((Instruction)o, \"The 'objref' item '\" + obj + \"' does not implement '\" + className2 + \"' as expected.\");\n             }\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj2) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj2, (Throwable)obj2);\n         }\n     }\n     \n     public void visitIOR(final IOR o) {\n         if (this.stack().peek() != Type.INT) {\n             this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n@@ -1411,16 +1384,15 @@\n         this.indexOfInt((Instruction)o, this.stack().peek());\n         if (this.stack().peek(1) == Type.NULL) {\n             return;\n         }\n         if (!(this.stack().peek(1) instanceof ArrayType)) {\n             this.constraintViolated((Instruction)o, \"Stack next-to-top must be of type long[] but is '\" + this.stack().peek(1) + \"'.\");\n         }\n-        final Type t = ((ArrayType)this.stack().peek(1)).getBasicType();\n-        if (t != Type.LONG) {\n+        if (((ArrayType)this.stack().peek(1)).getBasicType() != Type.LONG) {\n             this.constraintViolated((Instruction)o, \"Stack next-to-top must be of type long[] but is '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n     public void visitLAND(final LAND o) {\n         if (this.stack().peek() != Type.LONG) {\n             this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n@@ -1437,16 +1409,15 @@\n         this.indexOfInt((Instruction)o, this.stack().peek(1));\n         if (this.stack().peek(2) == Type.NULL) {\n             return;\n         }\n         if (!(this.stack().peek(2) instanceof ArrayType)) {\n             this.constraintViolated((Instruction)o, \"Stack next-to-next-to-top must be of type long[] but is '\" + this.stack().peek(2) + \"'.\");\n         }\n-        final Type t = ((ArrayType)this.stack().peek(2)).getBasicType();\n-        if (t != Type.LONG) {\n+        if (((ArrayType)this.stack().peek(2)).getBasicType() != Type.LONG) {\n             this.constraintViolated((Instruction)o, \"Stack next-to-next-to-top must be of type long[] but is '\" + this.stack().peek(2) + \"'.\");\n         }\n     }\n     \n     public void visitLCMP(final LCMP o) {\n         if (this.stack().peek() != Type.LONG) {\n             this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n@@ -1456,31 +1427,31 @@\n         }\n     }\n     \n     public void visitLCONST(final LCONST o) {\n     }\n     \n     public void visitLDC(final LDC o) {\n-        final Constant c = this.cpg.getConstant(o.getIndex());\n-        if (!(c instanceof ConstantInteger) && !(c instanceof ConstantFloat) && !(c instanceof ConstantString) && !(c instanceof ConstantClass)) {\n-            this.constraintViolated((Instruction)o, \"Referenced constant should be a CONSTANT_Integer, a CONSTANT_Float, a CONSTANT_String or a CONSTANT_Class, but is '\" + c + \"'.\");\n+        final Constant constant = this.cpg.getConstant(o.getIndex());\n+        if (!(constant instanceof ConstantInteger) && !(constant instanceof ConstantFloat) && !(constant instanceof ConstantString) && !(constant instanceof ConstantClass)) {\n+            this.constraintViolated((Instruction)o, \"Referenced constant should be a CONSTANT_Integer, a CONSTANT_Float, a CONSTANT_String or a CONSTANT_Class, but is '\" + constant + \"'.\");\n         }\n     }\n     \n     public void visitLDC_W(final LDC_W o) {\n-        final Constant c = this.cpg.getConstant(o.getIndex());\n-        if (!(c instanceof ConstantInteger) && !(c instanceof ConstantFloat) && !(c instanceof ConstantString) && !(c instanceof ConstantClass)) {\n-            this.constraintViolated((Instruction)o, \"Referenced constant should be a CONSTANT_Integer, a CONSTANT_Float, a CONSTANT_String or a CONSTANT_Class, but is '\" + c + \"'.\");\n+        final Constant constant = this.cpg.getConstant(o.getIndex());\n+        if (!(constant instanceof ConstantInteger) && !(constant instanceof ConstantFloat) && !(constant instanceof ConstantString) && !(constant instanceof ConstantClass)) {\n+            this.constraintViolated((Instruction)o, \"Referenced constant should be a CONSTANT_Integer, a CONSTANT_Float, a CONSTANT_String or a CONSTANT_Class, but is '\" + constant + \"'.\");\n         }\n     }\n     \n     public void visitLDC2_W(final LDC2_W o) {\n-        final Constant c = this.cpg.getConstant(o.getIndex());\n-        if (!(c instanceof ConstantLong) && !(c instanceof ConstantDouble)) {\n-            this.constraintViolated((Instruction)o, \"Referenced constant should be a CONSTANT_Integer, a CONSTANT_Float or a CONSTANT_String, but is '\" + c + \"'.\");\n+        final Constant constant = this.cpg.getConstant(o.getIndex());\n+        if (!(constant instanceof ConstantLong) && !(constant instanceof ConstantDouble)) {\n+            this.constraintViolated((Instruction)o, \"Referenced constant should be a CONSTANT_Integer, a CONSTANT_Float or a CONSTANT_String, but is '\" + constant + \"'.\");\n         }\n     }\n     \n     public void visitLDIV(final LDIV o) {\n         if (this.stack().peek() != Type.LONG) {\n             this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n         }\n@@ -1504,20 +1475,19 @@\n     public void visitLNEG(final LNEG o) {\n         if (this.stack().peek() != Type.LONG) {\n             this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n     public void visitLoadClass(final LoadClass o) {\n-        final ObjectType t = o.getLoadClassType(this.cpg);\n-        if (t != null) {\n-            final Verifier v = VerifierFactory.getVerifier(t.getClassName());\n-            final VerificationResult vr = v.doPass2();\n-            if (vr.getStatus() != 1) {\n-                this.constraintViolated((Instruction)o, \"Class '\" + o.getLoadClassType(this.cpg).getClassName() + \"' is referenced, but cannot be loaded and resolved: '\" + vr + \"'.\");\n+        final ObjectType loadClassType = o.getLoadClassType(this.cpg);\n+        if (loadClassType != null) {\n+            final VerificationResult doPass2 = VerifierFactory.getVerifier(loadClassType.getClassName()).doPass2();\n+            if (doPass2.getStatus() != 1) {\n+                this.constraintViolated((Instruction)o, \"Class '\" + o.getLoadClassType(this.cpg).getClassName() + \"' is referenced, but cannot be loaded and resolved: '\" + doPass2 + \"'.\");\n             }\n         }\n     }\n     \n     public void visitLoadInstruction(final LoadInstruction o) {\n         if (this.locals().get(o.getIndex()) == Type.UNKNOWN) {\n             this.constraintViolated((Instruction)o, \"Read-Access on local variable \" + o.getIndex() + \" with unknown content.\");\n@@ -1631,37 +1601,37 @@\n     public void visitMONITOREXIT(final MONITOREXIT o) {\n         if (!(this.stack().peek() instanceof ReferenceType)) {\n             this.constraintViolated((Instruction)o, \"The stack top should be of a ReferenceType, but is '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n     public void visitMULTIANEWARRAY(final MULTIANEWARRAY o) {\n-        for (int dimensions = o.getDimensions(), i = 0; i < dimensions; ++i) {\n-            if (this.stack().peek(i) != Type.INT) {\n+        for (short dimensions = o.getDimensions(), n = 0; n < dimensions; ++n) {\n+            if (this.stack().peek((int)n) != Type.INT) {\n                 this.constraintViolated((Instruction)o, \"The '\" + dimensions + \"' upper stack types should be 'int' but aren't.\");\n             }\n         }\n     }\n     \n     public void visitNEW(final NEW o) {\n-        final Type t = o.getType(this.cpg);\n-        if (!(t instanceof ReferenceType)) {\n+        final Type type = o.getType(this.cpg);\n+        if (!(type instanceof ReferenceType)) {\n             throw new AssertionViolatedException(\"NEW.getType() returning a non-reference type?!\");\n         }\n-        if (!(t instanceof ObjectType)) {\n-            this.constraintViolated((Instruction)o, \"Expecting a class type (ObjectType) to work on. Found: '\" + t + \"'.\");\n+        if (!(type instanceof ObjectType)) {\n+            this.constraintViolated((Instruction)o, \"Expecting a class type (ObjectType) to work on. Found: '\" + type + \"'.\");\n         }\n-        final ObjectType obj = (ObjectType)t;\n+        final ObjectType objectType = (ObjectType)type;\n         try {\n-            if (!obj.referencesClassExact()) {\n-                this.constraintViolated((Instruction)o, \"Expecting a class type (ObjectType) to work on. Found: '\" + obj + \"'.\");\n+            if (!objectType.referencesClassExact()) {\n+                this.constraintViolated((Instruction)o, \"Expecting a class type (ObjectType) to work on. Found: '\" + objectType + \"'.\");\n             }\n         }\n-        catch (final ClassNotFoundException e) {\n-            this.constraintViolated((Instruction)o, \"Expecting a class type (ObjectType) to work on. Found: '\" + obj + \"'. which threw \" + e);\n+        catch (final ClassNotFoundException obj) {\n+            this.constraintViolated((Instruction)o, \"Expecting a class type (ObjectType) to work on. Found: '\" + objectType + \"'. which threw \" + obj);\n         }\n     }\n     \n     public void visitNEWARRAY(final NEWARRAY o) {\n         if (this.stack().peek() != Type.INT) {\n             this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n@@ -1680,51 +1650,51 @@\n         if (this.stack().peek().getSize() != 2) {\n             this.constraintViolated((Instruction)o, \"Stack top size should be 2 but stack top is '\" + this.stack().peek() + \"' of size '\" + this.stack().peek().getSize() + \"'.\");\n         }\n     }\n     \n     public void visitPUTFIELD(final PUTFIELD o) {\n         try {\n-            final Type objectref = this.stack().peek(1);\n-            if (!(objectref instanceof ObjectType) && objectref != Type.NULL) {\n-                this.constraintViolated((Instruction)o, \"Stack next-to-top should be an object reference that's not an array reference, but is '\" + objectref + \"'.\");\n-            }\n-            final Field f = this.visitFieldInstructionInternals((FieldInstruction)o);\n-            if (f.isProtected()) {\n-                final ObjectType classtype = this.getObjectType((FieldInstruction)o);\n-                final ObjectType curr = ObjectType.getInstance(this.mg.getClassName());\n-                if (classtype.equals((Object)curr) || curr.subclassOf(classtype)) {\n-                    final Type tp = this.stack().peek(1);\n-                    if (tp == Type.NULL) {\n+            final Type peek = this.stack().peek(1);\n+            if (!(peek instanceof ObjectType) && peek != Type.NULL) {\n+                this.constraintViolated((Instruction)o, \"Stack next-to-top should be an object reference that's not an array reference, but is '\" + peek + \"'.\");\n+            }\n+            final Field visitFieldInstructionInternals = this.visitFieldInstructionInternals((FieldInstruction)o);\n+            if (visitFieldInstructionInternals.isProtected()) {\n+                final ObjectType objectType = this.getObjectType((FieldInstruction)o);\n+                final ObjectType instance = ObjectType.getInstance(this.mg.getClassName());\n+                if (objectType.equals((Object)instance) || instance.subclassOf(objectType)) {\n+                    final Type peek2 = this.stack().peek(1);\n+                    if (peek2 == Type.NULL) {\n                         return;\n                     }\n-                    if (!(tp instanceof ObjectType)) {\n-                        this.constraintViolated((Instruction)o, \"The 'objectref' must refer to an object that's not an array. Found instead: '\" + tp + \"'.\");\n+                    if (!(peek2 instanceof ObjectType)) {\n+                        this.constraintViolated((Instruction)o, \"The 'objectref' must refer to an object that's not an array. Found instead: '\" + peek2 + \"'.\");\n                     }\n-                    final ObjectType objreftype = (ObjectType)tp;\n-                    if (!objreftype.equals((Object)curr) && !objreftype.subclassOf(curr)) {\n+                    final ObjectType objectType2 = (ObjectType)peek2;\n+                    if (!objectType2.equals((Object)instance) && !objectType2.subclassOf(instance)) {\n                         this.constraintViolated((Instruction)o, \"The referenced field has the ACC_PROTECTED modifier, and it's a member of the current class or a superclass of the current class. However, the referenced object type '\" + this.stack().peek() + \"' is not the current class or a subclass of the current class.\");\n                     }\n                 }\n             }\n-            if (f.isStatic()) {\n-                this.constraintViolated((Instruction)o, \"Referenced field '\" + f + \"' is static which it shouldn't be.\");\n+            if (visitFieldInstructionInternals.isStatic()) {\n+                this.constraintViolated((Instruction)o, \"Referenced field '\" + visitFieldInstructionInternals + \"' is static which it shouldn't be.\");\n             }\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj, (Throwable)obj);\n         }\n     }\n     \n     public void visitPUTSTATIC(final PUTSTATIC o) {\n         try {\n             this.visitFieldInstructionInternals((FieldInstruction)o);\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj, (Throwable)obj);\n         }\n     }\n     \n     public void visitRET(final RET o) {\n         if (!(this.locals().get(o.getIndex()) instanceof ReturnaddressType)) {\n             this.constraintViolated((Instruction)o, \"Expecting a ReturnaddressType in local variable \" + o.getIndex() + \".\");\n         }\n@@ -1736,51 +1706,50 @@\n     public void visitRETURN(final RETURN o) {\n         if (this.mg.getName().equals(\"<init>\") && Frame.getThis() != null && !this.mg.getClassName().equals(Type.OBJECT.getClassName())) {\n             this.constraintViolated((Instruction)o, \"Leaving a constructor that itself did not call a constructor.\");\n         }\n     }\n     \n     public void visitReturnInstruction(final ReturnInstruction o) {\n-        Type methodType = this.mg.getType();\n-        if (methodType == Type.BOOLEAN || methodType == Type.BYTE || methodType == Type.SHORT || methodType == Type.CHAR) {\n-            methodType = (Type)Type.INT;\n+        Object obj = this.mg.getType();\n+        if (obj == Type.BOOLEAN || obj == Type.BYTE || obj == Type.SHORT || obj == Type.CHAR) {\n+            obj = Type.INT;\n         }\n         if (o instanceof RETURN) {\n-            if (methodType == Type.VOID) {\n+            if (obj == Type.VOID) {\n                 return;\n             }\n             this.constraintViolated((Instruction)o, \"RETURN instruction in non-void method.\");\n         }\n         if (o instanceof ARETURN) {\n-            if (methodType == Type.VOID) {\n+            if (obj == Type.VOID) {\n                 this.constraintViolated((Instruction)o, \"ARETURN instruction in void method.\");\n             }\n             if (this.stack().peek() == Type.NULL) {\n                 return;\n             }\n             if (!(this.stack().peek() instanceof ReferenceType)) {\n                 this.constraintViolated((Instruction)o, \"Reference type expected on top of stack, but is: '\" + this.stack().peek() + \"'.\");\n             }\n             this.referenceTypeIsInitialized((Instruction)o, (ReferenceType)this.stack().peek());\n         }\n-        else if (!methodType.equals((Object)this.stack().peek())) {\n-            this.constraintViolated((Instruction)o, \"Current method has return type of '\" + this.mg.getType() + \"' expecting a '\" + methodType + \"' on top of the stack. But stack top is a '\" + this.stack().peek() + \"'.\");\n+        else if (!((Type)obj).equals((Object)this.stack().peek())) {\n+            this.constraintViolated((Instruction)o, \"Current method has return type of '\" + this.mg.getType() + \"' expecting a '\" + obj + \"' on top of the stack. But stack top is a '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n     public void visitSALOAD(final SALOAD o) {\n         this.indexOfInt((Instruction)o, this.stack().peek());\n         if (this.stack().peek(1) == Type.NULL) {\n             return;\n         }\n         if (!(this.stack().peek(1) instanceof ArrayType)) {\n             this.constraintViolated((Instruction)o, \"Stack next-to-top must be of type short[] but is '\" + this.stack().peek(1) + \"'.\");\n         }\n-        final Type t = ((ArrayType)this.stack().peek(1)).getBasicType();\n-        if (t != Type.SHORT) {\n+        if (((ArrayType)this.stack().peek(1)).getBasicType() != Type.SHORT) {\n             this.constraintViolated((Instruction)o, \"Stack next-to-top must be of type short[] but is '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n     public void visitSASTORE(final SASTORE o) {\n         if (this.stack().peek() != Type.INT) {\n             this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n@@ -1788,31 +1757,30 @@\n         this.indexOfInt((Instruction)o, this.stack().peek(1));\n         if (this.stack().peek(2) == Type.NULL) {\n             return;\n         }\n         if (!(this.stack().peek(2) instanceof ArrayType)) {\n             this.constraintViolated((Instruction)o, \"Stack next-to-next-to-top must be of type short[] but is '\" + this.stack().peek(2) + \"'.\");\n         }\n-        final Type t = ((ArrayType)this.stack().peek(2)).getBasicType();\n-        if (t != Type.SHORT) {\n+        if (((ArrayType)this.stack().peek(2)).getBasicType() != Type.SHORT) {\n             this.constraintViolated((Instruction)o, \"Stack next-to-next-to-top must be of type short[] but is '\" + this.stack().peek(2) + \"'.\");\n         }\n     }\n     \n     public void visitSIPUSH(final SIPUSH o) {\n     }\n     \n     private void visitStackAccessor(final Instruction o) {\n-        final int consume = o.consumeStack(this.cpg);\n-        if (consume > this.stack().slotsUsed()) {\n-            this.constraintViolated(o, \"Cannot consume \" + consume + \" stack slots: only \" + this.stack().slotsUsed() + \" slot(s) left on stack!\\nStack:\\n\" + this.stack());\n-        }\n-        final int produce = o.produceStack(this.cpg) - o.consumeStack(this.cpg);\n-        if (produce + this.stack().slotsUsed() > this.stack().maxStack()) {\n-            this.constraintViolated(o, \"Cannot produce \" + produce + \" stack slots: only \" + (this.stack().maxStack() - this.stack().slotsUsed()) + \" free stack slot(s) left.\\nStack:\\n\" + this.stack());\n+        final int consumeStack = o.consumeStack(this.cpg);\n+        if (consumeStack > this.stack().slotsUsed()) {\n+            this.constraintViolated(o, \"Cannot consume \" + consumeStack + \" stack slots: only \" + this.stack().slotsUsed() + \" slot(s) left on stack!\\nStack:\\n\" + this.stack());\n+        }\n+        final int i = o.produceStack(this.cpg) - o.consumeStack(this.cpg);\n+        if (i + this.stack().slotsUsed() > this.stack().maxStack()) {\n+            this.constraintViolated(o, \"Cannot produce \" + i + \" stack slots: only \" + (this.stack().maxStack() - this.stack().slotsUsed()) + \" free stack slot(s) left.\\nStack:\\n\" + this.stack());\n         }\n     }\n     \n     public void visitStackConsumer(final StackConsumer o) {\n         this.visitStackAccessor((Instruction)o);\n     }\n     \n@@ -1830,16 +1798,16 @@\n         }\n         if (!(o instanceof ASTORE)) {\n             if (this.stack().peek() != o.getType(this.cpg)) {\n                 this.constraintViolated((Instruction)o, \"Stack top type and STOREing Instruction type mismatch: Stack top: '\" + this.stack().peek() + \"'; Instruction type: '\" + o.getType(this.cpg) + \"'.\");\n             }\n         }\n         else {\n-            final Type stacktop = this.stack().peek();\n-            if (!(stacktop instanceof ReferenceType) && !(stacktop instanceof ReturnaddressType)) {\n+            final Type peek = this.stack().peek();\n+            if (!(peek instanceof ReferenceType) && !(peek instanceof ReturnaddressType)) {\n                 this.constraintViolated((Instruction)o, \"Stack top type and STOREing Instruction type mismatch: Stack top: '\" + this.stack().peek() + \"'; Instruction expects a ReferenceType or a ReturnadressType.\");\n             }\n         }\n     }\n     \n     public void visitSWAP(final SWAP o) {\n         if (this.stack().peek().getSize() != 1) {\n"}]}
