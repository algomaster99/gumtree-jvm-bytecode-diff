{"diffoscope-json-version": 1, "source1": "first/RandomUtils.class", "source2": "second/RandomUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -7,77 +7,77 @@\n {\n     private static final Random RANDOM;\n     \n     public static boolean nextBoolean() {\n         return RandomUtils.RANDOM.nextBoolean();\n     }\n     \n-    public static byte[] nextBytes(final int count) {\n-        Validate.isTrue(count >= 0, \"Count cannot be negative.\", new Object[0]);\n-        final byte[] result = new byte[count];\n-        RandomUtils.RANDOM.nextBytes(result);\n-        return result;\n+    public static byte[] nextBytes(final int n) {\n+        Validate.isTrue(n >= 0, \"Count cannot be negative.\", new Object[0]);\n+        final byte[] bytes = new byte[n];\n+        RandomUtils.RANDOM.nextBytes(bytes);\n+        return bytes;\n     }\n     \n-    public static int nextInt(final int startInclusive, final int endExclusive) {\n-        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\", new Object[0]);\n-        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\", new Object[0]);\n-        if (startInclusive == endExclusive) {\n-            return startInclusive;\n+    public static int nextInt(final int n, final int n2) {\n+        Validate.isTrue(n2 >= n, \"Start value must be smaller or equal to end value.\", new Object[0]);\n+        Validate.isTrue(n >= 0, \"Both range values must be non-negative.\", new Object[0]);\n+        if (n == n2) {\n+            return n;\n         }\n-        return startInclusive + RandomUtils.RANDOM.nextInt(endExclusive - startInclusive);\n+        return n + RandomUtils.RANDOM.nextInt(n2 - n);\n     }\n     \n     public static int nextInt() {\n         return nextInt(0, Integer.MAX_VALUE);\n     }\n     \n-    public static long nextLong(final long startInclusive, final long endExclusive) {\n-        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\", new Object[0]);\n-        Validate.isTrue(startInclusive >= 0L, \"Both range values must be non-negative.\", new Object[0]);\n-        if (startInclusive == endExclusive) {\n-            return startInclusive;\n+    public static long nextLong(final long n, final long n2) {\n+        Validate.isTrue(n2 >= n, \"Start value must be smaller or equal to end value.\", new Object[0]);\n+        Validate.isTrue(n >= 0L, \"Both range values must be non-negative.\", new Object[0]);\n+        if (n == n2) {\n+            return n;\n         }\n-        return startInclusive + nextLong(endExclusive - startInclusive);\n+        return n + nextLong(n2 - n);\n     }\n     \n     public static long nextLong() {\n         return nextLong(Long.MAX_VALUE);\n     }\n     \n     private static long nextLong(final long n) {\n-        long bits;\n-        long val;\n+        long n2;\n+        long n3;\n         do {\n-            bits = RandomUtils.RANDOM.nextLong() >>> 1;\n-            val = bits % n;\n-        } while (bits - val + (n - 1L) < 0L);\n-        return val;\n+            n2 = RandomUtils.RANDOM.nextLong() >>> 1;\n+            n3 = n2 % n;\n+        } while (n2 - n3 + (n - 1L) < 0L);\n+        return n3;\n     }\n     \n-    public static double nextDouble(final double startInclusive, final double endExclusive) {\n-        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\", new Object[0]);\n-        Validate.isTrue(startInclusive >= 0.0, \"Both range values must be non-negative.\", new Object[0]);\n-        if (startInclusive == endExclusive) {\n-            return startInclusive;\n+    public static double nextDouble(final double n, final double n2) {\n+        Validate.isTrue(n2 >= n, \"Start value must be smaller or equal to end value.\", new Object[0]);\n+        Validate.isTrue(n >= 0.0, \"Both range values must be non-negative.\", new Object[0]);\n+        if (n == n2) {\n+            return n;\n         }\n-        return startInclusive + (endExclusive - startInclusive) * RandomUtils.RANDOM.nextDouble();\n+        return n + (n2 - n) * RandomUtils.RANDOM.nextDouble();\n     }\n     \n     public static double nextDouble() {\n         return nextDouble(0.0, Double.MAX_VALUE);\n     }\n     \n-    public static float nextFloat(final float startInclusive, final float endExclusive) {\n-        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\", new Object[0]);\n-        Validate.isTrue(startInclusive >= 0.0f, \"Both range values must be non-negative.\", new Object[0]);\n-        if (startInclusive == endExclusive) {\n-            return startInclusive;\n+    public static float nextFloat(final float n, final float n2) {\n+        Validate.isTrue(n2 >= n, \"Start value must be smaller or equal to end value.\", new Object[0]);\n+        Validate.isTrue(n >= 0.0f, \"Both range values must be non-negative.\", new Object[0]);\n+        if (n == n2) {\n+            return n;\n         }\n-        return startInclusive + (endExclusive - startInclusive) * RandomUtils.RANDOM.nextFloat();\n+        return n + (n2 - n) * RandomUtils.RANDOM.nextFloat();\n     }\n     \n     public static float nextFloat() {\n         return nextFloat(0.0f, Float.MAX_VALUE);\n     }\n     \n     static {\n"}]}
