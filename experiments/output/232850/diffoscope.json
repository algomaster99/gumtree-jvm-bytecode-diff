{"diffoscope-json-version": 1, "source1": "first/XPathExpressionEngine.class", "source2": "second/XPathExpressionEngine.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -4,16 +4,16 @@\n import org.apache.commons.jxpath.ri.model.NodePointerFactory;\n import org.apache.commons.jxpath.ri.JXPathContextReferenceImpl;\n import java.util.Iterator;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.StringTokenizer;\n import java.util.LinkedList;\n-import org.apache.commons.configuration2.tree.NodeAddData;\n import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.configuration2.tree.NodeAddData;\n import java.util.Collections;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.configuration2.tree.QueryResult;\n import java.util.List;\n import org.apache.commons.configuration2.tree.NodeHandler;\n import org.apache.commons.configuration2.tree.ExpressionEngine;\n \n@@ -28,185 +28,183 @@\n     private static final char END_INDEX = ']';\n     private final XPathContextFactory contextFactory;\n     \n     public XPathExpressionEngine() {\n         this(new XPathContextFactory());\n     }\n     \n-    XPathExpressionEngine(final XPathContextFactory factory) {\n-        this.contextFactory = factory;\n+    XPathExpressionEngine(final XPathContextFactory contextFactory) {\n+        this.contextFactory = contextFactory;\n     }\n     \n-    public <T> List<QueryResult<T>> query(final T root, final String key, final NodeHandler<T> handler) {\n-        if (StringUtils.isEmpty((CharSequence)key)) {\n-            final QueryResult<T> result = createResult(root);\n-            return Collections.singletonList(result);\n+    public <T> List<QueryResult<T>> query(final T t, final String s, final NodeHandler<T> nodeHandler) {\n+        if (StringUtils.isEmpty((CharSequence)s)) {\n+            return Collections.singletonList(createResult((Object)t));\n         }\n-        final JXPathContext context = this.createContext(root, handler);\n-        List<?> results = context.selectNodes(key);\n-        if (results == null) {\n-            results = Collections.emptyList();\n+        List<Object> list = this.createContext(t, nodeHandler).selectNodes(s);\n+        if (list == null) {\n+            list = Collections.emptyList();\n         }\n-        return convertResults(results);\n+        return (List<QueryResult<T>>)convertResults(list);\n     }\n     \n-    public <T> String nodeKey(final T node, final String parentKey, final NodeHandler<T> handler) {\n-        if (parentKey == null) {\n+    public <T> String nodeKey(final T t, final String str, final NodeHandler<T> nodeHandler) {\n+        if (str == null) {\n             return \"\";\n         }\n-        if (handler.nodeName((Object)node) == null) {\n-            return parentKey;\n+        if (nodeHandler.nodeName((Object)t) == null) {\n+            return str;\n         }\n-        final StringBuilder buf = new StringBuilder(parentKey.length() + handler.nodeName((Object)node).length() + \"/\".length());\n-        if (parentKey.length() > 0) {\n-            buf.append(parentKey);\n-            buf.append(\"/\");\n+        final StringBuilder sb = new StringBuilder(str.length() + nodeHandler.nodeName((Object)t).length() + \"/\".length());\n+        if (str.length() > 0) {\n+            sb.append(str);\n+            sb.append(\"/\");\n         }\n-        buf.append(handler.nodeName((Object)node));\n-        return buf.toString();\n+        sb.append(nodeHandler.nodeName((Object)t));\n+        return sb.toString();\n     }\n     \n-    public String attributeKey(final String parentKey, final String attributeName) {\n-        final StringBuilder buf = new StringBuilder(StringUtils.length((CharSequence)parentKey) + StringUtils.length((CharSequence)attributeName) + \"/\".length() + \"@\".length());\n-        if (StringUtils.isNotEmpty((CharSequence)parentKey)) {\n-            buf.append(parentKey).append(\"/\");\n+    public String attributeKey(final String str, final String str2) {\n+        final StringBuilder sb = new StringBuilder(StringUtils.length((CharSequence)str) + StringUtils.length((CharSequence)str2) + \"/\".length() + \"@\".length());\n+        if (StringUtils.isNotEmpty((CharSequence)str)) {\n+            sb.append(str).append(\"/\");\n         }\n-        buf.append(\"@\").append(attributeName);\n-        return buf.toString();\n+        sb.append(\"@\").append(str2);\n+        return sb.toString();\n     }\n     \n-    public <T> String canonicalKey(final T node, final String parentKey, final NodeHandler<T> handler) {\n-        final T parent = (T)handler.getParent((Object)node);\n+    public <T> String canonicalKey(final T t, final String str, final NodeHandler<T> nodeHandler) {\n+        final Object parent = nodeHandler.getParent((Object)t);\n         if (parent == null) {\n-            return StringUtils.defaultString(parentKey);\n+            return StringUtils.defaultString(str);\n         }\n-        final StringBuilder buf = new StringBuilder(128);\n-        if (StringUtils.isNotEmpty((CharSequence)parentKey)) {\n-            buf.append(parentKey).append(\"/\");\n+        final StringBuilder sb = new StringBuilder(128);\n+        if (StringUtils.isNotEmpty((CharSequence)str)) {\n+            sb.append(str).append(\"/\");\n         }\n-        buf.append(handler.nodeName((Object)node));\n-        buf.append('[');\n-        buf.append(determineIndex(parent, node, handler));\n-        buf.append(']');\n-        return buf.toString();\n+        sb.append(nodeHandler.nodeName((Object)t));\n+        sb.append('[');\n+        sb.append(determineIndex(parent, (Object)t, (org.apache.commons.configuration2.tree.NodeHandler<Object>)nodeHandler));\n+        sb.append(']');\n+        return sb.toString();\n     }\n     \n-    public <T> NodeAddData<T> prepareAdd(final T root, final String key, final NodeHandler<T> handler) {\n-        if (key == null) {\n+    public <T> NodeAddData<T> prepareAdd(final T t, final String str, final NodeHandler<T> nodeHandler) {\n+        if (str == null) {\n             throw new IllegalArgumentException(\"prepareAdd: key must not be null!\");\n         }\n-        String addKey = key;\n-        int index = findKeySeparator(addKey);\n-        if (index < 0) {\n-            addKey = this.generateKeyForAdd(root, addKey, handler);\n-            index = findKeySeparator(addKey);\n-        }\n-        else if (index >= addKey.length() - 1) {\n-            invalidPath(addKey, \" new node path must not be empty.\");\n-        }\n-        final List<QueryResult<T>> nodes = this.query(root, addKey.substring(0, index).trim(), handler);\n-        if (nodes.size() != 1) {\n-            throw new IllegalArgumentException(\"prepareAdd: key '\" + key + \"' must select exactly one target node!\");\n-        }\n-        return this.createNodeAddData(addKey.substring(index).trim(), (org.apache.commons.configuration2.tree.QueryResult<T>)(QueryResult)nodes.get(0));\n-    }\n-    \n-    private <T> JXPathContext createContext(final T root, final NodeHandler<T> handler) {\n-        return this.getContextFactory().createContext((Object)root, (NodeHandler)handler);\n-    }\n-    \n-     <T> NodeAddData<T> createNodeAddData(final String path, final QueryResult<T> parentNodeResult) {\n-        if (parentNodeResult.isAttributeResult()) {\n-            invalidPath(path, \" cannot add properties to an attribute.\");\n-        }\n-        final List<String> pathNodes = new LinkedList<String>();\n-        String lastComponent = null;\n-        boolean attr = false;\n-        boolean first = true;\n-        final StringTokenizer tok = new StringTokenizer(path, \"/@\", true);\n-        while (tok.hasMoreTokens()) {\n-            final String token = tok.nextToken();\n-            if (\"/\".equals(token)) {\n-                if (attr) {\n-                    invalidPath(path, \" contains an attribute delimiter at a disallowed position.\");\n+        String generateKeyForAdd = str;\n+        int n = findKeySeparator(generateKeyForAdd);\n+        if (n < 0) {\n+            generateKeyForAdd = this.generateKeyForAdd(t, generateKeyForAdd, nodeHandler);\n+            n = findKeySeparator(generateKeyForAdd);\n+        }\n+        else if (n >= generateKeyForAdd.length() - 1) {\n+            invalidPath(generateKeyForAdd, \" new node path must not be empty.\");\n+        }\n+        final List<org.apache.commons.configuration2.tree.QueryResult<T>> query = this.query(t, generateKeyForAdd.substring(0, n).trim(), nodeHandler);\n+        if (query.size() != 1) {\n+            throw new IllegalArgumentException(\"prepareAdd: key '\" + str + \"' must select exactly one target node!\");\n+        }\n+        return this.createNodeAddData(generateKeyForAdd.substring(n).trim(), (org.apache.commons.configuration2.tree.QueryResult<T>)(QueryResult)query.get(0));\n+    }\n+    \n+    private <T> JXPathContext createContext(final T t, final NodeHandler<T> nodeHandler) {\n+        return this.getContextFactory().createContext((Object)t, (NodeHandler)nodeHandler);\n+    }\n+    \n+     <T> NodeAddData<T> createNodeAddData(final String str, final QueryResult<T> queryResult) {\n+        if (queryResult.isAttributeResult()) {\n+            invalidPath(str, \" cannot add properties to an attribute.\");\n+        }\n+        final LinkedList list = new LinkedList();\n+        String s = null;\n+        boolean b = false;\n+        int n = 1;\n+        final StringTokenizer stringTokenizer = new StringTokenizer(str, \"/@\", true);\n+        while (stringTokenizer.hasMoreTokens()) {\n+            final String nextToken = stringTokenizer.nextToken();\n+            if (\"/\".equals(nextToken)) {\n+                if (b) {\n+                    invalidPath(str, \" contains an attribute delimiter at a disallowed position.\");\n                 }\n-                if (lastComponent == null) {\n-                    invalidPath(path, \" contains a '/' at a disallowed position.\");\n+                if (s == null) {\n+                    invalidPath(str, \" contains a '/' at a disallowed position.\");\n                 }\n-                pathNodes.add(lastComponent);\n-                lastComponent = null;\n+                list.add(s);\n+                s = null;\n             }\n-            else if (\"@\".equals(token)) {\n-                if (attr) {\n-                    invalidPath(path, \" contains multiple attribute delimiters.\");\n+            else if (\"@\".equals(nextToken)) {\n+                if (b) {\n+                    invalidPath(str, \" contains multiple attribute delimiters.\");\n                 }\n-                if (lastComponent == null && !first) {\n-                    invalidPath(path, \" contains an attribute delimiter at a disallowed position.\");\n+                if (s == null && n == 0) {\n+                    invalidPath(str, \" contains an attribute delimiter at a disallowed position.\");\n                 }\n-                if (lastComponent != null) {\n-                    pathNodes.add(lastComponent);\n+                if (s != null) {\n+                    list.add(s);\n                 }\n-                attr = true;\n-                lastComponent = null;\n+                b = true;\n+                s = null;\n             }\n             else {\n-                lastComponent = token;\n+                s = nextToken;\n             }\n-            first = false;\n+            n = 0;\n         }\n-        if (lastComponent == null) {\n-            invalidPath(path, \"contains no components.\");\n+        if (s == null) {\n+            invalidPath(str, \"contains no components.\");\n         }\n-        return (NodeAddData<T>)new NodeAddData(parentNodeResult.getNode(), lastComponent, attr, (Collection)pathNodes);\n+        return (NodeAddData<T>)new NodeAddData(queryResult.getNode(), s, b, (Collection)list);\n     }\n     \n     XPathContextFactory getContextFactory() {\n         return this.contextFactory;\n     }\n     \n-    private <T> String generateKeyForAdd(final T root, final String key, final NodeHandler<T> handler) {\n-        for (int pos = key.lastIndexOf(\"/\", key.length()); pos >= 0; pos = key.lastIndexOf(\"/\", pos - 1)) {\n-            final String keyExisting = key.substring(0, pos);\n-            if (!this.query(root, keyExisting, handler).isEmpty()) {\n-                final StringBuilder buf = new StringBuilder(key.length() + 1);\n-                buf.append(keyExisting).append(\" \");\n-                buf.append(key.substring(pos + 1));\n-                return buf.toString();\n+    private <T> String generateKeyForAdd(final T t, final String str, final NodeHandler<T> nodeHandler) {\n+        for (int i = str.lastIndexOf(\"/\", str.length()); i >= 0; i = str.lastIndexOf(\"/\", i - 1)) {\n+            final String substring = str.substring(0, i);\n+            if (!this.query(t, substring, nodeHandler).isEmpty()) {\n+                final StringBuilder sb = new StringBuilder(str.length() + 1);\n+                sb.append(substring).append(\" \");\n+                sb.append(str.substring(i + 1));\n+                return sb.toString();\n             }\n         }\n-        return \" \" + key;\n+        return \" \" + str;\n     }\n     \n-    private static <T> int determineIndex(final T parent, final T child, final NodeHandler<T> handler) {\n-        return handler.getChildren((Object)parent, handler.nodeName((Object)child)).indexOf(child) + 1;\n+    private static <T> int determineIndex(final T t, final T t2, final NodeHandler<T> nodeHandler) {\n+        return nodeHandler.getChildren((Object)t, nodeHandler.nodeName((Object)t2)).indexOf(t2) + 1;\n     }\n     \n-    private static void invalidPath(final String path, final String msg) {\n-        throw new IllegalArgumentException(\"Invalid node path: \\\"\" + path + \"\\\" \" + msg);\n+    private static void invalidPath(final String str, final String str2) {\n+        throw new IllegalArgumentException(\"Invalid node path: \\\"\" + str + \"\\\" \" + str2);\n     }\n     \n-    private static int findKeySeparator(final String key) {\n+    private static int findKeySeparator(final String s) {\n         int index;\n-        for (index = key.length() - 1; index >= 0 && !Character.isWhitespace(key.charAt(index)); --index) {}\n+        for (index = s.length() - 1; index >= 0 && !Character.isWhitespace(s.charAt(index)); --index) {}\n         return index;\n     }\n     \n-    private static <T> List<QueryResult<T>> convertResults(final List<?> results) {\n-        final List<QueryResult<T>> queryResults = new ArrayList<QueryResult<T>>(results.size());\n-        for (final Object res : results) {\n-            final QueryResult<T> queryResult = createResult(res);\n-            queryResults.add(queryResult);\n+    private static <T> List<QueryResult<T>> convertResults(final List<?> list) {\n+        final ArrayList list2 = new ArrayList(list.size());\n+        final Iterator iterator = list.iterator();\n+        while (iterator.hasNext()) {\n+            list2.add(createResult(iterator.next()));\n         }\n-        return queryResults;\n+        return list2;\n     }\n     \n-    private static <T> QueryResult<T> createResult(final Object resObj) {\n-        if (resObj instanceof QueryResult) {\n-            return (QueryResult<T>)resObj;\n+    private static <T> QueryResult<T> createResult(final Object o) {\n+        if (o instanceof QueryResult) {\n+            return (QueryResult<T>)o;\n         }\n-        return (QueryResult<T>)QueryResult.createNodeResult(resObj);\n+        return (QueryResult<T>)QueryResult.createNodeResult(o);\n     }\n     \n     static {\n         JXPathContextReferenceImpl.addNodePointerFactory((NodePointerFactory)new ConfigurationNodePointerFactory());\n     }\n }\n"}]}
