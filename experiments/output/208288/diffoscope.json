{"diffoscope-json-version": 1, "source1": "first/IOConsumer.class", "source2": "second/IOConsumer.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -8,52 +8,52 @@\n import org.apache.commons.io.IOIndexedException;\n import java.util.stream.Stream;\n import org.apache.commons.io.IOExceptionList;\n \n @FunctionalInterface\n public interface IOConsumer<T>\n {\n-    public static final IOConsumer<?> NOOP_IO_CONSUMER = t -> {};\n+    public static final IOConsumer<?> NOOP_IO_CONSUMER = p0 -> {};\n     \n-    default <T> void forAll(final IOConsumer<T> action, final Iterable<T> iterable) throws IOExceptionList {\n-        IOStreams.forAll(IOStreams.of((Iterable)iterable), (IOConsumer)action);\n+    default <T> void forAll(final IOConsumer<T> ioConsumer, final Iterable<T> iterable) throws IOExceptionList {\n+        IOStreams.forAll(IOStreams.of((Iterable)iterable), (IOConsumer)ioConsumer);\n     }\n     \n-    default <T> void forAll(final IOConsumer<T> action, final Stream<T> stream) throws IOExceptionList {\n-        IOStreams.forAll((Stream)stream, (IOConsumer)action, (BiFunction)IOIndexedException::new);\n+    default <T> void forAll(final IOConsumer<T> ioConsumer, final Stream<T> stream) throws IOExceptionList {\n+        IOStreams.forAll((Stream)stream, (IOConsumer)ioConsumer, (BiFunction)IOIndexedException::new);\n     }\n     \n     @SafeVarargs\n-    default <T> void forAll(final IOConsumer<T> action, final T... array) throws IOExceptionList {\n-        IOStreams.forAll(IOStreams.of((Object[])array), (IOConsumer)action);\n+    default <T> void forAll(final IOConsumer<T> ioConsumer, final T... array) throws IOExceptionList {\n+        IOStreams.forAll(IOStreams.of((Object[])array), (IOConsumer)ioConsumer);\n     }\n     \n-    default <T> void forEach(final Iterable<T> iterable, final IOConsumer<T> action) throws IOException {\n-        IOStreams.forEach(IOStreams.of((Iterable)iterable), (IOConsumer)action);\n+    default <T> void forEach(final Iterable<T> iterable, final IOConsumer<T> ioConsumer) throws IOException {\n+        IOStreams.forEach(IOStreams.of((Iterable)iterable), (IOConsumer)ioConsumer);\n     }\n     \n-    default <T> void forEach(final Stream<T> stream, final IOConsumer<T> action) throws IOException {\n-        IOStreams.forEach((Stream)stream, (IOConsumer)action);\n+    default <T> void forEach(final Stream<T> stream, final IOConsumer<T> ioConsumer) throws IOException {\n+        IOStreams.forEach((Stream)stream, (IOConsumer)ioConsumer);\n     }\n     \n-    default <T> void forEach(final T[] array, final IOConsumer<T> action) throws IOException {\n-        IOStreams.forEach(IOStreams.of((Object[])array), (IOConsumer)action);\n+    default <T> void forEach(final T[] array, final IOConsumer<T> ioConsumer) throws IOException {\n+        IOStreams.forEach(IOStreams.of((Object[])array), (IOConsumer)ioConsumer);\n     }\n     \n     default <T> IOConsumer<T> noop() {\n         return (IOConsumer<T>)IOConsumer.NOOP_IO_CONSUMER;\n     }\n     \n     void accept(final T p0) throws IOException;\n     \n-    default IOConsumer<T> andThen(final IOConsumer<? super T> after) {\n-        Objects.requireNonNull(after, \"after\");\n-        return t -> {\n-            this.accept(t);\n-            after.accept(t);\n+    default IOConsumer<T> andThen(final IOConsumer<? super T> obj) {\n+        Objects.requireNonNull(obj, \"after\");\n+        return o -> {\n+            this.accept(o);\n+            ioConsumer.accept(o);\n         };\n     }\n     \n     default Consumer<T> asConsumer() {\n-        return t -> Uncheck.accept(this, t);\n+        return o -> Uncheck.accept(this, o);\n     }\n }\n"}]}
