{"diffoscope-json-version": 1, "source1": "first/XmlStreamReader.class", "source2": "second/XmlStreamReader.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -41,14 +41,21 @@\n     private static final String HTTP_EX_1 = \"Invalid encoding, CT-MIME [{0}] CT-Enc [{1}] BOM [{2}] XML guess [{3}] XML prolog [{4}], BOM must be NULL\";\n     private static final String HTTP_EX_2 = \"Invalid encoding, CT-MIME [{0}] CT-Enc [{1}] BOM [{2}] XML guess [{3}] XML prolog [{4}], encoding mismatch\";\n     private static final String HTTP_EX_3 = \"Invalid encoding, CT-MIME [{0}] CT-Enc [{1}] BOM [{2}] XML guess [{3}] XML prolog [{4}], Invalid MIME\";\n     private final Reader reader;\n     private final String encoding;\n     private final String defaultEncoding;\n     \n+    static {\n+        BOMS = new ByteOrderMark[] { ByteOrderMark.UTF_8, ByteOrderMark.UTF_16BE, ByteOrderMark.UTF_16LE, ByteOrderMark.UTF_32BE, ByteOrderMark.UTF_32LE };\n+        XML_GUESS_BYTES = new ByteOrderMark[] { new ByteOrderMark(\"UTF-8\", new int[] { 60, 63, 120, 109 }), new ByteOrderMark(\"UTF-16BE\", new int[] { 0, 60, 0, 63 }), new ByteOrderMark(\"UTF-16LE\", new int[] { 60, 0, 63, 0 }), new ByteOrderMark(\"UTF-32BE\", new int[] { 0, 0, 0, 60, 0, 0, 0, 63, 0, 0, 0, 120, 0, 0, 0, 109 }), new ByteOrderMark(\"UTF-32LE\", new int[] { 60, 0, 0, 0, 63, 0, 0, 0, 120, 0, 0, 0, 109, 0, 0, 0 }), new ByteOrderMark(\"CP1047\", new int[] { 76, 111, 167, 148 }) };\n+        CHARSET_PATTERN = Pattern.compile(\"charset=[\\\"']?([.[^; \\\"']]*)[\\\"']?\");\n+        ENCODING_PATTERN = Pattern.compile(\"<\\\\?xml.*encoding[\\\\s]*=[\\\\s]*((?:\\\".[^\\\"]*\\\")|(?:'.[^']*'))\", 8);\n+    }\n+    \n     static String getContentTypeEncoding(final String httpContentType) {\n         String encoding = null;\n         if (httpContentType != null) {\n             final int i = httpContentType.indexOf(\";\");\n             if (i > -1) {\n                 final String postMime = httpContentType.substring(i + 1);\n                 final Matcher m = XmlStreamReader.CHARSET_PATTERN.matcher(postMime);\n@@ -161,15 +168,14 @@\n     public XmlStreamReader(final URL url) throws IOException {\n         this(((URL)Objects.requireNonNull(url, \"url\")).openConnection(), null);\n     }\n     \n     public XmlStreamReader(final URLConnection conn, final String defaultEncoding) throws IOException {\n         Objects.requireNonNull(conn, \"conn\");\n         this.defaultEncoding = defaultEncoding;\n-        final boolean lenient = true;\n         final String contentType = conn.getContentType();\n         final InputStream inputStream = conn.getInputStream();\n         final BOMInputStream bom = new BOMInputStream((InputStream)new BufferedInputStream(inputStream, 8192), false, XmlStreamReader.BOMS);\n         final BOMInputStream pis = new BOMInputStream((InputStream)bom, true, XmlStreamReader.XML_GUESS_BYTES);\n         if (conn instanceof HttpURLConnection || contentType != null) {\n             this.encoding = this.processHttpStream(bom, pis, contentType, true);\n         }\n@@ -343,15 +349,8 @@\n         }\n     }\n     \n     @Override\n     public int read(final char[] buf, final int offset, final int len) throws IOException {\n         return this.reader.read(buf, offset, len);\n     }\n-    \n-    static {\n-        BOMS = new ByteOrderMark[] { ByteOrderMark.UTF_8, ByteOrderMark.UTF_16BE, ByteOrderMark.UTF_16LE, ByteOrderMark.UTF_32BE, ByteOrderMark.UTF_32LE };\n-        XML_GUESS_BYTES = new ByteOrderMark[] { new ByteOrderMark(\"UTF-8\", new int[] { 60, 63, 120, 109 }), new ByteOrderMark(\"UTF-16BE\", new int[] { 0, 60, 0, 63 }), new ByteOrderMark(\"UTF-16LE\", new int[] { 60, 0, 63, 0 }), new ByteOrderMark(\"UTF-32BE\", new int[] { 0, 0, 0, 60, 0, 0, 0, 63, 0, 0, 0, 120, 0, 0, 0, 109 }), new ByteOrderMark(\"UTF-32LE\", new int[] { 60, 0, 0, 0, 63, 0, 0, 0, 120, 0, 0, 0, 109, 0, 0, 0 }), new ByteOrderMark(\"CP1047\", new int[] { 76, 111, 167, 148 }) };\n-        CHARSET_PATTERN = Pattern.compile(\"charset=[\\\"']?([.[^; \\\"']]*)[\\\"']?\");\n-        ENCODING_PATTERN = Pattern.compile(\"<\\\\?xml.*encoding[\\\\s]*=[\\\\s]*((?:\\\".[^\\\"]*\\\")|(?:'.[^']*'))\", 8);\n-    }\n }\n"}]}
