{"diffoscope-json-version": 1, "source1": "first/PhoneticEngine.class", "source2": "second/PhoneticEngine.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,37 +1,43 @@\n \n package org.apache.commons.codec.language.bm;\n \n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.EnumMap;\n import java.util.Iterator;\n-import java.util.Collection;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Locale;\n import java.util.Comparator;\n import java.util.TreeMap;\n import java.util.Objects;\n import java.util.stream.Collector;\n import java.util.stream.Collectors;\n import java.util.List;\n+import java.util.Collections;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Arrays;\n+import java.util.EnumMap;\n import java.util.Set;\n import java.util.Map;\n \n public class PhoneticEngine\n {\n     private static final int DEFAULT_MAX_PHONEMES = 20;\n     private static final Map<NameType, Set<String>> NAME_PREFIXES;\n     private final Lang lang;\n     private final NameType nameType;\n     private final RuleType ruleType;\n     private final boolean concat;\n     private final int maxPhonemes;\n     \n+    static {\n+        (NAME_PREFIXES = new EnumMap<NameType, Set<String>>(NameType.class)).put(NameType.ASHKENAZI, Collections.unmodifiableSet((Set<? extends String>)new HashSet<String>(Arrays.asList(\"bar\", \"ben\", \"da\", \"de\", \"van\", \"von\"))));\n+        PhoneticEngine.NAME_PREFIXES.put(NameType.SEPHARDIC, Collections.unmodifiableSet((Set<? extends String>)new HashSet<String>(Arrays.asList(\"al\", \"el\", \"da\", \"dal\", \"de\", \"del\", \"dela\", \"de la\", \"della\", \"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\"))));\n+        PhoneticEngine.NAME_PREFIXES.put(NameType.GENERIC, Collections.unmodifiableSet((Set<? extends String>)new HashSet<String>(Arrays.asList(\"da\", \"dal\", \"de\", \"del\", \"dela\", \"de la\", \"della\", \"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\"))));\n+    }\n+    \n     private static String join(final List<String> strings, final String sep) {\n         return strings.stream().collect((Collector<? super Object, ?, String>)Collectors.joining(sep));\n     }\n     \n     public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat) {\n         this(nameType, ruleType, concat, 20);\n     }\n@@ -54,34 +60,34 @@\n         }\n         final Map<Rule.Phoneme, Rule.Phoneme> phonemes = new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);\n         phonemeBuilder.getPhonemes().forEach(phoneme -> {\n             PhoneticEngine.PhonemeBuilder subBuilder = PhoneticEngine.PhonemeBuilder.empty(phoneme.getLanguages());\n             final String phonemeText = phoneme.getPhonemeText().toString();\n             PhoneticEngine.RulesApplication rulesApplication;\n             for (int i = 0; i < phonemeText.length(); i = rulesApplication.getI()) {\n-                rulesApplication = new PhoneticEngine.RulesApplication(finalRules, (CharSequence)phonemeText, subBuilder, i, this.maxPhonemes).invoke();\n+                rulesApplication = new PhoneticEngine.RulesApplication(map, (CharSequence)phonemeText, subBuilder, i, this.maxPhonemes).invoke();\n                 final boolean found = rulesApplication.isFound();\n                 subBuilder = rulesApplication.getPhonemeBuilder();\n                 if (!found) {\n                     subBuilder.append(phonemeText.subSequence(i, i + 1));\n                 }\n             }\n             subBuilder.getPhonemes().forEach(newPhoneme -> {\n-                if (phonemes.containsKey(newPhoneme)) {\n-                    final Rule.Phoneme oldPhoneme = (Rule.Phoneme)phonemes.remove(newPhoneme);\n+                if (map2.containsKey(newPhoneme)) {\n+                    final Rule.Phoneme oldPhoneme = (Rule.Phoneme)map2.remove(newPhoneme);\n                     final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());\n-                    phonemes.put(mergedPhoneme, mergedPhoneme);\n+                    map2.put(mergedPhoneme, mergedPhoneme);\n                 }\n                 else {\n-                    phonemes.put(newPhoneme, newPhoneme);\n+                    map2.put(newPhoneme, newPhoneme);\n                 }\n             });\n             return;\n         });\n-        return new PhoneticEngine.PhonemeBuilder((Set)phonemes.keySet(), (PhoneticEngine.PhoneticEngine$1)null);\n+        return new PhoneticEngine.PhonemeBuilder((Set)phonemes.keySet(), (PhoneticEngine.PhonemeBuilder)null);\n     }\n     \n     public String encode(final String input) {\n         final Languages.LanguageSet languageSet = this.lang.guessLanguages(input);\n         return this.encode(input, languageSet);\n     }\n     \n@@ -93,53 +99,53 @@\n         if (this.nameType == NameType.GENERIC) {\n             if (input.startsWith(\"d'\")) {\n                 final String remainder = input.substring(2);\n                 final String combined = \"d\" + remainder;\n                 return \"(\" + this.encode(remainder) + \")-(\" + this.encode(combined) + \")\";\n             }\n             for (final String l : (Set)PhoneticEngine.NAME_PREFIXES.get(this.nameType)) {\n-                if (input.startsWith(l + \" \")) {\n+                if (input.startsWith(String.valueOf(l) + \" \")) {\n                     final String remainder2 = input.substring(l.length() + 1);\n-                    final String combined2 = l + remainder2;\n+                    final String combined2 = String.valueOf(l) + remainder2;\n                     return \"(\" + this.encode(remainder2) + \")-(\" + this.encode(combined2) + \")\";\n                 }\n             }\n         }\n         final List<String> words = Arrays.asList(input.split(\"\\\\s+\"));\n         final List<String> words2 = new ArrayList<String>();\n-        switch (PhoneticEngine.PhoneticEngine$1.$SwitchMap$org$apache$commons$codec$language$bm$NameType[this.nameType.ordinal()]) {\n-            case 1: {\n+        switch (this.nameType) {\n+            case SEPHARDIC: {\n                 words.forEach(aWord -> {\n                     final String[] parts = aWord.split(\"'\");\n-                    words2.add(parts[parts.length - 1]);\n+                    list.add(parts[parts.length - 1]);\n                     return;\n                 });\n                 words2.removeAll(PhoneticEngine.NAME_PREFIXES.get(this.nameType));\n                 break;\n             }\n-            case 2: {\n+            case ASHKENAZI: {\n                 words2.addAll(words);\n                 words2.removeAll(PhoneticEngine.NAME_PREFIXES.get(this.nameType));\n                 break;\n             }\n-            case 3: {\n+            case GENERIC: {\n                 words2.addAll(words);\n                 break;\n             }\n             default: {\n                 throw new IllegalStateException(\"Unreachable case: \" + this.nameType);\n             }\n         }\n         if (this.concat) {\n             input = join(words2, \" \");\n         }\n         else {\n             if (words2.size() != 1) {\n                 final StringBuilder result = new StringBuilder();\n-                words2.forEach(word -> result.append(\"-\").append(this.encode(word)));\n+                words2.forEach(word -> sb.append(\"-\").append(this.encode(word)));\n                 return result.substring();\n             }\n             input = words.iterator().next();\n         }\n         PhoneticEngine.PhonemeBuilder phonemeBuilder = PhoneticEngine.PhonemeBuilder.empty(languageSet);\n         PhoneticEngine.RulesApplication rulesApplication;\n         for (int i = 0; i < input.length(); i = rulesApplication.getI(), phonemeBuilder = rulesApplication.getPhonemeBuilder()) {\n@@ -165,14 +171,8 @@\n     public boolean isConcat() {\n         return this.concat;\n     }\n     \n     public int getMaxPhonemes() {\n         return this.maxPhonemes;\n     }\n-    \n-    static {\n-        (NAME_PREFIXES = new EnumMap<NameType, Set<String>>(NameType.class)).put(NameType.ASHKENAZI, Collections.unmodifiableSet((Set<? extends String>)new HashSet<String>(Arrays.asList(\"bar\", \"ben\", \"da\", \"de\", \"van\", \"von\"))));\n-        PhoneticEngine.NAME_PREFIXES.put(NameType.SEPHARDIC, Collections.unmodifiableSet((Set<? extends String>)new HashSet<String>(Arrays.asList(\"al\", \"el\", \"da\", \"dal\", \"de\", \"del\", \"dela\", \"de la\", \"della\", \"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\"))));\n-        PhoneticEngine.NAME_PREFIXES.put(NameType.GENERIC, Collections.unmodifiableSet((Set<? extends String>)new HashSet<String>(Arrays.asList(\"da\", \"dal\", \"de\", \"del\", \"dela\", \"de la\", \"della\", \"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\"))));\n-    }\n }\n"}]}
