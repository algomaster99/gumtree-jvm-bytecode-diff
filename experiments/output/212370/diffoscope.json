{"diffoscope-json-version": 1, "source1": "first/ConcurrentUtils.class", "source2": "second/ConcurrentUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -24,79 +24,79 @@\n             return null;\n         }\n         throwCause(ex);\n         return new ConcurrentRuntimeException(ex.getMessage(), ex.getCause());\n     }\n     \n     public static void handleCause(final ExecutionException ex) throws ConcurrentException {\n-        final ConcurrentException cex = extractCause(ex);\n-        if (cex != null) {\n-            throw cex;\n+        final ConcurrentException cause = extractCause(ex);\n+        if (cause != null) {\n+            throw cause;\n         }\n     }\n     \n     public static void handleCauseUnchecked(final ExecutionException ex) {\n-        final ConcurrentRuntimeException crex = extractCauseUnchecked(ex);\n-        if (crex != null) {\n-            throw crex;\n+        final ConcurrentRuntimeException causeUnchecked = extractCauseUnchecked(ex);\n+        if (causeUnchecked != null) {\n+            throw causeUnchecked;\n         }\n     }\n     \n-    static Throwable checkedException(final Throwable ex) {\n-        Validate.isTrue(ex != null && !(ex instanceof RuntimeException) && !(ex instanceof Error), \"Not a checked exception: \" + ex, new Object[0]);\n-        return ex;\n+    static Throwable checkedException(final Throwable obj) {\n+        Validate.isTrue(obj != null && !(obj instanceof RuntimeException) && !(obj instanceof Error), \"Not a checked exception: \" + obj, new Object[0]);\n+        return obj;\n     }\n     \n     private static void throwCause(final ExecutionException ex) {\n         if (ex.getCause() instanceof RuntimeException) {\n             throw (RuntimeException)ex.getCause();\n         }\n         if (ex.getCause() instanceof Error) {\n             throw (Error)ex.getCause();\n         }\n     }\n     \n-    public static <T> T initialize(final ConcurrentInitializer<T> initializer) throws ConcurrentException {\n-        return (T)((initializer != null) ? initializer.get() : null);\n+    public static <T> T initialize(final ConcurrentInitializer<T> concurrentInitializer) throws ConcurrentException {\n+        return (T)((concurrentInitializer != null) ? concurrentInitializer.get() : null);\n     }\n     \n-    public static <T> T initializeUnchecked(final ConcurrentInitializer<T> initializer) {\n+    public static <T> T initializeUnchecked(final ConcurrentInitializer<T> concurrentInitializer) {\n         try {\n-            return (T)initialize((org.apache.commons.lang3.concurrent.ConcurrentInitializer<Object>)initializer);\n+            return (T)initialize((org.apache.commons.lang3.concurrent.ConcurrentInitializer<Object>)concurrentInitializer);\n         }\n-        catch (final ConcurrentException cex) {\n-            throw new ConcurrentRuntimeException(cex.getCause());\n+        catch (final ConcurrentException ex) {\n+            throw new ConcurrentRuntimeException(ex.getCause());\n         }\n     }\n     \n-    public static <K, V> V putIfAbsent(final ConcurrentMap<K, V> map, final K key, final V value) {\n-        if (map == null) {\n+    public static <K, V> V putIfAbsent(final ConcurrentMap<K, V> concurrentMap, final K k, final V v) {\n+        if (concurrentMap == null) {\n             return null;\n         }\n-        final V result = map.putIfAbsent(key, value);\n-        return (result != null) ? result : value;\n+        final V putIfAbsent = concurrentMap.putIfAbsent(k, v);\n+        return (putIfAbsent != null) ? putIfAbsent : v;\n     }\n     \n-    public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) throws ConcurrentException {\n-        if (map == null || init == null) {\n+    public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> concurrentMap, final K k, final ConcurrentInitializer<V> concurrentInitializer) throws ConcurrentException {\n+        if (concurrentMap == null || concurrentInitializer == null) {\n             return null;\n         }\n-        final V value = map.get(key);\n+        final V value = concurrentMap.get(k);\n         if (value == null) {\n-            return putIfAbsent(map, key, (V)init.get());\n+            return putIfAbsent(concurrentMap, k, (V)concurrentInitializer.get());\n         }\n         return value;\n     }\n     \n-    public static <K, V> V createIfAbsentUnchecked(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) {\n+    public static <K, V> V createIfAbsentUnchecked(final ConcurrentMap<K, V> concurrentMap, final K k, final ConcurrentInitializer<V> concurrentInitializer) {\n         try {\n-            return (V)createIfAbsent(map, (Object)key, (org.apache.commons.lang3.concurrent.ConcurrentInitializer<Object>)init);\n+            return (V)createIfAbsent(concurrentMap, (Object)k, (org.apache.commons.lang3.concurrent.ConcurrentInitializer<Object>)concurrentInitializer);\n         }\n-        catch (final ConcurrentException cex) {\n-            throw new ConcurrentRuntimeException(cex.getCause());\n+        catch (final ConcurrentException ex) {\n+            throw new ConcurrentRuntimeException(ex.getCause());\n         }\n     }\n     \n-    public static <T> Future<T> constantFuture(final T value) {\n-        return (Future<T>)new ConcurrentUtils.ConstantFuture((Object)value);\n+    public static <T> Future<T> constantFuture(final T t) {\n+        return (Future<T>)new ConcurrentUtils.ConstantFuture((Object)t);\n     }\n }\n"}]}
