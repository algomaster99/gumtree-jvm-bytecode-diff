{"diffoscope-json-version": 1, "source1": "first/ByteCodeForm.class", "source2": "second/ByteCodeForm.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,119 +1,27 @@\n \n package org.apache.commons.compress.harmony.unpack200.bytecode.forms;\n \n-import java.util.HashMap;\n import org.apache.commons.compress.harmony.unpack200.bytecode.CodeAttribute;\n import org.apache.commons.compress.harmony.unpack200.bytecode.OperandManager;\n import org.apache.commons.compress.harmony.unpack200.bytecode.ByteCode;\n+import java.util.HashMap;\n import java.util.Map;\n \n public abstract class ByteCodeForm\n {\n     protected static final boolean WIDENED = true;\n     protected static final ByteCodeForm[] byteCodeArray;\n     protected static final Map<String, ByteCodeForm> byteCodesByName;\n     private final int opcode;\n     private final String name;\n     private final int[] rewrite;\n     private int firstOperandIndex;\n     private int operandLength;\n     \n-    public ByteCodeForm(final int opcode, final String name) {\n-        this(opcode, name, new int[] { opcode });\n-    }\n-    \n-    public ByteCodeForm(final int opcode, final String name, final int[] rewrite) {\n-        this.opcode = opcode;\n-        this.name = name;\n-        this.rewrite = rewrite;\n-        this.calculateOperandPosition();\n-    }\n-    \n-    protected void calculateOperandPosition() {\n-        this.firstOperandIndex = -1;\n-        this.operandLength = -1;\n-        int iterationIndex = 0;\n-        while (iterationIndex < this.rewrite.length) {\n-            if (this.rewrite[iterationIndex] < 0) {\n-                this.firstOperandIndex = iterationIndex;\n-                iterationIndex = this.rewrite.length;\n-            }\n-            else {\n-                ++iterationIndex;\n-            }\n-        }\n-        if (this.firstOperandIndex == -1) {\n-            return;\n-        }\n-        int lastOperandIndex = -1;\n-        for (iterationIndex = this.firstOperandIndex; iterationIndex < this.rewrite.length; ++iterationIndex) {\n-            if (this.rewrite[iterationIndex] < 0) {\n-                lastOperandIndex = iterationIndex;\n-            }\n-        }\n-        final int difference = lastOperandIndex - this.firstOperandIndex;\n-        if (difference < 0) {\n-            throw new Error(\"Logic error: not finding rewrite operands correctly\");\n-        }\n-        this.operandLength = difference + 1;\n-    }\n-    \n-    public static ByteCodeForm get(final int opcode) {\n-        return ByteCodeForm.byteCodeArray[opcode];\n-    }\n-    \n-    @Override\n-    public String toString() {\n-        return this.getClass().getName() + \"(\" + this.getName() + \")\";\n-    }\n-    \n-    public int getOpcode() {\n-        return this.opcode;\n-    }\n-    \n-    public String getName() {\n-        return this.name;\n-    }\n-    \n-    public int[] getRewrite() {\n-        return this.rewrite;\n-    }\n-    \n-    public int[] getRewriteCopy() {\n-        final int[] result = new int[this.rewrite.length];\n-        System.arraycopy(this.rewrite, 0, result, 0, this.rewrite.length);\n-        return result;\n-    }\n-    \n-    public int firstOperandIndex() {\n-        return this.firstOperandIndex;\n-    }\n-    \n-    public int operandLength() {\n-        return this.operandLength;\n-    }\n-    \n-    public boolean hasNoOperand() {\n-        return false;\n-    }\n-    \n-    public boolean hasMultipleByteCodes() {\n-        return this.rewrite.length > 1 && this.rewrite[0] == 42 && this.rewrite[1] > 0;\n-    }\n-    \n-    public abstract void setByteCodeOperands(final ByteCode p0, final OperandManager p1, final int p2);\n-    \n-    public void fixUpByteCodeTargets(final ByteCode byteCode, final CodeAttribute codeAttribute) {\n-    }\n-    \n-    public boolean nestedMustStartClassPool() {\n-        return false;\n-    }\n-    \n     static {\n         byteCodeArray = new ByteCodeForm[256];\n         byteCodesByName = new HashMap<String, ByteCodeForm>(256);\n         ByteCodeForm.byteCodeArray[0] = (ByteCodeForm)new NoArgumentForm(0, \"nop\");\n         ByteCodeForm.byteCodeArray[1] = (ByteCodeForm)new NoArgumentForm(1, \"aconst_null\");\n         ByteCodeForm.byteCodeArray[2] = (ByteCodeForm)new NoArgumentForm(2, \"iconst_m1\");\n         ByteCodeForm.byteCodeArray[3] = (ByteCodeForm)new NoArgumentForm(3, \"iconst_0\");\n@@ -351,14 +259,108 @@\n         ByteCodeForm.byteCodeArray[235] = (ByteCodeForm)new FloatRefForm(235, \"fldc\", new int[] { 18, -1 });\n         ByteCodeForm.byteCodeArray[236] = (ByteCodeForm)new NarrowClassRefForm(236, \"cldc_w\", new int[] { 19, -1, -1 }, true);\n         ByteCodeForm.byteCodeArray[237] = (ByteCodeForm)new IntRefForm(237, \"ildc_w\", new int[] { 19, -1, -1 }, true);\n         ByteCodeForm.byteCodeArray[238] = (ByteCodeForm)new FloatRefForm(238, \"fldc_w\", new int[] { 19, -1, -1 }, true);\n         ByteCodeForm.byteCodeArray[239] = (ByteCodeForm)new DoubleForm(239, \"dldc2_w\", new int[] { 20, -1, -1 });\n         ByteCodeForm.byteCodeArray[254] = (ByteCodeForm)new NoArgumentForm(254, \"impdep1\");\n         ByteCodeForm.byteCodeArray[255] = (ByteCodeForm)new NoArgumentForm(255, \"impdep2\");\n-        for (final ByteCodeForm byteCode : ByteCodeForm.byteCodeArray) {\n+        ByteCodeForm[] byteCodeArray2;\n+        for (int length = (byteCodeArray2 = ByteCodeForm.byteCodeArray).length, i = 0; i < length; ++i) {\n+            final ByteCodeForm byteCode = byteCodeArray2[i];\n             if (byteCode != null) {\n                 ByteCodeForm.byteCodesByName.put(byteCode.getName(), byteCode);\n             }\n         }\n     }\n+    \n+    public ByteCodeForm(final int opcode, final String name) {\n+        this(opcode, name, new int[] { opcode });\n+    }\n+    \n+    public ByteCodeForm(final int opcode, final String name, final int[] rewrite) {\n+        this.opcode = opcode;\n+        this.name = name;\n+        this.rewrite = rewrite;\n+        this.calculateOperandPosition();\n+    }\n+    \n+    protected void calculateOperandPosition() {\n+        this.firstOperandIndex = -1;\n+        this.operandLength = -1;\n+        int iterationIndex = 0;\n+        while (iterationIndex < this.rewrite.length) {\n+            if (this.rewrite[iterationIndex] < 0) {\n+                this.firstOperandIndex = iterationIndex;\n+                iterationIndex = this.rewrite.length;\n+            }\n+            else {\n+                ++iterationIndex;\n+            }\n+        }\n+        if (this.firstOperandIndex == -1) {\n+            return;\n+        }\n+        int lastOperandIndex = -1;\n+        for (iterationIndex = this.firstOperandIndex; iterationIndex < this.rewrite.length; ++iterationIndex) {\n+            if (this.rewrite[iterationIndex] < 0) {\n+                lastOperandIndex = iterationIndex;\n+            }\n+        }\n+        final int difference = lastOperandIndex - this.firstOperandIndex;\n+        if (difference < 0) {\n+            throw new Error(\"Logic error: not finding rewrite operands correctly\");\n+        }\n+        this.operandLength = difference + 1;\n+    }\n+    \n+    public static ByteCodeForm get(final int opcode) {\n+        return ByteCodeForm.byteCodeArray[opcode];\n+    }\n+    \n+    @Override\n+    public String toString() {\n+        return String.valueOf(this.getClass().getName()) + \"(\" + this.getName() + \")\";\n+    }\n+    \n+    public int getOpcode() {\n+        return this.opcode;\n+    }\n+    \n+    public String getName() {\n+        return this.name;\n+    }\n+    \n+    public int[] getRewrite() {\n+        return this.rewrite;\n+    }\n+    \n+    public int[] getRewriteCopy() {\n+        final int[] result = new int[this.rewrite.length];\n+        System.arraycopy(this.rewrite, 0, result, 0, this.rewrite.length);\n+        return result;\n+    }\n+    \n+    public int firstOperandIndex() {\n+        return this.firstOperandIndex;\n+    }\n+    \n+    public int operandLength() {\n+        return this.operandLength;\n+    }\n+    \n+    public boolean hasNoOperand() {\n+        return false;\n+    }\n+    \n+    public boolean hasMultipleByteCodes() {\n+        return this.rewrite.length > 1 && this.rewrite[0] == 42 && this.rewrite[1] > 0;\n+    }\n+    \n+    public abstract void setByteCodeOperands(final ByteCode p0, final OperandManager p1, final int p2);\n+    \n+    public void fixUpByteCodeTargets(final ByteCode byteCode, final CodeAttribute codeAttribute) {\n+    }\n+    \n+    public boolean nestedMustStartClassPool() {\n+        return false;\n+    }\n }\n"}]}
