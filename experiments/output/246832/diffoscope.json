{"diffoscope-json-version": 1, "source1": "first/TreeTable.class", "source2": "second/TreeTable.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -18,16 +18,16 @@\n import com.puppycrawl.tools.checkstyle.utils.XpathUtil;\n import com.puppycrawl.tools.checkstyle.xpath.RootNode;\n import java.awt.FontMetrics;\n import com.puppycrawl.tools.checkstyle.xpath.XpathQueryGenerator;\n import com.puppycrawl.tools.checkstyle.api.DetailAST;\n import java.util.Collection;\n import javax.swing.tree.TreePath;\n-import javax.swing.Action;\n import java.awt.event.MouseListener;\n+import javax.swing.Action;\n import javax.swing.KeyStroke;\n import java.awt.Dimension;\n import javax.swing.table.TableCellEditor;\n import javax.swing.table.TableCellRenderer;\n import javax.swing.tree.TreeSelectionModel;\n import javax.swing.table.TableModel;\n import javax.swing.JTree;\n@@ -41,161 +41,149 @@\n     private static final long serialVersionUID = -8493693409423365387L;\n     private static final String NEWLINE = \"\\n\";\n     private final TreeTableCellRenderer tree;\n     private JTextArea editor;\n     private JTextArea xpathEditor;\n     private List<Integer> linePositionList;\n     \n-    public TreeTable(final ParseTreeTableModel treeTableModel) {\n-        this.tree = new TreeTableCellRenderer(this, (TreeModel)treeTableModel);\n-        this.setModel((TableModel)new TreeTableModelAdapter(treeTableModel, (JTree)this.tree));\n-        final ListToTreeSelectionModelWrapper selectionWrapper = new ListToTreeSelectionModelWrapper(this);\n-        this.tree.setSelectionModel((TreeSelectionModel)selectionWrapper);\n-        this.setSelectionModel(selectionWrapper.getListSelectionModel());\n+    public TreeTable(final ParseTreeTableModel parseTreeTableModel) {\n+        this.tree = new TreeTableCellRenderer(this, (TreeModel)parseTreeTableModel);\n+        this.setModel((TableModel)new TreeTableModelAdapter(parseTreeTableModel, (JTree)this.tree));\n+        final ListToTreeSelectionModelWrapper selectionModel = new ListToTreeSelectionModelWrapper(this);\n+        this.tree.setSelectionModel((TreeSelectionModel)selectionModel);\n+        this.setSelectionModel(selectionModel.getListSelectionModel());\n         this.setDefaultRenderer(ParseTreeTableModel.class, (TableCellRenderer)this.tree);\n         this.setDefaultEditor(ParseTreeTableModel.class, (TableCellEditor)new TreeTable.TreeTableCellEditor(this));\n         this.setShowGrid(false);\n         this.setIntercellSpacing(new Dimension(0, 0));\n         if (this.tree.getRowHeight() < 1) {\n-            final int height = this.getRowHeight();\n-            this.setRowHeight(height);\n+            this.setRowHeight(this.getRowHeight());\n         }\n         this.setColumnsInitialWidth();\n-        final Action expand = (Action)new TreeTable.TreeTable$1(this);\n-        final KeyStroke stroke = KeyStroke.getKeyStroke(\"ENTER\");\n-        final String command = \"expand/collapse\";\n-        this.getInputMap().put(stroke, \"expand/collapse\");\n-        this.getActionMap().put(\"expand/collapse\", expand);\n+        final TreeTable.TreeTable$1 action = new TreeTable.TreeTable$1(this);\n+        this.getInputMap().put(KeyStroke.getKeyStroke(\"ENTER\"), \"expand/collapse\");\n+        this.getActionMap().put(\"expand/collapse\", (Action)action);\n         this.addMouseListener((MouseListener)new TreeTable.TreeTable$2(this));\n     }\n     \n     private void expandSelectedNode() {\n-        final TreePath selected = this.tree.getSelectionPath();\n+        final TreePath selectionPath = this.tree.getSelectionPath();\n         this.makeCodeSelection();\n         this.generateXpath();\n-        if (this.tree.isExpanded(selected)) {\n-            this.tree.collapsePath(selected);\n+        if (this.tree.isExpanded(selectionPath)) {\n+            this.tree.collapsePath(selectionPath);\n         }\n         else {\n-            this.tree.expandPath(selected);\n+            this.tree.expandPath(selectionPath);\n         }\n-        this.tree.setSelectionPath(selected);\n+        this.tree.setSelectionPath(selectionPath);\n     }\n     \n     private void makeCodeSelection() {\n         new CodeSelector(this.tree.getLastSelectedPathComponent(), this.editor, (Collection)this.linePositionList).select();\n     }\n     \n     private void generateXpath() {\n         if (this.tree.getLastSelectedPathComponent() instanceof DetailAST) {\n-            final DetailAST ast = (DetailAST)this.tree.getLastSelectedPathComponent();\n-            final String xpath = XpathQueryGenerator.generateXpathQuery(ast);\n-            this.xpathEditor.setText(xpath);\n+            this.xpathEditor.setText(XpathQueryGenerator.generateXpathQuery((DetailAST)this.tree.getLastSelectedPathComponent()));\n         }\n         else {\n             this.xpathEditor.setText(\"Xpath is not supported yet for javadoc nodes\");\n         }\n     }\n     \n     private void setColumnsInitialWidth() {\n         final FontMetrics fontMetrics = this.getFontMetrics(this.getFont());\n-        final int widthOfSixCharacterString = fontMetrics.stringWidth(\"XXXXXX\");\n-        final int padding = 10;\n-        final int widthOfColumnContainingSixCharacterString = widthOfSixCharacterString + 10;\n-        this.getColumn(\"Line\").setMaxWidth(widthOfColumnContainingSixCharacterString);\n-        this.getColumn(\"Column\").setMaxWidth(widthOfColumnContainingSixCharacterString);\n-        final int preferredTreeColumnWidth = Math.toIntExact(Math.round(this.getPreferredSize().getWidth() * 0.6));\n-        this.getColumn(\"Tree\").setPreferredWidth(preferredTreeColumnWidth);\n-        final int widthOfTwentyEightCharacterString = fontMetrics.stringWidth(\"XXXXXXXXXXXXXXXXXXXXXXXXXXXX\");\n-        final int preferredTypeColumnWidth = widthOfTwentyEightCharacterString + 10;\n-        this.getColumn(\"Type\").setPreferredWidth(preferredTypeColumnWidth);\n+        final int n = fontMetrics.stringWidth(\"XXXXXX\") + 10;\n+        this.getColumn(\"Line\").setMaxWidth(n);\n+        this.getColumn(\"Column\").setMaxWidth(n);\n+        this.getColumn(\"Tree\").setPreferredWidth(Math.toIntExact(Math.round(this.getPreferredSize().getWidth() * 0.6)));\n+        this.getColumn(\"Type\").setPreferredWidth(fontMetrics.stringWidth(\"XXXXXXXXXXXXXXXXXXXXXXXXXXXX\") + 10);\n     }\n     \n     public void selectNodeByXpath() {\n-        final DetailAST rootAST = (DetailAST)this.tree.getModel().getRoot();\n-        if (rootAST.hasChildren()) {\n-            final String xpath = this.xpathEditor.getText();\n+        final DetailAST detailAST = (DetailAST)this.tree.getModel().getRoot();\n+        if (detailAST.hasChildren()) {\n+            final String text = this.xpathEditor.getText();\n             try {\n-                final Stream stream = XpathUtil.getXpathItems(xpath, (AbstractNode)new RootNode(rootAST)).stream();\n+                final Stream stream = XpathUtil.getXpathItems(text, (AbstractNode)new RootNode(detailAST)).stream();\n                 final Class<ElementNode> obj = ElementNode.class;\n                 Objects.requireNonNull(obj);\n-                final Deque<DetailAST> nodes = (Deque)stream.map(obj::cast).map(ElementNode::getUnderlyingNode).collect(Collectors.toCollection(ArrayDeque::new));\n-                this.updateTreeTable(xpath, nodes);\n+                this.updateTreeTable(text, (Deque<DetailAST>)stream.map(obj::cast).map(ElementNode::getUnderlyingNode).collect(Collectors.toCollection(ArrayDeque::new)));\n             }\n-            catch (final XPathException exception) {\n-                this.xpathEditor.setText(this.xpathEditor.getText() + \"\\n\" + exception.getMessage());\n+            catch (final XPathException ex) {\n+                this.xpathEditor.setText(this.xpathEditor.getText() + \"\\n\" + ex.getMessage());\n             }\n         }\n         else {\n             this.xpathEditor.setText(\"No file Opened\");\n         }\n     }\n     \n-    private void updateTreeTable(final String xpath, final Deque<DetailAST> nodes) {\n-        if (nodes.isEmpty()) {\n-            this.xpathEditor.setText(\"No elements matching XPath query '\" + xpath + \"' found.\");\n+    private void updateTreeTable(final String s, final Deque<DetailAST> deque) {\n+        if (deque.isEmpty()) {\n+            this.xpathEditor.setText(\"No elements matching XPath query '\" + s + \"' found.\");\n         }\n         else {\n-            for (final DetailAST node : nodes) {\n-                this.expandTreeTableByPath(node);\n+            final Iterator iterator = deque.iterator();\n+            while (iterator.hasNext()) {\n+                this.expandTreeTableByPath((DetailAST)iterator.next());\n                 this.makeCodeSelection();\n             }\n-            this.xpathEditor.setText(getAllMatchingXpathQueriesText(nodes));\n+            this.xpathEditor.setText(getAllMatchingXpathQueriesText(deque));\n         }\n     }\n     \n-    private void expandTreeTableByPath(final DetailAST node) {\n-        TreePath path = new TreePath(node);\n-        path = path.pathByAddingChild(node);\n-        if (!this.tree.isExpanded(path)) {\n-            this.tree.expandPath(path);\n+    private void expandTreeTableByPath(final DetailAST detailAST) {\n+        final TreePath pathByAddingChild = new TreePath(detailAST).pathByAddingChild(detailAST);\n+        if (!this.tree.isExpanded(pathByAddingChild)) {\n+            this.tree.expandPath(pathByAddingChild);\n         }\n-        this.tree.setSelectionPath(path);\n+        this.tree.setSelectionPath(pathByAddingChild);\n     }\n     \n-    private static String getAllMatchingXpathQueriesText(final Deque<DetailAST> nodes) {\n-        return nodes.stream().map((Function<? super Object, ?>)XpathQueryGenerator::generateXpathQuery).collect((Collector<? super Object, ?, String>)Collectors.joining(\"\\n\", \"\", \"\\n\"));\n+    private static String getAllMatchingXpathQueriesText(final Deque<DetailAST> deque) {\n+        return deque.stream().map((Function<? super Object, ?>)XpathQueryGenerator::generateXpathQuery).collect((Collector<? super Object, ?, String>)Collectors.joining(\"\\n\", \"\", \"\\n\"));\n     }\n     \n     @Override\n     public void updateUI() {\n         super.updateUI();\n         if (this.tree != null) {\n             this.tree.updateUI();\n         }\n         LookAndFeel.installColorsAndFont(this, \"Tree.background\", \"Tree.foreground\", \"Tree.font\");\n     }\n     \n     @Override\n     public int getEditingRow() {\n-        int rowIndex = -1;\n-        final Class<?> editingClass = this.getColumnClass(this.editingColumn);\n-        if (editingClass != ParseTreeTableModel.class) {\n-            rowIndex = this.editingRow;\n+        int editingRow = -1;\n+        if (this.getColumnClass(this.editingColumn) != ParseTreeTableModel.class) {\n+            editingRow = this.editingRow;\n         }\n-        return rowIndex;\n+        return editingRow;\n     }\n     \n     @Override\n-    public void setRowHeight(final int newRowHeight) {\n-        super.setRowHeight(newRowHeight);\n-        if (this.tree != null && this.tree.getRowHeight() != newRowHeight) {\n+    public void setRowHeight(final int rowHeight) {\n+        super.setRowHeight(rowHeight);\n+        if (this.tree != null && this.tree.getRowHeight() != rowHeight) {\n             this.tree.setRowHeight(this.getRowHeight());\n         }\n     }\n     \n     public JTree getTree() {\n         return (JTree)this.tree;\n     }\n     \n-    public void setEditor(final JTextArea textArea) {\n-        this.editor = textArea;\n+    public void setEditor(final JTextArea editor) {\n+        this.editor = editor;\n     }\n     \n-    public void setXpathEditor(final JTextArea xpathTextArea) {\n-        this.xpathEditor = xpathTextArea;\n+    public void setXpathEditor(final JTextArea xpathEditor) {\n+        this.xpathEditor = xpathEditor;\n     }\n     \n-    public void setLinePositionList(final Collection<Integer> linePositionList) {\n-        this.linePositionList = new ArrayList<Integer>(linePositionList);\n+    public void setLinePositionList(final Collection<Integer> c) {\n+        this.linePositionList = new ArrayList<Integer>(c);\n     }\n }\n"}]}
