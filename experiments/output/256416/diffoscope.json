{"diffoscope-json-version": 1, "source1": "first/ZipArchiveInputStream.class", "source2": "second/ZipArchiveInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -52,264 +52,263 @@\n     private static final byte[] APK_SIGNING_BLOCK_MAGIC;\n     private static final BigInteger LONG_MAX;\n     \n     public ZipArchiveInputStream(final InputStream inputStream) {\n         this(inputStream, \"UTF8\");\n     }\n     \n-    public ZipArchiveInputStream(final InputStream inputStream, final String encoding) {\n-        this(inputStream, encoding, true);\n+    public ZipArchiveInputStream(final InputStream inputStream, final String s) {\n+        this(inputStream, s, true);\n     }\n     \n-    public ZipArchiveInputStream(final InputStream inputStream, final String encoding, final boolean useUnicodeExtraFields) {\n-        this(inputStream, encoding, useUnicodeExtraFields, false);\n+    public ZipArchiveInputStream(final InputStream inputStream, final String s, final boolean b) {\n+        this(inputStream, s, b, false);\n     }\n     \n-    public ZipArchiveInputStream(final InputStream inputStream, final String encoding, final boolean useUnicodeExtraFields, final boolean allowStoredEntriesWithDataDescriptor) {\n-        this(inputStream, encoding, useUnicodeExtraFields, allowStoredEntriesWithDataDescriptor, false);\n+    public ZipArchiveInputStream(final InputStream inputStream, final String s, final boolean b, final boolean b2) {\n+        this(inputStream, s, b, b2, false);\n     }\n     \n-    public ZipArchiveInputStream(final InputStream inputStream, final String encoding, final boolean useUnicodeExtraFields, final boolean allowStoredEntriesWithDataDescriptor, final boolean skipSplitSig) {\n+    public ZipArchiveInputStream(final InputStream in, final String encoding, final boolean useUnicodeExtraFields, final boolean allowStoredEntriesWithDataDescriptor, final boolean skipSplitSig) {\n         this.inf = new Inflater(true);\n         this.buf = ByteBuffer.allocate(512);\n         this.lfhBuf = new byte[30];\n         this.skipBuf = new byte[1024];\n         this.shortBuf = new byte[2];\n         this.wordBuf = new byte[4];\n         this.twoDwordBuf = new byte[16];\n         this.encoding = encoding;\n         this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n         this.useUnicodeExtraFields = useUnicodeExtraFields;\n-        this.inputStream = new PushbackInputStream(inputStream, this.buf.capacity());\n+        this.inputStream = new PushbackInputStream(in, this.buf.capacity());\n         this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n         this.skipSplitSig = skipSplitSig;\n         this.buf.limit();\n     }\n     \n     public ZipArchiveEntry getNextZipEntry() throws IOException {\n         this.uncompressedCount = 0L;\n-        boolean firstEntry = true;\n+        boolean b = true;\n         if (this.closed || this.hitCentralDirectory) {\n             return null;\n         }\n         if (this.current != null) {\n             this.closeEntry();\n-            firstEntry = false;\n+            b = false;\n         }\n-        final long currentHeaderOffset = this.getBytesRead();\n+        final long bytesRead = this.getBytesRead();\n         try {\n-            if (firstEntry) {\n+            if (b) {\n                 this.readFirstLocalFileHeader();\n             }\n             else {\n                 this.readFully(this.lfhBuf);\n             }\n         }\n-        catch (final EOFException e) {\n+        catch (final EOFException ex) {\n             return null;\n         }\n-        final ZipLong sig = new ZipLong(this.lfhBuf);\n-        if (sig.equals((Object)ZipLong.LFH_SIG)) {\n-            int off = 4;\n+        final ZipLong zipLong = new ZipLong(this.lfhBuf);\n+        if (zipLong.equals((Object)ZipLong.LFH_SIG)) {\n+            int n = 4;\n             this.current = new ZipArchiveInputStream.CurrentEntry((ZipArchiveInputStream.ZipArchiveInputStream$1)null);\n-            final int versionMadeBy = ZipShort.getValue(this.lfhBuf, off);\n-            off += 2;\n-            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setPlatform(versionMadeBy >> 8 & 0xF);\n-            final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(this.lfhBuf, off);\n-            final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n-            final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : this.zipEncoding;\n-            ZipArchiveInputStream.CurrentEntry.access$202(this.current, gpFlag.usesDataDescriptor());\n-            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setGeneralPurposeBit(gpFlag);\n-            off += 2;\n-            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setMethod(ZipShort.getValue(this.lfhBuf, off));\n-            off += 2;\n-            final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(this.lfhBuf, off));\n-            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setTime(time);\n-            off += 4;\n-            ZipLong size = null;\n-            ZipLong cSize = null;\n+            final int value = ZipShort.getValue(this.lfhBuf, n);\n+            n += 2;\n+            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setPlatform(value >> 8 & 0xF);\n+            final GeneralPurposeBit parse = GeneralPurposeBit.parse(this.lfhBuf, n);\n+            final boolean usesUTF8ForNames = parse.usesUTF8ForNames();\n+            final ZipEncoding zipEncoding = usesUTF8ForNames ? ZipEncodingHelper.UTF8_ZIP_ENCODING : this.zipEncoding;\n+            ZipArchiveInputStream.CurrentEntry.access$202(this.current, parse.usesDataDescriptor());\n+            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setGeneralPurposeBit(parse);\n+            n += 2;\n+            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setMethod(ZipShort.getValue(this.lfhBuf, n));\n+            n += 2;\n+            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setTime(ZipUtil.dosToJavaTime(ZipLong.getValue(this.lfhBuf, n)));\n+            n += 4;\n+            ZipLong zipLong2 = null;\n+            ZipLong zipLong3 = null;\n             if (!ZipArchiveInputStream.CurrentEntry.access$200(this.current)) {\n-                ZipArchiveInputStream.CurrentEntry.access$100(this.current).setCrc(ZipLong.getValue(this.lfhBuf, off));\n-                off += 4;\n-                cSize = new ZipLong(this.lfhBuf, off);\n-                off += 4;\n-                size = new ZipLong(this.lfhBuf, off);\n-                off += 4;\n+                ZipArchiveInputStream.CurrentEntry.access$100(this.current).setCrc(ZipLong.getValue(this.lfhBuf, n));\n+                n += 4;\n+                zipLong3 = new ZipLong(this.lfhBuf, n);\n+                n += 4;\n+                zipLong2 = new ZipLong(this.lfhBuf, n);\n+                n += 4;\n             }\n             else {\n-                off += 12;\n+                n += 12;\n             }\n-            final int fileNameLen = ZipShort.getValue(this.lfhBuf, off);\n-            off += 2;\n-            final int extraLen = ZipShort.getValue(this.lfhBuf, off);\n-            off += 2;\n-            final byte[] fileName = this.readRange(fileNameLen);\n-            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setName(entryEncoding.decode(fileName), fileName);\n-            if (hasUTF8Flag) {\n+            final int value2 = ZipShort.getValue(this.lfhBuf, n);\n+            n += 2;\n+            final int value3 = ZipShort.getValue(this.lfhBuf, n);\n+            n += 2;\n+            final byte[] range = this.readRange(value2);\n+            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setName(zipEncoding.decode(range), range);\n+            if (usesUTF8ForNames) {\n                 ZipArchiveInputStream.CurrentEntry.access$100(this.current).setNameSource(ZipArchiveEntry.NameSource.NAME_WITH_EFS_FLAG);\n             }\n-            final byte[] extraData = this.readRange(extraLen);\n+            final byte[] range2 = this.readRange(value3);\n             try {\n-                ZipArchiveInputStream.CurrentEntry.access$100(this.current).setExtra(extraData);\n+                ZipArchiveInputStream.CurrentEntry.access$100(this.current).setExtra(range2);\n             }\n-            catch (final RuntimeException ex) {\n-                final ZipException z = new ZipException(\"Invalid extra data in entry \" + ZipArchiveInputStream.CurrentEntry.access$100(this.current).getName());\n-                z.initCause(ex);\n-                throw z;\n+            catch (final RuntimeException cause) {\n+                final ZipException ex2 = new ZipException(\"Invalid extra data in entry \" + ZipArchiveInputStream.CurrentEntry.access$100(this.current).getName());\n+                ex2.initCause(cause);\n+                throw ex2;\n             }\n-            if (!hasUTF8Flag && this.useUnicodeExtraFields) {\n-                ZipUtil.setNameAndCommentFromExtraFields(ZipArchiveInputStream.CurrentEntry.access$100(this.current), fileName, (byte[])null);\n+            if (!usesUTF8ForNames && this.useUnicodeExtraFields) {\n+                ZipUtil.setNameAndCommentFromExtraFields(ZipArchiveInputStream.CurrentEntry.access$100(this.current), range, (byte[])null);\n             }\n-            this.processZip64Extra(size, cSize);\n-            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setLocalHeaderOffset(currentHeaderOffset);\n+            this.processZip64Extra(zipLong2, zipLong3);\n+            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setLocalHeaderOffset(bytesRead);\n             ZipArchiveInputStream.CurrentEntry.access$100(this.current).setDataOffset(this.getBytesRead());\n             ZipArchiveInputStream.CurrentEntry.access$100(this.current).setStreamContiguous(true);\n-            final ZipMethod m = ZipMethod.getMethodByCode(ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod());\n+            final ZipMethod methodByCode = ZipMethod.getMethodByCode(ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod());\n             if (ZipArchiveInputStream.CurrentEntry.access$100(this.current).getCompressedSize() != -1L) {\n-                if (ZipUtil.canHandleEntryData(ZipArchiveInputStream.CurrentEntry.access$100(this.current)) && m != ZipMethod.STORED && m != ZipMethod.DEFLATED) {\n-                    final InputStream bis = (InputStream)new ZipArchiveInputStream.BoundedInputStream(this, this.inputStream, ZipArchiveInputStream.CurrentEntry.access$100(this.current).getCompressedSize());\n-                    switch (ZipArchiveInputStream.ZipArchiveInputStream$1.$SwitchMap$org$apache$commons$compress$archivers$zip$ZipMethod[m.ordinal()]) {\n+                if (ZipUtil.canHandleEntryData(ZipArchiveInputStream.CurrentEntry.access$100(this.current)) && methodByCode != ZipMethod.STORED && methodByCode != ZipMethod.DEFLATED) {\n+                    final ZipArchiveInputStream.BoundedInputStream boundedInputStream = new ZipArchiveInputStream.BoundedInputStream(this, this.inputStream, ZipArchiveInputStream.CurrentEntry.access$100(this.current).getCompressedSize());\n+                    switch (ZipArchiveInputStream.ZipArchiveInputStream$1.$SwitchMap$org$apache$commons$compress$archivers$zip$ZipMethod[methodByCode.ordinal()]) {\n                         case 1: {\n-                            ZipArchiveInputStream.CurrentEntry.access$302(this.current, (InputStream)new UnshrinkingInputStream(bis));\n+                            ZipArchiveInputStream.CurrentEntry.access$302(this.current, (InputStream)new UnshrinkingInputStream((InputStream)boundedInputStream));\n                             break;\n                         }\n                         case 2: {\n                             try {\n-                                ZipArchiveInputStream.CurrentEntry.access$302(this.current, (InputStream)new ExplodingInputStream(ZipArchiveInputStream.CurrentEntry.access$100(this.current).getGeneralPurposeBit().getSlidingDictionarySize(), ZipArchiveInputStream.CurrentEntry.access$100(this.current).getGeneralPurposeBit().getNumberOfShannonFanoTrees(), bis));\n+                                ZipArchiveInputStream.CurrentEntry.access$302(this.current, (InputStream)new ExplodingInputStream(ZipArchiveInputStream.CurrentEntry.access$100(this.current).getGeneralPurposeBit().getSlidingDictionarySize(), ZipArchiveInputStream.CurrentEntry.access$100(this.current).getGeneralPurposeBit().getNumberOfShannonFanoTrees(), (InputStream)boundedInputStream));\n                                 break;\n                             }\n-                            catch (final IllegalArgumentException ex2) {\n-                                throw new IOException(\"bad IMPLODE data\", ex2);\n+                            catch (final IllegalArgumentException cause2) {\n+                                throw new IOException(\"bad IMPLODE data\", cause2);\n                             }\n                         }\n                         case 3: {\n-                            ZipArchiveInputStream.CurrentEntry.access$302(this.current, (InputStream)new BZip2CompressorInputStream(bis));\n+                            ZipArchiveInputStream.CurrentEntry.access$302(this.current, (InputStream)new BZip2CompressorInputStream((InputStream)boundedInputStream));\n                             break;\n                         }\n                         case 4: {\n-                            ZipArchiveInputStream.CurrentEntry.access$302(this.current, (InputStream)new Deflate64CompressorInputStream(bis));\n+                            ZipArchiveInputStream.CurrentEntry.access$302(this.current, (InputStream)new Deflate64CompressorInputStream((InputStream)boundedInputStream));\n                             break;\n                         }\n                     }\n                 }\n             }\n-            else if (m == ZipMethod.ENHANCED_DEFLATED) {\n+            else if (methodByCode == ZipMethod.ENHANCED_DEFLATED) {\n                 ZipArchiveInputStream.CurrentEntry.access$302(this.current, (InputStream)new Deflate64CompressorInputStream(this.inputStream));\n             }\n             ++this.entriesRead;\n             return ZipArchiveInputStream.CurrentEntry.access$100(this.current);\n         }\n-        if (sig.equals((Object)ZipLong.CFH_SIG) || sig.equals((Object)ZipLong.AED_SIG) || this.isApkSigningBlock(this.lfhBuf)) {\n+        if (zipLong.equals((Object)ZipLong.CFH_SIG) || zipLong.equals((Object)ZipLong.AED_SIG) || this.isApkSigningBlock(this.lfhBuf)) {\n             this.hitCentralDirectory = true;\n             this.skipRemainderOfArchive();\n             return null;\n         }\n-        throw new ZipException(String.format(\"Unexpected record signature: 0x%x\", Long.valueOf(sig.getValue())));\n+        throw new ZipException(String.format(\"Unexpected record signature: 0x%x\", Long.valueOf(zipLong.getValue())));\n     }\n     \n     private void readFirstLocalFileHeader() throws IOException {\n         this.readFully(this.lfhBuf);\n-        final ZipLong sig = new ZipLong(this.lfhBuf);\n-        if (!this.skipSplitSig && sig.equals((Object)ZipLong.DD_SIG)) {\n+        final ZipLong zipLong = new ZipLong(this.lfhBuf);\n+        if (!this.skipSplitSig && zipLong.equals((Object)ZipLong.DD_SIG)) {\n             throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.SPLITTING);\n         }\n-        if (sig.equals((Object)ZipLong.SINGLE_SEGMENT_SPLIT_MARKER) || sig.equals((Object)ZipLong.DD_SIG)) {\n-            final byte[] missedLfhBytes = new byte[4];\n-            this.readFully(missedLfhBytes);\n+        if (zipLong.equals((Object)ZipLong.SINGLE_SEGMENT_SPLIT_MARKER) || zipLong.equals((Object)ZipLong.DD_SIG)) {\n+            final byte[] array = new byte[4];\n+            this.readFully(array);\n             System.arraycopy(this.lfhBuf, 4, this.lfhBuf, 0, 26);\n-            System.arraycopy(missedLfhBytes, 0, this.lfhBuf, 26, 4);\n+            System.arraycopy(array, 0, this.lfhBuf, 26, 4);\n         }\n     }\n     \n-    private void processZip64Extra(final ZipLong size, final ZipLong cSize) throws ZipException {\n-        final ZipExtraField extra = ZipArchiveInputStream.CurrentEntry.access$100(this.current).getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n-        if (extra != null && !(extra instanceof Zip64ExtendedInformationExtraField)) {\n+    private void processZip64Extra(final ZipLong zipLong, final ZipLong zipLong2) throws ZipException {\n+        final ZipExtraField extraField = ZipArchiveInputStream.CurrentEntry.access$100(this.current).getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n+        if (extraField != null && !(extraField instanceof Zip64ExtendedInformationExtraField)) {\n             throw new ZipException(\"archive contains unparseable zip64 extra field\");\n         }\n-        final Zip64ExtendedInformationExtraField z64 = (Zip64ExtendedInformationExtraField)extra;\n-        ZipArchiveInputStream.CurrentEntry.access$402(this.current, z64 != null);\n+        final Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField = (Zip64ExtendedInformationExtraField)extraField;\n+        ZipArchiveInputStream.CurrentEntry.access$402(this.current, zip64ExtendedInformationExtraField != null);\n         if (!ZipArchiveInputStream.CurrentEntry.access$200(this.current)) {\n-            if (z64 != null && (ZipLong.ZIP64_MAGIC.equals((Object)cSize) || ZipLong.ZIP64_MAGIC.equals((Object)size))) {\n-                if (z64.getCompressedSize() == null || z64.getSize() == null) {\n+            if (zip64ExtendedInformationExtraField != null && (ZipLong.ZIP64_MAGIC.equals((Object)zipLong2) || ZipLong.ZIP64_MAGIC.equals((Object)zipLong))) {\n+                if (zip64ExtendedInformationExtraField.getCompressedSize() == null || zip64ExtendedInformationExtraField.getSize() == null) {\n                     throw new ZipException(\"archive contains corrupted zip64 extra field\");\n                 }\n-                long s = z64.getCompressedSize().getLongValue();\n-                if (s < 0L) {\n+                final long longValue = zip64ExtendedInformationExtraField.getCompressedSize().getLongValue();\n+                if (longValue < 0L) {\n                     throw new ZipException(\"broken archive, entry with negative compressed size\");\n                 }\n-                ZipArchiveInputStream.CurrentEntry.access$100(this.current).setCompressedSize(s);\n-                s = z64.getSize().getLongValue();\n-                if (s < 0L) {\n+                ZipArchiveInputStream.CurrentEntry.access$100(this.current).setCompressedSize(longValue);\n+                final long longValue2 = zip64ExtendedInformationExtraField.getSize().getLongValue();\n+                if (longValue2 < 0L) {\n                     throw new ZipException(\"broken archive, entry with negative size\");\n                 }\n-                ZipArchiveInputStream.CurrentEntry.access$100(this.current).setSize(s);\n+                ZipArchiveInputStream.CurrentEntry.access$100(this.current).setSize(longValue2);\n             }\n-            else if (cSize != null && size != null) {\n-                if (cSize.getValue() < 0L) {\n+            else if (zipLong2 != null && zipLong != null) {\n+                if (zipLong2.getValue() < 0L) {\n                     throw new ZipException(\"broken archive, entry with negative compressed size\");\n                 }\n-                ZipArchiveInputStream.CurrentEntry.access$100(this.current).setCompressedSize(cSize.getValue());\n-                if (size.getValue() < 0L) {\n+                ZipArchiveInputStream.CurrentEntry.access$100(this.current).setCompressedSize(zipLong2.getValue());\n+                if (zipLong.getValue() < 0L) {\n                     throw new ZipException(\"broken archive, entry with negative size\");\n                 }\n-                ZipArchiveInputStream.CurrentEntry.access$100(this.current).setSize(size.getValue());\n+                ZipArchiveInputStream.CurrentEntry.access$100(this.current).setSize(zipLong.getValue());\n             }\n         }\n     }\n     \n     public ArchiveEntry getNextEntry() throws IOException {\n         return (ArchiveEntry)this.getNextZipEntry();\n     }\n     \n-    public boolean canReadEntryData(final ArchiveEntry ae) {\n-        if (ae instanceof ZipArchiveEntry) {\n-            final ZipArchiveEntry ze = (ZipArchiveEntry)ae;\n-            return ZipUtil.canHandleEntryData(ze) && this.supportsDataDescriptorFor(ze) && this.supportsCompressedSizeFor(ze);\n+    public boolean canReadEntryData(final ArchiveEntry archiveEntry) {\n+        if (archiveEntry instanceof ZipArchiveEntry) {\n+            final ZipArchiveEntry zipArchiveEntry = (ZipArchiveEntry)archiveEntry;\n+            return ZipUtil.canHandleEntryData(zipArchiveEntry) && this.supportsDataDescriptorFor(zipArchiveEntry) && this.supportsCompressedSizeFor(zipArchiveEntry);\n         }\n         return false;\n     }\n     \n-    public int read(final byte[] buffer, final int offset, final int length) throws IOException {\n-        if (length == 0) {\n+    public int read(final byte[] array, final int n, final int len) throws IOException {\n+        if (len == 0) {\n             return 0;\n         }\n         if (this.closed) {\n             throw new IOException(\"The stream is closed\");\n         }\n         if (this.current == null) {\n             return -1;\n         }\n-        if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n+        if (n > array.length || len < 0 || n < 0 || array.length - n < len) {\n             throw new ArrayIndexOutOfBoundsException();\n         }\n         ZipUtil.checkRequestedFeatures(ZipArchiveInputStream.CurrentEntry.access$100(this.current));\n         if (!this.supportsDataDescriptorFor(ZipArchiveInputStream.CurrentEntry.access$100(this.current))) {\n             throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, ZipArchiveInputStream.CurrentEntry.access$100(this.current));\n         }\n         if (!this.supportsCompressedSizeFor(ZipArchiveInputStream.CurrentEntry.access$100(this.current))) {\n             throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.UNKNOWN_COMPRESSED_SIZE, ZipArchiveInputStream.CurrentEntry.access$100(this.current));\n         }\n-        int read;\n+        int len2;\n         if (ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod() == 0) {\n-            read = this.readStored(buffer, offset, length);\n+            len2 = this.readStored(array, n, len);\n         }\n         else if (ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod() == 8) {\n-            read = this.readDeflated(buffer, offset, length);\n+            len2 = this.readDeflated(array, n, len);\n         }\n         else {\n             if (ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod() != ZipMethod.UNSHRINKING.getCode() && ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod() != ZipMethod.IMPLODING.getCode() && ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod() != ZipMethod.ENHANCED_DEFLATED.getCode() && ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod() != ZipMethod.BZIP2.getCode()) {\n                 throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod()), ZipArchiveInputStream.CurrentEntry.access$100(this.current));\n             }\n-            read = ZipArchiveInputStream.CurrentEntry.access$300(this.current).read(buffer, offset, length);\n+            len2 = ZipArchiveInputStream.CurrentEntry.access$300(this.current).read(array, n, len);\n         }\n-        if (read >= 0) {\n-            ZipArchiveInputStream.CurrentEntry.access$500(this.current).update(buffer, offset, read);\n-            this.uncompressedCount += read;\n+        if (len2 >= 0) {\n+            ZipArchiveInputStream.CurrentEntry.access$500(this.current).update(array, n, len2);\n+            this.uncompressedCount += len2;\n         }\n-        return read;\n+        return len2;\n     }\n     \n     public long getCompressedCount() {\n         final int method = ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod();\n         if (method == 0) {\n             return ZipArchiveInputStream.CurrentEntry.access$600(this.current);\n         }\n@@ -322,121 +321,121 @@\n         return -1L;\n     }\n     \n     public long getUncompressedCount() {\n         return this.uncompressedCount;\n     }\n     \n-    private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n+    private int readStored(final byte[] array, final int n, final int n2) throws IOException {\n         if (ZipArchiveInputStream.CurrentEntry.access$200(this.current)) {\n             if (this.lastStoredEntry == null) {\n                 this.readStoredEntry();\n             }\n-            return this.lastStoredEntry.read(buffer, offset, length);\n+            return this.lastStoredEntry.read(array, n, n2);\n         }\n-        final long csize = ZipArchiveInputStream.CurrentEntry.access$100(this.current).getSize();\n-        if (ZipArchiveInputStream.CurrentEntry.access$600(this.current) >= csize) {\n+        final long size = ZipArchiveInputStream.CurrentEntry.access$100(this.current).getSize();\n+        if (ZipArchiveInputStream.CurrentEntry.access$600(this.current) >= size) {\n             return -1;\n         }\n         if (this.buf.position() >= this.buf.limit()) {\n             this.buf.position();\n-            final int l = this.inputStream.read(this.buf.array());\n-            if (l == -1) {\n+            final int read = this.inputStream.read(this.buf.array());\n+            if (read == -1) {\n                 this.buf.limit();\n                 throw new IOException(\"Truncated ZIP file\");\n             }\n             this.buf.limit();\n-            this.count(l);\n-            ZipArchiveInputStream.CurrentEntry.access$814(this.current, (long)l);\n+            this.count(read);\n+            ZipArchiveInputStream.CurrentEntry.access$814(this.current, (long)read);\n         }\n-        int toRead = Math.min(this.buf.remaining(), length);\n-        if (csize - ZipArchiveInputStream.CurrentEntry.access$600(this.current) < toRead) {\n-            toRead = (int)(csize - ZipArchiveInputStream.CurrentEntry.access$600(this.current));\n+        int min = Math.min(this.buf.remaining(), n2);\n+        if (size - ZipArchiveInputStream.CurrentEntry.access$600(this.current) < min) {\n+            min = (int)(size - ZipArchiveInputStream.CurrentEntry.access$600(this.current));\n         }\n-        this.buf.get(buffer, offset, toRead);\n-        ZipArchiveInputStream.CurrentEntry.access$614(this.current, (long)toRead);\n-        return toRead;\n+        this.buf.get(array, n, min);\n+        ZipArchiveInputStream.CurrentEntry.access$614(this.current, (long)min);\n+        return min;\n     }\n     \n-    private int readDeflated(final byte[] buffer, final int offset, final int length) throws IOException {\n-        final int read = this.readFromInflater(buffer, offset, length);\n-        if (read <= 0) {\n+    private int readDeflated(final byte[] array, final int n, final int n2) throws IOException {\n+        final int fromInflater = this.readFromInflater(array, n, n2);\n+        if (fromInflater <= 0) {\n             if (this.inf.finished()) {\n                 return -1;\n             }\n             if (this.inf.needsDictionary()) {\n                 throw new ZipException(\"This archive needs a preset dictionary which is not supported by Commons Compress.\");\n             }\n-            if (read == -1) {\n+            if (fromInflater == -1) {\n                 throw new IOException(\"Truncated ZIP file\");\n             }\n         }\n-        return read;\n+        return fromInflater;\n     }\n     \n-    private int readFromInflater(final byte[] buffer, final int offset, final int length) throws IOException {\n-        int read = 0;\n+    private int readFromInflater(final byte[] output, final int off, final int len) throws IOException {\n+        int inflate = 0;\n         do {\n             if (this.inf.needsInput()) {\n-                final int l = this.fill();\n-                if (l > 0) {\n+                final int fill = this.fill();\n+                if (fill > 0) {\n                     ZipArchiveInputStream.CurrentEntry.access$814(this.current, (long)this.buf.limit());\n                 }\n                 else {\n-                    if (l == -1) {\n+                    if (fill == -1) {\n                         return -1;\n                     }\n                     break;\n                 }\n             }\n             try {\n-                read = this.inf.inflate(buffer, offset, length);\n+                inflate = this.inf.inflate(output, off, len);\n             }\n-            catch (final DataFormatException e) {\n-                throw (IOException)new ZipException(e.getMessage()).initCause(e);\n+            catch (final DataFormatException cause) {\n+                throw (IOException)new ZipException(cause.getMessage()).initCause(cause);\n             }\n-        } while (read == 0 && this.inf.needsInput());\n-        return read;\n+        } while (inflate == 0 && this.inf.needsInput());\n+        return inflate;\n     }\n     \n     public void close() throws IOException {\n         if (!this.closed) {\n             this.closed = true;\n             try {\n                 this.inputStream.close();\n             }\n             finally {\n                 this.inf.end();\n             }\n         }\n     }\n     \n-    public long skip(final long value) throws IOException {\n-        if (value >= 0L) {\n-            long skipped;\n-            int x;\n-            for (skipped = 0L; skipped < value; skipped += x) {\n-                final long rem = value - skipped;\n-                x = this.read(this.skipBuf, 0, (int)((this.skipBuf.length > rem) ? rem : ((long)this.skipBuf.length)));\n-                if (x == -1) {\n-                    return skipped;\n+    public long skip(final long n) throws IOException {\n+        if (n >= 0L) {\n+            long n2;\n+            int read;\n+            for (n2 = 0L; n2 < n; n2 += read) {\n+                final long n3 = n - n2;\n+                read = this.read(this.skipBuf, 0, (int)((this.skipBuf.length > n3) ? n3 : ((long)this.skipBuf.length)));\n+                if (read == -1) {\n+                    return n2;\n                 }\n             }\n-            return skipped;\n+            return n2;\n         }\n         throw new IllegalArgumentException();\n     }\n     \n-    public static boolean matches(final byte[] signature, final int length) {\n-        return length >= ZipArchiveOutputStream.LFH_SIG.length && (checksig(signature, ZipArchiveOutputStream.LFH_SIG) || checksig(signature, ZipArchiveOutputStream.EOCD_SIG) || checksig(signature, ZipArchiveOutputStream.DD_SIG) || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes()));\n+    public static boolean matches(final byte[] array, final int n) {\n+        return n >= ZipArchiveOutputStream.LFH_SIG.length && (checksig(array, ZipArchiveOutputStream.LFH_SIG) || checksig(array, ZipArchiveOutputStream.EOCD_SIG) || checksig(array, ZipArchiveOutputStream.DD_SIG) || checksig(array, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes()));\n     }\n     \n-    private static boolean checksig(final byte[] signature, final byte[] expected) {\n-        for (int i = 0; i < expected.length; ++i) {\n-            if (signature[i] != expected[i]) {\n+    private static boolean checksig(final byte[] array, final byte[] array2) {\n+        for (int i = 0; i < array2.length; ++i) {\n+            if (array[i] != array2[i]) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n     private void closeEntry() throws IOException {\n@@ -447,19 +446,18 @@\n             return;\n         }\n         if (this.currentEntryHasOutstandingBytes()) {\n             this.drainCurrentEntryData();\n         }\n         else {\n             this.skip(Long.MAX_VALUE);\n-            final long inB = (ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod() == 8) ? this.getBytesInflated() : ZipArchiveInputStream.CurrentEntry.access$600(this.current);\n-            final int diff = (int)(ZipArchiveInputStream.CurrentEntry.access$800(this.current) - inB);\n-            if (diff > 0) {\n-                this.pushback(this.buf.array(), this.buf.limit() - diff, diff);\n-                ZipArchiveInputStream.CurrentEntry.access$822(this.current, (long)diff);\n+            final int n = (int)(ZipArchiveInputStream.CurrentEntry.access$800(this.current) - ((ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod() == 8) ? this.getBytesInflated() : ZipArchiveInputStream.CurrentEntry.access$600(this.current)));\n+            if (n > 0) {\n+                this.pushback(this.buf.array(), this.buf.limit() - n, n);\n+                ZipArchiveInputStream.CurrentEntry.access$822(this.current, (long)n);\n             }\n             if (this.currentEntryHasOutstandingBytes()) {\n                 this.drainCurrentEntryData();\n             }\n         }\n         if (this.lastStoredEntry == null && ZipArchiveInputStream.CurrentEntry.access$200(this.current)) {\n             this.readDataDescriptor();\n@@ -472,296 +470,294 @@\n     \n     private boolean currentEntryHasOutstandingBytes() {\n         return ZipArchiveInputStream.CurrentEntry.access$800(this.current) <= ZipArchiveInputStream.CurrentEntry.access$100(this.current).getCompressedSize() && !ZipArchiveInputStream.CurrentEntry.access$200(this.current);\n     }\n     \n     private void drainCurrentEntryData() throws IOException {\n         long n;\n-        for (long remaining = ZipArchiveInputStream.CurrentEntry.access$100(this.current).getCompressedSize() - ZipArchiveInputStream.CurrentEntry.access$800(this.current); remaining > 0L; remaining -= n) {\n-            n = this.inputStream.read(this.buf.array(), 0, (int)Math.min(this.buf.capacity(), remaining));\n+        for (long b = ZipArchiveInputStream.CurrentEntry.access$100(this.current).getCompressedSize() - ZipArchiveInputStream.CurrentEntry.access$800(this.current); b > 0L; b -= n) {\n+            n = this.inputStream.read(this.buf.array(), 0, (int)Math.min(this.buf.capacity(), b));\n             if (n < 0L) {\n                 throw new EOFException(\"Truncated ZIP entry: \" + ArchiveUtils.sanitize(ZipArchiveInputStream.CurrentEntry.access$100(this.current).getName()));\n             }\n             this.count(n);\n         }\n     }\n     \n     private long getBytesInflated() {\n-        long inB = this.inf.getBytesRead();\n+        long bytesRead = this.inf.getBytesRead();\n         if (ZipArchiveInputStream.CurrentEntry.access$800(this.current) >= 4294967296L) {\n-            while (inB + 4294967296L <= ZipArchiveInputStream.CurrentEntry.access$800(this.current)) {\n-                inB += 4294967296L;\n+            while (bytesRead + 4294967296L <= ZipArchiveInputStream.CurrentEntry.access$800(this.current)) {\n+                bytesRead += 4294967296L;\n             }\n         }\n-        return inB;\n+        return bytesRead;\n     }\n     \n     private int fill() throws IOException {\n         if (this.closed) {\n             throw new IOException(\"The stream is closed\");\n         }\n-        final int length = this.inputStream.read(this.buf.array());\n-        if (length > 0) {\n+        final int read = this.inputStream.read(this.buf.array());\n+        if (read > 0) {\n             this.buf.limit();\n             this.count(this.buf.limit());\n             this.inf.setInput(this.buf.array(), 0, this.buf.limit());\n         }\n-        return length;\n+        return read;\n     }\n     \n-    private void readFully(final byte[] b) throws IOException {\n-        this.readFully(b, 0);\n+    private void readFully(final byte[] array) throws IOException {\n+        this.readFully(array, 0);\n     }\n     \n-    private void readFully(final byte[] b, final int off) throws IOException {\n-        final int len = b.length - off;\n-        final int count = IOUtils.readFully(this.inputStream, b, off, len);\n-        this.count(count);\n-        if (count < len) {\n+    private void readFully(final byte[] array, final int n) throws IOException {\n+        final int n2 = array.length - n;\n+        final int fully = IOUtils.readFully(this.inputStream, array, n, n2);\n+        this.count(fully);\n+        if (fully < n2) {\n             throw new EOFException();\n         }\n     }\n     \n-    private byte[] readRange(final int len) throws IOException {\n-        final byte[] ret = IOUtils.readRange(this.inputStream, len);\n-        this.count(ret.length);\n-        if (ret.length < len) {\n+    private byte[] readRange(final int n) throws IOException {\n+        final byte[] range = IOUtils.readRange(this.inputStream, n);\n+        this.count(range.length);\n+        if (range.length < n) {\n             throw new EOFException();\n         }\n-        return ret;\n+        return range;\n     }\n     \n     private void readDataDescriptor() throws IOException {\n         this.readFully(this.wordBuf);\n-        ZipLong val = new ZipLong(this.wordBuf);\n-        if (ZipLong.DD_SIG.equals((Object)val)) {\n+        ZipLong zipLong = new ZipLong(this.wordBuf);\n+        if (ZipLong.DD_SIG.equals((Object)zipLong)) {\n             this.readFully(this.wordBuf);\n-            val = new ZipLong(this.wordBuf);\n+            zipLong = new ZipLong(this.wordBuf);\n         }\n-        ZipArchiveInputStream.CurrentEntry.access$100(this.current).setCrc(val.getValue());\n+        ZipArchiveInputStream.CurrentEntry.access$100(this.current).setCrc(zipLong.getValue());\n         this.readFully(this.twoDwordBuf);\n-        final ZipLong potentialSig = new ZipLong(this.twoDwordBuf, 8);\n-        if (potentialSig.equals((Object)ZipLong.CFH_SIG) || potentialSig.equals((Object)ZipLong.LFH_SIG)) {\n+        final ZipLong zipLong2 = new ZipLong(this.twoDwordBuf, 8);\n+        if (zipLong2.equals((Object)ZipLong.CFH_SIG) || zipLong2.equals((Object)ZipLong.LFH_SIG)) {\n             this.pushback(this.twoDwordBuf, 8, 8);\n-            long size = ZipLong.getValue(this.twoDwordBuf);\n-            if (size < 0L) {\n+            final long value = ZipLong.getValue(this.twoDwordBuf);\n+            if (value < 0L) {\n                 throw new ZipException(\"broken archive, entry with negative compressed size\");\n             }\n-            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setCompressedSize(size);\n-            size = ZipLong.getValue(this.twoDwordBuf, 4);\n-            if (size < 0L) {\n+            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setCompressedSize(value);\n+            final long value2 = ZipLong.getValue(this.twoDwordBuf, 4);\n+            if (value2 < 0L) {\n                 throw new ZipException(\"broken archive, entry with negative size\");\n             }\n-            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setSize(size);\n+            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setSize(value2);\n         }\n         else {\n-            long size = ZipEightByteInteger.getLongValue(this.twoDwordBuf);\n-            if (size < 0L) {\n+            final long longValue = ZipEightByteInteger.getLongValue(this.twoDwordBuf);\n+            if (longValue < 0L) {\n                 throw new ZipException(\"broken archive, entry with negative compressed size\");\n             }\n-            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setCompressedSize(size);\n-            size = ZipEightByteInteger.getLongValue(this.twoDwordBuf, 8);\n-            if (size < 0L) {\n+            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setCompressedSize(longValue);\n+            final long longValue2 = ZipEightByteInteger.getLongValue(this.twoDwordBuf, 8);\n+            if (longValue2 < 0L) {\n                 throw new ZipException(\"broken archive, entry with negative size\");\n             }\n-            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setSize(size);\n+            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setSize(longValue2);\n         }\n     }\n     \n-    private boolean supportsDataDescriptorFor(final ZipArchiveEntry entry) {\n-        return !entry.getGeneralPurposeBit().usesDataDescriptor() || (this.allowStoredEntriesWithDataDescriptor && entry.getMethod() == 0) || entry.getMethod() == 8 || entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode();\n+    private boolean supportsDataDescriptorFor(final ZipArchiveEntry zipArchiveEntry) {\n+        return !zipArchiveEntry.getGeneralPurposeBit().usesDataDescriptor() || (this.allowStoredEntriesWithDataDescriptor && zipArchiveEntry.getMethod() == 0) || zipArchiveEntry.getMethod() == 8 || zipArchiveEntry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode();\n     }\n     \n-    private boolean supportsCompressedSizeFor(final ZipArchiveEntry entry) {\n-        return entry.getCompressedSize() != -1L || entry.getMethod() == 8 || entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || (entry.getGeneralPurposeBit().usesDataDescriptor() && this.allowStoredEntriesWithDataDescriptor && entry.getMethod() == 0);\n+    private boolean supportsCompressedSizeFor(final ZipArchiveEntry zipArchiveEntry) {\n+        return zipArchiveEntry.getCompressedSize() != -1L || zipArchiveEntry.getMethod() == 8 || zipArchiveEntry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || (zipArchiveEntry.getGeneralPurposeBit().usesDataDescriptor() && this.allowStoredEntriesWithDataDescriptor && zipArchiveEntry.getMethod() == 0);\n     }\n     \n     private void readStoredEntry() throws IOException {\n-        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        int off = 0;\n-        boolean done = false;\n-        final int ddLen = ZipArchiveInputStream.CurrentEntry.access$400(this.current) ? 20 : 12;\n-        while (!done) {\n-            final int r = this.inputStream.read(this.buf.array(), off, 512 - off);\n-            if (r <= 0) {\n+        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+        int cacheBytesRead = 0;\n+        boolean bufferContainsSignature = false;\n+        final int n = ZipArchiveInputStream.CurrentEntry.access$400(this.current) ? 20 : 12;\n+        while (!bufferContainsSignature) {\n+            final int read = this.inputStream.read(this.buf.array(), cacheBytesRead, 512 - cacheBytesRead);\n+            if (read <= 0) {\n                 throw new IOException(\"Truncated ZIP file\");\n             }\n-            if (r + off < 4) {\n-                off += r;\n+            if (read + cacheBytesRead < 4) {\n+                cacheBytesRead += read;\n             }\n             else {\n-                done = this.bufferContainsSignature(bos, off, r, ddLen);\n-                if (done) {\n+                bufferContainsSignature = this.bufferContainsSignature(byteArrayOutputStream, cacheBytesRead, read, n);\n+                if (bufferContainsSignature) {\n                     continue;\n                 }\n-                off = this.cacheBytesRead(bos, off, r, ddLen);\n+                cacheBytesRead = this.cacheBytesRead(byteArrayOutputStream, cacheBytesRead, read, n);\n             }\n         }\n         if (ZipArchiveInputStream.CurrentEntry.access$100(this.current).getCompressedSize() != ZipArchiveInputStream.CurrentEntry.access$100(this.current).getSize()) {\n             throw new ZipException(\"compressed and uncompressed size don't match while reading a stored entry using data descriptor. Either the archive is broken or it can not be read using ZipArchiveInputStream and you must use ZipFile. A common cause for this is a ZIP archive containing a ZIP archive. See http://commons.apache.org/proper/commons-compress/zip.html#ZipArchiveInputStream_vs_ZipFile\");\n         }\n-        final byte[] b = bos.toByteArray();\n-        if (b.length != ZipArchiveInputStream.CurrentEntry.access$100(this.current).getSize()) {\n+        final byte[] byteArray = byteArrayOutputStream.toByteArray();\n+        if (byteArray.length != ZipArchiveInputStream.CurrentEntry.access$100(this.current).getSize()) {\n             throw new ZipException(\"actual and claimed size don't match while reading a stored entry using data descriptor. Either the archive is broken or it can not be read using ZipArchiveInputStream and you must use ZipFile. A common cause for this is a ZIP archive containing a ZIP archive. See http://commons.apache.org/proper/commons-compress/zip.html#ZipArchiveInputStream_vs_ZipFile\");\n         }\n-        this.lastStoredEntry = new ByteArrayInputStream(b);\n+        this.lastStoredEntry = new ByteArrayInputStream(byteArray);\n     }\n     \n-    private boolean bufferContainsSignature(final ByteArrayOutputStream bos, final int offset, final int lastRead, final int expectedDDLen) throws IOException {\n-        boolean done = false;\n-        for (int i = 0; !done && i < offset + lastRead - 4; ++i) {\n-            if (this.buf.array()[i] == ZipArchiveInputStream.LFH[0] && this.buf.array()[i + 1] == ZipArchiveInputStream.LFH[1]) {\n-                int expectDDPos = i;\n-                if ((i >= expectedDDLen && this.buf.array()[i + 2] == ZipArchiveInputStream.LFH[2] && this.buf.array()[i + 3] == ZipArchiveInputStream.LFH[3]) || (this.buf.array()[i + 2] == ZipArchiveInputStream.CFH[2] && this.buf.array()[i + 3] == ZipArchiveInputStream.CFH[3])) {\n-                    expectDDPos = i - expectedDDLen;\n-                    done = true;\n-                }\n-                else if (this.buf.array()[i + 2] == ZipArchiveInputStream.DD[2] && this.buf.array()[i + 3] == ZipArchiveInputStream.DD[3]) {\n-                    done = true;\n-                }\n-                if (done) {\n-                    this.pushback(this.buf.array(), expectDDPos, offset + lastRead - expectDDPos);\n-                    bos.write(this.buf.array(), 0, expectDDPos);\n+    private boolean bufferContainsSignature(final ByteArrayOutputStream byteArrayOutputStream, final int n, final int n2, final int n3) throws IOException {\n+        boolean b = false;\n+        for (int n4 = 0; !b && n4 < n + n2 - 4; ++n4) {\n+            if (this.buf.array()[n4] == ZipArchiveInputStream.LFH[0] && this.buf.array()[n4 + 1] == ZipArchiveInputStream.LFH[1]) {\n+                int len = n4;\n+                if ((n4 >= n3 && this.buf.array()[n4 + 2] == ZipArchiveInputStream.LFH[2] && this.buf.array()[n4 + 3] == ZipArchiveInputStream.LFH[3]) || (this.buf.array()[n4 + 2] == ZipArchiveInputStream.CFH[2] && this.buf.array()[n4 + 3] == ZipArchiveInputStream.CFH[3])) {\n+                    len = n4 - n3;\n+                    b = true;\n+                }\n+                else if (this.buf.array()[n4 + 2] == ZipArchiveInputStream.DD[2] && this.buf.array()[n4 + 3] == ZipArchiveInputStream.DD[3]) {\n+                    b = true;\n+                }\n+                if (b) {\n+                    this.pushback(this.buf.array(), len, n + n2 - len);\n+                    byteArrayOutputStream.write(this.buf.array(), 0, len);\n                     this.readDataDescriptor();\n                 }\n             }\n         }\n-        return done;\n+        return b;\n     }\n     \n-    private int cacheBytesRead(final ByteArrayOutputStream bos, int offset, final int lastRead, final int expecteDDLen) {\n-        final int cacheable = offset + lastRead - expecteDDLen - 3;\n-        if (cacheable > 0) {\n-            bos.write(this.buf.array(), 0, cacheable);\n-            System.arraycopy(this.buf.array(), cacheable, this.buf.array(), 0, expecteDDLen + 3);\n-            offset = expecteDDLen + 3;\n+    private int cacheBytesRead(final ByteArrayOutputStream byteArrayOutputStream, int n, final int n2, final int n3) {\n+        final int len = n + n2 - n3 - 3;\n+        if (len > 0) {\n+            byteArrayOutputStream.write(this.buf.array(), 0, len);\n+            System.arraycopy(this.buf.array(), len, this.buf.array(), 0, n3 + 3);\n+            n = n3 + 3;\n         }\n         else {\n-            offset += lastRead;\n+            n += n2;\n         }\n-        return offset;\n+        return n;\n     }\n     \n-    private void pushback(final byte[] buf, final int offset, final int length) throws IOException {\n-        ((PushbackInputStream)this.inputStream).unread(buf, offset, length);\n-        this.pushedBackBytes((long)length);\n+    private void pushback(final byte[] b, final int off, final int len) throws IOException {\n+        ((PushbackInputStream)this.inputStream).unread(b, off, len);\n+        this.pushedBackBytes((long)len);\n     }\n     \n     private void skipRemainderOfArchive() throws IOException {\n         if (this.entriesRead > 0) {\n             this.realSkip(this.entriesRead * 46L - 30L);\n-            final boolean foundEocd = this.findEocdRecord();\n-            if (foundEocd) {\n+            if (this.findEocdRecord()) {\n                 this.realSkip(16L);\n                 this.readFully(this.shortBuf);\n-                final int commentLen = ZipShort.getValue(this.shortBuf);\n-                if (commentLen >= 0) {\n-                    this.realSkip(commentLen);\n+                final int value = ZipShort.getValue(this.shortBuf);\n+                if (value >= 0) {\n+                    this.realSkip(value);\n                     return;\n                 }\n             }\n         }\n         throw new IOException(\"Truncated ZIP file\");\n     }\n     \n     private boolean findEocdRecord() throws IOException {\n-        int currentByte = -1;\n-        boolean skipReadCall = false;\n-        while (skipReadCall || (currentByte = this.readOneByte()) > -1) {\n-            skipReadCall = false;\n-            if (!this.isFirstByteOfEocdSig(currentByte)) {\n+        int n = -1;\n+        int n2 = 0;\n+        while (n2 != 0 || (n = this.readOneByte()) > -1) {\n+            n2 = 0;\n+            if (!this.isFirstByteOfEocdSig(n)) {\n                 continue;\n             }\n-            currentByte = this.readOneByte();\n-            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[1]) {\n-                if (currentByte == -1) {\n+            n = this.readOneByte();\n+            if (n != ZipArchiveOutputStream.EOCD_SIG[1]) {\n+                if (n == -1) {\n                     break;\n                 }\n-                skipReadCall = this.isFirstByteOfEocdSig(currentByte);\n+                n2 = (this.isFirstByteOfEocdSig(n) ? 1 : 0);\n             }\n             else {\n-                currentByte = this.readOneByte();\n-                if (currentByte != ZipArchiveOutputStream.EOCD_SIG[2]) {\n-                    if (currentByte == -1) {\n+                n = this.readOneByte();\n+                if (n != ZipArchiveOutputStream.EOCD_SIG[2]) {\n+                    if (n == -1) {\n                         break;\n                     }\n-                    skipReadCall = this.isFirstByteOfEocdSig(currentByte);\n+                    n2 = (this.isFirstByteOfEocdSig(n) ? 1 : 0);\n                 }\n                 else {\n-                    currentByte = this.readOneByte();\n-                    if (currentByte == -1) {\n+                    n = this.readOneByte();\n+                    if (n == -1) {\n                         break;\n                     }\n-                    if (currentByte == ZipArchiveOutputStream.EOCD_SIG[3]) {\n+                    if (n == ZipArchiveOutputStream.EOCD_SIG[3]) {\n                         return true;\n                     }\n-                    skipReadCall = this.isFirstByteOfEocdSig(currentByte);\n+                    n2 = (this.isFirstByteOfEocdSig(n) ? 1 : 0);\n                 }\n             }\n         }\n         return false;\n     }\n     \n-    private void realSkip(final long value) throws IOException {\n-        if (value >= 0L) {\n-            int x;\n-            for (long skipped = 0L; skipped < value; skipped += x) {\n-                final long rem = value - skipped;\n-                x = this.inputStream.read(this.skipBuf, 0, (int)((this.skipBuf.length > rem) ? rem : ((long)this.skipBuf.length)));\n-                if (x == -1) {\n+    private void realSkip(final long n) throws IOException {\n+        if (n >= 0L) {\n+            int read;\n+            for (long n2 = 0L; n2 < n; n2 += read) {\n+                final long n3 = n - n2;\n+                read = this.inputStream.read(this.skipBuf, 0, (int)((this.skipBuf.length > n3) ? n3 : ((long)this.skipBuf.length)));\n+                if (read == -1) {\n                     return;\n                 }\n-                this.count(x);\n+                this.count(read);\n             }\n             return;\n         }\n         throw new IllegalArgumentException();\n     }\n     \n     private int readOneByte() throws IOException {\n-        final int b = this.inputStream.read();\n-        if (b != -1) {\n+        final int read = this.inputStream.read();\n+        if (read != -1) {\n             this.count(1);\n         }\n-        return b;\n+        return read;\n     }\n     \n-    private boolean isFirstByteOfEocdSig(final int b) {\n-        return b == ZipArchiveOutputStream.EOCD_SIG[0];\n+    private boolean isFirstByteOfEocdSig(final int n) {\n+        return n == ZipArchiveOutputStream.EOCD_SIG[0];\n     }\n     \n-    private boolean isApkSigningBlock(final byte[] suspectLocalFileHeader) throws IOException {\n-        final BigInteger len = ZipEightByteInteger.getValue(suspectLocalFileHeader);\n-        BigInteger toSkip = len.add(BigInteger.valueOf((long)(8 - suspectLocalFileHeader.length) - (long)ZipArchiveInputStream.APK_SIGNING_BLOCK_MAGIC.length));\n-        final byte[] magic = new byte[ZipArchiveInputStream.APK_SIGNING_BLOCK_MAGIC.length];\n+    private boolean isApkSigningBlock(final byte[] array) throws IOException {\n+        BigInteger bigInteger = ZipEightByteInteger.getValue(array).add(BigInteger.valueOf((long)(8 - array.length) - (long)ZipArchiveInputStream.APK_SIGNING_BLOCK_MAGIC.length));\n+        final byte[] a = new byte[ZipArchiveInputStream.APK_SIGNING_BLOCK_MAGIC.length];\n         try {\n-            if (toSkip.signum() < 0) {\n-                final int off = suspectLocalFileHeader.length + toSkip.intValue();\n-                if (off < 8) {\n+            if (bigInteger.signum() < 0) {\n+                final int n = array.length + bigInteger.intValue();\n+                if (n < 8) {\n                     return false;\n                 }\n-                final int bytesInBuffer = Math.abs(toSkip.intValue());\n-                System.arraycopy(suspectLocalFileHeader, off, magic, 0, Math.min(bytesInBuffer, magic.length));\n-                if (bytesInBuffer < magic.length) {\n-                    this.readFully(magic, bytesInBuffer);\n+                final int abs = Math.abs(bigInteger.intValue());\n+                System.arraycopy(array, n, a, 0, Math.min(abs, a.length));\n+                if (abs < a.length) {\n+                    this.readFully(a, abs);\n                 }\n             }\n             else {\n-                while (toSkip.compareTo(ZipArchiveInputStream.LONG_MAX) > 0) {\n+                while (bigInteger.compareTo(ZipArchiveInputStream.LONG_MAX) > 0) {\n                     this.realSkip(Long.MAX_VALUE);\n-                    toSkip = toSkip.add(ZipArchiveInputStream.LONG_MAX.negate());\n+                    bigInteger = bigInteger.add(ZipArchiveInputStream.LONG_MAX.negate());\n                 }\n-                this.realSkip(toSkip.longValue());\n-                this.readFully(magic);\n+                this.realSkip(bigInteger.longValue());\n+                this.readFully(a);\n             }\n         }\n         catch (final EOFException ex) {\n             return false;\n         }\n-        return Arrays.equals(magic, ZipArchiveInputStream.APK_SIGNING_BLOCK_MAGIC);\n+        return Arrays.equals(a, ZipArchiveInputStream.APK_SIGNING_BLOCK_MAGIC);\n     }\n     \n     static {\n         LFH = ZipLong.LFH_SIG.getBytes();\n         CFH = ZipLong.CFH_SIG.getBytes();\n         DD = ZipLong.DD_SIG.getBytes();\n         APK_SIGNING_BLOCK_MAGIC = new byte[] { 65, 80, 75, 32, 83, 105, 103, 32, 66, 108, 111, 99, 107, 32, 52, 50 };\n"}]}
