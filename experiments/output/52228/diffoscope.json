{"diffoscope-json-version": 1, "source1": "first/ZipArchiveInputStream.class", "source2": "second/ZipArchiveInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -48,14 +48,22 @@\n     private static final String USE_ZIPFILE_INSTEAD_OF_STREAM_DISCLAIMER = \" while reading a stored entry using data descriptor. Either the archive is broken or it can not be read using ZipArchiveInputStream and you must use ZipFile. A common cause for this is a ZIP archive containing a ZIP archive. See http://commons.apache.org/proper/commons-compress/zip.html#ZipArchiveInputStream_vs_ZipFile\";\n     private static final byte[] LFH;\n     private static final byte[] CFH;\n     private static final byte[] DD;\n     private static final byte[] APK_SIGNING_BLOCK_MAGIC;\n     private static final BigInteger LONG_MAX;\n     \n+    static {\n+        LFH = ZipLong.LFH_SIG.getBytes();\n+        CFH = ZipLong.CFH_SIG.getBytes();\n+        DD = ZipLong.DD_SIG.getBytes();\n+        APK_SIGNING_BLOCK_MAGIC = new byte[] { 65, 80, 75, 32, 83, 105, 103, 32, 66, 108, 111, 99, 107, 32, 52, 50 };\n+        LONG_MAX = BigInteger.valueOf(Long.MAX_VALUE);\n+    }\n+    \n     public ZipArchiveInputStream(final InputStream inputStream) {\n         this(inputStream, \"UTF8\");\n     }\n     \n     public ZipArchiveInputStream(final InputStream inputStream, final String encoding) {\n         this(inputStream, encoding, true);\n     }\n@@ -85,15 +93,15 @@\n         this.entriesRead = 0;\n         this.encoding = encoding;\n         this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n         this.useUnicodeExtraFields = useUnicodeExtraFields;\n         this.in = new PushbackInputStream(inputStream, this.buf.capacity());\n         this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n         this.skipSplitSig = skipSplitSig;\n-        this.buf.limit();\n+        this.buf.limit(0);\n     }\n     \n     public ZipArchiveEntry getNextZipEntry() throws IOException {\n         this.uncompressedCount = 0L;\n         boolean firstEntry = true;\n         if (this.closed || this.hitCentralDirectory) {\n             return null;\n@@ -107,39 +115,39 @@\n             if (firstEntry) {\n                 this.readFirstLocalFileHeader(this.lfhBuf);\n             }\n             else {\n                 this.readFully(this.lfhBuf);\n             }\n         }\n-        catch (final EOFException e) {\n+        catch (final EOFException ex) {\n             return null;\n         }\n         final ZipLong sig = new ZipLong(this.lfhBuf);\n         if (sig.equals((Object)ZipLong.LFH_SIG)) {\n             int off = 4;\n-            this.current = new ZipArchiveInputStream.CurrentEntry((ZipArchiveInputStream.ZipArchiveInputStream$1)null);\n+            this.current = new ZipArchiveInputStream.CurrentEntry((ZipArchiveInputStream.CurrentEntry)null);\n             final int versionMadeBy = ZipShort.getValue(this.lfhBuf, off);\n             off += 2;\n-            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setPlatform(versionMadeBy >> 8 & 0xF);\n+            ZipArchiveInputStream.CurrentEntry.access$3(this.current).setPlatform(versionMadeBy >> 8 & 0xF);\n             final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(this.lfhBuf, off);\n             final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n             final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : this.zipEncoding;\n-            ZipArchiveInputStream.CurrentEntry.access$202(this.current, gpFlag.usesDataDescriptor());\n-            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setGeneralPurposeBit(gpFlag);\n+            ZipArchiveInputStream.CurrentEntry.access$4(this.current, gpFlag.usesDataDescriptor());\n+            ZipArchiveInputStream.CurrentEntry.access$3(this.current).setGeneralPurposeBit(gpFlag);\n             off += 2;\n-            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setMethod(ZipShort.getValue(this.lfhBuf, off));\n+            ZipArchiveInputStream.CurrentEntry.access$3(this.current).setMethod(ZipShort.getValue(this.lfhBuf, off));\n             off += 2;\n             final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(this.lfhBuf, off));\n-            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setTime(time);\n+            ZipArchiveInputStream.CurrentEntry.access$3(this.current).setTime(time);\n             off += 4;\n             ZipLong size = null;\n             ZipLong cSize = null;\n-            if (!ZipArchiveInputStream.CurrentEntry.access$200(this.current)) {\n-                ZipArchiveInputStream.CurrentEntry.access$100(this.current).setCrc(ZipLong.getValue(this.lfhBuf, off));\n+            if (!ZipArchiveInputStream.CurrentEntry.access$5(this.current)) {\n+                ZipArchiveInputStream.CurrentEntry.access$3(this.current).setCrc(ZipLong.getValue(this.lfhBuf, off));\n                 off += 4;\n                 cSize = new ZipLong(this.lfhBuf, off);\n                 off += 4;\n                 size = new ZipLong(this.lfhBuf, off);\n                 off += 4;\n             }\n             else {\n@@ -147,57 +155,57 @@\n             }\n             final int fileNameLen = ZipShort.getValue(this.lfhBuf, off);\n             off += 2;\n             final int extraLen = ZipShort.getValue(this.lfhBuf, off);\n             off += 2;\n             final byte[] fileName = new byte[fileNameLen];\n             this.readFully(fileName);\n-            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setName(entryEncoding.decode(fileName), fileName);\n+            ZipArchiveInputStream.CurrentEntry.access$3(this.current).setName(entryEncoding.decode(fileName), fileName);\n             if (hasUTF8Flag) {\n-                ZipArchiveInputStream.CurrentEntry.access$100(this.current).setNameSource(ZipArchiveEntry.NameSource.NAME_WITH_EFS_FLAG);\n+                ZipArchiveInputStream.CurrentEntry.access$3(this.current).setNameSource(ZipArchiveEntry.NameSource.NAME_WITH_EFS_FLAG);\n             }\n             final byte[] extraData = new byte[extraLen];\n             this.readFully(extraData);\n-            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setExtra(extraData);\n+            ZipArchiveInputStream.CurrentEntry.access$3(this.current).setExtra(extraData);\n             if (!hasUTF8Flag && this.useUnicodeExtraFields) {\n-                ZipUtil.setNameAndCommentFromExtraFields(ZipArchiveInputStream.CurrentEntry.access$100(this.current), fileName, (byte[])null);\n+                ZipUtil.setNameAndCommentFromExtraFields(ZipArchiveInputStream.CurrentEntry.access$3(this.current), fileName, (byte[])null);\n             }\n             this.processZip64Extra(size, cSize);\n-            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setLocalHeaderOffset(currentHeaderOffset);\n-            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setDataOffset(this.getBytesRead());\n-            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setStreamContiguous(true);\n-            final ZipMethod m = ZipMethod.getMethodByCode(ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod());\n-            if (ZipArchiveInputStream.CurrentEntry.access$100(this.current).getCompressedSize() != -1L) {\n-                if (ZipUtil.canHandleEntryData(ZipArchiveInputStream.CurrentEntry.access$100(this.current)) && m != ZipMethod.STORED && m != ZipMethod.DEFLATED) {\n-                    final InputStream bis = (InputStream)new ZipArchiveInputStream.BoundedInputStream(this, this.in, ZipArchiveInputStream.CurrentEntry.access$100(this.current).getCompressedSize());\n-                    switch (ZipArchiveInputStream.ZipArchiveInputStream$1.$SwitchMap$org$apache$commons$compress$archivers$zip$ZipMethod[m.ordinal()]) {\n-                        case 1: {\n-                            ZipArchiveInputStream.CurrentEntry.access$302(this.current, (InputStream)new UnshrinkingInputStream(bis));\n+            ZipArchiveInputStream.CurrentEntry.access$3(this.current).setLocalHeaderOffset(currentHeaderOffset);\n+            ZipArchiveInputStream.CurrentEntry.access$3(this.current).setDataOffset(this.getBytesRead());\n+            ZipArchiveInputStream.CurrentEntry.access$3(this.current).setStreamContiguous(true);\n+            final ZipMethod m = ZipMethod.getMethodByCode(ZipArchiveInputStream.CurrentEntry.access$3(this.current).getMethod());\n+            if (ZipArchiveInputStream.CurrentEntry.access$3(this.current).getCompressedSize() != -1L) {\n+                if (ZipUtil.canHandleEntryData(ZipArchiveInputStream.CurrentEntry.access$3(this.current)) && m != ZipMethod.STORED && m != ZipMethod.DEFLATED) {\n+                    final InputStream bis = (InputStream)new ZipArchiveInputStream.BoundedInputStream(this, this.in, ZipArchiveInputStream.CurrentEntry.access$3(this.current).getCompressedSize());\n+                    switch (m) {\n+                        case UNSHRINKING: {\n+                            ZipArchiveInputStream.CurrentEntry.access$6(this.current, (InputStream)new UnshrinkingInputStream(bis));\n                             break;\n                         }\n-                        case 2: {\n-                            ZipArchiveInputStream.CurrentEntry.access$302(this.current, (InputStream)new ExplodingInputStream(ZipArchiveInputStream.CurrentEntry.access$100(this.current).getGeneralPurposeBit().getSlidingDictionarySize(), ZipArchiveInputStream.CurrentEntry.access$100(this.current).getGeneralPurposeBit().getNumberOfShannonFanoTrees(), bis));\n+                        case IMPLODING: {\n+                            ZipArchiveInputStream.CurrentEntry.access$6(this.current, (InputStream)new ExplodingInputStream(ZipArchiveInputStream.CurrentEntry.access$3(this.current).getGeneralPurposeBit().getSlidingDictionarySize(), ZipArchiveInputStream.CurrentEntry.access$3(this.current).getGeneralPurposeBit().getNumberOfShannonFanoTrees(), bis));\n                             break;\n                         }\n-                        case 3: {\n-                            ZipArchiveInputStream.CurrentEntry.access$302(this.current, (InputStream)new BZip2CompressorInputStream(bis));\n+                        case BZIP2: {\n+                            ZipArchiveInputStream.CurrentEntry.access$6(this.current, (InputStream)new BZip2CompressorInputStream(bis));\n                             break;\n                         }\n-                        case 4: {\n-                            ZipArchiveInputStream.CurrentEntry.access$302(this.current, (InputStream)new Deflate64CompressorInputStream(bis));\n+                        case ENHANCED_DEFLATED: {\n+                            ZipArchiveInputStream.CurrentEntry.access$6(this.current, (InputStream)new Deflate64CompressorInputStream(bis));\n                             break;\n                         }\n                     }\n                 }\n             }\n             else if (m == ZipMethod.ENHANCED_DEFLATED) {\n-                ZipArchiveInputStream.CurrentEntry.access$302(this.current, (InputStream)new Deflate64CompressorInputStream(this.in));\n+                ZipArchiveInputStream.CurrentEntry.access$6(this.current, (InputStream)new Deflate64CompressorInputStream(this.in));\n             }\n             ++this.entriesRead;\n-            return ZipArchiveInputStream.CurrentEntry.access$100(this.current);\n+            return ZipArchiveInputStream.CurrentEntry.access$3(this.current);\n         }\n         if (sig.equals((Object)ZipLong.CFH_SIG) || sig.equals((Object)ZipLong.AED_SIG) || this.isApkSigningBlock(this.lfhBuf)) {\n             this.hitCentralDirectory = true;\n             this.skipRemainderOfArchive();\n             return null;\n         }\n         throw new ZipException(String.format(\"Unexpected record signature: 0X%X\", Long.valueOf(sig.getValue())));\n@@ -214,24 +222,24 @@\n             this.readFully(missedLfhBytes);\n             System.arraycopy(lfh, 4, lfh, 0, 26);\n             System.arraycopy(missedLfhBytes, 0, lfh, 26, 4);\n         }\n     }\n     \n     private void processZip64Extra(final ZipLong size, final ZipLong cSize) {\n-        final Zip64ExtendedInformationExtraField z64 = (Zip64ExtendedInformationExtraField)ZipArchiveInputStream.CurrentEntry.access$100(this.current).getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n-        ZipArchiveInputStream.CurrentEntry.access$402(this.current, z64 != null);\n-        if (!ZipArchiveInputStream.CurrentEntry.access$200(this.current)) {\n+        final Zip64ExtendedInformationExtraField z64 = (Zip64ExtendedInformationExtraField)ZipArchiveInputStream.CurrentEntry.access$3(this.current).getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n+        ZipArchiveInputStream.CurrentEntry.access$7(this.current, z64 != null);\n+        if (!ZipArchiveInputStream.CurrentEntry.access$5(this.current)) {\n             if (z64 != null && (ZipLong.ZIP64_MAGIC.equals((Object)cSize) || ZipLong.ZIP64_MAGIC.equals((Object)size))) {\n-                ZipArchiveInputStream.CurrentEntry.access$100(this.current).setCompressedSize(z64.getCompressedSize().getLongValue());\n-                ZipArchiveInputStream.CurrentEntry.access$100(this.current).setSize(z64.getSize().getLongValue());\n+                ZipArchiveInputStream.CurrentEntry.access$3(this.current).setCompressedSize(z64.getCompressedSize().getLongValue());\n+                ZipArchiveInputStream.CurrentEntry.access$3(this.current).setSize(z64.getSize().getLongValue());\n             }\n             else if (cSize != null && size != null) {\n-                ZipArchiveInputStream.CurrentEntry.access$100(this.current).setCompressedSize(cSize.getValue());\n-                ZipArchiveInputStream.CurrentEntry.access$100(this.current).setSize(size.getValue());\n+                ZipArchiveInputStream.CurrentEntry.access$3(this.current).setCompressedSize(cSize.getValue());\n+                ZipArchiveInputStream.CurrentEntry.access$3(this.current).setSize(size.getValue());\n             }\n         }\n     }\n     \n     public ArchiveEntry getNextEntry() throws IOException {\n         return (ArchiveEntry)this.getNextZipEntry();\n     }\n@@ -253,97 +261,97 @@\n         }\n         if (this.current == null) {\n             return -1;\n         }\n         if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n             throw new ArrayIndexOutOfBoundsException();\n         }\n-        ZipUtil.checkRequestedFeatures(ZipArchiveInputStream.CurrentEntry.access$100(this.current));\n-        if (!this.supportsDataDescriptorFor(ZipArchiveInputStream.CurrentEntry.access$100(this.current))) {\n-            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, ZipArchiveInputStream.CurrentEntry.access$100(this.current));\n+        ZipUtil.checkRequestedFeatures(ZipArchiveInputStream.CurrentEntry.access$3(this.current));\n+        if (!this.supportsDataDescriptorFor(ZipArchiveInputStream.CurrentEntry.access$3(this.current))) {\n+            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, ZipArchiveInputStream.CurrentEntry.access$3(this.current));\n         }\n-        if (!this.supportsCompressedSizeFor(ZipArchiveInputStream.CurrentEntry.access$100(this.current))) {\n-            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.UNKNOWN_COMPRESSED_SIZE, ZipArchiveInputStream.CurrentEntry.access$100(this.current));\n+        if (!this.supportsCompressedSizeFor(ZipArchiveInputStream.CurrentEntry.access$3(this.current))) {\n+            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.UNKNOWN_COMPRESSED_SIZE, ZipArchiveInputStream.CurrentEntry.access$3(this.current));\n         }\n         int read;\n-        if (ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod() == 0) {\n+        if (ZipArchiveInputStream.CurrentEntry.access$3(this.current).getMethod() == 0) {\n             read = this.readStored(buffer, offset, length);\n         }\n-        else if (ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod() == 8) {\n+        else if (ZipArchiveInputStream.CurrentEntry.access$3(this.current).getMethod() == 8) {\n             read = this.readDeflated(buffer, offset, length);\n         }\n         else {\n-            if (ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod() != ZipMethod.UNSHRINKING.getCode() && ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod() != ZipMethod.IMPLODING.getCode() && ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod() != ZipMethod.ENHANCED_DEFLATED.getCode() && ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod() != ZipMethod.BZIP2.getCode()) {\n-                throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod()), ZipArchiveInputStream.CurrentEntry.access$100(this.current));\n+            if (ZipArchiveInputStream.CurrentEntry.access$3(this.current).getMethod() != ZipMethod.UNSHRINKING.getCode() && ZipArchiveInputStream.CurrentEntry.access$3(this.current).getMethod() != ZipMethod.IMPLODING.getCode() && ZipArchiveInputStream.CurrentEntry.access$3(this.current).getMethod() != ZipMethod.ENHANCED_DEFLATED.getCode() && ZipArchiveInputStream.CurrentEntry.access$3(this.current).getMethod() != ZipMethod.BZIP2.getCode()) {\n+                throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(ZipArchiveInputStream.CurrentEntry.access$3(this.current).getMethod()), ZipArchiveInputStream.CurrentEntry.access$3(this.current));\n             }\n-            read = ZipArchiveInputStream.CurrentEntry.access$300(this.current).read(buffer, offset, length);\n+            read = ZipArchiveInputStream.CurrentEntry.access$8(this.current).read(buffer, offset, length);\n         }\n         if (read >= 0) {\n-            ZipArchiveInputStream.CurrentEntry.access$500(this.current).update(buffer, offset, read);\n+            ZipArchiveInputStream.CurrentEntry.access$9(this.current).update(buffer, offset, read);\n             this.uncompressedCount += read;\n         }\n         return read;\n     }\n     \n     public long getCompressedCount() {\n-        if (ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod() == 0) {\n-            return ZipArchiveInputStream.CurrentEntry.access$600(this.current);\n+        if (ZipArchiveInputStream.CurrentEntry.access$3(this.current).getMethod() == 0) {\n+            return ZipArchiveInputStream.CurrentEntry.access$10(this.current);\n         }\n-        if (ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod() == 8) {\n+        if (ZipArchiveInputStream.CurrentEntry.access$3(this.current).getMethod() == 8) {\n             return this.getBytesInflated();\n         }\n-        if (ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n-            return ((UnshrinkingInputStream)ZipArchiveInputStream.CurrentEntry.access$300(this.current)).getCompressedCount();\n+        if (ZipArchiveInputStream.CurrentEntry.access$3(this.current).getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n+            return ((UnshrinkingInputStream)ZipArchiveInputStream.CurrentEntry.access$8(this.current)).getCompressedCount();\n         }\n-        if (ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod() == ZipMethod.IMPLODING.getCode()) {\n-            return ((ExplodingInputStream)ZipArchiveInputStream.CurrentEntry.access$300(this.current)).getCompressedCount();\n+        if (ZipArchiveInputStream.CurrentEntry.access$3(this.current).getMethod() == ZipMethod.IMPLODING.getCode()) {\n+            return ((ExplodingInputStream)ZipArchiveInputStream.CurrentEntry.access$8(this.current)).getCompressedCount();\n         }\n-        if (ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode()) {\n-            return ((Deflate64CompressorInputStream)ZipArchiveInputStream.CurrentEntry.access$300(this.current)).getCompressedCount();\n+        if (ZipArchiveInputStream.CurrentEntry.access$3(this.current).getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode()) {\n+            return ((Deflate64CompressorInputStream)ZipArchiveInputStream.CurrentEntry.access$8(this.current)).getCompressedCount();\n         }\n-        if (ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod() == ZipMethod.BZIP2.getCode()) {\n-            return ((BZip2CompressorInputStream)ZipArchiveInputStream.CurrentEntry.access$300(this.current)).getCompressedCount();\n+        if (ZipArchiveInputStream.CurrentEntry.access$3(this.current).getMethod() == ZipMethod.BZIP2.getCode()) {\n+            return ((BZip2CompressorInputStream)ZipArchiveInputStream.CurrentEntry.access$8(this.current)).getCompressedCount();\n         }\n         return -1L;\n     }\n     \n     public long getUncompressedCount() {\n         return this.uncompressedCount;\n     }\n     \n     private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n-        if (ZipArchiveInputStream.CurrentEntry.access$200(this.current)) {\n+        if (ZipArchiveInputStream.CurrentEntry.access$5(this.current)) {\n             if (this.lastStoredEntry == null) {\n                 this.readStoredEntry();\n             }\n             return this.lastStoredEntry.read(buffer, offset, length);\n         }\n-        final long csize = ZipArchiveInputStream.CurrentEntry.access$100(this.current).getSize();\n-        if (ZipArchiveInputStream.CurrentEntry.access$600(this.current) >= csize) {\n+        final long csize = ZipArchiveInputStream.CurrentEntry.access$3(this.current).getSize();\n+        if (ZipArchiveInputStream.CurrentEntry.access$10(this.current) >= csize) {\n             return -1;\n         }\n         if (this.buf.position() >= this.buf.limit()) {\n-            this.buf.position();\n+            this.buf.position(0);\n             final int l = this.in.read(this.buf.array());\n             if (l == -1) {\n-                this.buf.limit();\n+                this.buf.limit(0);\n                 throw new IOException(\"Truncated ZIP file\");\n             }\n-            this.buf.limit();\n+            this.buf.limit(l);\n             this.count(l);\n             final ZipArchiveInputStream.CurrentEntry current = this.current;\n-            ZipArchiveInputStream.CurrentEntry.access$702(current, ZipArchiveInputStream.CurrentEntry.access$700(current) + (long)l);\n+            ZipArchiveInputStream.CurrentEntry.access$1(current, ZipArchiveInputStream.CurrentEntry.access$0(current) + (long)l);\n         }\n         int toRead = Math.min(this.buf.remaining(), length);\n-        if (csize - ZipArchiveInputStream.CurrentEntry.access$600(this.current) < toRead) {\n-            toRead = (int)(csize - ZipArchiveInputStream.CurrentEntry.access$600(this.current));\n+        if (csize - ZipArchiveInputStream.CurrentEntry.access$10(this.current) < toRead) {\n+            toRead = (int)(csize - ZipArchiveInputStream.CurrentEntry.access$10(this.current));\n         }\n         this.buf.get(buffer, offset, toRead);\n         final ZipArchiveInputStream.CurrentEntry current2 = this.current;\n-        ZipArchiveInputStream.CurrentEntry.access$602(current2, ZipArchiveInputStream.CurrentEntry.access$600(current2) + (long)toRead);\n+        ZipArchiveInputStream.CurrentEntry.access$11(current2, ZipArchiveInputStream.CurrentEntry.access$10(current2) + (long)toRead);\n         return toRead;\n     }\n     \n     private int readDeflated(final byte[] buffer, final int offset, final int length) throws IOException {\n         final int read = this.readFromInflater(buffer, offset, length);\n         if (read <= 0) {\n             if (this.inf.finished()) {\n@@ -362,15 +370,15 @@\n     private int readFromInflater(final byte[] buffer, final int offset, final int length) throws IOException {\n         int read = 0;\n         do {\n             if (this.inf.needsInput()) {\n                 final int l = this.fill();\n                 if (l > 0) {\n                     final ZipArchiveInputStream.CurrentEntry current = this.current;\n-                    ZipArchiveInputStream.CurrentEntry.access$702(current, ZipArchiveInputStream.CurrentEntry.access$700(current) + (long)this.buf.limit());\n+                    ZipArchiveInputStream.CurrentEntry.access$1(current, ZipArchiveInputStream.CurrentEntry.access$0(current) + (long)this.buf.limit());\n                 }\n                 else {\n                     if (l == -1) {\n                         return -1;\n                     }\n                     break;\n                 }\n@@ -390,14 +398,15 @@\n             this.closed = true;\n             try {\n                 this.in.close();\n             }\n             finally {\n                 this.inf.end();\n             }\n+            this.inf.end();\n         }\n     }\n     \n     public long skip(final long value) throws IOException {\n         if (value >= 0L) {\n             long skipped;\n             int x;\n@@ -434,66 +443,66 @@\n             return;\n         }\n         if (this.currentEntryHasOutstandingBytes()) {\n             this.drainCurrentEntryData();\n         }\n         else {\n             this.skip(Long.MAX_VALUE);\n-            final long inB = (ZipArchiveInputStream.CurrentEntry.access$100(this.current).getMethod() == 8) ? this.getBytesInflated() : ZipArchiveInputStream.CurrentEntry.access$600(this.current);\n-            final int diff = (int)(ZipArchiveInputStream.CurrentEntry.access$700(this.current) - inB);\n+            final long inB = (ZipArchiveInputStream.CurrentEntry.access$3(this.current).getMethod() == 8) ? this.getBytesInflated() : ZipArchiveInputStream.CurrentEntry.access$10(this.current);\n+            final int diff = (int)(ZipArchiveInputStream.CurrentEntry.access$0(this.current) - inB);\n             if (diff > 0) {\n                 this.pushback(this.buf.array(), this.buf.limit() - diff, diff);\n                 final ZipArchiveInputStream.CurrentEntry current = this.current;\n-                ZipArchiveInputStream.CurrentEntry.access$702(current, ZipArchiveInputStream.CurrentEntry.access$700(current) - (long)diff);\n+                ZipArchiveInputStream.CurrentEntry.access$1(current, ZipArchiveInputStream.CurrentEntry.access$0(current) - (long)diff);\n             }\n             if (this.currentEntryHasOutstandingBytes()) {\n                 this.drainCurrentEntryData();\n             }\n         }\n-        if (this.lastStoredEntry == null && ZipArchiveInputStream.CurrentEntry.access$200(this.current)) {\n+        if (this.lastStoredEntry == null && ZipArchiveInputStream.CurrentEntry.access$5(this.current)) {\n             this.readDataDescriptor();\n         }\n         this.inf.reset();\n         this.buf.clear().flip();\n         this.current = null;\n         this.lastStoredEntry = null;\n     }\n     \n     private boolean currentEntryHasOutstandingBytes() {\n-        return ZipArchiveInputStream.CurrentEntry.access$700(this.current) <= ZipArchiveInputStream.CurrentEntry.access$100(this.current).getCompressedSize() && !ZipArchiveInputStream.CurrentEntry.access$200(this.current);\n+        return ZipArchiveInputStream.CurrentEntry.access$0(this.current) <= ZipArchiveInputStream.CurrentEntry.access$3(this.current).getCompressedSize() && !ZipArchiveInputStream.CurrentEntry.access$5(this.current);\n     }\n     \n     private void drainCurrentEntryData() throws IOException {\n         long n;\n-        for (long remaining = ZipArchiveInputStream.CurrentEntry.access$100(this.current).getCompressedSize() - ZipArchiveInputStream.CurrentEntry.access$700(this.current); remaining > 0L; remaining -= n) {\n+        for (long remaining = ZipArchiveInputStream.CurrentEntry.access$3(this.current).getCompressedSize() - ZipArchiveInputStream.CurrentEntry.access$0(this.current); remaining > 0L; remaining -= n) {\n             n = this.in.read(this.buf.array(), 0, (int)Math.min(this.buf.capacity(), remaining));\n             if (n < 0L) {\n-                throw new EOFException(\"Truncated ZIP entry: \" + ArchiveUtils.sanitize(ZipArchiveInputStream.CurrentEntry.access$100(this.current).getName()));\n+                throw new EOFException(\"Truncated ZIP entry: \" + ArchiveUtils.sanitize(ZipArchiveInputStream.CurrentEntry.access$3(this.current).getName()));\n             }\n             this.count(n);\n         }\n     }\n     \n     private long getBytesInflated() {\n         long inB = this.inf.getBytesRead();\n-        if (ZipArchiveInputStream.CurrentEntry.access$700(this.current) >= 4294967296L) {\n-            while (inB + 4294967296L <= ZipArchiveInputStream.CurrentEntry.access$700(this.current)) {\n+        if (ZipArchiveInputStream.CurrentEntry.access$0(this.current) >= 4294967296L) {\n+            while (inB + 4294967296L <= ZipArchiveInputStream.CurrentEntry.access$0(this.current)) {\n                 inB += 4294967296L;\n             }\n         }\n         return inB;\n     }\n     \n     private int fill() throws IOException {\n         if (this.closed) {\n             throw new IOException(\"The stream is closed\");\n         }\n         final int length = this.in.read(this.buf.array());\n         if (length > 0) {\n-            this.buf.limit();\n+            this.buf.limit(length);\n             this.count(this.buf.limit());\n             this.inf.setInput(this.buf.array(), 0, this.buf.limit());\n         }\n         return length;\n     }\n     \n     private void readFully(final byte[] b) throws IOException {\n@@ -512,25 +521,25 @@\n     private void readDataDescriptor() throws IOException {\n         this.readFully(this.wordBuf);\n         ZipLong val = new ZipLong(this.wordBuf);\n         if (ZipLong.DD_SIG.equals((Object)val)) {\n             this.readFully(this.wordBuf);\n             val = new ZipLong(this.wordBuf);\n         }\n-        ZipArchiveInputStream.CurrentEntry.access$100(this.current).setCrc(val.getValue());\n+        ZipArchiveInputStream.CurrentEntry.access$3(this.current).setCrc(val.getValue());\n         this.readFully(this.twoDwordBuf);\n         final ZipLong potentialSig = new ZipLong(this.twoDwordBuf, 8);\n         if (potentialSig.equals((Object)ZipLong.CFH_SIG) || potentialSig.equals((Object)ZipLong.LFH_SIG)) {\n             this.pushback(this.twoDwordBuf, 8, 8);\n-            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setCompressedSize(ZipLong.getValue(this.twoDwordBuf));\n-            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setSize(ZipLong.getValue(this.twoDwordBuf, 4));\n+            ZipArchiveInputStream.CurrentEntry.access$3(this.current).setCompressedSize(ZipLong.getValue(this.twoDwordBuf));\n+            ZipArchiveInputStream.CurrentEntry.access$3(this.current).setSize(ZipLong.getValue(this.twoDwordBuf, 4));\n         }\n         else {\n-            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setCompressedSize(ZipEightByteInteger.getLongValue(this.twoDwordBuf));\n-            ZipArchiveInputStream.CurrentEntry.access$100(this.current).setSize(ZipEightByteInteger.getLongValue(this.twoDwordBuf, 8));\n+            ZipArchiveInputStream.CurrentEntry.access$3(this.current).setCompressedSize(ZipEightByteInteger.getLongValue(this.twoDwordBuf));\n+            ZipArchiveInputStream.CurrentEntry.access$3(this.current).setSize(ZipEightByteInteger.getLongValue(this.twoDwordBuf, 8));\n         }\n     }\n     \n     private boolean supportsDataDescriptorFor(final ZipArchiveEntry entry) {\n         return !entry.getGeneralPurposeBit().usesDataDescriptor() || (this.allowStoredEntriesWithDataDescriptor && entry.getMethod() == 0) || entry.getMethod() == 8 || entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode();\n     }\n     \n@@ -538,15 +547,15 @@\n         return entry.getCompressedSize() != -1L || entry.getMethod() == 8 || entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || (entry.getGeneralPurposeBit().usesDataDescriptor() && this.allowStoredEntriesWithDataDescriptor && entry.getMethod() == 0);\n     }\n     \n     private void readStoredEntry() throws IOException {\n         final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n         int off = 0;\n         boolean done = false;\n-        final int ddLen = ZipArchiveInputStream.CurrentEntry.access$400(this.current) ? 20 : 12;\n+        final int ddLen = ZipArchiveInputStream.CurrentEntry.access$12(this.current) ? 20 : 12;\n         while (!done) {\n             final int r = this.in.read(this.buf.array(), off, 512 - off);\n             if (r <= 0) {\n                 throw new IOException(\"Truncated ZIP file\");\n             }\n             if (r + off < 4) {\n                 off += r;\n@@ -555,19 +564,19 @@\n                 done = this.bufferContainsSignature(bos, off, r, ddLen);\n                 if (done) {\n                     continue;\n                 }\n                 off = this.cacheBytesRead(bos, off, r, ddLen);\n             }\n         }\n-        if (ZipArchiveInputStream.CurrentEntry.access$100(this.current).getCompressedSize() != ZipArchiveInputStream.CurrentEntry.access$100(this.current).getSize()) {\n+        if (ZipArchiveInputStream.CurrentEntry.access$3(this.current).getCompressedSize() != ZipArchiveInputStream.CurrentEntry.access$3(this.current).getSize()) {\n             throw new ZipException(\"compressed and uncompressed size don't match while reading a stored entry using data descriptor. Either the archive is broken or it can not be read using ZipArchiveInputStream and you must use ZipFile. A common cause for this is a ZIP archive containing a ZIP archive. See http://commons.apache.org/proper/commons-compress/zip.html#ZipArchiveInputStream_vs_ZipFile\");\n         }\n         final byte[] b = bos.toByteArray();\n-        if (b.length != ZipArchiveInputStream.CurrentEntry.access$100(this.current).getSize()) {\n+        if (b.length != ZipArchiveInputStream.CurrentEntry.access$3(this.current).getSize()) {\n             throw new ZipException(\"actual and claimed size don't match while reading a stored entry using data descriptor. Either the archive is broken or it can not be read using ZipArchiveInputStream and you must use ZipFile. A common cause for this is a ZIP archive containing a ZIP archive. See http://commons.apache.org/proper/commons-compress/zip.html#ZipArchiveInputStream_vs_ZipFile\");\n         }\n         this.lastStoredEntry = new ByteArrayInputStream(b);\n     }\n     \n     private boolean bufferContainsSignature(final ByteArrayOutputStream bos, final int offset, final int lastRead, final int expectedDDLen) throws IOException {\n         boolean done = false;\n@@ -708,16 +717,8 @@\n             }\n         }\n         catch (final EOFException ex) {\n             return false;\n         }\n         return Arrays.equals(magic, ZipArchiveInputStream.APK_SIGNING_BLOCK_MAGIC);\n     }\n-    \n-    static {\n-        LFH = ZipLong.LFH_SIG.getBytes();\n-        CFH = ZipLong.CFH_SIG.getBytes();\n-        DD = ZipLong.DD_SIG.getBytes();\n-        APK_SIGNING_BLOCK_MAGIC = new byte[] { 65, 80, 75, 32, 83, 105, 103, 32, 66, 108, 111, 99, 107, 32, 52, 50 };\n-        LONG_MAX = BigInteger.valueOf(Long.MAX_VALUE);\n-    }\n }\n"}]}
