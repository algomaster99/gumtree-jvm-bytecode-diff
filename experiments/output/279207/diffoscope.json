{"diffoscope-json-version": 1, "source1": "first/SevenZFile.class", "source2": "second/SevenZFile.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,11 +1,11 @@\n \n package org.apache.commons.compress.archivers.sevenz;\n \n-import java.util.List;\n+import java.util.function.ToLongFunction;\n import java.io.DataInputStream;\n import java.nio.charset.StandardCharsets;\n import java.util.function.Predicate;\n import java.util.Objects;\n import java.util.LinkedHashMap;\n import java.util.BitSet;\n import java.nio.ByteOrder;\n@@ -54,290 +54,287 @@\n     private InputStream currentFolderInputStream;\n     private byte[] password;\n     private final SevenZFileOptions options;\n     private long compressedBytesReadFromCurrentEntry;\n     private long uncompressedBytesReadFromCurrentEntry;\n     private final ArrayList<InputStream> deferredBlockStreams;\n     \n-    private static int assertFitsIntoNonNegativeInt(final String what, final long value) throws IOException {\n-        if (value > 2147483647L || value < 0L) {\n-            throw new IOException(String.format(\"Cannot handle % %,d\", what, Long.valueOf(value)));\n+    private static int assertFitsIntoNonNegativeInt(final String s, final long l) throws IOException {\n+        if (l > 2147483647L || l < 0L) {\n+            throw new IOException(String.format(\"Cannot handle % %,d\", s, Long.valueOf(l)));\n         }\n-        return (int)value;\n+        return (int)l;\n     }\n     \n-    private static ByteBuffer checkEndOfFile(final ByteBuffer buf, final int expectRemaining) throws EOFException {\n-        final int remaining = buf.remaining();\n-        if (remaining < expectRemaining) {\n-            throw new EOFException(String.format(\"remaining %,d < expectRemaining %,d\", Integer.valueOf(remaining), Integer.valueOf(expectRemaining)));\n+    private static ByteBuffer checkEndOfFile(final ByteBuffer byteBuffer, final int i) throws EOFException {\n+        final int remaining = byteBuffer.remaining();\n+        if (remaining < i) {\n+            throw new EOFException(String.format(\"remaining %,d < expectRemaining %,d\", Integer.valueOf(remaining), Integer.valueOf(i)));\n         }\n-        return buf;\n+        return byteBuffer;\n     }\n     \n-    private static void get(final ByteBuffer buf, final byte[] to) throws EOFException {\n-        checkEndOfFile(buf, to.length).get(to);\n+    private static void get(final ByteBuffer byteBuffer, final byte[] dst) throws EOFException {\n+        checkEndOfFile(byteBuffer, dst.length).get(dst);\n     }\n     \n-    private static char getChar(final ByteBuffer buf) throws EOFException {\n-        return checkEndOfFile(buf, 2).getChar();\n+    private static char getChar(final ByteBuffer byteBuffer) throws EOFException {\n+        return checkEndOfFile(byteBuffer, 2).getChar();\n     }\n     \n-    private static int getInt(final ByteBuffer buf) throws EOFException {\n-        return checkEndOfFile(buf, 4).getInt();\n+    private static int getInt(final ByteBuffer byteBuffer) throws EOFException {\n+        return checkEndOfFile(byteBuffer, 4).getInt();\n     }\n     \n-    private static long getLong(final ByteBuffer buf) throws EOFException {\n-        return checkEndOfFile(buf, 8).getLong();\n+    private static long getLong(final ByteBuffer byteBuffer) throws EOFException {\n+        return checkEndOfFile(byteBuffer, 8).getLong();\n     }\n     \n-    private static int getUnsignedByte(final ByteBuffer buf) throws EOFException {\n-        if (!buf.hasRemaining()) {\n+    private static int getUnsignedByte(final ByteBuffer byteBuffer) throws EOFException {\n+        if (!byteBuffer.hasRemaining()) {\n             throw new EOFException();\n         }\n-        return buf.get() & 0xFF;\n+        return byteBuffer.get() & 0xFF;\n     }\n     \n-    public static boolean matches(final byte[] signature, final int length) {\n-        if (length < SevenZFile.sevenZSignature.length) {\n+    public static boolean matches(final byte[] array, final int n) {\n+        if (n < SevenZFile.sevenZSignature.length) {\n             return false;\n         }\n         for (int i = 0; i < SevenZFile.sevenZSignature.length; ++i) {\n-            if (signature[i] != SevenZFile.sevenZSignature[i]) {\n+            if (array[i] != SevenZFile.sevenZSignature[i]) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    private static long readUint64(final ByteBuffer in) throws IOException {\n-        final long firstByte = (long)getUnsignedByte(in);\n-        int mask = 128;\n-        long value = 0L;\n+    private static long readUint64(final ByteBuffer byteBuffer) throws IOException {\n+        final long n = (long)getUnsignedByte(byteBuffer);\n+        int n2 = 128;\n+        long n3 = 0L;\n         for (int i = 0; i < 8; ++i) {\n-            if ((firstByte & (long)mask) == 0x0L) {\n-                return value | (firstByte & (long)(mask - 1)) << 8 * i;\n+            if ((n & (long)n2) == 0x0L) {\n+                return n3 | (n & (long)(n2 - 1)) << 8 * i;\n             }\n-            final long nextByte = (long)getUnsignedByte(in);\n-            value |= nextByte << 8 * i;\n-            mask >>>= 1;\n+            n3 |= (long)getUnsignedByte(byteBuffer) << 8 * i;\n+            n2 >>>= 1;\n         }\n-        return value;\n+        return n3;\n     }\n     \n-    private static long skipBytesFully(final ByteBuffer input, long bytesToSkip) {\n-        if (bytesToSkip < 1L) {\n+    private static long skipBytesFully(final ByteBuffer byteBuffer, long n) {\n+        if (n < 1L) {\n             return 0L;\n         }\n-        final int current = input.position();\n-        final int maxSkip = input.remaining();\n-        if (maxSkip < bytesToSkip) {\n-            bytesToSkip = maxSkip;\n+        final int position = byteBuffer.position();\n+        final int remaining = byteBuffer.remaining();\n+        if (remaining < n) {\n+            n = remaining;\n         }\n-        input.position();\n-        return bytesToSkip;\n+        byteBuffer.position();\n+        return n;\n     }\n     \n-    public SevenZFile(final File fileName) throws IOException {\n-        this(fileName, SevenZFileOptions.DEFAULT);\n+    public SevenZFile(final File file) throws IOException {\n+        this(file, SevenZFileOptions.DEFAULT);\n     }\n     \n     @Deprecated\n-    public SevenZFile(final File fileName, final byte[] password) throws IOException {\n-        this(Files.newByteChannel(fileName.toPath(), (Set<? extends OpenOption>)EnumSet.of(StandardOpenOption.READ), (FileAttribute<?>[])new FileAttribute[0]), fileName.getAbsolutePath(), password, true, SevenZFileOptions.DEFAULT);\n+    public SevenZFile(final File file, final byte[] array) throws IOException {\n+        this(Files.newByteChannel(file.toPath(), (Set<? extends OpenOption>)EnumSet.of(StandardOpenOption.READ), (FileAttribute<?>[])new FileAttribute[0]), file.getAbsolutePath(), array, true, SevenZFileOptions.DEFAULT);\n     }\n     \n-    public SevenZFile(final File fileName, final char[] password) throws IOException {\n-        this(fileName, password, SevenZFileOptions.DEFAULT);\n+    public SevenZFile(final File file, final char[] array) throws IOException {\n+        this(file, array, SevenZFileOptions.DEFAULT);\n     }\n     \n-    public SevenZFile(final File fileName, final char[] password, final SevenZFileOptions options) throws IOException {\n-        this(Files.newByteChannel(fileName.toPath(), (Set<? extends OpenOption>)EnumSet.of(StandardOpenOption.READ), (FileAttribute<?>[])new FileAttribute[0]), fileName.getAbsolutePath(), AES256SHA256Decoder.utf16Decode(password), true, options);\n+    public SevenZFile(final File file, final char[] array, final SevenZFileOptions sevenZFileOptions) throws IOException {\n+        this(Files.newByteChannel(file.toPath(), (Set<? extends OpenOption>)EnumSet.of(StandardOpenOption.READ), (FileAttribute<?>[])new FileAttribute[0]), file.getAbsolutePath(), AES256SHA256Decoder.utf16Decode(array), true, sevenZFileOptions);\n     }\n     \n-    public SevenZFile(final File fileName, final SevenZFileOptions options) throws IOException {\n-        this(fileName, null, options);\n+    public SevenZFile(final File file, final SevenZFileOptions sevenZFileOptions) throws IOException {\n+        this(file, null, sevenZFileOptions);\n     }\n     \n-    public SevenZFile(final SeekableByteChannel channel) throws IOException {\n-        this(channel, SevenZFileOptions.DEFAULT);\n+    public SevenZFile(final SeekableByteChannel seekableByteChannel) throws IOException {\n+        this(seekableByteChannel, SevenZFileOptions.DEFAULT);\n     }\n     \n     @Deprecated\n-    public SevenZFile(final SeekableByteChannel channel, final byte[] password) throws IOException {\n-        this(channel, \"unknown archive\", password);\n+    public SevenZFile(final SeekableByteChannel seekableByteChannel, final byte[] array) throws IOException {\n+        this(seekableByteChannel, \"unknown archive\", array);\n     }\n     \n-    public SevenZFile(final SeekableByteChannel channel, final char[] password) throws IOException {\n-        this(channel, password, SevenZFileOptions.DEFAULT);\n+    public SevenZFile(final SeekableByteChannel seekableByteChannel, final char[] array) throws IOException {\n+        this(seekableByteChannel, array, SevenZFileOptions.DEFAULT);\n     }\n     \n-    public SevenZFile(final SeekableByteChannel channel, final char[] password, final SevenZFileOptions options) throws IOException {\n-        this(channel, \"unknown archive\", password, options);\n+    public SevenZFile(final SeekableByteChannel seekableByteChannel, final char[] array, final SevenZFileOptions sevenZFileOptions) throws IOException {\n+        this(seekableByteChannel, \"unknown archive\", array, sevenZFileOptions);\n     }\n     \n-    public SevenZFile(final SeekableByteChannel channel, final SevenZFileOptions options) throws IOException {\n-        this(channel, \"unknown archive\", null, options);\n+    public SevenZFile(final SeekableByteChannel seekableByteChannel, final SevenZFileOptions sevenZFileOptions) throws IOException {\n+        this(seekableByteChannel, \"unknown archive\", null, sevenZFileOptions);\n     }\n     \n-    public SevenZFile(final SeekableByteChannel channel, final String fileName) throws IOException {\n-        this(channel, fileName, SevenZFileOptions.DEFAULT);\n+    public SevenZFile(final SeekableByteChannel seekableByteChannel, final String s) throws IOException {\n+        this(seekableByteChannel, s, SevenZFileOptions.DEFAULT);\n     }\n     \n     @Deprecated\n-    public SevenZFile(final SeekableByteChannel channel, final String fileName, final byte[] password) throws IOException {\n-        this(channel, fileName, password, false, SevenZFileOptions.DEFAULT);\n+    public SevenZFile(final SeekableByteChannel seekableByteChannel, final String s, final byte[] array) throws IOException {\n+        this(seekableByteChannel, s, array, false, SevenZFileOptions.DEFAULT);\n     }\n     \n-    private SevenZFile(final SeekableByteChannel channel, final String filename, final byte[] password, final boolean closeOnError, final SevenZFileOptions options) throws IOException {\n+    private SevenZFile(final SeekableByteChannel channel, final String fileName, final byte[] original, final boolean b, final SevenZFileOptions options) throws IOException {\n         this.currentEntryIndex = -1;\n         this.currentFolderIndex = -1;\n         this.deferredBlockStreams = new ArrayList<InputStream>();\n-        boolean succeeded = false;\n+        boolean b2 = false;\n         this.channel = channel;\n-        this.fileName = filename;\n+        this.fileName = fileName;\n         this.options = options;\n         try {\n-            this.archive = this.readHeaders(password);\n-            if (password != null) {\n-                this.password = Arrays.copyOf(password, password.length);\n+            this.archive = this.readHeaders(original);\n+            if (original != null) {\n+                this.password = Arrays.copyOf(original, original.length);\n             }\n             else {\n                 this.password = null;\n             }\n-            succeeded = true;\n+            b2 = true;\n         }\n         finally {\n-            if (!succeeded && closeOnError) {\n+            if (!b2 && b) {\n                 this.channel.close();\n             }\n         }\n     }\n     \n-    public SevenZFile(final SeekableByteChannel channel, final String fileName, final char[] password) throws IOException {\n-        this(channel, fileName, password, SevenZFileOptions.DEFAULT);\n+    public SevenZFile(final SeekableByteChannel seekableByteChannel, final String s, final char[] array) throws IOException {\n+        this(seekableByteChannel, s, array, SevenZFileOptions.DEFAULT);\n     }\n     \n-    public SevenZFile(final SeekableByteChannel channel, final String fileName, final char[] password, final SevenZFileOptions options) throws IOException {\n-        this(channel, fileName, AES256SHA256Decoder.utf16Decode(password), false, options);\n+    public SevenZFile(final SeekableByteChannel seekableByteChannel, final String s, final char[] array, final SevenZFileOptions sevenZFileOptions) throws IOException {\n+        this(seekableByteChannel, s, AES256SHA256Decoder.utf16Decode(array), false, sevenZFileOptions);\n     }\n     \n-    public SevenZFile(final SeekableByteChannel channel, final String fileName, final SevenZFileOptions options) throws IOException {\n-        this(channel, fileName, null, false, options);\n+    public SevenZFile(final SeekableByteChannel seekableByteChannel, final String s, final SevenZFileOptions sevenZFileOptions) throws IOException {\n+        this(seekableByteChannel, s, null, false, sevenZFileOptions);\n     }\n     \n-    private InputStream buildDecoderStack(final Folder folder, final long folderOffset, final int firstPackStreamIndex, final SevenZArchiveEntry entry) throws IOException {\n-        this.channel.position(folderOffset);\n-        InputStream inputStreamStack = (InputStream)new SevenZFile.SevenZFile$1(this, (InputStream)new BufferedInputStream((InputStream)new BoundedSeekableByteChannelInputStream(this.channel, this.archive.packSizes[firstPackStreamIndex])));\n-        final LinkedList<SevenZMethodConfiguration> methods = new LinkedList<SevenZMethodConfiguration>();\n+    private InputStream buildDecoderStack(final Folder folder, final long n, final int n2, final SevenZArchiveEntry sevenZArchiveEntry) throws IOException {\n+        this.channel.position(n);\n+        Object addDecoder = new SevenZFile.SevenZFile$1(this, (InputStream)new BufferedInputStream((InputStream)new BoundedSeekableByteChannelInputStream(this.channel, this.archive.packSizes[n2])));\n+        final LinkedList contentMethods = new LinkedList();\n         for (final Coder coder : folder.getOrderedCoders()) {\n             if (coder.numInStreams != 1L || coder.numOutStreams != 1L) {\n                 throw new IOException(\"Multi input/output stream coders are not yet supported\");\n             }\n-            final SevenZMethod method = SevenZMethod.byId(coder.decompressionMethodId);\n-            inputStreamStack = Coders.addDecoder(this.fileName, inputStreamStack, folder.getUnpackSizeForCoder(coder), coder, this.password, this.options.getMaxMemoryLimitInKb());\n-            methods.addFirst(new SevenZMethodConfiguration(method, Coders.findByMethod(method).getOptionsFromCoder(coder, inputStreamStack)));\n+            final SevenZMethod byId = SevenZMethod.byId(coder.decompressionMethodId);\n+            addDecoder = Coders.addDecoder(this.fileName, (InputStream)addDecoder, folder.getUnpackSizeForCoder(coder), coder, this.password, this.options.getMaxMemoryLimitInKb());\n+            contentMethods.addFirst(new SevenZMethodConfiguration(byId, Coders.findByMethod(byId).getOptionsFromCoder(coder, (InputStream)addDecoder)));\n         }\n-        entry.setContentMethods((Iterable)methods);\n+        sevenZArchiveEntry.setContentMethods((Iterable)contentMethods);\n         if (folder.hasCrc) {\n-            return (InputStream)new CRC32VerifyingInputStream(inputStreamStack, folder.getUnpackSize(), folder.crc);\n+            return (InputStream)new CRC32VerifyingInputStream((InputStream)addDecoder, folder.getUnpackSize(), folder.crc);\n         }\n-        return inputStreamStack;\n+        return (InputStream)addDecoder;\n     }\n     \n-    private void buildDecodingStream(final int entryIndex, final boolean isRandomAccess) throws IOException {\n+    private void buildDecodingStream(final int n, final boolean b) throws IOException {\n         if (this.archive.streamMap == null) {\n             throw new IOException(\"Archive doesn't contain stream information to read entries\");\n         }\n-        final int folderIndex = this.archive.streamMap.fileFolderIndex[entryIndex];\n-        if (folderIndex < 0) {\n+        final int currentFolderIndex = this.archive.streamMap.fileFolderIndex[n];\n+        if (currentFolderIndex < 0) {\n             this.deferredBlockStreams.clear();\n             return;\n         }\n-        final SevenZArchiveEntry file = this.archive.files[entryIndex];\n-        boolean isInSameFolder = false;\n-        if (this.currentFolderIndex == folderIndex) {\n-            if (entryIndex > 0) {\n-                file.setContentMethods(this.archive.files[entryIndex - 1].getContentMethods());\n-            }\n-            if (isRandomAccess && file.getContentMethods() == null) {\n-                final int folderFirstFileIndex = this.archive.streamMap.folderFirstFileIndex[folderIndex];\n-                final SevenZArchiveEntry folderFirstFile = this.archive.files[folderFirstFileIndex];\n-                file.setContentMethods(folderFirstFile.getContentMethods());\n+        final SevenZArchiveEntry sevenZArchiveEntry = this.archive.files[n];\n+        boolean b2 = false;\n+        if (this.currentFolderIndex == currentFolderIndex) {\n+            if (n > 0) {\n+                sevenZArchiveEntry.setContentMethods(this.archive.files[n - 1].getContentMethods());\n             }\n-            isInSameFolder = true;\n+            if (b && sevenZArchiveEntry.getContentMethods() == null) {\n+                sevenZArchiveEntry.setContentMethods(this.archive.files[this.archive.streamMap.folderFirstFileIndex[currentFolderIndex]].getContentMethods());\n+            }\n+            b2 = true;\n         }\n         else {\n-            this.reopenFolderInputStream(this.currentFolderIndex = folderIndex, file);\n+            this.reopenFolderInputStream(this.currentFolderIndex = currentFolderIndex, sevenZArchiveEntry);\n         }\n-        boolean haveSkippedEntries = false;\n-        if (isRandomAccess) {\n-            haveSkippedEntries = this.skipEntriesWhenNeeded(entryIndex, isInSameFolder, folderIndex);\n+        boolean skipEntriesWhenNeeded = false;\n+        if (b) {\n+            skipEntriesWhenNeeded = this.skipEntriesWhenNeeded(n, b2, currentFolderIndex);\n         }\n-        if (isRandomAccess && this.currentEntryIndex == entryIndex && !haveSkippedEntries) {\n+        if (b && this.currentEntryIndex == n && !skipEntriesWhenNeeded) {\n             return;\n         }\n-        InputStream fileStream = (InputStream)new BoundedInputStream(this.currentFolderInputStream, file.getSize());\n-        if (file.getHasCrc()) {\n-            fileStream = (InputStream)new CRC32VerifyingInputStream(fileStream, file.getSize(), file.getCrcValue());\n+        Object e = new BoundedInputStream(this.currentFolderInputStream, sevenZArchiveEntry.getSize());\n+        if (sevenZArchiveEntry.getHasCrc()) {\n+            e = new CRC32VerifyingInputStream((InputStream)e, sevenZArchiveEntry.getSize(), sevenZArchiveEntry.getCrcValue());\n         }\n-        this.deferredBlockStreams.add(fileStream);\n+        this.deferredBlockStreams.add((InputStream)e);\n     }\n     \n     private void calculateStreamMap(final Archive archive) throws IOException {\n         final StreamMap streamMap = new StreamMap();\n-        int nextFolderPackStreamIndex = 0;\n-        final int numFolders = (archive.folders != null) ? archive.folders.length : 0;\n-        streamMap.folderFirstPackStreamIndex = new int[numFolders];\n-        for (int i = 0; i < numFolders; ++i) {\n-            streamMap.folderFirstPackStreamIndex[i] = nextFolderPackStreamIndex;\n-            nextFolderPackStreamIndex += archive.folders[i].packedStreams.length;\n-        }\n-        long nextPackStreamOffset = 0L;\n-        final int numPackSizes = archive.packSizes.length;\n-        streamMap.packStreamOffsets = new long[numPackSizes];\n-        for (int j = 0; j < numPackSizes; ++j) {\n-            streamMap.packStreamOffsets[j] = nextPackStreamOffset;\n-            nextPackStreamOffset += archive.packSizes[j];\n+        int n = 0;\n+        final int n2 = (archive.folders != null) ? archive.folders.length : 0;\n+        streamMap.folderFirstPackStreamIndex = new int[n2];\n+        for (int i = 0; i < n2; ++i) {\n+            streamMap.folderFirstPackStreamIndex[i] = n;\n+            n += archive.folders[i].packedStreams.length;\n+        }\n+        long n3 = 0L;\n+        final int length = archive.packSizes.length;\n+        streamMap.packStreamOffsets = new long[length];\n+        for (int j = 0; j < length; ++j) {\n+            streamMap.packStreamOffsets[j] = n3;\n+            n3 += archive.packSizes[j];\n         }\n-        streamMap.folderFirstFileIndex = new int[numFolders];\n+        streamMap.folderFirstFileIndex = new int[n2];\n         streamMap.fileFolderIndex = new int[archive.files.length];\n-        int nextFolderIndex = 0;\n-        int nextFolderUnpackStreamIndex = 0;\n-        for (int k = 0; k < archive.files.length; ++k) {\n-            if (!archive.files[k].hasStream() && nextFolderUnpackStreamIndex == 0) {\n-                streamMap.fileFolderIndex[k] = -1;\n+        int k = 0;\n+        int n4 = 0;\n+        for (int l = 0; l < archive.files.length; ++l) {\n+            if (!archive.files[l].hasStream() && n4 == 0) {\n+                streamMap.fileFolderIndex[l] = -1;\n             }\n             else {\n-                if (nextFolderUnpackStreamIndex == 0) {\n-                    while (nextFolderIndex < archive.folders.length) {\n-                        streamMap.folderFirstFileIndex[nextFolderIndex] = k;\n-                        if (archive.folders[nextFolderIndex].numUnpackSubStreams > 0) {\n+                if (n4 == 0) {\n+                    while (k < archive.folders.length) {\n+                        streamMap.folderFirstFileIndex[k] = l;\n+                        if (archive.folders[k].numUnpackSubStreams > 0) {\n                             break;\n                         }\n-                        ++nextFolderIndex;\n+                        ++k;\n                     }\n-                    if (nextFolderIndex >= archive.folders.length) {\n+                    if (k >= archive.folders.length) {\n                         throw new IOException(\"Too few folders in archive\");\n                     }\n                 }\n-                streamMap.fileFolderIndex[k] = nextFolderIndex;\n-                if (archive.files[k].hasStream()) {\n-                    if (++nextFolderUnpackStreamIndex >= archive.folders[nextFolderIndex].numUnpackSubStreams) {\n-                        ++nextFolderIndex;\n-                        nextFolderUnpackStreamIndex = 0;\n+                streamMap.fileFolderIndex[l] = k;\n+                if (archive.files[l].hasStream()) {\n+                    if (++n4 >= archive.folders[k].numUnpackSubStreams) {\n+                        ++k;\n+                        n4 = 0;\n                     }\n                 }\n             }\n         }\n         archive.streamMap = streamMap;\n     }\n     \n-    private void checkEntryIsInitialized(final Map<Integer, SevenZArchiveEntry> archiveEntries, final int index) {\n-        if (archiveEntries.get(Integer.valueOf(index)) == null) {\n-            archiveEntries.put(Integer.valueOf(index), new SevenZArchiveEntry());\n+    private void checkEntryIsInitialized(final Map<Integer, SevenZArchiveEntry> map, final int n) {\n+        if (map.get(Integer.valueOf(n)) == null) {\n+            map.put(Integer.valueOf(n), new SevenZArchiveEntry());\n         }\n     }\n     \n     @Override\n     public void close() throws IOException {\n         if (this.channel != null) {\n             try {\n@@ -357,1102 +354,1075 @@\n         if (this.archive.files[this.currentEntryIndex].getSize() == 0L) {\n             return new ByteArrayInputStream(ByteUtils.EMPTY_BYTE_ARRAY);\n         }\n         if (this.deferredBlockStreams.isEmpty()) {\n             throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n         }\n         while (this.deferredBlockStreams.size() > 1) {\n-            try (final InputStream stream = (InputStream)this.deferredBlockStreams.remove(0)) {\n-                IOUtils.skip(stream, Long.MAX_VALUE);\n+            try (final InputStream inputStream = (InputStream)this.deferredBlockStreams.remove(0)) {\n+                IOUtils.skip(inputStream, Long.MAX_VALUE);\n             }\n             this.compressedBytesReadFromCurrentEntry = 0L;\n         }\n         return this.deferredBlockStreams.get(0);\n     }\n     \n     public String getDefaultName() {\n         if (\"unknown archive\".equals(this.fileName) || this.fileName == null) {\n             return null;\n         }\n-        final String lastSegment = new File(this.fileName).getName();\n-        final int dotPos = lastSegment.lastIndexOf(\".\");\n-        if (dotPos > 0) {\n-            return lastSegment.substring(0, dotPos);\n+        final String name = new File(this.fileName).getName();\n+        final int lastIndex = name.lastIndexOf(\".\");\n+        if (lastIndex > 0) {\n+            return name.substring(0, lastIndex);\n         }\n-        return lastSegment + \"~\";\n+        return name + \"~\";\n     }\n     \n     public Iterable<SevenZArchiveEntry> getEntries() {\n         return new ArrayList<SevenZArchiveEntry>(Arrays.asList(this.archive.files));\n     }\n     \n-    public InputStream getInputStream(final SevenZArchiveEntry entry) throws IOException {\n-        int entryIndex = -1;\n+    public InputStream getInputStream(final SevenZArchiveEntry sevenZArchiveEntry) throws IOException {\n+        int currentEntryIndex = -1;\n         for (int i = 0; i < this.archive.files.length; ++i) {\n-            if (entry == this.archive.files[i]) {\n-                entryIndex = i;\n+            if (sevenZArchiveEntry == this.archive.files[i]) {\n+                currentEntryIndex = i;\n                 break;\n             }\n         }\n-        if (entryIndex < 0) {\n-            throw new IllegalArgumentException(\"Can not find \" + entry.getName() + \" in \" + this.fileName);\n+        if (currentEntryIndex < 0) {\n+            throw new IllegalArgumentException(\"Can not find \" + sevenZArchiveEntry.getName() + \" in \" + this.fileName);\n         }\n-        this.buildDecodingStream(entryIndex, true);\n-        this.currentEntryIndex = entryIndex;\n-        this.currentFolderIndex = this.archive.streamMap.fileFolderIndex[entryIndex];\n+        this.buildDecodingStream(currentEntryIndex, true);\n+        this.currentEntryIndex = currentEntryIndex;\n+        this.currentFolderIndex = this.archive.streamMap.fileFolderIndex[currentEntryIndex];\n         return this.getCurrentStream();\n     }\n     \n     public SevenZArchiveEntry getNextEntry() throws IOException {\n         if (this.currentEntryIndex >= this.archive.files.length - 1) {\n             return null;\n         }\n         ++this.currentEntryIndex;\n-        final SevenZArchiveEntry entry = this.archive.files[this.currentEntryIndex];\n-        if (entry.getName() == null && this.options.getUseDefaultNameForUnnamedEntries()) {\n-            entry.setName(this.getDefaultName());\n+        final SevenZArchiveEntry sevenZArchiveEntry = this.archive.files[this.currentEntryIndex];\n+        if (sevenZArchiveEntry.getName() == null && this.options.getUseDefaultNameForUnnamedEntries()) {\n+            sevenZArchiveEntry.setName(this.getDefaultName());\n         }\n         this.buildDecodingStream(this.currentEntryIndex, false);\n         final long n = 0L;\n         this.compressedBytesReadFromCurrentEntry = n;\n         this.uncompressedBytesReadFromCurrentEntry = n;\n-        return entry;\n+        return sevenZArchiveEntry;\n     }\n     \n     public InputStreamStatistics getStatisticsForCurrentEntry() {\n         return (InputStreamStatistics)new SevenZFile.SevenZFile$2(this);\n     }\n     \n     private boolean hasCurrentEntryBeenRead() {\n-        boolean hasCurrentEntryBeenRead = false;\n+        boolean b = false;\n         if (!this.deferredBlockStreams.isEmpty()) {\n-            final InputStream currentEntryInputStream = (InputStream)this.deferredBlockStreams.get(this.deferredBlockStreams.size() - 1);\n-            if (currentEntryInputStream instanceof CRC32VerifyingInputStream) {\n-                hasCurrentEntryBeenRead = (((CRC32VerifyingInputStream)currentEntryInputStream).getBytesRemaining() != this.archive.files[this.currentEntryIndex].getSize());\n+            final InputStream inputStream = (InputStream)this.deferredBlockStreams.get(this.deferredBlockStreams.size() - 1);\n+            if (inputStream instanceof CRC32VerifyingInputStream) {\n+                b = (((CRC32VerifyingInputStream)inputStream).getBytesRemaining() != this.archive.files[this.currentEntryIndex].getSize());\n             }\n-            if (currentEntryInputStream instanceof BoundedInputStream) {\n-                hasCurrentEntryBeenRead = (((BoundedInputStream)currentEntryInputStream).getBytesRemaining() != this.archive.files[this.currentEntryIndex].getSize());\n+            if (inputStream instanceof BoundedInputStream) {\n+                b = (((BoundedInputStream)inputStream).getBytesRemaining() != this.archive.files[this.currentEntryIndex].getSize());\n             }\n         }\n-        return hasCurrentEntryBeenRead;\n+        return b;\n     }\n     \n-    private Archive initializeArchive(final StartHeader startHeader, final byte[] password, final boolean verifyCrc) throws IOException {\n+    private Archive initializeArchive(final StartHeader startHeader, final byte[] array, final boolean b) throws IOException {\n         assertFitsIntoNonNegativeInt(\"nextHeaderSize\", startHeader.nextHeaderSize);\n-        final int nextHeaderSizeInt = (int)startHeader.nextHeaderSize;\n+        final int capacity = (int)startHeader.nextHeaderSize;\n         this.channel.position(32L + startHeader.nextHeaderOffset);\n-        if (verifyCrc) {\n+        if (b) {\n             final long position = this.channel.position();\n-            final CheckedInputStream cis = new CheckedInputStream(Channels.newInputStream(this.channel), new CRC32());\n-            if (cis.skip(nextHeaderSizeInt) != nextHeaderSizeInt) {\n+            final CheckedInputStream checkedInputStream = new CheckedInputStream(Channels.newInputStream(this.channel), new CRC32());\n+            if (checkedInputStream.skip(capacity) != capacity) {\n                 throw new IOException(\"Problem computing NextHeader CRC-32\");\n             }\n-            if (startHeader.nextHeaderCrc != cis.getChecksum().getValue()) {\n+            if (startHeader.nextHeaderCrc != checkedInputStream.getChecksum().getValue()) {\n                 throw new IOException(\"NextHeader CRC-32 mismatch\");\n             }\n             this.channel.position(position);\n         }\n         Archive archive = new Archive();\n-        ByteBuffer buf = ByteBuffer.allocate(nextHeaderSizeInt).order(ByteOrder.LITTLE_ENDIAN);\n-        this.readFully(buf);\n-        int nid = getUnsignedByte(buf);\n-        if (nid == 23) {\n-            buf = this.readEncodedHeader(buf, archive, password);\n+        ByteBuffer byteBuffer = ByteBuffer.allocate(capacity).order(ByteOrder.LITTLE_ENDIAN);\n+        this.readFully(byteBuffer);\n+        int n = getUnsignedByte(byteBuffer);\n+        if (n == 23) {\n+            byteBuffer = this.readEncodedHeader(byteBuffer, archive, array);\n             archive = new Archive();\n-            nid = getUnsignedByte(buf);\n+            n = getUnsignedByte(byteBuffer);\n         }\n-        if (nid != 1) {\n+        if (n != 1) {\n             throw new IOException(\"Broken or unsupported archive: no Header\");\n         }\n-        this.readHeader(buf, archive);\n+        this.readHeader(byteBuffer, archive);\n         archive.subStreamsInfo = null;\n         return archive;\n     }\n     \n     public int read() throws IOException {\n-        final int b = this.getCurrentStream().read();\n-        if (b >= 0) {\n+        final int read = this.getCurrentStream().read();\n+        if (read >= 0) {\n             ++this.uncompressedBytesReadFromCurrentEntry;\n         }\n-        return b;\n+        return read;\n     }\n     \n-    public int read(final byte[] b) throws IOException {\n-        return this.read(b, 0, b.length);\n+    public int read(final byte[] array) throws IOException {\n+        return this.read(array, 0, array.length);\n     }\n     \n     public int read(final byte[] b, final int off, final int len) throws IOException {\n         if (len == 0) {\n             return 0;\n         }\n-        final int cnt = this.getCurrentStream().read(b, off, len);\n-        if (cnt > 0) {\n-            this.uncompressedBytesReadFromCurrentEntry += cnt;\n+        final int read = this.getCurrentStream().read(b, off, len);\n+        if (read > 0) {\n+            this.uncompressedBytesReadFromCurrentEntry += read;\n         }\n-        return cnt;\n+        return read;\n     }\n     \n-    private BitSet readAllOrBits(final ByteBuffer header, final int size) throws IOException {\n-        final int areAllDefined = getUnsignedByte(header);\n+    private BitSet readAllOrBits(final ByteBuffer byteBuffer, final int nbits) throws IOException {\n         BitSet bits;\n-        if (areAllDefined != 0) {\n-            bits = new BitSet(size);\n-            for (int i = 0; i < size; ++i) {\n+        if (getUnsignedByte(byteBuffer) != 0) {\n+            bits = new BitSet(nbits);\n+            for (int i = 0; i < nbits; ++i) {\n                 bits.set(i, true);\n             }\n         }\n         else {\n-            bits = this.readBits(header, size);\n+            bits = this.readBits(byteBuffer, nbits);\n         }\n         return bits;\n     }\n     \n-    private void readArchiveProperties(final ByteBuffer input) throws IOException {\n-        for (int nid = getUnsignedByte(input); nid != 0; nid = getUnsignedByte(input)) {\n-            final long propertySize = readUint64(input);\n-            final byte[] property = new byte[(int)propertySize];\n-            get(input, property);\n-        }\n-    }\n-    \n-    private BitSet readBits(final ByteBuffer header, final int size) throws IOException {\n-        final BitSet bits = new BitSet(size);\n-        int mask = 0;\n-        int cache = 0;\n-        for (int i = 0; i < size; ++i) {\n-            if (mask == 0) {\n-                mask = 128;\n-                cache = getUnsignedByte(header);\n-            }\n-            bits.set(i, (cache & mask) != 0x0);\n-            mask >>>= 1;\n+    private void readArchiveProperties(final ByteBuffer byteBuffer) throws IOException {\n+        for (int i = getUnsignedByte(byteBuffer); i != 0; i = getUnsignedByte(byteBuffer)) {\n+            get(byteBuffer, new byte[(int)readUint64(byteBuffer)]);\n         }\n-        return bits;\n     }\n     \n-    private ByteBuffer readEncodedHeader(final ByteBuffer header, final Archive archive, final byte[] password) throws IOException {\n-        final int pos = header.position();\n-        final SevenZFile.ArchiveStatistics stats = new SevenZFile.ArchiveStatistics((SevenZFile.SevenZFile$1)null);\n-        this.sanityCheckStreamsInfo(header, stats);\n-        stats.assertValidity(this.options.getMaxMemoryLimitInKb());\n-        header.position();\n-        this.readStreamsInfo(header, archive);\n+    private BitSet readBits(final ByteBuffer byteBuffer, final int nbits) throws IOException {\n+        final BitSet set = new BitSet(nbits);\n+        int n = 0;\n+        int unsignedByte = 0;\n+        for (int i = 0; i < nbits; ++i) {\n+            if (n == 0) {\n+                n = 128;\n+                unsignedByte = getUnsignedByte(byteBuffer);\n+            }\n+            set.set(i, (unsignedByte & n) != 0x0);\n+            n >>>= 1;\n+        }\n+        return set;\n+    }\n+    \n+    private ByteBuffer readEncodedHeader(final ByteBuffer byteBuffer, final Archive archive, final byte[] array) throws IOException {\n+        final int position = byteBuffer.position();\n+        final SevenZFile.ArchiveStatistics archiveStatistics = new SevenZFile.ArchiveStatistics((SevenZFile.SevenZFile$1)null);\n+        this.sanityCheckStreamsInfo(byteBuffer, archiveStatistics);\n+        archiveStatistics.assertValidity(this.options.getMaxMemoryLimitInKb());\n+        byteBuffer.position();\n+        this.readStreamsInfo(byteBuffer, archive);\n         if (archive.folders == null || archive.folders.length == 0) {\n             throw new IOException(\"no folders, can't read encoded header\");\n         }\n         if (archive.packSizes == null || archive.packSizes.length == 0) {\n             throw new IOException(\"no packed streams, can't read encoded header\");\n         }\n         final Folder folder = archive.folders[0];\n-        final int firstPackStreamIndex = 0;\n-        final long folderOffset = 32L + archive.packPos + 0L;\n-        this.channel.position(folderOffset);\n-        InputStream inputStreamStack = (InputStream)new BoundedSeekableByteChannelInputStream(this.channel, archive.packSizes[0]);\n+        this.channel.position(32L + archive.packPos + 0L);\n+        Object addDecoder = new BoundedSeekableByteChannelInputStream(this.channel, archive.packSizes[0]);\n         for (final Coder coder : folder.getOrderedCoders()) {\n             if (coder.numInStreams != 1L || coder.numOutStreams != 1L) {\n                 throw new IOException(\"Multi input/output stream coders are not yet supported\");\n             }\n-            inputStreamStack = Coders.addDecoder(this.fileName, inputStreamStack, folder.getUnpackSizeForCoder(coder), coder, password, this.options.getMaxMemoryLimitInKb());\n+            addDecoder = Coders.addDecoder(this.fileName, (InputStream)addDecoder, folder.getUnpackSizeForCoder(coder), coder, array, this.options.getMaxMemoryLimitInKb());\n         }\n         if (folder.hasCrc) {\n-            inputStreamStack = (InputStream)new CRC32VerifyingInputStream(inputStreamStack, folder.getUnpackSize(), folder.crc);\n+            addDecoder = new CRC32VerifyingInputStream((InputStream)addDecoder, folder.getUnpackSize(), folder.crc);\n         }\n-        final int unpackSize = assertFitsIntoNonNegativeInt(\"unpackSize\", folder.getUnpackSize());\n-        final byte[] nextHeader = IOUtils.readRange(inputStreamStack, unpackSize);\n-        if (nextHeader.length < unpackSize) {\n+        final int assertFitsIntoNonNegativeInt = assertFitsIntoNonNegativeInt(\"unpackSize\", folder.getUnpackSize());\n+        final byte[] range = IOUtils.readRange((InputStream)addDecoder, assertFitsIntoNonNegativeInt);\n+        if (range.length < assertFitsIntoNonNegativeInt) {\n             throw new IOException(\"premature end of stream\");\n         }\n-        inputStreamStack.close();\n-        return ByteBuffer.wrap(nextHeader).order(ByteOrder.LITTLE_ENDIAN);\n+        ((InputStream)addDecoder).close();\n+        return ByteBuffer.wrap(range).order(ByteOrder.LITTLE_ENDIAN);\n     }\n     \n-    private void readFilesInfo(final ByteBuffer header, final Archive archive) throws IOException {\n-        final int numFilesInt = (int)readUint64(header);\n-        final Map<Integer, SevenZArchiveEntry> fileMap = new LinkedHashMap<Integer, SevenZArchiveEntry>();\n-        BitSet isEmptyStream = null;\n-        BitSet isEmptyFile = null;\n-        BitSet isAnti = null;\n+    private void readFilesInfo(final ByteBuffer byteBuffer, final Archive archive) throws IOException {\n+        final int n = (int)readUint64(byteBuffer);\n+        final LinkedHashMap linkedHashMap = new LinkedHashMap();\n+        BitSet bits = null;\n+        BitSet bits2 = null;\n+        BitSet bits3 = null;\n         while (true) {\n-            final int propertyType = getUnsignedByte(header);\n-            if (propertyType == 0) {\n-                int nonEmptyFileCounter = 0;\n-                int emptyFileCounter = 0;\n-                for (int i = 0; i < numFilesInt; ++i) {\n-                    final SevenZArchiveEntry entryAtIndex = (SevenZArchiveEntry)fileMap.get(Integer.valueOf(i));\n-                    if (entryAtIndex != null) {\n-                        entryAtIndex.setHasStream(isEmptyStream == null || !isEmptyStream.get(i));\n-                        if (entryAtIndex.hasStream()) {\n+            final int unsignedByte = getUnsignedByte(byteBuffer);\n+            if (unsignedByte == 0) {\n+                int bitIndex = 0;\n+                int n2 = 0;\n+                for (int i = 0; i < n; ++i) {\n+                    final SevenZArchiveEntry sevenZArchiveEntry = (SevenZArchiveEntry)linkedHashMap.get(Integer.valueOf(i));\n+                    if (sevenZArchiveEntry != null) {\n+                        sevenZArchiveEntry.setHasStream(bits == null || !bits.get(i));\n+                        if (sevenZArchiveEntry.hasStream()) {\n                             if (archive.subStreamsInfo == null) {\n                                 throw new IOException(\"Archive contains file with streams but no subStreamsInfo\");\n                             }\n-                            entryAtIndex.setDirectory(false);\n-                            entryAtIndex.setAntiItem(false);\n-                            entryAtIndex.setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\n-                            entryAtIndex.setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\n-                            entryAtIndex.setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n-                            if (entryAtIndex.getSize() < 0L) {\n+                            sevenZArchiveEntry.setDirectory(false);\n+                            sevenZArchiveEntry.setAntiItem(false);\n+                            sevenZArchiveEntry.setHasCrc(archive.subStreamsInfo.hasCrc.get(bitIndex));\n+                            sevenZArchiveEntry.setCrcValue(archive.subStreamsInfo.crcs[bitIndex]);\n+                            sevenZArchiveEntry.setSize(archive.subStreamsInfo.unpackSizes[bitIndex]);\n+                            if (sevenZArchiveEntry.getSize() < 0L) {\n                                 throw new IOException(\"broken archive, entry with negative size\");\n                             }\n-                            ++nonEmptyFileCounter;\n+                            ++bitIndex;\n                         }\n                         else {\n-                            entryAtIndex.setDirectory(isEmptyFile == null || !isEmptyFile.get(emptyFileCounter));\n-                            entryAtIndex.setAntiItem(isAnti != null && isAnti.get(emptyFileCounter));\n-                            entryAtIndex.setHasCrc(false);\n-                            entryAtIndex.setSize(0L);\n-                            ++emptyFileCounter;\n+                            sevenZArchiveEntry.setDirectory(bits2 == null || !bits2.get(n2));\n+                            sevenZArchiveEntry.setAntiItem(bits3 != null && bits3.get(n2));\n+                            sevenZArchiveEntry.setHasCrc(false);\n+                            sevenZArchiveEntry.setSize(0L);\n+                            ++n2;\n                         }\n                     }\n                 }\n-                archive.files = fileMap.values().stream().filter(Objects::nonNull).toArray(SevenZArchiveEntry[]::new);\n+                archive.files = (SevenZArchiveEntry[])linkedHashMap.values().stream().filter(Objects::nonNull).toArray(SevenZArchiveEntry[]::new);\n                 this.calculateStreamMap(archive);\n                 return;\n             }\n-            final long size = readUint64(header);\n-            switch (propertyType) {\n+            final long uint64 = readUint64(byteBuffer);\n+            switch (unsignedByte) {\n                 case 14: {\n-                    isEmptyStream = this.readBits(header, numFilesInt);\n+                    bits = this.readBits(byteBuffer, n);\n                     continue;\n                 }\n                 case 15: {\n-                    isEmptyFile = this.readBits(header, isEmptyStream.cardinality());\n+                    bits2 = this.readBits(byteBuffer, bits.cardinality());\n                     continue;\n                 }\n                 case 16: {\n-                    isAnti = this.readBits(header, isEmptyStream.cardinality());\n+                    bits3 = this.readBits(byteBuffer, bits.cardinality());\n                     continue;\n                 }\n                 case 17: {\n-                    getUnsignedByte(header);\n-                    final byte[] names = new byte[(int)(size - 1L)];\n-                    final int namesLength = names.length;\n-                    get(header, names);\n-                    int nextFile = 0;\n-                    int nextName = 0;\n-                    for (int j = 0; j < namesLength; j += 2) {\n-                        if (names[j] == 0 && names[j + 1] == 0) {\n-                            this.checkEntryIsInitialized(fileMap, nextFile);\n-                            ((SevenZArchiveEntry)fileMap.get(Integer.valueOf(nextFile))).setName(new String(names, nextName, j - nextName, StandardCharsets.UTF_16LE));\n-                            nextName = j + 2;\n-                            ++nextFile;\n+                    getUnsignedByte(byteBuffer);\n+                    final byte[] bytes = new byte[(int)(uint64 - 1L)];\n+                    final int length = bytes.length;\n+                    get(byteBuffer, bytes);\n+                    int j = 0;\n+                    int offset = 0;\n+                    for (int k = 0; k < length; k += 2) {\n+                        if (bytes[k] == 0 && bytes[k + 1] == 0) {\n+                            this.checkEntryIsInitialized(linkedHashMap, j);\n+                            ((SevenZArchiveEntry)linkedHashMap.get(Integer.valueOf(j))).setName(new String(bytes, offset, k - offset, StandardCharsets.UTF_16LE));\n+                            offset = k + 2;\n+                            ++j;\n                         }\n                     }\n-                    if (nextName != namesLength || nextFile != numFilesInt) {\n+                    if (offset != length || j != n) {\n                         throw new IOException(\"Error parsing file names\");\n                     }\n                     continue;\n                 }\n                 case 18: {\n-                    final BitSet timesDefined = this.readAllOrBits(header, numFilesInt);\n-                    getUnsignedByte(header);\n-                    for (int k = 0; k < numFilesInt; ++k) {\n-                        this.checkEntryIsInitialized(fileMap, k);\n-                        final SevenZArchiveEntry entryAtIndex2 = (SevenZArchiveEntry)fileMap.get(Integer.valueOf(k));\n-                        entryAtIndex2.setHasCreationDate(timesDefined.get(k));\n-                        if (entryAtIndex2.getHasCreationDate()) {\n-                            entryAtIndex2.setCreationDate(getLong(header));\n+                    final BitSet allOrBits = this.readAllOrBits(byteBuffer, n);\n+                    getUnsignedByte(byteBuffer);\n+                    for (int l = 0; l < n; ++l) {\n+                        this.checkEntryIsInitialized(linkedHashMap, l);\n+                        final SevenZArchiveEntry sevenZArchiveEntry2 = (SevenZArchiveEntry)linkedHashMap.get(Integer.valueOf(l));\n+                        sevenZArchiveEntry2.setHasCreationDate(allOrBits.get(l));\n+                        if (sevenZArchiveEntry2.getHasCreationDate()) {\n+                            sevenZArchiveEntry2.setCreationDate(getLong(byteBuffer));\n                         }\n                     }\n                     continue;\n                 }\n                 case 19: {\n-                    final BitSet timesDefined = this.readAllOrBits(header, numFilesInt);\n-                    getUnsignedByte(header);\n-                    for (int k = 0; k < numFilesInt; ++k) {\n-                        this.checkEntryIsInitialized(fileMap, k);\n-                        final SevenZArchiveEntry entryAtIndex2 = (SevenZArchiveEntry)fileMap.get(Integer.valueOf(k));\n-                        entryAtIndex2.setHasAccessDate(timesDefined.get(k));\n-                        if (entryAtIndex2.getHasAccessDate()) {\n-                            entryAtIndex2.setAccessDate(getLong(header));\n+                    final BitSet allOrBits2 = this.readAllOrBits(byteBuffer, n);\n+                    getUnsignedByte(byteBuffer);\n+                    for (int n3 = 0; n3 < n; ++n3) {\n+                        this.checkEntryIsInitialized(linkedHashMap, n3);\n+                        final SevenZArchiveEntry sevenZArchiveEntry3 = (SevenZArchiveEntry)linkedHashMap.get(Integer.valueOf(n3));\n+                        sevenZArchiveEntry3.setHasAccessDate(allOrBits2.get(n3));\n+                        if (sevenZArchiveEntry3.getHasAccessDate()) {\n+                            sevenZArchiveEntry3.setAccessDate(getLong(byteBuffer));\n                         }\n                     }\n                     continue;\n                 }\n                 case 20: {\n-                    final BitSet timesDefined = this.readAllOrBits(header, numFilesInt);\n-                    getUnsignedByte(header);\n-                    for (int k = 0; k < numFilesInt; ++k) {\n-                        this.checkEntryIsInitialized(fileMap, k);\n-                        final SevenZArchiveEntry entryAtIndex2 = (SevenZArchiveEntry)fileMap.get(Integer.valueOf(k));\n-                        entryAtIndex2.setHasLastModifiedDate(timesDefined.get(k));\n-                        if (entryAtIndex2.getHasLastModifiedDate()) {\n-                            entryAtIndex2.setLastModifiedDate(getLong(header));\n+                    final BitSet allOrBits3 = this.readAllOrBits(byteBuffer, n);\n+                    getUnsignedByte(byteBuffer);\n+                    for (int n4 = 0; n4 < n; ++n4) {\n+                        this.checkEntryIsInitialized(linkedHashMap, n4);\n+                        final SevenZArchiveEntry sevenZArchiveEntry4 = (SevenZArchiveEntry)linkedHashMap.get(Integer.valueOf(n4));\n+                        sevenZArchiveEntry4.setHasLastModifiedDate(allOrBits3.get(n4));\n+                        if (sevenZArchiveEntry4.getHasLastModifiedDate()) {\n+                            sevenZArchiveEntry4.setLastModifiedDate(getLong(byteBuffer));\n                         }\n                     }\n                     continue;\n                 }\n                 case 21: {\n-                    final BitSet attributesDefined = this.readAllOrBits(header, numFilesInt);\n-                    getUnsignedByte(header);\n-                    for (int k = 0; k < numFilesInt; ++k) {\n-                        this.checkEntryIsInitialized(fileMap, k);\n-                        final SevenZArchiveEntry entryAtIndex2 = (SevenZArchiveEntry)fileMap.get(Integer.valueOf(k));\n-                        entryAtIndex2.setHasWindowsAttributes(attributesDefined.get(k));\n-                        if (entryAtIndex2.getHasWindowsAttributes()) {\n-                            entryAtIndex2.setWindowsAttributes(getInt(header));\n+                    final BitSet allOrBits4 = this.readAllOrBits(byteBuffer, n);\n+                    getUnsignedByte(byteBuffer);\n+                    for (int n5 = 0; n5 < n; ++n5) {\n+                        this.checkEntryIsInitialized(linkedHashMap, n5);\n+                        final SevenZArchiveEntry sevenZArchiveEntry5 = (SevenZArchiveEntry)linkedHashMap.get(Integer.valueOf(n5));\n+                        sevenZArchiveEntry5.setHasWindowsAttributes(allOrBits4.get(n5));\n+                        if (sevenZArchiveEntry5.getHasWindowsAttributes()) {\n+                            sevenZArchiveEntry5.setWindowsAttributes(getInt(byteBuffer));\n                         }\n                     }\n                     continue;\n                 }\n                 case 25: {\n-                    skipBytesFully(header, size);\n+                    skipBytesFully(byteBuffer, uint64);\n                     continue;\n                 }\n                 default: {\n-                    skipBytesFully(header, size);\n+                    skipBytesFully(byteBuffer, uint64);\n                     continue;\n                 }\n             }\n         }\n     }\n     \n-    private Folder readFolder(final ByteBuffer header) throws IOException {\n+    private Folder readFolder(final ByteBuffer byteBuffer) throws IOException {\n         final Folder folder = new Folder();\n-        final long numCoders = readUint64(header);\n-        final Coder[] coders = new Coder[(int)numCoders];\n-        long totalInStreams = 0L;\n-        long totalOutStreams = 0L;\n+        final Coder[] coders = new Coder[(int)readUint64(byteBuffer)];\n+        long totalInputStreams = 0L;\n+        long totalOutputStreams = 0L;\n         for (int i = 0; i < coders.length; ++i) {\n             coders[i] = new Coder();\n-            final int bits = getUnsignedByte(header);\n-            final int idSize = bits & 0xF;\n-            final boolean isSimple = (bits & 0x10) == 0x0;\n-            final boolean hasAttributes = (bits & 0x20) != 0x0;\n-            final boolean moreAlternativeMethods = (bits & 0x80) != 0x0;\n-            get(header, coders[i].decompressionMethodId = new byte[idSize]);\n-            if (isSimple) {\n+            final int unsignedByte = getUnsignedByte(byteBuffer);\n+            final int n = unsignedByte & 0xF;\n+            final boolean b = (unsignedByte & 0x10) == 0x0;\n+            final boolean b2 = (unsignedByte & 0x20) != 0x0;\n+            final boolean b3 = (unsignedByte & 0x80) != 0x0;\n+            get(byteBuffer, coders[i].decompressionMethodId = new byte[n]);\n+            if (b) {\n                 coders[i].numInStreams = 1L;\n                 coders[i].numOutStreams = 1L;\n             }\n             else {\n-                coders[i].numInStreams = readUint64(header);\n-                coders[i].numOutStreams = readUint64(header);\n+                coders[i].numInStreams = readUint64(byteBuffer);\n+                coders[i].numOutStreams = readUint64(byteBuffer);\n             }\n-            totalInStreams += coders[i].numInStreams;\n-            totalOutStreams += coders[i].numOutStreams;\n-            if (hasAttributes) {\n-                final long propertiesSize = readUint64(header);\n-                get(header, coders[i].properties = new byte[(int)propertiesSize]);\n+            totalInputStreams += coders[i].numInStreams;\n+            totalOutputStreams += coders[i].numOutStreams;\n+            if (b2) {\n+                get(byteBuffer, coders[i].properties = new byte[(int)readUint64(byteBuffer)]);\n             }\n-            if (moreAlternativeMethods) {\n+            if (b3) {\n                 throw new IOException(\"Alternative methods are unsupported, please report. The reference implementation doesn't support them either.\");\n             }\n         }\n         folder.coders = coders;\n-        folder.totalInputStreams = totalInStreams;\n-        folder.totalOutputStreams = totalOutStreams;\n-        final long numBindPairs = totalOutStreams - 1L;\n-        final BindPair[] bindPairs = new BindPair[(int)numBindPairs];\n+        folder.totalInputStreams = totalInputStreams;\n+        folder.totalOutputStreams = totalOutputStreams;\n+        final long n2 = totalOutputStreams - 1L;\n+        final BindPair[] bindPairs = new BindPair[(int)n2];\n         for (int j = 0; j < bindPairs.length; ++j) {\n             bindPairs[j] = new BindPair();\n-            bindPairs[j].inIndex = readUint64(header);\n-            bindPairs[j].outIndex = readUint64(header);\n+            bindPairs[j].inIndex = readUint64(byteBuffer);\n+            bindPairs[j].outIndex = readUint64(byteBuffer);\n         }\n         folder.bindPairs = bindPairs;\n-        final long numPackedStreams = totalInStreams - numBindPairs;\n-        final long[] packedStreams = new long[(int)numPackedStreams];\n-        if (numPackedStreams == 1L) {\n-            int k;\n-            for (k = 0; k < (int)totalInStreams && folder.findBindPairForInStream(k) >= 0; ++k) {}\n-            packedStreams[0] = k;\n+        final long n3 = totalInputStreams - n2;\n+        final long[] packedStreams = new long[(int)n3];\n+        if (n3 == 1L) {\n+            int n4;\n+            for (n4 = 0; n4 < (int)totalInputStreams && folder.findBindPairForInStream(n4) >= 0; ++n4) {}\n+            packedStreams[0] = n4;\n         }\n         else {\n-            for (int k = 0; k < (int)numPackedStreams; ++k) {\n-                packedStreams[k] = readUint64(header);\n+            for (int k = 0; k < (int)n3; ++k) {\n+                packedStreams[k] = readUint64(byteBuffer);\n             }\n         }\n         folder.packedStreams = packedStreams;\n         return folder;\n     }\n     \n-    private void readFully(final ByteBuffer buf) throws IOException {\n-        buf.rewind();\n-        IOUtils.readFully((ReadableByteChannel)this.channel, buf);\n-        buf.flip();\n-    }\n-    \n-    private void readHeader(final ByteBuffer header, final Archive archive) throws IOException {\n-        final int pos = header.position();\n-        final SevenZFile.ArchiveStatistics stats = this.sanityCheckAndCollectStatistics(header);\n-        stats.assertValidity(this.options.getMaxMemoryLimitInKb());\n-        header.position();\n-        int nid = getUnsignedByte(header);\n-        if (nid == 2) {\n-            this.readArchiveProperties(header);\n-            nid = getUnsignedByte(header);\n+    private void readFully(final ByteBuffer byteBuffer) throws IOException {\n+        byteBuffer.rewind();\n+        IOUtils.readFully((ReadableByteChannel)this.channel, byteBuffer);\n+        byteBuffer.flip();\n+    }\n+    \n+    private void readHeader(final ByteBuffer byteBuffer, final Archive archive) throws IOException {\n+        final int position = byteBuffer.position();\n+        this.sanityCheckAndCollectStatistics(byteBuffer).assertValidity(this.options.getMaxMemoryLimitInKb());\n+        byteBuffer.position();\n+        int n = getUnsignedByte(byteBuffer);\n+        if (n == 2) {\n+            this.readArchiveProperties(byteBuffer);\n+            n = getUnsignedByte(byteBuffer);\n         }\n-        if (nid == 3) {\n+        if (n == 3) {\n             throw new IOException(\"Additional streams unsupported\");\n         }\n-        if (nid == 4) {\n-            this.readStreamsInfo(header, archive);\n-            nid = getUnsignedByte(header);\n-        }\n-        if (nid == 5) {\n-            this.readFilesInfo(header, archive);\n-            nid = getUnsignedByte(header);\n+        if (n == 4) {\n+            this.readStreamsInfo(byteBuffer, archive);\n+            n = getUnsignedByte(byteBuffer);\n+        }\n+        if (n == 5) {\n+            this.readFilesInfo(byteBuffer, archive);\n+            getUnsignedByte(byteBuffer);\n         }\n     }\n     \n-    private Archive readHeaders(final byte[] password) throws IOException {\n-        final ByteBuffer buf = ByteBuffer.allocate(12).order(ByteOrder.LITTLE_ENDIAN);\n-        this.readFully(buf);\n-        final byte[] signature = new byte[6];\n-        buf.get(signature);\n-        if (!Arrays.equals(signature, SevenZFile.sevenZSignature)) {\n+    private Archive readHeaders(final byte[] array) throws IOException {\n+        final ByteBuffer order = ByteBuffer.allocate(12).order(ByteOrder.LITTLE_ENDIAN);\n+        this.readFully(order);\n+        final byte[] array2 = new byte[6];\n+        order.get(array2);\n+        if (!Arrays.equals(array2, SevenZFile.sevenZSignature)) {\n             throw new IOException(\"Bad 7z signature\");\n         }\n-        final byte archiveVersionMajor = buf.get();\n-        final byte archiveVersionMinor = buf.get();\n-        if (archiveVersionMajor != 0) {\n-            throw new IOException(String.format(\"Unsupported 7z version (%d,%d)\", Byte.valueOf(archiveVersionMajor), Byte.valueOf(archiveVersionMinor)));\n-        }\n-        boolean headerLooksValid = false;\n-        final long startHeaderCrc = 0xFFFFFFFFL & (long)buf.getInt();\n-        if (startHeaderCrc == 0L) {\n-            final long currentPosition = this.channel.position();\n-            final ByteBuffer peekBuf = ByteBuffer.allocate(20);\n-            this.readFully(peekBuf);\n-            this.channel.position(currentPosition);\n-            while (peekBuf.hasRemaining()) {\n-                if (peekBuf.get() != 0) {\n-                    headerLooksValid = true;\n+        final byte value = order.get();\n+        final byte value2 = order.get();\n+        if (value != 0) {\n+            throw new IOException(String.format(\"Unsupported 7z version (%d,%d)\", Byte.valueOf(value), Byte.valueOf(value2)));\n+        }\n+        boolean b = false;\n+        final long n = 0xFFFFFFFFL & (long)order.getInt();\n+        if (n == 0L) {\n+            final long position = this.channel.position();\n+            final ByteBuffer allocate = ByteBuffer.allocate(20);\n+            this.readFully(allocate);\n+            this.channel.position(position);\n+            while (allocate.hasRemaining()) {\n+                if (allocate.get() != 0) {\n+                    b = true;\n                     break;\n                 }\n             }\n         }\n         else {\n-            headerLooksValid = true;\n+            b = true;\n         }\n-        if (headerLooksValid) {\n-            return this.initializeArchive(this.readStartHeader(startHeaderCrc), password, true);\n+        if (b) {\n+            return this.initializeArchive(this.readStartHeader(n), array, true);\n         }\n         if (this.options.getTryToRecoverBrokenArchives()) {\n-            return this.tryToLocateEndHeader(password);\n+            return this.tryToLocateEndHeader(array);\n         }\n         throw new IOException(\"archive seems to be invalid.\\nYou may want to retry and enable the tryToRecoverBrokenArchives if the archive could be a multi volume archive that has been closed prematurely.\");\n     }\n     \n-    private void readPackInfo(final ByteBuffer header, final Archive archive) throws IOException {\n-        archive.packPos = readUint64(header);\n-        final int numPackStreamsInt = (int)readUint64(header);\n-        int nid = getUnsignedByte(header);\n-        if (nid == 9) {\n-            archive.packSizes = new long[numPackStreamsInt];\n+    private void readPackInfo(final ByteBuffer byteBuffer, final Archive archive) throws IOException {\n+        archive.packPos = readUint64(byteBuffer);\n+        final int n = (int)readUint64(byteBuffer);\n+        int n2 = getUnsignedByte(byteBuffer);\n+        if (n2 == 9) {\n+            archive.packSizes = new long[n];\n             for (int i = 0; i < archive.packSizes.length; ++i) {\n-                archive.packSizes[i] = readUint64(header);\n+                archive.packSizes[i] = readUint64(byteBuffer);\n             }\n-            nid = getUnsignedByte(header);\n+            n2 = getUnsignedByte(byteBuffer);\n         }\n-        if (nid == 10) {\n-            archive.packCrcsDefined = this.readAllOrBits(header, numPackStreamsInt);\n-            archive.packCrcs = new long[numPackStreamsInt];\n-            for (int i = 0; i < numPackStreamsInt; ++i) {\n-                if (archive.packCrcsDefined.get(i)) {\n-                    archive.packCrcs[i] = (0xFFFFFFFFL & (long)getInt(header));\n+        if (n2 == 10) {\n+            archive.packCrcsDefined = this.readAllOrBits(byteBuffer, n);\n+            archive.packCrcs = new long[n];\n+            for (int j = 0; j < n; ++j) {\n+                if (archive.packCrcsDefined.get(j)) {\n+                    archive.packCrcs[j] = (0xFFFFFFFFL & (long)getInt(byteBuffer));\n                 }\n             }\n-            nid = getUnsignedByte(header);\n+            getUnsignedByte(byteBuffer);\n         }\n     }\n     \n-    private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\n+    private StartHeader readStartHeader(final long n) throws IOException {\n         final StartHeader startHeader = new StartHeader();\n-        try (final DataInputStream dataInputStream = new DataInputStream((InputStream)new CRC32VerifyingInputStream((InputStream)new BoundedSeekableByteChannelInputStream(this.channel, 20L), 20L, startHeaderCrc))) {\n+        try (final DataInputStream dataInputStream = new DataInputStream((InputStream)new CRC32VerifyingInputStream((InputStream)new BoundedSeekableByteChannelInputStream(this.channel, 20L), 20L, n))) {\n             startHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\n             if (startHeader.nextHeaderOffset < 0L || startHeader.nextHeaderOffset + 32L > this.channel.size()) {\n                 throw new IOException(\"nextHeaderOffset is out of bounds\");\n             }\n             startHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\n-            final long nextHeaderEnd = startHeader.nextHeaderOffset + startHeader.nextHeaderSize;\n-            if (nextHeaderEnd < startHeader.nextHeaderOffset || nextHeaderEnd + 32L > this.channel.size()) {\n+            final long n2 = startHeader.nextHeaderOffset + startHeader.nextHeaderSize;\n+            if (n2 < startHeader.nextHeaderOffset || n2 + 32L > this.channel.size()) {\n                 throw new IOException(\"nextHeaderSize is out of bounds\");\n             }\n             startHeader.nextHeaderCrc = (0xFFFFFFFFL & (long)Integer.reverseBytes(dataInputStream.readInt()));\n             return startHeader;\n         }\n     }\n     \n-    private void readStreamsInfo(final ByteBuffer header, final Archive archive) throws IOException {\n-        int nid = getUnsignedByte(header);\n-        if (nid == 6) {\n-            this.readPackInfo(header, archive);\n-            nid = getUnsignedByte(header);\n-        }\n-        if (nid == 7) {\n-            this.readUnpackInfo(header, archive);\n-            nid = getUnsignedByte(header);\n+    private void readStreamsInfo(final ByteBuffer byteBuffer, final Archive archive) throws IOException {\n+        int n = getUnsignedByte(byteBuffer);\n+        if (n == 6) {\n+            this.readPackInfo(byteBuffer, archive);\n+            n = getUnsignedByte(byteBuffer);\n+        }\n+        if (n == 7) {\n+            this.readUnpackInfo(byteBuffer, archive);\n+            n = getUnsignedByte(byteBuffer);\n         }\n         else {\n             archive.folders = Folder.EMPTY_FOLDER_ARRAY;\n         }\n-        if (nid == 8) {\n-            this.readSubStreamsInfo(header, archive);\n-            nid = getUnsignedByte(header);\n+        if (n == 8) {\n+            this.readSubStreamsInfo(byteBuffer, archive);\n+            getUnsignedByte(byteBuffer);\n         }\n     }\n     \n-    private void readSubStreamsInfo(final ByteBuffer header, final Archive archive) throws IOException {\n-        for (final Folder folder : archive.folders) {\n-            folder.numUnpackSubStreams = 1;\n+    private void readSubStreamsInfo(final ByteBuffer byteBuffer, final Archive archive) throws IOException {\n+        final Folder[] folders = archive.folders;\n+        for (int length = folders.length, i = 0; i < length; ++i) {\n+            folders[i].numUnpackSubStreams = 1;\n         }\n-        long unpackStreamsCount = (long)archive.folders.length;\n-        int nid = getUnsignedByte(header);\n-        if (nid == 13) {\n-            unpackStreamsCount = 0L;\n-            for (final Folder folder2 : archive.folders) {\n-                final long numStreams = readUint64(header);\n-                folder2.numUnpackSubStreams = (int)numStreams;\n-                unpackStreamsCount += numStreams;\n+        long n = (long)archive.folders.length;\n+        int n2 = getUnsignedByte(byteBuffer);\n+        if (n2 == 13) {\n+            n = 0L;\n+            for (final Folder folder : archive.folders) {\n+                final long uint64 = readUint64(byteBuffer);\n+                folder.numUnpackSubStreams = (int)uint64;\n+                n += uint64;\n             }\n-            nid = getUnsignedByte(header);\n+            n2 = getUnsignedByte(byteBuffer);\n         }\n-        final int totalUnpackStreams = (int)unpackStreamsCount;\n+        final int nbits = (int)n;\n         final SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\n-        subStreamsInfo.unpackSizes = new long[totalUnpackStreams];\n-        subStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\n-        subStreamsInfo.crcs = new long[totalUnpackStreams];\n-        int nextUnpackStream = 0;\n-        for (final Folder folder3 : archive.folders) {\n-            if (folder3.numUnpackSubStreams != 0) {\n-                long sum = 0L;\n-                if (nid == 9) {\n-                    for (int i = 0; i < folder3.numUnpackSubStreams - 1; ++i) {\n-                        final long size = readUint64(header);\n-                        subStreamsInfo.unpackSizes[nextUnpackStream++] = size;\n-                        sum += size;\n+        subStreamsInfo.unpackSizes = new long[nbits];\n+        subStreamsInfo.hasCrc = new BitSet(nbits);\n+        subStreamsInfo.crcs = new long[nbits];\n+        int n3 = 0;\n+        for (final Folder folder2 : archive.folders) {\n+            if (folder2.numUnpackSubStreams != 0) {\n+                long n4 = 0L;\n+                if (n2 == 9) {\n+                    for (int l = 0; l < folder2.numUnpackSubStreams - 1; ++l) {\n+                        final long uint65 = readUint64(byteBuffer);\n+                        subStreamsInfo.unpackSizes[n3++] = uint65;\n+                        n4 += uint65;\n                     }\n                 }\n-                if (sum > folder3.getUnpackSize()) {\n+                if (n4 > folder2.getUnpackSize()) {\n                     throw new IOException(\"sum of unpack sizes of folder exceeds total unpack size\");\n                 }\n-                subStreamsInfo.unpackSizes[nextUnpackStream++] = folder3.getUnpackSize() - sum;\n+                subStreamsInfo.unpackSizes[n3++] = folder2.getUnpackSize() - n4;\n             }\n         }\n-        if (nid == 9) {\n-            nid = getUnsignedByte(header);\n+        if (n2 == 9) {\n+            n2 = getUnsignedByte(byteBuffer);\n         }\n-        int numDigests = 0;\n-        for (final Folder folder4 : archive.folders) {\n-            if (folder4.numUnpackSubStreams != 1 || !folder4.hasCrc) {\n-                numDigests += folder4.numUnpackSubStreams;\n+        int n5 = 0;\n+        for (final Folder folder3 : archive.folders) {\n+            if (folder3.numUnpackSubStreams != 1 || !folder3.hasCrc) {\n+                n5 += folder3.numUnpackSubStreams;\n             }\n         }\n-        if (nid == 10) {\n-            final BitSet hasMissingCrc = this.readAllOrBits(header, numDigests);\n-            final long[] missingCrcs = new long[numDigests];\n-            for (int j = 0; j < numDigests; ++j) {\n-                if (hasMissingCrc.get(j)) {\n-                    missingCrcs[j] = (0xFFFFFFFFL & (long)getInt(header));\n-                }\n-            }\n-            int nextCrc = 0;\n-            int nextMissingCrc = 0;\n-            for (final Folder folder5 : archive.folders) {\n-                if (folder5.numUnpackSubStreams == 1 && folder5.hasCrc) {\n-                    subStreamsInfo.hasCrc.set(nextCrc, true);\n-                    subStreamsInfo.crcs[nextCrc] = folder5.crc;\n-                    ++nextCrc;\n+        if (n2 == 10) {\n+            final BitSet allOrBits = this.readAllOrBits(byteBuffer, n5);\n+            final long[] array = new long[n5];\n+            for (int bitIndex = 0; bitIndex < n5; ++bitIndex) {\n+                if (allOrBits.get(bitIndex)) {\n+                    array[bitIndex] = (0xFFFFFFFFL & (long)getInt(byteBuffer));\n+                }\n+            }\n+            int n7 = 0;\n+            int bitIndex2 = 0;\n+            for (final Folder folder4 : archive.folders) {\n+                if (folder4.numUnpackSubStreams == 1 && folder4.hasCrc) {\n+                    subStreamsInfo.hasCrc.set(n7, true);\n+                    subStreamsInfo.crcs[n7] = folder4.crc;\n+                    ++n7;\n                 }\n                 else {\n-                    for (int k = 0; k < folder5.numUnpackSubStreams; ++k) {\n-                        subStreamsInfo.hasCrc.set(nextCrc, hasMissingCrc.get(nextMissingCrc));\n-                        subStreamsInfo.crcs[nextCrc] = missingCrcs[nextMissingCrc];\n-                        ++nextCrc;\n-                        ++nextMissingCrc;\n+                    for (int n9 = 0; n9 < folder4.numUnpackSubStreams; ++n9) {\n+                        subStreamsInfo.hasCrc.set(n7, allOrBits.get(bitIndex2));\n+                        subStreamsInfo.crcs[n7] = array[bitIndex2];\n+                        ++n7;\n+                        ++bitIndex2;\n                     }\n                 }\n             }\n-            nid = getUnsignedByte(header);\n+            getUnsignedByte(byteBuffer);\n         }\n         archive.subStreamsInfo = subStreamsInfo;\n     }\n     \n-    private void readUnpackInfo(final ByteBuffer header, final Archive archive) throws IOException {\n-        int nid = getUnsignedByte(header);\n-        final int numFoldersInt = (int)readUint64(header);\n-        final Folder[] folders = new Folder[numFoldersInt];\n+    private void readUnpackInfo(final ByteBuffer byteBuffer, final Archive archive) throws IOException {\n+        getUnsignedByte(byteBuffer);\n+        final int n = (int)readUint64(byteBuffer);\n+        final Folder[] folders = new Folder[n];\n         archive.folders = folders;\n-        getUnsignedByte(header);\n-        for (int i = 0; i < numFoldersInt; ++i) {\n-            folders[i] = this.readFolder(header);\n+        getUnsignedByte(byteBuffer);\n+        for (int i = 0; i < n; ++i) {\n+            folders[i] = this.readFolder(byteBuffer);\n         }\n-        nid = getUnsignedByte(header);\n+        getUnsignedByte(byteBuffer);\n         for (final Folder folder : folders) {\n             assertFitsIntoNonNegativeInt(\"totalOutputStreams\", folder.totalOutputStreams);\n             folder.unpackSizes = new long[(int)folder.totalOutputStreams];\n-            for (int j = 0; j < folder.totalOutputStreams; ++j) {\n-                folder.unpackSizes[j] = readUint64(header);\n+            for (int n2 = 0; n2 < folder.totalOutputStreams; ++n2) {\n+                folder.unpackSizes[n2] = readUint64(byteBuffer);\n             }\n         }\n-        nid = getUnsignedByte(header);\n-        if (nid == 10) {\n-            final BitSet crcsDefined = this.readAllOrBits(header, numFoldersInt);\n-            for (int k = 0; k < numFoldersInt; ++k) {\n-                if (crcsDefined.get(k)) {\n+        if (getUnsignedByte(byteBuffer) == 10) {\n+            final BitSet allOrBits = this.readAllOrBits(byteBuffer, n);\n+            for (int k = 0; k < n; ++k) {\n+                if (allOrBits.get(k)) {\n                     folders[k].hasCrc = true;\n-                    folders[k].crc = (0xFFFFFFFFL & (long)getInt(header));\n+                    folders[k].crc = (0xFFFFFFFFL & (long)getInt(byteBuffer));\n                 }\n                 else {\n                     folders[k].hasCrc = false;\n                 }\n             }\n-            nid = getUnsignedByte(header);\n+            getUnsignedByte(byteBuffer);\n         }\n     }\n     \n-    private void reopenFolderInputStream(final int folderIndex, final SevenZArchiveEntry file) throws IOException {\n+    private void reopenFolderInputStream(final int n, final SevenZArchiveEntry sevenZArchiveEntry) throws IOException {\n         this.deferredBlockStreams.clear();\n         if (this.currentFolderInputStream != null) {\n             this.currentFolderInputStream.close();\n             this.currentFolderInputStream = null;\n         }\n-        final Folder folder = this.archive.folders[folderIndex];\n-        final int firstPackStreamIndex = this.archive.streamMap.folderFirstPackStreamIndex[folderIndex];\n-        final long folderOffset = 32L + this.archive.packPos + this.archive.streamMap.packStreamOffsets[firstPackStreamIndex];\n-        this.currentFolderInputStream = this.buildDecoderStack(folder, folderOffset, firstPackStreamIndex, file);\n+        final Folder folder = this.archive.folders[n];\n+        final int n2 = this.archive.streamMap.folderFirstPackStreamIndex[n];\n+        this.currentFolderInputStream = this.buildDecoderStack(folder, 32L + this.archive.packPos + this.archive.streamMap.packStreamOffsets[n2], n2, sevenZArchiveEntry);\n     }\n     \n-    private SevenZFile.ArchiveStatistics sanityCheckAndCollectStatistics(final ByteBuffer header) throws IOException {\n-        final SevenZFile.ArchiveStatistics stats = new SevenZFile.ArchiveStatistics((SevenZFile.SevenZFile$1)null);\n-        int nid = getUnsignedByte(header);\n-        if (nid == 2) {\n-            this.sanityCheckArchiveProperties(header);\n-            nid = getUnsignedByte(header);\n+    private SevenZFile.ArchiveStatistics sanityCheckAndCollectStatistics(final ByteBuffer byteBuffer) throws IOException {\n+        final SevenZFile.ArchiveStatistics archiveStatistics = new SevenZFile.ArchiveStatistics((SevenZFile.SevenZFile$1)null);\n+        int i = getUnsignedByte(byteBuffer);\n+        if (i == 2) {\n+            this.sanityCheckArchiveProperties(byteBuffer);\n+            i = getUnsignedByte(byteBuffer);\n         }\n-        if (nid == 3) {\n+        if (i == 3) {\n             throw new IOException(\"Additional streams unsupported\");\n         }\n-        if (nid == 4) {\n-            this.sanityCheckStreamsInfo(header, stats);\n-            nid = getUnsignedByte(header);\n+        if (i == 4) {\n+            this.sanityCheckStreamsInfo(byteBuffer, archiveStatistics);\n+            i = getUnsignedByte(byteBuffer);\n         }\n-        if (nid == 5) {\n-            this.sanityCheckFilesInfo(header, stats);\n-            nid = getUnsignedByte(header);\n+        if (i == 5) {\n+            this.sanityCheckFilesInfo(byteBuffer, archiveStatistics);\n+            i = getUnsignedByte(byteBuffer);\n         }\n-        if (nid != 0) {\n-            throw new IOException(\"Badly terminated header, found \" + nid);\n+        if (i != 0) {\n+            throw new IOException(\"Badly terminated header, found \" + i);\n         }\n-        return stats;\n+        return archiveStatistics;\n     }\n     \n-    private void sanityCheckArchiveProperties(final ByteBuffer header) throws IOException {\n-        for (int nid = getUnsignedByte(header); nid != 0; nid = getUnsignedByte(header)) {\n-            final int propertySize = assertFitsIntoNonNegativeInt(\"propertySize\", readUint64(header));\n-            if (skipBytesFully(header, propertySize) < propertySize) {\n+    private void sanityCheckArchiveProperties(final ByteBuffer byteBuffer) throws IOException {\n+        for (int i = getUnsignedByte(byteBuffer); i != 0; i = getUnsignedByte(byteBuffer)) {\n+            final int assertFitsIntoNonNegativeInt = assertFitsIntoNonNegativeInt(\"propertySize\", readUint64(byteBuffer));\n+            if (skipBytesFully(byteBuffer, assertFitsIntoNonNegativeInt) < assertFitsIntoNonNegativeInt) {\n                 throw new IOException(\"invalid property size\");\n             }\n         }\n     }\n     \n-    private void sanityCheckFilesInfo(final ByteBuffer header, final SevenZFile.ArchiveStatistics stats) throws IOException {\n-        SevenZFile.ArchiveStatistics.access$302(stats, assertFitsIntoNonNegativeInt(\"numFiles\", readUint64(header)));\n-        int emptyStreams = -1;\n+    private void sanityCheckFilesInfo(final ByteBuffer byteBuffer, final SevenZFile.ArchiveStatistics archiveStatistics) throws IOException {\n+        SevenZFile.ArchiveStatistics.access$302(archiveStatistics, assertFitsIntoNonNegativeInt(\"numFiles\", readUint64(byteBuffer)));\n+        int cardinality = -1;\n         while (true) {\n-            final int propertyType = getUnsignedByte(header);\n-            if (propertyType == 0) {\n-                SevenZFile.ArchiveStatistics.access$402(stats, SevenZFile.ArchiveStatistics.access$300(stats) - Math.max(emptyStreams, 0));\n+            final int unsignedByte = getUnsignedByte(byteBuffer);\n+            if (unsignedByte == 0) {\n+                SevenZFile.ArchiveStatistics.access$402(archiveStatistics, SevenZFile.ArchiveStatistics.access$300(archiveStatistics) - Math.max(cardinality, 0));\n                 return;\n             }\n-            final long size = readUint64(header);\n-            switch (propertyType) {\n+            final long uint64 = readUint64(byteBuffer);\n+            switch (unsignedByte) {\n                 case 14: {\n-                    emptyStreams = this.readBits(header, SevenZFile.ArchiveStatistics.access$300(stats)).cardinality();\n+                    cardinality = this.readBits(byteBuffer, SevenZFile.ArchiveStatistics.access$300(archiveStatistics)).cardinality();\n                     continue;\n                 }\n                 case 15: {\n-                    if (emptyStreams == -1) {\n+                    if (cardinality == -1) {\n                         throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n                     }\n-                    this.readBits(header, emptyStreams);\n+                    this.readBits(byteBuffer, cardinality);\n                     continue;\n                 }\n                 case 16: {\n-                    if (emptyStreams == -1) {\n+                    if (cardinality == -1) {\n                         throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n                     }\n-                    this.readBits(header, emptyStreams);\n+                    this.readBits(byteBuffer, cardinality);\n                     continue;\n                 }\n                 case 17: {\n-                    final int external = getUnsignedByte(header);\n-                    if (external != 0) {\n+                    if (getUnsignedByte(byteBuffer) != 0) {\n                         throw new IOException(\"Not implemented\");\n                     }\n-                    final int namesLength = assertFitsIntoNonNegativeInt(\"file names length\", size - 1L);\n-                    if ((namesLength & 0x1) != 0x0) {\n+                    final int assertFitsIntoNonNegativeInt = assertFitsIntoNonNegativeInt(\"file names length\", uint64 - 1L);\n+                    if ((assertFitsIntoNonNegativeInt & 0x1) != 0x0) {\n                         throw new IOException(\"File names length invalid\");\n                     }\n-                    int filesSeen = 0;\n-                    for (int i = 0; i < namesLength; i += 2) {\n-                        final char c = getChar(header);\n-                        if (c == '\\0') {\n-                            ++filesSeen;\n+                    int i = 0;\n+                    for (int j = 0; j < assertFitsIntoNonNegativeInt; j += 2) {\n+                        if (getChar(byteBuffer) == '\\0') {\n+                            ++i;\n                         }\n                     }\n-                    if (filesSeen != SevenZFile.ArchiveStatistics.access$300(stats)) {\n-                        throw new IOException(\"Invalid number of file names (\" + filesSeen + \" instead of \" + SevenZFile.ArchiveStatistics.access$300(stats) + \")\");\n+                    if (i != SevenZFile.ArchiveStatistics.access$300(archiveStatistics)) {\n+                        throw new IOException(\"Invalid number of file names (\" + i + \" instead of \" + SevenZFile.ArchiveStatistics.access$300(archiveStatistics) + \")\");\n                     }\n                     continue;\n                 }\n                 case 18: {\n-                    final int timesDefined = this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$300(stats)).cardinality();\n-                    final int external2 = getUnsignedByte(header);\n-                    if (external2 != 0) {\n+                    final int cardinality2 = this.readAllOrBits(byteBuffer, SevenZFile.ArchiveStatistics.access$300(archiveStatistics)).cardinality();\n+                    if (getUnsignedByte(byteBuffer) != 0) {\n                         throw new IOException(\"Not implemented\");\n                     }\n-                    if (skipBytesFully(header, 8 * timesDefined) < 8 * timesDefined) {\n+                    if (skipBytesFully(byteBuffer, 8 * cardinality2) < 8 * cardinality2) {\n                         throw new IOException(\"invalid creation dates size\");\n                     }\n                     continue;\n                 }\n                 case 19: {\n-                    final int timesDefined = this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$300(stats)).cardinality();\n-                    final int external2 = getUnsignedByte(header);\n-                    if (external2 != 0) {\n+                    final int cardinality3 = this.readAllOrBits(byteBuffer, SevenZFile.ArchiveStatistics.access$300(archiveStatistics)).cardinality();\n+                    if (getUnsignedByte(byteBuffer) != 0) {\n                         throw new IOException(\"Not implemented\");\n                     }\n-                    if (skipBytesFully(header, 8 * timesDefined) < 8 * timesDefined) {\n+                    if (skipBytesFully(byteBuffer, 8 * cardinality3) < 8 * cardinality3) {\n                         throw new IOException(\"invalid access dates size\");\n                     }\n                     continue;\n                 }\n                 case 20: {\n-                    final int timesDefined = this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$300(stats)).cardinality();\n-                    final int external2 = getUnsignedByte(header);\n-                    if (external2 != 0) {\n+                    final int cardinality4 = this.readAllOrBits(byteBuffer, SevenZFile.ArchiveStatistics.access$300(archiveStatistics)).cardinality();\n+                    if (getUnsignedByte(byteBuffer) != 0) {\n                         throw new IOException(\"Not implemented\");\n                     }\n-                    if (skipBytesFully(header, 8 * timesDefined) < 8 * timesDefined) {\n+                    if (skipBytesFully(byteBuffer, 8 * cardinality4) < 8 * cardinality4) {\n                         throw new IOException(\"invalid modification dates size\");\n                     }\n                     continue;\n                 }\n                 case 21: {\n-                    final int attributesDefined = this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$300(stats)).cardinality();\n-                    final int external2 = getUnsignedByte(header);\n-                    if (external2 != 0) {\n+                    final int cardinality5 = this.readAllOrBits(byteBuffer, SevenZFile.ArchiveStatistics.access$300(archiveStatistics)).cardinality();\n+                    if (getUnsignedByte(byteBuffer) != 0) {\n                         throw new IOException(\"Not implemented\");\n                     }\n-                    if (skipBytesFully(header, 4 * attributesDefined) < 4 * attributesDefined) {\n+                    if (skipBytesFully(byteBuffer, 4 * cardinality5) < 4 * cardinality5) {\n                         throw new IOException(\"invalid windows attributes size\");\n                     }\n                     continue;\n                 }\n                 case 24: {\n                     throw new IOException(\"kStartPos is unsupported, please report\");\n                 }\n                 case 25: {\n-                    if (skipBytesFully(header, size) < size) {\n+                    if (skipBytesFully(byteBuffer, uint64) < uint64) {\n                         throw new IOException(\"Incomplete kDummy property\");\n                     }\n                     continue;\n                 }\n                 default: {\n-                    if (skipBytesFully(header, size) < size) {\n-                        throw new IOException(\"Incomplete property of type \" + propertyType);\n+                    if (skipBytesFully(byteBuffer, uint64) < uint64) {\n+                        throw new IOException(\"Incomplete property of type \" + unsignedByte);\n                     }\n                     continue;\n                 }\n             }\n         }\n     }\n     \n-    private int sanityCheckFolder(final ByteBuffer header, final SevenZFile.ArchiveStatistics stats) throws IOException {\n-        final int numCoders = assertFitsIntoNonNegativeInt(\"numCoders\", readUint64(header));\n-        if (numCoders == 0) {\n+    private int sanityCheckFolder(final ByteBuffer byteBuffer, final SevenZFile.ArchiveStatistics archiveStatistics) throws IOException {\n+        final int assertFitsIntoNonNegativeInt = assertFitsIntoNonNegativeInt(\"numCoders\", readUint64(byteBuffer));\n+        if (assertFitsIntoNonNegativeInt == 0) {\n             throw new IOException(\"Folder without coders\");\n         }\n-        SevenZFile.ArchiveStatistics.access$514(stats, (long)numCoders);\n-        long totalOutStreams = 0L;\n-        long totalInStreams = 0L;\n-        for (int i = 0; i < numCoders; ++i) {\n-            final int bits = getUnsignedByte(header);\n-            final int idSize = bits & 0xF;\n-            get(header, new byte[idSize]);\n-            final boolean isSimple = (bits & 0x10) == 0x0;\n-            final boolean hasAttributes = (bits & 0x20) != 0x0;\n-            final boolean moreAlternativeMethods = (bits & 0x80) != 0x0;\n-            if (moreAlternativeMethods) {\n+        SevenZFile.ArchiveStatistics.access$514(archiveStatistics, (long)assertFitsIntoNonNegativeInt);\n+        long n = 0L;\n+        long n2 = 0L;\n+        for (int i = 0; i < assertFitsIntoNonNegativeInt; ++i) {\n+            final int unsignedByte = getUnsignedByte(byteBuffer);\n+            get(byteBuffer, new byte[unsignedByte & 0xF]);\n+            final boolean b = (unsignedByte & 0x10) == 0x0;\n+            final boolean b2 = (unsignedByte & 0x20) != 0x0;\n+            if ((unsignedByte & 0x80) != 0x0) {\n                 throw new IOException(\"Alternative methods are unsupported, please report. The reference implementation doesn't support them either.\");\n             }\n-            if (isSimple) {\n-                ++totalInStreams;\n-                ++totalOutStreams;\n+            if (b) {\n+                ++n2;\n+                ++n;\n             }\n             else {\n-                totalInStreams += assertFitsIntoNonNegativeInt(\"numInStreams\", readUint64(header));\n-                totalOutStreams += assertFitsIntoNonNegativeInt(\"numOutStreams\", readUint64(header));\n+                n2 += assertFitsIntoNonNegativeInt(\"numInStreams\", readUint64(byteBuffer));\n+                n += assertFitsIntoNonNegativeInt(\"numOutStreams\", readUint64(byteBuffer));\n             }\n-            if (hasAttributes) {\n-                final int propertiesSize = assertFitsIntoNonNegativeInt(\"propertiesSize\", readUint64(header));\n-                if (skipBytesFully(header, propertiesSize) < propertiesSize) {\n+            if (b2) {\n+                final int assertFitsIntoNonNegativeInt2 = assertFitsIntoNonNegativeInt(\"propertiesSize\", readUint64(byteBuffer));\n+                if (skipBytesFully(byteBuffer, assertFitsIntoNonNegativeInt2) < assertFitsIntoNonNegativeInt2) {\n                     throw new IOException(\"invalid propertiesSize in folder\");\n                 }\n             }\n         }\n-        assertFitsIntoNonNegativeInt(\"totalInStreams\", totalInStreams);\n-        assertFitsIntoNonNegativeInt(\"totalOutStreams\", totalOutStreams);\n-        SevenZFile.ArchiveStatistics.access$614(stats, totalOutStreams);\n-        SevenZFile.ArchiveStatistics.access$714(stats, totalInStreams);\n-        if (totalOutStreams == 0L) {\n+        assertFitsIntoNonNegativeInt(\"totalInStreams\", n2);\n+        assertFitsIntoNonNegativeInt(\"totalOutStreams\", n);\n+        SevenZFile.ArchiveStatistics.access$614(archiveStatistics, n);\n+        SevenZFile.ArchiveStatistics.access$714(archiveStatistics, n2);\n+        if (n == 0L) {\n             throw new IOException(\"Total output streams can't be 0\");\n         }\n-        final int numBindPairs = assertFitsIntoNonNegativeInt(\"numBindPairs\", totalOutStreams - 1L);\n-        if (totalInStreams < numBindPairs) {\n+        final int assertFitsIntoNonNegativeInt3 = assertFitsIntoNonNegativeInt(\"numBindPairs\", n - 1L);\n+        if (n2 < assertFitsIntoNonNegativeInt3) {\n             throw new IOException(\"Total input streams can't be less than the number of bind pairs\");\n         }\n-        final BitSet inStreamsBound = new BitSet((int)totalInStreams);\n-        for (int j = 0; j < numBindPairs; ++j) {\n-            final int inIndex = assertFitsIntoNonNegativeInt(\"inIndex\", readUint64(header));\n-            if (totalInStreams <= inIndex) {\n+        final BitSet set = new BitSet((int)n2);\n+        for (int j = 0; j < assertFitsIntoNonNegativeInt3; ++j) {\n+            final int assertFitsIntoNonNegativeInt4 = assertFitsIntoNonNegativeInt(\"inIndex\", readUint64(byteBuffer));\n+            if (n2 <= assertFitsIntoNonNegativeInt4) {\n                 throw new IOException(\"inIndex is bigger than number of inStreams\");\n             }\n-            inStreamsBound.set(inIndex);\n-            final int outIndex = assertFitsIntoNonNegativeInt(\"outIndex\", readUint64(header));\n-            if (totalOutStreams <= outIndex) {\n+            set.set(assertFitsIntoNonNegativeInt4);\n+            if (n <= assertFitsIntoNonNegativeInt(\"outIndex\", readUint64(byteBuffer))) {\n                 throw new IOException(\"outIndex is bigger than number of outStreams\");\n             }\n         }\n-        final int numPackedStreams = assertFitsIntoNonNegativeInt(\"numPackedStreams\", totalInStreams - (long)numBindPairs);\n-        if (numPackedStreams == 1) {\n-            if (inStreamsBound.nextClearBit(0) == -1) {\n+        final int assertFitsIntoNonNegativeInt5 = assertFitsIntoNonNegativeInt(\"numPackedStreams\", n2 - (long)assertFitsIntoNonNegativeInt3);\n+        if (assertFitsIntoNonNegativeInt5 == 1) {\n+            if (set.nextClearBit(0) == -1) {\n                 throw new IOException(\"Couldn't find stream's bind pair index\");\n             }\n         }\n         else {\n-            for (int k = 0; k < numPackedStreams; ++k) {\n-                final int packedStreamIndex = assertFitsIntoNonNegativeInt(\"packedStreamIndex\", readUint64(header));\n-                if (packedStreamIndex >= totalInStreams) {\n+            for (int k = 0; k < assertFitsIntoNonNegativeInt5; ++k) {\n+                if (assertFitsIntoNonNegativeInt(\"packedStreamIndex\", readUint64(byteBuffer)) >= n2) {\n                     throw new IOException(\"packedStreamIndex is bigger than number of totalInStreams\");\n                 }\n             }\n         }\n-        return (int)totalOutStreams;\n+        return (int)n;\n     }\n     \n-    private void sanityCheckPackInfo(final ByteBuffer header, final SevenZFile.ArchiveStatistics stats) throws IOException {\n-        final long packPos = readUint64(header);\n-        if (packPos < 0L || 32L + packPos > this.channel.size() || 32L + packPos < 0L) {\n-            throw new IOException(\"packPos (\" + packPos + \") is out of range\");\n-        }\n-        final long numPackStreams = readUint64(header);\n-        SevenZFile.ArchiveStatistics.access$802(stats, assertFitsIntoNonNegativeInt(\"numPackStreams\", numPackStreams));\n-        int nid = getUnsignedByte(header);\n-        if (nid == 9) {\n-            long totalPackSizes = 0L;\n-            for (int i = 0; i < SevenZFile.ArchiveStatistics.access$800(stats); ++i) {\n-                final long packSize = readUint64(header);\n-                totalPackSizes += packSize;\n-                final long endOfPackStreams = 32L + packPos + totalPackSizes;\n-                if (packSize < 0L || endOfPackStreams > this.channel.size() || endOfPackStreams < packPos) {\n-                    throw new IOException(\"packSize (\" + packSize + \") is out of range\");\n-                }\n-            }\n-            nid = getUnsignedByte(header);\n-        }\n-        if (nid == 10) {\n-            final int crcsDefined = this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$800(stats)).cardinality();\n-            if (skipBytesFully(header, 4 * crcsDefined) < 4 * crcsDefined) {\n+    private void sanityCheckPackInfo(final ByteBuffer byteBuffer, final SevenZFile.ArchiveStatistics archiveStatistics) throws IOException {\n+        final long uint64 = readUint64(byteBuffer);\n+        if (uint64 < 0L || 32L + uint64 > this.channel.size() || 32L + uint64 < 0L) {\n+            throw new IOException(\"packPos (\" + uint64 + \") is out of range\");\n+        }\n+        SevenZFile.ArchiveStatistics.access$802(archiveStatistics, assertFitsIntoNonNegativeInt(\"numPackStreams\", readUint64(byteBuffer)));\n+        int i = getUnsignedByte(byteBuffer);\n+        if (i == 9) {\n+            long n = 0L;\n+            for (int j = 0; j < SevenZFile.ArchiveStatistics.access$800(archiveStatistics); ++j) {\n+                final long uint65 = readUint64(byteBuffer);\n+                n += uint65;\n+                final long n2 = 32L + uint64 + n;\n+                if (uint65 < 0L || n2 > this.channel.size() || n2 < uint64) {\n+                    throw new IOException(\"packSize (\" + uint65 + \") is out of range\");\n+                }\n+            }\n+            i = getUnsignedByte(byteBuffer);\n+        }\n+        if (i == 10) {\n+            final int cardinality = this.readAllOrBits(byteBuffer, SevenZFile.ArchiveStatistics.access$800(archiveStatistics)).cardinality();\n+            if (skipBytesFully(byteBuffer, 4 * cardinality) < 4 * cardinality) {\n                 throw new IOException(\"invalid number of CRCs in PackInfo\");\n             }\n-            nid = getUnsignedByte(header);\n+            i = getUnsignedByte(byteBuffer);\n         }\n-        if (nid != 0) {\n-            throw new IOException(\"Badly terminated PackInfo (\" + nid + \")\");\n+        if (i != 0) {\n+            throw new IOException(\"Badly terminated PackInfo (\" + i + \")\");\n         }\n     }\n     \n-    private void sanityCheckStreamsInfo(final ByteBuffer header, final SevenZFile.ArchiveStatistics stats) throws IOException {\n-        int nid = getUnsignedByte(header);\n-        if (nid == 6) {\n-            this.sanityCheckPackInfo(header, stats);\n-            nid = getUnsignedByte(header);\n+    private void sanityCheckStreamsInfo(final ByteBuffer byteBuffer, final SevenZFile.ArchiveStatistics archiveStatistics) throws IOException {\n+        int n = getUnsignedByte(byteBuffer);\n+        if (n == 6) {\n+            this.sanityCheckPackInfo(byteBuffer, archiveStatistics);\n+            n = getUnsignedByte(byteBuffer);\n         }\n-        if (nid == 7) {\n-            this.sanityCheckUnpackInfo(header, stats);\n-            nid = getUnsignedByte(header);\n+        if (n == 7) {\n+            this.sanityCheckUnpackInfo(byteBuffer, archiveStatistics);\n+            n = getUnsignedByte(byteBuffer);\n         }\n-        if (nid == 8) {\n-            this.sanityCheckSubStreamsInfo(header, stats);\n-            nid = getUnsignedByte(header);\n+        if (n == 8) {\n+            this.sanityCheckSubStreamsInfo(byteBuffer, archiveStatistics);\n+            n = getUnsignedByte(byteBuffer);\n         }\n-        if (nid != 0) {\n+        if (n != 0) {\n             throw new IOException(\"Badly terminated StreamsInfo\");\n         }\n     }\n     \n-    private void sanityCheckSubStreamsInfo(final ByteBuffer header, final SevenZFile.ArchiveStatistics stats) throws IOException {\n-        int nid = getUnsignedByte(header);\n-        final List<Integer> numUnpackSubStreamsPerFolder = new LinkedList<Integer>();\n-        if (nid == 13) {\n-            for (int i = 0; i < SevenZFile.ArchiveStatistics.access$900(stats); ++i) {\n-                numUnpackSubStreamsPerFolder.add(Integer.valueOf(assertFitsIntoNonNegativeInt(\"numStreams\", readUint64(header))));\n+    private void sanityCheckSubStreamsInfo(final ByteBuffer byteBuffer, final SevenZFile.ArchiveStatistics archiveStatistics) throws IOException {\n+        int n = getUnsignedByte(byteBuffer);\n+        final LinkedList list = new LinkedList();\n+        if (n == 13) {\n+            for (int i = 0; i < SevenZFile.ArchiveStatistics.access$900(archiveStatistics); ++i) {\n+                list.add(Integer.valueOf(assertFitsIntoNonNegativeInt(\"numStreams\", readUint64(byteBuffer))));\n             }\n-            SevenZFile.ArchiveStatistics.access$1002(stats, numUnpackSubStreamsPerFolder.stream().mapToLong(Integer::longValue).sum());\n-            nid = getUnsignedByte(header);\n+            SevenZFile.ArchiveStatistics.access$1002(archiveStatistics, list.stream().mapToLong(Integer::longValue).sum());\n+            n = getUnsignedByte(byteBuffer);\n         }\n         else {\n-            SevenZFile.ArchiveStatistics.access$1002(stats, (long)SevenZFile.ArchiveStatistics.access$900(stats));\n+            SevenZFile.ArchiveStatistics.access$1002(archiveStatistics, (long)SevenZFile.ArchiveStatistics.access$900(archiveStatistics));\n         }\n-        assertFitsIntoNonNegativeInt(\"totalUnpackStreams\", SevenZFile.ArchiveStatistics.access$1000(stats));\n-        if (nid == 9) {\n-            final Iterator<Integer> iterator = numUnpackSubStreamsPerFolder.iterator();\n+        assertFitsIntoNonNegativeInt(\"totalUnpackStreams\", SevenZFile.ArchiveStatistics.access$1000(archiveStatistics));\n+        if (n == 9) {\n+            final Iterator iterator = list.iterator();\n             while (iterator.hasNext()) {\n-                final int numUnpackSubStreams = (int)Integer.valueOf(iterator.next());\n-                if (numUnpackSubStreams == 0) {\n+                final int intValue = (int)iterator.next();\n+                if (intValue == 0) {\n                     continue;\n                 }\n-                for (int j = 0; j < numUnpackSubStreams - 1; ++j) {\n-                    final long size = readUint64(header);\n-                    if (size < 0L) {\n+                for (int j = 0; j < intValue - 1; ++j) {\n+                    if (readUint64(byteBuffer) < 0L) {\n                         throw new IOException(\"negative unpackSize\");\n                     }\n                 }\n             }\n-            nid = getUnsignedByte(header);\n+            n = getUnsignedByte(byteBuffer);\n         }\n-        int numDigests = 0;\n-        if (numUnpackSubStreamsPerFolder.isEmpty()) {\n-            numDigests = ((SevenZFile.ArchiveStatistics.access$1100(stats) == null) ? SevenZFile.ArchiveStatistics.access$900(stats) : (SevenZFile.ArchiveStatistics.access$900(stats) - SevenZFile.ArchiveStatistics.access$1100(stats).cardinality()));\n+        int n2 = 0;\n+        if (list.isEmpty()) {\n+            n2 = ((SevenZFile.ArchiveStatistics.access$1100(archiveStatistics) == null) ? SevenZFile.ArchiveStatistics.access$900(archiveStatistics) : (SevenZFile.ArchiveStatistics.access$900(archiveStatistics) - SevenZFile.ArchiveStatistics.access$1100(archiveStatistics).cardinality()));\n         }\n         else {\n-            int folderIdx = 0;\n-            final Iterator<Integer> iterator2 = numUnpackSubStreamsPerFolder.iterator();\n+            int n3 = 0;\n+            final Iterator iterator2 = list.iterator();\n             while (iterator2.hasNext()) {\n-                final int numUnpackSubStreams2 = (int)Integer.valueOf(iterator2.next());\n-                if (numUnpackSubStreams2 != 1 || SevenZFile.ArchiveStatistics.access$1100(stats) == null || !SevenZFile.ArchiveStatistics.access$1100(stats).get(folderIdx++)) {\n-                    numDigests += numUnpackSubStreams2;\n+                final int intValue2 = (int)iterator2.next();\n+                if (intValue2 != 1 || SevenZFile.ArchiveStatistics.access$1100(archiveStatistics) == null || !SevenZFile.ArchiveStatistics.access$1100(archiveStatistics).get(n3++)) {\n+                    n2 += intValue2;\n                 }\n             }\n         }\n-        if (nid == 10) {\n-            assertFitsIntoNonNegativeInt(\"numDigests\", numDigests);\n-            final int missingCrcs = this.readAllOrBits(header, numDigests).cardinality();\n-            if (skipBytesFully(header, 4 * missingCrcs) < 4 * missingCrcs) {\n+        if (n == 10) {\n+            assertFitsIntoNonNegativeInt(\"numDigests\", n2);\n+            final int cardinality = this.readAllOrBits(byteBuffer, n2).cardinality();\n+            if (skipBytesFully(byteBuffer, 4 * cardinality) < 4 * cardinality) {\n                 throw new IOException(\"invalid number of missing CRCs in SubStreamInfo\");\n             }\n-            nid = getUnsignedByte(header);\n+            n = getUnsignedByte(byteBuffer);\n         }\n-        if (nid != 0) {\n+        if (n != 0) {\n             throw new IOException(\"Badly terminated SubStreamsInfo\");\n         }\n     }\n     \n-    private void sanityCheckUnpackInfo(final ByteBuffer header, final SevenZFile.ArchiveStatistics stats) throws IOException {\n-        int nid = getUnsignedByte(header);\n-        if (nid != 11) {\n-            throw new IOException(\"Expected kFolder, got \" + nid);\n-        }\n-        final long numFolders = readUint64(header);\n-        SevenZFile.ArchiveStatistics.access$902(stats, assertFitsIntoNonNegativeInt(\"numFolders\", numFolders));\n-        final int external = getUnsignedByte(header);\n-        if (external != 0) {\n+    private void sanityCheckUnpackInfo(final ByteBuffer byteBuffer, final SevenZFile.ArchiveStatistics archiveStatistics) throws IOException {\n+        final int unsignedByte = getUnsignedByte(byteBuffer);\n+        if (unsignedByte != 11) {\n+            throw new IOException(\"Expected kFolder, got \" + unsignedByte);\n+        }\n+        SevenZFile.ArchiveStatistics.access$902(archiveStatistics, assertFitsIntoNonNegativeInt(\"numFolders\", readUint64(byteBuffer)));\n+        if (getUnsignedByte(byteBuffer) != 0) {\n             throw new IOException(\"External unsupported\");\n         }\n-        final List<Integer> numberOfOutputStreamsPerFolder = new LinkedList<Integer>();\n-        for (int i = 0; i < SevenZFile.ArchiveStatistics.access$900(stats); ++i) {\n-            numberOfOutputStreamsPerFolder.add(Integer.valueOf(this.sanityCheckFolder(header, stats)));\n-        }\n-        final long totalNumberOfBindPairs = SevenZFile.ArchiveStatistics.access$600(stats) - SevenZFile.ArchiveStatistics.access$900(stats);\n-        final long packedStreamsRequiredByFolders = SevenZFile.ArchiveStatistics.access$700(stats) - totalNumberOfBindPairs;\n-        if (packedStreamsRequiredByFolders < SevenZFile.ArchiveStatistics.access$800(stats)) {\n+        final LinkedList list = new LinkedList();\n+        for (int i = 0; i < SevenZFile.ArchiveStatistics.access$900(archiveStatistics); ++i) {\n+            list.add(Integer.valueOf(this.sanityCheckFolder(byteBuffer, archiveStatistics)));\n+        }\n+        if (SevenZFile.ArchiveStatistics.access$700(archiveStatistics) - (SevenZFile.ArchiveStatistics.access$600(archiveStatistics) - SevenZFile.ArchiveStatistics.access$900(archiveStatistics)) < SevenZFile.ArchiveStatistics.access$800(archiveStatistics)) {\n             throw new IOException(\"archive doesn't contain enough packed streams\");\n         }\n-        nid = getUnsignedByte(header);\n-        if (nid != 12) {\n-            throw new IOException(\"Expected kCodersUnpackSize, got \" + nid);\n+        final int unsignedByte2 = getUnsignedByte(byteBuffer);\n+        if (unsignedByte2 != 12) {\n+            throw new IOException(\"Expected kCodersUnpackSize, got \" + unsignedByte2);\n         }\n-        final Iterator<Integer> iterator = numberOfOutputStreamsPerFolder.iterator();\n+        final Iterator iterator = list.iterator();\n         while (iterator.hasNext()) {\n-            for (int numberOfOutputStreams = (int)Integer.valueOf(iterator.next()), j = 0; j < numberOfOutputStreams; ++j) {\n-                final long unpackSize = readUint64(header);\n-                if (unpackSize < 0L) {\n+            for (int intValue = (int)iterator.next(), j = 0; j < intValue; ++j) {\n+                if (readUint64(byteBuffer) < 0L) {\n                     throw new IllegalArgumentException(\"negative unpackSize\");\n                 }\n             }\n         }\n-        nid = getUnsignedByte(header);\n-        if (nid == 10) {\n-            SevenZFile.ArchiveStatistics.access$1102(stats, this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$900(stats)));\n-            final int crcsDefined = SevenZFile.ArchiveStatistics.access$1100(stats).cardinality();\n-            if (skipBytesFully(header, 4 * crcsDefined) < 4 * crcsDefined) {\n+        int n = getUnsignedByte(byteBuffer);\n+        if (n == 10) {\n+            SevenZFile.ArchiveStatistics.access$1102(archiveStatistics, this.readAllOrBits(byteBuffer, SevenZFile.ArchiveStatistics.access$900(archiveStatistics)));\n+            final int cardinality = SevenZFile.ArchiveStatistics.access$1100(archiveStatistics).cardinality();\n+            if (skipBytesFully(byteBuffer, 4 * cardinality) < 4 * cardinality) {\n                 throw new IOException(\"invalid number of CRCs in UnpackInfo\");\n             }\n-            nid = getUnsignedByte(header);\n+            n = getUnsignedByte(byteBuffer);\n         }\n-        if (nid != 0) {\n+        if (n != 0) {\n             throw new IOException(\"Badly terminated UnpackInfo\");\n         }\n     }\n     \n-    private boolean skipEntriesWhenNeeded(final int entryIndex, final boolean isInSameFolder, final int folderIndex) throws IOException {\n-        final SevenZArchiveEntry file = this.archive.files[entryIndex];\n-        if (this.currentEntryIndex == entryIndex && !this.hasCurrentEntryBeenRead()) {\n+    private boolean skipEntriesWhenNeeded(final int n, final boolean b, final int n2) throws IOException {\n+        final SevenZArchiveEntry sevenZArchiveEntry = this.archive.files[n];\n+        if (this.currentEntryIndex == n && !this.hasCurrentEntryBeenRead()) {\n             return false;\n         }\n-        int filesToSkipStartIndex = this.archive.streamMap.folderFirstFileIndex[this.currentFolderIndex];\n-        if (isInSameFolder) {\n-            if (this.currentEntryIndex < entryIndex) {\n-                filesToSkipStartIndex = this.currentEntryIndex + 1;\n+        int n3 = this.archive.streamMap.folderFirstFileIndex[this.currentFolderIndex];\n+        if (b) {\n+            if (this.currentEntryIndex < n) {\n+                n3 = this.currentEntryIndex + 1;\n             }\n             else {\n-                this.reopenFolderInputStream(folderIndex, file);\n+                this.reopenFolderInputStream(n2, sevenZArchiveEntry);\n             }\n         }\n-        for (int i = filesToSkipStartIndex; i < entryIndex; ++i) {\n-            final SevenZArchiveEntry fileToSkip = this.archive.files[i];\n-            InputStream fileStreamToSkip = (InputStream)new BoundedInputStream(this.currentFolderInputStream, fileToSkip.getSize());\n-            if (fileToSkip.getHasCrc()) {\n-                fileStreamToSkip = (InputStream)new CRC32VerifyingInputStream(fileStreamToSkip, fileToSkip.getSize(), fileToSkip.getCrcValue());\n+        for (int i = n3; i < n; ++i) {\n+            final SevenZArchiveEntry sevenZArchiveEntry2 = this.archive.files[i];\n+            Object e = new BoundedInputStream(this.currentFolderInputStream, sevenZArchiveEntry2.getSize());\n+            if (sevenZArchiveEntry2.getHasCrc()) {\n+                e = new CRC32VerifyingInputStream((InputStream)e, sevenZArchiveEntry2.getSize(), sevenZArchiveEntry2.getCrcValue());\n             }\n-            this.deferredBlockStreams.add(fileStreamToSkip);\n-            fileToSkip.setContentMethods(file.getContentMethods());\n+            this.deferredBlockStreams.add((InputStream)e);\n+            sevenZArchiveEntry2.setContentMethods(sevenZArchiveEntry.getContentMethods());\n         }\n         return true;\n     }\n     \n     @Override\n     public String toString() {\n         return this.archive.toString();\n     }\n     \n-    private Archive tryToLocateEndHeader(final byte[] password) throws IOException {\n-        final ByteBuffer nidBuf = ByteBuffer.allocate(1);\n-        final long searchLimit = 1048576L;\n-        final long previousDataSize = this.channel.position() + 20L;\n-        long minPos;\n+    private Archive tryToLocateEndHeader(final byte[] array) throws IOException {\n+        final ByteBuffer allocate = ByteBuffer.allocate(1);\n+        final long n = this.channel.position() + 20L;\n+        long position;\n         if (this.channel.position() + 1048576L > this.channel.size()) {\n-            minPos = this.channel.position();\n+            position = this.channel.position();\n         }\n         else {\n-            minPos = this.channel.size() - 1048576L;\n+            position = this.channel.size() - 1048576L;\n         }\n-        long pos = this.channel.size() - 1L;\n-        while (pos > minPos) {\n-            --pos;\n-            this.channel.position(pos);\n-            nidBuf.rewind();\n-            if (this.channel.read(nidBuf) < 1) {\n+        long n2 = this.channel.size() - 1L;\n+        while (n2 > position) {\n+            --n2;\n+            this.channel.position(n2);\n+            allocate.rewind();\n+            if (this.channel.read(allocate) < 1) {\n                 throw new EOFException();\n             }\n-            final int nid = nidBuf.array()[0];\n-            if (nid != 23) {\n-                if (nid != 1) {\n+            final byte b = allocate.array()[0];\n+            if (b != 23) {\n+                if (b != 1) {\n                     continue;\n                 }\n             }\n             try {\n                 final StartHeader startHeader = new StartHeader();\n-                startHeader.nextHeaderOffset = pos - previousDataSize;\n-                startHeader.nextHeaderSize = this.channel.size() - pos;\n-                final Archive result = this.initializeArchive(startHeader, password, false);\n-                if (result.packSizes.length > 0 && result.files.length > 0) {\n-                    return result;\n+                startHeader.nextHeaderOffset = n2 - n;\n+                startHeader.nextHeaderSize = this.channel.size() - n2;\n+                final Archive initializeArchive = this.initializeArchive(startHeader, array, false);\n+                if (initializeArchive.packSizes.length > 0 && initializeArchive.files.length > 0) {\n+                    return initializeArchive;\n                 }\n                 continue;\n             }\n             catch (final Exception ex) {}\n         }\n         throw new IOException(\"Start header corrupt and unable to guess end header\");\n     }\n"}]}
