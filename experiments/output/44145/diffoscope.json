{"diffoscope-json-version": 1, "source1": "first/NodeTracker.class", "source2": "second/NodeTracker.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -29,24 +29,24 @@\n         return new NodeTracker(newState);\n     }\n     \n     public NodeTracker trackNodes(final Collection<NodeSelector> selectors, final Collection<ImmutableNode> nodes) {\n         final Map<NodeSelector, NodeTracker.TrackedNodeData> newState = new HashMap<NodeSelector, NodeTracker.TrackedNodeData>(this.trackedNodes);\n         final Iterator<ImmutableNode> itNodes = nodes.iterator();\n         selectors.forEach(selector -> {\n-            final ImmutableNode node = (ImmutableNode)itNodes.next();\n-            final NodeTracker.TrackedNodeData trackData = (NodeTracker.TrackedNodeData)newState.get(selector);\n+            final ImmutableNode node = (ImmutableNode)iterator.next();\n+            final NodeTracker.TrackedNodeData trackData = (NodeTracker.TrackedNodeData)map.get(selector);\n             NodeTracker.TrackedNodeData trackData2;\n             if (trackData == null) {\n                 trackData2 = new NodeTracker.TrackedNodeData(node);\n             }\n             else {\n                 trackData2 = trackData.observerAdded();\n             }\n-            newState.put(selector, trackData2);\n+            map.put(selector, trackData2);\n             return;\n         });\n         return new NodeTracker(newState);\n     }\n     \n     public NodeTracker untrackNode(final NodeSelector selector) {\n         final NodeTracker.TrackedNodeData trackData = this.getTrackedNodeData(selector);\n@@ -74,18 +74,15 @@\n     }\n     \n     public NodeTracker update(final ImmutableNode root, final NodeSelector txTarget, final NodeKeyResolver<ImmutableNode> resolver, final NodeHandler<ImmutableNode> handler) {\n         if (this.trackedNodes.isEmpty()) {\n             return this;\n         }\n         final Map<NodeSelector, NodeTracker.TrackedNodeData> newState = new HashMap<NodeSelector, NodeTracker.TrackedNodeData>();\n-        this.trackedNodes.entrySet().forEach(e -> {\n-            final NodeTracker.TrackedNodeData trackedNodeData = (NodeTracker.TrackedNodeData)newState.put(e.getKey(), determineUpdatedTrackedNodeData(root, txTarget, (NodeKeyResolver<ImmutableNode>)resolver, (NodeHandler<ImmutableNode>)handler, (Map.Entry<NodeSelector, NodeTracker.TrackedNodeData>)e));\n-            return;\n-        });\n+        this.trackedNodes.entrySet().forEach(e -> map.put(e.getKey(), determineUpdatedTrackedNodeData(root2, txTarget2, (NodeKeyResolver<ImmutableNode>)resolver2, (NodeHandler<ImmutableNode>)handler2, (Map.Entry<NodeSelector, NodeTracker.TrackedNodeData>)e)));\n         return new NodeTracker(newState);\n     }\n     \n     public NodeTracker detachAllTrackedNodes() {\n         if (this.trackedNodes.isEmpty()) {\n             return this;\n         }\n"}]}
