{"diffoscope-json-version": 1, "source1": "first/TarArchiveOutputStream.class", "source2": "second/TarArchiveOutputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -64,39 +64,39 @@\n     \n     @Deprecated\n     public TarArchiveOutputStream(final OutputStream outputStream, final int n, final int n2) {\n         this(outputStream, n, n2, null);\n     }\n     \n     @Deprecated\n-    public TarArchiveOutputStream(final OutputStream outputStream, final int n, final int i, final String s) {\n+    public TarArchiveOutputStream(final OutputStream outputStream, final int n, final int n2, final String s) {\n         this(outputStream, n, s);\n-        if (i != 512) {\n-            throw new IllegalArgumentException(\"Tar record size must always be 512 bytes. Attempt to set size of \" + i);\n+        if (n2 != 512) {\n+            throw new IllegalArgumentException(\"Tar record size must always be 512 bytes. Attempt to set size of \" + n2);\n         }\n     }\n     \n-    public TarArchiveOutputStream(final OutputStream outputStream, final int i, final String encoding) {\n+    public TarArchiveOutputStream(final OutputStream outputStream, final int n, final String encoding) {\n         this.longFileMode = 0;\n         this.bigNumberMode = 0;\n-        int n;\n-        if (-511 == i) {\n-            n = 512;\n+        int n2;\n+        if (-511 == n) {\n+            n2 = 512;\n         }\n         else {\n-            n = i;\n+            n2 = n;\n         }\n-        if (n <= 0 || n % 512 != 0) {\n-            throw new IllegalArgumentException(\"Block size must be a multiple of 512 bytes. Attempt to use set size of \" + i);\n+        if (n2 <= 0 || n2 % 512 != 0) {\n+            throw new IllegalArgumentException(\"Block size must be a multiple of 512 bytes. Attempt to use set size of \" + n);\n         }\n         this.out = new FixedLengthBlockOutputStream((OutputStream)(this.countingOut = new CountingOutputStream(outputStream)), 512);\n         this.encoding = encoding;\n         this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n         this.recordBuf = new byte[512];\n-        this.recordsPerBlock = n / 512;\n+        this.recordsPerBlock = n2 / 512;\n     }\n     \n     public void setLongFileMode(final int longFileMode) {\n         this.longFileMode = longFileMode;\n     }\n     \n     public void setBigNumberMode(final int bigNumberMode) {\n@@ -215,47 +215,47 @@\n         this.recordsWritten += this.currSize / 512L;\n         if (0L != this.currSize % 512L) {\n             ++this.recordsWritten;\n         }\n         this.haveUnclosedEntry = false;\n     }\n     \n-    public void write(final byte[] array, final int n, final int i) throws IOException {\n+    public void write(final byte[] array, final int n, final int n2) throws IOException {\n         if (!this.haveUnclosedEntry) {\n             throw new IllegalStateException(\"No current tar entry\");\n         }\n-        if (this.currBytes + i > this.currSize) {\n-            throw new IOException(\"Request to write '\" + i + \"' bytes exceeds size in header of '\" + this.currSize + \"' bytes for entry '\" + this.currName + \"'\");\n+        if (this.currBytes + n2 > this.currSize) {\n+            throw new IOException(\"Request to write '\" + n2 + \"' bytes exceeds size in header of '\" + this.currSize + \"' bytes for entry '\" + this.currName);\n         }\n-        this.out.write(array, n, i);\n-        this.currBytes += i;\n+        this.out.write(array, n, n2);\n+        this.currBytes += n2;\n     }\n     \n     void writePaxHeaders(final TarArchiveEntry tarArchiveEntry, final String s, final Map<String, String> map) throws IOException {\n-        String s2 = \"./PaxHeaders.X/\" + this.stripTo7Bits(s);\n-        if (s2.length() >= 100) {\n-            s2 = s2.substring(0, 99);\n+        String substring = \"./PaxHeaders.X/\" + this.stripTo7Bits(s);\n+        if (substring.length() >= 100) {\n+            substring = substring.substring(0, 99);\n         }\n-        final TarArchiveEntry tarArchiveEntry2 = new TarArchiveEntry(s2, (byte)120);\n+        final TarArchiveEntry tarArchiveEntry2 = new TarArchiveEntry(substring, (byte)120);\n         this.transferModTime(tarArchiveEntry, tarArchiveEntry2);\n         final byte[] encodeExtendedPaxHeadersContents = this.encodeExtendedPaxHeadersContents(map);\n         tarArchiveEntry2.setSize((long)encodeExtendedPaxHeadersContents.length);\n         this.putArchiveEntry((ArchiveEntry)tarArchiveEntry2);\n         this.write(encodeExtendedPaxHeadersContents);\n         this.closeArchiveEntry();\n     }\n     \n     private byte[] encodeExtendedPaxHeadersContents(final Map<String, String> map) {\n         final StringWriter stringWriter = new StringWriter();\n-        for (final Map.Entry entry : map.entrySet()) {\n+        for (Map.Entry entry : map.entrySet()) {\n             final String s = (String)entry.getKey();\n             final String s2 = (String)entry.getValue();\n             int i = s.length() + s2.length() + 3 + 2;\n-            String str = i + \" \" + s + \"=\" + s2 + \"\\n\";\n-            for (int n = str.getBytes(StandardCharsets.UTF_8).length; i != n; i = n, str = i + \" \" + s + \"=\" + s2 + \"\\n\", n = str.getBytes(StandardCharsets.UTF_8).length) {}\n+            String str = i + \" \" + s + \"=\" + s2;\n+            for (int n = str.getBytes(StandardCharsets.UTF_8).length; i != n; i = n, str = i + \" \" + s + \"=\" + s2, n = str.getBytes(StandardCharsets.UTF_8).length) {}\n             stringWriter.write(str);\n         }\n         return stringWriter.toString().getBytes(StandardCharsets.UTF_8);\n     }\n     \n     private String stripTo7Bits(final String s) {\n         final int length = s.length();\n@@ -297,15 +297,15 @@\n             throw new IOException(\"Stream has already been finished\");\n         }\n         return (ArchiveEntry)new TarArchiveEntry(path, s, array);\n     }\n     \n     private void writeRecord(final byte[] array) throws IOException {\n         if (array.length != 512) {\n-            throw new IOException(\"Record to write has length '\" + array.length + \"' which is not the record size of '\" + 512 + \"'\");\n+            throw new IOException(\"Record to write has length '\" + array.length + \"' which is not the record size of '512'\");\n         }\n         this.out.write(array);\n         ++this.recordsWritten;\n     }\n     \n     private void padAsNeeded() throws IOException {\n         final int n = this.recordsWritten % this.recordsPerBlock;\n@@ -346,39 +346,39 @@\n         this.failForBigNumber(s, n, n2, \"\");\n     }\n     \n     private void failForBigNumberWithPosixMessage(final String s, final long n, final long n2) {\n         this.failForBigNumber(s, n, n2, \" Use STAR or POSIX extensions to overcome this limit\");\n     }\n     \n-    private void failForBigNumber(final String str, final long lng, final long lng2, final String str2) {\n-        if (lng < 0L || lng > lng2) {\n-            throw new IllegalArgumentException(str + \" '\" + lng + \"' is too big ( > \" + lng2 + \" ).\" + str2);\n+    private void failForBigNumber(final String s, final long n, final long n2, final String s2) {\n+        if (n < 0L || n > n2) {\n+            throw new IllegalArgumentException(s + \" '\" + n + \"' is too big ( > \" + n2 + \" ).\" + s2);\n         }\n     }\n     \n-    private boolean handleLongName(final TarArchiveEntry tarArchiveEntry, final String str, final Map<String, String> map, final String s, final byte b, final String str2) throws IOException {\n-        final ByteBuffer encode = this.zipEncoding.encode(str);\n+    private boolean handleLongName(final TarArchiveEntry tarArchiveEntry, final String s, final Map<String, String> map, final String s2, final byte b, final String s3) throws IOException {\n+        final ByteBuffer encode = this.zipEncoding.encode(s);\n         final int n = encode.limit() - encode.position();\n         if (n >= 100) {\n             if (this.longFileMode == 3) {\n-                map.put(s, str);\n+                map.put(s2, s);\n                 return true;\n             }\n             if (this.longFileMode == 2) {\n                 final TarArchiveEntry tarArchiveEntry2 = new TarArchiveEntry(\"././@LongLink\", b);\n                 tarArchiveEntry2.setSize((long)n + 1L);\n                 this.transferModTime(tarArchiveEntry, tarArchiveEntry2);\n                 this.putArchiveEntry((ArchiveEntry)tarArchiveEntry2);\n                 this.write(encode.array(), encode.arrayOffset(), n);\n                 this.write(0);\n                 this.closeArchiveEntry();\n             }\n             else if (this.longFileMode != 1) {\n-                throw new IllegalArgumentException(str2 + \" '\" + str + \"' is too long ( > \" + 100 + \" bytes)\");\n+                throw new IllegalArgumentException(s3 + \" '\" + s + \"' is too long ( > 100 bytes)\");\n             }\n         }\n         return false;\n     }\n     \n     private void transferModTime(final TarArchiveEntry tarArchiveEntry, final TarArchiveEntry tarArchiveEntry2) {\n         Date modTime = tarArchiveEntry.getModTime();\n"}]}
