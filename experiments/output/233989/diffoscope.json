{"diffoscope-json-version": 1, "source1": "first/CSVParser.class", "source2": "second/CSVParser.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -30,74 +30,73 @@\n     private final Lexer lexer;\n     private final CSVParser.CSVRecordIterator csvRecordIterator;\n     private final List<String> recordList;\n     private long recordNumber;\n     private final long characterOffset;\n     private final Token reusableToken;\n     \n-    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n+    public static CSVParser parse(final File file, final Charset cs, final CSVFormat csvFormat) throws IOException {\n         Assertions.notNull((Object)file, \"file\");\n-        Assertions.notNull((Object)format, \"format\");\n-        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n+        Assertions.notNull((Object)csvFormat, \"format\");\n+        return new CSVParser(new InputStreamReader(new FileInputStream(file), cs), csvFormat);\n     }\n     \n-    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format) throws IOException {\n-        Assertions.notNull((Object)inputStream, \"inputStream\");\n-        Assertions.notNull((Object)format, \"format\");\n-        return parse(new InputStreamReader(inputStream, charset), format);\n+    public static CSVParser parse(final InputStream in, final Charset cs, final CSVFormat csvFormat) throws IOException {\n+        Assertions.notNull((Object)in, \"inputStream\");\n+        Assertions.notNull((Object)csvFormat, \"format\");\n+        return parse(new InputStreamReader(in, cs), csvFormat);\n     }\n     \n-    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n+    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat csvFormat) throws IOException {\n         Assertions.notNull((Object)path, \"path\");\n-        Assertions.notNull((Object)format, \"format\");\n-        return parse(Files.newInputStream(path, new OpenOption[0]), charset, format);\n+        Assertions.notNull((Object)csvFormat, \"format\");\n+        return parse(Files.newInputStream(path, new OpenOption[0]), charset, csvFormat);\n     }\n     \n-    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n-        return new CSVParser(reader, format);\n+    public static CSVParser parse(final Reader reader, final CSVFormat csvFormat) throws IOException {\n+        return new CSVParser(reader, csvFormat);\n     }\n     \n-    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n-        Assertions.notNull((Object)string, \"string\");\n-        Assertions.notNull((Object)format, \"format\");\n-        return new CSVParser(new StringReader(string), format);\n+    public static CSVParser parse(final String s, final CSVFormat csvFormat) throws IOException {\n+        Assertions.notNull((Object)s, \"string\");\n+        Assertions.notNull((Object)csvFormat, \"format\");\n+        return new CSVParser(new StringReader(s), csvFormat);\n     }\n     \n-    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n+    public static CSVParser parse(final URL url, final Charset cs, final CSVFormat csvFormat) throws IOException {\n         Assertions.notNull((Object)url, \"url\");\n-        Assertions.notNull((Object)charset, \"charset\");\n-        Assertions.notNull((Object)format, \"format\");\n-        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n+        Assertions.notNull((Object)cs, \"charset\");\n+        Assertions.notNull((Object)csvFormat, \"format\");\n+        return new CSVParser(new InputStreamReader(url.openStream(), cs), csvFormat);\n     }\n     \n-    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n-        this(reader, format, 0L, 1L);\n+    public CSVParser(final Reader reader, final CSVFormat csvFormat) throws IOException {\n+        this(reader, csvFormat, 0L, 1L);\n     }\n     \n-    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber) throws IOException {\n+    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long n) throws IOException {\n         this.recordList = new ArrayList<String>();\n         this.reusableToken = new Token();\n         Assertions.notNull((Object)reader, \"reader\");\n         Assertions.notNull((Object)format, \"format\");\n         this.format = format;\n         this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n         this.csvRecordIterator = new CSVParser.CSVRecordIterator(this);\n         this.headerMap = this.initializeHeader();\n         this.characterOffset = characterOffset;\n-        this.recordNumber = recordNumber - 1L;\n+        this.recordNumber = n - 1L;\n     }\n     \n-    private void addRecordValue(final boolean lastRecord) {\n-        final String input = this.reusableToken.content.toString();\n-        final String inputClean = this.format.getTrim() ? input.trim() : input;\n-        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {\n+    private void addRecordValue(final boolean b) {\n+        final String string = this.reusableToken.content.toString();\n+        final String s = this.format.getTrim() ? string.trim() : string;\n+        if (b && s.isEmpty() && this.format.getTrailingDelimiter()) {\n             return;\n         }\n-        final String nullString = this.format.getNullString();\n-        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);\n+        this.recordList.add(s.equals(this.format.getNullString()) ? null : s);\n     }\n     \n     @Override\n     public void close() throws IOException {\n         if (this.lexer != null) {\n             this.lexer.close();\n         }\n@@ -116,69 +115,69 @@\n     }\n     \n     public long getRecordNumber() {\n         return this.recordNumber;\n     }\n     \n     public List<CSVRecord> getRecords() throws IOException {\n-        final List<CSVRecord> records = new ArrayList<CSVRecord>();\n-        CSVRecord rec;\n-        while ((rec = this.nextRecord()) != null) {\n-            records.add(rec);\n+        final ArrayList list = new ArrayList();\n+        CSVRecord nextRecord;\n+        while ((nextRecord = this.nextRecord()) != null) {\n+            list.add(nextRecord);\n         }\n-        return records;\n+        return list;\n     }\n     \n     private Map<String, Integer> initializeHeader() throws IOException {\n-        Map<String, Integer> hdrMap = null;\n-        final String[] formatHeader = this.format.getHeader();\n-        if (formatHeader != null) {\n-            hdrMap = (Map<String, Integer>)(this.format.getIgnoreHeaderCase() ? new TreeMap<Object, Object>(String.CASE_INSENSITIVE_ORDER) : new LinkedHashMap<Object, Object>());\n-            String[] headerRecord = null;\n-            if (formatHeader.length == 0) {\n+        Object o = null;\n+        final String[] header = this.format.getHeader();\n+        if (header != null) {\n+            o = (this.format.getIgnoreHeaderCase() ? new TreeMap<Object, Object>(String.CASE_INSENSITIVE_ORDER) : new LinkedHashMap<Object, Object>());\n+            Object[] values = null;\n+            if (header.length == 0) {\n                 final CSVRecord nextRecord = this.nextRecord();\n                 if (nextRecord != null) {\n-                    headerRecord = nextRecord.values();\n+                    values = nextRecord.values();\n                 }\n             }\n             else {\n                 if (this.format.getSkipHeaderRecord()) {\n                     this.nextRecord();\n                 }\n-                headerRecord = formatHeader;\n+                values = header;\n             }\n-            if (headerRecord != null) {\n-                for (int i = 0; i < headerRecord.length; ++i) {\n-                    final String header = headerRecord[i];\n-                    final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n-                    if (containsHeader && (!emptyHeader || !this.format.getAllowMissingColumnNames())) {\n-                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header + \"\\\" in \" + Arrays.toString((Object[])headerRecord));\n+            if (values != null) {\n+                for (int i = 0; i < values.length; ++i) {\n+                    final Object str = values[i];\n+                    final boolean containsKey = ((Map)o).containsKey(str);\n+                    final boolean b = str == null || ((String)str).trim().isEmpty();\n+                    if (containsKey && (!b || !this.format.getAllowMissingColumnNames())) {\n+                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + (String)str + \"\\\" in \" + Arrays.toString(values));\n                     }\n-                    hdrMap.put(header, Integer.valueOf(i));\n+                    ((Map)o).put(str, Integer.valueOf(i));\n                 }\n             }\n         }\n-        return hdrMap;\n+        return (Map<String, Integer>)o;\n     }\n     \n     public boolean isClosed() {\n         return this.lexer.isClosed();\n     }\n     \n     @Override\n     public Iterator<CSVRecord> iterator() {\n         return (Iterator<CSVRecord>)this.csvRecordIterator;\n     }\n     \n     CSVRecord nextRecord() throws IOException {\n-        CSVRecord result = null;\n+        CSVRecord csvRecord = null;\n         this.recordList.clear();\n         StringBuilder sb = null;\n-        final long startCharPosition = this.lexer.getCharacterPosition() + this.characterOffset;\n+        final long n = this.lexer.getCharacterPosition() + this.characterOffset;\n         do {\n             this.reusableToken.reset();\n             this.lexer.nextToken(this.reusableToken);\n             switch (CSVParser.CSVParser$1.$SwitchMap$org$apache$commons$csv$Token$Type[this.reusableToken.type.ordinal()]) {\n                 case 1: {\n                     this.addRecordValue(false);\n                     continue;\n@@ -211,13 +210,12 @@\n                 default: {\n                     throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n                 }\n             }\n         } while (this.reusableToken.type == Token.Type.TOKEN);\n         if (!this.recordList.isEmpty()) {\n             ++this.recordNumber;\n-            final String comment = (sb == null) ? null : sb.toString();\n-            result = new CSVRecord((String[])this.recordList.toArray(new String[this.recordList.size()]), (Map)this.headerMap, comment, this.recordNumber, startCharPosition);\n+            csvRecord = new CSVRecord((String[])this.recordList.toArray(new String[this.recordList.size()]), (Map)this.headerMap, (sb == null) ? null : sb.toString(), this.recordNumber, n);\n         }\n-        return result;\n+        return csvRecord;\n     }\n }\n"}]}
