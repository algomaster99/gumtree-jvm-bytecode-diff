{"diffoscope-json-version": 1, "source1": "first/ExtendedMessageFormat.class", "source2": "second/ExtendedMessageFormat.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,17 +1,17 @@\n \n package org.apache.commons.lang3.text;\n \n import java.util.Objects;\n import org.apache.commons.lang3.ObjectUtils;\n import java.util.Iterator;\n+import java.text.Format;\n import java.util.Collection;\n import org.apache.commons.lang3.Validate;\n import java.text.ParsePosition;\n-import java.text.Format;\n import java.util.ArrayList;\n import org.apache.commons.lang3.LocaleUtils;\n import java.util.Locale;\n import java.util.Map;\n import java.text.MessageFormat;\n \n @Deprecated\n@@ -23,118 +23,117 @@\n     private static final char START_FMT = ',';\n     private static final char END_FE = '}';\n     private static final char START_FE = '{';\n     private static final char QUOTE = '\\'';\n     private String toPattern;\n     private final Map<String, ? extends FormatFactory> registry;\n     \n-    public ExtendedMessageFormat(final String pattern) {\n-        this(pattern, Locale.getDefault());\n+    public ExtendedMessageFormat(final String s) {\n+        this(s, Locale.getDefault());\n     }\n     \n-    public ExtendedMessageFormat(final String pattern, final Locale locale) {\n-        this(pattern, locale, null);\n+    public ExtendedMessageFormat(final String s, final Locale locale) {\n+        this(s, locale, null);\n     }\n     \n-    public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry) {\n-        this(pattern, Locale.getDefault(), registry);\n+    public ExtendedMessageFormat(final String s, final Map<String, ? extends FormatFactory> map) {\n+        this(s, Locale.getDefault(), map);\n     }\n     \n-    public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry) {\n+    public ExtendedMessageFormat(final String s, final Locale locale, final Map<String, ? extends FormatFactory> registry) {\n         super(\"\");\n         this.setLocale(LocaleUtils.toLocale(locale));\n         this.registry = registry;\n-        this.applyPattern(pattern);\n+        this.applyPattern(s);\n     }\n     \n     @Override\n     public String toPattern() {\n         return this.toPattern;\n     }\n     \n     @Override\n     public final void applyPattern(final String pattern) {\n         if (this.registry == null) {\n             super.applyPattern(pattern);\n             this.toPattern = super.toPattern();\n             return;\n         }\n-        final ArrayList<Format> foundFormats = new ArrayList<Format>();\n-        final ArrayList<String> foundDescriptions = new ArrayList<String>();\n-        final StringBuilder stripCustom = new StringBuilder(pattern.length());\n-        final ParsePosition pos = new ParsePosition(0);\n-        final char[] c = pattern.toCharArray();\n-        int fmtCount = 0;\n-        while (pos.getIndex() < pattern.length()) {\n-            switch (c[pos.getIndex()]) {\n+        final ArrayList list = new ArrayList();\n+        final ArrayList list2 = new ArrayList();\n+        final StringBuilder sb = new StringBuilder(pattern.length());\n+        final ParsePosition parsePosition = new ParsePosition(0);\n+        final char[] charArray = pattern.toCharArray();\n+        int n = 0;\n+        while (parsePosition.getIndex() < pattern.length()) {\n+            switch (charArray[parsePosition.getIndex()]) {\n                 case '\\'': {\n-                    this.appendQuotedString(pattern, pos, stripCustom);\n+                    this.appendQuotedString(pattern, parsePosition, sb);\n                     continue;\n                 }\n                 case '{': {\n-                    ++fmtCount;\n-                    this.seekNonWs(pattern, pos);\n-                    final int start = pos.getIndex();\n-                    final int index = this.readArgumentIndex(pattern, this.next(pos));\n-                    stripCustom.append('{').append(index);\n-                    this.seekNonWs(pattern, pos);\n+                    ++n;\n+                    this.seekNonWs(pattern, parsePosition);\n+                    final int index = parsePosition.getIndex();\n+                    sb.append('{').append(this.readArgumentIndex(pattern, this.next(parsePosition)));\n+                    this.seekNonWs(pattern, parsePosition);\n                     Format format = null;\n                     String formatDescription = null;\n-                    if (c[pos.getIndex()] == ',') {\n-                        formatDescription = this.parseFormatDescription(pattern, this.next(pos));\n+                    if (charArray[parsePosition.getIndex()] == ',') {\n+                        formatDescription = this.parseFormatDescription(pattern, this.next(parsePosition));\n                         format = this.getFormat(formatDescription);\n                         if (format == null) {\n-                            stripCustom.append(',').append(formatDescription);\n+                            sb.append(',').append(formatDescription);\n                         }\n                     }\n-                    foundFormats.add(format);\n-                    foundDescriptions.add((format == null) ? null : formatDescription);\n-                    Validate.isTrue(foundFormats.size() == fmtCount);\n-                    Validate.isTrue(foundDescriptions.size() == fmtCount);\n-                    if (c[pos.getIndex()] != '}') {\n-                        throw new IllegalArgumentException(\"Unreadable format element at position \" + start);\n+                    list.add(format);\n+                    list2.add((format == null) ? null : formatDescription);\n+                    Validate.isTrue(list.size() == n);\n+                    Validate.isTrue(list2.size() == n);\n+                    if (charArray[parsePosition.getIndex()] != '}') {\n+                        throw new IllegalArgumentException(\"Unreadable format element at position \" + index);\n                     }\n                     break;\n                 }\n             }\n-            stripCustom.append(c[pos.getIndex()]);\n-            this.next(pos);\n+            sb.append(charArray[parsePosition.getIndex()]);\n+            this.next(parsePosition);\n         }\n-        super.applyPattern(stripCustom.toString());\n-        this.toPattern = this.insertFormats(super.toPattern(), foundDescriptions);\n-        if (this.containsElements(foundFormats)) {\n-            final Format[] origFormats = this.getFormats();\n-            int i = 0;\n-            for (final Format f : foundFormats) {\n-                if (f != null) {\n-                    origFormats[i] = f;\n+        super.applyPattern(sb.toString());\n+        this.toPattern = this.insertFormats(super.toPattern(), list2);\n+        if (this.containsElements(list)) {\n+            final Format[] formats = this.getFormats();\n+            int n2 = 0;\n+            for (final Format format2 : list) {\n+                if (format2 != null) {\n+                    formats[n2] = format2;\n                 }\n-                ++i;\n+                ++n2;\n             }\n-            super.setFormats(origFormats);\n+            super.setFormats(formats);\n         }\n     }\n     \n     @Override\n-    public void setFormat(final int formatElementIndex, final Format newFormat) {\n+    public void setFormat(final int n, final Format format) {\n         throw new UnsupportedOperationException();\n     }\n     \n     @Override\n-    public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat) {\n+    public void setFormatByArgumentIndex(final int n, final Format format) {\n         throw new UnsupportedOperationException();\n     }\n     \n     @Override\n-    public void setFormats(final Format[] newFormats) {\n+    public void setFormats(final Format[] array) {\n         throw new UnsupportedOperationException();\n     }\n     \n     @Override\n-    public void setFormatsByArgumentIndex(final Format[] newFormats) {\n+    public void setFormatsByArgumentIndex(final Format[] array) {\n         throw new UnsupportedOperationException();\n     }\n     \n     @Override\n     public boolean equals(final Object obj) {\n         if (obj == this) {\n             return true;\n@@ -144,185 +143,183 @@\n         }\n         if (!super.equals(obj)) {\n             return false;\n         }\n         if (ObjectUtils.notEqual((Object)this.getClass(), (Object)obj.getClass())) {\n             return false;\n         }\n-        final ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj;\n-        return !ObjectUtils.notEqual((Object)this.toPattern, (Object)rhs.toPattern) && !ObjectUtils.notEqual((Object)this.registry, (Object)rhs.registry);\n+        final ExtendedMessageFormat extendedMessageFormat = (ExtendedMessageFormat)obj;\n+        return !ObjectUtils.notEqual((Object)this.toPattern, (Object)extendedMessageFormat.toPattern) && !ObjectUtils.notEqual((Object)this.registry, (Object)extendedMessageFormat.registry);\n     }\n     \n     @Override\n     public int hashCode() {\n-        int result = super.hashCode();\n-        result = 31 * result + Objects.hashCode(this.registry);\n-        result = 31 * result + Objects.hashCode(this.toPattern);\n-        return result;\n+        return 31 * (31 * super.hashCode() + Objects.hashCode(this.registry)) + Objects.hashCode(this.toPattern);\n     }\n     \n-    private Format getFormat(final String desc) {\n+    private Format getFormat(final String s) {\n         if (this.registry != null) {\n-            String name = desc;\n-            String args = null;\n-            final int i = desc.indexOf(44);\n-            if (i > 0) {\n-                name = desc.substring(0, i).trim();\n-                args = desc.substring(i + 1).trim();\n+            String trim = s;\n+            String trim2 = null;\n+            final int index = s.indexOf(44);\n+            if (index > 0) {\n+                trim = s.substring(0, index).trim();\n+                trim2 = s.substring(index + 1).trim();\n             }\n-            final FormatFactory factory = (FormatFactory)this.registry.get(name);\n-            if (factory != null) {\n-                return factory.getFormat(name, args, this.getLocale());\n+            final FormatFactory formatFactory = (FormatFactory)this.registry.get(trim);\n+            if (formatFactory != null) {\n+                return formatFactory.getFormat(trim, trim2, this.getLocale());\n             }\n         }\n         return null;\n     }\n     \n-    private int readArgumentIndex(final String pattern, final ParsePosition pos) {\n-        final int start = pos.getIndex();\n-        this.seekNonWs(pattern, pos);\n-        final StringBuilder result = new StringBuilder();\n-        boolean error = false;\n-        while (!error && pos.getIndex() < pattern.length()) {\n-            char c = pattern.charAt(pos.getIndex());\n+    private int readArgumentIndex(final String s, final ParsePosition parsePosition) {\n+        final int index = parsePosition.getIndex();\n+        this.seekNonWs(s, parsePosition);\n+        final StringBuilder sb = new StringBuilder();\n+        int n = 0;\n+        while (n == 0 && parsePosition.getIndex() < s.length()) {\n+            char c = s.charAt(parsePosition.getIndex());\n             Label_0149: {\n                 if (Character.isWhitespace(c)) {\n-                    this.seekNonWs(pattern, pos);\n-                    c = pattern.charAt(pos.getIndex());\n+                    this.seekNonWs(s, parsePosition);\n+                    c = s.charAt(parsePosition.getIndex());\n                     if (c != ',' && c != '}') {\n-                        error = true;\n+                        n = 1;\n                         break Label_0149;\n                     }\n                 }\n-                if ((c == ',' || c == '}') && result.length() > 0) {\n+                if ((c == ',' || c == '}') && sb.length() > 0) {\n                     try {\n-                        return Integer.parseInt(result.toString());\n+                        return Integer.parseInt(sb.toString());\n                     }\n                     catch (final NumberFormatException ex) {}\n                 }\n-                error = !Character.isDigit(c);\n-                result.append(c);\n+                n = (Character.isDigit(c) ? 0 : 1);\n+                sb.append(c);\n             }\n-            this.next(pos);\n+            this.next(parsePosition);\n         }\n-        if (error) {\n-            throw new IllegalArgumentException(\"Invalid format argument index at position \" + start + \": \" + pattern.substring(start, pos.getIndex()));\n+        if (n != 0) {\n+            throw new IllegalArgumentException(\"Invalid format argument index at position \" + index + \": \" + s.substring(index, parsePosition.getIndex()));\n         }\n-        throw new IllegalArgumentException(\"Unterminated format element at position \" + start);\n+        throw new IllegalArgumentException(\"Unterminated format element at position \" + index);\n     }\n     \n-    private String parseFormatDescription(final String pattern, final ParsePosition pos) {\n-        final int start = pos.getIndex();\n-        this.seekNonWs(pattern, pos);\n-        final int text = pos.getIndex();\n-        int depth = 1;\n-        while (pos.getIndex() < pattern.length()) {\n-            switch (pattern.charAt(pos.getIndex())) {\n+    private String parseFormatDescription(final String s, final ParsePosition parsePosition) {\n+        final int index = parsePosition.getIndex();\n+        this.seekNonWs(s, parsePosition);\n+        final int index2 = parsePosition.getIndex();\n+        int n = 1;\n+        while (parsePosition.getIndex() < s.length()) {\n+            switch (s.charAt(parsePosition.getIndex())) {\n                 case '{': {\n-                    ++depth;\n+                    ++n;\n                     break;\n                 }\n                 case '}': {\n-                    if (--depth == 0) {\n-                        return pattern.substring(text, pos.getIndex());\n+                    if (--n == 0) {\n+                        return s.substring(index2, parsePosition.getIndex());\n                     }\n                     break;\n                 }\n                 case '\\'': {\n-                    this.getQuotedString(pattern, pos);\n+                    this.getQuotedString(s, parsePosition);\n                     break;\n                 }\n             }\n-            this.next(pos);\n+            this.next(parsePosition);\n         }\n-        throw new IllegalArgumentException(\"Unterminated format element at position \" + start);\n+        throw new IllegalArgumentException(\"Unterminated format element at position \" + index);\n     }\n     \n-    private String insertFormats(final String pattern, final ArrayList<String> customPatterns) {\n-        if (!this.containsElements(customPatterns)) {\n-            return pattern;\n-        }\n-        final StringBuilder sb = new StringBuilder(pattern.length() * 2);\n-        final ParsePosition pos = new ParsePosition(0);\n-        int fe = -1;\n-        int depth = 0;\n-        while (pos.getIndex() < pattern.length()) {\n-            final char c = pattern.charAt(pos.getIndex());\n-            switch (c) {\n-                case '\\'': {\n-                    this.appendQuotedString(pattern, pos, sb);\n+    private String insertFormats(final String s, final ArrayList<String> list) {\n+        if (!this.containsElements(list)) {\n+            return s;\n+        }\n+        final StringBuilder sb = new StringBuilder(s.length() * 2);\n+        final ParsePosition parsePosition = new ParsePosition(0);\n+        int index = -1;\n+        int n = 0;\n+        while (parsePosition.getIndex() < s.length()) {\n+            final char char1 = s.charAt(parsePosition.getIndex());\n+            switch (char1) {\n+                case 39: {\n+                    this.appendQuotedString(s, parsePosition, sb);\n                     continue;\n                 }\n-                case '{': {\n-                    ++depth;\n-                    sb.append('{').append(this.readArgumentIndex(pattern, this.next(pos)));\n-                    if (depth == 1) {\n-                        ++fe;\n-                        final String customPattern = (String)customPatterns.get(fe);\n-                        if (customPattern == null) {\n+                case 123: {\n+                    ++n;\n+                    sb.append('{').append(this.readArgumentIndex(s, this.next(parsePosition)));\n+                    if (n == 1) {\n+                        ++index;\n+                        final String str = (String)list.get(index);\n+                        if (str == null) {\n                             continue;\n                         }\n-                        sb.append(',').append(customPattern);\n+                        sb.append(',').append(str);\n                         continue;\n                     }\n                     continue;\n                 }\n-                case '}': {\n-                    --depth;\n+                case 125: {\n+                    --n;\n                     break;\n                 }\n             }\n-            sb.append(c);\n-            this.next(pos);\n+            sb.append(char1);\n+            this.next(parsePosition);\n         }\n         return sb.toString();\n     }\n     \n-    private void seekNonWs(final String pattern, final ParsePosition pos) {\n-        int len = 0;\n-        final char[] buffer = pattern.toCharArray();\n+    private void seekNonWs(final String s, final ParsePosition parsePosition) {\n+        final char[] charArray = s.toCharArray();\n+        int match;\n         do {\n-            len = StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex());\n-            pos.setIndex(pos.getIndex() + len);\n-        } while (len > 0 && pos.getIndex() < pattern.length());\n-    }\n-    \n-    private ParsePosition next(final ParsePosition pos) {\n-        pos.setIndex(pos.getIndex() + 1);\n-        return pos;\n-    }\n-    \n-    private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo) {\n-        assert pattern.toCharArray()[pos.getIndex()] == '\\'' : \"Quoted string must start with quote character\";\n-        if (appendTo != null) {\n-            appendTo.append('\\'');\n-        }\n-        this.next(pos);\n-        final int start = pos.getIndex();\n-        final char[] c = pattern.toCharArray();\n-        final int lastHold = start;\n-        for (int i = pos.getIndex(); i < pattern.length(); ++i) {\n-            if (c[pos.getIndex()] == '\\'') {\n-                this.next(pos);\n-                return (appendTo == null) ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold);\n+            match = StrMatcher.splitMatcher().isMatch(charArray, parsePosition.getIndex());\n+            parsePosition.setIndex(parsePosition.getIndex() + match);\n+        } while (match > 0 && parsePosition.getIndex() < s.length());\n+    }\n+    \n+    private ParsePosition next(final ParsePosition parsePosition) {\n+        parsePosition.setIndex(parsePosition.getIndex() + 1);\n+        return parsePosition;\n+    }\n+    \n+    private StringBuilder appendQuotedString(final String s, final ParsePosition parsePosition, final StringBuilder sb) {\n+        assert s.toCharArray()[parsePosition.getIndex()] == '\\'' : \"Quoted string must start with quote character\";\n+        if (sb != null) {\n+            sb.append('\\'');\n+        }\n+        this.next(parsePosition);\n+        final int index = parsePosition.getIndex();\n+        final char[] charArray = s.toCharArray();\n+        final int offset = index;\n+        for (int i = parsePosition.getIndex(); i < s.length(); ++i) {\n+            if (charArray[parsePosition.getIndex()] == '\\'') {\n+                this.next(parsePosition);\n+                return (sb == null) ? null : sb.append(charArray, offset, parsePosition.getIndex() - offset);\n             }\n-            this.next(pos);\n+            this.next(parsePosition);\n         }\n-        throw new IllegalArgumentException(\"Unterminated quoted string at position \" + start);\n+        throw new IllegalArgumentException(\"Unterminated quoted string at position \" + index);\n     }\n     \n-    private void getQuotedString(final String pattern, final ParsePosition pos) {\n-        this.appendQuotedString(pattern, pos, null);\n+    private void getQuotedString(final String s, final ParsePosition parsePosition) {\n+        this.appendQuotedString(s, parsePosition, null);\n     }\n     \n-    private boolean containsElements(final Collection<?> coll) {\n-        if (coll == null || coll.isEmpty()) {\n+    private boolean containsElements(final Collection<?> collection) {\n+        if (collection == null || collection.isEmpty()) {\n             return false;\n         }\n-        for (final Object name : coll) {\n-            if (name != null) {\n+        final Iterator iterator = collection.iterator();\n+        while (iterator.hasNext()) {\n+            if (iterator.next() != null) {\n                 return true;\n             }\n         }\n         return false;\n     }\n }\n"}]}
