{"diffoscope-json-version": 1, "source1": "first/Pass2Verifier$FAMRAV_Visitor.class", "source2": "second/Pass2Verifier$FAMRAV_Visitor.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -24,84 +24,75 @@\n         this.cp = jc.getConstantPool();\n     }\n     \n     public void visitConstantFieldref(final ConstantFieldref obj) {\n         if (obj.getTag() != 9) {\n             throw new ClassConstraintException(\"ConstantFieldref '\" + Pass2Verifier.access$000((Node)obj) + \"' has wrong tag!\");\n         }\n-        final int nameAndTypeIndex = obj.getNameAndTypeIndex();\n-        final ConstantNameAndType cnat = (ConstantNameAndType)this.cp.getConstant(nameAndTypeIndex);\n-        final String name = ((ConstantUtf8)this.cp.getConstant(cnat.getNameIndex())).getBytes();\n-        if (!Pass2Verifier.access$400(name)) {\n-            throw new ClassConstraintException(\"Invalid field name '\" + name + \"' referenced by '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n-        }\n-        final int classIndex = obj.getClassIndex();\n-        final ConstantClass cc = (ConstantClass)this.cp.getConstant(classIndex);\n-        final String className = ((ConstantUtf8)this.cp.getConstant(cc.getNameIndex())).getBytes();\n-        if (!Pass2Verifier.access$600(className)) {\n-            throw new ClassConstraintException(\"Illegal class name '\" + className + \"' used by '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n+        final ConstantNameAndType constantNameAndType = (ConstantNameAndType)this.cp.getConstant(obj.getNameAndTypeIndex());\n+        final String bytes = ((ConstantUtf8)this.cp.getConstant(constantNameAndType.getNameIndex())).getBytes();\n+        if (!Pass2Verifier.access$400(bytes)) {\n+            throw new ClassConstraintException(\"Invalid field name '\" + bytes + \"' referenced by '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n+        }\n+        final String bytes2 = ((ConstantUtf8)this.cp.getConstant(((ConstantClass)this.cp.getConstant(obj.getClassIndex())).getNameIndex())).getBytes();\n+        if (!Pass2Verifier.access$600(bytes2)) {\n+            throw new ClassConstraintException(\"Illegal class name '\" + bytes2 + \"' used by '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n         }\n-        final String sig = ((ConstantUtf8)this.cp.getConstant(cnat.getSignatureIndex())).getBytes();\n+        final String bytes3 = ((ConstantUtf8)this.cp.getConstant(constantNameAndType.getSignatureIndex())).getBytes();\n         try {\n-            Type.getType(sig);\n+            Type.getType(bytes3);\n         }\n-        catch (final ClassFormatException cfe) {\n-            throw new ClassConstraintException(\"Illegal descriptor (==signature) '\" + sig + \"' used by '\" + Pass2Verifier.access$000((Node)obj) + \"'.\", (Throwable)cfe);\n+        catch (final ClassFormatException ex) {\n+            throw new ClassConstraintException(\"Illegal descriptor (==signature) '\" + bytes3 + \"' used by '\" + Pass2Verifier.access$000((Node)obj) + \"'.\", (Throwable)ex);\n         }\n     }\n     \n     public void visitConstantInterfaceMethodref(final ConstantInterfaceMethodref obj) {\n         if (obj.getTag() != 11) {\n             throw new ClassConstraintException(\"ConstantInterfaceMethodref '\" + Pass2Verifier.access$000((Node)obj) + \"' has wrong tag!\");\n         }\n-        final int nameAndTypeIndex = obj.getNameAndTypeIndex();\n-        final ConstantNameAndType cnat = (ConstantNameAndType)this.cp.getConstant(nameAndTypeIndex);\n-        final String name = ((ConstantUtf8)this.cp.getConstant(cnat.getNameIndex())).getBytes();\n-        if (!Pass2Verifier.access$700(name)) {\n-            throw new ClassConstraintException(\"Invalid (interface) method name '\" + name + \"' referenced by '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n-        }\n-        final int classIndex = obj.getClassIndex();\n-        final ConstantClass cc = (ConstantClass)this.cp.getConstant(classIndex);\n-        final String className = ((ConstantUtf8)this.cp.getConstant(cc.getNameIndex())).getBytes();\n-        if (!Pass2Verifier.access$600(className)) {\n-            throw new ClassConstraintException(\"Illegal class name '\" + className + \"' used by '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n+        final ConstantNameAndType constantNameAndType = (ConstantNameAndType)this.cp.getConstant(obj.getNameAndTypeIndex());\n+        final String bytes = ((ConstantUtf8)this.cp.getConstant(constantNameAndType.getNameIndex())).getBytes();\n+        if (!Pass2Verifier.access$700(bytes)) {\n+            throw new ClassConstraintException(\"Invalid (interface) method name '\" + bytes + \"' referenced by '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n+        }\n+        final String bytes2 = ((ConstantUtf8)this.cp.getConstant(((ConstantClass)this.cp.getConstant(obj.getClassIndex())).getNameIndex())).getBytes();\n+        if (!Pass2Verifier.access$600(bytes2)) {\n+            throw new ClassConstraintException(\"Illegal class name '\" + bytes2 + \"' used by '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n         }\n-        final String sig = ((ConstantUtf8)this.cp.getConstant(cnat.getSignatureIndex())).getBytes();\n+        final String bytes3 = ((ConstantUtf8)this.cp.getConstant(constantNameAndType.getSignatureIndex())).getBytes();\n         try {\n-            final Type t = Type.getReturnType(sig);\n-            if (name.equals(\"<clinit>\") && t != Type.VOID) {\n-                this.this$0.addMessage(\"Class or interface initialization method '<clinit>' usually has VOID return type instead of '\" + t + \"'. Note this is really not a requirement of The Java Virtual Machine Specification, Second Edition.\");\n+            final Type returnType = Type.getReturnType(bytes3);\n+            if (bytes.equals(\"<clinit>\") && returnType != Type.VOID) {\n+                this.this$0.addMessage(\"Class or interface initialization method '<clinit>' usually has VOID return type instead of '\" + returnType + \"'. Note this is really not a requirement of The Java Virtual Machine Specification, Second Edition.\");\n             }\n         }\n-        catch (final ClassFormatException cfe) {\n-            throw new ClassConstraintException(\"Illegal descriptor (==signature) '\" + sig + \"' used by '\" + Pass2Verifier.access$000((Node)obj) + \"'.\", (Throwable)cfe);\n+        catch (final ClassFormatException ex) {\n+            throw new ClassConstraintException(\"Illegal descriptor (==signature) '\" + bytes3 + \"' used by '\" + Pass2Verifier.access$000((Node)obj) + \"'.\", (Throwable)ex);\n         }\n     }\n     \n     public void visitConstantMethodref(final ConstantMethodref obj) {\n         if (obj.getTag() != 10) {\n             throw new ClassConstraintException(\"ConstantMethodref '\" + Pass2Verifier.access$000((Node)obj) + \"' has wrong tag!\");\n         }\n-        final int nameAndTypeIndex = obj.getNameAndTypeIndex();\n-        final ConstantNameAndType cnat = (ConstantNameAndType)this.cp.getConstant(nameAndTypeIndex);\n-        final String name = ((ConstantUtf8)this.cp.getConstant(cnat.getNameIndex())).getBytes();\n-        if (!Pass2Verifier.access$800(name)) {\n-            throw new ClassConstraintException(\"Invalid (non-interface) method name '\" + name + \"' referenced by '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n-        }\n-        final int classIndex = obj.getClassIndex();\n-        final ConstantClass cc = (ConstantClass)this.cp.getConstant(classIndex);\n-        final String className = ((ConstantUtf8)this.cp.getConstant(cc.getNameIndex())).getBytes();\n-        if (!Pass2Verifier.access$600(className)) {\n-            throw new ClassConstraintException(\"Illegal class name '\" + className + \"' used by '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n+        final ConstantNameAndType constantNameAndType = (ConstantNameAndType)this.cp.getConstant(obj.getNameAndTypeIndex());\n+        final String bytes = ((ConstantUtf8)this.cp.getConstant(constantNameAndType.getNameIndex())).getBytes();\n+        if (!Pass2Verifier.access$800(bytes)) {\n+            throw new ClassConstraintException(\"Invalid (non-interface) method name '\" + bytes + \"' referenced by '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n+        }\n+        final String bytes2 = ((ConstantUtf8)this.cp.getConstant(((ConstantClass)this.cp.getConstant(obj.getClassIndex())).getNameIndex())).getBytes();\n+        if (!Pass2Verifier.access$600(bytes2)) {\n+            throw new ClassConstraintException(\"Illegal class name '\" + bytes2 + \"' used by '\" + Pass2Verifier.access$000((Node)obj) + \"'.\");\n         }\n-        final String sig = ((ConstantUtf8)this.cp.getConstant(cnat.getSignatureIndex())).getBytes();\n+        final String bytes3 = ((ConstantUtf8)this.cp.getConstant(constantNameAndType.getSignatureIndex())).getBytes();\n         try {\n-            final Type t = Type.getReturnType(sig);\n-            if (name.equals(\"<init>\") && t != Type.VOID) {\n+            final Type returnType = Type.getReturnType(bytes3);\n+            if (bytes.equals(\"<init>\") && returnType != Type.VOID) {\n                 throw new ClassConstraintException(\"Instance initialization method must have VOID return type.\");\n             }\n         }\n-        catch (final ClassFormatException cfe) {\n-            throw new ClassConstraintException(\"Illegal descriptor (==signature) '\" + sig + \"' used by '\" + Pass2Verifier.access$000((Node)obj) + \"'.\", (Throwable)cfe);\n+        catch (final ClassFormatException ex) {\n+            throw new ClassConstraintException(\"Illegal descriptor (==signature) '\" + bytes3 + \"' used by '\" + Pass2Verifier.access$000((Node)obj) + \"'.\", (Throwable)ex);\n         }\n     }\n }\n"}]}
