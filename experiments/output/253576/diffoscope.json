{"diffoscope-json-version": 1, "source1": "first/RegexpHeaderCheck.class", "source2": "second/RegexpHeaderCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -24,83 +24,82 @@\n     private BitSet multiLines;\n     \n     public RegexpHeaderCheck() {\n         this.headerRegexps = new ArrayList<Pattern>();\n         this.multiLines = new BitSet();\n     }\n     \n-    public void setMultiLines(final int... list) {\n-        this.multiLines = TokenUtil.asBitSet(list);\n+    public void setMultiLines(final int... array) {\n+        this.multiLines = TokenUtil.asBitSet(array);\n     }\n     \n     protected void processFiltered(final File file, final FileText fileText) {\n-        final int headerSize = this.getHeaderLines().size();\n-        final int fileSize = fileText.size();\n-        if (headerSize - this.multiLines.cardinality() > fileSize) {\n+        final int size = this.getHeaderLines().size();\n+        final int size2 = fileText.size();\n+        if (size - this.multiLines.cardinality() > size2) {\n             this.log(1, \"header.missing\", new Object[0]);\n         }\n         else {\n-            int headerLineNo;\n-            int index;\n-            for (headerLineNo = 0, index = 0; headerLineNo < headerSize && index < fileSize; ++index) {\n-                String line;\n-                boolean isMatch;\n-                for (line = fileText.get(index), isMatch = this.isMatch(line, headerLineNo); !isMatch && this.isMultiLine(headerLineNo); isMatch = (++headerLineNo == headerSize || this.isMatch(line, headerLineNo))) {}\n-                if (!isMatch) {\n-                    this.log(index + 1, \"header.mismatch\", new Object[] { this.getHeaderLine(headerLineNo) });\n+            int n;\n+            int n2;\n+            for (n = 0, n2 = 0; n < size && n2 < size2; ++n2) {\n+                String value;\n+                boolean match;\n+                for (value = fileText.get(n2), match = this.isMatch(value, n); !match && this.isMultiLine(n); match = (++n == size || this.isMatch(value, n))) {}\n+                if (!match) {\n+                    this.log(n2 + 1, \"header.mismatch\", new Object[] { this.getHeaderLine(n) });\n                     break;\n                 }\n-                if (!this.isMultiLine(headerLineNo)) {\n-                    ++headerLineNo;\n+                if (!this.isMultiLine(n)) {\n+                    ++n;\n                 }\n             }\n-            if (index == fileSize) {\n-                this.logFirstSinglelineLine(headerLineNo, headerSize);\n+            if (n2 == size2) {\n+                this.logFirstSinglelineLine(n, size);\n             }\n         }\n     }\n     \n-    private String getHeaderLine(final int headerLineNo) {\n-        String line = (String)this.getHeaderLines().get(headerLineNo);\n-        if (line.isEmpty()) {\n-            line = \"^$\";\n+    private String getHeaderLine(final int n) {\n+        String s = (String)this.getHeaderLines().get(n);\n+        if (s.isEmpty()) {\n+            s = \"^$\";\n         }\n-        return line;\n+        return s;\n     }\n     \n-    private void logFirstSinglelineLine(final int startHeaderLine, final int headerSize) {\n-        for (int lineNum = startHeaderLine; lineNum < headerSize; ++lineNum) {\n-            if (!this.isMultiLine(lineNum)) {\n+    private void logFirstSinglelineLine(final int n, final int n2) {\n+        for (int i = n; i < n2; ++i) {\n+            if (!this.isMultiLine(i)) {\n                 this.log(1, \"header.missing\", new Object[0]);\n                 break;\n             }\n         }\n     }\n     \n-    private boolean isMatch(final String line, final int headerLineNo) {\n-        return ((Pattern)this.headerRegexps.get(headerLineNo)).matcher(line).find();\n+    private boolean isMatch(final String input, final int n) {\n+        return ((Pattern)this.headerRegexps.get(n)).matcher(input).find();\n     }\n     \n-    private boolean isMultiLine(final int lineNo) {\n-        return this.multiLines.get(lineNo + 1);\n+    private boolean isMultiLine(final int n) {\n+        return this.multiLines.get(n + 1);\n     }\n     \n     protected void postProcessHeaderLines() {\n-        final List<String> headerLines = this.getHeaderLines();\n-        for (final String line : headerLines) {\n+        for (final String regex : this.getHeaderLines()) {\n             try {\n-                if (line.isEmpty()) {\n+                if (regex.isEmpty()) {\n                     this.headerRegexps.add(RegexpHeaderCheck.BLANK_LINE);\n                 }\n                 else {\n-                    this.headerRegexps.add(Pattern.compile(line));\n+                    this.headerRegexps.add(Pattern.compile(regex));\n                 }\n             }\n-            catch (final PatternSyntaxException ex) {\n-                throw new IllegalArgumentException(\"line \" + (this.headerRegexps.size() + 1) + \" in header specification is not a regular expression\", (Throwable)ex);\n+            catch (final PatternSyntaxException cause) {\n+                throw new IllegalArgumentException(\"line \" + (this.headerRegexps.size() + 1) + \" in header specification is not a regular expression\", (Throwable)cause);\n             }\n         }\n     }\n     \n     public void setHeader(final String header) {\n         if (!CommonUtil.isBlank(header)) {\n             if (!CommonUtil.isPatternValid(header)) {\n"}]}
