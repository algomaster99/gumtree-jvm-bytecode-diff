{"diffoscope-json-version": 1, "source1": "first/ConfigurationNodeIteratorChildren.class", "source2": "second/ConfigurationNodeIteratorChildren.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -12,82 +12,82 @@\n import org.apache.commons.jxpath.ri.compiler.NodeTest;\n import java.util.List;\n \n class ConfigurationNodeIteratorChildren<T> extends ConfigurationNodeIteratorBase<T>\n {\n     private final List<T> subNodes;\n     \n-    public ConfigurationNodeIteratorChildren(final ConfigurationNodePointer<T> parent, final NodeTest nodeTest, final boolean reverse, final ConfigurationNodePointer<T> startsWith) {\n-        super((ConfigurationNodePointer)parent, reverse);\n-        final T root = (T)parent.getConfigurationNode();\n-        this.subNodes = this.createSubNodeList(root, nodeTest);\n-        if (startsWith != null) {\n-            this.setStartOffset(this.findStartIndex((List<Object>)this.subNodes, startsWith.getConfigurationNode()));\n+    public ConfigurationNodeIteratorChildren(final ConfigurationNodePointer<T> configurationNodePointer, final NodeTest nodeTest, final boolean b, final ConfigurationNodePointer<T> configurationNodePointer2) {\n+        super((ConfigurationNodePointer)configurationNodePointer, b);\n+        this.subNodes = (List<T>)this.createSubNodeList(configurationNodePointer.getConfigurationNode(), nodeTest);\n+        if (configurationNodePointer2 != null) {\n+            this.setStartOffset(this.findStartIndex((List<Object>)this.subNodes, configurationNodePointer2.getConfigurationNode()));\n         }\n-        else if (reverse) {\n+        else if (b) {\n             this.setStartOffset(this.size());\n         }\n     }\n     \n-    protected NodePointer createNodePointer(final int position) {\n-        return (NodePointer)new ConfigurationNodePointer(this.getParent(), (Object)this.subNodes.get(position), this.getNodeHandler());\n+    protected NodePointer createNodePointer(final int n) {\n+        return (NodePointer)new ConfigurationNodePointer(this.getParent(), (Object)this.subNodes.get(n), this.getNodeHandler());\n     }\n     \n     protected int size() {\n         return this.subNodes.size();\n     }\n     \n-    private List<T> createSubNodeList(final T node, final NodeTest test) {\n-        if (test == null) {\n-            return this.getNodeHandler().getChildren((Object)node);\n-        }\n-        if (test instanceof NodeNameTest) {\n-            final NodeNameTest nameTest = (NodeNameTest)test;\n-            final QName name = nameTest.getNodeName();\n-            return nameTest.isWildcard() ? this.createSubNodeListForWildcardName(node, name) : this.createSubNodeListForName(node, name);\n-        }\n-        if (test instanceof NodeTypeTest) {\n-            final NodeTypeTest typeTest = (NodeTypeTest)test;\n-            if (typeTest.getNodeType() == 1 || typeTest.getNodeType() == 2) {\n-                return this.getNodeHandler().getChildren((Object)node);\n+    private List<T> createSubNodeList(final T t, final NodeTest nodeTest) {\n+        if (nodeTest == null) {\n+            return this.getNodeHandler().getChildren((Object)t);\n+        }\n+        if (nodeTest instanceof NodeNameTest) {\n+            final NodeNameTest nodeNameTest = (NodeNameTest)nodeTest;\n+            final QName nodeName = nodeNameTest.getNodeName();\n+            return nodeNameTest.isWildcard() ? this.createSubNodeListForWildcardName(t, nodeName) : this.createSubNodeListForName(t, nodeName);\n+        }\n+        if (nodeTest instanceof NodeTypeTest) {\n+            final NodeTypeTest nodeTypeTest = (NodeTypeTest)nodeTest;\n+            if (nodeTypeTest.getNodeType() == 1 || nodeTypeTest.getNodeType() == 2) {\n+                return this.getNodeHandler().getChildren((Object)t);\n             }\n         }\n         return Collections.emptyList();\n     }\n     \n-    private List<T> createSubNodeListForName(final T node, final QName name) {\n-        final String compareName = qualifiedName(name);\n-        final List<T> result = new ArrayList<T>();\n-        for (final T child : this.getNodeHandler().getChildren((Object)node)) {\n-            if (StringUtils.equals((CharSequence)compareName, (CharSequence)this.getNodeHandler().nodeName((Object)child))) {\n-                result.add(child);\n+    private List<T> createSubNodeListForName(final T t, final QName qName) {\n+        final String qualifiedName = qualifiedName(qName);\n+        final ArrayList list = new ArrayList();\n+        for (final Object next : this.getNodeHandler().getChildren((Object)t)) {\n+            if (StringUtils.equals((CharSequence)qualifiedName, (CharSequence)this.getNodeHandler().nodeName(next))) {\n+                list.add(next);\n             }\n         }\n-        return result;\n+        return list;\n     }\n     \n-    private List<T> createSubNodeListForWildcardName(final T node, final QName name) {\n-        final List<T> children = this.getNodeHandler().getChildren((Object)node);\n-        if (name.getPrefix() == null) {\n+    private List<T> createSubNodeListForWildcardName(final T t, final QName qName) {\n+        final List children = this.getNodeHandler().getChildren((Object)t);\n+        if (qName.getPrefix() == null) {\n             return children;\n         }\n-        final List<T> prefixChildren = new ArrayList<T>(children.size());\n-        final String prefix = prefixName(name.getPrefix(), (String)null);\n-        for (final T child : children) {\n-            if (StringUtils.startsWith((CharSequence)this.getNodeHandler().nodeName((Object)child), (CharSequence)prefix)) {\n-                prefixChildren.add(child);\n+        final ArrayList list = new ArrayList(children.size());\n+        final String prefixName = prefixName(qName.getPrefix(), (String)null);\n+        for (final Object next : children) {\n+            if (StringUtils.startsWith((CharSequence)this.getNodeHandler().nodeName(next), (CharSequence)prefixName)) {\n+                list.add(next);\n             }\n         }\n-        return prefixChildren;\n+        return (List<T>)list;\n     }\n     \n-    private int findStartIndex(final List<T> children, final T startNode) {\n-        int index = 0;\n-        for (final T child : children) {\n-            if (child == startNode) {\n-                return index;\n+    private int findStartIndex(final List<T> list, final T t) {\n+        int n = 0;\n+        final Iterator<T> iterator = list.iterator();\n+        while (iterator.hasNext()) {\n+            if (iterator.next() == t) {\n+                return n;\n             }\n-            ++index;\n+            ++n;\n         }\n         return -1;\n     }\n }\n"}]}
