{"diffoscope-json-version": 1, "source1": "first/FileUtils.class", "source2": "second/FileUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -10,16 +10,16 @@\n import java.nio.file.attribute.BasicFileAttributeView;\n import java.nio.file.attribute.BasicFileAttributes;\n import java.io.FileOutputStream;\n import java.io.FileInputStream;\n import java.util.stream.Collector;\n import java.util.stream.Collectors;\n import java.util.function.Function;\n-import java.util.Set;\n import java.nio.file.FileVisitor;\n+import java.util.Set;\n import java.util.Collections;\n import java.util.HashSet;\n import org.apache.commons.io.file.PathFilter;\n import org.apache.commons.io.filefilter.FileEqualsFileFilter;\n import org.apache.commons.io.file.AccumulatorPathVisitor;\n import java.nio.file.FileVisitOption;\n import java.util.function.Consumer;\n@@ -50,16 +50,16 @@\n import java.io.FileNotFoundException;\n import java.io.OutputStream;\n import java.util.List;\n import java.util.ArrayList;\n import java.nio.file.StandardCopyOption;\n import java.nio.file.CopyOption;\n import java.util.Collection;\n-import java.io.Reader;\n import java.nio.charset.Charset;\n+import java.io.Reader;\n import java.io.InputStreamReader;\n import org.apache.commons.io.function.IOConsumer;\n import java.io.FileFilter;\n import java.util.zip.CRC32;\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.zip.CheckedInputStream;\n@@ -84,326 +84,345 @@\n     public static final BigInteger ONE_PB_BI;\n     public static final long ONE_EB = 1152921504606846976L;\n     public static final BigInteger ONE_EB_BI;\n     public static final BigInteger ONE_ZB;\n     public static final BigInteger ONE_YB;\n     public static final File[] EMPTY_FILE_ARRAY;\n     \n-    public static String byteCountToDisplaySize(final BigInteger size) {\n-        Objects.requireNonNull(size, \"size\");\n-        String displaySize;\n-        if (size.divide(FileUtils.ONE_EB_BI).compareTo(BigInteger.ZERO) > 0) {\n-            displaySize = size.divide(FileUtils.ONE_EB_BI) + \" EB\";\n-        }\n-        else if (size.divide(FileUtils.ONE_PB_BI).compareTo(BigInteger.ZERO) > 0) {\n-            displaySize = size.divide(FileUtils.ONE_PB_BI) + \" PB\";\n-        }\n-        else if (size.divide(FileUtils.ONE_TB_BI).compareTo(BigInteger.ZERO) > 0) {\n-            displaySize = size.divide(FileUtils.ONE_TB_BI) + \" TB\";\n+    public static String byteCountToDisplaySize(final BigInteger bigInteger) {\n+        Objects.requireNonNull(bigInteger, \"size\");\n+        String s;\n+        if (bigInteger.divide(FileUtils.ONE_EB_BI).compareTo(BigInteger.ZERO) > 0) {\n+            s = bigInteger.divide(FileUtils.ONE_EB_BI) + \" EB\";\n+        }\n+        else if (bigInteger.divide(FileUtils.ONE_PB_BI).compareTo(BigInteger.ZERO) > 0) {\n+            s = bigInteger.divide(FileUtils.ONE_PB_BI) + \" PB\";\n+        }\n+        else if (bigInteger.divide(FileUtils.ONE_TB_BI).compareTo(BigInteger.ZERO) > 0) {\n+            s = bigInteger.divide(FileUtils.ONE_TB_BI) + \" TB\";\n         }\n-        else if (size.divide(FileUtils.ONE_GB_BI).compareTo(BigInteger.ZERO) > 0) {\n-            displaySize = size.divide(FileUtils.ONE_GB_BI) + \" GB\";\n+        else if (bigInteger.divide(FileUtils.ONE_GB_BI).compareTo(BigInteger.ZERO) > 0) {\n+            s = bigInteger.divide(FileUtils.ONE_GB_BI) + \" GB\";\n         }\n-        else if (size.divide(FileUtils.ONE_MB_BI).compareTo(BigInteger.ZERO) > 0) {\n-            displaySize = size.divide(FileUtils.ONE_MB_BI) + \" MB\";\n+        else if (bigInteger.divide(FileUtils.ONE_MB_BI).compareTo(BigInteger.ZERO) > 0) {\n+            s = bigInteger.divide(FileUtils.ONE_MB_BI) + \" MB\";\n         }\n-        else if (size.divide(FileUtils.ONE_KB_BI).compareTo(BigInteger.ZERO) > 0) {\n-            displaySize = size.divide(FileUtils.ONE_KB_BI) + \" KB\";\n+        else if (bigInteger.divide(FileUtils.ONE_KB_BI).compareTo(BigInteger.ZERO) > 0) {\n+            s = bigInteger.divide(FileUtils.ONE_KB_BI) + \" KB\";\n         }\n         else {\n-            displaySize = size + \" bytes\";\n+            s = bigInteger + \" bytes\";\n         }\n-        return displaySize;\n+        return s;\n     }\n     \n-    public static String byteCountToDisplaySize(final long size) {\n-        return byteCountToDisplaySize(BigInteger.valueOf(size));\n+    public static String byteCountToDisplaySize(final long val) {\n+        return byteCountToDisplaySize(BigInteger.valueOf(val));\n     }\n     \n-    public static String byteCountToDisplaySize(final Number size) {\n-        return byteCountToDisplaySize(size.longValue());\n+    public static String byteCountToDisplaySize(final Number n) {\n+        return byteCountToDisplaySize(n.longValue());\n     }\n     \n     public static Checksum checksum(final File file, final Checksum checksum) throws IOException {\n         requireExistsChecked(file, \"file\");\n         requireFile(file, \"file\");\n         Objects.requireNonNull(checksum, \"checksum\");\n-        try (final InputStream inputStream = new CheckedInputStream(Files.newInputStream(file.toPath(), new OpenOption[0]), checksum)) {\n-            IOUtils.consume(inputStream);\n+        try (final CheckedInputStream checkedInputStream = new CheckedInputStream(Files.newInputStream(file.toPath(), new OpenOption[0]), checksum)) {\n+            IOUtils.consume((InputStream)checkedInputStream);\n         }\n         return checksum;\n     }\n     \n     public static long checksumCRC32(final File file) throws IOException {\n         return checksum(file, new CRC32()).getValue();\n     }\n     \n-    public static void cleanDirectory(final File directory) throws IOException {\n-        IOConsumer.forAll(FileUtils::forceDelete, (Object[])listFiles(directory, null));\n+    public static void cleanDirectory(final File file) throws IOException {\n+        IOConsumer.forAll(FileUtils::forceDelete, (Object[])listFiles(file, null));\n     }\n     \n-    private static void cleanDirectoryOnExit(final File directory) throws IOException {\n-        IOConsumer.forAll(FileUtils::forceDeleteOnExit, (Object[])listFiles(directory, null));\n+    private static void cleanDirectoryOnExit(final File file) throws IOException {\n+        IOConsumer.forAll(FileUtils::forceDeleteOnExit, (Object[])listFiles(file, null));\n     }\n     \n-    public static boolean contentEquals(final File file1, final File file2) throws IOException {\n-        if (file1 == null && file2 == null) {\n+    public static boolean contentEquals(final File file, final File file2) throws IOException {\n+        if (file == null && file2 == null) {\n             return true;\n         }\n-        if (file1 == null || file2 == null) {\n+        if (file == null || file2 == null) {\n             return false;\n         }\n-        final boolean file1Exists = file1.exists();\n-        if (file1Exists != file2.exists()) {\n+        final boolean exists = file.exists();\n+        if (exists != file2.exists()) {\n             return false;\n         }\n-        if (!file1Exists) {\n+        if (!exists) {\n             return true;\n         }\n-        requireFile(file1, \"file1\");\n+        requireFile(file, \"file1\");\n         requireFile(file2, \"file2\");\n-        if (file1.length() != file2.length()) {\n+        if (file.length() != file2.length()) {\n             return false;\n         }\n-        if (file1.getCanonicalFile().equals(file2.getCanonicalFile())) {\n+        if (file.getCanonicalFile().equals(file2.getCanonicalFile())) {\n             return true;\n         }\n-        try (final InputStream input1 = Files.newInputStream(file1.toPath(), new OpenOption[0]);\n-             final InputStream input2 = Files.newInputStream(file2.toPath(), new OpenOption[0])) {\n-            return IOUtils.contentEquals(input1, input2);\n+        try (final InputStream inputStream = Files.newInputStream(file.toPath(), new OpenOption[0]);\n+             final InputStream inputStream2 = Files.newInputStream(file2.toPath(), new OpenOption[0])) {\n+            return IOUtils.contentEquals(inputStream, inputStream2);\n         }\n     }\n     \n-    public static boolean contentEqualsIgnoreEOL(final File file1, final File file2, final String charsetName) throws IOException {\n-        if (file1 == null && file2 == null) {\n+    public static boolean contentEqualsIgnoreEOL(final File file, final File file2, final String s) throws IOException {\n+        if (file == null && file2 == null) {\n             return true;\n         }\n-        if (file1 == null || file2 == null) {\n+        if (file == null || file2 == null) {\n             return false;\n         }\n-        final boolean file1Exists = file1.exists();\n-        if (file1Exists != file2.exists()) {\n+        final boolean exists = file.exists();\n+        if (exists != file2.exists()) {\n             return false;\n         }\n-        if (!file1Exists) {\n+        if (!exists) {\n             return true;\n         }\n-        requireFile(file1, \"file1\");\n+        requireFile(file, \"file1\");\n         requireFile(file2, \"file2\");\n-        if (file1.getCanonicalFile().equals(file2.getCanonicalFile())) {\n+        if (file.getCanonicalFile().equals(file2.getCanonicalFile())) {\n             return true;\n         }\n-        final Charset charset = Charsets.toCharset(charsetName);\n-        try (final Reader input1 = new InputStreamReader(Files.newInputStream(file1.toPath(), new OpenOption[0]), charset);\n-             final Reader input2 = new InputStreamReader(Files.newInputStream(file2.toPath(), new OpenOption[0]), charset)) {\n-            return IOUtils.contentEqualsIgnoreEOL(input1, input2);\n+        final Charset charset = Charsets.toCharset(s);\n+        try (final InputStreamReader inputStreamReader = new InputStreamReader(Files.newInputStream(file.toPath(), new OpenOption[0]), charset);\n+             final InputStreamReader inputStreamReader2 = new InputStreamReader(Files.newInputStream(file2.toPath(), new OpenOption[0]), charset)) {\n+            return IOUtils.contentEqualsIgnoreEOL((Reader)inputStreamReader, (Reader)inputStreamReader2);\n         }\n     }\n     \n-    public static File[] convertFileCollectionToFileArray(final Collection<File> files) {\n-        return files.toArray(FileUtils.EMPTY_FILE_ARRAY);\n+    public static File[] convertFileCollectionToFileArray(final Collection<File> collection) {\n+        return collection.toArray(FileUtils.EMPTY_FILE_ARRAY);\n     }\n     \n-    public static void copyDirectory(final File srcDir, final File destDir) throws IOException {\n-        copyDirectory(srcDir, destDir, true);\n+    public static void copyDirectory(final File file, final File file2) throws IOException {\n+        copyDirectory(file, file2, true);\n     }\n     \n-    public static void copyDirectory(final File srcDir, final File destDir, final boolean preserveFileDate) throws IOException {\n-        copyDirectory(srcDir, destDir, null, preserveFileDate);\n+    public static void copyDirectory(final File file, final File file2, final boolean b) throws IOException {\n+        copyDirectory(file, file2, null, b);\n     }\n     \n-    public static void copyDirectory(final File srcDir, final File destDir, final FileFilter filter) throws IOException {\n-        copyDirectory(srcDir, destDir, filter, true);\n+    public static void copyDirectory(final File file, final File file2, final FileFilter fileFilter) throws IOException {\n+        copyDirectory(file, file2, fileFilter, true);\n     }\n     \n-    public static void copyDirectory(final File srcDir, final File destDir, final FileFilter filter, final boolean preserveFileDate) throws IOException {\n-        copyDirectory(srcDir, destDir, filter, preserveFileDate, StandardCopyOption.REPLACE_EXISTING);\n+    public static void copyDirectory(final File file, final File file2, final FileFilter fileFilter, final boolean b) throws IOException {\n+        copyDirectory(file, file2, fileFilter, b, StandardCopyOption.REPLACE_EXISTING);\n     }\n     \n-    public static void copyDirectory(final File srcDir, final File destDir, final FileFilter fileFilter, final boolean preserveFileDate, final CopyOption... copyOptions) throws IOException {\n-        requireFileCopy(srcDir, destDir);\n-        requireDirectory(srcDir, \"srcDir\");\n-        requireCanonicalPathsNotEquals(srcDir, destDir);\n-        List<String> exclusionList = null;\n-        final String srcDirCanonicalPath = srcDir.getCanonicalPath();\n-        final String destDirCanonicalPath = destDir.getCanonicalPath();\n-        if (destDirCanonicalPath.startsWith(srcDirCanonicalPath)) {\n-            final File[] srcFiles = listFiles(srcDir, fileFilter);\n-            if (srcFiles.length > 0) {\n-                exclusionList = new ArrayList<String>(srcFiles.length);\n-                for (final File srcFile : srcFiles) {\n-                    exclusionList.add(new File(destDir, srcFile.getName()).getCanonicalPath());\n+    public static void copyDirectory(final File file, final File parent, final FileFilter fileFilter, final boolean b, final CopyOption... array) throws IOException {\n+        requireFileCopy(file, parent);\n+        requireDirectory(file, \"srcDir\");\n+        requireCanonicalPathsNotEquals(file, parent);\n+        List list = null;\n+        if (parent.getCanonicalPath().startsWith(file.getCanonicalPath())) {\n+            final File[] listFiles = listFiles(file, fileFilter);\n+            if (listFiles.length > 0) {\n+                list = new ArrayList(listFiles.length);\n+                final File[] array2 = listFiles;\n+                for (int length = array2.length, i = 0; i < length; ++i) {\n+                    list.add(new File(parent, array2[i].getName()).getCanonicalPath());\n                 }\n             }\n         }\n-        doCopyDirectory(srcDir, destDir, fileFilter, exclusionList, preserveFileDate, copyOptions);\n+        doCopyDirectory(file, parent, fileFilter, list, b, array);\n     }\n     \n-    public static void copyDirectoryToDirectory(final File sourceDir, final File destinationDir) throws IOException {\n-        requireDirectoryIfExists(sourceDir, \"sourceDir\");\n-        requireDirectoryIfExists(destinationDir, \"destinationDir\");\n-        copyDirectory(sourceDir, new File(destinationDir, sourceDir.getName()), true);\n+    public static void copyDirectoryToDirectory(final File file, final File parent) throws IOException {\n+        requireDirectoryIfExists(file, \"sourceDir\");\n+        requireDirectoryIfExists(parent, \"destinationDir\");\n+        copyDirectory(file, new File(parent, file.getName()), true);\n     }\n     \n-    public static void copyFile(final File srcFile, final File destFile) throws IOException {\n-        copyFile(srcFile, destFile, StandardCopyOption.REPLACE_EXISTING);\n+    public static void copyFile(final File file, final File file2) throws IOException {\n+        copyFile(file, file2, StandardCopyOption.REPLACE_EXISTING);\n     }\n     \n-    public static void copyFile(final File srcFile, final File destFile, final boolean preserveFileDate) throws IOException {\n-        copyFile(srcFile, destFile, preserveFileDate, StandardCopyOption.REPLACE_EXISTING);\n+    public static void copyFile(final File file, final File file2, final boolean b) throws IOException {\n+        copyFile(file, file2, b, StandardCopyOption.REPLACE_EXISTING);\n     }\n     \n-    public static void copyFile(final File srcFile, final File destFile, final boolean preserveFileDate, final CopyOption... copyOptions) throws IOException {\n-        requireFileCopy(srcFile, destFile);\n-        requireFile(srcFile, \"srcFile\");\n-        requireCanonicalPathsNotEquals(srcFile, destFile);\n-        createParentDirectories(destFile);\n-        requireFileIfExists(destFile, \"destFile\");\n-        if (destFile.exists()) {\n-            requireCanWrite(destFile, \"destFile\");\n+    public static void copyFile(final File file, final File file2, final boolean b, final CopyOption... options) throws IOException {\n+        requireFileCopy(file, file2);\n+        requireFile(file, \"srcFile\");\n+        requireCanonicalPathsNotEquals(file, file2);\n+        createParentDirectories(file2);\n+        requireFileIfExists(file2, \"destFile\");\n+        if (file2.exists()) {\n+            requireCanWrite(file2, \"destFile\");\n         }\n-        Files.copy(srcFile.toPath(), destFile.toPath(), copyOptions);\n-        if (preserveFileDate && !setTimes(srcFile, destFile)) {\n+        Files.copy(file.toPath(), file2.toPath(), options);\n+        if (b && !setTimes(file, file2)) {\n             throw new IOException(\"Cannot set the file time.\");\n         }\n     }\n     \n-    public static void copyFile(final File srcFile, final File destFile, final CopyOption... copyOptions) throws IOException {\n-        copyFile(srcFile, destFile, true, copyOptions);\n+    public static void copyFile(final File file, final File file2, final CopyOption... array) throws IOException {\n+        copyFile(file, file2, true, array);\n     }\n     \n-    public static long copyFile(final File input, final OutputStream output) throws IOException {\n-        try (final InputStream fis = Files.newInputStream(input.toPath(), new OpenOption[0])) {\n-            return IOUtils.copyLarge(fis, output);\n+    public static long copyFile(final File file, final OutputStream outputStream) throws IOException {\n+        try (final InputStream inputStream = Files.newInputStream(file.toPath(), new OpenOption[0])) {\n+            return IOUtils.copyLarge(inputStream, outputStream);\n         }\n     }\n     \n-    public static void copyFileToDirectory(final File srcFile, final File destDir) throws IOException {\n-        copyFileToDirectory(srcFile, destDir, true);\n+    public static void copyFileToDirectory(final File file, final File file2) throws IOException {\n+        copyFileToDirectory(file, file2, true);\n     }\n     \n-    public static void copyFileToDirectory(final File sourceFile, final File destinationDir, final boolean preserveFileDate) throws IOException {\n-        Objects.requireNonNull(sourceFile, \"sourceFile\");\n-        requireDirectoryIfExists(destinationDir, \"destinationDir\");\n-        copyFile(sourceFile, new File(destinationDir, sourceFile.getName()), preserveFileDate);\n+    public static void copyFileToDirectory(final File obj, final File parent, final boolean b) throws IOException {\n+        Objects.requireNonNull(obj, \"sourceFile\");\n+        requireDirectoryIfExists(parent, \"destinationDir\");\n+        copyFile(obj, new File(parent, obj.getName()), b);\n     }\n     \n-    public static void copyInputStreamToFile(final InputStream source, final File destination) throws IOException {\n-        try (final InputStream inputStream = source) {\n-            copyToFile(inputStream, destination);\n+    public static void copyInputStreamToFile(final InputStream inputStream, final File file) throws IOException {\n+        Throwable t = null;\n+        try {\n+            copyToFile(inputStream, file);\n+        }\n+        catch (final Throwable t2) {\n+            t = t2;\n+            throw t2;\n+        }\n+        finally {\n+            if (inputStream != null) {\n+                if (t != null) {\n+                    try {\n+                        inputStream.close();\n+                    }\n+                    catch (final Throwable exception) {\n+                        t.addSuppressed(exception);\n+                    }\n+                }\n+                else {\n+                    inputStream.close();\n+                }\n+            }\n         }\n     }\n     \n-    public static void copyToDirectory(final File sourceFile, final File destinationDir) throws IOException {\n-        Objects.requireNonNull(sourceFile, \"sourceFile\");\n-        if (sourceFile.isFile()) {\n-            copyFileToDirectory(sourceFile, destinationDir);\n+    public static void copyToDirectory(final File file, final File file2) throws IOException {\n+        Objects.requireNonNull(file, \"sourceFile\");\n+        if (file.isFile()) {\n+            copyFileToDirectory(file, file2);\n         }\n         else {\n-            if (!sourceFile.isDirectory()) {\n-                throw new FileNotFoundException(\"The source \" + sourceFile + \" does not exist\");\n+            if (!file.isDirectory()) {\n+                throw new FileNotFoundException(\"The source \" + file + \" does not exist\");\n             }\n-            copyDirectoryToDirectory(sourceFile, destinationDir);\n+            copyDirectoryToDirectory(file, file2);\n         }\n     }\n     \n-    public static void copyToDirectory(final Iterable<File> sourceIterable, final File destinationDir) throws IOException {\n-        Objects.requireNonNull(sourceIterable, \"sourceIterable\");\n-        for (final File src : sourceIterable) {\n-            copyFileToDirectory(src, destinationDir);\n+    public static void copyToDirectory(final Iterable<File> obj, final File file) throws IOException {\n+        Objects.requireNonNull(obj, \"sourceIterable\");\n+        final Iterator<File> iterator = obj.iterator();\n+        while (iterator.hasNext()) {\n+            copyFileToDirectory(iterator.next(), file);\n         }\n     }\n     \n     public static void copyToFile(final InputStream inputStream, final File file) throws IOException {\n-        try (final OutputStream out = newOutputStream(file, false)) {\n-            IOUtils.copy(inputStream, out);\n+        try (final OutputStream outputStream = newOutputStream(file, false)) {\n+            IOUtils.copy(inputStream, outputStream);\n         }\n     }\n     \n-    public static void copyURLToFile(final URL source, final File destination) throws IOException {\n-        final Path path = destination.toPath();\n+    public static void copyURLToFile(final URL url, final File file) throws IOException {\n+        final Path path = file.toPath();\n         PathUtils.createParentDirectories(path, new FileAttribute[0]);\n-        PathUtils.copy(source::openStream, path, new CopyOption[] { StandardCopyOption.REPLACE_EXISTING });\n+        PathUtils.copy(url::openStream, path, new CopyOption[] { StandardCopyOption.REPLACE_EXISTING });\n     }\n     \n-    public static void copyURLToFile(final URL source, final File destination, final int connectionTimeoutMillis, final int readTimeoutMillis) throws IOException {\n-        try (final CloseableURLConnection urlConnection = CloseableURLConnection.open(source)) {\n-            urlConnection.setConnectTimeout(connectionTimeoutMillis);\n-            urlConnection.setReadTimeout(readTimeoutMillis);\n-            try (final InputStream stream = urlConnection.getInputStream()) {\n-                copyInputStreamToFile(stream, destination);\n+    public static void copyURLToFile(final URL url, final File file, final int connectTimeout, final int readTimeout) throws IOException {\n+        try (final CloseableURLConnection open = CloseableURLConnection.open(url)) {\n+            open.setConnectTimeout(connectTimeout);\n+            open.setReadTimeout(readTimeout);\n+            try (final InputStream inputStream = open.getInputStream()) {\n+                copyInputStreamToFile(inputStream, file);\n             }\n         }\n     }\n     \n     public static File createParentDirectories(final File file) throws IOException {\n         return mkdirs(getParentFile(file));\n     }\n     \n     public static File current() {\n         return PathUtils.current().toFile();\n     }\n     \n-    static String decodeUrl(final String url) {\n-        String decoded = url;\n-        if (url != null && url.indexOf(37) >= 0) {\n-            final int n = url.length();\n-            final StringBuilder builder = new StringBuilder();\n-            final ByteBuffer byteBuffer = ByteBuffer.allocate(n);\n+    static String decodeUrl(final String s) {\n+        String string = s;\n+        if (s != null && s.indexOf(37) >= 0) {\n+            final int length = s.length();\n+            final StringBuilder sb = new StringBuilder();\n+            final ByteBuffer allocate = ByteBuffer.allocate(length);\n             int i = 0;\n-            while (i < n) {\n-                if (url.charAt(i) == '%') {\n+            while (i < length) {\n+                if (s.charAt(i) == '%') {\n                     try {\n                         do {\n-                            final byte octet = (byte)Integer.parseInt(url.substring(i + 1, i + 3), 16);\n-                            byteBuffer.put(octet);\n+                            allocate.put((byte)Integer.parseInt(s.substring(i + 1, i + 3), 16));\n                             i += 3;\n-                        } while (i < n && url.charAt(i) == '%');\n+                        } while (i < length && s.charAt(i) == '%');\n                         continue;\n                     }\n                     catch (final RuntimeException ex) {}\n                     finally {\n-                        if (byteBuffer.position() > 0) {\n-                            byteBuffer.flip();\n-                            builder.append(StandardCharsets.UTF_8.decode(byteBuffer).toString());\n-                            byteBuffer.clear();\n+                        if (allocate.position() > 0) {\n+                            allocate.flip();\n+                            sb.append(StandardCharsets.UTF_8.decode(allocate).toString());\n+                            allocate.clear();\n                         }\n                     }\n                 }\n-                builder.append(url.charAt(i++));\n+                sb.append(s.charAt(i++));\n             }\n-            decoded = builder.toString();\n+            string = sb.toString();\n         }\n-        return decoded;\n+        return string;\n     }\n     \n-    public static File delete(final File file) throws IOException {\n-        Objects.requireNonNull(file, \"file\");\n-        Files.delete(file.toPath());\n-        return file;\n+    public static File delete(final File obj) throws IOException {\n+        Objects.requireNonNull(obj, \"file\");\n+        Files.delete(obj.toPath());\n+        return obj;\n     }\n     \n-    public static void deleteDirectory(final File directory) throws IOException {\n-        Objects.requireNonNull(directory, \"directory\");\n-        if (!directory.exists()) {\n+    public static void deleteDirectory(final File obj) throws IOException {\n+        Objects.requireNonNull(obj, \"directory\");\n+        if (!obj.exists()) {\n             return;\n         }\n-        if (!isSymlink(directory)) {\n-            cleanDirectory(directory);\n+        if (!isSymlink(obj)) {\n+            cleanDirectory(obj);\n         }\n-        delete(directory);\n+        delete(obj);\n     }\n     \n-    private static void deleteDirectoryOnExit(final File directory) throws IOException {\n-        if (!directory.exists()) {\n+    private static void deleteDirectoryOnExit(final File file) throws IOException {\n+        if (!file.exists()) {\n             return;\n         }\n-        directory.deleteOnExit();\n-        if (!isSymlink(directory)) {\n-            cleanDirectoryOnExit(directory);\n+        file.deleteOnExit();\n+        if (!isSymlink(file)) {\n+            cleanDirectoryOnExit(file);\n         }\n     }\n     \n     public static boolean deleteQuietly(final File file) {\n         if (file == null) {\n             return false;\n         }\n@@ -412,99 +431,99 @@\n                 cleanDirectory(file);\n             }\n         }\n         catch (final Exception ex) {}\n         try {\n             return file.delete();\n         }\n-        catch (final Exception ignored) {\n+        catch (final Exception ex2) {\n             return false;\n         }\n     }\n     \n-    public static boolean directoryContains(final File directory, final File child) throws IOException {\n-        requireDirectoryExists(directory, \"directory\");\n-        return child != null && directory.exists() && child.exists() && FilenameUtils.directoryContains(directory.getCanonicalPath(), child.getCanonicalPath());\n+    public static boolean directoryContains(final File file, final File file2) throws IOException {\n+        requireDirectoryExists(file, \"directory\");\n+        return file2 != null && file.exists() && file2.exists() && FilenameUtils.directoryContains(file.getCanonicalPath(), file2.getCanonicalPath());\n     }\n     \n-    private static void doCopyDirectory(final File srcDir, final File destDir, final FileFilter fileFilter, final List<String> exclusionList, final boolean preserveDirDate, final CopyOption... copyOptions) throws IOException {\n-        final File[] srcFiles = listFiles(srcDir, fileFilter);\n-        requireDirectoryIfExists(destDir, \"destDir\");\n-        mkdirs(destDir);\n-        requireCanWrite(destDir, \"destDir\");\n-        for (final File srcFile : srcFiles) {\n-            final File dstFile = new File(destDir, srcFile.getName());\n-            if (exclusionList == null || !exclusionList.contains(srcFile.getCanonicalPath())) {\n-                if (srcFile.isDirectory()) {\n-                    doCopyDirectory(srcFile, dstFile, fileFilter, exclusionList, preserveDirDate, copyOptions);\n+    private static void doCopyDirectory(final File file, final File parent, final FileFilter fileFilter, final List<String> list, final boolean b, final CopyOption... array) throws IOException {\n+        final File[] listFiles = listFiles(file, fileFilter);\n+        requireDirectoryIfExists(parent, \"destDir\");\n+        mkdirs(parent);\n+        requireCanWrite(parent, \"destDir\");\n+        for (final File file2 : listFiles) {\n+            final File file3 = new File(parent, file2.getName());\n+            if (list == null || !list.contains(file2.getCanonicalPath())) {\n+                if (file2.isDirectory()) {\n+                    doCopyDirectory(file2, file3, fileFilter, list, b, array);\n                 }\n                 else {\n-                    copyFile(srcFile, dstFile, preserveDirDate, copyOptions);\n+                    copyFile(file2, file3, b, array);\n                 }\n             }\n         }\n-        if (preserveDirDate) {\n-            setTimes(srcDir, destDir);\n+        if (b) {\n+            setTimes(file, parent);\n         }\n     }\n     \n-    public static void forceDelete(final File file) throws IOException {\n-        Objects.requireNonNull(file, \"file\");\n-        Counters.PathCounters deleteCounters;\n+    public static void forceDelete(final File obj) throws IOException {\n+        Objects.requireNonNull(obj, \"file\");\n+        Counters.PathCounters delete;\n         try {\n-            deleteCounters = PathUtils.delete(file.toPath(), PathUtils.EMPTY_LINK_OPTION_ARRAY, new DeleteOption[] { (DeleteOption)StandardDeleteOption.OVERRIDE_READ_ONLY });\n+            delete = PathUtils.delete(obj.toPath(), PathUtils.EMPTY_LINK_OPTION_ARRAY, new DeleteOption[] { (DeleteOption)StandardDeleteOption.OVERRIDE_READ_ONLY });\n         }\n-        catch (final IOException e) {\n-            throw new IOException(\"Cannot delete file: \" + file, e);\n+        catch (final IOException cause) {\n+            throw new IOException(\"Cannot delete file: \" + obj, cause);\n         }\n-        if (deleteCounters.getFileCounter().get() < 1L && deleteCounters.getDirectoryCounter().get() < 1L) {\n-            throw new FileNotFoundException(\"File does not exist: \" + file);\n+        if (delete.getFileCounter().get() < 1L && delete.getDirectoryCounter().get() < 1L) {\n+            throw new FileNotFoundException(\"File does not exist: \" + obj);\n         }\n     }\n     \n-    public static void forceDeleteOnExit(final File file) throws IOException {\n-        Objects.requireNonNull(file, \"file\");\n-        if (file.isDirectory()) {\n-            deleteDirectoryOnExit(file);\n+    public static void forceDeleteOnExit(final File obj) throws IOException {\n+        Objects.requireNonNull(obj, \"file\");\n+        if (obj.isDirectory()) {\n+            deleteDirectoryOnExit(obj);\n         }\n         else {\n-            file.deleteOnExit();\n+            obj.deleteOnExit();\n         }\n     }\n     \n-    public static void forceMkdir(final File directory) throws IOException {\n-        mkdirs(directory);\n+    public static void forceMkdir(final File file) throws IOException {\n+        mkdirs(file);\n     }\n     \n-    public static void forceMkdirParent(final File file) throws IOException {\n-        forceMkdir(getParentFile((File)Objects.requireNonNull(file, \"file\")));\n+    public static void forceMkdirParent(final File obj) throws IOException {\n+        forceMkdir(getParentFile((File)Objects.requireNonNull(obj, \"file\")));\n     }\n     \n-    public static File getFile(final File directory, final String... names) {\n-        Objects.requireNonNull(directory, \"directory\");\n-        Objects.requireNonNull(names, \"names\");\n-        File file = directory;\n-        for (final String name : names) {\n-            file = new File(file, name);\n+    public static File getFile(final File obj, final String... obj2) {\n+        Objects.requireNonNull(obj, \"directory\");\n+        Objects.requireNonNull(obj2, \"names\");\n+        File parent = obj;\n+        for (int length = obj2.length, i = 0; i < length; ++i) {\n+            parent = new File(parent, obj2[i]);\n         }\n-        return file;\n+        return parent;\n     }\n     \n-    public static File getFile(final String... names) {\n-        Objects.requireNonNull(names, \"names\");\n-        File file = null;\n-        for (final String name : names) {\n-            if (file == null) {\n-                file = new File(name);\n+    public static File getFile(final String... obj) {\n+        Objects.requireNonNull(obj, \"names\");\n+        File parent = null;\n+        for (final String s : obj) {\n+            if (parent == null) {\n+                parent = new File(s);\n             }\n             else {\n-                file = new File(file, name);\n+                parent = new File(parent, s);\n             }\n         }\n-        return file;\n+        return parent;\n     }\n     \n     private static File getParentFile(final File file) {\n         return (file == null) ? null : file.getParentFile();\n     }\n     \n     public static File getTempDirectory() {\n@@ -523,159 +542,159 @@\n         return System.getProperty(\"user.home\");\n     }\n     \n     public static boolean isDirectory(final File file, final LinkOption... options) {\n         return file != null && Files.isDirectory(file.toPath(), options);\n     }\n     \n-    public static boolean isEmptyDirectory(final File directory) throws IOException {\n-        return PathUtils.isEmptyDirectory(directory.toPath());\n+    public static boolean isEmptyDirectory(final File file) throws IOException {\n+        return PathUtils.isEmptyDirectory(file.toPath());\n     }\n     \n     public static boolean isFileNewer(final File file, final ChronoLocalDate chronoLocalDate) {\n         return isFileNewer(file, chronoLocalDate, LocalTime.MAX);\n     }\n     \n-    public static boolean isFileNewer(final File file, final ChronoLocalDate chronoLocalDate, final LocalTime localTime) {\n-        Objects.requireNonNull(chronoLocalDate, \"chronoLocalDate\");\n+    public static boolean isFileNewer(final File file, final ChronoLocalDate obj, final LocalTime localTime) {\n+        Objects.requireNonNull(obj, \"chronoLocalDate\");\n         Objects.requireNonNull(localTime, \"localTime\");\n-        return isFileNewer(file, chronoLocalDate.atTime(localTime));\n+        return isFileNewer(file, obj.atTime(localTime));\n     }\n     \n-    public static boolean isFileNewer(final File file, final ChronoLocalDate chronoLocalDate, final OffsetTime offsetTime) {\n-        Objects.requireNonNull(chronoLocalDate, \"chronoLocalDate\");\n-        Objects.requireNonNull(offsetTime, \"offsetTime\");\n-        return isFileNewer(file, chronoLocalDate.atTime(offsetTime.toLocalTime()));\n+    public static boolean isFileNewer(final File file, final ChronoLocalDate obj, final OffsetTime obj2) {\n+        Objects.requireNonNull(obj, \"chronoLocalDate\");\n+        Objects.requireNonNull(obj2, \"offsetTime\");\n+        return isFileNewer(file, obj.atTime(obj2.toLocalTime()));\n     }\n     \n     public static boolean isFileNewer(final File file, final ChronoLocalDateTime<?> chronoLocalDateTime) {\n         return isFileNewer(file, chronoLocalDateTime, ZoneId.systemDefault());\n     }\n     \n-    public static boolean isFileNewer(final File file, final ChronoLocalDateTime<?> chronoLocalDateTime, final ZoneId zoneId) {\n-        Objects.requireNonNull(chronoLocalDateTime, \"chronoLocalDateTime\");\n-        Objects.requireNonNull(zoneId, \"zoneId\");\n-        return isFileNewer(file, chronoLocalDateTime.atZone(zoneId));\n+    public static boolean isFileNewer(final File file, final ChronoLocalDateTime<?> obj, final ZoneId obj2) {\n+        Objects.requireNonNull(obj, \"chronoLocalDateTime\");\n+        Objects.requireNonNull(obj2, \"zoneId\");\n+        return isFileNewer(file, obj.atZone(obj2));\n     }\n     \n-    public static boolean isFileNewer(final File file, final ChronoZonedDateTime<?> chronoZonedDateTime) {\n-        Objects.requireNonNull(file, \"file\");\n-        Objects.requireNonNull(chronoZonedDateTime, \"chronoZonedDateTime\");\n-        return (boolean)Uncheck.get(() -> Boolean.valueOf(PathUtils.isNewer(file.toPath(), chronoZonedDateTime, new LinkOption[0])));\n+    public static boolean isFileNewer(final File obj, final ChronoZonedDateTime<?> obj2) {\n+        Objects.requireNonNull(obj, \"file\");\n+        Objects.requireNonNull(obj2, \"chronoZonedDateTime\");\n+        return (boolean)Uncheck.get(() -> Boolean.valueOf(PathUtils.isNewer(obj.toPath(), obj2, new LinkOption[0])));\n     }\n     \n-    public static boolean isFileNewer(final File file, final Date date) {\n-        Objects.requireNonNull(date, \"date\");\n-        return isFileNewer(file, date.getTime());\n+    public static boolean isFileNewer(final File file, final Date obj) {\n+        Objects.requireNonNull(obj, \"date\");\n+        return isFileNewer(file, obj.getTime());\n     }\n     \n-    public static boolean isFileNewer(final File file, final File reference) {\n-        requireExists(reference, \"reference\");\n-        return (boolean)Uncheck.get(() -> Boolean.valueOf(PathUtils.isNewer(file.toPath(), reference.toPath())));\n+    public static boolean isFileNewer(final File file, final File file2) {\n+        requireExists(file2, \"reference\");\n+        return (boolean)Uncheck.get(() -> Boolean.valueOf(PathUtils.isNewer(file.toPath(), file2.toPath())));\n     }\n     \n-    public static boolean isFileNewer(final File file, final FileTime fileTime) throws IOException {\n-        Objects.requireNonNull(file, \"file\");\n-        return PathUtils.isNewer(file.toPath(), fileTime, new LinkOption[0]);\n+    public static boolean isFileNewer(final File obj, final FileTime fileTime) throws IOException {\n+        Objects.requireNonNull(obj, \"file\");\n+        return PathUtils.isNewer(obj.toPath(), fileTime, new LinkOption[0]);\n     }\n     \n-    public static boolean isFileNewer(final File file, final Instant instant) {\n-        Objects.requireNonNull(instant, \"instant\");\n-        return (boolean)Uncheck.get(() -> Boolean.valueOf(PathUtils.isNewer(file.toPath(), instant, new LinkOption[0])));\n+    public static boolean isFileNewer(final File file, final Instant obj) {\n+        Objects.requireNonNull(obj, \"instant\");\n+        return (boolean)Uncheck.get(() -> Boolean.valueOf(PathUtils.isNewer(file.toPath(), obj, new LinkOption[0])));\n     }\n     \n-    public static boolean isFileNewer(final File file, final long timeMillis) {\n-        Objects.requireNonNull(file, \"file\");\n-        return (boolean)Uncheck.get(() -> Boolean.valueOf(PathUtils.isNewer(file.toPath(), timeMillis, new LinkOption[0])));\n+    public static boolean isFileNewer(final File obj, final long n) {\n+        Objects.requireNonNull(obj, \"file\");\n+        return (boolean)Uncheck.get(() -> Boolean.valueOf(PathUtils.isNewer(obj.toPath(), n, new LinkOption[0])));\n     }\n     \n-    public static boolean isFileNewer(final File file, final OffsetDateTime offsetDateTime) {\n-        Objects.requireNonNull(offsetDateTime, \"offsetDateTime\");\n-        return isFileNewer(file, offsetDateTime.toInstant());\n+    public static boolean isFileNewer(final File file, final OffsetDateTime obj) {\n+        Objects.requireNonNull(obj, \"offsetDateTime\");\n+        return isFileNewer(file, obj.toInstant());\n     }\n     \n     public static boolean isFileOlder(final File file, final ChronoLocalDate chronoLocalDate) {\n         return isFileOlder(file, chronoLocalDate, LocalTime.MAX);\n     }\n     \n-    public static boolean isFileOlder(final File file, final ChronoLocalDate chronoLocalDate, final LocalTime localTime) {\n-        Objects.requireNonNull(chronoLocalDate, \"chronoLocalDate\");\n+    public static boolean isFileOlder(final File file, final ChronoLocalDate obj, final LocalTime localTime) {\n+        Objects.requireNonNull(obj, \"chronoLocalDate\");\n         Objects.requireNonNull(localTime, \"localTime\");\n-        return isFileOlder(file, chronoLocalDate.atTime(localTime));\n+        return isFileOlder(file, obj.atTime(localTime));\n     }\n     \n-    public static boolean isFileOlder(final File file, final ChronoLocalDate chronoLocalDate, final OffsetTime offsetTime) {\n-        Objects.requireNonNull(chronoLocalDate, \"chronoLocalDate\");\n-        Objects.requireNonNull(offsetTime, \"offsetTime\");\n-        return isFileOlder(file, chronoLocalDate.atTime(offsetTime.toLocalTime()));\n+    public static boolean isFileOlder(final File file, final ChronoLocalDate obj, final OffsetTime obj2) {\n+        Objects.requireNonNull(obj, \"chronoLocalDate\");\n+        Objects.requireNonNull(obj2, \"offsetTime\");\n+        return isFileOlder(file, obj.atTime(obj2.toLocalTime()));\n     }\n     \n     public static boolean isFileOlder(final File file, final ChronoLocalDateTime<?> chronoLocalDateTime) {\n         return isFileOlder(file, chronoLocalDateTime, ZoneId.systemDefault());\n     }\n     \n-    public static boolean isFileOlder(final File file, final ChronoLocalDateTime<?> chronoLocalDateTime, final ZoneId zoneId) {\n-        Objects.requireNonNull(chronoLocalDateTime, \"chronoLocalDateTime\");\n-        Objects.requireNonNull(zoneId, \"zoneId\");\n-        return isFileOlder(file, chronoLocalDateTime.atZone(zoneId));\n+    public static boolean isFileOlder(final File file, final ChronoLocalDateTime<?> obj, final ZoneId obj2) {\n+        Objects.requireNonNull(obj, \"chronoLocalDateTime\");\n+        Objects.requireNonNull(obj2, \"zoneId\");\n+        return isFileOlder(file, obj.atZone(obj2));\n     }\n     \n-    public static boolean isFileOlder(final File file, final ChronoZonedDateTime<?> chronoZonedDateTime) {\n-        Objects.requireNonNull(chronoZonedDateTime, \"chronoZonedDateTime\");\n-        return isFileOlder(file, chronoZonedDateTime.toInstant());\n+    public static boolean isFileOlder(final File file, final ChronoZonedDateTime<?> obj) {\n+        Objects.requireNonNull(obj, \"chronoZonedDateTime\");\n+        return isFileOlder(file, obj.toInstant());\n     }\n     \n-    public static boolean isFileOlder(final File file, final Date date) {\n-        Objects.requireNonNull(date, \"date\");\n-        return isFileOlder(file, date.getTime());\n+    public static boolean isFileOlder(final File file, final Date obj) {\n+        Objects.requireNonNull(obj, \"date\");\n+        return isFileOlder(file, obj.getTime());\n     }\n     \n-    public static boolean isFileOlder(final File file, final File reference) {\n-        requireExists(reference, \"reference\");\n-        return (boolean)Uncheck.get(() -> Boolean.valueOf(PathUtils.isOlder(file.toPath(), reference.toPath())));\n+    public static boolean isFileOlder(final File file, final File file2) {\n+        requireExists(file2, \"reference\");\n+        return (boolean)Uncheck.get(() -> Boolean.valueOf(PathUtils.isOlder(file.toPath(), file2.toPath())));\n     }\n     \n-    public static boolean isFileOlder(final File file, final FileTime fileTime) throws IOException {\n-        Objects.requireNonNull(file, \"file\");\n-        return PathUtils.isOlder(file.toPath(), fileTime, new LinkOption[0]);\n+    public static boolean isFileOlder(final File obj, final FileTime fileTime) throws IOException {\n+        Objects.requireNonNull(obj, \"file\");\n+        return PathUtils.isOlder(obj.toPath(), fileTime, new LinkOption[0]);\n     }\n     \n-    public static boolean isFileOlder(final File file, final Instant instant) {\n-        Objects.requireNonNull(instant, \"instant\");\n-        return (boolean)Uncheck.get(() -> Boolean.valueOf(PathUtils.isOlder(file.toPath(), instant, new LinkOption[0])));\n+    public static boolean isFileOlder(final File file, final Instant obj) {\n+        Objects.requireNonNull(obj, \"instant\");\n+        return (boolean)Uncheck.get(() -> Boolean.valueOf(PathUtils.isOlder(file.toPath(), obj, new LinkOption[0])));\n     }\n     \n-    public static boolean isFileOlder(final File file, final long timeMillis) {\n-        Objects.requireNonNull(file, \"file\");\n-        return (boolean)Uncheck.get(() -> Boolean.valueOf(PathUtils.isOlder(file.toPath(), timeMillis, new LinkOption[0])));\n+    public static boolean isFileOlder(final File obj, final long n) {\n+        Objects.requireNonNull(obj, \"file\");\n+        return (boolean)Uncheck.get(() -> Boolean.valueOf(PathUtils.isOlder(obj.toPath(), n, new LinkOption[0])));\n     }\n     \n-    public static boolean isFileOlder(final File file, final OffsetDateTime offsetDateTime) {\n-        Objects.requireNonNull(offsetDateTime, \"offsetDateTime\");\n-        return isFileOlder(file, offsetDateTime.toInstant());\n+    public static boolean isFileOlder(final File file, final OffsetDateTime obj) {\n+        Objects.requireNonNull(obj, \"offsetDateTime\");\n+        return isFileOlder(file, obj.toInstant());\n     }\n     \n     public static boolean isRegularFile(final File file, final LinkOption... options) {\n         return file != null && Files.isRegularFile(file.toPath(), options);\n     }\n     \n     public static boolean isSymlink(final File file) {\n         return file != null && Files.isSymbolicLink(file.toPath());\n     }\n     \n-    public static Iterator<File> iterateFiles(final File directory, final IOFileFilter fileFilter, final IOFileFilter dirFilter) {\n-        return listFiles(directory, fileFilter, dirFilter).iterator();\n+    public static Iterator<File> iterateFiles(final File file, final IOFileFilter ioFileFilter, final IOFileFilter ioFileFilter2) {\n+        return listFiles(file, ioFileFilter, ioFileFilter2).iterator();\n     }\n     \n-    public static Iterator<File> iterateFiles(final File directory, final String[] extensions, final boolean recursive) {\n-        return (Iterator)Uncheck.apply(d -> streamFiles(d, recursive, extensions).iterator(), (Object)directory);\n+    public static Iterator<File> iterateFiles(final File file, final String[] array, final boolean b) {\n+        return (Iterator)Uncheck.apply(file -> streamFiles(file, b, array).iterator(), (Object)file);\n     }\n     \n-    public static Iterator<File> iterateFilesAndDirs(final File directory, final IOFileFilter fileFilter, final IOFileFilter dirFilter) {\n-        return listFilesAndDirs(directory, fileFilter, dirFilter).iterator();\n+    public static Iterator<File> iterateFilesAndDirs(final File file, final IOFileFilter ioFileFilter, final IOFileFilter ioFileFilter2) {\n+        return listFilesAndDirs(file, ioFileFilter, ioFileFilter2).iterator();\n     }\n     \n     public static long lastModified(final File file) throws IOException {\n         return lastModifiedFileTime(file).toMillis();\n     }\n     \n     public static FileTime lastModifiedFileTime(final File file) throws IOException {\n@@ -686,139 +705,136 @@\n         return (long)Uncheck.apply(FileUtils::lastModified, (Object)file);\n     }\n     \n     public static LineIterator lineIterator(final File file) throws IOException {\n         return lineIterator(file, null);\n     }\n     \n-    public static LineIterator lineIterator(final File file, final String charsetName) throws IOException {\n+    public static LineIterator lineIterator(final File file, final String s) throws IOException {\n         InputStream inputStream = null;\n         try {\n             inputStream = Files.newInputStream(file.toPath(), new OpenOption[0]);\n-            return IOUtils.lineIterator(inputStream, charsetName);\n+            return IOUtils.lineIterator(inputStream, s);\n         }\n         catch (final IOException | RuntimeException ex) {\n             IOUtils.closeQuietly((Closeable)inputStream, (Consumer)ex::addSuppressed);\n             throw ex;\n         }\n     }\n     \n-    private static AccumulatorPathVisitor listAccumulate(final File directory, final IOFileFilter fileFilter, final IOFileFilter dirFilter, final FileVisitOption... options) throws IOException {\n-        final boolean isDirFilterSet = dirFilter != null;\n-        final FileEqualsFileFilter rootDirFilter = new FileEqualsFileFilter(directory);\n-        final PathFilter dirPathFilter = (PathFilter)(isDirFilterSet ? rootDirFilter.or(dirFilter) : rootDirFilter);\n-        final AccumulatorPathVisitor visitor = new AccumulatorPathVisitor(Counters.noopPathCounters(), (PathFilter)fileFilter, dirPathFilter, (p, e) -> FileVisitResult.CONTINUE);\n-        final Set<FileVisitOption> optionSet = new HashSet<FileVisitOption>();\n-        Collections.addAll(optionSet, options);\n-        Files.walkFileTree(directory.toPath(), optionSet, toMaxDepth(isDirFilterSet), (FileVisitor<? super Path>)visitor);\n+    private static AccumulatorPathVisitor listAccumulate(final File file, final IOFileFilter ioFileFilter, final IOFileFilter ioFileFilter2, final FileVisitOption... elements) throws IOException {\n+        final boolean b = ioFileFilter2 != null;\n+        final FileEqualsFileFilter fileEqualsFileFilter = new FileEqualsFileFilter(file);\n+        final AccumulatorPathVisitor visitor = new AccumulatorPathVisitor(Counters.noopPathCounters(), (PathFilter)ioFileFilter, (PathFilter)(b ? fileEqualsFileFilter.or(ioFileFilter2) : fileEqualsFileFilter), (path, ex) -> FileVisitResult.CONTINUE);\n+        final HashSet<Object> set = new HashSet<Object>();\n+        Collections.addAll(set, elements);\n+        Files.walkFileTree(file.toPath(), (Set<FileVisitOption>)set, toMaxDepth(b), (FileVisitor<? super Path>)visitor);\n         return visitor;\n     }\n     \n-    private static File[] listFiles(final File directory, final FileFilter fileFilter) throws IOException {\n-        requireDirectoryExists(directory, \"directory\");\n-        final File[] files = (fileFilter == null) ? directory.listFiles() : directory.listFiles(fileFilter);\n-        if (files == null) {\n-            throw new IOException(\"Unknown I/O error listing contents of directory: \" + directory);\n+    private static File[] listFiles(final File obj, final FileFilter filter) throws IOException {\n+        requireDirectoryExists(obj, \"directory\");\n+        final File[] array = (filter == null) ? obj.listFiles() : obj.listFiles(filter);\n+        if (array == null) {\n+            throw new IOException(\"Unknown I/O error listing contents of directory: \" + obj);\n         }\n-        return files;\n+        return array;\n     }\n     \n-    public static Collection<File> listFiles(final File directory, final IOFileFilter fileFilter, final IOFileFilter dirFilter) {\n-        final AccumulatorPathVisitor visitor = (AccumulatorPathVisitor)Uncheck.apply(d -> listAccumulate(d, FileFileFilter.INSTANCE.and(fileFilter), dirFilter, FileVisitOption.FOLLOW_LINKS), (Object)directory);\n-        return (Collection)visitor.getFileList().stream().map(Path::toFile).collect(Collectors.toList());\n+    public static Collection<File> listFiles(final File file, final IOFileFilter ioFileFilter, final IOFileFilter ioFileFilter2) {\n+        return (Collection)((AccumulatorPathVisitor)Uncheck.apply(file -> listAccumulate(file, FileFileFilter.INSTANCE.and(ioFileFilter), ioFileFilter2, FileVisitOption.FOLLOW_LINKS), (Object)file)).getFileList().stream().map(Path::toFile).collect(Collectors.toList());\n     }\n     \n-    public static Collection<File> listFiles(final File directory, final String[] extensions, final boolean recursive) {\n-        return (Collection)Uncheck.apply(d -> toList(streamFiles(d, recursive, extensions)), (Object)directory);\n+    public static Collection<File> listFiles(final File file, final String[] array, final boolean b) {\n+        return (Collection)Uncheck.apply(file -> toList(streamFiles(file, b, array)), (Object)file);\n     }\n     \n-    public static Collection<File> listFilesAndDirs(final File directory, final IOFileFilter fileFilter, final IOFileFilter dirFilter) {\n-        final AccumulatorPathVisitor visitor = (AccumulatorPathVisitor)Uncheck.apply(d -> listAccumulate(d, fileFilter, dirFilter, FileVisitOption.FOLLOW_LINKS), (Object)directory);\n-        final List<Path> list = visitor.getFileList();\n-        list.addAll(visitor.getDirList());\n-        return list.stream().map((Function<? super Object, ?>)Path::toFile).collect((Collector<? super Object, ?, Collection<File>>)Collectors.toList());\n+    public static Collection<File> listFilesAndDirs(final File file, final IOFileFilter ioFileFilter, final IOFileFilter ioFileFilter2) {\n+        final AccumulatorPathVisitor accumulatorPathVisitor = (AccumulatorPathVisitor)Uncheck.apply(file -> listAccumulate(file, ioFileFilter, ioFileFilter2, FileVisitOption.FOLLOW_LINKS), (Object)file);\n+        final List fileList = accumulatorPathVisitor.getFileList();\n+        fileList.addAll(accumulatorPathVisitor.getDirList());\n+        return (Collection)fileList.stream().map(Path::toFile).collect(Collectors.toList());\n     }\n     \n-    private static File mkdirs(final File directory) throws IOException {\n-        if (directory != null && !directory.mkdirs() && !directory.isDirectory()) {\n-            throw new IOException(\"Cannot create directory '\" + directory + \"'.\");\n+    private static File mkdirs(final File obj) throws IOException {\n+        if (obj != null && !obj.mkdirs() && !obj.isDirectory()) {\n+            throw new IOException(\"Cannot create directory '\" + obj + \"'.\");\n         }\n-        return directory;\n+        return obj;\n     }\n     \n-    public static void moveDirectory(final File srcDir, final File destDir) throws IOException {\n-        validateMoveParameters(srcDir, destDir);\n-        requireDirectory(srcDir, \"srcDir\");\n-        requireAbsent(destDir, \"destDir\");\n-        if (!srcDir.renameTo(destDir)) {\n-            if (destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator)) {\n-                throw new IOException(\"Cannot move directory: \" + srcDir + \" to a subdirectory of itself: \" + destDir);\n+    public static void moveDirectory(final File file, final File obj) throws IOException {\n+        validateMoveParameters(file, obj);\n+        requireDirectory(file, \"srcDir\");\n+        requireAbsent(obj, \"destDir\");\n+        if (!file.renameTo(obj)) {\n+            if (obj.getCanonicalPath().startsWith(file.getCanonicalPath() + File.separator)) {\n+                throw new IOException(\"Cannot move directory: \" + file + \" to a subdirectory of itself: \" + obj);\n             }\n-            copyDirectory(srcDir, destDir);\n-            deleteDirectory(srcDir);\n-            if (srcDir.exists()) {\n-                throw new IOException(\"Failed to delete original directory '\" + srcDir + \"' after copy to '\" + destDir + \"'\");\n+            copyDirectory(file, obj);\n+            deleteDirectory(file);\n+            if (file.exists()) {\n+                throw new IOException(\"Failed to delete original directory '\" + file + \"' after copy to '\" + obj + \"'\");\n             }\n         }\n     }\n     \n-    public static void moveDirectoryToDirectory(final File source, final File destDir, final boolean createDestDir) throws IOException {\n-        validateMoveParameters(source, destDir);\n-        if (!destDir.isDirectory()) {\n-            if (destDir.exists()) {\n-                throw new IOException(\"Destination '\" + destDir + \"' is not a directory\");\n+    public static void moveDirectoryToDirectory(final File file, final File parent, final boolean b) throws IOException {\n+        validateMoveParameters(file, parent);\n+        if (!parent.isDirectory()) {\n+            if (parent.exists()) {\n+                throw new IOException(\"Destination '\" + parent + \"' is not a directory\");\n             }\n-            if (!createDestDir) {\n-                throw new FileNotFoundException(\"Destination directory '\" + destDir + \"' does not exist [createDestDir=\" + false + \"]\");\n+            if (!b) {\n+                throw new FileNotFoundException(\"Destination directory '\" + parent + \"' does not exist [createDestDir=\" + false + \"]\");\n             }\n-            mkdirs(destDir);\n+            mkdirs(parent);\n         }\n-        moveDirectory(source, new File(destDir, source.getName()));\n+        moveDirectory(file, new File(parent, file.getName()));\n     }\n     \n-    public static void moveFile(final File srcFile, final File destFile) throws IOException {\n-        moveFile(srcFile, destFile, StandardCopyOption.COPY_ATTRIBUTES);\n+    public static void moveFile(final File file, final File file2) throws IOException {\n+        moveFile(file, file2, StandardCopyOption.COPY_ATTRIBUTES);\n     }\n     \n-    public static void moveFile(final File srcFile, final File destFile, final CopyOption... copyOptions) throws IOException {\n-        validateMoveParameters(srcFile, destFile);\n-        requireFile(srcFile, \"srcFile\");\n-        requireAbsent(destFile, \"destFile\");\n-        final boolean rename = srcFile.renameTo(destFile);\n-        if (!rename) {\n-            copyFile(srcFile, destFile, false, copyOptions);\n-            if (!srcFile.delete()) {\n-                deleteQuietly(destFile);\n-                throw new IOException(\"Failed to delete original file '\" + srcFile + \"' after copy to '\" + destFile + \"'\");\n+    public static void moveFile(final File obj, final File file, final CopyOption... array) throws IOException {\n+        validateMoveParameters(obj, file);\n+        requireFile(obj, \"srcFile\");\n+        requireAbsent(file, \"destFile\");\n+        if (!obj.renameTo(file)) {\n+            copyFile(obj, file, false, array);\n+            if (!obj.delete()) {\n+                deleteQuietly(file);\n+                throw new IOException(\"Failed to delete original file '\" + obj + \"' after copy to '\" + file + \"'\");\n             }\n         }\n     }\n     \n-    public static void moveFileToDirectory(final File srcFile, final File destDir, final boolean createDestDir) throws IOException {\n-        validateMoveParameters(srcFile, destDir);\n-        if (!destDir.exists() && createDestDir) {\n-            mkdirs(destDir);\n-        }\n-        requireExistsChecked(destDir, \"destDir\");\n-        requireDirectory(destDir, \"destDir\");\n-        moveFile(srcFile, new File(destDir, srcFile.getName()));\n+    public static void moveFileToDirectory(final File file, final File parent, final boolean b) throws IOException {\n+        validateMoveParameters(file, parent);\n+        if (!parent.exists() && b) {\n+            mkdirs(parent);\n+        }\n+        requireExistsChecked(parent, \"destDir\");\n+        requireDirectory(parent, \"destDir\");\n+        moveFile(file, new File(parent, file.getName()));\n     }\n     \n-    public static void moveToDirectory(final File src, final File destDir, final boolean createDestDir) throws IOException {\n-        validateMoveParameters(src, destDir);\n-        if (src.isDirectory()) {\n-            moveDirectoryToDirectory(src, destDir, createDestDir);\n+    public static void moveToDirectory(final File file, final File file2, final boolean b) throws IOException {\n+        validateMoveParameters(file, file2);\n+        if (file.isDirectory()) {\n+            moveDirectoryToDirectory(file, file2, b);\n         }\n         else {\n-            moveFileToDirectory(src, destDir, createDestDir);\n+            moveFileToDirectory(file, file2, b);\n         }\n     }\n     \n-    public static OutputStream newOutputStream(final File file, final boolean append) throws IOException {\n-        return PathUtils.newOutputStream(((File)Objects.requireNonNull(file, \"file\")).toPath(), append);\n+    public static OutputStream newOutputStream(final File obj, final boolean b) throws IOException {\n+        return PathUtils.newOutputStream(((File)Objects.requireNonNull(obj, \"file\")).toPath(), b);\n     }\n     \n     public static FileInputStream openInputStream(final File file) throws IOException {\n         Objects.requireNonNull(file, \"file\");\n         return new FileInputStream(file);\n     }\n     \n@@ -834,327 +850,324 @@\n         }\n         else {\n             createParentDirectories(file);\n         }\n         return new FileOutputStream(file, append);\n     }\n     \n-    public static byte[] readFileToByteArray(final File file) throws IOException {\n-        Objects.requireNonNull(file, \"file\");\n-        return Files.readAllBytes(file.toPath());\n+    public static byte[] readFileToByteArray(final File obj) throws IOException {\n+        Objects.requireNonNull(obj, \"file\");\n+        return Files.readAllBytes(obj.toPath());\n     }\n     \n     @Deprecated\n     public static String readFileToString(final File file) throws IOException {\n         return readFileToString(file, Charset.defaultCharset());\n     }\n     \n-    public static String readFileToString(final File file, final Charset charsetName) throws IOException {\n-        return IOUtils.toString(() -> Files.newInputStream(file.toPath(), new OpenOption[0]), Charsets.toCharset(charsetName));\n+    public static String readFileToString(final File file, final Charset charset) throws IOException {\n+        return IOUtils.toString(() -> Files.newInputStream(file.toPath(), new OpenOption[0]), Charsets.toCharset(charset));\n     }\n     \n-    public static String readFileToString(final File file, final String charsetName) throws IOException {\n-        return readFileToString(file, Charsets.toCharset(charsetName));\n+    public static String readFileToString(final File file, final String s) throws IOException {\n+        return readFileToString(file, Charsets.toCharset(s));\n     }\n     \n     @Deprecated\n     public static List<String> readLines(final File file) throws IOException {\n         return readLines(file, Charset.defaultCharset());\n     }\n     \n-    public static List<String> readLines(final File file, final Charset charset) throws IOException {\n-        return Files.readAllLines(file.toPath(), charset);\n+    public static List<String> readLines(final File file, final Charset cs) throws IOException {\n+        return Files.readAllLines(file.toPath(), cs);\n     }\n     \n-    public static List<String> readLines(final File file, final String charsetName) throws IOException {\n-        return readLines(file, Charsets.toCharset(charsetName));\n+    public static List<String> readLines(final File file, final String s) throws IOException {\n+        return readLines(file, Charsets.toCharset(s));\n     }\n     \n-    private static void requireAbsent(final File file, final String name) throws FileExistsException {\n+    private static void requireAbsent(final File file, final String s) throws FileExistsException {\n         if (file.exists()) {\n-            throw new FileExistsException(String.format(\"File element in parameter '%s' already exists: '%s'\", name, file));\n+            throw new FileExistsException(String.format(\"File element in parameter '%s' already exists: '%s'\", s, file));\n         }\n     }\n     \n-    private static void requireCanonicalPathsNotEquals(final File file1, final File file2) throws IOException {\n-        final String canonicalPath = file1.getCanonicalPath();\n+    private static void requireCanonicalPathsNotEquals(final File file, final File file2) throws IOException {\n+        final String canonicalPath = file.getCanonicalPath();\n         if (canonicalPath.equals(file2.getCanonicalPath())) {\n-            throw new IllegalArgumentException(String.format(\"File canonical paths are equal: '%s' (file1='%s', file2='%s')\", canonicalPath, file1, file2));\n+            throw new IllegalArgumentException(String.format(\"File canonical paths are equal: '%s' (file1='%s', file2='%s')\", canonicalPath, file, file2));\n         }\n     }\n     \n-    private static void requireCanWrite(final File file, final String name) {\n+    private static void requireCanWrite(final File file, final String str) {\n         Objects.requireNonNull(file, \"file\");\n         if (!file.canWrite()) {\n-            throw new IllegalArgumentException(\"File parameter '\" + name + \" is not writable: '\" + file + \"'\");\n+            throw new IllegalArgumentException(\"File parameter '\" + str + \" is not writable: '\" + file + \"'\");\n         }\n     }\n     \n-    private static File requireDirectory(final File directory, final String name) {\n-        Objects.requireNonNull(directory, name);\n-        if (!directory.isDirectory()) {\n-            throw new IllegalArgumentException(\"Parameter '\" + name + \"' is not a directory: '\" + directory + \"'\");\n+    private static File requireDirectory(final File file, final String s) {\n+        Objects.requireNonNull(file, s);\n+        if (!file.isDirectory()) {\n+            throw new IllegalArgumentException(\"Parameter '\" + s + \"' is not a directory: '\" + file + \"'\");\n         }\n-        return directory;\n+        return file;\n     }\n     \n-    private static File requireDirectoryExists(final File directory, final String name) {\n-        requireExists(directory, name);\n-        requireDirectory(directory, name);\n-        return directory;\n+    private static File requireDirectoryExists(final File file, final String s) {\n+        requireExists(file, s);\n+        requireDirectory(file, s);\n+        return file;\n     }\n     \n-    private static File requireDirectoryIfExists(final File directory, final String name) {\n-        Objects.requireNonNull(directory, name);\n-        if (directory.exists()) {\n-            requireDirectory(directory, name);\n+    private static File requireDirectoryIfExists(final File obj, final String message) {\n+        Objects.requireNonNull(obj, message);\n+        if (obj.exists()) {\n+            requireDirectory(obj, message);\n         }\n-        return directory;\n+        return obj;\n     }\n     \n-    private static File requireExists(final File file, final String fileParamName) {\n-        Objects.requireNonNull(file, fileParamName);\n+    private static File requireExists(final File file, final String s) {\n+        Objects.requireNonNull(file, s);\n         if (!file.exists()) {\n-            throw new IllegalArgumentException(\"File system element for parameter '\" + fileParamName + \"' does not exist: '\" + file + \"'\");\n+            throw new IllegalArgumentException(\"File system element for parameter '\" + s + \"' does not exist: '\" + file + \"'\");\n         }\n         return file;\n     }\n     \n-    private static File requireExistsChecked(final File file, final String fileParamName) throws FileNotFoundException {\n-        Objects.requireNonNull(file, fileParamName);\n+    private static File requireExistsChecked(final File file, final String s) throws FileNotFoundException {\n+        Objects.requireNonNull(file, s);\n         if (!file.exists()) {\n-            throw new FileNotFoundException(\"File system element for parameter '\" + fileParamName + \"' does not exist: '\" + file + \"'\");\n+            throw new FileNotFoundException(\"File system element for parameter '\" + s + \"' does not exist: '\" + file + \"'\");\n         }\n         return file;\n     }\n     \n-    private static File requireFile(final File file, final String name) {\n-        Objects.requireNonNull(file, name);\n+    private static File requireFile(final File file, final String s) {\n+        Objects.requireNonNull(file, s);\n         if (!file.isFile()) {\n-            throw new IllegalArgumentException(\"Parameter '\" + name + \"' is not a file: \" + file);\n+            throw new IllegalArgumentException(\"Parameter '\" + s + \"' is not a file: \" + file);\n         }\n         return file;\n     }\n     \n-    private static void requireFileCopy(final File source, final File destination) throws FileNotFoundException {\n-        requireExistsChecked(source, \"source\");\n-        Objects.requireNonNull(destination, \"destination\");\n+    private static void requireFileCopy(final File file, final File obj) throws FileNotFoundException {\n+        requireExistsChecked(file, \"source\");\n+        Objects.requireNonNull(obj, \"destination\");\n     }\n     \n-    private static File requireFileIfExists(final File file, final String name) {\n-        Objects.requireNonNull(file, name);\n-        return file.exists() ? requireFile(file, name) : file;\n+    private static File requireFileIfExists(final File obj, final String message) {\n+        Objects.requireNonNull(obj, message);\n+        return obj.exists() ? requireFile(obj, message) : obj;\n     }\n     \n-    private static boolean setTimes(final File sourceFile, final File targetFile) throws IOException {\n-        Objects.requireNonNull(sourceFile, \"sourceFile\");\n-        Objects.requireNonNull(targetFile, \"targetFile\");\n+    private static boolean setTimes(final File obj, final File obj2) throws IOException {\n+        Objects.requireNonNull(obj, \"sourceFile\");\n+        Objects.requireNonNull(obj2, \"targetFile\");\n         try {\n-            final BasicFileAttributes srcAttr = Files.readAttributes(sourceFile.toPath(), BasicFileAttributes.class, new LinkOption[0]);\n-            final BasicFileAttributeView destAttrView = (BasicFileAttributeView)Files.getFileAttributeView(targetFile.toPath(), BasicFileAttributeView.class, new LinkOption[0]);\n-            destAttrView.setTimes(srcAttr.lastModifiedTime(), srcAttr.lastAccessTime(), srcAttr.creationTime());\n+            final BasicFileAttributes attributes = Files.readAttributes(obj.toPath(), BasicFileAttributes.class, new LinkOption[0]);\n+            ((BasicFileAttributeView)Files.getFileAttributeView(obj2.toPath(), BasicFileAttributeView.class, new LinkOption[0])).setTimes(attributes.lastModifiedTime(), attributes.lastAccessTime(), attributes.creationTime());\n             return true;\n         }\n-        catch (final IOException ignored) {\n-            return targetFile.setLastModified(sourceFile.lastModified());\n+        catch (final IOException ex) {\n+            return obj2.setLastModified(obj.lastModified());\n         }\n     }\n     \n     public static long sizeOf(final File file) {\n         requireExists(file, \"file\");\n         return (long)Uncheck.get(() -> Long.valueOf(PathUtils.sizeOf(file.toPath())));\n     }\n     \n     public static BigInteger sizeOfAsBigInteger(final File file) {\n         requireExists(file, \"file\");\n         return (BigInteger)Uncheck.get(() -> PathUtils.sizeOfAsBigInteger(file.toPath()));\n     }\n     \n-    public static long sizeOfDirectory(final File directory) {\n-        requireDirectoryExists(directory, \"directory\");\n-        return (long)Uncheck.get(() -> Long.valueOf(PathUtils.sizeOfDirectory(directory.toPath())));\n+    public static long sizeOfDirectory(final File file) {\n+        requireDirectoryExists(file, \"directory\");\n+        return (long)Uncheck.get(() -> Long.valueOf(PathUtils.sizeOfDirectory(file.toPath())));\n     }\n     \n-    public static BigInteger sizeOfDirectoryAsBigInteger(final File directory) {\n-        requireDirectoryExists(directory, \"directory\");\n-        return (BigInteger)Uncheck.get(() -> PathUtils.sizeOfDirectoryAsBigInteger(directory.toPath()));\n+    public static BigInteger sizeOfDirectoryAsBigInteger(final File file) {\n+        requireDirectoryExists(file, \"directory\");\n+        return (BigInteger)Uncheck.get(() -> PathUtils.sizeOfDirectoryAsBigInteger(file.toPath()));\n     }\n     \n-    public static Stream<File> streamFiles(final File directory, final boolean recursive, final String... extensions) throws IOException {\n-        final IOFileFilter filter = (extensions == null) ? FileFileFilter.INSTANCE : FileFileFilter.INSTANCE.and((IOFileFilter)new SuffixFileFilter(toSuffixes(extensions)));\n-        return PathUtils.walk(directory.toPath(), (PathFilter)filter, toMaxDepth(recursive), false, new FileVisitOption[] { FileVisitOption.FOLLOW_LINKS }).map(Path::toFile);\n+    public static Stream<File> streamFiles(final File file, final boolean b, final String... array) throws IOException {\n+        return PathUtils.walk(file.toPath(), (PathFilter)((array == null) ? FileFileFilter.INSTANCE : FileFileFilter.INSTANCE.and((IOFileFilter)new SuffixFileFilter(toSuffixes(array)))), toMaxDepth(b), false, new FileVisitOption[] { FileVisitOption.FOLLOW_LINKS }).map(Path::toFile);\n     }\n     \n     public static File toFile(final URL url) {\n         if (url == null || !\"file\".equalsIgnoreCase(url.getProtocol())) {\n             return null;\n         }\n-        final String filename = url.getFile().replace('/', File.separatorChar);\n-        return new File(decodeUrl(filename));\n+        return new File(decodeUrl(url.getFile().replace('/', File.separatorChar)));\n     }\n     \n-    public static File[] toFiles(final URL... urls) {\n-        if (IOUtils.length((Object[])urls) == 0) {\n+    public static File[] toFiles(final URL... array) {\n+        if (IOUtils.length((Object[])array) == 0) {\n             return FileUtils.EMPTY_FILE_ARRAY;\n         }\n-        final File[] files = new File[urls.length];\n-        for (int i = 0; i < urls.length; ++i) {\n-            final URL url = urls[i];\n-            if (url != null) {\n-                if (!\"file\".equalsIgnoreCase(url.getProtocol())) {\n-                    throw new IllegalArgumentException(\"Can only convert file URL to a File: \" + url);\n+        final File[] array2 = new File[array.length];\n+        for (int i = 0; i < array.length; ++i) {\n+            final URL obj = array[i];\n+            if (obj != null) {\n+                if (!\"file\".equalsIgnoreCase(obj.getProtocol())) {\n+                    throw new IllegalArgumentException(\"Can only convert file URL to a File: \" + obj);\n                 }\n-                files[i] = toFile(url);\n+                array2[i] = toFile(obj);\n             }\n         }\n-        return files;\n+        return array2;\n     }\n     \n     private static List<File> toList(final Stream<File> stream) {\n         return stream.collect((Collector<? super File, ?, List<File>>)Collectors.toList());\n     }\n     \n-    private static int toMaxDepth(final boolean recursive) {\n-        return recursive ? Integer.MAX_VALUE : 1;\n+    private static int toMaxDepth(final boolean b) {\n+        return b ? Integer.MAX_VALUE : 1;\n     }\n     \n-    private static String[] toSuffixes(final String... extensions) {\n-        return Stream.of((Object[])(T[])Objects.requireNonNull((T[])extensions, \"extensions\")).map(e -> \".\" + e).toArray(String[]::new);\n+    private static String[] toSuffixes(final String... obj) {\n+        return Stream.of((Object[])(T[])Objects.requireNonNull((T[])obj, \"extensions\")).map(str -> \".\" + str).toArray(String[]::new);\n     }\n     \n-    public static void touch(final File file) throws IOException {\n-        PathUtils.touch(((File)Objects.requireNonNull(file, \"file\")).toPath());\n+    public static void touch(final File obj) throws IOException {\n+        PathUtils.touch(((File)Objects.requireNonNull(obj, \"file\")).toPath());\n     }\n     \n-    public static URL[] toURLs(final File... files) throws IOException {\n-        Objects.requireNonNull(files, \"files\");\n-        final URL[] urls = new URL[files.length];\n-        for (int i = 0; i < urls.length; ++i) {\n-            urls[i] = files[i].toURI().toURL();\n+    public static URL[] toURLs(final File... obj) throws IOException {\n+        Objects.requireNonNull(obj, \"files\");\n+        final URL[] array = new URL[obj.length];\n+        for (int i = 0; i < array.length; ++i) {\n+            array[i] = obj[i].toURI().toURL();\n         }\n-        return urls;\n+        return array;\n     }\n     \n-    private static void validateMoveParameters(final File source, final File destination) throws FileNotFoundException {\n-        Objects.requireNonNull(source, \"source\");\n-        Objects.requireNonNull(destination, \"destination\");\n-        if (!source.exists()) {\n-            throw new FileNotFoundException(\"Source '\" + source + \"' does not exist\");\n+    private static void validateMoveParameters(final File file, final File obj) throws FileNotFoundException {\n+        Objects.requireNonNull(file, \"source\");\n+        Objects.requireNonNull(obj, \"destination\");\n+        if (!file.exists()) {\n+            throw new FileNotFoundException(\"Source '\" + file + \"' does not exist\");\n         }\n     }\n     \n-    public static boolean waitFor(final File file, final int seconds) {\n-        Objects.requireNonNull(file, \"file\");\n-        return PathUtils.waitFor(file.toPath(), Duration.ofSeconds((long)seconds), PathUtils.EMPTY_LINK_OPTION_ARRAY);\n+    public static boolean waitFor(final File obj, final int n) {\n+        Objects.requireNonNull(obj, \"file\");\n+        return PathUtils.waitFor(obj.toPath(), Duration.ofSeconds((long)n), PathUtils.EMPTY_LINK_OPTION_ARRAY);\n     }\n     \n     @Deprecated\n-    public static void write(final File file, final CharSequence data) throws IOException {\n-        write(file, data, Charset.defaultCharset(), false);\n+    public static void write(final File file, final CharSequence charSequence) throws IOException {\n+        write(file, charSequence, Charset.defaultCharset(), false);\n     }\n     \n     @Deprecated\n-    public static void write(final File file, final CharSequence data, final boolean append) throws IOException {\n-        write(file, data, Charset.defaultCharset(), append);\n+    public static void write(final File file, final CharSequence charSequence, final boolean b) throws IOException {\n+        write(file, charSequence, Charset.defaultCharset(), b);\n     }\n     \n-    public static void write(final File file, final CharSequence data, final Charset charset) throws IOException {\n-        write(file, data, charset, false);\n+    public static void write(final File file, final CharSequence charSequence, final Charset charset) throws IOException {\n+        write(file, charSequence, charset, false);\n     }\n     \n-    public static void write(final File file, final CharSequence data, final Charset charset, final boolean append) throws IOException {\n-        writeStringToFile(file, Objects.toString((Object)data, (String)null), charset, append);\n+    public static void write(final File file, final CharSequence o, final Charset charset, final boolean b) throws IOException {\n+        writeStringToFile(file, Objects.toString((Object)o, (String)null), charset, b);\n     }\n     \n-    public static void write(final File file, final CharSequence data, final String charsetName) throws IOException {\n-        write(file, data, charsetName, false);\n+    public static void write(final File file, final CharSequence charSequence, final String s) throws IOException {\n+        write(file, charSequence, s, false);\n     }\n     \n-    public static void write(final File file, final CharSequence data, final String charsetName, final boolean append) throws IOException {\n-        write(file, data, Charsets.toCharset(charsetName), append);\n+    public static void write(final File file, final CharSequence charSequence, final String s, final boolean b) throws IOException {\n+        write(file, charSequence, Charsets.toCharset(s), b);\n     }\n     \n-    public static void writeByteArrayToFile(final File file, final byte[] data) throws IOException {\n-        writeByteArrayToFile(file, data, false);\n+    public static void writeByteArrayToFile(final File file, final byte[] array) throws IOException {\n+        writeByteArrayToFile(file, array, false);\n     }\n     \n-    public static void writeByteArrayToFile(final File file, final byte[] data, final boolean append) throws IOException {\n-        writeByteArrayToFile(file, data, 0, data.length, append);\n+    public static void writeByteArrayToFile(final File file, final byte[] array, final boolean b) throws IOException {\n+        writeByteArrayToFile(file, array, 0, array.length, b);\n     }\n     \n-    public static void writeByteArrayToFile(final File file, final byte[] data, final int off, final int len) throws IOException {\n-        writeByteArrayToFile(file, data, off, len, false);\n+    public static void writeByteArrayToFile(final File file, final byte[] array, final int n, final int n2) throws IOException {\n+        writeByteArrayToFile(file, array, n, n2, false);\n     }\n     \n-    public static void writeByteArrayToFile(final File file, final byte[] data, final int off, final int len, final boolean append) throws IOException {\n-        try (final OutputStream out = newOutputStream(file, append)) {\n-            out.write(data, off, len);\n+    public static void writeByteArrayToFile(final File file, final byte[] b, final int off, final int len, final boolean b2) throws IOException {\n+        try (final OutputStream outputStream = newOutputStream(file, b2)) {\n+            outputStream.write(b, off, len);\n         }\n     }\n     \n-    public static void writeLines(final File file, final Collection<?> lines) throws IOException {\n-        writeLines(file, null, lines, null, false);\n+    public static void writeLines(final File file, final Collection<?> collection) throws IOException {\n+        writeLines(file, null, collection, null, false);\n     }\n     \n-    public static void writeLines(final File file, final Collection<?> lines, final boolean append) throws IOException {\n-        writeLines(file, null, lines, null, append);\n+    public static void writeLines(final File file, final Collection<?> collection, final boolean b) throws IOException {\n+        writeLines(file, null, collection, null, b);\n     }\n     \n-    public static void writeLines(final File file, final Collection<?> lines, final String lineEnding) throws IOException {\n-        writeLines(file, null, lines, lineEnding, false);\n+    public static void writeLines(final File file, final Collection<?> collection, final String s) throws IOException {\n+        writeLines(file, null, collection, s, false);\n     }\n     \n-    public static void writeLines(final File file, final Collection<?> lines, final String lineEnding, final boolean append) throws IOException {\n-        writeLines(file, null, lines, lineEnding, append);\n+    public static void writeLines(final File file, final Collection<?> collection, final String s, final boolean b) throws IOException {\n+        writeLines(file, null, collection, s, b);\n     }\n     \n-    public static void writeLines(final File file, final String charsetName, final Collection<?> lines) throws IOException {\n-        writeLines(file, charsetName, lines, null, false);\n+    public static void writeLines(final File file, final String s, final Collection<?> collection) throws IOException {\n+        writeLines(file, s, collection, null, false);\n     }\n     \n-    public static void writeLines(final File file, final String charsetName, final Collection<?> lines, final boolean append) throws IOException {\n-        writeLines(file, charsetName, lines, null, append);\n+    public static void writeLines(final File file, final String s, final Collection<?> collection, final boolean b) throws IOException {\n+        writeLines(file, s, collection, null, b);\n     }\n     \n-    public static void writeLines(final File file, final String charsetName, final Collection<?> lines, final String lineEnding) throws IOException {\n-        writeLines(file, charsetName, lines, lineEnding, false);\n+    public static void writeLines(final File file, final String s, final Collection<?> collection, final String s2) throws IOException {\n+        writeLines(file, s, collection, s2, false);\n     }\n     \n-    public static void writeLines(final File file, final String charsetName, final Collection<?> lines, final String lineEnding, final boolean append) throws IOException {\n-        try (final OutputStream out = new BufferedOutputStream(newOutputStream(file, append))) {\n-            IOUtils.writeLines((Collection)lines, lineEnding, out, charsetName);\n+    public static void writeLines(final File file, final String s, final Collection<?> collection, final String s2, final boolean b) throws IOException {\n+        try (final BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(newOutputStream(file, b))) {\n+            IOUtils.writeLines((Collection)collection, s2, (OutputStream)bufferedOutputStream, s);\n         }\n     }\n     \n     @Deprecated\n-    public static void writeStringToFile(final File file, final String data) throws IOException {\n-        writeStringToFile(file, data, Charset.defaultCharset(), false);\n+    public static void writeStringToFile(final File file, final String s) throws IOException {\n+        writeStringToFile(file, s, Charset.defaultCharset(), false);\n     }\n     \n     @Deprecated\n-    public static void writeStringToFile(final File file, final String data, final boolean append) throws IOException {\n-        writeStringToFile(file, data, Charset.defaultCharset(), append);\n+    public static void writeStringToFile(final File file, final String s, final boolean b) throws IOException {\n+        writeStringToFile(file, s, Charset.defaultCharset(), b);\n     }\n     \n-    public static void writeStringToFile(final File file, final String data, final Charset charset) throws IOException {\n-        writeStringToFile(file, data, charset, false);\n+    public static void writeStringToFile(final File file, final String s, final Charset charset) throws IOException {\n+        writeStringToFile(file, s, charset, false);\n     }\n     \n-    public static void writeStringToFile(final File file, final String data, final Charset charset, final boolean append) throws IOException {\n-        try (final OutputStream out = newOutputStream(file, append)) {\n-            IOUtils.write(data, out, charset);\n+    public static void writeStringToFile(final File file, final String s, final Charset charset, final boolean b) throws IOException {\n+        try (final OutputStream outputStream = newOutputStream(file, b)) {\n+            IOUtils.write(s, outputStream, charset);\n         }\n     }\n     \n-    public static void writeStringToFile(final File file, final String data, final String charsetName) throws IOException {\n-        writeStringToFile(file, data, charsetName, false);\n+    public static void writeStringToFile(final File file, final String s, final String s2) throws IOException {\n+        writeStringToFile(file, s, s2, false);\n     }\n     \n-    public static void writeStringToFile(final File file, final String data, final String charsetName, final boolean append) throws IOException {\n-        writeStringToFile(file, data, Charsets.toCharset(charsetName), append);\n+    public static void writeStringToFile(final File file, final String s, final String s2, final boolean b) throws IOException {\n+        writeStringToFile(file, s, Charsets.toCharset(s2), b);\n     }\n     \n     @Deprecated\n     public FileUtils() {\n     }\n     \n     static {\n"}]}
