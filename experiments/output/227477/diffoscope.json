{"diffoscope-json-version": 1, "source1": "first/JavadocMethodCheck.class", "source2": "second/JavadocMethodCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -11,15 +11,14 @@\n import java.util.Iterator;\n import java.util.List;\n import java.util.Collection;\n import com.puppycrawl.tools.checkstyle.utils.AnnotationUtil;\n import java.util.Arrays;\n import com.puppycrawl.tools.checkstyle.utils.CheckUtil;\n import com.puppycrawl.tools.checkstyle.api.TextBlock;\n-import com.puppycrawl.tools.checkstyle.api.FileContents;\n import com.puppycrawl.tools.checkstyle.api.DetailAST;\n import com.puppycrawl.tools.checkstyle.utils.UnmodifiableCollectionUtil;\n import java.util.Set;\n import com.puppycrawl.tools.checkstyle.checks.naming.AccessModifierOption;\n import java.util.regex.Pattern;\n import com.puppycrawl.tools.checkstyle.StatelessCheck;\n import com.puppycrawl.tools.checkstyle.api.AbstractCheck;\n@@ -51,395 +50,375 @@\n     private Set<String> allowedAnnotations;\n     \n     public JavadocMethodCheck() {\n         this.accessModifiers = new AccessModifierOption[] { AccessModifierOption.PUBLIC, AccessModifierOption.PROTECTED, AccessModifierOption.PACKAGE, AccessModifierOption.PRIVATE };\n         this.allowedAnnotations = Set.of(\"Override\");\n     }\n     \n-    public void setValidateThrows(final boolean value) {\n-        this.validateThrows = value;\n+    public void setValidateThrows(final boolean validateThrows) {\n+        this.validateThrows = validateThrows;\n     }\n     \n-    public void setAllowedAnnotations(final String... userAnnotations) {\n-        this.allowedAnnotations = Set.of(userAnnotations);\n+    public void setAllowedAnnotations(final String... elements) {\n+        this.allowedAnnotations = Set.of(elements);\n     }\n     \n-    public void setAccessModifiers(final AccessModifierOption... accessModifiers) {\n-        this.accessModifiers = (AccessModifierOption[])UnmodifiableCollectionUtil.copyOfArray((Object[])accessModifiers, accessModifiers.length);\n+    public void setAccessModifiers(final AccessModifierOption... array) {\n+        this.accessModifiers = (AccessModifierOption[])UnmodifiableCollectionUtil.copyOfArray((Object[])array, array.length);\n     }\n     \n-    public void setAllowMissingParamTags(final boolean flag) {\n-        this.allowMissingParamTags = flag;\n+    public void setAllowMissingParamTags(final boolean allowMissingParamTags) {\n+        this.allowMissingParamTags = allowMissingParamTags;\n     }\n     \n-    public void setAllowMissingReturnTag(final boolean flag) {\n-        this.allowMissingReturnTag = flag;\n+    public void setAllowMissingReturnTag(final boolean allowMissingReturnTag) {\n+        this.allowMissingReturnTag = allowMissingReturnTag;\n     }\n     \n     public final int[] getRequiredTokens() {\n         return new int[] { 14, 15, 154, 199 };\n     }\n     \n     public int[] getDefaultTokens() {\n         return this.getAcceptableTokens();\n     }\n     \n     public int[] getAcceptableTokens() {\n         return new int[] { 14, 154, 15, 9, 8, 161, 199, 203 };\n     }\n     \n-    public final void visitToken(final DetailAST ast) {\n-        if (ast.getType() == 9 || ast.getType() == 8 || ast.getType() == 161 || ast.getType() == 203) {\n-            this.processAST(ast);\n+    public final void visitToken(final DetailAST detailAST) {\n+        if (detailAST.getType() == 9 || detailAST.getType() == 8 || detailAST.getType() == 161 || detailAST.getType() == 203) {\n+            this.processAST(detailAST);\n         }\n     }\n     \n-    private void processAST(final DetailAST ast) {\n-        if (this.shouldCheck(ast)) {\n-            final FileContents contents = this.getFileContents();\n-            final TextBlock textBlock = contents.getJavadocBefore(ast.getLineNo());\n-            if (textBlock != null) {\n-                this.checkComment(ast, textBlock);\n+    private void processAST(final DetailAST detailAST) {\n+        if (this.shouldCheck(detailAST)) {\n+            final TextBlock javadocBefore = this.getFileContents().getJavadocBefore(detailAST.getLineNo());\n+            if (javadocBefore != null) {\n+                this.checkComment(detailAST, javadocBefore);\n             }\n         }\n     }\n     \n-    private boolean shouldCheck(final DetailAST ast) {\n-        final AccessModifierOption surroundingAccessModifier = CheckUtil.getSurroundingAccessModifier(ast);\n-        final AccessModifierOption accessModifier = CheckUtil.getAccessModifierFromModifiersToken(ast);\n-        return surroundingAccessModifier != null && Arrays.stream(this.accessModifiers).anyMatch(modifier -> modifier == surroundingAccessModifier) && Arrays.stream(this.accessModifiers).anyMatch(modifier -> modifier == accessModifier);\n+    private boolean shouldCheck(final DetailAST detailAST) {\n+        final AccessModifierOption surroundingAccessModifier = CheckUtil.getSurroundingAccessModifier(detailAST);\n+        CheckUtil.getAccessModifierFromModifiersToken(detailAST);\n+        return surroundingAccessModifier != null && Arrays.stream(this.accessModifiers).anyMatch(accessModifierOption2 -> accessModifierOption2 == accessModifierOption) && Arrays.stream(this.accessModifiers).anyMatch(accessModifierOption4 -> accessModifierOption4 == accessModifierOption3);\n     }\n     \n-    private void checkComment(final DetailAST ast, final TextBlock comment) {\n-        final List<JavadocTag> tags = getMethodTags(comment);\n-        if (!this.hasShortCircuitTag(ast, tags)) {\n-            if (ast.getType() == 161) {\n-                this.checkReturnTag(tags, ast.getLineNo(), true);\n+    private void checkComment(final DetailAST detailAST, final TextBlock textBlock) {\n+        final List<JavadocTag> methodTags = getMethodTags(textBlock);\n+        if (!this.hasShortCircuitTag(detailAST, methodTags)) {\n+            if (detailAST.getType() == 161) {\n+                this.checkReturnTag(methodTags, detailAST.getLineNo(), true);\n             }\n             else {\n-                Iterator<JavadocTag> it;\n-                boolean hasInheritDocTag;\n-                for (it = tags.iterator(), hasInheritDocTag = false; !hasInheritDocTag && it.hasNext(); hasInheritDocTag = ((JavadocTag)it.next()).isInheritDocTag()) {}\n-                final boolean reportExpectedTags = !hasInheritDocTag && !AnnotationUtil.containsAnnotation(ast, (Set)this.allowedAnnotations);\n-                if (ast.getType() != 203) {\n-                    this.checkParamTags(tags, ast, reportExpectedTags);\n+                Iterator<Object> iterator;\n+                boolean inheritDocTag;\n+                for (iterator = methodTags.iterator(), inheritDocTag = false; !inheritDocTag && iterator.hasNext(); inheritDocTag = ((JavadocTag)iterator.next()).isInheritDocTag()) {}\n+                final boolean b = !inheritDocTag && !AnnotationUtil.containsAnnotation(detailAST, (Set)this.allowedAnnotations);\n+                if (detailAST.getType() != 203) {\n+                    this.checkParamTags(methodTags, detailAST, b);\n                 }\n-                final List<JavadocMethodCheck.ExceptionInfo> throwed = combineExceptionInfo(getThrows(ast), getThrowed(ast));\n-                this.checkThrowsTags(tags, throwed, reportExpectedTags);\n-                if (CheckUtil.isNonVoidMethod(ast)) {\n-                    this.checkReturnTag(tags, ast.getLineNo(), reportExpectedTags);\n+                this.checkThrowsTags(methodTags, combineExceptionInfo((Collection<JavadocMethodCheck.ExceptionInfo>)getThrows(detailAST), (Iterable<JavadocMethodCheck.ExceptionInfo>)getThrowed(detailAST)), b);\n+                if (CheckUtil.isNonVoidMethod(detailAST)) {\n+                    this.checkReturnTag(methodTags, detailAST.getLineNo(), b);\n                 }\n             }\n-            tags.stream().filter(javadocTag -> !javadocTag.isSeeOrInheritDocTag()).forEach(javadocTag -> this.log(javadocTag.getLineNo(), \"javadoc.unusedTagGeneral\", new Object[0]));\n+            methodTags.stream().filter(javadocTag -> !javadocTag.isSeeOrInheritDocTag()).forEach(javadocTag2 -> this.log(javadocTag2.getLineNo(), \"javadoc.unusedTagGeneral\", new Object[0]));\n         }\n     }\n     \n-    private boolean hasShortCircuitTag(final DetailAST ast, final List<JavadocTag> tags) {\n-        boolean result = true;\n-        if (tags.size() == 1 && ((JavadocTag)tags.get(0)).isInheritDocTag()) {\n-            if (!JavadocTagInfo.INHERIT_DOC.isValidOn(ast)) {\n-                this.log(ast, \"javadoc.invalidInheritDoc\", new Object[0]);\n+    private boolean hasShortCircuitTag(final DetailAST detailAST, final List<JavadocTag> list) {\n+        boolean b = true;\n+        if (list.size() == 1 && ((JavadocTag)list.get(0)).isInheritDocTag()) {\n+            if (!JavadocTagInfo.INHERIT_DOC.isValidOn(detailAST)) {\n+                this.log(detailAST, \"javadoc.invalidInheritDoc\", new Object[0]);\n             }\n         }\n         else {\n-            result = false;\n+            b = false;\n         }\n-        return result;\n+        return b;\n     }\n     \n-    private static List<JavadocTag> getMethodTags(final TextBlock comment) {\n-        final String[] lines = comment.getText();\n-        final List<JavadocTag> tags = new ArrayList<JavadocTag>();\n-        int currentLine = comment.getStartLineNo() - 1;\n-        final int startColumnNumber = comment.getStartColNo();\n-        for (int i = 0; i < lines.length; ++i) {\n-            ++currentLine;\n-            final Matcher javadocArgMatcher = JavadocMethodCheck.MATCH_JAVADOC_ARG.matcher(lines[i]);\n-            final Matcher javadocArgMissingDescriptionMatcher = JavadocMethodCheck.MATCH_JAVADOC_ARG_MISSING_DESCRIPTION.matcher(lines[i]);\n-            final Matcher javadocNoargMatcher = JavadocMethodCheck.MATCH_JAVADOC_NOARG.matcher(lines[i]);\n-            final Matcher noargCurlyMatcher = JavadocMethodCheck.MATCH_JAVADOC_NOARG_CURLY.matcher(lines[i]);\n-            final Matcher noargMultilineStart = JavadocMethodCheck.MATCH_JAVADOC_NOARG_MULTILINE_START.matcher(lines[i]);\n-            if (javadocArgMatcher.find()) {\n-                final int col = calculateTagColumn(javadocArgMatcher, i, startColumnNumber);\n-                tags.add(new JavadocTag(currentLine, col, javadocArgMatcher.group(1), javadocArgMatcher.group(2)));\n+    private static List<JavadocTag> getMethodTags(final TextBlock textBlock) {\n+        final String[] text = textBlock.getText();\n+        final ArrayList list = new ArrayList();\n+        int n = textBlock.getStartLineNo() - 1;\n+        final int startColNo = textBlock.getStartColNo();\n+        for (int i = 0; i < text.length; ++i) {\n+            ++n;\n+            final Matcher matcher = JavadocMethodCheck.MATCH_JAVADOC_ARG.matcher(text[i]);\n+            final Matcher matcher2 = JavadocMethodCheck.MATCH_JAVADOC_ARG_MISSING_DESCRIPTION.matcher(text[i]);\n+            final Matcher matcher3 = JavadocMethodCheck.MATCH_JAVADOC_NOARG.matcher(text[i]);\n+            final Matcher matcher4 = JavadocMethodCheck.MATCH_JAVADOC_NOARG_CURLY.matcher(text[i]);\n+            final Matcher matcher5 = JavadocMethodCheck.MATCH_JAVADOC_NOARG_MULTILINE_START.matcher(text[i]);\n+            if (matcher.find()) {\n+                list.add(new JavadocTag(n, calculateTagColumn(matcher, i, startColNo), matcher.group(1), matcher.group(2)));\n             }\n-            else if (javadocArgMissingDescriptionMatcher.find()) {\n-                final int col = calculateTagColumn(javadocArgMissingDescriptionMatcher, i, startColumnNumber);\n-                tags.add(new JavadocTag(currentLine, col, javadocArgMissingDescriptionMatcher.group(1), javadocArgMissingDescriptionMatcher.group(2)));\n+            else if (matcher2.find()) {\n+                list.add(new JavadocTag(n, calculateTagColumn(matcher2, i, startColNo), matcher2.group(1), matcher2.group(2)));\n             }\n-            else if (javadocNoargMatcher.find()) {\n-                final int col = calculateTagColumn(javadocNoargMatcher, i, startColumnNumber);\n-                tags.add(new JavadocTag(currentLine, col, javadocNoargMatcher.group(1)));\n+            else if (matcher3.find()) {\n+                list.add(new JavadocTag(n, calculateTagColumn(matcher3, i, startColNo), matcher3.group(1)));\n             }\n-            else if (noargCurlyMatcher.find()) {\n-                final int col = calculateTagColumn(noargCurlyMatcher, i, startColumnNumber);\n-                tags.add(new JavadocTag(currentLine, col, noargCurlyMatcher.group(1)));\n+            else if (matcher4.find()) {\n+                list.add(new JavadocTag(n, calculateTagColumn(matcher4, i, startColNo), matcher4.group(1)));\n             }\n-            else if (noargMultilineStart.find()) {\n-                tags.addAll(getMultilineNoArgTags(noargMultilineStart, lines, i, currentLine));\n+            else if (matcher5.find()) {\n+                list.addAll(getMultilineNoArgTags(matcher5, text, i, n));\n             }\n         }\n-        return tags;\n+        return list;\n     }\n     \n-    private static int calculateTagColumn(final MatchResult javadocTagMatchResult, final int lineNumber, final int startColumnNumber) {\n-        int col = javadocTagMatchResult.start(1) - 1;\n-        if (lineNumber == 0) {\n-            col += startColumnNumber;\n+    private static int calculateTagColumn(final MatchResult matchResult, final int n, final int n2) {\n+        int n3 = matchResult.start(1) - 1;\n+        if (n == 0) {\n+            n3 += n2;\n         }\n-        return col;\n+        return n3;\n     }\n     \n-    private static List<JavadocTag> getMultilineNoArgTags(final Matcher noargMultilineStart, final String[] lines, final int lineIndex, final int tagLine) {\n-        int remIndex = lineIndex;\n-        Matcher multilineCont;\n+    private static List<JavadocTag> getMultilineNoArgTags(final Matcher matcher, final String[] array, final int n, final int n2) {\n+        int n3 = n;\n+        Matcher matcher2;\n         do {\n-            ++remIndex;\n-            multilineCont = JavadocMethodCheck.MATCH_JAVADOC_MULTILINE_CONT.matcher(lines[remIndex]);\n-        } while (!multilineCont.find());\n-        final List<JavadocTag> tags = new ArrayList<JavadocTag>();\n-        final String lFin = multilineCont.group(1);\n-        if (!\"@\".equals(lFin) && !\"*/\".equals(lFin)) {\n-            final String param1 = noargMultilineStart.group(1);\n-            final int col = noargMultilineStart.start(1) - 1;\n-            tags.add(new JavadocTag(tagLine, col, param1));\n-        }\n-        return tags;\n-    }\n-    \n-    private static List<DetailAST> getParameters(final DetailAST ast) {\n-        final DetailAST params = ast.findFirstToken(20);\n-        final List<DetailAST> returnValue = new ArrayList<DetailAST>();\n-        for (DetailAST child = params.getFirstChild(); child != null; child = child.getNextSibling()) {\n-            if (child.getType() == 21) {\n-                final DetailAST ident = child.findFirstToken(58);\n-                if (ident != null) {\n-                    returnValue.add(ident);\n+            ++n3;\n+            matcher2 = JavadocMethodCheck.MATCH_JAVADOC_MULTILINE_CONT.matcher(array[n3]);\n+        } while (!matcher2.find());\n+        final ArrayList list = new ArrayList();\n+        final String group = matcher2.group(1);\n+        if (!\"@\".equals(group) && !\"*/\".equals(group)) {\n+            list.add(new JavadocTag(n2, matcher.start(1) - 1, matcher.group(1)));\n+        }\n+        return list;\n+    }\n+    \n+    private static List<DetailAST> getParameters(final DetailAST detailAST) {\n+        final DetailAST firstToken = detailAST.findFirstToken(20);\n+        final ArrayList list = new ArrayList();\n+        for (DetailAST detailAST2 = firstToken.getFirstChild(); detailAST2 != null; detailAST2 = detailAST2.getNextSibling()) {\n+            if (detailAST2.getType() == 21) {\n+                final DetailAST firstToken2 = detailAST2.findFirstToken(58);\n+                if (firstToken2 != null) {\n+                    list.add(firstToken2);\n                 }\n             }\n         }\n-        return returnValue;\n+        return list;\n     }\n     \n-    private static List<JavadocMethodCheck.ExceptionInfo> getThrows(final DetailAST ast) {\n-        final List<JavadocMethodCheck.ExceptionInfo> returnValue = new ArrayList<JavadocMethodCheck.ExceptionInfo>();\n-        final DetailAST throwsAST = ast.findFirstToken(81);\n-        if (throwsAST != null) {\n-            for (DetailAST child = throwsAST.getFirstChild(); child != null; child = child.getNextSibling()) {\n-                if (child.getType() == 58 || child.getType() == 59) {\n-                    returnValue.add(getExceptionInfo(child));\n+    private static List<JavadocMethodCheck.ExceptionInfo> getThrows(final DetailAST detailAST) {\n+        final ArrayList list = new ArrayList();\n+        final DetailAST firstToken = detailAST.findFirstToken(81);\n+        if (firstToken != null) {\n+            for (DetailAST detailAST2 = firstToken.getFirstChild(); detailAST2 != null; detailAST2 = detailAST2.getNextSibling()) {\n+                if (detailAST2.getType() == 58 || detailAST2.getType() == 59) {\n+                    list.add(getExceptionInfo(detailAST2));\n                 }\n             }\n         }\n-        return returnValue;\n+        return list;\n     }\n     \n-    private static List<JavadocMethodCheck.ExceptionInfo> getThrowed(final DetailAST methodAst) {\n-        final List<JavadocMethodCheck.ExceptionInfo> returnValue = new ArrayList<JavadocMethodCheck.ExceptionInfo>();\n-        final DetailAST blockAst = methodAst.findFirstToken(7);\n-        if (blockAst != null) {\n-            final List<DetailAST> throwLiterals = findTokensInAstByType(blockAst, 90);\n-            for (final DetailAST throwAst : throwLiterals) {\n-                if (!isInIgnoreBlock(blockAst, throwAst)) {\n-                    final DetailAST newAst = throwAst.getFirstChild().getFirstChild();\n-                    if (newAst.getType() != 136) {\n+    private static List<JavadocMethodCheck.ExceptionInfo> getThrowed(final DetailAST detailAST) {\n+        final ArrayList list = new ArrayList();\n+        final DetailAST firstToken = detailAST.findFirstToken(7);\n+        if (firstToken != null) {\n+            for (final DetailAST detailAST2 : findTokensInAstByType(firstToken, 90)) {\n+                if (!isInIgnoreBlock(firstToken, detailAST2)) {\n+                    final DetailAST firstChild = detailAST2.getFirstChild().getFirstChild();\n+                    if (firstChild.getType() != 136) {\n                         continue;\n                     }\n-                    final DetailAST child = newAst.getFirstChild();\n-                    returnValue.add(getExceptionInfo(child));\n+                    list.add(getExceptionInfo(firstChild.getFirstChild()));\n                 }\n             }\n         }\n-        return returnValue;\n+        return list;\n     }\n     \n-    private static JavadocMethodCheck.ExceptionInfo getExceptionInfo(final DetailAST ast) {\n-        final FullIdent ident = FullIdent.createFullIdent(ast);\n-        final DetailAST firstClassNameNode = getFirstClassNameNode(ast);\n-        return new JavadocMethodCheck.ExceptionInfo(firstClassNameNode, new JavadocMethodCheck.ClassInfo(new JavadocMethodCheck.Token(ident)));\n+    private static JavadocMethodCheck.ExceptionInfo getExceptionInfo(final DetailAST detailAST) {\n+        return new JavadocMethodCheck.ExceptionInfo(getFirstClassNameNode(detailAST), new JavadocMethodCheck.ClassInfo(new JavadocMethodCheck.Token(FullIdent.createFullIdent(detailAST))));\n     }\n     \n-    private static DetailAST getFirstClassNameNode(final DetailAST ast) {\n-        DetailAST startNode;\n-        for (startNode = ast; startNode.getType() == 59; startNode = startNode.getFirstChild()) {}\n-        return startNode;\n+    private static DetailAST getFirstClassNameNode(final DetailAST detailAST) {\n+        DetailAST firstChild;\n+        for (firstChild = detailAST; firstChild.getType() == 59; firstChild = firstChild.getFirstChild()) {}\n+        return firstChild;\n     }\n     \n-    private static boolean isInIgnoreBlock(final DetailAST methodBodyAst, final DetailAST throwAst) {\n-        DetailAST ancestor;\n-        for (ancestor = throwAst.getParent(); ancestor != methodBodyAst && (ancestor.getType() != 95 || ancestor.findFirstToken(96) == null) && ancestor.getType() != 181 && ancestor.getType() != 6; ancestor = ancestor.getParent()) {\n-            if (ancestor.getType() == 96 || ancestor.getType() == 97) {\n-                ancestor = ancestor.getParent();\n+    private static boolean isInIgnoreBlock(final DetailAST detailAST, final DetailAST detailAST2) {\n+        DetailAST detailAST3;\n+        for (detailAST3 = detailAST2.getParent(); detailAST3 != detailAST && (detailAST3.getType() != 95 || detailAST3.findFirstToken(96) == null) && detailAST3.getType() != 181 && detailAST3.getType() != 6; detailAST3 = detailAST3.getParent()) {\n+            if (detailAST3.getType() == 96 || detailAST3.getType() == 97) {\n+                detailAST3 = detailAST3.getParent();\n             }\n         }\n-        return ancestor != methodBodyAst;\n+        return detailAST3 != detailAST;\n     }\n     \n-    private static List<JavadocMethodCheck.ExceptionInfo> combineExceptionInfo(final Collection<JavadocMethodCheck.ExceptionInfo> first, final Iterable<JavadocMethodCheck.ExceptionInfo> second) {\n-        final List<JavadocMethodCheck.ExceptionInfo> result = new ArrayList<JavadocMethodCheck.ExceptionInfo>(first);\n-        for (final JavadocMethodCheck.ExceptionInfo exceptionInfo : second) {\n-            if (result.stream().noneMatch(item -> isExceptionInfoSame(item, exceptionInfo))) {\n-                result.add(exceptionInfo);\n+    private static List<JavadocMethodCheck.ExceptionInfo> combineExceptionInfo(final Collection<JavadocMethodCheck.ExceptionInfo> c, final Iterable<JavadocMethodCheck.ExceptionInfo> iterable) {\n+        final ArrayList list = new ArrayList((Collection<? extends E>)c);\n+        for (final JavadocMethodCheck.ExceptionInfo exceptionInfo : iterable) {\n+            if (list.stream().noneMatch(exceptionInfo3 -> isExceptionInfoSame(exceptionInfo3, exceptionInfo2))) {\n+                list.add(exceptionInfo);\n             }\n         }\n-        return result;\n+        return list;\n     }\n     \n-    public static List<DetailAST> findTokensInAstByType(final DetailAST root, final int astType) {\n-        final List<DetailAST> result = new ArrayList<DetailAST>();\n-        DetailAST curNode = root;\n+    public static List<DetailAST> findTokensInAstByType(final DetailAST detailAST, final int n) {\n+        final ArrayList list = new ArrayList();\n+        DetailAST detailAST2 = detailAST;\n         do {\n-            if (curNode.getType() == astType) {\n-                result.add(curNode);\n+            if (detailAST2.getType() == n) {\n+                list.add(detailAST2);\n             }\n-            if (curNode.hasChildren()) {\n-                curNode = curNode.getFirstChild();\n+            if (detailAST2.hasChildren()) {\n+                detailAST2 = detailAST2.getFirstChild();\n             }\n             else {\n-                while (curNode != root && curNode.getNextSibling() == null) {\n-                    curNode = curNode.getParent();\n+                while (detailAST2 != detailAST && detailAST2.getNextSibling() == null) {\n+                    detailAST2 = detailAST2.getParent();\n                 }\n-                if (curNode == root) {\n+                if (detailAST2 == detailAST) {\n                     continue;\n                 }\n-                curNode = curNode.getNextSibling();\n+                detailAST2 = detailAST2.getNextSibling();\n             }\n-        } while (curNode != root);\n-        return result;\n+        } while (detailAST2 != detailAST);\n+        return list;\n     }\n     \n-    private void checkParamTags(final List<JavadocTag> tags, final DetailAST parent, final boolean reportExpectedTags) {\n-        final List<DetailAST> params = getParameters(parent);\n-        final List<DetailAST> typeParams = CheckUtil.getTypeParameters(parent);\n-        final ListIterator<JavadocTag> tagIt = tags.listIterator();\n-        while (tagIt.hasNext()) {\n-            final JavadocTag tag = (JavadocTag)tagIt.next();\n-            if (!tag.isParamTag()) {\n+    private void checkParamTags(final List<JavadocTag> list, final DetailAST detailAST, final boolean b) {\n+        final List<DetailAST> parameters = getParameters(detailAST);\n+        final List typeParameters = CheckUtil.getTypeParameters(detailAST);\n+        final ListIterator<JavadocTag> listIterator = list.listIterator();\n+        while (listIterator.hasNext()) {\n+            final JavadocTag javadocTag = (JavadocTag)listIterator.next();\n+            if (!javadocTag.isParamTag()) {\n                 continue;\n             }\n-            tagIt.remove();\n-            final String arg1 = tag.getFirstArg();\n-            boolean found = removeMatchingParam(params, arg1);\n-            if (arg1.startsWith(\"<\") && arg1.endsWith(\">\")) {\n-                found = searchMatchingTypeParameter(typeParams, arg1.substring(1, arg1.length() - 1));\n+            listIterator.remove();\n+            final String firstArg = javadocTag.getFirstArg();\n+            boolean b2 = removeMatchingParam(parameters, firstArg);\n+            if (firstArg.startsWith(\"<\") && firstArg.endsWith(\">\")) {\n+                b2 = searchMatchingTypeParameter(typeParameters, firstArg.substring(1, firstArg.length() - 1));\n             }\n-            if (found) {\n+            if (b2) {\n                 continue;\n             }\n-            this.log(tag.getLineNo(), tag.getColumnNo(), \"javadoc.unusedTag\", new Object[] { \"@param\", arg1 });\n+            this.log(javadocTag.getLineNo(), javadocTag.getColumnNo(), \"javadoc.unusedTag\", new Object[] { \"@param\", firstArg });\n         }\n-        if (!this.allowMissingParamTags && reportExpectedTags) {\n-            for (final DetailAST param : params) {\n-                this.log(param, \"javadoc.expectedTag\", new Object[] { JavadocTagInfo.PARAM.getText(), param.getText() });\n+        if (!this.allowMissingParamTags && b) {\n+            for (final DetailAST detailAST2 : parameters) {\n+                this.log(detailAST2, \"javadoc.expectedTag\", new Object[] { JavadocTagInfo.PARAM.getText(), detailAST2.getText() });\n             }\n-            for (DetailAST typeParam : typeParams) {\n-                this.log(typeParam, \"javadoc.expectedTag\", new Object[] { JavadocTagInfo.PARAM.getText(), \"<\" + typeParam.findFirstToken(58).getText() });\n+            for (DetailAST detailAST3 : typeParameters) {\n+                this.log(detailAST3, \"javadoc.expectedTag\", new Object[] { JavadocTagInfo.PARAM.getText(), \"<\" + detailAST3.findFirstToken(58).getText() });\n             }\n         }\n     }\n     \n-    private static boolean searchMatchingTypeParameter(final Iterable<DetailAST> typeParams, final String requiredTypeName) {\n-        final Iterator<DetailAST> typeParamsIt = typeParams.iterator();\n-        boolean found = false;\n-        while (typeParamsIt.hasNext()) {\n-            final DetailAST typeParam = (DetailAST)typeParamsIt.next();\n-            if (typeParam.findFirstToken(58).getText().equals(requiredTypeName)) {\n-                found = true;\n-                typeParamsIt.remove();\n+    private static boolean searchMatchingTypeParameter(final Iterable<DetailAST> iterable, final String anObject) {\n+        final Iterator<DetailAST> iterator = iterable.iterator();\n+        boolean b = false;\n+        while (iterator.hasNext()) {\n+            if (((DetailAST)iterator.next()).findFirstToken(58).getText().equals(anObject)) {\n+                b = true;\n+                iterator.remove();\n                 break;\n             }\n         }\n-        return found;\n+        return b;\n     }\n     \n-    private static boolean removeMatchingParam(final Iterable<DetailAST> params, final String paramName) {\n-        boolean found = false;\n-        final Iterator<DetailAST> paramIt = params.iterator();\n-        while (paramIt.hasNext()) {\n-            final DetailAST param = (DetailAST)paramIt.next();\n-            if (param.getText().equals(paramName)) {\n-                found = true;\n-                paramIt.remove();\n+    private static boolean removeMatchingParam(final Iterable<DetailAST> iterable, final String anObject) {\n+        boolean b = false;\n+        final Iterator<DetailAST> iterator = iterable.iterator();\n+        while (iterator.hasNext()) {\n+            if (((DetailAST)iterator.next()).getText().equals(anObject)) {\n+                b = true;\n+                iterator.remove();\n                 break;\n             }\n         }\n-        return found;\n+        return b;\n     }\n     \n-    private void checkReturnTag(final List<JavadocTag> tags, final int lineNo, final boolean reportExpectedTags) {\n-        boolean found = false;\n-        final ListIterator<JavadocTag> it = tags.listIterator();\n-        while (it.hasNext()) {\n-            final JavadocTag javadocTag = (JavadocTag)it.next();\n+    private void checkReturnTag(final List<JavadocTag> list, final int n, final boolean b) {\n+        int n2 = 0;\n+        final ListIterator<JavadocTag> listIterator = list.listIterator();\n+        while (listIterator.hasNext()) {\n+            final JavadocTag javadocTag = (JavadocTag)listIterator.next();\n             if (javadocTag.isReturnTag()) {\n-                if (found) {\n+                if (n2 != 0) {\n                     this.log(javadocTag.getLineNo(), javadocTag.getColumnNo(), \"javadoc.duplicateTag\", new Object[] { JavadocTagInfo.RETURN.getText() });\n                 }\n-                found = true;\n-                it.remove();\n+                n2 = 1;\n+                listIterator.remove();\n             }\n         }\n-        if (!found && !this.allowMissingReturnTag && reportExpectedTags) {\n-            this.log(lineNo, \"javadoc.return.expected\", new Object[0]);\n+        if (n2 == 0 && !this.allowMissingReturnTag && b) {\n+            this.log(n, \"javadoc.return.expected\", new Object[0]);\n         }\n     }\n     \n-    private void checkThrowsTags(final List<JavadocTag> tags, final List<JavadocMethodCheck.ExceptionInfo> throwsList, final boolean reportExpectedTags) {\n-        final Set<String> foundThrows = new HashSet<String>();\n-        final ListIterator<JavadocTag> tagIt = tags.listIterator();\n-        while (tagIt.hasNext()) {\n-            final JavadocTag tag = (JavadocTag)tagIt.next();\n-            if (!tag.isThrowsTag()) {\n+    private void checkThrowsTags(final List<JavadocTag> list, final List<JavadocMethodCheck.ExceptionInfo> list2, final boolean b) {\n+        final HashSet set = new HashSet();\n+        final ListIterator<JavadocTag> listIterator = list.listIterator();\n+        while (listIterator.hasNext()) {\n+            final JavadocTag javadocTag = (JavadocTag)listIterator.next();\n+            if (!javadocTag.isThrowsTag()) {\n                 continue;\n             }\n-            tagIt.remove();\n-            final JavadocMethodCheck.Token token = new JavadocMethodCheck.Token(tag.getFirstArg(), tag.getLineNo(), tag.getColumnNo());\n-            final JavadocMethodCheck.ClassInfo documentedClassInfo = new JavadocMethodCheck.ClassInfo(token);\n-            processThrows(throwsList, documentedClassInfo, foundThrows);\n-        }\n-        if (this.validateThrows && reportExpectedTags) {\n-            throwsList.stream().filter(exceptionInfo -> !exceptionInfo.isFound()).forEach(exceptionInfo -> {\n-                final JavadocMethodCheck.Token token2 = exceptionInfo.getName();\n-                this.log(exceptionInfo.getAst(), \"javadoc.expectedTag\", new Object[] { JavadocTagInfo.THROWS.getText(), token2.getText() });\n+            listIterator.remove();\n+            processThrows(list2, new JavadocMethodCheck.ClassInfo(new JavadocMethodCheck.Token(javadocTag.getFirstArg(), javadocTag.getLineNo(), javadocTag.getColumnNo())), set);\n+        }\n+        if (this.validateThrows && b) {\n+            list2.stream().filter(exceptionInfo -> !exceptionInfo.isFound()).forEach(exceptionInfo2 -> {\n+                exceptionInfo2.getName();\n+                final JavadocMethodCheck.Token token;\n+                this.log(exceptionInfo2.getAst(), \"javadoc.expectedTag\", new Object[] { JavadocTagInfo.THROWS.getText(), token.getText() });\n             });\n         }\n     }\n     \n-    private static void processThrows(final Iterable<JavadocMethodCheck.ExceptionInfo> throwsIterable, final JavadocMethodCheck.ClassInfo documentedClassInfo, final Set<String> foundThrows) {\n-        JavadocMethodCheck.ExceptionInfo foundException = null;\n-        for (final JavadocMethodCheck.ExceptionInfo exceptionInfo : throwsIterable) {\n-            if (isClassNamesSame(exceptionInfo.getName().getText(), documentedClassInfo.getName().getText())) {\n-                foundException = exceptionInfo;\n+    private static void processThrows(final Iterable<JavadocMethodCheck.ExceptionInfo> iterable, final JavadocMethodCheck.ClassInfo classInfo, final Set<String> set) {\n+        JavadocMethodCheck.ExceptionInfo exceptionInfo = null;\n+        for (final JavadocMethodCheck.ExceptionInfo exceptionInfo2 : iterable) {\n+            if (isClassNamesSame(exceptionInfo2.getName().getText(), classInfo.getName().getText())) {\n+                exceptionInfo = exceptionInfo2;\n                 break;\n             }\n         }\n-        if (foundException != null) {\n-            foundException.setFound();\n-            foundThrows.add(documentedClassInfo.getName().getText());\n+        if (exceptionInfo != null) {\n+            exceptionInfo.setFound();\n+            set.add(classInfo.getName().getText());\n         }\n     }\n     \n-    private static boolean isExceptionInfoSame(final JavadocMethodCheck.ExceptionInfo info1, final JavadocMethodCheck.ExceptionInfo info2) {\n-        return isClassNamesSame(info1.getName().getText(), info2.getName().getText());\n+    private static boolean isExceptionInfoSame(final JavadocMethodCheck.ExceptionInfo exceptionInfo, final JavadocMethodCheck.ExceptionInfo exceptionInfo2) {\n+        return isClassNamesSame(exceptionInfo.getName().getText(), exceptionInfo2.getName().getText());\n     }\n     \n-    private static boolean isClassNamesSame(final String class1, final String class2) {\n-        boolean result = false;\n-        if (class1.equals(class2)) {\n-            result = true;\n+    private static boolean isClassNamesSame(final String s, final String anObject) {\n+        boolean equals = false;\n+        if (s.equals(anObject)) {\n+            equals = true;\n         }\n-        else {\n-            final String separator = \".\";\n-            if (class1.contains(\".\") || class2.contains(\".\")) {\n-                final String class1ShortName = class1.substring(class1.lastIndexOf(46) + 1);\n-                final String class2ShortName = class2.substring(class2.lastIndexOf(46) + 1);\n-                result = class1ShortName.equals(class2ShortName);\n-            }\n+        else if (s.contains(\".\") || anObject.contains(\".\")) {\n+            equals = s.substring(s.lastIndexOf(46) + 1).equals(anObject.substring(anObject.lastIndexOf(46) + 1));\n         }\n-        return result;\n+        return equals;\n     }\n     \n     static {\n         MATCH_JAVADOC_ARG = CommonUtil.createPattern(\"^\\\\s*(?>\\\\*|\\\\/\\\\*\\\\*)?\\\\s*@(throws|exception|param)\\\\s+(\\\\S+)\\\\s+\\\\S*\");\n         MATCH_JAVADOC_ARG_MISSING_DESCRIPTION = CommonUtil.createPattern(\"^\\\\s*(?>\\\\*|\\\\/\\\\*\\\\*)?\\\\s*@(throws|exception|param)\\\\s+(\\\\S[^*]*)(?:(\\\\s+|\\\\*\\\\/))?\");\n         MATCH_JAVADOC_MULTILINE_CONT = CommonUtil.createPattern(\"(\\\\*\\\\/|@|[^\\\\s\\\\*])\");\n         MATCH_JAVADOC_NOARG = CommonUtil.createPattern(\"^\\\\s*(?>\\\\*|\\\\/\\\\*\\\\*)?\\\\s*@(return|see)\\\\s+\\\\S\");\n"}]}
