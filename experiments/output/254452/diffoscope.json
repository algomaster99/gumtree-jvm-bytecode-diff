{"diffoscope-json-version": 1, "source1": "first/RFC1522Codec.class", "source2": "second/RFC1522Codec.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -9,68 +9,64 @@\n \n abstract class RFC1522Codec\n {\n     protected static final char SEP = '?';\n     protected static final String POSTFIX = \"?=\";\n     protected static final String PREFIX = \"=?\";\n     \n-    protected String encodeText(final String text, final Charset charset) throws EncoderException {\n-        if (text == null) {\n+    protected String encodeText(final String s, final Charset charset) throws EncoderException {\n+        if (s == null) {\n             return null;\n         }\n-        final StringBuilder buffer = new StringBuilder();\n-        buffer.append(\"=?\");\n-        buffer.append(charset);\n-        buffer.append('?');\n-        buffer.append(this.getEncoding());\n-        buffer.append('?');\n-        final byte[] rawData = this.doEncoding(text.getBytes(charset));\n-        buffer.append(StringUtils.newStringUsAscii(rawData));\n-        buffer.append(\"?=\");\n-        return buffer.toString();\n+        final StringBuilder sb = new StringBuilder();\n+        sb.append(\"=?\");\n+        sb.append(charset);\n+        sb.append('?');\n+        sb.append(this.getEncoding());\n+        sb.append('?');\n+        sb.append(StringUtils.newStringUsAscii(this.doEncoding(s.getBytes(charset))));\n+        sb.append(\"?=\");\n+        return sb.toString();\n     }\n     \n-    protected String encodeText(final String text, final String charsetName) throws EncoderException, UnsupportedEncodingException {\n-        if (text == null) {\n+    protected String encodeText(final String s, final String charsetName) throws EncoderException, UnsupportedEncodingException {\n+        if (s == null) {\n             return null;\n         }\n-        return this.encodeText(text, Charset.forName(charsetName));\n+        return this.encodeText(s, Charset.forName(charsetName));\n     }\n     \n-    protected String decodeText(final String text) throws DecoderException, UnsupportedEncodingException {\n-        if (text == null) {\n+    protected String decodeText(final String s) throws DecoderException, UnsupportedEncodingException {\n+        if (s == null) {\n             return null;\n         }\n-        if (!text.startsWith(\"=?\") || !text.endsWith(\"?=\")) {\n+        if (!s.startsWith(\"=?\") || !s.endsWith(\"?=\")) {\n             throw new DecoderException(\"RFC 1522 violation: malformed encoded content\");\n         }\n-        final int terminator = text.length() - 2;\n-        int from = 2;\n-        int to = text.indexOf(63, from);\n-        if (to == terminator) {\n+        final int n = s.length() - 2;\n+        final int n2 = 2;\n+        final int index = s.indexOf(63, n2);\n+        if (index == n) {\n             throw new DecoderException(\"RFC 1522 violation: charset token not found\");\n         }\n-        final String charset = text.substring(from, to);\n-        if (charset.equals(\"\")) {\n+        final String substring = s.substring(n2, index);\n+        if (substring.equals(\"\")) {\n             throw new DecoderException(\"RFC 1522 violation: charset not specified\");\n         }\n-        from = to + 1;\n-        to = text.indexOf(63, from);\n-        if (to == terminator) {\n+        final int n3 = index + 1;\n+        final int index2 = s.indexOf(63, n3);\n+        if (index2 == n) {\n             throw new DecoderException(\"RFC 1522 violation: encoding token not found\");\n         }\n-        final String encoding = text.substring(from, to);\n-        if (!this.getEncoding().equalsIgnoreCase(encoding)) {\n-            throw new DecoderException(\"This codec cannot decode \" + encoding + \" encoded content\");\n-        }\n-        from = to + 1;\n-        to = text.indexOf(63, from);\n-        byte[] data = StringUtils.getBytesUsAscii(text.substring(from, to));\n-        data = this.doDecoding(data);\n-        return new String(data, charset);\n+        final String substring2 = s.substring(n3, index2);\n+        if (!this.getEncoding().equalsIgnoreCase(substring2)) {\n+            throw new DecoderException(\"This codec cannot decode \" + substring2 + \" encoded content\");\n+        }\n+        final int n4 = index2 + 1;\n+        return new String(this.doDecoding(StringUtils.getBytesUsAscii(s.substring(n4, s.indexOf(63, n4)))), substring);\n     }\n     \n     protected abstract String getEncoding();\n     \n     protected abstract byte[] doEncoding(final byte[] p0) throws EncoderException;\n     \n     protected abstract byte[] doDecoding(final byte[] p0) throws DecoderException;\n"}]}
