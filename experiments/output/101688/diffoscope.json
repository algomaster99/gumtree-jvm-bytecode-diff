{"diffoscope-json-version": 1, "source1": "first/Rule.class", "source2": "second/Rule.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,21 +1,21 @@\n \n package org.apache.commons.codec.language.bm;\n \n-import java.util.Collections;\n-import java.util.EnumMap;\n-import java.util.HashMap;\n import java.util.Set;\n import java.util.HashSet;\n import java.util.Arrays;\n-import java.util.Iterator;\n import java.util.Collection;\n import java.util.ArrayList;\n import java.io.InputStream;\n import java.util.Scanner;\n+import java.util.Iterator;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.EnumMap;\n import java.util.List;\n import java.util.Map;\n \n public class Rule\n {\n     public static final Rule.RPattern ALL_STRINGS_RMATCHER;\n     public static final String ALL = \"ALL\";\n@@ -23,14 +23,89 @@\n     private static final String HASH_INCLUDE = \"#include\";\n     private static final Map<NameType, Map<RuleType, Map<String, Map<String, List<Rule>>>>> RULES;\n     private final Rule.RPattern lContext;\n     private final String pattern;\n     private final Rule.PhonemeExpr phoneme;\n     private final Rule.RPattern rContext;\n     \n+    static {\n+        ALL_STRINGS_RMATCHER = (Rule.RPattern)new Rule.Rule$1();\n+        RULES = new EnumMap<NameType, Map<RuleType, Map<String, Map<String, List<Rule>>>>>(NameType.class);\n+        NameType[] values;\n+        for (int length = (values = NameType.values()).length, i = 0; i < length; ++i) {\n+            final NameType s = values[i];\n+            final Map<RuleType, Map<String, Map<String, List<Rule>>>> rts = new EnumMap<RuleType, Map<String, Map<String, List<Rule>>>>(RuleType.class);\n+            RuleType[] values2;\n+            for (int length2 = (values2 = RuleType.values()).length, j = 0; j < length2; ++j) {\n+                final RuleType rt = values2[j];\n+                final Map<String, Map<String, List<Rule>>> rs = new HashMap<String, Map<String, List<Rule>>>();\n+                final Languages ls = Languages.getInstance(s);\n+                for (final String l : ls.getLanguages()) {\n+                    try {\n+                        Throwable t = null;\n+                        try {\n+                            final Scanner scanner = createScanner(s, rt, l);\n+                            try {\n+                                rs.put(l, parseRules(scanner, createResourceName(s, rt, l)));\n+                            }\n+                            finally {\n+                                if (scanner != null) {\n+                                    scanner.close();\n+                                }\n+                            }\n+                        }\n+                        finally {\n+                            if (t == null) {\n+                                final Throwable exception;\n+                                t = exception;\n+                            }\n+                            else {\n+                                final Throwable exception;\n+                                if (t != exception) {\n+                                    t.addSuppressed(exception);\n+                                }\n+                            }\n+                        }\n+                    }\n+                    catch (final IllegalStateException e) {\n+                        throw new IllegalStateException(\"Problem processing \" + createResourceName(s, rt, l), e);\n+                    }\n+                }\n+                if (!rt.equals((Object)RuleType.RULES)) {\n+                    Throwable t2 = null;\n+                    try {\n+                        final Scanner scanner2 = createScanner(s, rt, \"common\");\n+                        try {\n+                            rs.put(\"common\", parseRules(scanner2, createResourceName(s, rt, \"common\")));\n+                        }\n+                        finally {\n+                            if (scanner2 != null) {\n+                                scanner2.close();\n+                            }\n+                        }\n+                    }\n+                    finally {\n+                        if (t2 == null) {\n+                            final Throwable exception2;\n+                            t2 = exception2;\n+                        }\n+                        else {\n+                            final Throwable exception2;\n+                            if (t2 != exception2) {\n+                                t2.addSuppressed(exception2);\n+                            }\n+                        }\n+                    }\n+                }\n+                rts.put(rt, Collections.unmodifiableMap((Map<? extends String, ? extends Map<String, List<Rule>>>)rs));\n+            }\n+            Rule.RULES.put(s, Collections.unmodifiableMap((Map<? extends RuleType, ? extends Map<String, Map<String, List<Rule>>>>)rts));\n+        }\n+    }\n+    \n     private static boolean contains(final CharSequence chars, final char input) {\n         for (int i = 0; i < chars.length(); ++i) {\n             if (chars.charAt(i) == input) {\n                 return true;\n             }\n         }\n         return false;\n@@ -116,15 +191,17 @@\n             return (Rule.PhonemeExpr)parsePhoneme(ph);\n         }\n         if (!ph.endsWith(\")\")) {\n             throw new IllegalArgumentException(\"Phoneme starts with '(' so must end with ')'\");\n         }\n         final List<Rule.Phoneme> phs = new ArrayList<Rule.Phoneme>();\n         final String body = ph.substring(1, ph.length() - 1);\n-        for (final String part : body.split(\"[|]\")) {\n+        String[] split;\n+        for (int length = (split = body.split(\"[|]\")).length, i = 0; i < length; ++i) {\n+            final String part = split[i];\n             phs.add(parsePhoneme(part));\n         }\n         if (body.startsWith(\"|\") || body.endsWith(\"|\")) {\n             phs.add(new Rule.Phoneme((CharSequence)\"\", Languages.ANY_LANGUAGE));\n         }\n         return (Rule.PhonemeExpr)new Rule.PhonemeList((List)phs);\n     }\n@@ -156,44 +233,60 @@\n                     continue;\n                 }\n                 if (line.startsWith(\"#include\")) {\n                     final String incl = line.substring(\"#include\".length()).trim();\n                     if (incl.contains(\" \")) {\n                         throw new IllegalArgumentException(\"Malformed import statement '\" + rawLine + \"' in \" + location);\n                     }\n-                    try (final Scanner hashIncludeScanner = createScanner(incl)) {\n-                        lines.putAll(parseRules(hashIncludeScanner, location + \"->\" + incl));\n-                        if (hashIncludeScanner == null) {\n-                            continue;\n+                    Throwable t = null;\n+                    try {\n+                        final Scanner hashIncludeScanner = createScanner(incl);\n+                        try {\n+                            lines.putAll(parseRules(hashIncludeScanner, String.valueOf(location) + \"->\" + incl));\n+                        }\n+                        finally {\n+                            if (hashIncludeScanner != null) {\n+                                hashIncludeScanner.close();\n+                            }\n                         }\n                     }\n-                }\n-                else {\n-                    final String[] parts = line.split(\"\\\\s+\");\n-                    if (parts.length != 4) {\n-                        throw new IllegalArgumentException(\"Malformed rule statement split into \" + parts.length + \" parts: \" + rawLine + \" in \" + location);\n-                    }\n-                    try {\n-                        final String pat = stripQuotes(parts[0]);\n-                        final String lCon = stripQuotes(parts[1]);\n-                        final String rCon = stripQuotes(parts[2]);\n-                        final Rule.PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3]));\n-                        final int cLine = currentLine;\n-                        final Rule r = (Rule)new Rule.Rule$2(pat, lCon, rCon, ph, cLine, location, pat, lCon, rCon);\n-                        final String patternKey = r.pattern.substring(0, 1);\n-                        List<Rule> rules = (List<Rule>)lines.get(patternKey);\n-                        if (rules == null) {\n-                            rules = new ArrayList<Rule>();\n-                            lines.put(patternKey, rules);\n+                    finally {\n+                        if (t == null) {\n+                            final Throwable exception;\n+                            t = exception;\n+                        }\n+                        else {\n+                            final Throwable exception;\n+                            if (t != exception) {\n+                                t.addSuppressed(exception);\n+                            }\n                         }\n-                        rules.add(r);\n                     }\n-                    catch (final IllegalArgumentException e) {\n-                        throw new IllegalStateException(\"Problem parsing line '\" + currentLine + \"' in \" + location, e);\n+                }\n+                final String[] parts = line.split(\"\\\\s+\");\n+                if (parts.length != 4) {\n+                    throw new IllegalArgumentException(\"Malformed rule statement split into \" + parts.length + \" parts: \" + rawLine + \" in \" + location);\n+                }\n+                try {\n+                    final String pat = stripQuotes(parts[0]);\n+                    final String lCon = stripQuotes(parts[1]);\n+                    final String rCon = stripQuotes(parts[2]);\n+                    final Rule.PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3]));\n+                    final int cLine = currentLine;\n+                    final Rule r = (Rule)new Rule.Rule$2(pat, lCon, rCon, ph, cLine, location, pat, lCon, rCon);\n+                    final String patternKey = r.pattern.substring(0, 1);\n+                    List<Rule> rules = (List<Rule>)lines.get(patternKey);\n+                    if (rules == null) {\n+                        rules = new ArrayList<Rule>();\n+                        lines.put(patternKey, rules);\n                     }\n+                    rules.add(r);\n+                }\n+                catch (final IllegalArgumentException e) {\n+                    throw new IllegalStateException(\"Problem parsing line '\" + currentLine + \"' in \" + location, e);\n                 }\n             }\n         }\n         return lines;\n     }\n     \n     private static Rule.RPattern pattern(final String regex) {\n@@ -267,15 +360,15 @@\n             str = str.substring(0, str.length() - 1);\n         }\n         return str;\n     }\n     \n     public Rule(final String pattern, final String lContext, final String rContext, final Rule.PhonemeExpr phoneme) {\n         this.pattern = pattern;\n-        this.lContext = pattern(lContext + \"$\");\n+        this.lContext = pattern(String.valueOf(lContext) + \"$\");\n         this.rContext = pattern(\"^\" + rContext);\n         this.phoneme = phoneme;\n     }\n     \n     public Rule.RPattern getLContext() {\n         return this.lContext;\n     }\n@@ -296,38 +389,8 @@\n         if (i < 0) {\n             throw new IndexOutOfBoundsException(\"Can not match pattern at negative indexes\");\n         }\n         final int patternLength = this.pattern.length();\n         final int ipl = i + patternLength;\n         return ipl <= input.length() && input.subSequence(i, ipl).equals(this.pattern) && this.rContext.isMatch(input.subSequence(ipl, input.length())) && this.lContext.isMatch(input.subSequence(0, i));\n     }\n-    \n-    static {\n-        ALL_STRINGS_RMATCHER = (Rule.RPattern)new Rule.Rule$1();\n-        RULES = new EnumMap<NameType, Map<RuleType, Map<String, Map<String, List<Rule>>>>>(NameType.class);\n-        for (final NameType s : NameType.values()) {\n-            final Map<RuleType, Map<String, Map<String, List<Rule>>>> rts = new EnumMap<RuleType, Map<String, Map<String, List<Rule>>>>(RuleType.class);\n-            for (final RuleType rt : RuleType.values()) {\n-                final Map<String, Map<String, List<Rule>>> rs = new HashMap<String, Map<String, List<Rule>>>();\n-                final Languages ls = Languages.getInstance(s);\n-                for (final String l : ls.getLanguages()) {\n-                    try (final Scanner scanner = createScanner(s, rt, l)) {\n-                        rs.put(l, parseRules(scanner, createResourceName(s, rt, l)));\n-                        if (scanner == null) {\n-                            continue;\n-                        }\n-                    }\n-                    catch (final IllegalStateException e) {\n-                        throw new IllegalStateException(\"Problem processing \" + createResourceName(s, rt, l), e);\n-                    }\n-                }\n-                if (!rt.equals((Object)RuleType.RULES)) {\n-                    try (final Scanner scanner2 = createScanner(s, rt, \"common\")) {\n-                        rs.put(\"common\", parseRules(scanner2, createResourceName(s, rt, \"common\")));\n-                    }\n-                }\n-                rts.put(rt, Collections.unmodifiableMap((Map<? extends String, ? extends Map<String, List<Rule>>>)rs));\n-            }\n-            Rule.RULES.put(s, Collections.unmodifiableMap((Map<? extends RuleType, ? extends Map<String, Map<String, List<Rule>>>>)rts));\n-        }\n-    }\n }\n"}]}
