{"diffoscope-json-version": 1, "source1": "first/ClassGen.class", "source2": "second/ClassGen.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,15 +1,14 @@\n \n package org.apache.bcel.generic;\n \n import org.apache.bcel.classfile.AnnotationEntry;\n import org.apache.bcel.classfile.RuntimeInvisibleAnnotations;\n import org.apache.bcel.classfile.RuntimeVisibleAnnotations;\n import org.apache.bcel.classfile.Utility;\n-import org.apache.bcel.classfile.ConstantPool;\n import java.util.Arrays;\n import org.apache.commons.lang3.ArrayUtils;\n import java.util.Iterator;\n import org.apache.bcel.classfile.SourceFile;\n import org.apache.bcel.classfile.Annotations;\n import java.util.Collection;\n import java.util.Collections;\n@@ -64,22 +63,22 @@\n         this.className = clazz.getClassName();\n         this.superClassName = clazz.getSuperclassName();\n         this.fileName = clazz.getSourceFileName();\n         this.cp = new ConstantPoolGen(clazz.getConstantPool());\n         this.major = clazz.getMajor();\n         this.minor = clazz.getMinor();\n         final Attribute[] attributes = clazz.getAttributes();\n-        final AnnotationEntryGen[] annotations = this.unpackAnnotations(attributes);\n+        final AnnotationEntryGen[] unpackAnnotations = this.unpackAnnotations(attributes);\n         Collections.addAll(this.interfaceList, clazz.getInterfaceNames());\n-        for (final Attribute attribute : attributes) {\n-            if (!(attribute instanceof Annotations)) {\n-                this.addAttribute(attribute);\n+        for (final Attribute a : attributes) {\n+            if (!(a instanceof Annotations)) {\n+                this.addAttribute(a);\n             }\n         }\n-        Collections.addAll(this.annotationList, annotations);\n+        Collections.addAll(this.annotationList, unpackAnnotations);\n         Collections.addAll(this.methodList, clazz.getMethods());\n         Collections.addAll(this.fieldList, clazz.getFields());\n     }\n     \n     public ClassGen(final String className, final String superClassName, final String fileName, final int accessFlags, final String[] interfaces) {\n         this(className, superClassName, fileName, accessFlags, interfaces, new ConstantPoolGen());\n     }\n@@ -114,21 +113,21 @@\n     }\n     \n     public void addAttribute(final Attribute a) {\n         this.attributeList.add(a);\n     }\n     \n     public void addEmptyConstructor(final int accessFlags) {\n-        final InstructionList il = new InstructionList();\n-        il.append((Instruction)InstructionConst.THIS);\n-        il.append((Instruction)new INVOKESPECIAL(this.cp.addMethodref(this.superClassName, \"<init>\", \"()V\")));\n-        il.append((Instruction)InstructionConst.RETURN);\n-        final MethodGen mg = new MethodGen(accessFlags, (Type)Type.VOID, Type.NO_ARGS, (String[])null, \"<init>\", this.className, il, this.cp);\n-        mg.setMaxStack(1);\n-        this.addMethod(mg.getMethod());\n+        final InstructionList list = new InstructionList();\n+        list.append((Instruction)InstructionConst.THIS);\n+        list.append((Instruction)new INVOKESPECIAL(this.cp.addMethodref(this.superClassName, \"<init>\", \"()V\")));\n+        list.append((Instruction)InstructionConst.RETURN);\n+        final MethodGen methodGen = new MethodGen(accessFlags, (Type)Type.VOID, Type.NO_ARGS, (String[])null, \"<init>\", this.className, list, this.cp);\n+        methodGen.setMaxStack(1);\n+        this.addMethod(methodGen.getMethod());\n     }\n     \n     public void addField(final Field f) {\n         this.fieldList.add(f);\n     }\n     \n     public void addInterface(final String name) {\n@@ -146,36 +145,36 @@\n         this.observers.add(o);\n     }\n     \n     public Object clone() {\n         try {\n             return super.clone();\n         }\n-        catch (final CloneNotSupportedException e) {\n+        catch (final CloneNotSupportedException ex) {\n             throw new Error(\"Clone Not Supported\");\n         }\n     }\n     \n     public boolean containsField(final Field f) {\n         return this.fieldList.contains(f);\n     }\n     \n     public Field containsField(final String name) {\n-        for (final Field f : this.fieldList) {\n-            if (f.getName().equals(name)) {\n-                return f;\n+        for (final Field field : this.fieldList) {\n+            if (field.getName().equals(name)) {\n+                return field;\n             }\n         }\n         return null;\n     }\n     \n     public Method containsMethod(final String name, final String signature) {\n-        for (final Method m : this.methodList) {\n-            if (m.getName().equals(name) && m.getSignature().equals(signature)) {\n-                return m;\n+        for (final Method method : this.methodList) {\n+            if (method.getName().equals(name) && method.getSignature().equals(signature)) {\n+                return method;\n             }\n         }\n         return null;\n     }\n     \n     public boolean equals(final Object obj) {\n         return ClassGen.bcelComparator.equals((Object)this, obj);\n@@ -210,36 +209,34 @@\n     }\n     \n     public String[] getInterfaceNames() {\n         return this.interfaceList.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n     }\n     \n     public int[] getInterfaces() {\n-        final int size = this.interfaceList.size();\n-        final int[] interfaces = new int[size];\n-        Arrays.setAll(interfaces, i -> this.cp.addClass((String)this.interfaceList.get(i)));\n-        return interfaces;\n+        final int[] array = new int[this.interfaceList.size()];\n+        Arrays.setAll(array, n2 -> this.cp.addClass((String)this.interfaceList.get(n2)));\n+        return array;\n     }\n     \n     public JavaClass getJavaClass() {\n         final int[] interfaces = this.getInterfaces();\n         final Field[] fields = this.getFields();\n         final Method[] methods = this.getMethods();\n-        Attribute[] attributes = null;\n+        Attribute[] attributes;\n         if (this.annotationList.isEmpty()) {\n             attributes = this.getAttributes();\n         }\n         else {\n-            final Attribute[] annAttributes = AnnotationEntryGen.getAnnotationAttributes(this.cp, this.getAnnotationEntries());\n-            attributes = new Attribute[this.attributeList.size() + annAttributes.length];\n+            final Attribute[] annotationAttributes = AnnotationEntryGen.getAnnotationAttributes(this.cp, this.getAnnotationEntries());\n+            attributes = new Attribute[this.attributeList.size() + annotationAttributes.length];\n             this.attributeList.toArray(attributes);\n-            System.arraycopy(annAttributes, 0, attributes, this.attributeList.size(), annAttributes.length);\n+            System.arraycopy(annotationAttributes, 0, attributes, this.attributeList.size(), annotationAttributes.length);\n         }\n-        final ConstantPool cp = this.cp.getFinalConstantPool();\n-        return new JavaClass(this.classNameIndex, this.superclassNameIndex, this.fileName, this.major, this.minor, super.getAccessFlags(), cp, interfaces, fields, methods, attributes);\n+        return new JavaClass(this.classNameIndex, this.superclassNameIndex, this.fileName, this.major, this.minor, super.getAccessFlags(), this.cp.getFinalConstantPool(), interfaces, fields, methods, attributes);\n     }\n     \n     public int getMajor() {\n         return this.major;\n     }\n     \n     public Method getMethodAt(final int pos) {\n@@ -288,33 +285,33 @@\n         }\n     }\n     \n     public void replaceField(final Field old, final Field newField) {\n         if (newField == null) {\n             throw new ClassGenException(\"Replacement method must not be null\");\n         }\n-        final int i = this.fieldList.indexOf(old);\n-        if (i < 0) {\n+        final int index = this.fieldList.indexOf(old);\n+        if (index < 0) {\n             this.fieldList.add(newField);\n         }\n         else {\n-            this.fieldList.set(i, newField);\n+            this.fieldList.set(index, newField);\n         }\n     }\n     \n     public void replaceMethod(final Method old, final Method newMethod) {\n         if (newMethod == null) {\n             throw new ClassGenException(\"Replacement method must not be null\");\n         }\n-        final int i = this.methodList.indexOf(old);\n-        if (i < 0) {\n+        final int index = this.methodList.indexOf(old);\n+        if (index < 0) {\n             this.methodList.add(newMethod);\n         }\n         else {\n-            this.methodList.set(i, newMethod);\n+            this.methodList.set(index, newMethod);\n         }\n     }\n     \n     public void setClassName(final String name) {\n         this.className = Utility.pathToPackage(name);\n         this.classNameIndex = this.cp.addClass(name);\n     }\n@@ -352,32 +349,31 @@\n     \n     public void setSuperclassNameIndex(final int superclassNameIndex) {\n         this.superclassNameIndex = superclassNameIndex;\n         this.superClassName = Utility.pathToPackage(this.cp.getConstantPool().getConstantString(superclassNameIndex, (byte)7));\n     }\n     \n     private AnnotationEntryGen[] unpackAnnotations(final Attribute[] attrs) {\n-        final List<AnnotationEntryGen> annotationGenObjs = new ArrayList<AnnotationEntryGen>();\n-        for (final Attribute attr : attrs) {\n-            if (attr instanceof RuntimeVisibleAnnotations) {\n-                final RuntimeVisibleAnnotations rva = (RuntimeVisibleAnnotations)attr;\n-                rva.forEach(a -> annotationGenObjs.add(new AnnotationEntryGen(a, this.getConstantPool(), false)));\n+        final ArrayList list = new ArrayList();\n+        for (final Attribute attribute : attrs) {\n+            if (attribute instanceof RuntimeVisibleAnnotations) {\n+                ((RuntimeVisibleAnnotations)attribute).forEach(annotationEntry -> list2.add(new AnnotationEntryGen(annotationEntry, this.getConstantPool(), (boolean)(0 != 0))));\n             }\n-            else if (attr instanceof RuntimeInvisibleAnnotations) {\n-                final RuntimeInvisibleAnnotations ria = (RuntimeInvisibleAnnotations)attr;\n-                ria.forEach(a -> annotationGenObjs.add(new AnnotationEntryGen(a, this.getConstantPool(), false)));\n+            else if (attribute instanceof RuntimeInvisibleAnnotations) {\n+                ((RuntimeInvisibleAnnotations)attribute).forEach(annotationEntry2 -> list3.add(new AnnotationEntryGen(annotationEntry2, this.getConstantPool(), (boolean)(0 != 0))));\n             }\n         }\n-        return annotationGenObjs.toArray(AnnotationEntryGen.EMPTY_ARRAY);\n+        return (AnnotationEntryGen[])list.toArray(AnnotationEntryGen.EMPTY_ARRAY);\n     }\n     \n     public void update() {\n         if (this.observers != null) {\n-            for (final ClassObserver observer : this.observers) {\n-                observer.notify(this);\n+            final Iterator<ClassObserver> iterator = this.observers.iterator();\n+            while (iterator.hasNext()) {\n+                ((ClassObserver)iterator.next()).notify(this);\n             }\n         }\n     }\n     \n     static {\n         ClassGen.bcelComparator = (BCELComparator)new ClassGen.ClassGen$1();\n     }\n"}]}
