{"diffoscope-json-version": 1, "source1": "first/EventCountCircuitBreaker.class", "source2": "second/EventCountCircuitBreaker.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -11,28 +11,28 @@\n     private static final Map<AbstractCircuitBreaker.State, EventCountCircuitBreaker.StateStrategy> STRATEGY_MAP;\n     private final AtomicReference<EventCountCircuitBreaker.CheckIntervalData> checkIntervalData;\n     private final int openingThreshold;\n     private final long openingInterval;\n     private final int closingThreshold;\n     private final long closingInterval;\n     \n-    public EventCountCircuitBreaker(final int openingThreshold, final long openingInterval, final TimeUnit openingUnit, final int closingThreshold, final long closingInterval, final TimeUnit closingUnit) {\n+    public EventCountCircuitBreaker(final int openingThreshold, final long duration, final TimeUnit timeUnit, final int closingThreshold, final long duration2, final TimeUnit timeUnit2) {\n         this.checkIntervalData = new AtomicReference<EventCountCircuitBreaker.CheckIntervalData>(new EventCountCircuitBreaker.CheckIntervalData(0, 0L));\n         this.openingThreshold = openingThreshold;\n-        this.openingInterval = openingUnit.toNanos(openingInterval);\n+        this.openingInterval = timeUnit.toNanos(duration);\n         this.closingThreshold = closingThreshold;\n-        this.closingInterval = closingUnit.toNanos(closingInterval);\n+        this.closingInterval = timeUnit2.toNanos(duration2);\n     }\n     \n-    public EventCountCircuitBreaker(final int openingThreshold, final long checkInterval, final TimeUnit checkUnit, final int closingThreshold) {\n-        this(openingThreshold, checkInterval, checkUnit, closingThreshold, checkInterval, checkUnit);\n+    public EventCountCircuitBreaker(final int n, final long n2, final TimeUnit timeUnit, final int n3) {\n+        this(n, n2, timeUnit, n3, n2, timeUnit);\n     }\n     \n-    public EventCountCircuitBreaker(final int threshold, final long checkInterval, final TimeUnit checkUnit) {\n-        this(threshold, checkInterval, checkUnit, threshold);\n+    public EventCountCircuitBreaker(final int n, final long n2, final TimeUnit timeUnit) {\n+        this(n, n2, timeUnit, n);\n     }\n     \n     public int getOpeningThreshold() {\n         return this.openingThreshold;\n     }\n     \n     public long getOpeningInterval() {\n@@ -47,16 +47,16 @@\n         return this.closingInterval;\n     }\n     \n     public boolean checkState() {\n         return this.performStateCheck(0);\n     }\n     \n-    public boolean incrementAndCheckState(final Integer increment) {\n-        return this.performStateCheck(increment);\n+    public boolean incrementAndCheckState(final Integer n) {\n+        return this.performStateCheck(n);\n     }\n     \n     public boolean incrementAndCheckState() {\n         return this.incrementAndCheckState(Integer.valueOf(1));\n     }\n     \n     public void open() {\n@@ -65,63 +65,63 @@\n     }\n     \n     public void close() {\n         super.close();\n         this.checkIntervalData.set(new EventCountCircuitBreaker.CheckIntervalData(0, this.now()));\n     }\n     \n-    private boolean performStateCheck(final int increment) {\n-        EventCountCircuitBreaker.CheckIntervalData currentData;\n-        EventCountCircuitBreaker.CheckIntervalData nextData;\n-        AbstractCircuitBreaker.State currentState;\n+    private boolean performStateCheck(final int n) {\n+        EventCountCircuitBreaker.CheckIntervalData checkIntervalData;\n+        EventCountCircuitBreaker.CheckIntervalData nextCheckIntervalData;\n+        AbstractCircuitBreaker.State oppositeState;\n         do {\n-            final long time = this.now();\n-            currentState = this.state.get();\n-            currentData = this.checkIntervalData.get();\n-            nextData = this.nextCheckIntervalData(increment, currentData, currentState, time);\n-        } while (!this.updateCheckIntervalData(currentData, nextData));\n-        if (stateStrategy(currentState).isStateTransition(this, currentData, nextData)) {\n-            currentState = currentState.oppositeState();\n-            this.changeStateAndStartNewCheckInterval(currentState);\n+            final long now = this.now();\n+            oppositeState = this.state.get();\n+            checkIntervalData = this.checkIntervalData.get();\n+            nextCheckIntervalData = this.nextCheckIntervalData(n, checkIntervalData, oppositeState, now);\n+        } while (!this.updateCheckIntervalData(checkIntervalData, nextCheckIntervalData));\n+        if (stateStrategy(oppositeState).isStateTransition(this, checkIntervalData, nextCheckIntervalData)) {\n+            oppositeState = oppositeState.oppositeState();\n+            this.changeStateAndStartNewCheckInterval(oppositeState);\n         }\n-        return !isOpen(currentState);\n+        return !isOpen(oppositeState);\n     }\n     \n-    private boolean updateCheckIntervalData(final EventCountCircuitBreaker.CheckIntervalData currentData, final EventCountCircuitBreaker.CheckIntervalData nextData) {\n-        return currentData == nextData || this.checkIntervalData.compareAndSet(currentData, nextData);\n+    private boolean updateCheckIntervalData(final EventCountCircuitBreaker.CheckIntervalData expectedValue, final EventCountCircuitBreaker.CheckIntervalData newValue) {\n+        return expectedValue == newValue || this.checkIntervalData.compareAndSet(expectedValue, newValue);\n     }\n     \n-    private void changeStateAndStartNewCheckInterval(final AbstractCircuitBreaker.State newState) {\n-        this.changeState(newState);\n+    private void changeStateAndStartNewCheckInterval(final AbstractCircuitBreaker.State state) {\n+        this.changeState(state);\n         this.checkIntervalData.set(new EventCountCircuitBreaker.CheckIntervalData(0, this.now()));\n     }\n     \n-    private EventCountCircuitBreaker.CheckIntervalData nextCheckIntervalData(final int increment, final EventCountCircuitBreaker.CheckIntervalData currentData, final AbstractCircuitBreaker.State currentState, final long time) {\n-        EventCountCircuitBreaker.CheckIntervalData nextData;\n-        if (stateStrategy(currentState).isCheckIntervalFinished(this, currentData, time)) {\n-            nextData = new EventCountCircuitBreaker.CheckIntervalData(increment, time);\n+    private EventCountCircuitBreaker.CheckIntervalData nextCheckIntervalData(final int n, final EventCountCircuitBreaker.CheckIntervalData checkIntervalData, final AbstractCircuitBreaker.State state, final long n2) {\n+        EventCountCircuitBreaker.CheckIntervalData increment;\n+        if (stateStrategy(state).isCheckIntervalFinished(this, checkIntervalData, n2)) {\n+            increment = new EventCountCircuitBreaker.CheckIntervalData(n, n2);\n         }\n         else {\n-            nextData = currentData.increment(increment);\n+            increment = checkIntervalData.increment(n);\n         }\n-        return nextData;\n+        return increment;\n     }\n     \n     long now() {\n         return System.nanoTime();\n     }\n     \n     private static EventCountCircuitBreaker.StateStrategy stateStrategy(final AbstractCircuitBreaker.State state) {\n         return EventCountCircuitBreaker.STRATEGY_MAP.get(state);\n     }\n     \n     private static Map<AbstractCircuitBreaker.State, EventCountCircuitBreaker.StateStrategy> createStrategyMap() {\n-        final Map<AbstractCircuitBreaker.State, EventCountCircuitBreaker.StateStrategy> map = new EnumMap<AbstractCircuitBreaker.State, EventCountCircuitBreaker.StateStrategy>(AbstractCircuitBreaker.State.class);\n-        map.put(AbstractCircuitBreaker.State.CLOSED, (EventCountCircuitBreaker.StateStrategy)new EventCountCircuitBreaker.StateStrategyClosed((EventCountCircuitBreaker.EventCountCircuitBreaker$1)null));\n-        map.put(AbstractCircuitBreaker.State.OPEN, (EventCountCircuitBreaker.StateStrategy)new EventCountCircuitBreaker.StateStrategyOpen((EventCountCircuitBreaker.EventCountCircuitBreaker$1)null));\n-        return map;\n+        final EnumMap enumMap = new EnumMap((Class<K>)AbstractCircuitBreaker.State.class);\n+        enumMap.put(AbstractCircuitBreaker.State.CLOSED, new EventCountCircuitBreaker.StateStrategyClosed((EventCountCircuitBreaker.EventCountCircuitBreaker$1)null));\n+        enumMap.put(AbstractCircuitBreaker.State.OPEN, new EventCountCircuitBreaker.StateStrategyOpen((EventCountCircuitBreaker.EventCountCircuitBreaker$1)null));\n+        return enumMap;\n     }\n     \n     static {\n         STRATEGY_MAP = createStrategyMap();\n     }\n }\n"}]}
