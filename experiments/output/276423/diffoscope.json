{"diffoscope-json-version": 1, "source1": "first/JavadocStyleCheck.class", "source2": "second/JavadocStyleCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -2,18 +2,17 @@\n package com.puppycrawl.tools.checkstyle.checks.javadoc;\n \n import java.util.Locale;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Deque;\n import java.util.ArrayDeque;\n+import com.puppycrawl.tools.checkstyle.api.TextBlock;\n import com.puppycrawl.tools.checkstyle.utils.ScopeUtil;\n import com.puppycrawl.tools.checkstyle.utils.CheckUtil;\n-import com.puppycrawl.tools.checkstyle.api.TextBlock;\n-import com.puppycrawl.tools.checkstyle.api.FileContents;\n import com.puppycrawl.tools.checkstyle.api.DetailAST;\n import com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n import java.util.regex.Pattern;\n import com.puppycrawl.tools.checkstyle.api.Scope;\n import java.util.Set;\n import com.puppycrawl.tools.checkstyle.StatelessCheck;\n import com.puppycrawl.tools.checkstyle.api.AbstractCheck;\n@@ -50,218 +49,215 @@\n         return new int[] { 157, 161, 14, 8, 155, 154, 15, 9, 16, 10, 199, 203 };\n     }\n     \n     public int[] getRequiredTokens() {\n         return CommonUtil.EMPTY_INT_ARRAY;\n     }\n     \n-    public void visitToken(final DetailAST ast) {\n-        if (this.shouldCheck(ast)) {\n-            final FileContents contents = this.getFileContents();\n-            final TextBlock textBlock = contents.getJavadocBefore(ast.getFirstChild().getLineNo());\n-            this.checkComment(ast, textBlock);\n+    public void visitToken(final DetailAST detailAST) {\n+        if (this.shouldCheck(detailAST)) {\n+            this.checkComment(detailAST, this.getFileContents().getJavadocBefore(detailAST.getFirstChild().getLineNo()));\n         }\n     }\n     \n-    private boolean shouldCheck(final DetailAST ast) {\n-        boolean check = false;\n-        if (ast.getType() == 16) {\n-            check = CheckUtil.isPackageInfo(this.getFilePath());\n+    private boolean shouldCheck(final DetailAST detailAST) {\n+        boolean packageInfo = false;\n+        if (detailAST.getType() == 16) {\n+            packageInfo = CheckUtil.isPackageInfo(this.getFilePath());\n         }\n-        else if (!ScopeUtil.isInCodeBlock(ast)) {\n-            final Scope customScope = ScopeUtil.getScope(ast);\n-            final Scope surroundingScope = ScopeUtil.getSurroundingScope(ast);\n-            check = (customScope.isIn(this.scope) && (surroundingScope == null || surroundingScope.isIn(this.scope)) && (this.excludeScope == null || !customScope.isIn(this.excludeScope) || (surroundingScope != null && !surroundingScope.isIn(this.excludeScope))));\n+        else if (!ScopeUtil.isInCodeBlock(detailAST)) {\n+            final Scope scope = ScopeUtil.getScope(detailAST);\n+            final Scope surroundingScope = ScopeUtil.getSurroundingScope(detailAST);\n+            packageInfo = (scope.isIn(this.scope) && (surroundingScope == null || surroundingScope.isIn(this.scope)) && (this.excludeScope == null || !scope.isIn(this.excludeScope) || (surroundingScope != null && !surroundingScope.isIn(this.excludeScope))));\n         }\n-        return check;\n+        return packageInfo;\n     }\n     \n-    private void checkComment(final DetailAST ast, final TextBlock comment) {\n-        if (comment != null) {\n+    private void checkComment(final DetailAST detailAST, final TextBlock textBlock) {\n+        if (textBlock != null) {\n             if (this.checkFirstSentence) {\n-                this.checkFirstSentenceEnding(ast, comment);\n+                this.checkFirstSentenceEnding(detailAST, textBlock);\n             }\n             if (this.checkHtml) {\n-                this.checkHtmlTags(ast, comment);\n+                this.checkHtmlTags(detailAST, textBlock);\n             }\n             if (this.checkEmptyJavadoc) {\n-                this.checkJavadocIsNotEmpty(comment);\n+                this.checkJavadocIsNotEmpty(textBlock);\n             }\n         }\n     }\n     \n-    private void checkFirstSentenceEnding(final DetailAST ast, final TextBlock comment) {\n-        final String commentText = getCommentText(comment.getText());\n-        if (!commentText.isEmpty() && !this.endOfSentenceFormat.matcher(commentText).find() && (!commentText.startsWith(\"{@inheritDoc}\") || !JavadocTagInfo.INHERIT_DOC.isValidOn(ast))) {\n-            this.log(comment.getStartLineNo(), \"javadoc.noPeriod\", new Object[0]);\n+    private void checkFirstSentenceEnding(final DetailAST detailAST, final TextBlock textBlock) {\n+        final String commentText = getCommentText(textBlock.getText());\n+        if (!commentText.isEmpty() && !this.endOfSentenceFormat.matcher(commentText).find() && (!commentText.startsWith(\"{@inheritDoc}\") || !JavadocTagInfo.INHERIT_DOC.isValidOn(detailAST))) {\n+            this.log(textBlock.getStartLineNo(), \"javadoc.noPeriod\", new Object[0]);\n         }\n     }\n     \n-    private void checkJavadocIsNotEmpty(final TextBlock comment) {\n-        final String commentText = getCommentText(comment.getText());\n-        if (commentText.isEmpty()) {\n-            this.log(comment.getStartLineNo(), \"javadoc.empty\", new Object[0]);\n+    private void checkJavadocIsNotEmpty(final TextBlock textBlock) {\n+        if (getCommentText(textBlock.getText()).isEmpty()) {\n+            this.log(textBlock.getStartLineNo(), \"javadoc.empty\", new Object[0]);\n         }\n     }\n     \n-    private static String getCommentText(final String... comments) {\n-        final StringBuilder builder = new StringBuilder(1024);\n-        for (final String line : comments) {\n-            final int textStart = findTextStart(line);\n+    private static String getCommentText(final String... array) {\n+        final StringBuilder sb = new StringBuilder(1024);\n+        for (final String s : array) {\n+            final int textStart = findTextStart(s);\n             if (textStart != -1) {\n-                if (line.charAt(textStart) == '@') {\n+                if (s.charAt(textStart) == '@') {\n                     break;\n                 }\n-                builder.append(line.substring(textStart));\n-                trimTail(builder);\n-                builder.append('\\n');\n+                sb.append(s.substring(textStart));\n+                trimTail(sb);\n+                sb.append('\\n');\n             }\n         }\n-        return builder.toString().trim();\n+        return sb.toString().trim();\n     }\n     \n-    private static int findTextStart(final String line) {\n-        int textStart = -1;\n-        for (int index = 0; index < line.length(); ++index) {\n-            if (!Character.isWhitespace(line.charAt(index))) {\n-                if (line.regionMatches(index, \"/**\", 0, \"/**\".length())) {\n-                    index += 2;\n+    private static int findTextStart(final String s) {\n+        int n = -1;\n+        for (int i = 0; i < s.length(); ++i) {\n+            if (!Character.isWhitespace(s.charAt(i))) {\n+                if (s.regionMatches(i, \"/**\", 0, \"/**\".length())) {\n+                    i += 2;\n                 }\n-                else if (line.regionMatches(index, \"*/\", 0, 2)) {\n-                    ++index;\n+                else if (s.regionMatches(i, \"*/\", 0, 2)) {\n+                    ++i;\n                 }\n-                else if (line.charAt(index) != '*') {\n-                    textStart = index;\n+                else if (s.charAt(i) != '*') {\n+                    n = i;\n                     break;\n                 }\n             }\n         }\n-        return textStart;\n+        return n;\n     }\n     \n-    private static void trimTail(final StringBuilder builder) {\n-        int index = builder.length() - 1;\n+    private static void trimTail(final StringBuilder sb) {\n+        int n = sb.length() - 1;\n         while (true) {\n-            if (Character.isWhitespace(builder.charAt())) {\n-                builder.deleteCharAt(index);\n+            if (Character.isWhitespace(sb.charAt())) {\n+                sb.deleteCharAt(n);\n             }\n             else {\n-                if (index <= 0 || builder.charAt() != '/' || builder.charAt() != '*') {\n+                if (n <= 0 || sb.charAt() != '/' || sb.charAt() != '*') {\n                     break;\n                 }\n-                builder.deleteCharAt(index);\n-                builder.deleteCharAt(index - 1);\n-                --index;\n-                while (builder.charAt() == '*') {\n-                    builder.deleteCharAt(index - 1);\n-                    --index;\n+                sb.deleteCharAt(n);\n+                sb.deleteCharAt(n - 1);\n+                --n;\n+                while (sb.charAt() == '*') {\n+                    sb.deleteCharAt(n - 1);\n+                    --n;\n                 }\n             }\n-            --index;\n+            --n;\n         }\n     }\n     \n-    private void checkHtmlTags(final DetailAST ast, final TextBlock comment) {\n-        final int lineNo = comment.getStartLineNo();\n-        final Deque<HtmlTag> htmlStack = new ArrayDeque<HtmlTag>();\n-        final String[] text = comment.getText();\n-        final TagParser parser = new TagParser(text, lineNo);\n-        while (parser.hasNextTag()) {\n-            final HtmlTag tag = parser.nextTag();\n-            if (tag.isIncompleteTag()) {\n-                this.log(tag.getLineNo(), \"javadoc.incompleteTag\", new Object[] { text[tag.getLineNo() - lineNo] });\n+    private void checkHtmlTags(final DetailAST detailAST, final TextBlock textBlock) {\n+        final int startLineNo = textBlock.getStartLineNo();\n+        final ArrayDeque arrayDeque = new ArrayDeque();\n+        final String[] text = textBlock.getText();\n+        final TagParser tagParser = new TagParser(text, startLineNo);\n+        while (tagParser.hasNextTag()) {\n+            final HtmlTag nextTag = tagParser.nextTag();\n+            if (nextTag.isIncompleteTag()) {\n+                this.log(nextTag.getLineNo(), \"javadoc.incompleteTag\", new Object[] { text[nextTag.getLineNo() - startLineNo] });\n                 return;\n             }\n-            if (tag.isClosedTag()) {\n+            if (nextTag.isClosedTag()) {\n                 continue;\n             }\n-            if (tag.isCloseTag()) {\n-                if (isExtraHtml(tag.getId(), htmlStack)) {\n-                    this.log(tag.getLineNo(), tag.getPosition(), \"javadoc.extraHtml\", new Object[] { tag.getText() });\n+            if (nextTag.isCloseTag()) {\n+                if (isExtraHtml(nextTag.getId(), arrayDeque)) {\n+                    this.log(nextTag.getLineNo(), nextTag.getPosition(), \"javadoc.extraHtml\", new Object[] { nextTag.getText() });\n                 }\n                 else {\n-                    this.checkUnclosedTags(htmlStack, tag.getId());\n+                    this.checkUnclosedTags(arrayDeque, nextTag.getId());\n                 }\n             }\n             else {\n-                if (!isAllowedTag(tag)) {\n+                if (!isAllowedTag(nextTag)) {\n                     continue;\n                 }\n-                htmlStack.push(tag);\n+                arrayDeque.push(nextTag);\n             }\n         }\n-        String lastFound = \"\";\n-        final List<String> typeParameters = CheckUtil.getTypeParameterNames(ast);\n-        for (final HtmlTag htmlTag : htmlStack) {\n-            if (!isSingleTag(htmlTag) && !htmlTag.getId().equals(lastFound) && !typeParameters.contains(htmlTag.getId())) {\n+        String id = \"\";\n+        final List typeParameterNames = CheckUtil.getTypeParameterNames(detailAST);\n+        for (final HtmlTag htmlTag : arrayDeque) {\n+            if (!isSingleTag(htmlTag) && !htmlTag.getId().equals(id) && !typeParameterNames.contains(htmlTag.getId())) {\n                 this.log(htmlTag.getLineNo(), htmlTag.getPosition(), \"javadoc.unclosedHtml\", new Object[] { htmlTag.getText() });\n-                lastFound = htmlTag.getId();\n+                id = htmlTag.getId();\n             }\n         }\n     }\n     \n-    private void checkUnclosedTags(final Deque<HtmlTag> htmlStack, final String token) {\n-        final Deque<HtmlTag> unclosedTags = new ArrayDeque<HtmlTag>();\n-        for (HtmlTag lastOpenTag = (HtmlTag)htmlStack.pop(); !token.equalsIgnoreCase(lastOpenTag.getId()); lastOpenTag = htmlStack.pop()) {\n-            if (!isSingleTag(lastOpenTag)) {\n-                unclosedTags.push(lastOpenTag);\n+    private void checkUnclosedTags(final Deque<HtmlTag> deque, final String s) {\n+        final ArrayDeque arrayDeque = new ArrayDeque();\n+        for (HtmlTag htmlTag = (HtmlTag)deque.pop(); !s.equalsIgnoreCase(htmlTag.getId()); htmlTag = deque.pop()) {\n+            if (!isSingleTag(htmlTag)) {\n+                arrayDeque.push(htmlTag);\n             }\n         }\n-        String lastFound = \"\";\n-        for (final HtmlTag lastOpenTag : unclosedTags) {\n-            final HtmlTag htag = lastOpenTag;\n-            if (lastOpenTag.getId().equals(lastFound)) {\n+        String id = \"\";\n+        for (final HtmlTag htmlTag2 : arrayDeque) {\n+            if (htmlTag2.getId().equals(id)) {\n                 continue;\n             }\n-            lastFound = lastOpenTag.getId();\n-            this.log(lastOpenTag.getLineNo(), lastOpenTag.getPosition(), \"javadoc.unclosedHtml\", new Object[] { lastOpenTag.getText() });\n+            id = htmlTag2.getId();\n+            this.log(htmlTag2.getLineNo(), htmlTag2.getPosition(), \"javadoc.unclosedHtml\", new Object[] { htmlTag2.getText() });\n         }\n     }\n     \n-    private static boolean isSingleTag(final HtmlTag tag) {\n-        return JavadocStyleCheck.SINGLE_TAGS.contains(tag.getId().toLowerCase(Locale.ENGLISH));\n+    private static boolean isSingleTag(final HtmlTag htmlTag) {\n+        return JavadocStyleCheck.SINGLE_TAGS.contains(htmlTag.getId().toLowerCase(Locale.ENGLISH));\n     }\n     \n-    private static boolean isAllowedTag(final HtmlTag tag) {\n-        return JavadocStyleCheck.ALLOWED_TAGS.contains(tag.getId().toLowerCase(Locale.ENGLISH));\n+    private static boolean isAllowedTag(final HtmlTag htmlTag) {\n+        return JavadocStyleCheck.ALLOWED_TAGS.contains(htmlTag.getId().toLowerCase(Locale.ENGLISH));\n     }\n     \n-    private static boolean isExtraHtml(final String token, final Deque<HtmlTag> htmlStack) {\n-        boolean isExtra = true;\n-        for (final HtmlTag tag : htmlStack) {\n-            if (token.equalsIgnoreCase(tag.getId())) {\n-                isExtra = false;\n+    private static boolean isExtraHtml(final String s, final Deque<HtmlTag> deque) {\n+        boolean b = true;\n+        final Iterator<HtmlTag> iterator = deque.iterator();\n+        while (iterator.hasNext()) {\n+            if (s.equalsIgnoreCase(((HtmlTag)iterator.next()).getId())) {\n+                b = false;\n                 break;\n             }\n         }\n-        return isExtra;\n+        return b;\n     }\n     \n     public void setScope(final Scope scope) {\n         this.scope = scope;\n     }\n     \n     public void setExcludeScope(final Scope excludeScope) {\n         this.excludeScope = excludeScope;\n     }\n     \n-    public void setEndOfSentenceFormat(final Pattern pattern) {\n-        this.endOfSentenceFormat = pattern;\n+    public void setEndOfSentenceFormat(final Pattern endOfSentenceFormat) {\n+        this.endOfSentenceFormat = endOfSentenceFormat;\n     }\n     \n-    public void setCheckFirstSentence(final boolean flag) {\n-        this.checkFirstSentence = flag;\n+    public void setCheckFirstSentence(final boolean checkFirstSentence) {\n+        this.checkFirstSentence = checkFirstSentence;\n     }\n     \n-    public void setCheckHtml(final boolean flag) {\n-        this.checkHtml = flag;\n+    public void setCheckHtml(final boolean checkHtml) {\n+        this.checkHtml = checkHtml;\n     }\n     \n-    public void setCheckEmptyJavadoc(final boolean flag) {\n-        this.checkEmptyJavadoc = flag;\n+    public void setCheckEmptyJavadoc(final boolean checkEmptyJavadoc) {\n+        this.checkEmptyJavadoc = checkEmptyJavadoc;\n     }\n     \n     static {\n         SINGLE_TAGS = Set.of(\"br\", \"li\", \"dt\", \"dd\", \"hr\", \"img\", \"p\", \"td\", \"tr\", \"th\");\n         ALLOWED_TAGS = Set.of(new String[] { \"a\", \"abbr\", \"acronym\", \"address\", \"area\", \"b\", \"bdo\", \"big\", \"blockquote\", \"br\", \"caption\", \"cite\", \"code\", \"colgroup\", \"dd\", \"del\", \"dfn\", \"div\", \"dl\", \"dt\", \"em\", \"fieldset\", \"font\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"hr\", \"i\", \"img\", \"ins\", \"kbd\", \"li\", \"ol\", \"p\", \"pre\", \"q\", \"samp\", \"small\", \"span\", \"strong\", \"sub\", \"sup\", \"table\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\", \"tt\", \"u\", \"ul\", \"var\" });\n     }\n }\n"}]}
