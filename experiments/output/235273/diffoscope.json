{"diffoscope-json-version": 1, "source1": "first/ByteOrderMark.class", "source2": "second/ByteOrderMark.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -14,89 +14,90 @@\n     public static final ByteOrderMark UTF_16LE;\n     public static final ByteOrderMark UTF_32BE;\n     public static final ByteOrderMark UTF_32LE;\n     public static final char UTF_BOM = '\\ufeff';\n     private final String charsetName;\n     private final int[] bytes;\n     \n-    public ByteOrderMark(final String charsetName, final int... bytes) {\n-        Objects.requireNonNull(charsetName, \"charsetName\");\n-        Objects.requireNonNull(bytes, \"bytes\");\n-        if (charsetName.isEmpty()) {\n+    public ByteOrderMark(final String s, final int... obj) {\n+        Objects.requireNonNull(s, \"charsetName\");\n+        Objects.requireNonNull(obj, \"bytes\");\n+        if (s.isEmpty()) {\n             throw new IllegalArgumentException(\"No charsetName specified\");\n         }\n-        if (bytes.length == 0) {\n+        if (obj.length == 0) {\n             throw new IllegalArgumentException(\"No bytes specified\");\n         }\n-        this.charsetName = charsetName;\n-        this.bytes = bytes.clone();\n+        this.charsetName = s;\n+        this.bytes = obj.clone();\n     }\n     \n     @Override\n-    public boolean equals(final Object obj) {\n-        if (!(obj instanceof ByteOrderMark)) {\n+    public boolean equals(final Object o) {\n+        if (!(o instanceof ByteOrderMark)) {\n             return false;\n         }\n-        final ByteOrderMark bom = (ByteOrderMark)obj;\n-        if (this.bytes.length != bom.length()) {\n+        final ByteOrderMark byteOrderMark = (ByteOrderMark)o;\n+        if (this.bytes.length != byteOrderMark.length()) {\n             return false;\n         }\n         for (int i = 0; i < this.bytes.length; ++i) {\n-            if (this.bytes[i] != bom.get(i)) {\n+            if (this.bytes[i] != byteOrderMark.get(i)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    public int get(final int pos) {\n-        return this.bytes[pos];\n+    public int get(final int n) {\n+        return this.bytes[n];\n     }\n     \n     public byte[] getBytes() {\n-        final byte[] copy = IOUtils.byteArray(this.bytes.length);\n+        final byte[] byteArray = IOUtils.byteArray(this.bytes.length);\n         for (int i = 0; i < this.bytes.length; ++i) {\n-            copy[i] = (byte)this.bytes[i];\n+            byteArray[i] = (byte)this.bytes[i];\n         }\n-        return copy;\n+        return byteArray;\n     }\n     \n     public String getCharsetName() {\n         return this.charsetName;\n     }\n     \n     @Override\n     public int hashCode() {\n         int hashCode = this.getClass().hashCode();\n-        for (final int b : this.bytes) {\n-            hashCode += b;\n+        final int[] bytes = this.bytes;\n+        for (int length = bytes.length, i = 0; i < length; ++i) {\n+            hashCode += bytes[i];\n         }\n         return hashCode;\n     }\n     \n     public int length() {\n         return this.bytes.length;\n     }\n     \n     @Override\n     public String toString() {\n-        final StringBuilder builder = new StringBuilder();\n-        builder.append(this.getClass().getSimpleName());\n-        builder.append('[');\n-        builder.append(this.charsetName);\n-        builder.append(\": \");\n+        final StringBuilder sb = new StringBuilder();\n+        sb.append(this.getClass().getSimpleName());\n+        sb.append('[');\n+        sb.append(this.charsetName);\n+        sb.append(\": \");\n         for (int i = 0; i < this.bytes.length; ++i) {\n             if (i > 0) {\n-                builder.append(\",\");\n+                sb.append(\",\");\n             }\n-            builder.append(\"0x\");\n-            builder.append(Integer.toHexString(0xFF & this.bytes[i]).toUpperCase(Locale.ROOT));\n+            sb.append(\"0x\");\n+            sb.append(Integer.toHexString(0xFF & this.bytes[i]).toUpperCase(Locale.ROOT));\n         }\n-        builder.append(']');\n-        return builder.toString();\n+        sb.append(']');\n+        return sb.toString();\n     }\n     \n     static {\n         UTF_8 = new ByteOrderMark(StandardCharsets.UTF_8.name(), new int[] { 239, 187, 191 });\n         UTF_16BE = new ByteOrderMark(StandardCharsets.UTF_16BE.name(), new int[] { 254, 255 });\n         UTF_16LE = new ByteOrderMark(StandardCharsets.UTF_16LE.name(), new int[] { 255, 254 });\n         UTF_32BE = new ByteOrderMark(\"UTF-32BE\", new int[] { 0, 0, 254, 255 });\n"}]}
