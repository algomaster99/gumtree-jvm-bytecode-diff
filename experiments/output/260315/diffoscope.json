{"diffoscope-json-version": 1, "source1": "first/CharSequenceInputStream.class", "source2": "second/CharSequenceInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -18,115 +18,115 @@\n     private static final int NO_MARK = -1;\n     private final CharsetEncoder encoder;\n     private final CharBuffer cbuf;\n     private final ByteBuffer bbuf;\n     private int mark_cbuf;\n     private int mark_bbuf;\n     \n-    public CharSequenceInputStream(final CharSequence cs, final Charset charset, final int bufferSize) {\n+    public CharSequenceInputStream(final CharSequence csq, final Charset charset, final int n) {\n         this.encoder = charset.newEncoder().onMalformedInput(CodingErrorAction.REPLACE).onUnmappableCharacter(CodingErrorAction.REPLACE);\n         final float maxBytesPerChar = this.encoder.maxBytesPerChar();\n-        if (bufferSize < maxBytesPerChar) {\n-            throw new IllegalArgumentException(\"Buffer size \" + bufferSize + \" is less than maxBytesPerChar \" + maxBytesPerChar);\n+        if (n < maxBytesPerChar) {\n+            throw new IllegalArgumentException(\"Buffer size \" + n + \" is less than maxBytesPerChar \" + maxBytesPerChar);\n         }\n-        (this.bbuf = ByteBuffer.allocate(bufferSize)).flip();\n-        this.cbuf = CharBuffer.wrap(cs);\n+        (this.bbuf = ByteBuffer.allocate(n)).flip();\n+        this.cbuf = CharBuffer.wrap(csq);\n         this.mark_cbuf = -1;\n         this.mark_bbuf = -1;\n     }\n     \n-    public CharSequenceInputStream(final CharSequence cs, final String charset, final int bufferSize) {\n-        this(cs, Charset.forName(charset), bufferSize);\n+    public CharSequenceInputStream(final CharSequence charSequence, final String charsetName, final int n) {\n+        this(charSequence, Charset.forName(charsetName), n);\n     }\n     \n-    public CharSequenceInputStream(final CharSequence cs, final Charset charset) {\n-        this(cs, charset, 2048);\n+    public CharSequenceInputStream(final CharSequence charSequence, final Charset charset) {\n+        this(charSequence, charset, 2048);\n     }\n     \n-    public CharSequenceInputStream(final CharSequence cs, final String charset) {\n-        this(cs, charset, 2048);\n+    public CharSequenceInputStream(final CharSequence charSequence, final String s) {\n+        this(charSequence, s, 2048);\n     }\n     \n     private void fillBuffer() throws CharacterCodingException {\n         this.bbuf.compact();\n-        final CoderResult result = this.encoder.encode(this.cbuf, this.bbuf, true);\n-        if (result.isError()) {\n-            result.throwException();\n+        final CoderResult encode = this.encoder.encode(this.cbuf, this.bbuf, true);\n+        if (encode.isError()) {\n+            encode.throwException();\n         }\n         this.bbuf.flip();\n     }\n     \n     @Override\n-    public int read(final byte[] array, int off, int len) throws IOException {\n+    public int read(final byte[] array, int n, int i) throws IOException {\n         Objects.requireNonNull(array, \"array\");\n-        if (len < 0 || off + len > array.length) {\n-            throw new IndexOutOfBoundsException(\"Array Size=\" + array.length + \", offset=\" + off + \", length=\" + len);\n+        if (i < 0 || n + i > array.length) {\n+            throw new IndexOutOfBoundsException(\"Array Size=\" + array.length + \", offset=\" + n + \", length=\" + i);\n         }\n-        if (len == 0) {\n+        if (i == 0) {\n             return 0;\n         }\n         if (!this.bbuf.hasRemaining() && !this.cbuf.hasRemaining()) {\n             return -1;\n         }\n-        int bytesRead = 0;\n-        while (len > 0) {\n+        int n2 = 0;\n+        while (i > 0) {\n             if (this.bbuf.hasRemaining()) {\n-                final int chunk = Math.min(this.bbuf.remaining(), len);\n-                this.bbuf.get(array, off, chunk);\n-                off += chunk;\n-                len -= chunk;\n-                bytesRead += chunk;\n+                final int min = Math.min(this.bbuf.remaining(), i);\n+                this.bbuf.get(array, n, min);\n+                n += min;\n+                i -= min;\n+                n2 += min;\n             }\n             else {\n                 this.fillBuffer();\n                 if (!this.bbuf.hasRemaining() && !this.cbuf.hasRemaining()) {\n                     break;\n                 }\n                 continue;\n             }\n         }\n-        return (bytesRead == 0 && !this.cbuf.hasRemaining()) ? -1 : bytesRead;\n+        return (n2 == 0 && !this.cbuf.hasRemaining()) ? -1 : n2;\n     }\n     \n     @Override\n     public int read() throws IOException {\n         while (!this.bbuf.hasRemaining()) {\n             this.fillBuffer();\n             if (!this.bbuf.hasRemaining() && !this.cbuf.hasRemaining()) {\n                 return -1;\n             }\n         }\n         return this.bbuf.get() & 0xFF;\n     }\n     \n     @Override\n-    public int read(final byte[] b) throws IOException {\n-        return this.read(b, 0, b.length);\n+    public int read(final byte[] array) throws IOException {\n+        return this.read(array, 0, array.length);\n     }\n     \n     @Override\n     public long skip(long n) throws IOException {\n-        long skipped;\n-        for (skipped = 0L; n > 0L && this.available() > 0; --n, ++skipped) {\n+        long n2;\n+        for (n2 = 0L; n > 0L && this.available() > 0; --n, ++n2) {\n             this.read();\n         }\n-        return skipped;\n+        return n2;\n     }\n     \n     @Override\n     public int available() throws IOException {\n         return this.bbuf.remaining() + this.cbuf.remaining();\n     }\n     \n     @Override\n     public void close() throws IOException {\n     }\n     \n     @Override\n-    public synchronized void mark(final int readlimit) {\n+    public synchronized void mark(final int n) {\n         this.mark_cbuf = this.cbuf.position();\n         this.mark_bbuf = this.bbuf.position();\n         this.cbuf.mark();\n         this.bbuf.mark();\n     }\n     \n     @Override\n"}]}
