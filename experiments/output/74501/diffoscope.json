{"diffoscope-json-version": 1, "source1": "first/MergeCombiner.class", "source2": "second/MergeCombiner.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,73 +1,65 @@\n \n package org.apache.commons.configuration2.tree;\n \n import java.util.Iterator;\n+import java.util.Objects;\n import java.util.ArrayList;\n import java.util.function.BiConsumer;\n import java.util.Map;\n import java.util.HashMap;\n import java.util.function.Consumer;\n-import java.util.Objects;\n import java.util.List;\n import java.util.Collection;\n import java.util.LinkedList;\n \n public class MergeCombiner extends NodeCombiner\n {\n     public ImmutableNode combine(final ImmutableNode node1, final ImmutableNode node2) {\n         final ImmutableNode.Builder result = new ImmutableNode.Builder();\n         result.name(node1.getNodeName());\n         result.value(node1.getValue());\n         this.addAttributes(result, node1, node2);\n         final List<ImmutableNode> children2 = new LinkedList<ImmutableNode>(node2.getChildren());\n         node1.forEach(child1 -> {\n-            final ImmutableNode child2 = this.canCombine(node2, child1, children2);\n+            final ImmutableNode child2 = this.canCombine(node3, child1, children3);\n             if (child2 != null) {\n-                result.addChild(this.combine(child1, child2));\n-                children2.remove(child2);\n+                builder.addChild(this.combine(child1, child2));\n+                children3.remove(child2);\n             }\n             else {\n-                result.addChild(child1);\n+                builder.addChild(child1);\n             }\n             return;\n         });\n-        final List<ImmutableNode> list = children2;\n-        final ImmutableNode.Builder obj = result;\n-        Objects.requireNonNull(obj);\n-        list.forEach(obj::addChild);\n+        children2.forEach(result::addChild);\n         return result.create();\n     }\n     \n     protected void addAttributes(final ImmutableNode.Builder result, final ImmutableNode node1, final ImmutableNode node2) {\n         final Map<String, Object> attributes = new HashMap<String, Object>(node1.getAttributes());\n-        final Map attributes2 = node2.getAttributes();\n-        final Map<String, Object> obj = attributes;\n-        Objects.requireNonNull((HashMap)obj);\n-        attributes2.forEach(obj::putIfAbsent);\n+        node2.getAttributes().forEach(attributes::putIfAbsent);\n         result.addAttributes((Map)attributes);\n     }\n     \n     protected ImmutableNode canCombine(final ImmutableNode node2, final ImmutableNode child, final List<ImmutableNode> children2) {\n         final Map<String, Object> attrs1 = child.getAttributes();\n         final List<ImmutableNode> nodes = new ArrayList<ImmutableNode>();\n         final List<ImmutableNode> children3 = MergeCombiner.HANDLER.getChildren((Object)node2, child.getNodeName());\n         children3.forEach(node -> {\n-            if (matchAttributes(attrs1, node)) {\n-                nodes.add(node);\n+            if (matchAttributes(attrs2, node)) {\n+                list.add(node);\n             }\n             return;\n         });\n         if (nodes.size() == 1) {\n             return nodes.get(0);\n         }\n         if (nodes.size() > 1 && !this.isListNode(child)) {\n-            final List<ImmutableNode> list = nodes;\n-            Objects.requireNonNull(children2);\n-            list.forEach(children2::remove);\n+            nodes.forEach(children2::remove);\n         }\n         return null;\n     }\n     \n     private static boolean matchAttributes(final Map<String, Object> attrs1, final ImmutableNode node) {\n         final Map<String, Object> attrs2 = node.getAttributes();\n         for (final Map.Entry<String, Object> e : attrs1.entrySet()) {\n"}]}
