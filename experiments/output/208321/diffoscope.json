{"diffoscope-json-version": 1, "source1": "first/CharSequenceInputStream.class", "source2": "second/CharSequenceInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -18,58 +18,58 @@\n     private static final int NO_MARK = -1;\n     private final CharsetEncoder charsetEncoder;\n     private final CharBuffer cBuf;\n     private final ByteBuffer bBuf;\n     private int cBufMark;\n     private int bBufMark;\n     \n-    public CharSequenceInputStream(final CharSequence cs, final Charset charset) {\n-        this(cs, charset, 8192);\n+    public CharSequenceInputStream(final CharSequence charSequence, final Charset charset) {\n+        this(charSequence, charset, 8192);\n     }\n     \n-    public CharSequenceInputStream(final CharSequence cs, final Charset charset, final int bufferSize) {\n+    public CharSequenceInputStream(final CharSequence csq, final Charset charset, final int n) {\n         this.charsetEncoder = Charsets.toCharset(charset).newEncoder().onMalformedInput(CodingErrorAction.REPLACE).onUnmappableCharacter(CodingErrorAction.REPLACE);\n-        (this.bBuf = ByteBuffer.allocate(ReaderInputStream.checkMinBufferSize(this.charsetEncoder, bufferSize))).flip();\n-        this.cBuf = CharBuffer.wrap(cs);\n+        (this.bBuf = ByteBuffer.allocate(ReaderInputStream.checkMinBufferSize(this.charsetEncoder, n))).flip();\n+        this.cBuf = CharBuffer.wrap(csq);\n         this.cBufMark = -1;\n         this.bBufMark = -1;\n     }\n     \n-    public CharSequenceInputStream(final CharSequence cs, final String charset) {\n-        this(cs, charset, 8192);\n+    public CharSequenceInputStream(final CharSequence charSequence, final String s) {\n+        this(charSequence, s, 8192);\n     }\n     \n-    public CharSequenceInputStream(final CharSequence cs, final String charset, final int bufferSize) {\n-        this(cs, Charsets.toCharset(charset), bufferSize);\n+    public CharSequenceInputStream(final CharSequence charSequence, final String s, final int n) {\n+        this(charSequence, Charsets.toCharset(s), n);\n     }\n     \n     @Override\n     public int available() throws IOException {\n         return this.bBuf.remaining() + this.cBuf.remaining();\n     }\n     \n     @Override\n     public void close() throws IOException {\n     }\n     \n     private void fillBuffer() throws CharacterCodingException {\n         this.bBuf.compact();\n-        final CoderResult result = this.charsetEncoder.encode(this.cBuf, this.bBuf, true);\n-        if (result.isError()) {\n-            result.throwException();\n+        final CoderResult encode = this.charsetEncoder.encode(this.cBuf, this.bBuf, true);\n+        if (encode.isError()) {\n+            encode.throwException();\n         }\n         this.bBuf.flip();\n     }\n     \n     CharsetEncoder getCharsetEncoder() {\n         return this.charsetEncoder;\n     }\n     \n     @Override\n-    public synchronized void mark(final int readlimit) {\n+    public synchronized void mark(final int n) {\n         this.cBufMark = this.cBuf.position();\n         this.bBufMark = this.bBuf.position();\n         this.cBuf.mark();\n         this.bBuf.mark();\n     }\n     \n     @Override\n@@ -85,48 +85,48 @@\n                 return -1;\n             }\n         }\n         return this.bBuf.get() & 0xFF;\n     }\n     \n     @Override\n-    public int read(final byte[] b) throws IOException {\n-        return this.read(b, 0, b.length);\n+    public int read(final byte[] array) throws IOException {\n+        return this.read(array, 0, array.length);\n     }\n     \n     @Override\n-    public int read(final byte[] array, int off, int len) throws IOException {\n+    public int read(final byte[] array, int n, int i) throws IOException {\n         Objects.requireNonNull(array, \"array\");\n-        if (len < 0 || off + len > array.length) {\n-            throw new IndexOutOfBoundsException(\"Array Size=\" + array.length + \", offset=\" + off + \", length=\" + len);\n+        if (i < 0 || n + i > array.length) {\n+            throw new IndexOutOfBoundsException(\"Array Size=\" + array.length + \", offset=\" + n + \", length=\" + i);\n         }\n-        if (len == 0) {\n+        if (i == 0) {\n             return 0;\n         }\n         if (!this.bBuf.hasRemaining() && !this.cBuf.hasRemaining()) {\n             return -1;\n         }\n-        int bytesRead = 0;\n-        while (len > 0) {\n+        int n2 = 0;\n+        while (i > 0) {\n             if (this.bBuf.hasRemaining()) {\n-                final int chunk = Math.min(this.bBuf.remaining(), len);\n-                this.bBuf.get(array, off, chunk);\n-                off += chunk;\n-                len -= chunk;\n-                bytesRead += chunk;\n+                final int min = Math.min(this.bBuf.remaining(), i);\n+                this.bBuf.get(array, n, min);\n+                n += min;\n+                i -= min;\n+                n2 += min;\n             }\n             else {\n                 this.fillBuffer();\n                 if (!this.bBuf.hasRemaining() && !this.cBuf.hasRemaining()) {\n                     break;\n                 }\n                 continue;\n             }\n         }\n-        return (bytesRead == 0 && !this.cBuf.hasRemaining()) ? -1 : bytesRead;\n+        return (n2 == 0 && !this.cBuf.hasRemaining()) ? -1 : n2;\n     }\n     \n     @Override\n     public synchronized void reset() throws IOException {\n         if (this.cBufMark != -1) {\n             if (this.cBuf.position() != 0) {\n                 this.charsetEncoder.reset();\n@@ -146,14 +146,14 @@\n             this.cBufMark = -1;\n             this.bBufMark = -1;\n         }\n     }\n     \n     @Override\n     public long skip(long n) throws IOException {\n-        long skipped;\n-        for (skipped = 0L; n > 0L && this.available() > 0; --n, ++skipped) {\n+        long n2;\n+        for (n2 = 0L; n > 0L && this.available() > 0; --n, ++n2) {\n             this.read();\n         }\n-        return skipped;\n+        return n2;\n     }\n }\n"}]}
