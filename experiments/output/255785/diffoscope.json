{"diffoscope-json-version": 1, "source1": "first/HuffmanDecoder.class", "source2": "second/HuffmanDecoder.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -31,192 +31,183 @@\n     \n     @Override\n     public void close() {\n         this.state = (HuffmanDecoder.DecoderState)new HuffmanDecoder.InitialState((HuffmanDecoder.HuffmanDecoder$1)null);\n         this.reader = null;\n     }\n     \n-    public int decode(final byte[] b) throws IOException {\n-        return this.decode(b, 0, b.length);\n+    public int decode(final byte[] array) throws IOException {\n+        return this.decode(array, 0, array.length);\n     }\n     \n-    public int decode(final byte[] b, final int off, final int len) throws IOException {\n+    public int decode(final byte[] array, final int n, final int n2) throws IOException {\n         while (!this.finalBlock || this.state.hasData()) {\n             if (this.state.state() == HuffmanState.INITIAL) {\n                 this.finalBlock = (this.readBits(1) == 1L);\n-                final int mode = (int)this.readBits(2);\n-                switch (mode) {\n+                final int n3 = (int)this.readBits(2);\n+                switch (n3) {\n                     case 0: {\n                         this.switchToUncompressedState();\n                         continue;\n                     }\n                     case 1: {\n                         this.state = (HuffmanDecoder.DecoderState)new HuffmanDecoder.HuffmanCodes(this, HuffmanState.FIXED_CODES, HuffmanDecoder.FIXED_LITERALS, HuffmanDecoder.FIXED_DISTANCE);\n                         continue;\n                     }\n                     case 2: {\n-                        final int[][] tables = this.readDynamicTables();\n-                        this.state = (HuffmanDecoder.DecoderState)new HuffmanDecoder.HuffmanCodes(this, HuffmanState.DYNAMIC_CODES, tables[0], tables[1]);\n+                        final int[][] dynamicTables = this.readDynamicTables();\n+                        this.state = (HuffmanDecoder.DecoderState)new HuffmanDecoder.HuffmanCodes(this, HuffmanState.DYNAMIC_CODES, dynamicTables[0], dynamicTables[1]);\n                         continue;\n                     }\n                     default: {\n-                        throw new IllegalStateException(\"Unsupported compression: \" + mode);\n+                        throw new IllegalStateException(\"Unsupported compression: \" + n3);\n                     }\n                 }\n             }\n             else {\n-                final int r = this.state.read(b, off, len);\n-                if (r != 0) {\n-                    return r;\n+                final int read = this.state.read(array, n, n2);\n+                if (read != 0) {\n+                    return read;\n                 }\n                 continue;\n             }\n         }\n         return -1;\n     }\n     \n     long getBytesRead() {\n         return this.reader.getBytesRead();\n     }\n     \n     private void switchToUncompressedState() throws IOException {\n         this.reader.alignWithByteBoundary();\n-        final long bLen = this.readBits(16);\n-        final long bNLen = this.readBits(16);\n-        if (((bLen ^ 0xFFFFL) & 0xFFFFL) != bNLen) {\n+        final long bits = this.readBits(16);\n+        if (((bits ^ 0xFFFFL) & 0xFFFFL) != this.readBits(16)) {\n             throw new IllegalStateException(\"Illegal LEN / NLEN values\");\n         }\n-        this.state = (HuffmanDecoder.DecoderState)new HuffmanDecoder.UncompressedState(this, bLen, (HuffmanDecoder.HuffmanDecoder$1)null);\n+        this.state = (HuffmanDecoder.DecoderState)new HuffmanDecoder.UncompressedState(this, bits, (HuffmanDecoder.HuffmanDecoder$1)null);\n     }\n     \n     private int[][] readDynamicTables() throws IOException {\n-        final int[][] result = new int[2][];\n-        final int literals = (int)(this.readBits(5) + 257L);\n-        result[0] = new int[literals];\n-        final int distances = (int)(this.readBits(5) + 1L);\n-        result[1] = new int[distances];\n-        populateDynamicTables(this.reader, result[0], result[1]);\n-        return result;\n+        final int[][] array = { new int[(int)(this.readBits(5) + 257L)], new int[(int)(this.readBits(5) + 1L)] };\n+        populateDynamicTables(this.reader, array[0], array[1]);\n+        return array;\n     }\n     \n     int available() throws IOException {\n         return this.state.available();\n     }\n     \n-    private static int nextSymbol(final BitInputStream reader, final HuffmanDecoder.BinaryTreeNode tree) throws IOException {\n-        HuffmanDecoder.BinaryTreeNode node;\n-        long bit;\n-        for (node = tree; node != null && node.literal == -1; node = ((bit == 0L) ? node.leftNode : node.rightNode)) {\n-            bit = readBits(reader, 1);\n-        }\n-        return (node != null) ? node.literal : -1;\n-    }\n-    \n-    private static void populateDynamicTables(final BitInputStream reader, final int[] literals, final int[] distances) throws IOException {\n-        final int codeLengths = (int)(readBits(reader, 4) + 4L);\n-        final int[] codeLengthValues = new int[19];\n-        for (int cLen = 0; cLen < codeLengths; ++cLen) {\n-            codeLengthValues[HuffmanDecoder.CODE_LENGTHS_ORDER[cLen]] = (int)readBits(reader, 3);\n-        }\n-        final HuffmanDecoder.BinaryTreeNode codeLengthTree = buildTree(codeLengthValues);\n-        final int[] auxBuffer = new int[literals.length + distances.length];\n-        int value = -1;\n-        int length = 0;\n-        int off = 0;\n-        while (off < auxBuffer.length) {\n-            if (length > 0) {\n-                auxBuffer[off++] = value;\n-                --length;\n+    private static int nextSymbol(final BitInputStream bitInputStream, final HuffmanDecoder.BinaryTreeNode binaryTreeNode) throws IOException {\n+        HuffmanDecoder.BinaryTreeNode binaryTreeNode2;\n+        for (binaryTreeNode2 = binaryTreeNode; binaryTreeNode2 != null && binaryTreeNode2.literal == -1; binaryTreeNode2 = ((readBits(bitInputStream, 1) == 0L) ? binaryTreeNode2.leftNode : binaryTreeNode2.rightNode)) {}\n+        return (binaryTreeNode2 != null) ? binaryTreeNode2.literal : -1;\n+    }\n+    \n+    private static void populateDynamicTables(final BitInputStream bitInputStream, final int[] array, final int[] array2) throws IOException {\n+        final int n = (int)(readBits(bitInputStream, 4) + 4L);\n+        final int[] array3 = new int[19];\n+        for (int i = 0; i < n; ++i) {\n+            array3[HuffmanDecoder.CODE_LENGTHS_ORDER[i]] = (int)readBits(bitInputStream, 3);\n+        }\n+        final HuffmanDecoder.BinaryTreeNode buildTree = buildTree(array3);\n+        final int[] array4 = new int[array.length + array2.length];\n+        int n2 = -1;\n+        int n3 = 0;\n+        int j = 0;\n+        while (j < array4.length) {\n+            if (n3 > 0) {\n+                array4[j++] = n2;\n+                --n3;\n             }\n             else {\n-                final int symbol = nextSymbol(reader, codeLengthTree);\n-                if (symbol < 16) {\n-                    value = symbol;\n-                    auxBuffer[off++] = value;\n+                final int nextSymbol = nextSymbol(bitInputStream, buildTree);\n+                if (nextSymbol < 16) {\n+                    n2 = nextSymbol;\n+                    array4[j++] = n2;\n                 }\n                 else {\n-                    switch (symbol) {\n+                    switch (nextSymbol) {\n                         case 16: {\n-                            length = (int)(readBits(reader, 2) + 3L);\n+                            n3 = (int)(readBits(bitInputStream, 2) + 3L);\n                             continue;\n                         }\n                         case 17: {\n-                            value = 0;\n-                            length = (int)(readBits(reader, 3) + 3L);\n+                            n2 = 0;\n+                            n3 = (int)(readBits(bitInputStream, 3) + 3L);\n                             continue;\n                         }\n                         case 18: {\n-                            value = 0;\n-                            length = (int)(readBits(reader, 7) + 11L);\n+                            n2 = 0;\n+                            n3 = (int)(readBits(bitInputStream, 7) + 11L);\n                             continue;\n                         }\n                     }\n                 }\n             }\n         }\n-        System.arraycopy(auxBuffer, 0, literals, 0, literals.length);\n-        System.arraycopy(auxBuffer, literals.length, distances, 0, distances.length);\n+        System.arraycopy(array4, 0, array, 0, array.length);\n+        System.arraycopy(array4, array.length, array2, 0, array2.length);\n     }\n     \n-    private static HuffmanDecoder.BinaryTreeNode buildTree(final int[] litTable) {\n-        final int[] literalCodes = getCodes(litTable);\n-        final HuffmanDecoder.BinaryTreeNode root = new HuffmanDecoder.BinaryTreeNode(0, (HuffmanDecoder.HuffmanDecoder$1)null);\n-        for (int i = 0; i < litTable.length; ++i) {\n-            final int len = litTable[i];\n-            if (len != 0) {\n-                HuffmanDecoder.BinaryTreeNode node = root;\n-                final int lit = literalCodes[len - 1];\n-                for (int p = len - 1; p >= 0; --p) {\n-                    final int bit = lit & 1 << p;\n-                    node = ((bit == 0) ? node.left() : node.right());\n-                    if (node == null) {\n+    private static HuffmanDecoder.BinaryTreeNode buildTree(final int[] array) {\n+        final int[] codes = getCodes(array);\n+        final HuffmanDecoder.BinaryTreeNode binaryTreeNode = new HuffmanDecoder.BinaryTreeNode(0, (HuffmanDecoder.HuffmanDecoder$1)null);\n+        for (int i = 0; i < array.length; ++i) {\n+            final int n = array[i];\n+            if (n != 0) {\n+                HuffmanDecoder.BinaryTreeNode binaryTreeNode2 = binaryTreeNode;\n+                final int n2 = codes[n - 1];\n+                for (int j = n - 1; j >= 0; --j) {\n+                    binaryTreeNode2 = (((n2 & 1 << j) == 0x0) ? binaryTreeNode2.left() : binaryTreeNode2.right());\n+                    if (binaryTreeNode2 == null) {\n                         throw new IllegalStateException(\"node doesn't exist in Huffman tree\");\n                     }\n                 }\n-                node.leaf(i);\n-                final int[] array = literalCodes;\n-                final int n = len - 1;\n-                ++array[n];\n+                binaryTreeNode2.leaf(i);\n+                final int[] array2 = codes;\n+                final int n3 = n - 1;\n+                ++array2[n3];\n             }\n         }\n-        return root;\n+        return binaryTreeNode;\n     }\n     \n-    private static int[] getCodes(final int[] litTable) {\n+    private static int[] getCodes(final int[] array) {\n         int max = 0;\n-        int[] blCount = new int[65];\n-        for (final int aLitTable : litTable) {\n-            if (aLitTable < 0 || aLitTable > 64) {\n-                throw new IllegalArgumentException(\"Invalid code \" + aLitTable + \" in literal table\");\n+        final int[] original = new int[65];\n+        for (final int b : array) {\n+            if (b < 0 || b > 64) {\n+                throw new IllegalArgumentException(\"Invalid code \" + b + \" in literal table\");\n             }\n-            max = Math.max(max, aLitTable);\n-            final int[] array = blCount;\n-            final int n = aLitTable;\n-            ++array[n];\n+            max = Math.max(max, b);\n+            final int[] array2 = original;\n+            final int n = b;\n+            ++array2[n];\n         }\n-        blCount = Arrays.copyOf(blCount, max + 1);\n-        int code = 0;\n-        final int[] nextCode = new int[max + 1];\n-        for (int i = 0; i <= max; ++i) {\n-            code = code + blCount[i] << 1;\n-            nextCode[i] = code;\n+        final int[] copy = Arrays.copyOf(original, max + 1);\n+        int n2 = 0;\n+        final int[] array3 = new int[max + 1];\n+        for (int j = 0; j <= max; ++j) {\n+            n2 = n2 + copy[j] << 1;\n+            array3[j] = n2;\n         }\n-        return nextCode;\n+        return array3;\n     }\n     \n-    private long readBits(final int numBits) throws IOException {\n-        return readBits(this.reader, numBits);\n+    private long readBits(final int n) throws IOException {\n+        return readBits(this.reader, n);\n     }\n     \n-    private static long readBits(final BitInputStream reader, final int numBits) throws IOException {\n-        final long r = reader.readBits(numBits);\n-        if (r == -1L) {\n+    private static long readBits(final BitInputStream bitInputStream, final int n) throws IOException {\n+        final long bits = bitInputStream.readBits(n);\n+        if (bits == -1L) {\n             throw new EOFException(\"Truncated Deflate64 Stream\");\n         }\n-        return r;\n+        return bits;\n     }\n     \n     static {\n         RUN_LENGTH_TABLE = new short[] { 96, 128, 160, 192, 224, 256, 288, 320, 353, 417, 481, 545, 610, 738, 866, 994, 1123, 1379, 1635, 1891, 2148, 2660, 3172, 3684, 4197, 5221, 6245, 7269, 112 };\n         DISTANCE_TABLE = new int[] { 16, 32, 48, 64, 81, 113, 146, 210, 275, 403, 532, 788, 1045, 1557, 2070, 3094, 4119, 6167, 8216, 12312, 16409, 24601, 32794, 49178, 65563, 98331, 131100, 196636, 262173, 393245, 524318, 786462 };\n         CODE_LENGTHS_ORDER = new int[] { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };\n         Arrays.fill(FIXED_LITERALS = new int[288], 0, 144, 8);\n"}]}
