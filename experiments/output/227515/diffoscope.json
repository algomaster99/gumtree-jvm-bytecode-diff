{"diffoscope-json-version": 1, "source1": "first/NPathComplexityCheck.class", "source2": "second/NPathComplexityCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -44,51 +44,51 @@\n         return this.getRequiredTokens();\n     }\n     \n     public int[] getRequiredTokens() {\n         return new int[] { 8, 9, 12, 11, 84, 85, 91, 83, 92, 89, 33, 95, 96, 109, 88, 94, 203, 208 };\n     }\n     \n-    public void beginTree(final DetailAST rootAST) {\n+    public void beginTree(final DetailAST detailAST) {\n         this.rangeValues.clear();\n         this.expressionValues.clear();\n         this.afterValues.clear();\n         this.processingTokenEnd.reset();\n         this.currentRangeValue = NPathComplexityCheck.INITIAL_VALUE;\n         this.branchVisited = false;\n     }\n     \n-    public void visitToken(final DetailAST ast) {\n-        switch (ast.getType()) {\n+    public void visitToken(final DetailAST detailAST) {\n+        switch (detailAST.getType()) {\n             case 83:\n             case 84:\n             case 85:\n             case 89:\n             case 91: {\n-                this.visitConditional(ast, 1);\n+                this.visitConditional(detailAST, 1);\n                 break;\n             }\n             case 109: {\n-                this.visitUnitaryOperator(ast, 2);\n+                this.visitUnitaryOperator(detailAST, 2);\n                 break;\n             }\n             case 88: {\n-                this.visitUnitaryOperator(ast, 0);\n+                this.visitUnitaryOperator(detailAST, 0);\n                 break;\n             }\n             case 33: {\n-                final int caseNumber = countCaseTokens(ast);\n+                final int countCaseTokens = countCaseTokens(detailAST);\n                 this.branchVisited = true;\n-                this.pushValue(Integer.valueOf(caseNumber));\n+                this.pushValue(Integer.valueOf(countCaseTokens));\n                 break;\n             }\n             case 208: {\n-                final int caseConstantNumber = countCaseConstants(ast);\n+                final int countCaseConstants = countCaseConstants(detailAST);\n                 this.branchVisited = true;\n-                this.pushValue(Integer.valueOf(caseConstantNumber));\n+                this.pushValue(Integer.valueOf(countCaseConstants));\n                 break;\n             }\n             case 92: {\n                 this.branchVisited = true;\n                 if (this.currentRangeValue.equals(BigInteger.ZERO)) {\n                     this.currentRangeValue = BigInteger.ONE;\n                 }\n@@ -108,16 +108,16 @@\n             case 203: {\n                 this.pushValue(Integer.valueOf(0));\n                 break;\n             }\n         }\n     }\n     \n-    public void leaveToken(final DetailAST ast) {\n-        switch (ast.getType()) {\n+    public void leaveToken(final DetailAST detailAST) {\n+        switch (detailAST.getType()) {\n             case 83:\n             case 84:\n             case 85:\n             case 89:\n             case 91: {\n                 this.leaveConditional();\n                 break;\n@@ -147,147 +147,144 @@\n                 break;\n             }\n             case 8:\n             case 9:\n             case 11:\n             case 12:\n             case 203: {\n-                this.leaveMethodDef(ast);\n+                this.leaveMethodDef(detailAST);\n                 break;\n             }\n         }\n     }\n     \n-    private void visitConditional(final DetailAST ast, final int basicBranchingFactor) {\n-        int expressionValue = basicBranchingFactor;\n-        DetailAST bracketed;\n-        for (bracketed = ast.findFirstToken(76); bracketed.getType() != 77; bracketed = bracketed.getNextSibling()) {\n-            expressionValue += countConditionalOperators(bracketed);\n+    private void visitConditional(final DetailAST detailAST, final int n) {\n+        int i = n;\n+        DetailAST token;\n+        for (token = detailAST.findFirstToken(76); token.getType() != 77; token = token.getNextSibling()) {\n+            i += countConditionalOperators(token);\n         }\n-        this.processingTokenEnd.setToken(bracketed);\n-        this.pushValue(Integer.valueOf(expressionValue));\n+        this.processingTokenEnd.setToken(token);\n+        this.pushValue(Integer.valueOf(i));\n     }\n     \n-    private void visitUnitaryOperator(final DetailAST ast, final int basicBranchingFactor) {\n-        final boolean isAfter = this.processingTokenEnd.isAfter(ast);\n-        this.afterValues.push(Boolean.valueOf(isAfter));\n-        if (!isAfter) {\n-            this.processingTokenEnd.setToken(getLastToken(ast));\n-            final int expressionValue = basicBranchingFactor + countConditionalOperators(ast);\n-            this.pushValue(Integer.valueOf(expressionValue));\n+    private void visitUnitaryOperator(final DetailAST detailAST, final int n) {\n+        final boolean after = this.processingTokenEnd.isAfter(detailAST);\n+        this.afterValues.push(Boolean.valueOf(after));\n+        if (!after) {\n+            this.processingTokenEnd.setToken(getLastToken(detailAST));\n+            this.pushValue(Integer.valueOf(n + countConditionalOperators(detailAST)));\n         }\n     }\n     \n     private void leaveUnitaryOperator() {\n         if (Boolean.FALSE.equals(this.afterValues.pop())) {\n-            final NPathComplexityCheck.Values valuePair = this.popValue();\n-            BigInteger basicRangeValue = valuePair.getRangeValue();\n-            BigInteger expressionValue = valuePair.getExpressionValue();\n-            if (expressionValue.equals(BigInteger.ZERO)) {\n-                expressionValue = BigInteger.ONE;\n+            final NPathComplexityCheck.Values popValue = this.popValue();\n+            BigInteger val = popValue.getRangeValue();\n+            BigInteger val2 = popValue.getExpressionValue();\n+            if (val2.equals(BigInteger.ZERO)) {\n+                val2 = BigInteger.ONE;\n             }\n-            if (basicRangeValue.equals(BigInteger.ZERO)) {\n-                basicRangeValue = BigInteger.ONE;\n+            if (val.equals(BigInteger.ZERO)) {\n+                val = BigInteger.ONE;\n             }\n-            this.currentRangeValue = this.currentRangeValue.add(expressionValue).multiply(basicRangeValue);\n+            this.currentRangeValue = this.currentRangeValue.add(val2).multiply(val);\n         }\n     }\n     \n     private void leaveConditional() {\n-        final NPathComplexityCheck.Values valuePair = this.popValue();\n-        final BigInteger expressionValue = valuePair.getExpressionValue();\n-        BigInteger basicRangeValue = valuePair.getRangeValue();\n+        final NPathComplexityCheck.Values popValue = this.popValue();\n+        final BigInteger expressionValue = popValue.getExpressionValue();\n+        BigInteger val = popValue.getRangeValue();\n         if (this.currentRangeValue.equals(BigInteger.ZERO)) {\n             this.currentRangeValue = BigInteger.ONE;\n         }\n-        if (basicRangeValue.equals(BigInteger.ZERO)) {\n-            basicRangeValue = BigInteger.ONE;\n+        if (val.equals(BigInteger.ZERO)) {\n+            val = BigInteger.ONE;\n         }\n-        this.currentRangeValue = this.currentRangeValue.add(expressionValue).multiply(basicRangeValue);\n+        this.currentRangeValue = this.currentRangeValue.add(expressionValue).multiply(val);\n     }\n     \n     private void leaveBranch() {\n-        final NPathComplexityCheck.Values valuePair = this.popValue();\n-        final BigInteger basicRangeValue = valuePair.getRangeValue();\n-        final BigInteger expressionValue = valuePair.getExpressionValue();\n+        final NPathComplexityCheck.Values popValue = this.popValue();\n+        final BigInteger rangeValue = popValue.getRangeValue();\n+        final BigInteger expressionValue = popValue.getExpressionValue();\n         if (this.branchVisited && this.currentRangeValue.equals(BigInteger.ZERO)) {\n             this.currentRangeValue = BigInteger.ONE;\n         }\n-        this.currentRangeValue = this.currentRangeValue.subtract(BigInteger.ONE).add(basicRangeValue).add(expressionValue);\n+        this.currentRangeValue = this.currentRangeValue.subtract(BigInteger.ONE).add(rangeValue).add(expressionValue);\n     }\n     \n-    private void leaveMethodDef(final DetailAST ast) {\n-        final BigInteger bigIntegerMax = BigInteger.valueOf(this.max);\n-        if (this.currentRangeValue.compareTo(bigIntegerMax) > 0) {\n-            this.log(ast, \"npathComplexity\", new Object[] { this.currentRangeValue, bigIntegerMax });\n+    private void leaveMethodDef(final DetailAST detailAST) {\n+        final BigInteger value = BigInteger.valueOf(this.max);\n+        if (this.currentRangeValue.compareTo(value) > 0) {\n+            this.log(detailAST, \"npathComplexity\", new Object[] { this.currentRangeValue, value });\n         }\n         this.popValue();\n         this.currentRangeValue = NPathComplexityCheck.INITIAL_VALUE;\n     }\n     \n     private void leaveAddingConditional() {\n         this.currentRangeValue = this.currentRangeValue.add(this.popValue().getRangeValue().add(BigInteger.ONE));\n     }\n     \n-    private void pushValue(final Integer expressionValue) {\n+    private void pushValue(final Integer n) {\n         this.rangeValues.push(this.currentRangeValue);\n-        this.expressionValues.push(expressionValue);\n+        this.expressionValues.push(n);\n         this.currentRangeValue = NPathComplexityCheck.INITIAL_VALUE;\n     }\n     \n     private NPathComplexityCheck.Values popValue() {\n-        final int expressionValue = (int)Integer.valueOf(this.expressionValues.pop());\n-        return new NPathComplexityCheck.Values(this.rangeValues.pop(), BigInteger.valueOf(expressionValue));\n+        return new NPathComplexityCheck.Values(this.rangeValues.pop(), BigInteger.valueOf(Integer.valueOf(this.expressionValues.pop())));\n     }\n     \n     private void leaveMultiplyingConditional() {\n         this.currentRangeValue = this.currentRangeValue.add(BigInteger.ONE).multiply(this.popValue().getRangeValue().add(BigInteger.ONE));\n     }\n     \n-    private static int countConditionalOperators(final DetailAST ast) {\n-        int number = 0;\n-        for (DetailAST child = ast.getFirstChild(); child != null; child = child.getNextSibling()) {\n-            final int type = child.getType();\n+    private static int countConditionalOperators(final DetailAST detailAST) {\n+        int n = 0;\n+        for (DetailAST detailAST2 = detailAST.getFirstChild(); detailAST2 != null; detailAST2 = detailAST2.getNextSibling()) {\n+            final int type = detailAST2.getType();\n             if (type == 110 || type == 111) {\n-                ++number;\n+                ++n;\n             }\n             else if (type == 109) {\n-                number += 2;\n+                n += 2;\n             }\n-            number += countConditionalOperators(child);\n+            n += countConditionalOperators(detailAST2);\n         }\n-        return number;\n+        return n;\n     }\n     \n-    private static DetailAST getLastToken(final DetailAST ast) {\n-        final DetailAST lastChild = ast.getLastChild();\n-        DetailAST result;\n+    private static DetailAST getLastToken(final DetailAST detailAST) {\n+        final DetailAST lastChild = detailAST.getLastChild();\n+        DetailAST lastToken;\n         if (lastChild.getFirstChild() == null) {\n-            result = lastChild;\n+            lastToken = lastChild;\n         }\n         else {\n-            result = getLastToken(lastChild);\n+            lastToken = getLastToken(lastChild);\n         }\n-        return result;\n+        return lastToken;\n     }\n     \n-    private static int countCaseTokens(final DetailAST ast) {\n-        int counter = 0;\n-        for (DetailAST iterator = ast.getFirstChild(); iterator != null; iterator = iterator.getNextSibling()) {\n-            if (iterator.getType() == 93) {\n-                ++counter;\n+    private static int countCaseTokens(final DetailAST detailAST) {\n+        int n = 0;\n+        for (DetailAST detailAST2 = detailAST.getFirstChild(); detailAST2 != null; detailAST2 = detailAST2.getNextSibling()) {\n+            if (detailAST2.getType() == 93) {\n+                ++n;\n             }\n         }\n-        return counter;\n+        return n;\n     }\n     \n-    private static int countCaseConstants(final DetailAST ast) {\n-        final AtomicInteger counter = new AtomicInteger();\n-        final DetailAST literalCase = ast.getFirstChild();\n-        TokenUtil.forEachChild(literalCase, 28, node -> counter.getAndIncrement());\n-        return counter.get();\n+    private static int countCaseConstants(final DetailAST detailAST) {\n+        final AtomicInteger atomicInteger = new AtomicInteger();\n+        TokenUtil.forEachChild(detailAST.getFirstChild(), 28, p1 -> atomicInteger2.getAndIncrement());\n+        return atomicInteger.get();\n     }\n     \n     static {\n         INITIAL_VALUE = BigInteger.ZERO;\n     }\n }\n"}]}
