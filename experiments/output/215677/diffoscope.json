{"diffoscope-json-version": 1, "source1": "first/InstructionFinder.class", "source2": "second/InstructionFinder.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,13 +1,12 @@\n \n package org.apache.bcel.util;\n \n import java.util.HashMap;\n import java.util.regex.Matcher;\n-import java.util.List;\n import java.util.ArrayList;\n import java.util.regex.Pattern;\n import org.apache.bcel.generic.ClassGenException;\n import java.util.Iterator;\n import java.util.Locale;\n import org.apache.bcel.Const;\n import org.apache.bcel.generic.InstructionHandle;\n@@ -25,122 +24,121 @@\n     \n     public InstructionFinder(final InstructionList il) {\n         this.il = il;\n         this.reread();\n     }\n     \n     public final void reread() {\n-        final int size = this.il.getLength();\n-        final char[] buf = new char[size];\n+        final int length = this.il.getLength();\n+        final char[] value = new char[length];\n         this.handles = this.il.getInstructionHandles();\n-        for (int i = 0; i < size; ++i) {\n-            buf[i] = makeChar(this.handles[i].getInstruction().getOpcode());\n+        for (int i = 0; i < length; ++i) {\n+            value[i] = makeChar(this.handles[i].getInstruction().getOpcode());\n         }\n-        this.ilString = new String(buf);\n+        this.ilString = new String(value);\n     }\n     \n-    private static String mapName(final String pattern) {\n-        final String result = (String)InstructionFinder.map.get(pattern);\n-        if (result != null) {\n-            return result;\n+    private static String mapName(final String str) {\n+        final String s = (String)InstructionFinder.map.get(str);\n+        if (s != null) {\n+            return s;\n         }\n-        for (short i = 0; i < 256; ++i) {\n-            if (pattern.equals(Const.getOpcodeName((int)i))) {\n-                return \"\" + makeChar(i);\n+        for (short n = 0; n < 256; ++n) {\n+            if (str.equals(Const.getOpcodeName((int)n))) {\n+                return \"\" + makeChar(n);\n             }\n         }\n-        throw new IllegalArgumentException(\"Instruction unknown: \" + pattern);\n+        throw new IllegalArgumentException(\"Instruction unknown: \" + str);\n     }\n     \n-    private static String compilePattern(final String pattern) {\n-        final String lower = pattern.toLowerCase(Locale.ENGLISH);\n-        final StringBuilder buf = new StringBuilder();\n-        for (int size = pattern.length(), i = 0; i < size; ++i) {\n-            char ch = lower.charAt(i);\n-            if (Character.isLetterOrDigit(ch)) {\n-                final StringBuilder name = new StringBuilder();\n-                while ((Character.isLetterOrDigit(ch) || ch == '_') && i < size) {\n-                    name.append(ch);\n-                    if (++i >= size) {\n+    private static String compilePattern(final String s) {\n+        final String lowerCase = s.toLowerCase(Locale.ENGLISH);\n+        final StringBuilder sb = new StringBuilder();\n+        for (int length = s.length(), i = 0; i < length; ++i) {\n+            char c = lowerCase.charAt(i);\n+            if (Character.isLetterOrDigit(c)) {\n+                final StringBuilder sb2 = new StringBuilder();\n+                while ((Character.isLetterOrDigit(c) || c == '_') && i < length) {\n+                    sb2.append(c);\n+                    if (++i >= length) {\n                         break;\n                     }\n-                    ch = lower.charAt(i);\n+                    c = lowerCase.charAt(i);\n                 }\n                 --i;\n-                buf.append(mapName(name.toString()));\n+                sb.append(mapName(sb2.toString()));\n             }\n-            else if (!Character.isWhitespace(ch)) {\n-                buf.append(ch);\n+            else if (!Character.isWhitespace(c)) {\n+                sb.append(c);\n             }\n         }\n-        return buf.toString();\n+        return sb.toString();\n     }\n     \n-    private InstructionHandle[] getMatch(final int matched_from, final int match_length) {\n-        final InstructionHandle[] match = new InstructionHandle[match_length];\n-        System.arraycopy(this.handles, matched_from, match, 0, match_length);\n-        return match;\n+    private InstructionHandle[] getMatch(final int n, final int n2) {\n+        final InstructionHandle[] array = new InstructionHandle[n2];\n+        System.arraycopy(this.handles, n, array, 0, n2);\n+        return array;\n     }\n     \n-    public final Iterator<InstructionHandle[]> search(final String pattern, final InstructionHandle from, final InstructionFinder.CodeConstraint constraint) {\n-        final String search = compilePattern(pattern);\n+    public final Iterator<InstructionHandle[]> search(final String s, final InstructionHandle obj, final InstructionFinder.CodeConstraint codeConstraint) {\n+        final String compilePattern = compilePattern(s);\n         int start = -1;\n         for (int i = 0; i < this.handles.length; ++i) {\n-            if (this.handles[i] == from) {\n+            if (this.handles[i] == obj) {\n                 start = i;\n                 break;\n             }\n         }\n         if (start == -1) {\n-            throw new ClassGenException(\"Instruction handle \" + from + \" not found in instruction list.\");\n+            throw new ClassGenException(\"Instruction handle \" + obj + \" not found in instruction list.\");\n         }\n-        final Pattern regex = Pattern.compile(search);\n-        final List<InstructionHandle[]> matches = new ArrayList<InstructionHandle[]>();\n-        int endExpr;\n-        for (Matcher matcher = regex.matcher(this.ilString); start < this.ilString.length() && matcher.find(start); start = endExpr) {\n-            final int startExpr = matcher.start();\n-            endExpr = matcher.end();\n-            final int lenExpr = endExpr - startExpr;\n-            final InstructionHandle[] match = this.getMatch(startExpr, lenExpr);\n-            if (constraint == null || constraint.checkCode(match)) {\n-                matches.add(match);\n+        final Pattern compile = Pattern.compile(compilePattern);\n+        final ArrayList list = new ArrayList();\n+        int end;\n+        for (Matcher matcher = compile.matcher(this.ilString); start < this.ilString.length() && matcher.find(start); start = end) {\n+            final int start2 = matcher.start();\n+            end = matcher.end();\n+            final InstructionHandle[] match = this.getMatch(start2, end - start2);\n+            if (codeConstraint == null || codeConstraint.checkCode(match)) {\n+                list.add(match);\n             }\n         }\n-        return matches.iterator();\n+        return list.iterator();\n     }\n     \n-    public final Iterator<InstructionHandle[]> search(final String pattern) {\n-        return this.search(pattern, this.il.getStart(), null);\n+    public final Iterator<InstructionHandle[]> search(final String s) {\n+        return this.search(s, this.il.getStart(), null);\n     }\n     \n-    public final Iterator<InstructionHandle[]> search(final String pattern, final InstructionHandle from) {\n-        return this.search(pattern, from, null);\n+    public final Iterator<InstructionHandle[]> search(final String s, final InstructionHandle instructionHandle) {\n+        return this.search(s, instructionHandle, null);\n     }\n     \n-    public final Iterator<InstructionHandle[]> search(final String pattern, final InstructionFinder.CodeConstraint constraint) {\n-        return this.search(pattern, this.il.getStart(), constraint);\n+    public final Iterator<InstructionHandle[]> search(final String s, final InstructionFinder.CodeConstraint codeConstraint) {\n+        return this.search(s, this.il.getStart(), codeConstraint);\n     }\n     \n-    private static char makeChar(final short opcode) {\n-        return (char)(opcode + 32767);\n+    private static char makeChar(final short n) {\n+        return (char)(n + 32767);\n     }\n     \n     public final InstructionList getInstructionList() {\n         return this.il;\n     }\n     \n-    private static String precompile(final short from, final short to, final short extra) {\n-        final StringBuilder buf = new StringBuilder(\"(\");\n-        for (short i = from; i <= to; ++i) {\n-            buf.append(makeChar(i));\n-            buf.append('|');\n-        }\n-        buf.append(makeChar(extra));\n-        buf.append(\")\");\n-        return buf.toString();\n+    private static String precompile(final short n, final short n2, final short n3) {\n+        final StringBuilder sb = new StringBuilder(\"(\");\n+        for (short n4 = n; n4 <= n2; ++n4) {\n+            sb.append(makeChar(n4));\n+            sb.append('|');\n+        }\n+        sb.append(makeChar(n3));\n+        sb.append(\")\");\n+        return sb.toString();\n     }\n     \n     static {\n         (map = new HashMap<String, String>()).put(\"arithmeticinstruction\", \"(irem|lrem|iand|ior|ineg|isub|lneg|fneg|fmul|ldiv|fadd|lxor|frem|idiv|land|ixor|ishr|fsub|lshl|fdiv|iadd|lor|dmul|lsub|ishl|imul|lmul|lushr|dneg|iushr|lshr|ddiv|drem|dadd|ladd|dsub)\");\n         InstructionFinder.map.put(\"invokeinstruction\", \"(invokevirtual|invokeinterface|invokestatic|invokespecial|invokedynamic)\");\n         InstructionFinder.map.put(\"arrayinstruction\", \"(baload|aastore|saload|caload|fastore|lastore|iaload|castore|iastore|aaload|bastore|sastore|faload|laload|daload|dastore)\");\n         InstructionFinder.map.put(\"gotoinstruction\", \"(goto|goto_w)\");\n@@ -182,28 +180,27 @@\n         InstructionFinder.map.put(\"fload\", precompile((short)34, (short)37, (short)23));\n         InstructionFinder.map.put(\"aload\", precompile((short)42, (short)45, (short)25));\n         InstructionFinder.map.put(\"lstore\", precompile((short)63, (short)66, (short)55));\n         InstructionFinder.map.put(\"istore\", precompile((short)59, (short)62, (short)54));\n         InstructionFinder.map.put(\"dstore\", precompile((short)71, (short)74, (short)57));\n         InstructionFinder.map.put(\"fstore\", precompile((short)67, (short)70, (short)56));\n         InstructionFinder.map.put(\"astore\", precompile((short)75, (short)78, (short)58));\n-        for (final Map.Entry<String, String> entry : InstructionFinder.map.entrySet()) {\n-            final String key = (String)entry.getKey();\n-            final String value = (String)entry.getValue();\n-            final char ch = value.charAt(1);\n-            if (ch < '\\u7fff') {\n-                InstructionFinder.map.put(key, compilePattern(value));\n+        for (final Map.Entry entry : InstructionFinder.map.entrySet()) {\n+            final String s = (String)entry.getKey();\n+            final String s2 = (String)entry.getValue();\n+            if (s2.charAt(1) < '\\u7fff') {\n+                InstructionFinder.map.put(s, compilePattern(s2));\n             }\n         }\n-        final StringBuilder buf = new StringBuilder(\"(\");\n-        for (short i = 0; i < 256; ++i) {\n-            if (Const.getNoOfOperands((int)i) != -1) {\n-                buf.append(makeChar(i));\n-                if (i < 255) {\n-                    buf.append('|');\n+        final StringBuilder sb = new StringBuilder(\"(\");\n+        for (short n = 0; n < 256; ++n) {\n+            if (Const.getNoOfOperands((int)n) != -1) {\n+                sb.append(makeChar(n));\n+                if (n < 255) {\n+                    sb.append('|');\n                 }\n             }\n         }\n-        buf.append(')');\n-        InstructionFinder.map.put(\"instruction\", buf.toString());\n+        sb.append(')');\n+        InstructionFinder.map.put(\"instruction\", sb.toString());\n     }\n }\n"}]}
