{"diffoscope-json-version": 1, "source1": "first/Utility.class", "source2": "second/Utility.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,14 +1,13 @@\n \n package org.apache.bcel.classfile;\n \n import java.util.Locale;\n import java.io.PrintWriter;\n import java.io.PrintStream;\n-import java.util.List;\n import org.apache.commons.lang3.ArrayUtils;\n import java.util.ArrayList;\n import java.io.Writer;\n import java.io.CharArrayWriter;\n import java.io.OutputStream;\n import java.util.zip.GZIPOutputStream;\n import java.util.Arrays;\n@@ -32,128 +31,125 @@\n     private static final char ESCAPE_CHAR = '$';\n     \n     public static String accessToString(final int accessFlags) {\n         return accessToString(accessFlags, false);\n     }\n     \n     public static String accessToString(final int accessFlags, final boolean forClass) {\n-        final StringBuilder buf = new StringBuilder();\n-        int p = 0;\n+        final StringBuilder sb = new StringBuilder();\n         int i = 0;\n-        while (p < 32768) {\n-            p = pow2(i);\n+        int n = 0;\n+        while (i < 32768) {\n+            i = pow2(n);\n             Label_0066: {\n-                if ((accessFlags & p) != 0x0) {\n+                if ((accessFlags & i) != 0x0) {\n                     if (forClass) {\n-                        if (p == 32) {\n+                        if (i == 32) {\n                             break Label_0066;\n                         }\n-                        if (p == 512) {\n+                        if (i == 512) {\n                             break Label_0066;\n                         }\n                     }\n-                    buf.append(Const.getAccessName(i)).append(\" \");\n+                    sb.append(Const.getAccessName(n)).append(\" \");\n                 }\n             }\n-            ++i;\n+            ++n;\n         }\n-        return buf.toString().trim();\n+        return sb.toString().trim();\n     }\n     \n     private static short byteToShort(final byte b) {\n         return (b < 0) ? ((short)(256 + b)) : ((short)b);\n     }\n     \n     public static String classOrInterface(final int accessFlags) {\n         return ((accessFlags & 0x200) != 0x0) ? \"interface\" : \"class\";\n     }\n     \n     public static int clearBit(final int flag, final int i) {\n-        final int bit = pow2(i);\n-        return ((flag & bit) == 0x0) ? flag : (flag ^ bit);\n+        final int pow2 = pow2(i);\n+        return ((flag & pow2) == 0x0) ? flag : (flag ^ pow2);\n     }\n     \n     public static String codeToString(final byte[] code, final ConstantPool constantPool, final int index, final int length) {\n         return codeToString(code, constantPool, index, length, true);\n     }\n     \n     public static String codeToString(final byte[] code, final ConstantPool constantPool, final int index, final int length, final boolean verbose) {\n-        final StringBuilder buf = new StringBuilder(code.length * 20);\n-        try (final ByteSequence stream = new ByteSequence(code)) {\n+        final StringBuilder sb = new StringBuilder(code.length * 20);\n+        try (final ByteSequence byteSequence = new ByteSequence(code)) {\n             for (int i = 0; i < index; ++i) {\n-                codeToString(stream, constantPool, verbose);\n+                codeToString(byteSequence, constantPool, verbose);\n             }\n-            int i = 0;\n-            while (stream.available() > 0) {\n-                if (length < 0 || i < length) {\n-                    final String indices = fillup(stream.getIndex() + \":\", 6, true, ' ');\n-                    buf.append(indices).append(codeToString(stream, constantPool, verbose)).append('\\n');\n+            int n = 0;\n+            while (byteSequence.available() > 0) {\n+                if (length < 0 || n < length) {\n+                    sb.append(fillup(byteSequence.getIndex() + \":\", 6, true, ' ')).append(codeToString(byteSequence, constantPool, verbose)).append('\\n');\n                 }\n-                ++i;\n+                ++n;\n             }\n         }\n-        catch (final IOException e) {\n-            throw new ClassFormatException(\"Byte code error: \" + buf.toString(), (Throwable)e);\n+        catch (final IOException ex) {\n+            throw new ClassFormatException(\"Byte code error: \" + sb.toString(), (Throwable)ex);\n         }\n-        return buf.toString();\n+        return sb.toString();\n     }\n     \n     public static String codeToString(final ByteSequence bytes, final ConstantPool constantPool) throws IOException {\n         return codeToString(bytes, constantPool, true);\n     }\n     \n     public static String codeToString(final ByteSequence bytes, final ConstantPool constantPool, final boolean verbose) throws IOException {\n-        final short opcode = (short)bytes.readUnsignedByte();\n-        int defaultOffset = 0;\n-        int noPadBytes = 0;\n-        final StringBuilder buf = new StringBuilder(Const.getOpcodeName((int)opcode));\n-        if (opcode == 170 || opcode == 171) {\n-            final int remainder = bytes.getIndex() % 4;\n-            noPadBytes = ((remainder == 0) ? 0 : (4 - remainder));\n-            for (int i = 0; i < noPadBytes; ++i) {\n-                final byte b;\n-                if ((b = bytes.readByte()) != 0) {\n-                    System.err.println(\"Warning: Padding byte != 0 in \" + Const.getOpcodeName((int)opcode) + \":\" + b);\n+        final short n = (short)bytes.readUnsignedByte();\n+        int int1 = 0;\n+        int n2 = 0;\n+        final StringBuilder sb = new StringBuilder(Const.getOpcodeName((int)n));\n+        if (n == 170 || n == 171) {\n+            final int n3 = bytes.getIndex() % 4;\n+            n2 = ((n3 == 0) ? 0 : (4 - n3));\n+            for (int i = 0; i < n2; ++i) {\n+                final byte byte1;\n+                if ((byte1 = bytes.readByte()) != 0) {\n+                    System.err.println(\"Warning: Padding byte != 0 in \" + Const.getOpcodeName((int)n) + \":\" + byte1);\n                 }\n             }\n-            defaultOffset = bytes.readInt();\n+            int1 = bytes.readInt();\n         }\n-        switch (opcode) {\n+        switch (n) {\n             case 170: {\n-                final int low = bytes.readInt();\n-                final int high = bytes.readInt();\n-                final int offset = bytes.getIndex() - 12 - noPadBytes - 1;\n-                defaultOffset += offset;\n-                buf.append(\"\\tdefault = \").append(defaultOffset).append(\", low = \").append(low).append(\", high = \").append(high).append(\"(\");\n-                final int[] jumpTable = new int[high - low + 1];\n-                for (int j = 0; j < jumpTable.length; ++j) {\n-                    buf.append(jumpTable[j] = offset + bytes.readInt());\n-                    if (j < jumpTable.length - 1) {\n-                        buf.append(\", \");\n+                final int int2 = bytes.readInt();\n+                final int int3 = bytes.readInt();\n+                final int n4 = bytes.getIndex() - 12 - n2 - 1;\n+                sb.append(\"\\tdefault = \").append(int1 + n4).append(\", low = \").append(int2).append(\", high = \").append(int3).append(\"(\");\n+                final int[] array = new int[int3 - int2 + 1];\n+                for (int j = 0; j < array.length; ++j) {\n+                    sb.append(array[j] = n4 + bytes.readInt());\n+                    if (j < array.length - 1) {\n+                        sb.append(\", \");\n                     }\n                 }\n-                buf.append(\")\");\n+                sb.append(\")\");\n                 break;\n             }\n             case 171: {\n-                final int npairs = bytes.readInt();\n-                final int offset = bytes.getIndex() - 8 - noPadBytes - 1;\n-                final int[] match = new int[npairs];\n-                final int[] jumpTable = new int[npairs];\n-                defaultOffset += offset;\n-                buf.append(\"\\tdefault = \").append(defaultOffset).append(\", npairs = \").append(npairs).append(\" (\");\n-                for (int j = 0; j < npairs; ++j) {\n-                    match[j] = bytes.readInt();\n-                    jumpTable[j] = offset + bytes.readInt();\n-                    buf.append(\"(\").append(match[j]).append(\", \").append(jumpTable[j]).append(\")\");\n-                    if (j < npairs - 1) {\n-                        buf.append(\", \");\n+                final int int4 = bytes.readInt();\n+                final int n5 = bytes.getIndex() - 8 - n2 - 1;\n+                final int[] array2 = new int[int4];\n+                final int[] array3 = new int[int4];\n+                sb.append(\"\\tdefault = \").append(int1 + n5).append(\", npairs = \").append(int4).append(\" (\");\n+                for (int k = 0; k < int4; ++k) {\n+                    array2[k] = bytes.readInt();\n+                    array3[k] = n5 + bytes.readInt();\n+                    sb.append(\"(\").append(array2[k]).append(\", \").append(array3[k]).append(\")\");\n+                    if (k < int4 - 1) {\n+                        sb.append(\", \");\n                     }\n                 }\n-                buf.append(\")\");\n+                sb.append(\")\");\n                 break;\n             }\n             case 153:\n             case 154:\n             case 155:\n             case 156:\n             case 157:\n@@ -166,353 +162,350 @@\n             case 164:\n             case 165:\n             case 166:\n             case 167:\n             case 168:\n             case 198:\n             case 199: {\n-                buf.append(\"\\t\\t#\").append(bytes.getIndex() - 1 + bytes.readShort());\n+                sb.append(\"\\t\\t#\").append(bytes.getIndex() - 1 + bytes.readShort());\n                 break;\n             }\n             case 200:\n             case 201: {\n-                buf.append(\"\\t\\t#\").append(bytes.getIndex() - 1 + bytes.readInt());\n+                sb.append(\"\\t\\t#\").append(bytes.getIndex() - 1 + bytes.readInt());\n                 break;\n             }\n             case 21:\n             case 22:\n             case 23:\n             case 24:\n             case 25:\n             case 54:\n             case 55:\n             case 56:\n             case 57:\n             case 58:\n             case 169: {\n-                int vindex;\n+                int l;\n                 if (Utility.wide) {\n-                    vindex = bytes.readUnsignedShort();\n+                    l = bytes.readUnsignedShort();\n                     Utility.wide = false;\n                 }\n                 else {\n-                    vindex = bytes.readUnsignedByte();\n+                    l = bytes.readUnsignedByte();\n                 }\n-                buf.append(\"\\t\\t%\").append(vindex);\n+                sb.append(\"\\t\\t%\").append(l);\n                 break;\n             }\n             case 196: {\n                 Utility.wide = true;\n-                buf.append(\"\\t(wide)\");\n+                sb.append(\"\\t(wide)\");\n                 break;\n             }\n             case 188: {\n-                buf.append(\"\\t\\t<\").append(Const.getTypeName((int)bytes.readByte())).append(\">\");\n+                sb.append(\"\\t\\t<\").append(Const.getTypeName((int)bytes.readByte())).append(\">\");\n                 break;\n             }\n             case 178:\n             case 179:\n             case 180:\n             case 181: {\n-                final int index = bytes.readUnsignedShort();\n-                buf.append(\"\\t\\t\").append(constantPool.constantToString(index, (byte)9)).append(verbose ? (\" (\" + index + \")\") : \"\");\n+                final int unsignedShort = bytes.readUnsignedShort();\n+                sb.append(\"\\t\\t\").append(constantPool.constantToString(unsignedShort, (byte)9)).append(verbose ? (\" (\" + unsignedShort + \")\") : \"\");\n                 break;\n             }\n             case 187:\n             case 192: {\n-                buf.append(\"\\t\");\n+                sb.append(\"\\t\");\n             }\n             case 193: {\n-                final int index = bytes.readUnsignedShort();\n-                buf.append(\"\\t<\").append(constantPool.constantToString(index, (byte)7)).append(\">\").append(verbose ? (\" (\" + index + \")\") : \"\");\n+                final int unsignedShort2 = bytes.readUnsignedShort();\n+                sb.append(\"\\t<\").append(constantPool.constantToString(unsignedShort2, (byte)7)).append(\">\").append(verbose ? (\" (\" + unsignedShort2 + \")\") : \"\");\n                 break;\n             }\n             case 183:\n             case 184: {\n-                final int index = bytes.readUnsignedShort();\n-                final Constant c = constantPool.getConstant(index);\n-                buf.append(\"\\t\").append(constantPool.constantToString(index, c.getTag())).append(verbose ? (\" (\" + index + \")\") : \"\");\n+                final int unsignedShort3 = bytes.readUnsignedShort();\n+                sb.append(\"\\t\").append(constantPool.constantToString(unsignedShort3, constantPool.getConstant(unsignedShort3).getTag())).append(verbose ? (\" (\" + unsignedShort3 + \")\") : \"\");\n                 break;\n             }\n             case 182: {\n-                final int index = bytes.readUnsignedShort();\n-                buf.append(\"\\t\").append(constantPool.constantToString(index, (byte)10)).append(verbose ? (\" (\" + index + \")\") : \"\");\n+                final int unsignedShort4 = bytes.readUnsignedShort();\n+                sb.append(\"\\t\").append(constantPool.constantToString(unsignedShort4, (byte)10)).append(verbose ? (\" (\" + unsignedShort4 + \")\") : \"\");\n                 break;\n             }\n             case 185: {\n-                final int index = bytes.readUnsignedShort();\n-                final int nargs = bytes.readUnsignedByte();\n-                buf.append(\"\\t\").append(constantPool.constantToString(index, (byte)11)).append(verbose ? (\" (\" + index + \")\\t\") : \"\").append(nargs).append(\"\\t\").append(bytes.readUnsignedByte());\n+                final int unsignedShort5 = bytes.readUnsignedShort();\n+                sb.append(\"\\t\").append(constantPool.constantToString(unsignedShort5, (byte)11)).append(verbose ? (\" (\" + unsignedShort5 + \")\\t\") : \"\").append(bytes.readUnsignedByte()).append(\"\\t\").append(bytes.readUnsignedByte());\n                 break;\n             }\n             case 186: {\n-                final int index = bytes.readUnsignedShort();\n-                buf.append(\"\\t\").append(constantPool.constantToString(index, (byte)18)).append(verbose ? (\" (\" + index + \")\\t\") : \"\").append(bytes.readUnsignedByte()).append(bytes.readUnsignedByte());\n+                final int unsignedShort6 = bytes.readUnsignedShort();\n+                sb.append(\"\\t\").append(constantPool.constantToString(unsignedShort6, (byte)18)).append(verbose ? (\" (\" + unsignedShort6 + \")\\t\") : \"\").append(bytes.readUnsignedByte()).append(bytes.readUnsignedByte());\n                 break;\n             }\n             case 19:\n             case 20: {\n-                final int index = bytes.readUnsignedShort();\n-                buf.append(\"\\t\\t\").append(constantPool.constantToString(index, constantPool.getConstant(index).getTag())).append(verbose ? (\" (\" + index + \")\") : \"\");\n+                final int unsignedShort7 = bytes.readUnsignedShort();\n+                sb.append(\"\\t\\t\").append(constantPool.constantToString(unsignedShort7, constantPool.getConstant(unsignedShort7).getTag())).append(verbose ? (\" (\" + unsignedShort7 + \")\") : \"\");\n                 break;\n             }\n             case 18: {\n-                final int index = bytes.readUnsignedByte();\n-                buf.append(\"\\t\\t\").append(constantPool.constantToString(index, constantPool.getConstant(index).getTag())).append(verbose ? (\" (\" + index + \")\") : \"\");\n+                final int unsignedByte = bytes.readUnsignedByte();\n+                sb.append(\"\\t\\t\").append(constantPool.constantToString(unsignedByte, constantPool.getConstant(unsignedByte).getTag())).append(verbose ? (\" (\" + unsignedByte + \")\") : \"\");\n                 break;\n             }\n             case 189: {\n-                final int index = bytes.readUnsignedShort();\n-                buf.append(\"\\t\\t<\").append(compactClassName(constantPool.getConstantString(index, (byte)7), false)).append(\">\").append(verbose ? (\" (\" + index + \")\") : \"\");\n+                final int unsignedShort8 = bytes.readUnsignedShort();\n+                sb.append(\"\\t\\t<\").append(compactClassName(constantPool.getConstantString(unsignedShort8, (byte)7), false)).append(\">\").append(verbose ? (\" (\" + unsignedShort8 + \")\") : \"\");\n                 break;\n             }\n             case 197: {\n-                final int index = bytes.readUnsignedShort();\n-                final int dimensions = bytes.readUnsignedByte();\n-                buf.append(\"\\t<\").append(compactClassName(constantPool.getConstantString(index, (byte)7), false)).append(\">\\t\").append(dimensions).append(verbose ? (\" (\" + index + \")\") : \"\");\n+                final int unsignedShort9 = bytes.readUnsignedShort();\n+                sb.append(\"\\t<\").append(compactClassName(constantPool.getConstantString(unsignedShort9, (byte)7), false)).append(\">\\t\").append(bytes.readUnsignedByte()).append(verbose ? (\" (\" + unsignedShort9 + \")\") : \"\");\n                 break;\n             }\n             case 132: {\n-                int vindex;\n-                int constant;\n+                int m;\n+                short i2;\n                 if (Utility.wide) {\n-                    vindex = bytes.readUnsignedShort();\n-                    constant = bytes.readShort();\n+                    m = bytes.readUnsignedShort();\n+                    i2 = bytes.readShort();\n                     Utility.wide = false;\n                 }\n                 else {\n-                    vindex = bytes.readUnsignedByte();\n-                    constant = bytes.readByte();\n+                    m = bytes.readUnsignedByte();\n+                    i2 = bytes.readByte();\n                 }\n-                buf.append(\"\\t\\t%\").append(vindex).append(\"\\t\").append(constant);\n+                sb.append(\"\\t\\t%\").append(m).append(\"\\t\").append(i2);\n                 break;\n             }\n             default: {\n-                if (Const.getNoOfOperands((int)opcode) > 0) {\n-                    for (int k = 0; k < Const.getOperandTypeCount((int)opcode); ++k) {\n-                        buf.append(\"\\t\\t\");\n-                        switch (Const.getOperandType((int)opcode, k)) {\n+                if (Const.getNoOfOperands((int)n) > 0) {\n+                    for (int n6 = 0; n6 < Const.getOperandTypeCount((int)n); ++n6) {\n+                        sb.append(\"\\t\\t\");\n+                        switch (Const.getOperandType((int)n, n6)) {\n                             case 8: {\n-                                buf.append(bytes.readByte());\n+                                sb.append(bytes.readByte());\n                                 break;\n                             }\n                             case 9: {\n-                                buf.append(bytes.readShort());\n+                                sb.append(bytes.readShort());\n                                 break;\n                             }\n                             case 10: {\n-                                buf.append(bytes.readInt());\n+                                sb.append(bytes.readInt());\n                                 break;\n                             }\n                             default: {\n                                 throw new IllegalStateException(\"Unreachable default case reached!\");\n                             }\n                         }\n                     }\n                     break;\n                 }\n                 break;\n             }\n         }\n-        return buf.toString();\n+        return sb.toString();\n     }\n     \n     public static String compactClassName(final String str) {\n         return compactClassName(str, true);\n     }\n     \n     public static String compactClassName(final String str, final boolean chopit) {\n         return compactClassName(str, \"java.lang.\", chopit);\n     }\n     \n     public static String compactClassName(String str, final String prefix, final boolean chopit) {\n-        final int len = prefix.length();\n+        final int length = prefix.length();\n         str = pathToPackage(str);\n-        if (chopit && str.startsWith(prefix) && str.substring(len).indexOf(46) == -1) {\n-            str = str.substring(len);\n+        if (chopit && str.startsWith(prefix) && str.substring(length).indexOf(46) == -1) {\n+            str = str.substring(length);\n         }\n         return str;\n     }\n     \n     public static String convertString(final String label) {\n-        final char[] ch = label.toCharArray();\n-        final StringBuilder buf = new StringBuilder();\n-        for (final char element : ch) {\n-            switch (element) {\n-                case '\\n': {\n-                    buf.append(\"\\\\n\");\n+        final char[] charArray = label.toCharArray();\n+        final StringBuilder sb = new StringBuilder();\n+        for (final char c : charArray) {\n+            switch (c) {\n+                case 10: {\n+                    sb.append(\"\\\\n\");\n                     break;\n                 }\n-                case '\\r': {\n-                    buf.append(\"\\\\r\");\n+                case 13: {\n+                    sb.append(\"\\\\r\");\n                     break;\n                 }\n-                case '\\\"': {\n-                    buf.append(\"\\\\\\\"\");\n+                case 34: {\n+                    sb.append(\"\\\\\\\"\");\n                     break;\n                 }\n-                case '\\'': {\n-                    buf.append(\"\\\\'\");\n+                case 39: {\n+                    sb.append(\"\\\\'\");\n                     break;\n                 }\n-                case '\\\\': {\n-                    buf.append(\"\\\\\\\\\");\n+                case 92: {\n+                    sb.append(\"\\\\\\\\\");\n                     break;\n                 }\n                 default: {\n-                    buf.append(element);\n+                    sb.append(c);\n                     break;\n                 }\n             }\n         }\n-        return buf.toString();\n+        return sb.toString();\n     }\n     \n     private static int countBrackets(final String brackets) {\n-        final char[] chars = brackets.toCharArray();\n-        int count = 0;\n-        boolean open = false;\n-        for (final char c : chars) {\n-            switch (c) {\n+        final char[] charArray = brackets.toCharArray();\n+        int n = 0;\n+        int n2 = 0;\n+        final char[] array = charArray;\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            switch (array[i]) {\n                 case '[': {\n-                    if (open) {\n+                    if (n2 != 0) {\n                         throw new IllegalArgumentException(\"Illegally nested brackets:\" + brackets);\n                     }\n-                    open = true;\n+                    n2 = 1;\n                     break;\n                 }\n                 case ']': {\n-                    if (!open) {\n+                    if (n2 == 0) {\n                         throw new IllegalArgumentException(\"Illegally nested brackets:\" + brackets);\n                     }\n-                    open = false;\n-                    ++count;\n+                    n2 = 0;\n+                    ++n;\n                     break;\n                 }\n             }\n         }\n-        if (open) {\n+        if (n2 != 0) {\n             throw new IllegalArgumentException(\"Illegally nested brackets:\" + brackets);\n         }\n-        return count;\n+        return n;\n     }\n     \n     public static byte[] decode(final String s, final boolean uncompress) throws IOException {\n-        byte[] bytes;\n-        try (final Utility.JavaReader jr = new Utility.JavaReader((Reader)new CharArrayReader(s.toCharArray()));\n-             final ByteArrayOutputStream bos = new ByteArrayOutputStream()) {\n-            int ch;\n-            while ((ch = jr.read()) >= 0) {\n-                bos.write(ch);\n+        byte[] buf;\n+        try (final Utility.JavaReader javaReader = new Utility.JavaReader((Reader)new CharArrayReader(s.toCharArray()));\n+             final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) {\n+            int read;\n+            while ((read = javaReader.read()) >= 0) {\n+                byteArrayOutputStream.write(read);\n             }\n-            bytes = bos.toByteArray();\n+            buf = byteArrayOutputStream.toByteArray();\n         }\n         if (uncompress) {\n-            final GZIPInputStream gis = new GZIPInputStream(new ByteArrayInputStream(bytes));\n-            final byte[] tmp = new byte[bytes.length * 3];\n-            int count = 0;\n-            int b;\n-            while ((b = gis.read()) >= 0) {\n-                tmp[count++] = (byte)b;\n+            final GZIPInputStream gzipInputStream = new GZIPInputStream(new ByteArrayInputStream(buf));\n+            final byte[] original = new byte[buf.length * 3];\n+            int newLength = 0;\n+            int read2;\n+            while ((read2 = gzipInputStream.read()) >= 0) {\n+                original[newLength++] = (byte)read2;\n             }\n-            bytes = Arrays.copyOf(tmp, count);\n+            buf = Arrays.copyOf(original, newLength);\n         }\n-        return bytes;\n+        return buf;\n     }\n     \n     public static String encode(byte[] bytes, final boolean compress) throws IOException {\n         if (compress) {\n-            try (final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-                 final GZIPOutputStream gos = new GZIPOutputStream(baos)) {\n-                gos.write(bytes, 0, bytes.length);\n-                gos.close();\n-                bytes = baos.toByteArray();\n+            try (final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+                 final GZIPOutputStream gzipOutputStream = new GZIPOutputStream(out)) {\n+                gzipOutputStream.write(bytes, 0, bytes.length);\n+                gzipOutputStream.close();\n+                bytes = out.toByteArray();\n             }\n         }\n-        final CharArrayWriter caw = new CharArrayWriter();\n-        try (final Utility.JavaWriter jw = new Utility.JavaWriter((Writer)caw)) {\n-            for (final byte b : bytes) {\n-                final int in = b & 0xFF;\n-                jw.write(in);\n+        final CharArrayWriter charArrayWriter = new CharArrayWriter();\n+        try (final Utility.JavaWriter javaWriter = new Utility.JavaWriter((Writer)charArrayWriter)) {\n+            final byte[] array = bytes;\n+            for (int length = array.length, i = 0; i < length; ++i) {\n+                javaWriter.write(array[i] & 0xFF);\n             }\n         }\n-        return caw.toString();\n+        return charArrayWriter.toString();\n     }\n     \n     public static String fillup(final String str, final int length, final boolean leftJustify, final char fill) {\n-        final int len = length - str.length();\n-        final char[] buf = new char[Math.max(len, 0)];\n-        Arrays.fill(buf, fill);\n+        final char[] value = new char[Math.max(length - str.length(), 0)];\n+        Arrays.fill(value, fill);\n         if (leftJustify) {\n-            return str + new String(buf);\n+            return str + new String(value);\n         }\n-        return new String(buf) + str;\n+        return new String(value) + str;\n     }\n     \n     public static String format(final int i, final int length, final boolean leftJustify, final char fill) {\n         return fillup(Integer.toString(i), length, leftJustify, fill);\n     }\n     \n     public static String getSignature(String type) {\n-        final StringBuilder buf = new StringBuilder();\n-        final char[] chars = type.toCharArray();\n-        boolean charFound = false;\n-        boolean delim = false;\n-        int index = -1;\n+        final StringBuilder sb = new StringBuilder();\n+        final char[] charArray = type.toCharArray();\n+        int n = 0;\n+        boolean b = false;\n+        int beginIndex = -1;\n     Label_0162:\n-        for (int i = 0; i < chars.length; ++i) {\n-            switch (chars[i]) {\n+        for (int i = 0; i < charArray.length; ++i) {\n+            switch (charArray[i]) {\n                 case '\\t':\n                 case '\\n':\n                 case '\\f':\n                 case '\\r':\n                 case ' ': {\n-                    if (charFound) {\n-                        delim = true;\n+                    if (n != 0) {\n+                        b = true;\n                         break;\n                     }\n                     break;\n                 }\n                 case '[': {\n-                    if (!charFound) {\n+                    if (n == 0) {\n                         throw new IllegalArgumentException(\"Illegal type: \" + type);\n                     }\n-                    index = i;\n+                    beginIndex = i;\n                     break Label_0162;\n                 }\n                 default: {\n-                    charFound = true;\n-                    if (!delim) {\n-                        buf.append(chars[i]);\n+                    n = 1;\n+                    if (!b) {\n+                        sb.append(charArray[i]);\n                         break;\n                     }\n                     break;\n                 }\n             }\n         }\n-        int brackets = 0;\n-        if (index > 0) {\n-            brackets = countBrackets(type.substring(index));\n-        }\n-        type = buf.toString();\n-        buf.setLength();\n-        for (int j = 0; j < brackets; ++j) {\n-            buf.append('[');\n-        }\n-        boolean found = false;\n-        for (int k = 4; k <= 12 && !found; ++k) {\n-            if (Const.getTypeName(k).equals(type)) {\n-                found = true;\n-                buf.append(Const.getShortTypeName(k));\n+        int countBrackets = 0;\n+        if (beginIndex > 0) {\n+            countBrackets = countBrackets(type.substring(beginIndex));\n+        }\n+        type = sb.toString();\n+        sb.setLength();\n+        for (int j = 0; j < countBrackets; ++j) {\n+            sb.append('[');\n+        }\n+        int n2 = 0;\n+        for (int n3 = 4; n3 <= 12 && n2 == 0; ++n3) {\n+            if (Const.getTypeName(n3).equals(type)) {\n+                n2 = 1;\n+                sb.append(Const.getShortTypeName(n3));\n             }\n         }\n-        if (!found) {\n-            buf.append('L').append(packageToPath(type)).append(';');\n+        if (n2 == 0) {\n+            sb.append('L').append(packageToPath(type)).append(';');\n         }\n-        return buf.toString();\n+        return sb.toString();\n     }\n     \n     public static boolean isJavaIdentifierPart(final char ch) {\n         return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch == '_';\n     }\n     \n     public static boolean isSet(final int flag, final int i) {\n@@ -520,115 +513,114 @@\n     }\n     \n     public static String[] methodSignatureArgumentTypes(final String signature) throws ClassFormatException {\n         return methodSignatureArgumentTypes(signature, true);\n     }\n     \n     public static String[] methodSignatureArgumentTypes(final String signature, final boolean chopit) throws ClassFormatException {\n-        final List<String> vec = new ArrayList<String>();\n+        final ArrayList list = new ArrayList();\n         try {\n-            int index = signature.indexOf(40) + 1;\n-            if (index <= 0) {\n+            int n = signature.indexOf(40) + 1;\n+            if (n <= 0) {\n                 throw new ClassFormatException(\"Invalid method signature: \" + signature);\n             }\n-            while (signature.charAt(index) != ')') {\n-                vec.add(typeSignatureToString(signature.substring(index), chopit));\n-                index += unwrap(Utility.CONSUMER_CHARS);\n+            while (signature.charAt(n) != ')') {\n+                list.add(typeSignatureToString(signature.substring(n), chopit));\n+                n += unwrap(Utility.CONSUMER_CHARS);\n             }\n         }\n-        catch (final StringIndexOutOfBoundsException e) {\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)e);\n+        catch (final StringIndexOutOfBoundsException ex) {\n+            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)ex);\n         }\n-        return vec.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n+        return (String[])list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n     }\n     \n     public static String methodSignatureReturnType(final String signature) throws ClassFormatException {\n         return methodSignatureReturnType(signature, true);\n     }\n     \n     public static String methodSignatureReturnType(final String signature, final boolean chopit) throws ClassFormatException {\n-        String type;\n+        String typeSignatureToString;\n         try {\n-            final int index = signature.lastIndexOf(41) + 1;\n-            if (index <= 0) {\n+            final int beginIndex = signature.lastIndexOf(41) + 1;\n+            if (beginIndex <= 0) {\n                 throw new ClassFormatException(\"Invalid method signature: \" + signature);\n             }\n-            type = typeSignatureToString(signature.substring(index), chopit);\n+            typeSignatureToString = typeSignatureToString(signature.substring(beginIndex), chopit);\n         }\n-        catch (final StringIndexOutOfBoundsException e) {\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)e);\n+        catch (final StringIndexOutOfBoundsException ex) {\n+            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)ex);\n         }\n-        return type;\n+        return typeSignatureToString;\n     }\n     \n     public static String methodSignatureToString(final String signature, final String name, final String access) {\n         return methodSignatureToString(signature, name, access, true);\n     }\n     \n     public static String methodSignatureToString(final String signature, final String name, final String access, final boolean chopit) {\n         return methodSignatureToString(signature, name, access, chopit, null);\n     }\n     \n     public static String methodSignatureToString(final String signature, final String name, final String access, final boolean chopit, final LocalVariableTable vars) throws ClassFormatException {\n-        final StringBuilder buf = new StringBuilder(\"(\");\n-        int varIndex = access.contains(\"static\") ? 0 : 1;\n-        String type;\n+        final StringBuilder sb = new StringBuilder(\"(\");\n+        int i = access.contains(\"static\") ? 0 : 1;\n+        String typeSignatureToString2;\n         try {\n-            int index = signature.indexOf(40) + 1;\n-            if (index <= 0) {\n+            int beginIndex = signature.indexOf(40) + 1;\n+            if (beginIndex <= 0) {\n                 throw new ClassFormatException(\"Invalid method signature: \" + signature);\n             }\n-            while (signature.charAt(index) != ')') {\n-                final String paramType = typeSignatureToString(signature.substring(index), chopit);\n-                buf.append(paramType);\n+            while (signature.charAt(beginIndex) != ')') {\n+                final String typeSignatureToString = typeSignatureToString(signature.substring(beginIndex), chopit);\n+                sb.append(typeSignatureToString);\n                 if (vars != null) {\n-                    final LocalVariable l = vars.getLocalVariable(varIndex, 0);\n-                    if (l != null) {\n-                        buf.append(\" \").append(l.getName());\n+                    final LocalVariable localVariable = vars.getLocalVariable(i, 0);\n+                    if (localVariable != null) {\n+                        sb.append(\" \").append(localVariable.getName());\n                     }\n                 }\n                 else {\n-                    buf.append(\" arg\").append(varIndex);\n+                    sb.append(\" arg\").append(i);\n                 }\n-                if (\"double\".equals(paramType) || \"long\".equals(paramType)) {\n-                    varIndex += 2;\n+                if (\"double\".equals(typeSignatureToString) || \"long\".equals(typeSignatureToString)) {\n+                    i += 2;\n                 }\n                 else {\n-                    ++varIndex;\n+                    ++i;\n                 }\n-                buf.append(\", \");\n-                index += unwrap(Utility.CONSUMER_CHARS);\n+                sb.append(\", \");\n+                beginIndex += unwrap(Utility.CONSUMER_CHARS);\n             }\n-            ++index;\n-            type = typeSignatureToString(signature.substring(index), chopit);\n+            ++beginIndex;\n+            typeSignatureToString2 = typeSignatureToString(signature.substring(beginIndex), chopit);\n         }\n-        catch (final StringIndexOutOfBoundsException e) {\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)e);\n+        catch (final StringIndexOutOfBoundsException ex) {\n+            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)ex);\n         }\n-        if (buf.length() > 1) {\n-            buf.setLength();\n+        if (sb.length() > 1) {\n+            sb.setLength();\n         }\n-        buf.append(\")\");\n-        return access + (access.isEmpty() ? \"\" : \" \") + type + \" \" + name + buf.toString();\n+        sb.append(\")\");\n+        return access + (access.isEmpty() ? \"\" : \" \") + typeSignatureToString2 + \" \" + name + sb.toString();\n     }\n     \n     public static String methodTypeToSignature(final String ret, final String[] argv) throws ClassFormatException {\n-        final StringBuilder buf = new StringBuilder(\"(\");\n+        final StringBuilder sb = new StringBuilder(\"(\");\n         if (argv != null) {\n-            for (final String element : argv) {\n-                final String str = getSignature(element);\n-                if (str.endsWith(\"V\")) {\n-                    throw new ClassFormatException(\"Invalid type: \" + element);\n+            for (final String s : argv) {\n+                final String signature = getSignature(s);\n+                if (signature.endsWith(\"V\")) {\n+                    throw new ClassFormatException(\"Invalid type: \" + s);\n                 }\n-                buf.append(str);\n+                sb.append(signature);\n             }\n         }\n-        final String str = getSignature(ret);\n-        buf.append(\")\").append(str);\n-        return buf.toString();\n+        sb.append(\")\").append(getSignature(ret));\n+        return sb.toString();\n     }\n     \n     public static String packageToPath(final String name) {\n         return name.replace('.', '/');\n     }\n     \n     public static String pathToPackage(final String str) {\n@@ -647,143 +639,141 @@\n         return printArray(obj, braces, false);\n     }\n     \n     public static String printArray(final Object[] obj, final boolean braces, final boolean quote) {\n         if (obj == null) {\n             return null;\n         }\n-        final StringBuilder buf = new StringBuilder();\n+        final StringBuilder sb = new StringBuilder();\n         if (braces) {\n-            buf.append('{');\n+            sb.append('{');\n         }\n         for (int i = 0; i < obj.length; ++i) {\n             if (obj[i] != null) {\n-                buf.append(quote ? \"\\\"\" : \"\").append(obj[i]).append(quote ? \"\\\"\" : \"\");\n+                sb.append(quote ? \"\\\"\" : \"\").append(obj[i]).append(quote ? \"\\\"\" : \"\");\n             }\n             else {\n-                buf.append(\"null\");\n+                sb.append(\"null\");\n             }\n             if (i < obj.length - 1) {\n-                buf.append(\", \");\n+                sb.append(\", \");\n             }\n         }\n         if (braces) {\n-            buf.append('}');\n+            sb.append('}');\n         }\n-        return buf.toString();\n+        return sb.toString();\n     }\n     \n     public static void printArray(final PrintStream out, final Object[] obj) {\n         out.println(printArray(obj, true));\n     }\n     \n     public static void printArray(final PrintWriter out, final Object[] obj) {\n         out.println(printArray(obj, true));\n     }\n     \n     public static String replace(String str, final String old, final String new_) {\n         try {\n             if (str.contains(old)) {\n-                final StringBuilder buf = new StringBuilder();\n-                int oldIndex;\n+                final StringBuilder sb = new StringBuilder();\n+                int beginIndex;\n                 int index;\n-                for (oldIndex = 0; (index = str.indexOf(old, oldIndex)) != -1; oldIndex = index + old.length()) {\n-                    buf.append(str, oldIndex, index);\n-                    buf.append(new_);\n+                for (beginIndex = 0; (index = str.indexOf(old, beginIndex)) != -1; beginIndex = index + old.length()) {\n+                    sb.append(str, beginIndex, index);\n+                    sb.append(new_);\n                 }\n-                buf.append(str.substring(oldIndex));\n-                str = buf.toString();\n+                sb.append(str.substring(beginIndex));\n+                str = sb.toString();\n             }\n         }\n-        catch (final StringIndexOutOfBoundsException e) {\n-            System.err.println(e);\n+        catch (final StringIndexOutOfBoundsException x) {\n+            System.err.println(x);\n         }\n         return str;\n     }\n     \n     public static short searchOpcode(String name) {\n         name = name.toLowerCase(Locale.ENGLISH);\n-        for (short i = 0; i < Const.OPCODE_NAMES_LENGTH; ++i) {\n-            if (Const.getOpcodeName((int)i).equals(name)) {\n-                return i;\n+        for (short n = 0; n < Const.OPCODE_NAMES_LENGTH; ++n) {\n+            if (Const.getOpcodeName((int)n).equals(name)) {\n+                return n;\n             }\n         }\n         return -1;\n     }\n     \n     public static int setBit(final int flag, final int i) {\n         return flag | pow2(i);\n     }\n     \n     public static String signatureToString(final String signature) {\n         return signatureToString(signature, true);\n     }\n     \n     public static String signatureToString(final String signature, final boolean chopit) {\n-        String type = \"\";\n-        String typeParams = \"\";\n-        int index = 0;\n+        String typeParamTypesToString = \"\";\n+        int beginIndex = 0;\n         if (signature.charAt(0) == '<') {\n-            typeParams = typeParamTypesToString(signature, chopit);\n-            index += unwrap(Utility.CONSUMER_CHARS);\n+            typeParamTypesToString = typeParamTypesToString(signature, chopit);\n+            beginIndex += unwrap(Utility.CONSUMER_CHARS);\n         }\n-        if (signature.charAt(index) == '(') {\n-            type = typeParams + typeSignaturesToString(signature.substring(index), chopit, ')');\n-            index += unwrap(Utility.CONSUMER_CHARS);\n-            type += typeSignatureToString(signature.substring(index), chopit);\n-            index += unwrap(Utility.CONSUMER_CHARS);\n-            return type;\n-        }\n-        type = typeSignatureToString(signature.substring(index), chopit);\n-        index += unwrap(Utility.CONSUMER_CHARS);\n-        if (typeParams.isEmpty() && index == signature.length()) {\n-            return type;\n-        }\n-        final StringBuilder typeClass = new StringBuilder(typeParams);\n-        typeClass.append(\" extends \");\n-        typeClass.append(type);\n-        if (index < signature.length()) {\n-            typeClass.append(\" implements \");\n-            typeClass.append(typeSignatureToString(signature.substring(index), chopit));\n-            index += unwrap(Utility.CONSUMER_CHARS);\n+        if (signature.charAt(beginIndex) == '(') {\n+            final String string = typeParamTypesToString + typeSignaturesToString(signature.substring(beginIndex), chopit, ')');\n+            final int beginIndex2 = beginIndex + unwrap(Utility.CONSUMER_CHARS);\n+            final String string2 = string + typeSignatureToString(signature.substring(beginIndex2), chopit);\n+            final int n = beginIndex2 + unwrap(Utility.CONSUMER_CHARS);\n+            return string2;\n+        }\n+        final String typeSignatureToString = typeSignatureToString(signature.substring(beginIndex), chopit);\n+        int i = beginIndex + unwrap(Utility.CONSUMER_CHARS);\n+        if (typeParamTypesToString.isEmpty() && i == signature.length()) {\n+            return typeSignatureToString;\n+        }\n+        final StringBuilder sb = new StringBuilder(typeParamTypesToString);\n+        sb.append(\" extends \");\n+        sb.append(typeSignatureToString);\n+        if (i < signature.length()) {\n+            sb.append(\" implements \");\n+            sb.append(typeSignatureToString(signature.substring(i), chopit));\n+            i += unwrap(Utility.CONSUMER_CHARS);\n+        }\n+        while (i < signature.length()) {\n+            sb.append(\", \");\n+            sb.append(typeSignatureToString(signature.substring(i), chopit));\n+            i += unwrap(Utility.CONSUMER_CHARS);\n         }\n-        while (index < signature.length()) {\n-            typeClass.append(\", \");\n-            typeClass.append(typeSignatureToString(signature.substring(index), chopit));\n-            index += unwrap(Utility.CONSUMER_CHARS);\n-        }\n-        return typeClass.toString();\n+        return sb.toString();\n     }\n     \n     public static String toHexString(final byte[] bytes) {\n-        final StringBuilder buf = new StringBuilder();\n+        final StringBuilder sb = new StringBuilder();\n         for (int i = 0; i < bytes.length; ++i) {\n-            final short b = byteToShort(bytes[i]);\n-            final String hex = Integer.toHexString(b);\n-            if (b < 16) {\n-                buf.append('0');\n+            final short byteToShort = byteToShort(bytes[i]);\n+            final String hexString = Integer.toHexString(byteToShort);\n+            if (byteToShort < 16) {\n+                sb.append('0');\n             }\n-            buf.append(hex);\n+            sb.append(hexString);\n             if (i < bytes.length - 1) {\n-                buf.append(' ');\n+                sb.append(' ');\n             }\n         }\n-        return buf.toString();\n+        return sb.toString();\n     }\n     \n     public static byte typeOfMethodSignature(final String signature) throws ClassFormatException {\n         try {\n             if (signature.charAt(0) != '(') {\n                 throw new ClassFormatException(\"Invalid method signature: \" + signature);\n             }\n-            final int index = signature.lastIndexOf(41) + 1;\n-            return typeOfSignature(signature.substring(index));\n+            return typeOfSignature(signature.substring(signature.lastIndexOf(41) + 1));\n         }\n-        catch (final StringIndexOutOfBoundsException e) {\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)e);\n+        catch (final StringIndexOutOfBoundsException ex) {\n+            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)ex);\n         }\n     }\n     \n     public static byte typeOfSignature(final String signature) throws ClassFormatException {\n         try {\n             switch (signature.charAt(0)) {\n                 case 'B': {\n@@ -826,67 +816,68 @@\n                     return typeOfSignature(signature.substring(1));\n                 }\n                 default: {\n                     throw new ClassFormatException(\"Invalid method signature: \" + signature);\n                 }\n             }\n         }\n-        catch (final StringIndexOutOfBoundsException e) {\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)e);\n+        catch (final StringIndexOutOfBoundsException ex) {\n+            throw new ClassFormatException(\"Invalid method signature: \" + signature, (Throwable)ex);\n         }\n     }\n     \n     private static String typeParamTypesToString(final String signature, final boolean chopit) {\n-        final StringBuilder typeParams = new StringBuilder(\"<\");\n-        int index = 1;\n-        typeParams.append(typeParamTypeToString(signature.substring(index), chopit));\n-        for (index += unwrap(Utility.CONSUMER_CHARS); signature.charAt(index) != '>'; index += unwrap(Utility.CONSUMER_CHARS)) {\n-            typeParams.append(\", \");\n-            typeParams.append(typeParamTypeToString(signature.substring(index), chopit));\n+        final StringBuilder sb = new StringBuilder(\"<\");\n+        final int beginIndex = 1;\n+        sb.append(typeParamTypeToString(signature.substring(beginIndex), chopit));\n+        int n;\n+        for (n = beginIndex + unwrap(Utility.CONSUMER_CHARS); signature.charAt(n) != '>'; n += unwrap(Utility.CONSUMER_CHARS)) {\n+            sb.append(\", \");\n+            sb.append(typeParamTypeToString(signature.substring(n), chopit));\n         }\n-        wrap(Utility.CONSUMER_CHARS, index + 1);\n-        return typeParams.append(\">\").toString();\n+        wrap(Utility.CONSUMER_CHARS, n + 1);\n+        return sb.append(\">\").toString();\n     }\n     \n     private static String typeParamTypeToString(final String signature, final boolean chopit) {\n         int index = signature.indexOf(58);\n         if (index <= 0) {\n             throw new ClassFormatException(\"Invalid type parameter signature: \" + signature);\n         }\n-        final StringBuilder typeParam = new StringBuilder(signature.substring(0, index));\n+        final StringBuilder sb = new StringBuilder(signature.substring(0, index));\n         ++index;\n         if (signature.charAt(index) != ':') {\n-            typeParam.append(\" extends \");\n-            typeParam.append(typeSignatureToString(signature.substring(index), chopit));\n+            sb.append(\" extends \");\n+            sb.append(typeSignatureToString(signature.substring(index), chopit));\n             index += unwrap(Utility.CONSUMER_CHARS);\n         }\n         while (signature.charAt(index) == ':') {\n             ++index;\n-            typeParam.append(\" & \");\n-            typeParam.append(typeSignatureToString(signature.substring(index), chopit));\n+            sb.append(\" & \");\n+            sb.append(typeSignatureToString(signature.substring(index), chopit));\n             index += unwrap(Utility.CONSUMER_CHARS);\n         }\n         wrap(Utility.CONSUMER_CHARS, index);\n-        return typeParam.toString();\n+        return sb.toString();\n     }\n     \n     private static String typeSignaturesToString(final String signature, final boolean chopit, final char term) {\n-        final StringBuilder typeList = new StringBuilder(signature.substring(0, 1));\n-        int index = 1;\n-        if (signature.charAt(index) != term) {\n-            typeList.append(typeSignatureToString(signature.substring(index), chopit));\n-            index += unwrap(Utility.CONSUMER_CHARS);\n+        final StringBuilder sb = new StringBuilder(signature.substring(0, 1));\n+        int n = 1;\n+        if (signature.charAt(n) != term) {\n+            sb.append(typeSignatureToString(signature.substring(n), chopit));\n+            n += unwrap(Utility.CONSUMER_CHARS);\n+        }\n+        while (signature.charAt(n) != term) {\n+            sb.append(\", \");\n+            sb.append(typeSignatureToString(signature.substring(n), chopit));\n+            n += unwrap(Utility.CONSUMER_CHARS);\n         }\n-        while (signature.charAt(index) != term) {\n-            typeList.append(\", \");\n-            typeList.append(typeSignatureToString(signature.substring(index), chopit));\n-            index += unwrap(Utility.CONSUMER_CHARS);\n-        }\n-        wrap(Utility.CONSUMER_CHARS, index + 1);\n-        return typeList.append(term).toString();\n+        wrap(Utility.CONSUMER_CHARS, n + 1);\n+        return sb.append(term).toString();\n     }\n     \n     public static String typeSignatureToString(final String signature, final boolean chopit) throws ClassFormatException {\n         wrap(Utility.CONSUMER_CHARS, 1);\n         try {\n             switch (signature.charAt(0)) {\n                 case 'B': {\n@@ -912,123 +903,122 @@\n                     if (index < 0) {\n                         throw new ClassFormatException(\"Invalid type variable signature: \" + signature);\n                     }\n                     wrap(Utility.CONSUMER_CHARS, index + 1);\n                     return compactClassName(signature.substring(1, index), chopit);\n                 }\n                 case 'L': {\n-                    int fromIndex = signature.indexOf(60);\n-                    if (fromIndex < 0) {\n-                        fromIndex = 0;\n+                    final int index2 = signature.indexOf(60);\n+                    int index3;\n+                    if (index2 < 0) {\n+                        index3 = 0;\n                     }\n                     else {\n-                        fromIndex = signature.indexOf(62, fromIndex);\n-                        if (fromIndex < 0) {\n+                        index3 = signature.indexOf(62, index2);\n+                        if (index3 < 0) {\n                             throw new ClassFormatException(\"Invalid signature: \" + signature);\n                         }\n                     }\n-                    final int index2 = signature.indexOf(59, fromIndex);\n-                    if (index2 < 0) {\n+                    final int index4 = signature.indexOf(59, index3);\n+                    if (index4 < 0) {\n                         throw new ClassFormatException(\"Invalid signature: \" + signature);\n                     }\n-                    final int bracketIndex = signature.substring(0, index2).indexOf(60);\n-                    if (bracketIndex < 0) {\n-                        wrap(Utility.CONSUMER_CHARS, index2 + 1);\n-                        return compactClassName(signature.substring(1, index2), chopit);\n+                    final int index5 = signature.substring(0, index4).indexOf(60);\n+                    if (index5 < 0) {\n+                        wrap(Utility.CONSUMER_CHARS, index4 + 1);\n+                        return compactClassName(signature.substring(1, index4), chopit);\n                     }\n-                    fromIndex = signature.indexOf(59);\n-                    if (fromIndex < 0) {\n+                    final int index6 = signature.indexOf(59);\n+                    if (index6 < 0) {\n                         throw new ClassFormatException(\"Invalid signature: \" + signature);\n                     }\n-                    if (fromIndex < bracketIndex) {\n-                        wrap(Utility.CONSUMER_CHARS, fromIndex + 1);\n-                        return compactClassName(signature.substring(1, fromIndex), chopit);\n-                    }\n-                    final StringBuilder type = new StringBuilder(compactClassName(signature.substring(1, bracketIndex), chopit)).append(\"<\");\n-                    int consumedChars = bracketIndex + 1;\n-                    if (signature.charAt(consumedChars) == '+') {\n-                        type.append(\"? extends \");\n-                        ++consumedChars;\n-                    }\n-                    else if (signature.charAt(consumedChars) == '-') {\n-                        type.append(\"? super \");\n-                        ++consumedChars;\n-                    }\n-                    if (signature.charAt(consumedChars) == '*') {\n-                        type.append(\"?\");\n-                        ++consumedChars;\n+                    if (index6 < index5) {\n+                        wrap(Utility.CONSUMER_CHARS, index6 + 1);\n+                        return compactClassName(signature.substring(1, index6), chopit);\n+                    }\n+                    final StringBuilder append = new StringBuilder(compactClassName(signature.substring(1, index5), chopit)).append(\"<\");\n+                    int index7 = index5 + 1;\n+                    if (signature.charAt(index7) == '+') {\n+                        append.append(\"? extends \");\n+                        ++index7;\n+                    }\n+                    else if (signature.charAt(index7) == '-') {\n+                        append.append(\"? super \");\n+                        ++index7;\n+                    }\n+                    if (signature.charAt(index7) == '*') {\n+                        append.append(\"?\");\n+                        ++index7;\n                     }\n                     else {\n-                        type.append(typeSignatureToString(signature.substring(consumedChars), chopit));\n-                        consumedChars += unwrap(Utility.CONSUMER_CHARS);\n-                        wrap(Utility.CONSUMER_CHARS, consumedChars);\n-                    }\n-                    while (signature.charAt(consumedChars) != '>') {\n-                        type.append(\", \");\n-                        if (signature.charAt(consumedChars) == '+') {\n-                            type.append(\"? extends \");\n-                            ++consumedChars;\n+                        append.append(typeSignatureToString(signature.substring(index7), chopit));\n+                        index7 += unwrap(Utility.CONSUMER_CHARS);\n+                        wrap(Utility.CONSUMER_CHARS, index7);\n+                    }\n+                    while (signature.charAt(index7) != '>') {\n+                        append.append(\", \");\n+                        if (signature.charAt(index7) == '+') {\n+                            append.append(\"? extends \");\n+                            ++index7;\n                         }\n-                        else if (signature.charAt(consumedChars) == '-') {\n-                            type.append(\"? super \");\n-                            ++consumedChars;\n+                        else if (signature.charAt(index7) == '-') {\n+                            append.append(\"? super \");\n+                            ++index7;\n                         }\n-                        if (signature.charAt(consumedChars) == '*') {\n-                            type.append(\"?\");\n-                            ++consumedChars;\n+                        if (signature.charAt(index7) == '*') {\n+                            append.append(\"?\");\n+                            ++index7;\n                         }\n                         else {\n-                            type.append(typeSignatureToString(signature.substring(consumedChars), chopit));\n-                            consumedChars += unwrap(Utility.CONSUMER_CHARS);\n-                            wrap(Utility.CONSUMER_CHARS, consumedChars);\n+                            append.append(typeSignatureToString(signature.substring(index7), chopit));\n+                            index7 += unwrap(Utility.CONSUMER_CHARS);\n+                            wrap(Utility.CONSUMER_CHARS, index7);\n                         }\n                     }\n-                    ++consumedChars;\n-                    type.append(\">\");\n-                    if (signature.charAt(consumedChars) == '.') {\n-                        type.append(\".\");\n-                        type.append(typeSignatureToString(\"L\" + signature.substring(consumedChars + 1), chopit));\n-                        consumedChars += unwrap(Utility.CONSUMER_CHARS);\n-                        wrap(Utility.CONSUMER_CHARS, consumedChars);\n-                        return type.toString();\n+                    ++index7;\n+                    append.append(\">\");\n+                    if (signature.charAt(index7) == '.') {\n+                        append.append(\".\");\n+                        append.append(typeSignatureToString(\"L\" + signature.substring(index7 + 1), chopit));\n+                        wrap(Utility.CONSUMER_CHARS, unwrap(Utility.CONSUMER_CHARS) + index7);\n+                        return append.toString();\n                     }\n-                    if (signature.charAt(consumedChars) != ';') {\n+                    if (signature.charAt(index7) != ';') {\n                         throw new ClassFormatException(\"Invalid signature: \" + signature);\n                     }\n-                    wrap(Utility.CONSUMER_CHARS, consumedChars + 1);\n-                    return type.toString();\n+                    wrap(Utility.CONSUMER_CHARS, index7 + 1);\n+                    return append.toString();\n                 }\n                 case 'S': {\n                     return \"short\";\n                 }\n                 case 'Z': {\n                     return \"boolean\";\n                 }\n                 case '[': {\n-                    final StringBuilder brackets = new StringBuilder();\n+                    final StringBuilder sb = new StringBuilder();\n                     int n;\n                     for (n = 0; signature.charAt(n) == '['; ++n) {\n-                        brackets.append(\"[]\");\n+                        sb.append(\"[]\");\n                     }\n-                    final int consumedChars2 = n;\n-                    final String type2 = typeSignatureToString(signature.substring(n), chopit);\n-                    final int temp = unwrap(Utility.CONSUMER_CHARS) + consumedChars2;\n-                    wrap(Utility.CONSUMER_CHARS, temp);\n-                    return type2 + brackets.toString();\n+                    final int n2 = n;\n+                    final String typeSignatureToString = typeSignatureToString(signature.substring(n), chopit);\n+                    wrap(Utility.CONSUMER_CHARS, unwrap(Utility.CONSUMER_CHARS) + n2);\n+                    return typeSignatureToString + sb.toString();\n                 }\n                 case 'V': {\n                     return \"void\";\n                 }\n                 default: {\n                     throw new ClassFormatException(\"Invalid signature: '\" + signature + \"'\");\n                 }\n             }\n         }\n-        catch (final StringIndexOutOfBoundsException e) {\n-            throw new ClassFormatException(\"Invalid signature: \" + signature, (Throwable)e);\n+        catch (final StringIndexOutOfBoundsException ex) {\n+            throw new ClassFormatException(\"Invalid signature: \" + signature, (Throwable)ex);\n         }\n     }\n     \n     private static int unwrap(final ThreadLocal<Integer> tl) {\n         return Integer.valueOf(tl.get());\n     }\n     \n@@ -1036,25 +1026,25 @@\n         tl.set(Integer.valueOf(value));\n     }\n     \n     static {\n         CONSUMER_CHARS = ThreadLocal.withInitial(() -> Integer.valueOf(0));\n         CHAR_MAP = new int[48];\n         MAP_CHAR = new int[256];\n-        int j = 0;\n+        int n = 0;\n         for (int i = 65; i <= 90; ++i) {\n-            Utility.CHAR_MAP[j] = i;\n-            Utility.MAP_CHAR[i] = j;\n-            ++j;\n-        }\n-        for (int i = 103; i <= 122; ++i) {\n-            Utility.CHAR_MAP[j] = i;\n-            Utility.MAP_CHAR[i] = j;\n-            ++j;\n-        }\n-        Utility.CHAR_MAP[j] = 36;\n-        Utility.MAP_CHAR[36] = j;\n-        ++j;\n-        Utility.CHAR_MAP[j] = 95;\n-        Utility.MAP_CHAR[95] = j;\n+            Utility.CHAR_MAP[n] = i;\n+            Utility.MAP_CHAR[i] = n;\n+            ++n;\n+        }\n+        for (int j = 103; j <= 122; ++j) {\n+            Utility.CHAR_MAP[n] = j;\n+            Utility.MAP_CHAR[j] = n;\n+            ++n;\n+        }\n+        Utility.CHAR_MAP[n] = 36;\n+        Utility.MAP_CHAR[36] = n;\n+        ++n;\n+        Utility.CHAR_MAP[n] = 95;\n+        Utility.MAP_CHAR[95] = n;\n     }\n }\n"}]}
