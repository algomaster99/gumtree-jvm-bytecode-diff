{"diffoscope-json-version": 1, "source1": "first/BinaryTree.class", "source2": "second/BinaryTree.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -8,101 +8,100 @@\n \n class BinaryTree\n {\n     private static final int UNDEFINED = -1;\n     private static final int NODE = -2;\n     private final int[] tree;\n     \n-    public BinaryTree(final int depth) {\n-        Arrays.fill(this.tree = new int[(1 << depth + 1) - 1], -1);\n+    public BinaryTree(final int n) {\n+        Arrays.fill(this.tree = new int[(1 << n + 1) - 1], -1);\n     }\n     \n-    public void addLeaf(final int node, final int path, final int depth, final int value) {\n-        if (depth == 0) {\n-            if (this.tree[node] != -1) {\n-                throw new IllegalArgumentException(\"Tree value at index \" + node + \" has already been assigned (\" + this.tree[node] + \")\");\n+    public void addLeaf(final int i, final int n, final int n2, final int n3) {\n+        if (n2 == 0) {\n+            if (this.tree[i] != -1) {\n+                throw new IllegalArgumentException(\"Tree value at index \" + i + \" has already been assigned (\" + this.tree[i] + \")\");\n             }\n-            this.tree[node] = value;\n+            this.tree[i] = n3;\n         }\n         else {\n-            this.tree[node] = -2;\n-            final int nextChild = 2 * node + 1 + (path & 0x1);\n-            this.addLeaf(nextChild, path >>> 1, depth - 1, value);\n+            this.tree[i] = -2;\n+            this.addLeaf(2 * i + 1 + (n & 0x1), n >>> 1, n2 - 1, n3);\n         }\n     }\n     \n-    public int read(final BitStream stream) throws IOException {\n-        int currentIndex = 0;\n+    public int read(final BitStream bitStream) throws IOException {\n+        int i = 0;\n         while (true) {\n-            final int bit = stream.nextBit();\n-            if (bit == -1) {\n+            final int nextBit = bitStream.nextBit();\n+            if (nextBit == -1) {\n                 return -1;\n             }\n-            final int childIndex = 2 * currentIndex + 1 + bit;\n-            final int value = this.tree[childIndex];\n-            if (value == -2) {\n-                currentIndex = childIndex;\n+            final int n = 2 * i + 1 + nextBit;\n+            final int n2 = this.tree[n];\n+            if (n2 == -2) {\n+                i = n;\n             }\n             else {\n-                if (value != -1) {\n-                    return value;\n+                if (n2 != -1) {\n+                    return n2;\n                 }\n-                throw new IOException(\"The child \" + bit + \" of node at index \" + currentIndex + \" is not defined\");\n+                throw new IOException(\"The child \" + nextBit + \" of node at index \" + i + \" is not defined\");\n             }\n         }\n     }\n     \n-    static BinaryTree decode(final InputStream in, final int totalNumberOfValues) throws IOException {\n-        final int size = in.read() + 1;\n-        if (size == 0) {\n+    static BinaryTree decode(final InputStream in, final int n) throws IOException {\n+        final int n2 = in.read() + 1;\n+        if (n2 == 0) {\n             throw new IOException(\"Cannot read the size of the encoded tree, unexpected end of stream\");\n         }\n-        final byte[] encodedTree = new byte[size];\n-        new DataInputStream(in).readFully(encodedTree);\n-        int maxLength = 0;\n-        final int[] originalBitLengths = new int[totalNumberOfValues];\n-        int pos = 0;\n-        for (final byte b : encodedTree) {\n-            final int numberOfValues = ((b & 0xF0) >> 4) + 1;\n-            final int bitLength = (b & 0xF) + 1;\n-            for (int j = 0; j < numberOfValues; ++j) {\n-                originalBitLengths[pos++] = bitLength;\n-            }\n-            maxLength = Math.max(maxLength, bitLength);\n-        }\n-        final int[] permutation = new int[originalBitLengths.length];\n-        for (int k = 0; k < permutation.length; ++k) {\n-            permutation[k] = k;\n-        }\n-        int c = 0;\n-        final int[] sortedBitLengths = new int[originalBitLengths.length];\n-        for (int i = 0; i < originalBitLengths.length; ++i) {\n-            for (int l = 0; l < originalBitLengths.length; ++l) {\n-                if (originalBitLengths[l] == i) {\n-                    sortedBitLengths[c] = i;\n-                    permutation[c] = l;\n-                    ++c;\n+        final byte[] b = new byte[n2];\n+        new DataInputStream(in).readFully(b);\n+        int max = 0;\n+        final int[] array = new int[n];\n+        int n3 = 0;\n+        for (final byte b2 : b) {\n+            final int n4 = ((b2 & 0xF0) >> 4) + 1;\n+            final int b3 = (b2 & 0xF) + 1;\n+            for (int j = 0; j < n4; ++j) {\n+                array[n3++] = b3;\n+            }\n+            max = Math.max(max, b3);\n+        }\n+        final int[] array3 = new int[array.length];\n+        for (int k = 0; k < array3.length; ++k) {\n+            array3[k] = k;\n+        }\n+        int n5 = 0;\n+        final int[] array4 = new int[array.length];\n+        for (int l = 0; l < array.length; ++l) {\n+            for (int n6 = 0; n6 < array.length; ++n6) {\n+                if (array[n6] == l) {\n+                    array4[n5] = l;\n+                    array3[n5] = n6;\n+                    ++n5;\n                 }\n             }\n         }\n-        int code = 0;\n-        int codeIncrement = 0;\n-        int lastBitLength = 0;\n-        final int[] codes = new int[totalNumberOfValues];\n-        for (int m = totalNumberOfValues - 1; m >= 0; --m) {\n-            code += codeIncrement;\n-            if (sortedBitLengths[m] != lastBitLength) {\n-                lastBitLength = sortedBitLengths[m];\n-                codeIncrement = 1 << 16 - lastBitLength;\n-            }\n-            codes[permutation[m]] = code;\n-        }\n-        final BinaryTree tree = new BinaryTree(maxLength);\n-        for (int k2 = 0; k2 < codes.length; ++k2) {\n-            final int bitLength2 = originalBitLengths[k2];\n-            if (bitLength2 > 0) {\n-                tree.addLeaf(0, Integer.reverse(codes[k2] << 16), bitLength2, k2);\n+        int n7 = 0;\n+        int n8 = 0;\n+        int n9 = 0;\n+        final int[] array5 = new int[n];\n+        for (int n10 = n - 1; n10 >= 0; --n10) {\n+            n7 += n8;\n+            if (array4[n10] != n9) {\n+                n9 = array4[n10];\n+                n8 = 1 << 16 - n9;\n+            }\n+            array5[array3[n10]] = n7;\n+        }\n+        final BinaryTree binaryTree = new BinaryTree(max);\n+        for (int n11 = 0; n11 < array5.length; ++n11) {\n+            final int n12 = array[n11];\n+            if (n12 > 0) {\n+                binaryTree.addLeaf(0, Integer.reverse(array5[n11] << 16), n12, n11);\n             }\n         }\n-        return tree;\n+        return binaryTree;\n     }\n }\n"}]}
