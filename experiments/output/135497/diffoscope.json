{"diffoscope-json-version": 1, "source1": "first/MethodGen.class", "source2": "second/MethodGen.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -44,14 +44,18 @@\n     private final List<String> throwsList;\n     private final List<Attribute> codeAttrsList;\n     private List<AnnotationEntryGen>[] paramAnnotations;\n     private boolean hasParameterAnnotations;\n     private boolean haveUnpackedParameterAnnotations;\n     private List<MethodObserver> observers;\n     \n+    static {\n+        MethodGen.bcelComparator = (BCELComparator)new MethodGen.MethodGen$1();\n+    }\n+    \n     private static byte[] getByteCodes(final Method method) {\n         final Code code = method.getCode();\n         if (code == null) {\n             throw new IllegalStateException(String.format(\"The method '%s' has no code.\", method));\n         }\n         return code.getCode();\n     }\n@@ -79,17 +83,18 @@\n             if (stackDepth > maxStackDepth) {\n                 maxStackDepth = stackDepth;\n             }\n             if (instruction instanceof BranchInstruction) {\n                 final BranchInstruction branch = (BranchInstruction)instruction;\n                 if (instruction instanceof Select) {\n                     final Select select = (Select)branch;\n-                    final InstructionHandle[] targets2;\n-                    final InstructionHandle[] targets = targets2 = select.getTargets();\n-                    for (final InstructionHandle target : targets2) {\n+                    final InstructionHandle[] targets = select.getTargets();\n+                    InstructionHandle[] array;\n+                    for (int length2 = (array = targets).length, j = 0; j < length2; ++j) {\n+                        final InstructionHandle target = array[j];\n                         branchTargets.push(target, stackDepth);\n                     }\n                     ih = null;\n                 }\n                 else if (!(branch instanceof IfInstruction)) {\n                     if (opcode == 168 || opcode == 201) {\n                         branchTargets.push(ih.getNext(), stackDepth - 1);\n@@ -168,25 +173,28 @@\n                 }\n             }\n         }\n     }\n     \n     public MethodGen(final Method method, final String className, final ConstantPoolGen cp) {\n         this(method.getAccessFlags(), Type.getReturnType(method.getSignature()), Type.getArgumentTypes(method.getSignature()), null, method.getName(), className, ((method.getAccessFlags() & 0x500) == 0x0) ? new InstructionList(getByteCodes(method)) : null, cp);\n-        final Attribute[] attributes2;\n-        final Attribute[] attributes = attributes2 = method.getAttributes();\n-        for (Attribute a : attributes2) {\n-            final Attribute attribute = a;\n+        final Attribute[] attributes = method.getAttributes();\n+        Attribute[] array;\n+        for (int length2 = (array = attributes).length, i = 0; i < length2; ++i) {\n+            Attribute a;\n+            final Attribute attribute = a = array[i];\n             if (a instanceof Code) {\n                 final Code c = (Code)a;\n                 this.setMaxStack(c.getMaxStack());\n                 this.setMaxLocals(c.getMaxLocals());\n                 final CodeException[] ces = c.getExceptionTable();\n                 if (ces != null) {\n-                    for (final CodeException ce : ces) {\n+                    CodeException[] array2;\n+                    for (int length3 = (array2 = ces).length, j = 0; j < length3; ++j) {\n+                        final CodeException ce = array2[j];\n                         final int type = ce.getCatchType();\n                         ObjectType cType = null;\n                         if (type > 0) {\n                             final String cen = method.getConstantPool().getConstantString(type, (byte)7);\n                             cType = ObjectType.getInstance(cen);\n                         }\n                         final int end_pc = ce.getEndPC();\n@@ -198,18 +206,18 @@\n                         else {\n                             end = this.il.findHandle(end_pc);\n                             end = end.getPrev();\n                         }\n                         this.addExceptionHandler(this.il.findHandle(ce.getStartPC()), end, this.il.findHandle(ce.getHandlerPC()), cType);\n                     }\n                 }\n-                final Attribute[] attributes3;\n-                final Attribute[] c_attributes = attributes3 = c.getAttributes();\n-                for (int length4 = attributes3.length, k = 0; k < length4; ++k) {\n-                    final Attribute c_attribute = a = attributes3[k];\n+                final Attribute[] c_attributes = c.getAttributes();\n+                Attribute[] array3;\n+                for (int length4 = (array3 = c_attributes).length, k = 0; k < length4; ++k) {\n+                    final Attribute c_attribute = a = array3[k];\n                     if (a instanceof LineNumberTable) {\n                         ((LineNumberTable)a).forEach(l -> {\n                             final InstructionHandle ih = this.il.findHandle(l.getStartPC());\n                             if (ih != null) {\n                                 this.addLineNumber(ih, l.getLineNumber());\n                             }\n                             return;\n@@ -227,15 +235,15 @@\n                 }\n             }\n             else if (a instanceof ExceptionTable) {\n                 Collections.addAll(this.throwsList, ((ExceptionTable)a).getExceptionNames());\n             }\n             else if (a instanceof Annotations) {\n                 final Annotations runtimeAnnotations = (Annotations)a;\n-                runtimeAnnotations.forEach(element -> this.addAnnotationEntry(new AnnotationEntryGen(element, cp, false)));\n+                runtimeAnnotations.forEach(element -> this.addAnnotationEntry(new AnnotationEntryGen(element, constantPoolGen, false)));\n             }\n             else {\n                 this.addAttribute(a);\n             }\n         }\n     }\n     \n@@ -300,15 +308,15 @@\n         }\n         this.observers.add(o);\n     }\n     \n     public void addParameterAnnotation(final int parameterIndex, final AnnotationEntryGen annotation) {\n         this.ensureExistingParameterAnnotationsUnpacked();\n         if (!this.hasParameterAnnotations) {\n-            final List<AnnotationEntryGen>[] parmList = new List[this.argTypes.length];\n+            final List[] parmList = new List[this.argTypes.length];\n             this.paramAnnotations = parmList;\n             this.hasParameterAnnotations = true;\n         }\n         final List<AnnotationEntryGen> existingAnnotations = this.paramAnnotations[parameterIndex];\n         if (existingAnnotations != null) {\n             existingAnnotations.add(annotation);\n         }\n@@ -342,16 +350,20 @@\n         final Attribute[] attrs = AnnotationEntryGen.getParameterAnnotationAttributes(cp, (List[])this.paramAnnotations);\n         this.addAll(attrs);\n         return attrs;\n     }\n     \n     private void adjustLocalVariableTypeTable(final LocalVariableTable lvt) {\n         final LocalVariable[] lv = lvt.getLocalVariableTable();\n-        for (final LocalVariable element : this.localVariableTypeTable.getLocalVariableTypeTable()) {\n-            for (final LocalVariable l : lv) {\n+        LocalVariable[] localVariableTypeTable;\n+        for (int length = (localVariableTypeTable = this.localVariableTypeTable.getLocalVariableTypeTable()).length, i = 0; i < length; ++i) {\n+            final LocalVariable element = localVariableTypeTable[i];\n+            LocalVariable[] array;\n+            for (int length2 = (array = lv).length, j = 0; j < length2; ++j) {\n+                final LocalVariable l = array[j];\n                 if (element.getName().equals(l.getName()) && element.getIndex() == l.getOrigIndex()) {\n                     element.setLength(l.getLength());\n                     element.setStartPC(l.getStartPC());\n                     element.setIndex(l.getIndex());\n                     break;\n                 }\n             }\n@@ -371,18 +383,20 @@\n     private void ensureExistingParameterAnnotationsUnpacked() {\n         if (this.haveUnpackedParameterAnnotations) {\n             return;\n         }\n         final Attribute[] attrs = this.getAttributes();\n         ParameterAnnotations paramAnnVisAttr = null;\n         ParameterAnnotations paramAnnInvisAttr = null;\n-        for (final Attribute attribute : attrs) {\n+        Attribute[] array;\n+        for (int length = (array = attrs).length, i = 0; i < length; ++i) {\n+            final Attribute attribute = array[i];\n             if (attribute instanceof ParameterAnnotations) {\n                 if (!this.hasParameterAnnotations) {\n-                    final List<AnnotationEntryGen>[] parmList = new List[this.argTypes.length];\n+                    final List[] parmList = new List[this.argTypes.length];\n                     Arrays.setAll(this.paramAnnotations = parmList, i -> new ArrayList());\n                 }\n                 this.hasParameterAnnotations = true;\n                 final ParameterAnnotations rpa = (ParameterAnnotations)attribute;\n                 if (rpa instanceof RuntimeVisibleParameterAnnotations) {\n                     paramAnnVisAttr = rpa;\n                 }\n@@ -456,15 +470,15 @@\n     public String[] getExceptions() {\n         return this.throwsList.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n     }\n     \n     private ExceptionTable getExceptionTable(final ConstantPoolGen cp) {\n         final int size = this.throwsList.size();\n         final int[] ex = new int[size];\n-        Arrays.setAll(ex, i -> cp.addClass((String)this.throwsList.get(i)));\n+        Arrays.setAll(ex, i -> constantPoolGen.addClass((String)this.throwsList.get(i)));\n         return new ExceptionTable(cp.addUtf8(\"Exceptions\"), 2 + 2 * size, ex, cp.getConstantPool());\n     }\n     \n     public InstructionList getInstructionList() {\n         return this.il;\n     }\n     \n@@ -497,15 +511,15 @@\n         return lg;\n     }\n     \n     public LocalVariableTable getLocalVariableTable(final ConstantPoolGen cp) {\n         final LocalVariableGen[] lg = this.getLocalVariables();\n         final int size = lg.length;\n         final LocalVariable[] lv = new LocalVariable[size];\n-        Arrays.setAll(lv, i -> lg[i].getLocalVariable(cp));\n+        Arrays.setAll(lv, i -> array[i].getLocalVariable(constantPoolGen));\n         return new LocalVariableTable(cp.addUtf8(\"LocalVariableTable\"), 2 + lv.length * 10, lv, cp.getConstantPool());\n     }\n     \n     public LocalVariableTypeTable getLocalVariableTypeTable() {\n         return this.localVariableTypeTable;\n     }\n     \n@@ -536,24 +550,27 @@\n             this.addCodeAttribute((Attribute)this.localVariableTypeTable);\n         }\n         if (!this.lineNumberList.isEmpty() && !this.stripAttributes) {\n             this.addCodeAttribute((Attribute)(lnt = this.getLineNumberTable(cp)));\n         }\n         final Attribute[] codeAttrs = this.getCodeAttributes();\n         int attrs_len = 0;\n-        for (final Attribute code_attr : codeAttrs) {\n+        Attribute[] array;\n+        for (int length = (array = codeAttrs).length, i = 0; i < length; ++i) {\n+            final Attribute code_attr = array[i];\n             attrs_len += code_attr.getLength() + 6;\n         }\n         final CodeException[] cExc = this.getCodeExceptions();\n         final int exc_len = cExc.length * 8;\n         Code code = null;\n         if (byteCode != null && !this.isAbstract() && !this.isNative()) {\n-            final Attribute[] attributes2;\n-            final Attribute[] attributes = attributes2 = this.getAttributes();\n-            for (final Attribute a : attributes2) {\n+            final Attribute[] attributes = this.getAttributes();\n+            Attribute[] array2;\n+            for (int length2 = (array2 = attributes).length, j = 0; j < length2; ++j) {\n+                final Attribute a = array2[j];\n                 if (a instanceof Code) {\n                     this.removeAttribute(a);\n                 }\n             }\n             code = new Code(cp.addUtf8(\"Code\"), 8 + byteCode.length + 2 + exc_len + 2 + attrs_len, this.maxStack, this.maxLocals, byteCode, cExc, codeAttrs, cp.getConstantPool());\n             this.addAttribute((Attribute)code);\n         }\n@@ -657,16 +674,20 @@\n             for (InstructionHandle ih = this.il.getStart(); ih != null; ih = next) {\n                 next = ih.getNext();\n                 if (next != null && ih.getInstruction() instanceof NOP) {\n                     try {\n                         this.il.delete(ih);\n                     }\n                     catch (final TargetLostException e) {\n-                        for (final InstructionHandle target : e.getTargets()) {\n-                            for (final InstructionTargeter targeter : target.getTargeters()) {\n+                        InstructionHandle[] targets;\n+                        for (int length = (targets = e.getTargets()).length, i = 0; i < length; ++i) {\n+                            final InstructionHandle target = targets[i];\n+                            InstructionTargeter[] targeters;\n+                            for (int length2 = (targeters = target.getTargeters()).length, j = 0; j < length2; ++j) {\n+                                final InstructionTargeter targeter = targeters[j];\n                                 targeter.updateTarget(target, next);\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n@@ -708,15 +729,17 @@\n         this.il = il;\n     }\n     \n     public void setMaxLocals() {\n         if (this.il != null) {\n             int max = this.isStatic() ? 0 : 1;\n             if (this.argTypes != null) {\n-                for (final Type argType : this.argTypes) {\n+                Type[] argTypes;\n+                for (int length = (argTypes = this.argTypes).length, i = 0; i < length; ++i) {\n+                    final Type argType = argTypes[i];\n                     max += argType.getSize();\n                 }\n             }\n             for (InstructionHandle ih = this.il.getStart(); ih != null; ih = ih.getNext()) {\n                 final Instruction ins = ih.getInstruction();\n                 if (ins instanceof LocalVariableInstruction || ins instanceof RET || ins instanceof IINC) {\n                     final int index = ((IndexedInstruction)ins).getIndex() + ((TypedInstruction)ins).getType(super.getConstantPool()).getSize();\n@@ -758,15 +781,17 @@\n     }\n     \n     public final String toString() {\n         final String access = Utility.accessToString(super.getAccessFlags());\n         String signature = Type.getMethodSignature(super.getType(), this.argTypes);\n         signature = Utility.methodSignatureToString(signature, super.getName(), access, true, this.getLocalVariableTable(super.getConstantPool()));\n         final StringBuilder buf = new StringBuilder(signature);\n-        for (final Attribute a : this.getAttributes()) {\n+        Attribute[] attributes;\n+        for (int length = (attributes = this.getAttributes()).length, i = 0; i < length; ++i) {\n+            final Attribute a = attributes[i];\n             if (!(a instanceof Code) && !(a instanceof ExceptionTable)) {\n                 buf.append(\" [\").append(a).append(\"]\");\n             }\n         }\n         if (!this.throwsList.isEmpty()) {\n             for (final String throwsDescriptor : this.throwsList) {\n                 buf.append(\"\\n\\t\\tthrows \").append(throwsDescriptor);\n@@ -781,21 +806,19 @@\n                 observer.notify(this);\n             }\n         }\n     }\n     \n     private void updateLocalVariableTable(final LocalVariableTable a) {\n         this.removeLocalVariables();\n-        for (final LocalVariable l : a.getLocalVariableTable()) {\n+        LocalVariable[] localVariableTable;\n+        for (int length = (localVariableTable = a.getLocalVariableTable()).length, i = 0; i < length; ++i) {\n+            final LocalVariable l = localVariableTable[i];\n             InstructionHandle start = this.il.findHandle(l.getStartPC());\n             final InstructionHandle end = this.il.findHandle(l.getStartPC() + l.getLength());\n-            if (null == start) {\n+            if (start == null) {\n                 start = this.il.getStart();\n             }\n             this.addLocalVariable(l.getName(), Type.getType(l.getSignature()), l.getIndex(), start, end, l.getOrigIndex());\n         }\n     }\n-    \n-    static {\n-        MethodGen.bcelComparator = (BCELComparator)new MethodGen.MethodGen$1();\n-    }\n }\n"}]}
