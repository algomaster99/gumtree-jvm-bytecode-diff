{"diffoscope-json-version": 1, "source1": "first/MissingDeprecatedCheck.class", "source2": "second/MissingDeprecatedCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,28 +1,32 @@\n \n package com.puppycrawl.tools.checkstyle.checks.annotation;\n \n-import com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n import com.puppycrawl.tools.checkstyle.checks.javadoc.JavadocTagInfo;\n import com.puppycrawl.tools.checkstyle.api.DetailAST;\n import com.puppycrawl.tools.checkstyle.utils.AnnotationUtil;\n import com.puppycrawl.tools.checkstyle.api.DetailNode;\n+import com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n import java.util.BitSet;\n import com.puppycrawl.tools.checkstyle.StatelessCheck;\n import com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\n \n @StatelessCheck\n public final class MissingDeprecatedCheck extends AbstractJavadocCheck\n {\n     public static final String MSG_KEY_ANNOTATION_MISSING_DEPRECATED = \"annotation.missing.deprecated\";\n     public static final String MSG_KEY_JAVADOC_DUPLICATE_TAG = \"javadoc.duplicateTag\";\n     private static final String DEPRECATED = \"Deprecated\";\n     private static final String FQ_DEPRECATED = \"java.lang.Deprecated\";\n     private static final BitSet TYPES_HASH_SET;\n     \n+    static {\n+        TYPES_HASH_SET = TokenUtil.asBitSet(new int[] { 13, 5, 159, 158, 17, 165, 59 });\n+    }\n+    \n     public int[] getDefaultJavadocTokens() {\n         return this.getRequiredJavadocTokens();\n     }\n     \n     public int[] getRequiredJavadocTokens() {\n         return new int[] { 10000 };\n     }\n@@ -34,15 +38,17 @@\n         if (containsAnnotation ^ containsJavadocTag) {\n             this.log(parentAst.getLineNo(), \"annotation.missing.deprecated\", new Object[0]);\n         }\n     }\n     \n     private boolean containsDeprecatedTag(final DetailNode javadoc) {\n         boolean found = false;\n-        for (final DetailNode child : javadoc.getChildren()) {\n+        DetailNode[] children;\n+        for (int length = (children = javadoc.getChildren()).length, i = 0; i < length; ++i) {\n+            final DetailNode child = children[i];\n             if (child.getType() == 10071 && child.getChildren()[0].getType() == 8) {\n                 if (found) {\n                     this.log(child.getLineNumber(), \"javadoc.duplicateTag\", new Object[] { JavadocTagInfo.DEPRECATED.getText() });\n                 }\n                 found = true;\n             }\n         }\n@@ -64,12 +70,8 @@\n                     break;\n                 }\n                 result = result.getNextSibling();\n             }\n         }\n         return result;\n     }\n-    \n-    static {\n-        TYPES_HASH_SET = TokenUtil.asBitSet(new int[] { 13, 5, 159, 158, 17, 165, 59 });\n-    }\n }\n"}]}
