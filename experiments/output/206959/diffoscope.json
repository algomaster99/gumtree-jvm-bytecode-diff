{"diffoscope-json-version": 1, "source1": "first/CSVFormat.class", "source2": "second/CSVFormat.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,14 +1,13 @@\n \n package org.apache.commons.csv;\n \n import java.sql.ResultSetMetaData;\n import java.sql.SQLException;\n import java.sql.ResultSet;\n-import java.util.Set;\n import java.util.HashSet;\n import java.io.Writer;\n import java.nio.file.Files;\n import java.nio.file.OpenOption;\n import java.nio.file.Path;\n import java.io.OutputStream;\n import java.io.OutputStreamWriter;\n@@ -60,144 +59,144 @@\n         return c == '\\n' || c == '\\r';\n     }\n     \n     private static boolean isLineBreak(final Character c) {\n         return c != null && isLineBreak((char)c);\n     }\n     \n-    public static CSVFormat newFormat(final char delimiter) {\n-        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false, false, false, false, false, true);\n+    public static CSVFormat newFormat(final char c) {\n+        return new CSVFormat(c, null, null, null, null, false, false, null, null, null, null, false, false, false, false, false, false, true);\n     }\n     \n-    public static CSVFormat valueOf(final String format) {\n-        return CSVFormat.Predefined.valueOf(format).getFormat();\n+    public static CSVFormat valueOf(final String s) {\n+        return CSVFormat.Predefined.valueOf(s).getFormat();\n     }\n     \n-    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush, final boolean allowDuplicateHeaderNames) {\n+    private CSVFormat(final char delimiter, final Character quoteCharacter, final QuoteMode quoteMode, final Character commentMarker, final Character escapeCharacter, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String s, final Object[] array, final String[] array2, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush, final boolean allowDuplicateHeaderNames) {\n         this.delimiter = delimiter;\n-        this.quoteCharacter = quoteChar;\n+        this.quoteCharacter = quoteCharacter;\n         this.quoteMode = quoteMode;\n-        this.commentMarker = commentStart;\n-        this.escapeCharacter = escape;\n+        this.commentMarker = commentMarker;\n+        this.escapeCharacter = escapeCharacter;\n         this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n         this.allowMissingColumnNames = allowMissingColumnNames;\n         this.ignoreEmptyLines = ignoreEmptyLines;\n         this.recordSeparator = recordSeparator;\n-        this.nullString = nullString;\n-        this.headerComments = this.toStringArray(headerComments);\n-        this.header = (String[])((header == null) ? null : ((String[])header.clone()));\n+        this.nullString = s;\n+        this.headerComments = this.toStringArray(array);\n+        this.header = (String[])((array2 == null) ? null : ((String[])array2.clone()));\n         this.skipHeaderRecord = skipHeaderRecord;\n         this.ignoreHeaderCase = ignoreHeaderCase;\n         this.trailingDelimiter = trailingDelimiter;\n         this.trim = trim;\n         this.autoFlush = autoFlush;\n-        this.quotedNullString = this.quoteCharacter + nullString + this.quoteCharacter;\n+        this.quotedNullString = this.quoteCharacter + s + this.quoteCharacter;\n         this.allowDuplicateHeaderNames = allowDuplicateHeaderNames;\n         this.validate();\n     }\n     \n     @Override\n-    public boolean equals(final Object obj) {\n-        if (this == obj) {\n+    public boolean equals(final Object o) {\n+        if (this == o) {\n             return true;\n         }\n-        if (obj == null) {\n+        if (o == null) {\n             return false;\n         }\n-        if (this.getClass() != obj.getClass()) {\n+        if (this.getClass() != o.getClass()) {\n             return false;\n         }\n-        final CSVFormat other = (CSVFormat)obj;\n-        if (this.delimiter != other.delimiter) {\n+        final CSVFormat csvFormat = (CSVFormat)o;\n+        if (this.delimiter != csvFormat.delimiter) {\n             return false;\n         }\n-        if (this.trailingDelimiter != other.trailingDelimiter) {\n+        if (this.trailingDelimiter != csvFormat.trailingDelimiter) {\n             return false;\n         }\n-        if (this.autoFlush != other.autoFlush) {\n+        if (this.autoFlush != csvFormat.autoFlush) {\n             return false;\n         }\n-        if (this.trim != other.trim) {\n+        if (this.trim != csvFormat.trim) {\n             return false;\n         }\n-        if (this.allowMissingColumnNames != other.allowMissingColumnNames) {\n+        if (this.allowMissingColumnNames != csvFormat.allowMissingColumnNames) {\n             return false;\n         }\n-        if (this.allowDuplicateHeaderNames != other.allowDuplicateHeaderNames) {\n+        if (this.allowDuplicateHeaderNames != csvFormat.allowDuplicateHeaderNames) {\n             return false;\n         }\n-        if (this.ignoreHeaderCase != other.ignoreHeaderCase) {\n+        if (this.ignoreHeaderCase != csvFormat.ignoreHeaderCase) {\n             return false;\n         }\n-        if (this.quoteMode != other.quoteMode) {\n+        if (this.quoteMode != csvFormat.quoteMode) {\n             return false;\n         }\n         if (this.quoteCharacter == null) {\n-            if (other.quoteCharacter != null) {\n+            if (csvFormat.quoteCharacter != null) {\n                 return false;\n             }\n         }\n-        else if (!this.quoteCharacter.equals(other.quoteCharacter)) {\n+        else if (!this.quoteCharacter.equals(csvFormat.quoteCharacter)) {\n             return false;\n         }\n         if (this.commentMarker == null) {\n-            if (other.commentMarker != null) {\n+            if (csvFormat.commentMarker != null) {\n                 return false;\n             }\n         }\n-        else if (!this.commentMarker.equals(other.commentMarker)) {\n+        else if (!this.commentMarker.equals(csvFormat.commentMarker)) {\n             return false;\n         }\n         if (this.escapeCharacter == null) {\n-            if (other.escapeCharacter != null) {\n+            if (csvFormat.escapeCharacter != null) {\n                 return false;\n             }\n         }\n-        else if (!this.escapeCharacter.equals(other.escapeCharacter)) {\n+        else if (!this.escapeCharacter.equals(csvFormat.escapeCharacter)) {\n             return false;\n         }\n         if (this.nullString == null) {\n-            if (other.nullString != null) {\n+            if (csvFormat.nullString != null) {\n                 return false;\n             }\n         }\n-        else if (!this.nullString.equals(other.nullString)) {\n+        else if (!this.nullString.equals(csvFormat.nullString)) {\n             return false;\n         }\n-        if (!Arrays.equals(this.header, other.header)) {\n+        if (!Arrays.equals(this.header, csvFormat.header)) {\n             return false;\n         }\n-        if (this.ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n+        if (this.ignoreSurroundingSpaces != csvFormat.ignoreSurroundingSpaces) {\n             return false;\n         }\n-        if (this.ignoreEmptyLines != other.ignoreEmptyLines) {\n+        if (this.ignoreEmptyLines != csvFormat.ignoreEmptyLines) {\n             return false;\n         }\n-        if (this.skipHeaderRecord != other.skipHeaderRecord) {\n+        if (this.skipHeaderRecord != csvFormat.skipHeaderRecord) {\n             return false;\n         }\n         if (this.recordSeparator == null) {\n-            if (other.recordSeparator != null) {\n+            if (csvFormat.recordSeparator != null) {\n                 return false;\n             }\n         }\n-        else if (!this.recordSeparator.equals(other.recordSeparator)) {\n+        else if (!this.recordSeparator.equals(csvFormat.recordSeparator)) {\n             return false;\n         }\n-        return Arrays.equals(this.headerComments, other.headerComments);\n+        return Arrays.equals(this.headerComments, csvFormat.headerComments);\n     }\n     \n-    public String format(final Object... values) {\n-        final StringWriter out = new StringWriter();\n-        try (final CSVPrinter csvPrinter = new CSVPrinter((Appendable)out, this)) {\n-            csvPrinter.printRecord(values);\n-            return out.toString().trim();\n+    public String format(final Object... array) {\n+        final StringWriter stringWriter = new StringWriter();\n+        try (final CSVPrinter csvPrinter = new CSVPrinter((Appendable)stringWriter, this)) {\n+            csvPrinter.printRecord(array);\n+            return stringWriter.toString().trim();\n         }\n-        catch (final IOException e) {\n-            throw new IllegalStateException(e);\n+        catch (final IOException cause) {\n+            throw new IllegalStateException(cause);\n         }\n     }\n     \n     public boolean getAllowDuplicateHeaderNames() {\n         return this.allowDuplicateHeaderNames;\n     }\n     \n@@ -267,35 +266,15 @@\n     \n     public boolean getTrim() {\n         return this.trim;\n     }\n     \n     @Override\n     public int hashCode() {\n-        final int prime = 31;\n-        int result = 1;\n-        result = 31 * result + this.delimiter;\n-        result = 31 * result + ((this.quoteMode == null) ? 0 : this.quoteMode.hashCode());\n-        result = 31 * result + ((this.quoteCharacter == null) ? 0 : this.quoteCharacter.hashCode());\n-        result = 31 * result + ((this.commentMarker == null) ? 0 : this.commentMarker.hashCode());\n-        result = 31 * result + ((this.escapeCharacter == null) ? 0 : this.escapeCharacter.hashCode());\n-        result = 31 * result + ((this.nullString == null) ? 0 : this.nullString.hashCode());\n-        result = 31 * result + (this.ignoreSurroundingSpaces ? 1231 : 1237);\n-        result = 31 * result + (this.ignoreHeaderCase ? 1231 : 1237);\n-        result = 31 * result + (this.ignoreEmptyLines ? 1231 : 1237);\n-        result = 31 * result + (this.skipHeaderRecord ? 1231 : 1237);\n-        result = 31 * result + (this.allowDuplicateHeaderNames ? 1231 : 1237);\n-        result = 31 * result + (this.trim ? 1231 : 1237);\n-        result = 31 * result + (this.autoFlush ? 1231 : 1237);\n-        result = 31 * result + (this.trailingDelimiter ? 1231 : 1237);\n-        result = 31 * result + (this.allowMissingColumnNames ? 1231 : 1237);\n-        result = 31 * result + ((this.recordSeparator == null) ? 0 : this.recordSeparator.hashCode());\n-        result = 31 * result + Arrays.hashCode(this.header);\n-        result = 31 * result + Arrays.hashCode(this.headerComments);\n-        return result;\n+        return 31 * (31 * (31 * (31 * (31 * (31 * (31 * (31 * (31 * (31 * (31 * (31 * (31 * (31 * (31 * (31 * (31 * (31 * 1 + this.delimiter) + ((this.quoteMode == null) ? 0 : this.quoteMode.hashCode())) + ((this.quoteCharacter == null) ? 0 : this.quoteCharacter.hashCode())) + ((this.commentMarker == null) ? 0 : this.commentMarker.hashCode())) + ((this.escapeCharacter == null) ? 0 : this.escapeCharacter.hashCode())) + ((this.nullString == null) ? 0 : this.nullString.hashCode())) + (this.ignoreSurroundingSpaces ? 1231 : 1237)) + (this.ignoreHeaderCase ? 1231 : 1237)) + (this.ignoreEmptyLines ? 1231 : 1237)) + (this.skipHeaderRecord ? 1231 : 1237)) + (this.allowDuplicateHeaderNames ? 1231 : 1237)) + (this.trim ? 1231 : 1237)) + (this.autoFlush ? 1231 : 1237)) + (this.trailingDelimiter ? 1231 : 1237)) + (this.allowMissingColumnNames ? 1231 : 1237)) + ((this.recordSeparator == null) ? 0 : this.recordSeparator.hashCode())) + Arrays.hashCode(this.header)) + Arrays.hashCode(this.headerComments);\n     }\n     \n     public boolean isCommentMarkerSet() {\n         return this.commentMarker != null;\n     }\n     \n     public boolean isEscapeCharacterSet() {\n@@ -306,287 +285,280 @@\n         return this.nullString != null;\n     }\n     \n     public boolean isQuoteCharacterSet() {\n         return this.quoteCharacter != null;\n     }\n     \n-    public CSVParser parse(final Reader in) throws IOException {\n-        return new CSVParser(in, this);\n+    public CSVParser parse(final Reader reader) throws IOException {\n+        return new CSVParser(reader, this);\n     }\n     \n-    public CSVPrinter print(final Appendable out) throws IOException {\n-        return new CSVPrinter(out, this);\n+    public CSVPrinter print(final Appendable appendable) throws IOException {\n+        return new CSVPrinter(appendable, this);\n     }\n     \n-    public CSVPrinter print(final File out, final Charset charset) throws IOException {\n-        return new CSVPrinter((Appendable)new OutputStreamWriter(new FileOutputStream(out), charset), this);\n+    public CSVPrinter print(final File file, final Charset cs) throws IOException {\n+        return new CSVPrinter((Appendable)new OutputStreamWriter(new FileOutputStream(file), cs), this);\n     }\n     \n-    public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\n+    public void print(final Object o, final Appendable appendable, final boolean b) throws IOException {\n         CharSequence charSequence;\n-        if (value == null) {\n+        if (o == null) {\n             if (null == this.nullString) {\n                 charSequence = \"\";\n             }\n             else if (QuoteMode.ALL == this.quoteMode) {\n                 charSequence = this.quotedNullString;\n             }\n             else {\n                 charSequence = this.nullString;\n             }\n         }\n-        else if (value instanceof CharSequence) {\n-            charSequence = (CharSequence)value;\n+        else if (o instanceof CharSequence) {\n+            charSequence = (CharSequence)o;\n         }\n         else {\n-            if (value instanceof Reader) {\n-                this.print((Reader)value, out, newRecord);\n+            if (o instanceof Reader) {\n+                this.print((Reader)o, appendable, b);\n                 return;\n             }\n-            charSequence = value.toString();\n+            charSequence = o.toString();\n         }\n-        charSequence = (this.getTrim() ? this.trim(charSequence) : charSequence);\n-        this.print(value, charSequence, out, newRecord);\n+        this.print(o, this.getTrim() ? this.trim(charSequence) : charSequence, appendable, b);\n     }\n     \n-    private void print(final Object object, final CharSequence value, final Appendable out, final boolean newRecord) throws IOException {\n-        final int offset = 0;\n-        final int len = value.length();\n-        if (!newRecord) {\n-            out.append(this.getDelimiter());\n+    private void print(final Object o, final CharSequence charSequence, final Appendable appendable, final boolean b) throws IOException {\n+        final int length = charSequence.length();\n+        if (!b) {\n+            appendable.append(this.getDelimiter());\n         }\n-        if (object == null) {\n-            out.append(value);\n+        if (o == null) {\n+            appendable.append(charSequence);\n         }\n         else if (this.isQuoteCharacterSet()) {\n-            this.printWithQuotes(object, value, out, newRecord);\n+            this.printWithQuotes(o, charSequence, appendable, b);\n         }\n         else if (this.isEscapeCharacterSet()) {\n-            this.printWithEscapes(value, out);\n+            this.printWithEscapes(charSequence, appendable);\n         }\n         else {\n-            out.append(value, 0, len);\n+            appendable.append(charSequence, 0, length);\n         }\n     }\n     \n-    public CSVPrinter print(final Path out, final Charset charset) throws IOException {\n-        return this.print(Files.newBufferedWriter(out, charset, new OpenOption[0]));\n+    public CSVPrinter print(final Path path, final Charset cs) throws IOException {\n+        return this.print(Files.newBufferedWriter(path, cs, new OpenOption[0]));\n     }\n     \n-    private void print(final Reader reader, final Appendable out, final boolean newRecord) throws IOException {\n-        if (!newRecord) {\n-            out.append(this.getDelimiter());\n+    private void print(final Reader reader, final Appendable appendable, final boolean b) throws IOException {\n+        if (!b) {\n+            appendable.append(this.getDelimiter());\n         }\n         if (this.isQuoteCharacterSet()) {\n-            this.printWithQuotes(reader, out);\n+            this.printWithQuotes(reader, appendable);\n         }\n         else if (this.isEscapeCharacterSet()) {\n-            this.printWithEscapes(reader, out);\n+            this.printWithEscapes(reader, appendable);\n         }\n-        else if (out instanceof Writer) {\n-            IOUtils.copyLarge(reader, (Writer)out);\n+        else if (appendable instanceof Writer) {\n+            IOUtils.copyLarge(reader, (Writer)appendable);\n         }\n         else {\n-            IOUtils.copy(reader, out);\n+            IOUtils.copy(reader, appendable);\n         }\n     }\n     \n     public CSVPrinter printer() throws IOException {\n         return new CSVPrinter((Appendable)System.out, this);\n     }\n     \n-    public void println(final Appendable out) throws IOException {\n+    public void println(final Appendable appendable) throws IOException {\n         if (this.getTrailingDelimiter()) {\n-            out.append(this.getDelimiter());\n+            appendable.append(this.getDelimiter());\n         }\n         if (this.recordSeparator != null) {\n-            out.append(this.recordSeparator);\n+            appendable.append(this.recordSeparator);\n         }\n     }\n     \n-    public void printRecord(final Appendable out, final Object... values) throws IOException {\n-        for (int i = 0; i < values.length; ++i) {\n-            this.print(values[i], out, i == 0);\n+    public void printRecord(final Appendable appendable, final Object... array) throws IOException {\n+        for (int i = 0; i < array.length; ++i) {\n+            this.print(array[i], appendable, i == 0);\n         }\n-        this.println(out);\n+        this.println(appendable);\n     }\n     \n-    private void printWithEscapes(final CharSequence value, final Appendable out) throws IOException {\n-        int start = 0;\n-        int pos = 0;\n-        final int end;\n-        final int len = end = value.length();\n-        final char delim = this.getDelimiter();\n-        final char escape = (char)this.getEscapeCharacter();\n-        while (pos < end) {\n-            char c = value.charAt(pos);\n-            if (c == '\\r' || c == '\\n' || c == delim || c == escape) {\n-                if (pos > start) {\n-                    out.append(value, start, pos);\n+    private void printWithEscapes(final CharSequence charSequence, final Appendable appendable) throws IOException {\n+        int n = 0;\n+        int i = 0;\n+        final int length = charSequence.length();\n+        final char delimiter = this.getDelimiter();\n+        final char charValue = (char)this.getEscapeCharacter();\n+        while (i < length) {\n+            char char1 = charSequence.charAt(i);\n+            if (char1 == '\\r' || char1 == '\\n' || char1 == delimiter || char1 == charValue) {\n+                if (i > n) {\n+                    appendable.append(charSequence, n, i);\n                 }\n-                if (c == '\\n') {\n-                    c = 'n';\n+                if (char1 == '\\n') {\n+                    char1 = 'n';\n                 }\n-                else if (c == '\\r') {\n-                    c = 'r';\n+                else if (char1 == '\\r') {\n+                    char1 = 'r';\n                 }\n-                out.append(escape);\n-                out.append(c);\n-                start = pos + 1;\n+                appendable.append(charValue);\n+                appendable.append(char1);\n+                n = i + 1;\n             }\n-            ++pos;\n+            ++i;\n         }\n-        if (pos > start) {\n-            out.append(value, start, pos);\n+        if (i > n) {\n+            appendable.append(charSequence, n, i);\n         }\n     }\n     \n-    private void printWithEscapes(final Reader reader, final Appendable out) throws IOException {\n-        int start = 0;\n-        int pos = 0;\n-        final char delim = this.getDelimiter();\n-        final char escape = (char)this.getEscapeCharacter();\n-        final StringBuilder builder = new StringBuilder(4096);\n-        int c;\n-        while (-1 != (c = reader.read())) {\n-            builder.append((char)c);\n-            if (c == 13 || c == 10 || c == delim || c == escape) {\n-                if (pos > start) {\n-                    out.append(builder.substring());\n-                    builder.setLength();\n+    private void printWithEscapes(final Reader reader, final Appendable appendable) throws IOException {\n+        int n = 0;\n+        int n2 = 0;\n+        final char delimiter = this.getDelimiter();\n+        final char charValue = (char)this.getEscapeCharacter();\n+        final StringBuilder sb = new StringBuilder(4096);\n+        int read;\n+        while (-1 != (read = reader.read())) {\n+            sb.append((char)read);\n+            if (read == '\\r' || read == '\\n' || read == delimiter || read == charValue) {\n+                if (n2 > n) {\n+                    appendable.append(sb.substring());\n+                    sb.setLength();\n                 }\n-                if (c == 10) {\n-                    c = 110;\n+                if (read == '\\n') {\n+                    read = 'n';\n                 }\n-                else if (c == 13) {\n-                    c = 114;\n+                else if (read == '\\r') {\n+                    read = 'r';\n                 }\n-                out.append(escape);\n-                out.append((char)c);\n-                start = pos + 1;\n+                appendable.append(charValue);\n+                appendable.append((char)read);\n+                n = n2 + 1;\n             }\n-            ++pos;\n+            ++n2;\n         }\n-        if (pos > start) {\n-            out.append(builder.substring());\n+        if (n2 > n) {\n+            appendable.append(sb.substring());\n         }\n     }\n     \n-    private void printWithQuotes(final Object object, final CharSequence value, final Appendable out, final boolean newRecord) throws IOException {\n-        boolean quote = false;\n-        int start = 0;\n-        int pos = 0;\n-        final int end;\n-        final int len = end = value.length();\n-        final char delimChar = this.getDelimiter();\n-        final char quoteChar = (char)this.getQuoteCharacter();\n-        final char escapeChar = this.isEscapeCharacterSet() ? ((char)this.getEscapeCharacter()) : quoteChar;\n-        QuoteMode quoteModePolicy = this.getQuoteMode();\n-        if (quoteModePolicy == null) {\n-            quoteModePolicy = QuoteMode.MINIMAL;\n+    private void printWithQuotes(final Object o, final CharSequence charSequence, final Appendable appendable, final boolean b) throws IOException {\n+        int n = 0;\n+        int n2 = 0;\n+        int i = 0;\n+        final int length;\n+        final int n3 = length = charSequence.length();\n+        final char delimiter = this.getDelimiter();\n+        final char charValue = (char)this.getQuoteCharacter();\n+        final char c = this.isEscapeCharacterSet() ? ((char)this.getEscapeCharacter()) : charValue;\n+        QuoteMode obj = this.getQuoteMode();\n+        if (obj == null) {\n+            obj = QuoteMode.MINIMAL;\n         }\n-        switch (CSVFormat.CSVFormat$1.$SwitchMap$org$apache$commons$csv$QuoteMode[quoteModePolicy.ordinal()]) {\n+        switch (CSVFormat.CSVFormat$1.$SwitchMap$org$apache$commons$csv$QuoteMode[obj.ordinal()]) {\n             case 1:\n             case 2: {\n-                quote = true;\n+                n = 1;\n                 break;\n             }\n             case 3: {\n-                quote = !(object instanceof Number);\n+                n = ((o instanceof Number) ? 0 : 1);\n                 break;\n             }\n             case 4: {\n-                this.printWithEscapes(value, out);\n+                this.printWithEscapes(charSequence, appendable);\n                 return;\n             }\n             case 5: {\n-                if (len <= 0) {\n-                    if (newRecord) {\n-                        quote = true;\n+                if (n3 <= 0) {\n+                    if (b) {\n+                        n = 1;\n                     }\n                 }\n+                else if (charSequence.charAt(i) <= '#') {\n+                    n = 1;\n+                }\n                 else {\n-                    char c = value.charAt(pos);\n-                    if (c <= '#') {\n-                        quote = true;\n-                    }\n-                    else {\n-                        while (pos < end) {\n-                            c = value.charAt(pos);\n-                            if (c == '\\n' || c == '\\r' || c == quoteChar || c == delimChar || c == escapeChar) {\n-                                quote = true;\n-                                break;\n-                            }\n-                            ++pos;\n+                    while (i < length) {\n+                        final char char1 = charSequence.charAt(i);\n+                        if (char1 == '\\n' || char1 == '\\r' || char1 == charValue || char1 == delimiter || char1 == c) {\n+                            n = 1;\n+                            break;\n                         }\n-                        if (!quote) {\n-                            pos = end - 1;\n-                            c = value.charAt(pos);\n-                            if (c <= ' ') {\n-                                quote = true;\n-                            }\n+                        ++i;\n+                    }\n+                    if (n == 0) {\n+                        i = length - 1;\n+                        if (charSequence.charAt(i) <= ' ') {\n+                            n = 1;\n                         }\n                     }\n                 }\n-                if (!quote) {\n-                    out.append(value, start, end);\n+                if (n == 0) {\n+                    appendable.append(charSequence, n2, length);\n                     return;\n                 }\n                 break;\n             }\n             default: {\n-                throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n+                throw new IllegalStateException(\"Unexpected Quote value: \" + obj);\n             }\n         }\n-        if (!quote) {\n-            out.append(value, start, end);\n+        if (n == 0) {\n+            appendable.append(charSequence, n2, length);\n             return;\n         }\n-        out.append(quoteChar);\n-        while (pos < end) {\n-            final char c = value.charAt(pos);\n-            if (c == quoteChar || c == escapeChar) {\n-                out.append(value, start, pos);\n-                out.append(escapeChar);\n-                start = pos;\n+        appendable.append(charValue);\n+        while (i < length) {\n+            final char char2 = charSequence.charAt(i);\n+            if (char2 == charValue || char2 == c) {\n+                appendable.append(charSequence, n2, i);\n+                appendable.append(c);\n+                n2 = i;\n             }\n-            ++pos;\n+            ++i;\n         }\n-        out.append(value, start, pos);\n-        out.append(quoteChar);\n+        appendable.append(charSequence, n2, i);\n+        appendable.append(charValue);\n     }\n     \n-    private void printWithQuotes(final Reader reader, final Appendable out) throws IOException {\n+    private void printWithQuotes(final Reader reader, final Appendable appendable) throws IOException {\n         if (this.getQuoteMode() == QuoteMode.NONE) {\n-            this.printWithEscapes(reader, out);\n+            this.printWithEscapes(reader, appendable);\n             return;\n         }\n-        int pos = 0;\n-        final char quote = (char)this.getQuoteCharacter();\n-        final StringBuilder builder = new StringBuilder(4096);\n-        out.append(quote);\n-        int c;\n-        while (-1 != (c = reader.read())) {\n-            builder.append((char)c);\n-            if (c == quote) {\n-                if (pos > 0) {\n-                    out.append(builder.substring());\n-                    builder.setLength();\n-                    pos = -1;\n-                }\n-                out.append(quote);\n-                out.append((char)c);\n+        int n = 0;\n+        final char charValue = (char)this.getQuoteCharacter();\n+        final StringBuilder sb = new StringBuilder(4096);\n+        appendable.append(charValue);\n+        int read;\n+        while (-1 != (read = reader.read())) {\n+            sb.append((char)read);\n+            if (read == charValue) {\n+                if (n > 0) {\n+                    appendable.append(sb.substring());\n+                    sb.setLength();\n+                    n = -1;\n+                }\n+                appendable.append(charValue);\n+                appendable.append((char)read);\n             }\n-            ++pos;\n+            ++n;\n         }\n-        if (pos > 0) {\n-            out.append(builder.substring());\n+        if (n > 0) {\n+            appendable.append(sb.substring());\n         }\n-        out.append(quote);\n+        appendable.append(charValue);\n     }\n     \n     @Override\n     public String toString() {\n         final StringBuilder sb = new StringBuilder();\n         sb.append(\"Delimiter=<\").append(this.delimiter).append('>');\n         if (this.isEscapeCharacterSet()) {\n@@ -630,38 +602,38 @@\n         if (this.header != null) {\n             sb.append(' ');\n             sb.append(\"Header:\").append(Arrays.toString((Object[])this.header));\n         }\n         return sb.toString();\n     }\n     \n-    private String[] toStringArray(final Object[] values) {\n-        if (values == null) {\n+    private String[] toStringArray(final Object[] array) {\n+        if (array == null) {\n             return null;\n         }\n-        final String[] strings = new String[values.length];\n-        for (int i = 0; i < values.length; ++i) {\n-            final Object value = values[i];\n-            strings[i] = ((value == null) ? null : value.toString());\n+        final String[] array2 = new String[array.length];\n+        for (int i = 0; i < array.length; ++i) {\n+            final Object o = array[i];\n+            array2[i] = ((o == null) ? null : o.toString());\n         }\n-        return strings;\n+        return array2;\n     }\n     \n     private CharSequence trim(final CharSequence charSequence) {\n         if (charSequence instanceof String) {\n             return ((String)charSequence).trim();\n         }\n-        int len;\n-        int count;\n-        int pos;\n-        for (count = (len = charSequence.length()), pos = 0; pos < len && charSequence.charAt(pos) <= ' '; ++pos) {}\n-        while (pos < len && charSequence.charAt(len - 1) <= ' ') {\n-            --len;\n+        int length;\n+        int n;\n+        int n2;\n+        for (n = (length = charSequence.length()), n2 = 0; n2 < length && charSequence.charAt(n2) <= ' '; ++n2) {}\n+        while (n2 < length && charSequence.charAt(length - 1) <= ' ') {\n+            --length;\n         }\n-        return (pos > 0 || len < count) ? charSequence.subSequence(pos, len) : charSequence;\n+        return (n2 > 0 || length < n) ? charSequence.subSequence(n2, length) : charSequence;\n     }\n     \n     private void validate() throws IllegalArgumentException {\n         if (isLineBreak(this.delimiter)) {\n             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n         }\n         if (this.quoteCharacter != null && this.delimiter == this.quoteCharacter) {\n@@ -679,189 +651,189 @@\n         if (this.escapeCharacter != null && this.escapeCharacter.equals(this.commentMarker)) {\n             throw new IllegalArgumentException(\"The comment start and the escape character cannot be the same ('\" + this.commentMarker + \"')\");\n         }\n         if (this.escapeCharacter == null && this.quoteMode == QuoteMode.NONE) {\n             throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n         }\n         if (this.header != null && !this.allowDuplicateHeaderNames) {\n-            final Set<String> dupCheck = new HashSet<String>();\n-            for (final String hdr : this.header) {\n-                if (!dupCheck.add(hdr)) {\n-                    throw new IllegalArgumentException(\"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString((Object[])this.header));\n+            final HashSet set = new HashSet();\n+            for (final String str : this.header) {\n+                if (!set.add(str)) {\n+                    throw new IllegalArgumentException(\"The header contains a duplicate entry: '\" + str + \"' in \" + Arrays.toString((Object[])this.header));\n                 }\n             }\n         }\n     }\n     \n     public CSVFormat withAllowDuplicateHeaderNames() {\n         return this.withAllowDuplicateHeaderNames(true);\n     }\n     \n-    public CSVFormat withAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\n-        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, allowDuplicateHeaderNames);\n+    public CSVFormat withAllowDuplicateHeaderNames(final boolean b) {\n+        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, b);\n     }\n     \n     public CSVFormat withAllowMissingColumnNames() {\n         return this.withAllowMissingColumnNames(true);\n     }\n     \n-    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n-        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n+    public CSVFormat withAllowMissingColumnNames(final boolean b) {\n+        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, b, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n     }\n     \n-    public CSVFormat withAutoFlush(final boolean autoFlush) {\n-        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, autoFlush, this.allowDuplicateHeaderNames);\n+    public CSVFormat withAutoFlush(final boolean b) {\n+        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, b, this.allowDuplicateHeaderNames);\n     }\n     \n-    public CSVFormat withCommentMarker(final char commentMarker) {\n-        return this.withCommentMarker(Character.valueOf(commentMarker));\n+    public CSVFormat withCommentMarker(final char c) {\n+        return this.withCommentMarker(Character.valueOf(c));\n     }\n     \n-    public CSVFormat withCommentMarker(final Character commentMarker) {\n-        if (isLineBreak(commentMarker)) {\n+    public CSVFormat withCommentMarker(final Character c) {\n+        if (isLineBreak(c)) {\n             throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n         }\n-        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n+        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, c, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n     }\n     \n-    public CSVFormat withDelimiter(final char delimiter) {\n-        if (isLineBreak(delimiter)) {\n+    public CSVFormat withDelimiter(final char c) {\n+        if (isLineBreak(c)) {\n             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n         }\n-        return new CSVFormat(delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n+        return new CSVFormat(c, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n     }\n     \n-    public CSVFormat withEscape(final char escape) {\n-        return this.withEscape(Character.valueOf(escape));\n+    public CSVFormat withEscape(final char c) {\n+        return this.withEscape(Character.valueOf(c));\n     }\n     \n-    public CSVFormat withEscape(final Character escape) {\n-        if (isLineBreak(escape)) {\n+    public CSVFormat withEscape(final Character c) {\n+        if (isLineBreak(c)) {\n             throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n         }\n-        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, escape, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n+        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, c, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n     }\n     \n     public CSVFormat withFirstRecordAsHeader() {\n         return this.withHeader(new String[0]).withSkipHeaderRecord();\n     }\n     \n-    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\n-        String[] header = null;\n-        if (headerEnum != null) {\n-            final Enum<?>[] enumValues = (Enum[])headerEnum.getEnumConstants();\n-            header = new String[enumValues.length];\n-            for (int i = 0; i < enumValues.length; ++i) {\n-                header[i] = enumValues[i].name();\n+    public CSVFormat withHeader(final Class<? extends Enum<?>> clazz) {\n+        String[] array = null;\n+        if (clazz != null) {\n+            final Enum[] array2 = (Enum[])clazz.getEnumConstants();\n+            array = new String[array2.length];\n+            for (int i = 0; i < array2.length; ++i) {\n+                array[i] = array2[i].name();\n             }\n         }\n-        return this.withHeader(header);\n+        return this.withHeader(array);\n     }\n     \n-    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\n-        return this.withHeader((resultSet != null) ? resultSet.getMetaData() : null);\n+    public CSVFormat withHeader(final ResultSet set) throws SQLException {\n+        return this.withHeader((set != null) ? set.getMetaData() : null);\n     }\n     \n-    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException {\n-        String[] labels = null;\n-        if (metaData != null) {\n-            final int columnCount = metaData.getColumnCount();\n-            labels = new String[columnCount];\n+    public CSVFormat withHeader(final ResultSetMetaData resultSetMetaData) throws SQLException {\n+        String[] array = null;\n+        if (resultSetMetaData != null) {\n+            final int columnCount = resultSetMetaData.getColumnCount();\n+            array = new String[columnCount];\n             for (int i = 0; i < columnCount; ++i) {\n-                labels[i] = metaData.getColumnLabel(i + 1);\n+                array[i] = resultSetMetaData.getColumnLabel(i + 1);\n             }\n         }\n-        return this.withHeader(labels);\n+        return this.withHeader(array);\n     }\n     \n-    public CSVFormat withHeader(final String... header) {\n-        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n+    public CSVFormat withHeader(final String... array) {\n+        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, array, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n     }\n     \n-    public CSVFormat withHeaderComments(final Object... headerComments) {\n-        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n+    public CSVFormat withHeaderComments(final Object... array) {\n+        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, array, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n     }\n     \n     public CSVFormat withIgnoreEmptyLines() {\n         return this.withIgnoreEmptyLines(true);\n     }\n     \n-    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n-        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n+    public CSVFormat withIgnoreEmptyLines(final boolean b) {\n+        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, b, this.recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n     }\n     \n     public CSVFormat withIgnoreHeaderCase() {\n         return this.withIgnoreHeaderCase(true);\n     }\n     \n-    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n-        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n+    public CSVFormat withIgnoreHeaderCase(final boolean b) {\n+        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, b, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n     }\n     \n     public CSVFormat withIgnoreSurroundingSpaces() {\n         return this.withIgnoreSurroundingSpaces(true);\n     }\n     \n-    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n-        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n+    public CSVFormat withIgnoreSurroundingSpaces(final boolean b) {\n+        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, b, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n     }\n     \n-    public CSVFormat withNullString(final String nullString) {\n-        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n+    public CSVFormat withNullString(final String s) {\n+        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, s, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n     }\n     \n-    public CSVFormat withQuote(final char quoteChar) {\n-        return this.withQuote(Character.valueOf(quoteChar));\n+    public CSVFormat withQuote(final char c) {\n+        return this.withQuote(Character.valueOf(c));\n     }\n     \n-    public CSVFormat withQuote(final Character quoteChar) {\n-        if (isLineBreak(quoteChar)) {\n+    public CSVFormat withQuote(final Character c) {\n+        if (isLineBreak(c)) {\n             throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n         }\n-        return new CSVFormat(this.delimiter, quoteChar, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n+        return new CSVFormat(this.delimiter, c, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n     }\n     \n-    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n-        return new CSVFormat(this.delimiter, this.quoteCharacter, quoteModePolicy, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n+    public CSVFormat withQuoteMode(final QuoteMode quoteMode) {\n+        return new CSVFormat(this.delimiter, this.quoteCharacter, quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n     }\n     \n-    public CSVFormat withRecordSeparator(final char recordSeparator) {\n-        return this.withRecordSeparator(String.valueOf(recordSeparator));\n+    public CSVFormat withRecordSeparator(final char c) {\n+        return this.withRecordSeparator(String.valueOf(c));\n     }\n     \n-    public CSVFormat withRecordSeparator(final String recordSeparator) {\n-        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n+    public CSVFormat withRecordSeparator(final String s) {\n+        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, s, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n     }\n     \n     public CSVFormat withSkipHeaderRecord() {\n         return this.withSkipHeaderRecord(true);\n     }\n     \n-    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n-        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n+    public CSVFormat withSkipHeaderRecord(final boolean b) {\n+        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, b, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n     }\n     \n     public CSVFormat withSystemRecordSeparator() {\n         return this.withRecordSeparator(System.getProperty(\"line.separator\"));\n     }\n     \n     public CSVFormat withTrailingDelimiter() {\n         return this.withTrailingDelimiter(true);\n     }\n     \n-    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\n-        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n+    public CSVFormat withTrailingDelimiter(final boolean b) {\n+        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, this.trim, b, this.autoFlush, this.allowDuplicateHeaderNames);\n     }\n     \n     public CSVFormat withTrim() {\n         return this.withTrim(true);\n     }\n     \n-    public CSVFormat withTrim(final boolean trim) {\n-        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, trim, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n+    public CSVFormat withTrim(final boolean b) {\n+        return new CSVFormat(this.delimiter, this.quoteCharacter, this.quoteMode, this.commentMarker, this.escapeCharacter, this.ignoreSurroundingSpaces, this.ignoreEmptyLines, this.recordSeparator, this.nullString, this.headerComments, this.header, this.skipHeaderRecord, this.allowMissingColumnNames, this.ignoreHeaderCase, b, this.trailingDelimiter, this.autoFlush, this.allowDuplicateHeaderNames);\n     }\n     \n     static {\n         DEFAULT = new CSVFormat(',', Constants.DOUBLE_QUOTE_CHAR, null, null, null, false, true, \"\\r\\n\", null, null, null, false, false, false, false, false, false, true);\n         EXCEL = CSVFormat.DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames();\n         INFORMIX_UNLOAD = CSVFormat.DEFAULT.withDelimiter('|').withEscape('\\\\').withQuote(Constants.DOUBLE_QUOTE_CHAR).withRecordSeparator('\\n');\n         INFORMIX_UNLOAD_CSV = CSVFormat.DEFAULT.withDelimiter(',').withQuote(Constants.DOUBLE_QUOTE_CHAR).withRecordSeparator('\\n');\n"}]}
