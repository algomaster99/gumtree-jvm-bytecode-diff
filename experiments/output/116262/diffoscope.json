{"diffoscope-json-version": 1, "source1": "first/PropertyCacheFile.class", "source2": "second/PropertyCacheFile.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -36,14 +36,18 @@\n     private static final byte[] BUFFER;\n     private static final int BASE_16 = 16;\n     private final Properties details;\n     private final Configuration config;\n     private final String fileName;\n     private String configHash;\n     \n+    static {\n+        BUFFER = new byte[1024];\n+    }\n+    \n     public PropertyCacheFile(final Configuration config, final String fileName) {\n         this.details = new Properties();\n         if (config == null) {\n             throw new IllegalArgumentException(\"config can not be null\");\n         }\n         if (fileName == null) {\n             throw new IllegalArgumentException(\"fileName can not be null\");\n@@ -52,35 +56,75 @@\n         this.fileName = fileName;\n     }\n     \n     public void load() throws IOException {\n         this.configHash = getHashCodeBasedOnObjectContent((Serializable)this.config);\n         final Path path = Path.of(this.fileName, new String[0]);\n         if (Files.exists(path, new LinkOption[0])) {\n-            try (final InputStream inStream = Files.newInputStream(path, new OpenOption[0])) {\n-                this.details.load(inStream);\n-                final String cachedConfigHash = this.details.getProperty(\"configuration*?\");\n-                if (!this.configHash.equals(cachedConfigHash)) {\n-                    this.reset();\n+            Throwable t = null;\n+            try {\n+                final InputStream inStream = Files.newInputStream(path, new OpenOption[0]);\n+                try {\n+                    this.details.load(inStream);\n+                    final String cachedConfigHash = this.details.getProperty(\"configuration*?\");\n+                    if (!this.configHash.equals(cachedConfigHash)) {\n+                        this.reset();\n+                    }\n+                }\n+                finally {\n+                    if (inStream != null) {\n+                        inStream.close();\n+                    }\n+                }\n+            }\n+            finally {\n+                if (t == null) {\n+                    final Throwable exception;\n+                    t = exception;\n+                }\n+                else {\n+                    final Throwable exception;\n+                    if (t != exception) {\n+                        t.addSuppressed(exception);\n+                    }\n                 }\n             }\n         }\n-        else {\n-            this.reset();\n-        }\n+        this.reset();\n     }\n     \n     public void persist() throws IOException {\n         final Path path = Paths.get(this.fileName, new String[0]);\n         final Path directory = path.getParent();\n         if (directory != null) {\n             Files.createDirectories(directory, (FileAttribute<?>[])new FileAttribute[0]);\n         }\n-        try (final OutputStream out = Files.newOutputStream(path, new OpenOption[0])) {\n-            this.details.store(out, null);\n+        Throwable t = null;\n+        try {\n+            final OutputStream out = Files.newOutputStream(path, new OpenOption[0]);\n+            try {\n+                this.details.store(out, null);\n+            }\n+            finally {\n+                if (out != null) {\n+                    out.close();\n+                }\n+            }\n+        }\n+        finally {\n+            if (t == null) {\n+                final Throwable exception;\n+                t = exception;\n+            }\n+            else {\n+                final Throwable exception;\n+                if (t != exception) {\n+                    t.addSuppressed(exception);\n+                }\n+            }\n         }\n     }\n     \n     public void reset() {\n         this.details.clear();\n         this.details.setProperty(\"configuration*?\", this.configHash);\n     }\n@@ -112,30 +156,51 @@\n         }\n         catch (final IOException | NoSuchAlgorithmException ex) {\n             throw new IllegalStateException(\"Unable to calculate hashcode.\", ex);\n         }\n     }\n     \n     private static void serialize(final Serializable object, final OutputStream outputStream) throws IOException {\n-        try (final ObjectOutputStream oos = new ObjectOutputStream(outputStream)) {\n-            oos.writeObject(object);\n+        Throwable t = null;\n+        try {\n+            final ObjectOutputStream oos = new ObjectOutputStream(outputStream);\n+            try {\n+                oos.writeObject(object);\n+            }\n+            finally {\n+                if (oos != null) {\n+                    oos.close();\n+                }\n+            }\n+        }\n+        finally {\n+            if (t == null) {\n+                final Throwable exception;\n+                t = exception;\n+            }\n+            else {\n+                final Throwable exception;\n+                if (t != exception) {\n+                    t.addSuppressed(exception);\n+                }\n+            }\n         }\n     }\n     \n     public void putExternalResources(final Set<String> locations) {\n         final Set<PropertyCacheFile.ExternalResource> resources = loadExternalResources(locations);\n         if (this.areExternalResourcesChanged(resources)) {\n             this.reset();\n             this.fillCacheWithExternalResources(resources);\n         }\n     }\n     \n     private static Set<PropertyCacheFile.ExternalResource> loadExternalResources(final Set<String> resourceLocations) {\n         final Set<PropertyCacheFile.ExternalResource> resources = new HashSet<PropertyCacheFile.ExternalResource>();\n-        for (String location : resourceLocations) {\n+        for (final String location : resourceLocations) {\n             try {\n                 final byte[] content = loadExternalResource(location);\n                 final String contentHashSum = getHashCodeBasedOnObjectContent(content);\n                 resources.add(new PropertyCacheFile.ExternalResource(\"module-resource*?:\" + location, contentHashSum));\n             }\n             catch (final CheckstyleException | IOException ex) {\n                 final String contentHashSum = getHashCodeBasedOnObjectContent(ex);\n@@ -143,16 +208,37 @@\n             }\n         }\n         return resources;\n     }\n     \n     private static byte[] loadExternalResource(final String location) throws IOException, CheckstyleException {\n         final URI uri = CommonUtil.getUriByFilename(location);\n-        try (final InputStream is = uri.toURL().openStream()) {\n-            return toByteArray(is);\n+        Throwable t = null;\n+        try {\n+            final InputStream is = uri.toURL().openStream();\n+            try {\n+                return toByteArray(is);\n+            }\n+            finally {\n+                if (is != null) {\n+                    is.close();\n+                }\n+            }\n+        }\n+        finally {\n+            if (t == null) {\n+                final Throwable exception;\n+                t = exception;\n+            }\n+            else {\n+                final Throwable exception;\n+                if (t != exception) {\n+                    t.addSuppressed(exception);\n+                }\n+            }\n         }\n     }\n     \n     private static byte[] toByteArray(final InputStream stream) throws IOException {\n         final ByteArrayOutputStream content = new ByteArrayOutputStream();\n         while (true) {\n             final int size = stream.read(PropertyCacheFile.BUFFER);\n@@ -187,12 +273,8 @@\n         externalResources.forEach(resource -> this.details.setProperty(resource.location, resource.contentHashSum));\n     }\n     \n     private boolean isResourceLocationInCache(final String location) {\n         final String cachedHashSum = this.details.getProperty(location);\n         return cachedHashSum != null;\n     }\n-    \n-    static {\n-        BUFFER = new byte[1024];\n-    }\n }\n"}]}
