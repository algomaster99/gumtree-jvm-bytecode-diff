{"diffoscope-json-version": 1, "source1": "first/AbstractByteArrayOutputStream.class", "source2": "second/AbstractByteArrayOutputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -31,32 +31,32 @@\n         this.reuseBuffers = true;\n     }\n     \n     @Override\n     public void close() throws IOException {\n     }\n     \n-    protected void needNewBuffer(final int newCount) {\n+    protected void needNewBuffer(final int n) {\n         if (this.currentBufferIndex < this.buffers.size() - 1) {\n             this.filledBufferSum += this.currentBuffer.length;\n             ++this.currentBufferIndex;\n             this.currentBuffer = this.buffers.get(this.currentBufferIndex);\n         }\n         else {\n-            int newBufferSize;\n+            int max;\n             if (this.currentBuffer == null) {\n-                newBufferSize = newCount;\n+                max = n;\n                 this.filledBufferSum = 0;\n             }\n             else {\n-                newBufferSize = Math.max(this.currentBuffer.length << 1, newCount - this.filledBufferSum);\n+                max = Math.max(this.currentBuffer.length << 1, n - this.filledBufferSum);\n                 this.filledBufferSum += this.currentBuffer.length;\n             }\n             ++this.currentBufferIndex;\n-            this.currentBuffer = IOUtils.byteArray(newBufferSize);\n+            this.currentBuffer = IOUtils.byteArray(max);\n             this.buffers.add(this.currentBuffer);\n         }\n     }\n     \n     public abstract void reset();\n     \n     protected void resetImpl() {\n@@ -64,133 +64,133 @@\n         this.filledBufferSum = 0;\n         this.currentBufferIndex = 0;\n         if (this.reuseBuffers) {\n             this.currentBuffer = this.buffers.get(this.currentBufferIndex);\n         }\n         else {\n             this.currentBuffer = null;\n-            final int size = ((byte[])this.buffers.get(0)).length;\n+            final int length = ((byte[])this.buffers.get(0)).length;\n             this.buffers.clear();\n-            this.needNewBuffer(size);\n+            this.needNewBuffer(length);\n             this.reuseBuffers = true;\n         }\n     }\n     \n     public abstract int size();\n     \n     public abstract byte[] toByteArray();\n     \n     protected byte[] toByteArrayImpl() {\n-        int remaining = this.count;\n-        if (remaining == 0) {\n+        int count = this.count;\n+        if (count == 0) {\n             return IOUtils.EMPTY_BYTE_ARRAY;\n         }\n-        final byte[] newBuf = IOUtils.byteArray(remaining);\n-        int pos = 0;\n-        for (final byte[] buf : this.buffers) {\n-            final int c = Math.min(buf.length, remaining);\n-            System.arraycopy(buf, 0, newBuf, pos, c);\n-            pos += c;\n-            remaining -= c;\n-            if (remaining == 0) {\n+        final byte[] byteArray = IOUtils.byteArray(count);\n+        int n = 0;\n+        for (final byte[] array : this.buffers) {\n+            final int min = Math.min(array.length, count);\n+            System.arraycopy(array, 0, byteArray, n, min);\n+            n += min;\n+            count -= min;\n+            if (count == 0) {\n                 break;\n             }\n         }\n-        return newBuf;\n+        return byteArray;\n     }\n     \n     public abstract InputStream toInputStream();\n     \n-    protected <T extends InputStream> InputStream toInputStream(final AbstractByteArrayOutputStream.InputStreamConstructor<T> isConstructor) {\n-        int remaining = this.count;\n-        if (remaining == 0) {\n+    protected <T extends InputStream> InputStream toInputStream(final AbstractByteArrayOutputStream.InputStreamConstructor<T> inputStreamConstructor) {\n+        int count = this.count;\n+        if (count == 0) {\n             return (InputStream)ClosedInputStream.INSTANCE;\n         }\n-        final List<T> list = new ArrayList<T>(this.buffers.size());\n-        for (final byte[] buf : this.buffers) {\n-            final int c = Math.min(buf.length, remaining);\n-            list.add((T)isConstructor.construct(buf, 0, c));\n-            remaining -= c;\n-            if (remaining == 0) {\n+        final ArrayList c = new ArrayList(this.buffers.size());\n+        for (final byte[] array : this.buffers) {\n+            final int min = Math.min(array.length, count);\n+            c.add(inputStreamConstructor.construct(array, 0, min));\n+            count -= min;\n+            if (count == 0) {\n                 break;\n             }\n         }\n         this.reuseBuffers = false;\n-        return new SequenceInputStream(Collections.enumeration(list));\n+        return new SequenceInputStream((Enumeration<? extends InputStream>)Collections.enumeration((Collection<Object>)c));\n     }\n     \n     @Deprecated\n     @Override\n     public String toString() {\n         return new String(this.toByteArray(), Charset.defaultCharset());\n     }\n     \n     public String toString(final Charset charset) {\n         return new String(this.toByteArray(), charset);\n     }\n     \n-    public String toString(final String enc) throws UnsupportedEncodingException {\n-        return new String(this.toByteArray(), enc);\n+    public String toString(final String charsetName) throws UnsupportedEncodingException {\n+        return new String(this.toByteArray(), charsetName);\n     }\n     \n     @Override\n     public abstract void write(final byte[] p0, final int p1, final int p2);\n     \n     public abstract int write(final InputStream p0) throws IOException;\n     \n     @Override\n     public abstract void write(final int p0);\n     \n-    protected void writeImpl(final byte[] b, final int off, final int len) {\n-        final int newCount = this.count + len;\n-        int remaining = len;\n-        int inBufferPos = this.count - this.filledBufferSum;\n-        while (remaining > 0) {\n-            final int part = Math.min(remaining, this.currentBuffer.length - inBufferPos);\n-            System.arraycopy(b, off + len - remaining, this.currentBuffer, inBufferPos, part);\n-            remaining -= part;\n-            if (remaining > 0) {\n-                this.needNewBuffer(newCount);\n-                inBufferPos = 0;\n-            }\n-        }\n-        this.count = newCount;\n-    }\n-    \n-    protected int writeImpl(final InputStream in) throws IOException {\n-        int readCount = 0;\n-        for (int inBufferPos = this.count - this.filledBufferSum, n = in.read(this.currentBuffer, inBufferPos, this.currentBuffer.length - inBufferPos); n != -1; n = in.read(this.currentBuffer, inBufferPos, this.currentBuffer.length - inBufferPos)) {\n-            readCount += n;\n-            inBufferPos += n;\n-            this.count += n;\n-            if (inBufferPos == this.currentBuffer.length) {\n+    protected void writeImpl(final byte[] array, final int n, final int n2) {\n+        final int count = this.count + n2;\n+        int i = n2;\n+        int n3 = this.count - this.filledBufferSum;\n+        while (i > 0) {\n+            final int min = Math.min(i, this.currentBuffer.length - n3);\n+            System.arraycopy(array, n + n2 - i, this.currentBuffer, n3, min);\n+            i -= min;\n+            if (i > 0) {\n+                this.needNewBuffer(count);\n+                n3 = 0;\n+            }\n+        }\n+        this.count = count;\n+    }\n+    \n+    protected int writeImpl(final InputStream inputStream) throws IOException {\n+        int n = 0;\n+        for (int n2 = this.count - this.filledBufferSum, i = inputStream.read(this.currentBuffer, n2, this.currentBuffer.length - n2); i != -1; i = inputStream.read(this.currentBuffer, n2, this.currentBuffer.length - n2)) {\n+            n += i;\n+            n2 += i;\n+            this.count += i;\n+            if (n2 == this.currentBuffer.length) {\n                 this.needNewBuffer(this.currentBuffer.length);\n-                inBufferPos = 0;\n+                n2 = 0;\n             }\n         }\n-        return readCount;\n+        return n;\n     }\n     \n-    protected void writeImpl(final int b) {\n-        int inBufferPos = this.count - this.filledBufferSum;\n-        if (inBufferPos == this.currentBuffer.length) {\n+    protected void writeImpl(final int n) {\n+        int n2 = this.count - this.filledBufferSum;\n+        if (n2 == this.currentBuffer.length) {\n             this.needNewBuffer(this.count + 1);\n-            inBufferPos = 0;\n+            n2 = 0;\n         }\n-        this.currentBuffer[inBufferPos] = (byte)b;\n+        this.currentBuffer[n2] = (byte)n;\n         ++this.count;\n     }\n     \n     public abstract void writeTo(final OutputStream p0) throws IOException;\n     \n-    protected void writeToImpl(final OutputStream out) throws IOException {\n-        int remaining = this.count;\n-        for (final byte[] buf : this.buffers) {\n-            final int c = Math.min(buf.length, remaining);\n-            out.write(buf, 0, c);\n-            remaining -= c;\n-            if (remaining == 0) {\n+    protected void writeToImpl(final OutputStream outputStream) throws IOException {\n+        int count = this.count;\n+        for (final byte[] b : this.buffers) {\n+            final int min = Math.min(b.length, count);\n+            outputStream.write(b, 0, min);\n+            count -= min;\n+            if (count == 0) {\n                 break;\n             }\n         }\n     }\n }\n"}]}
