{"diffoscope-json-version": 1, "source1": "first/MagicNumberFileFilter.class", "source2": "second/MagicNumberFileFilter.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -19,84 +19,82 @@\n \n public class MagicNumberFileFilter extends AbstractFileFilter implements Serializable\n {\n     private static final long serialVersionUID = -547733176983104172L;\n     private final byte[] magicNumbers;\n     private final long byteOffset;\n     \n-    public MagicNumberFileFilter(final byte[] magicNumber) {\n-        this(magicNumber, 0L);\n+    public MagicNumberFileFilter(final byte[] array) {\n+        this(array, 0L);\n     }\n     \n-    public MagicNumberFileFilter(final byte[] magicNumber, final long offset) {\n-        if (magicNumber == null) {\n+    public MagicNumberFileFilter(final byte[] array, final long byteOffset) {\n+        if (array == null) {\n             throw new IllegalArgumentException(\"The magic number cannot be null\");\n         }\n-        if (magicNumber.length == 0) {\n+        if (array.length == 0) {\n             throw new IllegalArgumentException(\"The magic number must contain at least one byte\");\n         }\n-        if (offset < 0L) {\n+        if (byteOffset < 0L) {\n             throw new IllegalArgumentException(\"The offset cannot be negative\");\n         }\n-        System.arraycopy(magicNumber, 0, this.magicNumbers = IOUtils.byteArray(magicNumber.length), 0, magicNumber.length);\n-        this.byteOffset = offset;\n+        System.arraycopy(array, 0, this.magicNumbers = IOUtils.byteArray(array.length), 0, array.length);\n+        this.byteOffset = byteOffset;\n     }\n     \n-    public MagicNumberFileFilter(final String magicNumber) {\n-        this(magicNumber, 0L);\n+    public MagicNumberFileFilter(final String s) {\n+        this(s, 0L);\n     }\n     \n-    public MagicNumberFileFilter(final String magicNumber, final long offset) {\n-        if (magicNumber == null) {\n+    public MagicNumberFileFilter(final String s, final long byteOffset) {\n+        if (s == null) {\n             throw new IllegalArgumentException(\"The magic number cannot be null\");\n         }\n-        if (magicNumber.isEmpty()) {\n+        if (s.isEmpty()) {\n             throw new IllegalArgumentException(\"The magic number must contain at least one byte\");\n         }\n-        if (offset < 0L) {\n+        if (byteOffset < 0L) {\n             throw new IllegalArgumentException(\"The offset cannot be negative\");\n         }\n-        this.magicNumbers = magicNumber.getBytes(Charset.defaultCharset());\n-        this.byteOffset = offset;\n+        this.magicNumbers = s.getBytes(Charset.defaultCharset());\n+        this.byteOffset = byteOffset;\n     }\n     \n     public boolean accept(final File file) {\n         if (file != null && file.isFile() && file.canRead()) {\n             try (final RandomAccessFile randomAccessFile = new RandomAccessFile(file, \"r\")) {\n-                final byte[] fileBytes = IOUtils.byteArray(this.magicNumbers.length);\n+                final byte[] byteArray = IOUtils.byteArray(this.magicNumbers.length);\n                 randomAccessFile.seek(this.byteOffset);\n-                final int read = randomAccessFile.read(fileBytes);\n-                if (read != this.magicNumbers.length) {\n+                if (randomAccessFile.read(byteArray) != this.magicNumbers.length) {\n                     return false;\n                 }\n-                return Arrays.equals(this.magicNumbers, fileBytes);\n+                return Arrays.equals(this.magicNumbers, byteArray);\n             }\n             catch (final IOException ex) {}\n         }\n         return false;\n     }\n     \n-    public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {\n-        if (file != null && Files.isRegularFile(file, new LinkOption[0]) && Files.isReadable(file)) {\n-            try (final FileChannel fileChannel = FileChannel.open(file, new OpenOption[0])) {\n-                final ByteBuffer byteBuffer = ByteBuffer.allocate(this.magicNumbers.length);\n-                final int read = fileChannel.read(byteBuffer);\n-                if (read != this.magicNumbers.length) {\n+    public FileVisitResult accept(final Path path, final BasicFileAttributes basicFileAttributes) {\n+        if (path != null && Files.isRegularFile(path, new LinkOption[0]) && Files.isReadable(path)) {\n+            try (final FileChannel open = FileChannel.open(path, new OpenOption[0])) {\n+                final ByteBuffer allocate = ByteBuffer.allocate(this.magicNumbers.length);\n+                if (open.read(allocate) != this.magicNumbers.length) {\n                     return FileVisitResult.TERMINATE;\n                 }\n-                return toFileVisitResult(Arrays.equals(this.magicNumbers, byteBuffer.array()), file);\n+                return toFileVisitResult(Arrays.equals(this.magicNumbers, allocate.array()), path);\n             }\n             catch (final IOException ex) {}\n         }\n         return FileVisitResult.TERMINATE;\n     }\n     \n     public String toString() {\n-        final StringBuilder builder = new StringBuilder(super.toString());\n-        builder.append(\"(\");\n-        builder.append(new String(this.magicNumbers, Charset.defaultCharset()));\n-        builder.append(\",\");\n-        builder.append(this.byteOffset);\n-        builder.append(\")\");\n-        return builder.toString();\n+        final StringBuilder sb = new StringBuilder(super.toString());\n+        sb.append(\"(\");\n+        sb.append(new String(this.magicNumbers, Charset.defaultCharset()));\n+        sb.append(\",\");\n+        sb.append(this.byteOffset);\n+        sb.append(\")\");\n+        return sb.toString();\n     }\n }\n"}]}
