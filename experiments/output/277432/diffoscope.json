{"diffoscope-json-version": 1, "source1": "first/ZipUtil.class", "source2": "second/ZipUtil.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -8,180 +8,174 @@\n import java.util.Calendar;\n import java.util.Date;\n \n public abstract class ZipUtil\n {\n     private static final byte[] DOS_TIME_MIN;\n     \n-    public static ZipLong toDosTime(final Date time) {\n-        return new ZipLong(toDosTime(time.getTime()));\n+    public static ZipLong toDosTime(final Date date) {\n+        return new ZipLong(toDosTime(date.getTime()));\n     }\n     \n-    public static byte[] toDosTime(final long t) {\n-        final byte[] result = new byte[4];\n-        toDosTime(t, result, 0);\n-        return result;\n+    public static byte[] toDosTime(final long n) {\n+        final byte[] array = new byte[4];\n+        toDosTime(n, array, 0);\n+        return array;\n     }\n     \n-    public static void toDosTime(final long t, final byte[] buf, final int offset) {\n-        toDosTime(Calendar.getInstance(), t, buf, offset);\n+    public static void toDosTime(final long n, final byte[] array, final int n2) {\n+        toDosTime(Calendar.getInstance(), n, array, n2);\n     }\n     \n-    static void toDosTime(final Calendar c, final long t, final byte[] buf, final int offset) {\n-        c.setTimeInMillis(t);\n-        final int year = c.get(1);\n-        if (year < 1980) {\n-            copy(ZipUtil.DOS_TIME_MIN, buf, offset);\n+    static void toDosTime(final Calendar calendar, final long timeInMillis, final byte[] array, final int n) {\n+        calendar.setTimeInMillis(timeInMillis);\n+        final int value = calendar.get(1);\n+        if (value < 1980) {\n+            copy(ZipUtil.DOS_TIME_MIN, array, n);\n             return;\n         }\n-        final int month = c.get(2) + 1;\n-        final long value = (long)(year - 1980 << 25 | month << 21 | c.get(5) << 16 | c.get(11) << 11 | c.get(12) << 5 | c.get(13) >> 1);\n-        ZipLong.putLong(value, buf, offset);\n+        ZipLong.putLong((long)(value - 1980 << 25 | calendar.get(2) + 1 << 21 | calendar.get(5) << 16 | calendar.get(11) << 11 | calendar.get(12) << 5 | calendar.get(13) >> 1), array, n);\n     }\n     \n-    public static long adjustToLong(final int i) {\n-        if (i < 0) {\n-            return 4294967296L + i;\n+    public static long adjustToLong(final int n) {\n+        if (n < 0) {\n+            return 4294967296L + n;\n         }\n-        return i;\n+        return n;\n     }\n     \n     public static byte[] reverse(final byte[] array) {\n-        final int z = array.length - 1;\n+        final int n = array.length - 1;\n         for (int i = 0; i < array.length / 2; ++i) {\n-            final byte x = array[i];\n-            array[i] = array[z - i];\n-            array[z - i] = x;\n+            final byte b = array[i];\n+            array[i] = array[n - i];\n+            array[n - i] = b;\n         }\n         return array;\n     }\n     \n-    static long bigToLong(final BigInteger big) {\n-        if (big.bitLength() <= 63) {\n-            return big.longValue();\n+    static long bigToLong(final BigInteger obj) {\n+        if (obj.bitLength() <= 63) {\n+            return obj.longValue();\n         }\n-        throw new NumberFormatException(\"The BigInteger cannot fit inside a 64 bit java long: [\" + String.valueOf((Object)big));\n+        throw new NumberFormatException(\"The BigInteger cannot fit inside a 64 bit java long: [\" + String.valueOf((Object)obj));\n     }\n     \n-    static BigInteger longToBig(long l) {\n-        if (l < -2147483648L) {\n-            throw new IllegalArgumentException(\"Negative longs < -2^31 not permitted: [\" + l);\n+    static BigInteger longToBig(long adjustToLong) {\n+        if (adjustToLong < -2147483648L) {\n+            throw new IllegalArgumentException(\"Negative longs < -2^31 not permitted: [\" + adjustToLong);\n         }\n-        if (l < 0L && l >= -2147483648L) {\n-            l = adjustToLong((int)l);\n+        if (adjustToLong < 0L && adjustToLong >= -2147483648L) {\n+            adjustToLong = adjustToLong((int)adjustToLong);\n         }\n-        return BigInteger.valueOf(l);\n+        return BigInteger.valueOf(adjustToLong);\n     }\n     \n     public static int signedByteToUnsignedInt(final byte b) {\n         if (b >= 0) {\n             return b;\n         }\n         return 256 + b;\n     }\n     \n-    public static byte unsignedIntToSignedByte(final int i) {\n-        if (i > 255 || i < 0) {\n-            throw new IllegalArgumentException(\"Can only convert non-negative integers between [0,255] to byte: [\" + i);\n-        }\n-        if (i < 128) {\n-            return (byte)i;\n-        }\n-        return (byte)(i - 256);\n-    }\n-    \n-    public static Date fromDosTime(final ZipLong zipDosTime) {\n-        final long dosTime = zipDosTime.getValue();\n-        return new Date(dosToJavaTime(dosTime));\n-    }\n-    \n-    public static long dosToJavaTime(final long dosTime) {\n-        final Calendar cal = Calendar.getInstance();\n-        cal.set(1, (int)(dosTime >> 25 & 0x7FL) + 1980);\n-        cal.set(2, (int)(dosTime >> 21 & 0xFL) - 1);\n-        cal.set(5, (int)(dosTime >> 16) & 0x1F);\n-        cal.set(11, (int)(dosTime >> 11) & 0x1F);\n-        cal.set(12, (int)(dosTime >> 5) & 0x3F);\n-        cal.set(13, (int)(dosTime << 1) & 0x3E);\n-        cal.set(14, 0);\n-        return cal.getTime().getTime();\n-    }\n-    \n-    static void setNameAndCommentFromExtraFields(final ZipArchiveEntry ze, final byte[] originalNameBytes, final byte[] commentBytes) {\n-        final ZipExtraField nameCandidate = ze.getExtraField(UnicodePathExtraField.UPATH_ID);\n-        final UnicodePathExtraField name = (nameCandidate instanceof UnicodePathExtraField) ? ((UnicodePathExtraField)nameCandidate) : null;\n-        final String newName = getUnicodeStringIfOriginalMatches((AbstractUnicodeExtraField)name, originalNameBytes);\n-        if (newName != null) {\n-            ze.setName(newName);\n-            ze.setNameSource(ZipArchiveEntry.NameSource.UNICODE_EXTRA_FIELD);\n-        }\n-        if (commentBytes != null && commentBytes.length > 0) {\n-            final ZipExtraField cmtCandidate = ze.getExtraField(UnicodeCommentExtraField.UCOM_ID);\n-            final UnicodeCommentExtraField cmt = (cmtCandidate instanceof UnicodeCommentExtraField) ? ((UnicodeCommentExtraField)cmtCandidate) : null;\n-            final String newComment = getUnicodeStringIfOriginalMatches((AbstractUnicodeExtraField)cmt, commentBytes);\n-            if (newComment != null) {\n-                ze.setComment(newComment);\n-                ze.setCommentSource(ZipArchiveEntry.CommentSource.UNICODE_EXTRA_FIELD);\n+    public static byte unsignedIntToSignedByte(final int n) {\n+        if (n > 255 || n < 0) {\n+            throw new IllegalArgumentException(\"Can only convert non-negative integers between [0,255] to byte: [\" + n);\n+        }\n+        if (n < 128) {\n+            return (byte)n;\n+        }\n+        return (byte)(n - 256);\n+    }\n+    \n+    public static Date fromDosTime(final ZipLong zipLong) {\n+        return new Date(dosToJavaTime(zipLong.getValue()));\n+    }\n+    \n+    public static long dosToJavaTime(final long n) {\n+        final Calendar instance = Calendar.getInstance();\n+        instance.set(1, (int)(n >> 25 & 0x7FL) + 1980);\n+        instance.set(2, (int)(n >> 21 & 0xFL) - 1);\n+        instance.set(5, (int)(n >> 16) & 0x1F);\n+        instance.set(11, (int)(n >> 11) & 0x1F);\n+        instance.set(12, (int)(n >> 5) & 0x3F);\n+        instance.set(13, (int)(n << 1) & 0x3E);\n+        instance.set(14, 0);\n+        return instance.getTime().getTime();\n+    }\n+    \n+    static void setNameAndCommentFromExtraFields(final ZipArchiveEntry zipArchiveEntry, final byte[] array, final byte[] array2) {\n+        final ZipExtraField extraField = zipArchiveEntry.getExtraField(UnicodePathExtraField.UPATH_ID);\n+        final String unicodeStringIfOriginalMatches = getUnicodeStringIfOriginalMatches((extraField instanceof UnicodePathExtraField) ? ((UnicodePathExtraField)extraField) : null, array);\n+        if (unicodeStringIfOriginalMatches != null) {\n+            zipArchiveEntry.setName(unicodeStringIfOriginalMatches);\n+            zipArchiveEntry.setNameSource(ZipArchiveEntry.NameSource.UNICODE_EXTRA_FIELD);\n+        }\n+        if (array2 != null && array2.length > 0) {\n+            final ZipExtraField extraField2 = zipArchiveEntry.getExtraField(UnicodeCommentExtraField.UCOM_ID);\n+            final String unicodeStringIfOriginalMatches2 = getUnicodeStringIfOriginalMatches((extraField2 instanceof UnicodeCommentExtraField) ? ((UnicodeCommentExtraField)extraField2) : null, array2);\n+            if (unicodeStringIfOriginalMatches2 != null) {\n+                zipArchiveEntry.setComment(unicodeStringIfOriginalMatches2);\n+                zipArchiveEntry.setCommentSource(ZipArchiveEntry.CommentSource.UNICODE_EXTRA_FIELD);\n             }\n         }\n     }\n     \n-    private static String getUnicodeStringIfOriginalMatches(final AbstractUnicodeExtraField f, final byte[] orig) {\n-        if (f != null) {\n+    private static String getUnicodeStringIfOriginalMatches(final AbstractUnicodeExtraField abstractUnicodeExtraField, final byte[] b) {\n+        if (abstractUnicodeExtraField != null) {\n             final CRC32 crc32 = new CRC32();\n-            crc32.update(orig);\n-            final long origCRC32 = crc32.getValue();\n-            if (origCRC32 == f.getNameCRC32()) {\n+            crc32.update(b);\n+            if (crc32.getValue() == abstractUnicodeExtraField.getNameCRC32()) {\n                 try {\n-                    return ZipEncodingHelper.UTF8_ZIP_ENCODING.decode(f.getUnicodeName());\n+                    return ZipEncodingHelper.UTF8_ZIP_ENCODING.decode(abstractUnicodeExtraField.getUnicodeName());\n                 }\n                 catch (final IOException ex) {\n                     return null;\n                 }\n             }\n         }\n         return null;\n     }\n     \n-    static byte[] copy(final byte[] from) {\n-        if (from != null) {\n-            return Arrays.copyOf(from, from.length);\n+    static byte[] copy(final byte[] original) {\n+        if (original != null) {\n+            return Arrays.copyOf(original, original.length);\n         }\n         return null;\n     }\n     \n-    static void copy(final byte[] from, final byte[] to, final int offset) {\n-        if (from != null) {\n-            System.arraycopy(from, 0, to, offset, from.length);\n+    static void copy(final byte[] array, final byte[] array2, final int n) {\n+        if (array != null) {\n+            System.arraycopy(array, 0, array2, n, array.length);\n         }\n     }\n     \n-    static boolean canHandleEntryData(final ZipArchiveEntry entry) {\n-        return supportsEncryptionOf(entry) && supportsMethodOf(entry);\n+    static boolean canHandleEntryData(final ZipArchiveEntry zipArchiveEntry) {\n+        return supportsEncryptionOf(zipArchiveEntry) && supportsMethodOf(zipArchiveEntry);\n     }\n     \n-    private static boolean supportsEncryptionOf(final ZipArchiveEntry entry) {\n-        return !entry.getGeneralPurposeBit().usesEncryption();\n+    private static boolean supportsEncryptionOf(final ZipArchiveEntry zipArchiveEntry) {\n+        return !zipArchiveEntry.getGeneralPurposeBit().usesEncryption();\n     }\n     \n-    private static boolean supportsMethodOf(final ZipArchiveEntry entry) {\n-        return entry.getMethod() == 0 || entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || entry.getMethod() == ZipMethod.IMPLODING.getCode() || entry.getMethod() == 8 || entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || entry.getMethod() == ZipMethod.BZIP2.getCode();\n+    private static boolean supportsMethodOf(final ZipArchiveEntry zipArchiveEntry) {\n+        return zipArchiveEntry.getMethod() == 0 || zipArchiveEntry.getMethod() == ZipMethod.UNSHRINKING.getCode() || zipArchiveEntry.getMethod() == ZipMethod.IMPLODING.getCode() || zipArchiveEntry.getMethod() == 8 || zipArchiveEntry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || zipArchiveEntry.getMethod() == ZipMethod.BZIP2.getCode();\n     }\n     \n-    static void checkRequestedFeatures(final ZipArchiveEntry ze) throws UnsupportedZipFeatureException {\n-        if (!supportsEncryptionOf(ze)) {\n-            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.ENCRYPTION, ze);\n+    static void checkRequestedFeatures(final ZipArchiveEntry zipArchiveEntry) throws UnsupportedZipFeatureException {\n+        if (!supportsEncryptionOf(zipArchiveEntry)) {\n+            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.ENCRYPTION, zipArchiveEntry);\n         }\n-        if (supportsMethodOf(ze)) {\n+        if (supportsMethodOf(zipArchiveEntry)) {\n             return;\n         }\n-        final ZipMethod m = ZipMethod.getMethodByCode(ze.getMethod());\n-        if (m == null) {\n-            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.METHOD, ze);\n+        final ZipMethod methodByCode = ZipMethod.getMethodByCode(zipArchiveEntry.getMethod());\n+        if (methodByCode == null) {\n+            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.METHOD, zipArchiveEntry);\n         }\n-        throw new UnsupportedZipFeatureException(m, ze);\n+        throw new UnsupportedZipFeatureException(methodByCode, zipArchiveEntry);\n     }\n     \n     static {\n         DOS_TIME_MIN = ZipLong.getBytes(8448L);\n     }\n }\n"}]}
