{"diffoscope-json-version": 1, "source1": "first/ImportOrderCheck.class", "source2": "second/ImportOrderCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -38,24 +38,24 @@\n         this.groups = ImportOrderCheck.EMPTY_PATTERN_ARRAY;\n         this.staticGroups = ImportOrderCheck.EMPTY_PATTERN_ARRAY;\n         this.ordered = true;\n         this.caseSensitive = true;\n         this.option = ImportOrderOption.UNDER;\n     }\n     \n-    public void setOption(final String optionStr) {\n-        this.option = ImportOrderOption.valueOf(optionStr.trim().toUpperCase(Locale.ENGLISH));\n+    public void setOption(final String s) {\n+        this.option = ImportOrderOption.valueOf(s.trim().toUpperCase(Locale.ENGLISH));\n     }\n     \n-    public void setGroups(final String... packageGroups) {\n-        this.groups = compilePatterns(packageGroups);\n+    public void setGroups(final String... array) {\n+        this.groups = compilePatterns(array);\n     }\n     \n-    public void setStaticGroups(final String... packageGroups) {\n-        this.staticGroups = compilePatterns(packageGroups);\n+    public void setStaticGroups(final String... array) {\n+        this.staticGroups = compilePatterns(array);\n     }\n     \n     public void setOrdered(final boolean ordered) {\n         this.ordered = ordered;\n     }\n     \n     public void setSeparated(final boolean separated) {\n@@ -66,249 +66,241 @@\n         this.separatedStaticGroups = separatedStaticGroups;\n     }\n     \n     public void setCaseSensitive(final boolean caseSensitive) {\n         this.caseSensitive = caseSensitive;\n     }\n     \n-    public void setSortStaticImportsAlphabetically(final boolean sortAlphabetically) {\n-        this.sortStaticImportsAlphabetically = sortAlphabetically;\n+    public void setSortStaticImportsAlphabetically(final boolean sortStaticImportsAlphabetically) {\n+        this.sortStaticImportsAlphabetically = sortStaticImportsAlphabetically;\n     }\n     \n-    public void setUseContainerOrderingForStatic(final boolean useContainerOrdering) {\n-        this.useContainerOrderingForStatic = useContainerOrdering;\n+    public void setUseContainerOrderingForStatic(final boolean useContainerOrderingForStatic) {\n+        this.useContainerOrderingForStatic = useContainerOrderingForStatic;\n     }\n     \n     public int[] getDefaultTokens() {\n         return this.getRequiredTokens();\n     }\n     \n     public int[] getAcceptableTokens() {\n         return this.getRequiredTokens();\n     }\n     \n     public int[] getRequiredTokens() {\n         return new int[] { 30, 152 };\n     }\n     \n-    public void beginTree(final DetailAST rootAST) {\n+    public void beginTree(final DetailAST detailAST) {\n         this.lastGroup = Integer.MIN_VALUE;\n         this.lastImportLine = Integer.MIN_VALUE;\n         this.lastImportStatic = false;\n         this.beforeFirstImport = true;\n         this.staticImportsApart = (this.option == ImportOrderOption.TOP || this.option == ImportOrderOption.BOTTOM);\n     }\n     \n-    public void visitToken(final DetailAST ast) {\n-        FullIdent ident;\n-        boolean isStatic;\n-        if (ast.getType() == 30) {\n-            ident = FullIdent.createFullIdentBelow(ast);\n-            isStatic = false;\n+    public void visitToken(final DetailAST detailAST) {\n+        FullIdent fullIdent;\n+        boolean lastImportStatic;\n+        if (detailAST.getType() == 30) {\n+            fullIdent = FullIdent.createFullIdentBelow(detailAST);\n+            lastImportStatic = false;\n         }\n         else {\n-            ident = FullIdent.createFullIdent(ast.getFirstChild().getNextSibling());\n-            isStatic = true;\n+            fullIdent = FullIdent.createFullIdent(detailAST.getFirstChild().getNextSibling());\n+            lastImportStatic = true;\n         }\n         if (this.option == ImportOrderOption.TOP || this.option == ImportOrderOption.ABOVE) {\n-            final boolean isStaticAndNotLastImport = isStatic && !this.lastImportStatic;\n-            this.doVisitToken(ident, isStatic, isStaticAndNotLastImport, ast);\n+            this.doVisitToken(fullIdent, lastImportStatic, lastImportStatic && !this.lastImportStatic, detailAST);\n         }\n         else if (this.option == ImportOrderOption.BOTTOM || this.option == ImportOrderOption.UNDER) {\n-            final boolean isLastImportAndNonStatic = this.lastImportStatic && !isStatic;\n-            this.doVisitToken(ident, isStatic, isLastImportAndNonStatic, ast);\n+            this.doVisitToken(fullIdent, lastImportStatic, this.lastImportStatic && !lastImportStatic, detailAST);\n         }\n         else {\n             if (this.option != ImportOrderOption.INFLOW) {\n                 throw new IllegalStateException(\"Unexpected option for static imports: \" + this.option);\n             }\n-            this.doVisitToken(ident, isStatic, true, ast);\n+            this.doVisitToken(fullIdent, lastImportStatic, true, detailAST);\n         }\n-        this.lastImportLine = ast.findFirstToken(45).getLineNo();\n-        this.lastImportStatic = isStatic;\n+        this.lastImportLine = detailAST.findFirstToken(45).getLineNo();\n+        this.lastImportStatic = lastImportStatic;\n         this.beforeFirstImport = false;\n     }\n     \n-    private void doVisitToken(final FullIdent ident, final boolean isStatic, final boolean previous, final DetailAST ast) {\n-        final String name = ident.getText();\n-        final int groupIdx = this.getGroupNumber(isStatic && this.staticImportsApart, name);\n-        if (groupIdx > this.lastGroup) {\n-            if (!this.beforeFirstImport && ast.getLineNo() - this.lastImportLine < 2 && this.needSeparator(isStatic)) {\n-                this.log(ast, \"import.separation\", new Object[] { name });\n+    private void doVisitToken(final FullIdent fullIdent, final boolean b, final boolean b2, final DetailAST detailAST) {\n+        final String text = fullIdent.getText();\n+        final int groupNumber = this.getGroupNumber(b && this.staticImportsApart, text);\n+        if (groupNumber > this.lastGroup) {\n+            if (!this.beforeFirstImport && detailAST.getLineNo() - this.lastImportLine < 2 && this.needSeparator(b)) {\n+                this.log(detailAST, \"import.separation\", new Object[] { text });\n             }\n         }\n-        else if (groupIdx == this.lastGroup) {\n-            this.doVisitTokenInSameGroup(isStatic, previous, name, ast);\n+        else if (groupNumber == this.lastGroup) {\n+            this.doVisitTokenInSameGroup(b, b2, text, detailAST);\n         }\n         else {\n-            this.log(ast, \"import.ordering\", new Object[] { name });\n+            this.log(detailAST, \"import.ordering\", new Object[] { text });\n         }\n-        if (this.isSeparatorInGroup(groupIdx, isStatic, ast.getLineNo())) {\n-            this.log(ast, \"import.groups.separated.internally\", new Object[] { name });\n+        if (this.isSeparatorInGroup(groupNumber, b, detailAST.getLineNo())) {\n+            this.log(detailAST, \"import.groups.separated.internally\", new Object[] { text });\n         }\n-        this.lastGroup = groupIdx;\n-        this.lastImport = name;\n+        this.lastGroup = groupNumber;\n+        this.lastImport = text;\n     }\n     \n-    private boolean needSeparator(final boolean isStatic) {\n-        final boolean typeImportSeparator = !isStatic && this.separated;\n-        boolean staticImportSeparator;\n+    private boolean needSeparator(final boolean b) {\n+        final boolean b2 = !b && this.separated;\n+        boolean separated;\n         if (this.staticImportsApart) {\n-            staticImportSeparator = (isStatic && this.separatedStaticGroups);\n+            separated = (b && this.separatedStaticGroups);\n         }\n         else {\n-            staticImportSeparator = this.separated;\n+            separated = this.separated;\n         }\n-        final boolean separatorBetween = isStatic != this.lastImportStatic && (this.separated || this.separatedStaticGroups);\n-        return typeImportSeparator || staticImportSeparator || separatorBetween;\n+        final boolean b3 = b != this.lastImportStatic && (this.separated || this.separatedStaticGroups);\n+        return b2 || separated || b3;\n     }\n     \n-    private boolean isSeparatorInGroup(final int groupIdx, final boolean isStatic, final int line) {\n-        final boolean inSameGroup = groupIdx == this.lastGroup;\n-        return (inSameGroup || !this.needSeparator(isStatic)) && this.isSeparatorBeforeImport(line);\n+    private boolean isSeparatorInGroup(final int n, final boolean b, final int n2) {\n+        return (n == this.lastGroup || !this.needSeparator(b)) && this.isSeparatorBeforeImport(n2);\n     }\n     \n-    private boolean isSeparatorBeforeImport(final int line) {\n-        return line - this.lastImportLine > 1;\n+    private boolean isSeparatorBeforeImport(final int n) {\n+        return n - this.lastImportLine > 1;\n     }\n     \n-    private void doVisitTokenInSameGroup(final boolean isStatic, final boolean previous, final String name, final DetailAST ast) {\n+    private void doVisitTokenInSameGroup(final boolean b, final boolean b2, final String s, final DetailAST detailAST) {\n         if (this.ordered) {\n             if (this.option == ImportOrderOption.INFLOW) {\n-                if (this.isWrongOrder(name, isStatic)) {\n-                    this.log(ast, \"import.ordering\", new Object[] { name });\n+                if (this.isWrongOrder(s, b)) {\n+                    this.log(detailAST, \"import.ordering\", new Object[] { s });\n                 }\n             }\n-            else {\n-                final boolean shouldFireError = previous || (this.lastImportStatic == isStatic && this.isWrongOrder(name, isStatic));\n-                if (shouldFireError) {\n-                    this.log(ast, \"import.ordering\", new Object[] { name });\n-                }\n+            else if (b2 || (this.lastImportStatic == b && this.isWrongOrder(s, b))) {\n+                this.log(detailAST, \"import.ordering\", new Object[] { s });\n             }\n         }\n     }\n     \n-    private boolean isWrongOrder(final String name, final boolean isStatic) {\n-        boolean result;\n-        if (isStatic) {\n+    private boolean isWrongOrder(final String s, final boolean b) {\n+        boolean b2;\n+        if (b) {\n             if (this.useContainerOrderingForStatic) {\n-                result = (compareContainerOrder(this.lastImport, name, this.caseSensitive) > 0);\n+                b2 = (compareContainerOrder(this.lastImport, s, this.caseSensitive) > 0);\n             }\n             else if (this.staticImportsApart) {\n-                result = (this.sortStaticImportsAlphabetically && compare(this.lastImport, name, this.caseSensitive) > 0);\n+                b2 = (this.sortStaticImportsAlphabetically && compare(this.lastImport, s, this.caseSensitive) > 0);\n             }\n             else {\n-                result = (compare(this.lastImport, name, this.caseSensitive) > 0);\n+                b2 = (compare(this.lastImport, s, this.caseSensitive) > 0);\n             }\n         }\n         else {\n-            result = (compare(this.lastImport, name, this.caseSensitive) > 0);\n+            b2 = (compare(this.lastImport, s, this.caseSensitive) > 0);\n         }\n-        return result;\n+        return b2;\n     }\n     \n-    private static int compareContainerOrder(final String importName1, final String importName2, final boolean caseSensitive) {\n-        final String container1 = getImportContainer(importName1);\n-        final String container2 = getImportContainer(importName2);\n-        int compareContainersOrderResult;\n-        if (caseSensitive) {\n-            compareContainersOrderResult = container1.compareTo(container2);\n+    private static int compareContainerOrder(final String s, final String s2, final boolean b) {\n+        final String importContainer = getImportContainer(s);\n+        final String importContainer2 = getImportContainer(s2);\n+        int n;\n+        if (b) {\n+            n = importContainer.compareTo(importContainer2);\n         }\n         else {\n-            compareContainersOrderResult = container1.compareToIgnoreCase(container2);\n+            n = importContainer.compareToIgnoreCase(importContainer2);\n         }\n-        int result;\n-        if (compareContainersOrderResult == 0) {\n-            result = compare(importName1, importName2, caseSensitive);\n+        int compare;\n+        if (n == 0) {\n+            compare = compare(s, s2, b);\n         }\n         else {\n-            result = compareContainersOrderResult;\n+            compare = n;\n         }\n-        return result;\n+        return compare;\n     }\n     \n-    private static String getImportContainer(final String qualifiedImportName) {\n-        final int lastDotIndex = qualifiedImportName.lastIndexOf(46);\n-        return qualifiedImportName.substring(0, lastDotIndex);\n+    private static String getImportContainer(final String s) {\n+        return s.substring(0, s.lastIndexOf(46));\n     }\n     \n-    private int getGroupNumber(final boolean isStatic, final String name) {\n-        Pattern[] patterns;\n-        if (isStatic) {\n-            patterns = this.staticGroups;\n+    private int getGroupNumber(final boolean b, final String s) {\n+        Pattern[] array;\n+        if (b) {\n+            array = this.staticGroups;\n         }\n         else {\n-            patterns = this.groups;\n+            array = this.groups;\n         }\n-        int number = getGroupNumber(patterns, name);\n-        if (isStatic && this.option == ImportOrderOption.BOTTOM) {\n-            number += this.groups.length + 1;\n+        int groupNumber = getGroupNumber(array, s);\n+        if (b && this.option == ImportOrderOption.BOTTOM) {\n+            groupNumber += this.groups.length + 1;\n         }\n-        else if (!isStatic && this.option == ImportOrderOption.TOP) {\n-            number += this.staticGroups.length + 1;\n+        else if (!b && this.option == ImportOrderOption.TOP) {\n+            groupNumber += this.staticGroups.length + 1;\n         }\n-        return number;\n+        return groupNumber;\n     }\n     \n-    private static int getGroupNumber(final Pattern[] patterns, final String name) {\n-        int bestIndex = patterns.length;\n-        int bestEnd = -1;\n-        int bestPos = Integer.MAX_VALUE;\n-        for (int i = 0; i < patterns.length; ++i) {\n-            final Matcher matcher = patterns[i].matcher(name);\n+    private static int getGroupNumber(final Pattern[] array, final String input) {\n+        int length = array.length;\n+        int n = -1;\n+        int start = Integer.MAX_VALUE;\n+        for (int i = 0; i < array.length; ++i) {\n+            final Matcher matcher = array[i].matcher(input);\n             if (matcher.find()) {\n-                if (matcher.start() < bestPos) {\n-                    bestIndex = i;\n-                    bestEnd = matcher.end();\n-                    bestPos = matcher.start();\n+                if (matcher.start() < start) {\n+                    length = i;\n+                    n = matcher.end();\n+                    start = matcher.start();\n                 }\n-                else if (matcher.start() == bestPos && matcher.end() > bestEnd) {\n-                    bestIndex = i;\n-                    bestEnd = matcher.end();\n+                else if (matcher.start() == start && matcher.end() > n) {\n+                    length = i;\n+                    n = matcher.end();\n                 }\n             }\n         }\n-        return bestIndex;\n+        return length;\n     }\n     \n-    private static int compare(final String string1, final String string2, final boolean caseSensitive) {\n-        int result;\n-        if (caseSensitive) {\n-            result = string1.compareTo(string2);\n+    private static int compare(final String s, final String s2, final boolean b) {\n+        int n;\n+        if (b) {\n+            n = s.compareTo(s2);\n         }\n         else {\n-            result = string1.compareToIgnoreCase(string2);\n+            n = s.compareToIgnoreCase(s2);\n         }\n-        return result;\n+        return n;\n     }\n     \n-    private static Pattern[] compilePatterns(final String... packageGroups) {\n-        final Pattern[] patterns = new Pattern[packageGroups.length];\n-        for (int i = 0; i < packageGroups.length; ++i) {\n-            String pkg = packageGroups[i];\n-            Pattern grp;\n-            if (\"*\".equals(pkg)) {\n-                grp = Pattern.compile(\"\");\n-            }\n-            else if (pkg.startsWith(\"/\")) {\n-                if (!pkg.endsWith(\"/\")) {\n-                    throw new IllegalArgumentException(\"Invalid group: \" + pkg);\n+    private static Pattern[] compilePatterns(final String... array) {\n+        final Pattern[] array2 = new Pattern[array.length];\n+        for (int i = 0; i < array.length; ++i) {\n+            final String s = array[i];\n+            Pattern pattern;\n+            if (\"*\".equals(s)) {\n+                pattern = Pattern.compile(\"\");\n+            }\n+            else if (s.startsWith(\"/\")) {\n+                if (!s.endsWith(\"/\")) {\n+                    throw new IllegalArgumentException(\"Invalid group: \" + s);\n                 }\n-                pkg = pkg.substring(1, pkg.length() - 1);\n-                grp = Pattern.compile(pkg);\n+                pattern = Pattern.compile(s.substring(1, s.length() - 1));\n             }\n             else {\n-                final StringBuilder pkgBuilder = new StringBuilder(pkg);\n-                if (!pkg.endsWith(\".\")) {\n-                    pkgBuilder.append('.');\n+                final StringBuilder sb = new StringBuilder(s);\n+                if (!s.endsWith(\".\")) {\n+                    sb.append('.');\n                 }\n-                grp = Pattern.compile(\"^\" + Pattern.quote(pkgBuilder.toString()));\n+                pattern = Pattern.compile(\"^\" + Pattern.quote(sb.toString()));\n             }\n-            patterns[i] = grp;\n+            array2[i] = pattern;\n         }\n-        return patterns;\n+        return array2;\n     }\n     \n     static {\n         EMPTY_PATTERN_ARRAY = new Pattern[0];\n     }\n }\n"}]}
