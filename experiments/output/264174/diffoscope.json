{"diffoscope-json-version": 1, "source1": "first/TelnetInputStream.class", "source2": "second/TelnetInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -31,33 +31,33 @@\n     private final TelnetClient client;\n     private final Thread thread;\n     private IOException ioException;\n     private final int[] suboption;\n     private int suboptionCount;\n     private volatile boolean threaded;\n     \n-    TelnetInputStream(final InputStream input, final TelnetClient client) {\n-        this(input, client, true);\n+    TelnetInputStream(final InputStream inputStream, final TelnetClient telnetClient) {\n+        this(inputStream, telnetClient, true);\n     }\n     \n-    TelnetInputStream(final InputStream input, final TelnetClient client, final boolean readerThread) {\n-        super(input);\n+    TelnetInputStream(final InputStream in, final TelnetClient client, final boolean b) {\n+        super(in);\n         this.client = client;\n         this.receiveState = 0;\n         this.isClosed = true;\n         this.hasReachedEOF = false;\n         this.queue = new int[2049];\n         this.queueHead = 0;\n         this.queueTail = 0;\n         this.suboption = new int[client.maxSubnegotiationLength];\n         this.bytesAvailable = 0;\n         this.ioException = null;\n         this.readIsWaiting = false;\n         this.threaded = false;\n-        if (readerThread) {\n+        if (b) {\n             this.thread = new Thread(this);\n         }\n         else {\n             this.thread = null;\n         }\n     }\n     \n@@ -85,153 +85,153 @@\n     }\n     \n     @Override\n     public boolean markSupported() {\n         return false;\n     }\n     \n-    private boolean processChar(final int ch) throws InterruptedException {\n-        final boolean bufferWasEmpty;\n+    private boolean processChar(final int n) throws InterruptedException {\n+        final boolean b;\n         synchronized (this.queue) {\n-            bufferWasEmpty = (this.bytesAvailable == 0);\n+            b = (this.bytesAvailable == 0);\n             while (this.bytesAvailable >= this.queue.length - 1) {\n                 if (!this.threaded) {\n                     throw new IllegalStateException(\"Queue is full! Cannot process another character.\");\n                 }\n                 this.queue.notify();\n                 try {\n                     this.queue.wait();\n                     continue;\n                 }\n-                catch (final InterruptedException e) {\n-                    throw e;\n+                catch (final InterruptedException ex) {\n+                    throw ex;\n                 }\n                 break;\n             }\n             if (this.readIsWaiting && this.threaded) {\n                 this.queue.notify();\n             }\n-            this.queue[this.queueTail] = ch;\n+            this.queue[this.queueTail] = n;\n             ++this.bytesAvailable;\n             if (++this.queueTail >= this.queue.length) {\n                 this.queueTail = 0;\n             }\n         }\n-        return bufferWasEmpty;\n+        return b;\n     }\n     \n     @Override\n     public int read() throws IOException {\n         synchronized (this.queue) {\n             while (this.ioException == null) {\n                 if (this.bytesAvailable != 0) {\n-                    final int ch = this.queue[this.queueHead];\n+                    final int n = this.queue[this.queueHead];\n                     if (++this.queueHead >= this.queue.length) {\n                         this.queueHead = 0;\n                     }\n                     --this.bytesAvailable;\n                     if (this.bytesAvailable == 0 && this.threaded) {\n                         this.queue.notify();\n                     }\n-                    return ch;\n+                    return n;\n                 }\n                 if (this.hasReachedEOF) {\n                     return -1;\n                 }\n                 if (this.threaded) {\n                     this.queue.notify();\n                     try {\n                         this.readIsWaiting = true;\n                         this.queue.wait();\n                         this.readIsWaiting = false;\n                         continue;\n                     }\n-                    catch (final InterruptedException e) {\n+                    catch (final InterruptedException ex) {\n                         throw new InterruptedIOException(\"Fatal thread interruption during read.\");\n                     }\n                 }\n                 this.readIsWaiting = true;\n-                boolean mayBlock = true;\n+                boolean b = true;\n                 do {\n-                    int ch;\n+                    int read;\n                     try {\n-                        if ((ch = this.read(mayBlock)) < 0 && ch != -2) {\n-                            return ch;\n+                        if ((read = this.read(b)) < 0 && read != -2) {\n+                            return read;\n                         }\n                     }\n-                    catch (final InterruptedIOException e2) {\n+                    catch (final InterruptedIOException ioException) {\n                         synchronized (this.queue) {\n-                            this.ioException = e2;\n+                            this.ioException = ioException;\n                             this.queue.notifyAll();\n                             try {\n                                 this.queue.wait(100L);\n                             }\n-                            catch (final InterruptedException ex) {}\n+                            catch (final InterruptedException ex2) {}\n                         }\n                         return -1;\n                     }\n                     try {\n-                        if (ch != -2) {\n-                            this.processChar(ch);\n+                        if (read != -2) {\n+                            this.processChar(read);\n                         }\n                     }\n-                    catch (final InterruptedException e3) {\n+                    catch (final InterruptedException ex3) {\n                         if (this.isClosed) {\n                             return -1;\n                         }\n                     }\n-                    mayBlock = false;\n+                    b = false;\n                 } while (super.available() > 0 && this.bytesAvailable < this.queue.length - 1);\n                 this.readIsWaiting = false;\n             }\n-            final IOException e4 = this.ioException;\n+            final IOException ioException2 = this.ioException;\n             this.ioException = null;\n-            throw e4;\n+            throw ioException2;\n         }\n     }\n     \n-    private int read(final boolean mayBlock) throws IOException {\n-        while (mayBlock || super.available() != 0) {\n-            int ch;\n-            if ((ch = super.read()) < 0) {\n+    private int read(final boolean b) throws IOException {\n+        while (b || super.available() != 0) {\n+            final int read;\n+            if ((read = super.read()) < 0) {\n                 return -1;\n             }\n-            ch &= 0xFF;\n+            final int n = read & 0xFF;\n             synchronized (this.client) {\n                 this.client.processAYTResponse();\n             }\n-            this.client.spyRead(ch);\n+            this.client.spyRead(n);\n             Label_0718: {\n                 switch (this.receiveState) {\n                     case 8: {\n-                        if (ch == 0) {\n+                        if (n == 0) {\n                             continue;\n                         }\n                     }\n                     case 0: {\n-                        if (ch == 255) {\n+                        if (n == 255) {\n                             this.receiveState = 1;\n                             continue;\n                         }\n-                        if (ch == 13) {\n+                        if (n == 13) {\n                             synchronized (this.client) {\n                                 if (this.client.requestedDont(0)) {\n                                     this.receiveState = 8;\n                                 }\n                                 else {\n                                     this.receiveState = 0;\n                                 }\n                             }\n                             break;\n                         }\n                         this.receiveState = 0;\n                         break;\n                     }\n                     case 1: {\n-                        switch (ch) {\n+                        switch (n) {\n                             case 251: {\n                                 this.receiveState = 2;\n                                 continue;\n                             }\n                             case 252: {\n                                 this.receiveState = 3;\n                                 continue;\n@@ -255,167 +255,167 @@\n                             }\n                             case 240: {\n                                 this.receiveState = 0;\n                                 continue;\n                             }\n                             default: {\n                                 this.receiveState = 0;\n-                                this.client.processCommand(ch);\n+                                this.client.processCommand(n);\n                                 continue;\n                             }\n                         }\n                         break;\n                     }\n                     case 2: {\n                         synchronized (this.client) {\n-                            this.client.processWill(ch);\n+                            this.client.processWill(n);\n                             this.client.flushOutputStream();\n                         }\n                         this.receiveState = 0;\n                         continue;\n                     }\n                     case 3: {\n                         synchronized (this.client) {\n-                            this.client.processWont(ch);\n+                            this.client.processWont(n);\n                             this.client.flushOutputStream();\n                         }\n                         this.receiveState = 0;\n                         continue;\n                     }\n                     case 4: {\n                         synchronized (this.client) {\n-                            this.client.processDo(ch);\n+                            this.client.processDo(n);\n                             this.client.flushOutputStream();\n                         }\n                         this.receiveState = 0;\n                         continue;\n                     }\n                     case 5: {\n                         synchronized (this.client) {\n-                            this.client.processDont(ch);\n+                            this.client.processDont(n);\n                             this.client.flushOutputStream();\n                         }\n                         this.receiveState = 0;\n                         continue;\n                     }\n                     case 6: {\n-                        switch (ch) {\n+                        switch (n) {\n                             case 255: {\n                                 this.receiveState = 9;\n                                 continue;\n                             }\n                             default: {\n                                 if (this.suboptionCount < this.suboption.length) {\n-                                    this.suboption[this.suboptionCount++] = ch;\n+                                    this.suboption[this.suboptionCount++] = n;\n                                 }\n                                 this.receiveState = 6;\n                                 continue;\n                             }\n                         }\n                         break;\n                     }\n                     case 9: {\n-                        switch (ch) {\n+                        switch (n) {\n                             case 240: {\n                                 synchronized (this.client) {\n                                     this.client.processSuboption(this.suboption, this.suboptionCount);\n                                     this.client.flushOutputStream();\n                                 }\n                                 this.receiveState = 0;\n                                 continue;\n                             }\n                             case 255: {\n                                 if (this.suboptionCount < this.suboption.length) {\n-                                    this.suboption[this.suboptionCount++] = ch;\n+                                    this.suboption[this.suboptionCount++] = n;\n                                     break;\n                                 }\n                                 break;\n                             }\n                         }\n                         this.receiveState = 6;\n                         continue;\n                     }\n                 }\n             }\n-            return ch;\n+            return n;\n         }\n         return -2;\n     }\n     \n     @Override\n-    public int read(final byte[] buffer) throws IOException {\n-        return this.read(buffer, 0, buffer.length);\n+    public int read(final byte[] array) throws IOException {\n+        return this.read(array, 0, array.length);\n     }\n     \n     @Override\n-    public int read(final byte[] buffer, int offset, int length) throws IOException {\n-        if (length < 1) {\n+    public int read(final byte[] array, int n, int bytesAvailable) throws IOException {\n+        if (bytesAvailable < 1) {\n             return 0;\n         }\n         synchronized (this.queue) {\n-            if (length > this.bytesAvailable) {\n-                length = this.bytesAvailable;\n+            if (bytesAvailable > this.bytesAvailable) {\n+                bytesAvailable = this.bytesAvailable;\n             }\n         }\n-        int ch;\n-        if ((ch = this.read()) == -1) {\n+        int n2;\n+        if ((n2 = this.read()) == -1) {\n             return -1;\n         }\n-        final int off = offset;\n+        final int n3 = n;\n         do {\n-            buffer[offset++] = (byte)ch;\n-        } while (--length > 0 && (ch = this.read()) != -1);\n-        return offset - off;\n+            array[n++] = (byte)n2;\n+        } while (--bytesAvailable > 0 && (n2 = this.read()) != -1);\n+        return n - n3;\n     }\n     \n     @Override\n     public void run() {\n         try {\n             while (!this.isClosed) {\n-                int ch;\n+                int read;\n                 try {\n-                    if ((ch = this.read(true)) < 0) {\n+                    if ((read = this.read(true)) < 0) {\n                         break;\n                     }\n                 }\n-                catch (final InterruptedIOException e) {\n+                catch (final InterruptedIOException ioException) {\n                     synchronized (this.queue) {\n-                        this.ioException = e;\n+                        this.ioException = ioException;\n                         this.queue.notifyAll();\n                         try {\n                             this.queue.wait(100L);\n                         }\n-                        catch (final InterruptedException interrupted) {\n+                        catch (final InterruptedException ex) {\n                             if (this.isClosed) {\n                                 break;\n                             }\n                         }\n                     }\n                 }\n-                catch (final RuntimeException re) {\n+                catch (final RuntimeException ex2) {\n                     super.close();\n                     break;\n                 }\n-                boolean notify = false;\n+                boolean processChar = false;\n                 try {\n-                    notify = this.processChar(ch);\n+                    processChar = this.processChar(read);\n                 }\n-                catch (final InterruptedException e2) {\n+                catch (final InterruptedException ex3) {\n                     if (this.isClosed) {\n                         break;\n                     }\n                 }\n-                if (notify) {\n+                if (processChar) {\n                     this.client.notifyInputListener();\n                 }\n             }\n         }\n-        catch (final IOException ioe) {\n+        catch (final IOException ioException2) {\n             synchronized (this.queue) {\n-                this.ioException = ioe;\n+                this.ioException = ioException2;\n             }\n             this.client.notifyInputListener();\n         }\n         synchronized (this.queue) {\n             this.isClosed = true;\n             this.hasReachedEOF = true;\n             this.queue.notify();\n"}]}
