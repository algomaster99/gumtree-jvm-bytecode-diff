{"diffoscope-json-version": 1, "source1": "first/NewlineAtEndOfFileCheck.class", "source2": "second/NewlineAtEndOfFileCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -21,45 +21,45 @@\n         this.lineSeparator = LineSeparatorOption.LF_CR_CRLF;\n     }\n     \n     protected void processFiltered(final File file, final FileText fileText) {\n         try {\n             this.readAndCheckFile(file);\n         }\n-        catch (final IOException ignored) {\n+        catch (final IOException ex) {\n             this.log(1, \"unable.open\", new Object[] { file.getPath() });\n         }\n     }\n     \n-    public void setLineSeparator(final String lineSeparatorParam) {\n-        this.lineSeparator = Enum.valueOf(LineSeparatorOption.class, lineSeparatorParam.trim().toUpperCase(Locale.ENGLISH));\n+    public void setLineSeparator(final String s) {\n+        this.lineSeparator = Enum.valueOf(LineSeparatorOption.class, s.trim().toUpperCase(Locale.ENGLISH));\n     }\n     \n     private void readAndCheckFile(final File file) throws IOException {\n         try (final RandomAccessFile randomAccessFile = new RandomAccessFile(file, \"r\")) {\n             if (this.lineSeparator == LineSeparatorOption.LF && endsWithNewline(randomAccessFile, LineSeparatorOption.CRLF)) {\n                 this.log(1, \"wrong.line.end\", new Object[0]);\n             }\n             else if (!endsWithNewline(randomAccessFile, this.lineSeparator)) {\n                 this.log(1, \"noNewlineAtEOF\", new Object[0]);\n             }\n         }\n     }\n     \n-    private static boolean endsWithNewline(final RandomAccessFile file, final LineSeparatorOption separator) throws IOException {\n-        final int len = separator.length();\n-        boolean result;\n-        if (file.length() < len) {\n-            result = false;\n+    private static boolean endsWithNewline(final RandomAccessFile randomAccessFile, final LineSeparatorOption lineSeparatorOption) throws IOException {\n+        final int length = lineSeparatorOption.length();\n+        boolean matches;\n+        if (randomAccessFile.length() < length) {\n+            matches = false;\n         }\n         else {\n-            file.seek(file.length() - (long)len);\n-            final byte[] lastBytes = new byte[len];\n-            final int readBytes = file.read(lastBytes);\n-            if (readBytes != len) {\n-                throw new IOException(\"Unable to read \" + len + \" bytes, got \" + readBytes);\n+            randomAccessFile.seek(randomAccessFile.length() - (long)length);\n+            final byte[] b = new byte[length];\n+            final int read = randomAccessFile.read(b);\n+            if (read != length) {\n+                throw new IOException(\"Unable to read \" + length + \" bytes, got \" + read);\n             }\n-            result = separator.matches(lastBytes);\n+            matches = lineSeparatorOption.matches(b);\n         }\n-        return result;\n+        return matches;\n     }\n }\n"}]}
