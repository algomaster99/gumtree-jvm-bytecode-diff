{"diffoscope-json-version": 1, "source1": "first/UnsynchronizedBufferedInputStream.class", "source2": "second/UnsynchronizedBufferedInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -8,205 +8,205 @@\n {\n     protected volatile byte[] buffer;\n     protected int count;\n     protected int markLimit;\n     protected int markPos;\n     protected int pos;\n     \n-    private UnsynchronizedBufferedInputStream(final InputStream in, final int size) {\n-        super(in);\n+    private UnsynchronizedBufferedInputStream(final InputStream inputStream, final int n) {\n+        super(inputStream);\n         this.markPos = -1;\n-        if (size <= 0) {\n+        if (n <= 0) {\n             throw new IllegalArgumentException(\"Size must be > 0\");\n         }\n-        this.buffer = new byte[size];\n+        this.buffer = new byte[n];\n     }\n     \n     public int available() throws IOException {\n-        final InputStream localIn = this.inputStream;\n-        if (this.buffer == null || localIn == null) {\n+        final InputStream inputStream = this.inputStream;\n+        if (this.buffer == null || inputStream == null) {\n             throw new IOException(\"Stream is closed\");\n         }\n-        return this.count - this.pos + localIn.available();\n+        return this.count - this.pos + inputStream.available();\n     }\n     \n     public void close() throws IOException {\n         this.buffer = null;\n-        final InputStream localIn = this.inputStream;\n+        final InputStream inputStream = this.inputStream;\n         this.inputStream = null;\n-        if (localIn != null) {\n-            localIn.close();\n+        if (inputStream != null) {\n+            inputStream.close();\n         }\n     }\n     \n-    private int fillBuffer(final InputStream localIn, byte[] localBuf) throws IOException {\n+    private int fillBuffer(final InputStream inputStream, byte[] array) throws IOException {\n         if (this.markPos == -1 || this.pos - this.markPos >= this.markLimit) {\n-            final int result = localIn.read(localBuf);\n-            if (result > 0) {\n+            final int read = inputStream.read(array);\n+            if (read > 0) {\n                 this.markPos = -1;\n                 this.pos = 0;\n-                this.count = result;\n+                this.count = read;\n             }\n-            return result;\n+            return read;\n         }\n-        if (this.markPos == 0 && this.markLimit > localBuf.length) {\n-            int newLength = localBuf.length * 2;\n-            if (newLength > this.markLimit) {\n-                newLength = this.markLimit;\n-            }\n-            final byte[] newbuf = new byte[newLength];\n-            System.arraycopy(localBuf, 0, newbuf, 0, localBuf.length);\n-            final byte[] buffer = newbuf;\n+        if (this.markPos == 0 && this.markLimit > array.length) {\n+            int markLimit = array.length * 2;\n+            if (markLimit > this.markLimit) {\n+                markLimit = this.markLimit;\n+            }\n+            final byte[] array2 = new byte[markLimit];\n+            System.arraycopy(array, 0, array2, 0, array.length);\n+            final byte[] buffer = array2;\n             this.buffer = buffer;\n-            localBuf = buffer;\n+            array = buffer;\n         }\n         else if (this.markPos > 0) {\n-            System.arraycopy(localBuf, this.markPos, localBuf, 0, localBuf.length - this.markPos);\n+            System.arraycopy(array, this.markPos, array, 0, array.length - this.markPos);\n         }\n         this.pos -= this.markPos;\n         final int n = 0;\n         this.markPos = n;\n         this.count = n;\n-        final int bytesread = localIn.read(localBuf, this.pos, localBuf.length - this.pos);\n-        this.count = ((bytesread <= 0) ? this.pos : (this.pos + bytesread));\n-        return bytesread;\n+        final int read2 = inputStream.read(array, this.pos, array.length - this.pos);\n+        this.count = ((read2 <= 0) ? this.pos : (this.pos + read2));\n+        return read2;\n     }\n     \n     byte[] getBuffer() {\n         return this.buffer;\n     }\n     \n-    public void mark(final int readlimit) {\n-        this.markLimit = readlimit;\n+    public void mark(final int markLimit) {\n+        this.markLimit = markLimit;\n         this.markPos = this.pos;\n     }\n     \n     public boolean markSupported() {\n         return true;\n     }\n     \n     public int read() throws IOException {\n-        byte[] localBuf = this.buffer;\n-        final InputStream localIn = this.inputStream;\n-        if (localBuf == null || localIn == null) {\n+        byte[] array = this.buffer;\n+        final InputStream inputStream = this.inputStream;\n+        if (array == null || inputStream == null) {\n             throw new IOException(\"Stream is closed\");\n         }\n-        if (this.pos >= this.count && this.fillBuffer(localIn, localBuf) == -1) {\n+        if (this.pos >= this.count && this.fillBuffer(inputStream, array) == -1) {\n             return -1;\n         }\n-        if (localBuf != this.buffer) {\n-            localBuf = this.buffer;\n-            if (localBuf == null) {\n+        if (array != this.buffer) {\n+            array = this.buffer;\n+            if (array == null) {\n                 throw new IOException(\"Stream is closed\");\n             }\n         }\n         if (this.count - this.pos > 0) {\n-            return localBuf[this.pos++] & 0xFF;\n+            return array[this.pos++] & 0xFF;\n         }\n         return -1;\n     }\n     \n-    public int read(final byte[] buffer, int offset, final int length) throws IOException {\n-        byte[] localBuf = buffer;\n-        if (localBuf == null) {\n+    public int read(final byte[] b, int off, final int n) throws IOException {\n+        byte[] array = b;\n+        if (array == null) {\n             throw new IOException(\"Stream is closed\");\n         }\n-        if (offset > buffer.length - length || offset < 0 || length < 0) {\n+        if (off > b.length - n || off < 0 || n < 0) {\n             throw new IndexOutOfBoundsException();\n         }\n-        if (length == 0) {\n+        if (n == 0) {\n             return 0;\n         }\n-        final InputStream localIn = this.inputStream;\n-        if (localIn == null) {\n+        final InputStream inputStream = this.inputStream;\n+        if (inputStream == null) {\n             throw new IOException(\"Stream is closed\");\n         }\n-        int required;\n+        int len;\n         if (this.pos < this.count) {\n-            final int copylength = (this.count - this.pos >= length) ? length : (this.count - this.pos);\n-            System.arraycopy(localBuf, this.pos, buffer, offset, copylength);\n-            this.pos += copylength;\n-            if (copylength == length || localIn.available() == 0) {\n-                return copylength;\n+            final int n2 = (this.count - this.pos >= n) ? n : (this.count - this.pos);\n+            System.arraycopy(array, this.pos, b, off, n2);\n+            this.pos += n2;\n+            if (n2 == n || inputStream.available() == 0) {\n+                return n2;\n             }\n-            offset += copylength;\n-            required = length - copylength;\n+            off += n2;\n+            len = n - n2;\n         }\n         else {\n-            required = length;\n+            len = n;\n         }\n         while (true) {\n             int read;\n-            if (this.markPos == -1 && required >= localBuf.length) {\n-                read = localIn.read(buffer, offset, required);\n+            if (this.markPos == -1 && len >= array.length) {\n+                read = inputStream.read(b, off, len);\n                 if (read == -1) {\n-                    return (required == length) ? -1 : (length - required);\n+                    return (len == n) ? -1 : (n - len);\n                 }\n             }\n             else {\n-                if (this.fillBuffer(localIn, localBuf) == -1) {\n-                    return (required == length) ? -1 : (length - required);\n+                if (this.fillBuffer(inputStream, array) == -1) {\n+                    return (len == n) ? -1 : (n - len);\n                 }\n-                if (localBuf != buffer) {\n-                    localBuf = buffer;\n-                    if (localBuf == null) {\n+                if (array != b) {\n+                    array = b;\n+                    if (array == null) {\n                         throw new IOException(\"Stream is closed\");\n                     }\n                 }\n-                read = ((this.count - this.pos >= required) ? required : (this.count - this.pos));\n-                System.arraycopy(localBuf, this.pos, buffer, offset, read);\n+                read = ((this.count - this.pos >= len) ? len : (this.count - this.pos));\n+                System.arraycopy(array, this.pos, b, off, read);\n                 this.pos += read;\n             }\n-            required -= read;\n-            if (required == 0) {\n-                return length;\n+            len -= read;\n+            if (len == 0) {\n+                return n;\n             }\n-            if (localIn.available() == 0) {\n-                return length - required;\n+            if (inputStream.available() == 0) {\n+                return n - len;\n             }\n-            offset += read;\n+            off += read;\n         }\n     }\n     \n     public void reset() throws IOException {\n         if (this.buffer == null) {\n             throw new IOException(\"Stream is closed\");\n         }\n         if (-1 == this.markPos) {\n             throw new IOException(\"Mark has been invalidated\");\n         }\n         this.pos = this.markPos;\n     }\n     \n-    public long skip(final long amount) throws IOException {\n-        final byte[] localBuf = this.buffer;\n-        final InputStream localIn = this.inputStream;\n-        if (localBuf == null) {\n+    public long skip(final long n) throws IOException {\n+        final byte[] buffer = this.buffer;\n+        final InputStream inputStream = this.inputStream;\n+        if (buffer == null) {\n             throw new IOException(\"Stream is closed\");\n         }\n-        if (amount < 1L) {\n+        if (n < 1L) {\n             return 0L;\n         }\n-        if (localIn == null) {\n+        if (inputStream == null) {\n             throw new IOException(\"Stream is closed\");\n         }\n-        if (this.count - this.pos >= amount) {\n-            this.pos += amount;\n-            return amount;\n+        if (this.count - this.pos >= n) {\n+            this.pos += n;\n+            return n;\n         }\n-        long read = (long)(this.count - this.pos);\n+        final long n2 = (long)(this.count - this.pos);\n         this.pos = this.count;\n-        if (this.markPos == -1 || amount > this.markLimit) {\n-            return read + localIn.skip(amount - read);\n+        if (this.markPos == -1 || n > this.markLimit) {\n+            return n2 + inputStream.skip(n - n2);\n         }\n-        if (this.fillBuffer(localIn, localBuf) == -1) {\n-            return read;\n+        if (this.fillBuffer(inputStream, buffer) == -1) {\n+            return n2;\n         }\n-        if (this.count - this.pos >= amount - read) {\n-            this.pos += amount - read;\n-            return amount;\n+        if (this.count - this.pos >= n - n2) {\n+            this.pos += n - n2;\n+            return n;\n         }\n-        read += this.count - this.pos;\n+        final long n3 = n2 + (this.count - this.pos);\n         this.pos = this.count;\n-        return read;\n+        return n3;\n     }\n }\n"}]}
