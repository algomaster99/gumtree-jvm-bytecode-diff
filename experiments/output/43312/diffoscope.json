{"diffoscope-json-version": 1, "source1": "first/DefaultBeanFactory.class", "source2": "second/DefaultBeanFactory.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -14,14 +14,18 @@\n \n public class DefaultBeanFactory implements BeanFactory\n {\n     public static final DefaultBeanFactory INSTANCE;\n     private static final String FMT_CTOR_ERROR = \"%s! Bean class = %s, constructor arguments = %s\";\n     private final ConversionHandler conversionHandler;\n     \n+    static {\n+        INSTANCE = new DefaultBeanFactory();\n+    }\n+    \n     public DefaultBeanFactory() {\n         this(null);\n     }\n     \n     public DefaultBeanFactory(final ConversionHandler convHandler) {\n         this.conversionHandler = (ConversionHandler)((convHandler != null) ? convHandler : DefaultConversionHandler.INSTANCE);\n     }\n@@ -53,21 +57,21 @@\n     protected static <T> Constructor<T> findMatchingConstructor(final Class<T> beanClass, final BeanDeclaration data) {\n         final List<Constructor<T>> matchingConstructors = findMatchingConstructors(beanClass, data);\n         checkSingleMatchingConstructor(beanClass, data, matchingConstructors);\n         return matchingConstructors.get(0);\n     }\n     \n     private Object[] fetchConstructorArgs(final Constructor<?> ctor, final BeanCreationContext bcc) {\n-        final Class<?>[] types = ctor.getParameterTypes();\n+        final Class[] types = ctor.getParameterTypes();\n         assert types.length == nullSafeConstructorArgs(bcc.getBeanDeclaration()).size() : \"Wrong number of constructor arguments!\";\n         final Object[] args = new Object[types.length];\n         int idx = 0;\n         for (final ConstructorArg arg : nullSafeConstructorArgs(bcc.getBeanDeclaration())) {\n             final Object val = arg.isNestedBeanDeclaration() ? bcc.createBean(arg.getBeanDeclaration()) : arg.getValue();\n-            args[idx] = this.getConversionHandler().to(val, (Class)types[idx], (ConfigurationInterpolator)null);\n+            args[idx] = this.getConversionHandler().to(val, types[idx], (ConfigurationInterpolator)null);\n             ++idx;\n         }\n         return args;\n     }\n     \n     private static Collection<ConstructorArg> nullSafeConstructorArgs(final BeanDeclaration data) {\n         Collection<ConstructorArg> args = data.getConstructorArgs();\n@@ -76,31 +80,33 @@\n         }\n         return args;\n     }\n     \n     private static <T> List<Constructor<T>> findMatchingConstructors(final Class<T> beanClass, final BeanDeclaration data) {\n         final List<Constructor<T>> result = new LinkedList<Constructor<T>>();\n         final Collection<ConstructorArg> args = getConstructorArgs(data);\n-        for (final Constructor<?> ctor : beanClass.getConstructors()) {\n+        Constructor<?>[] constructors;\n+        for (int length = (constructors = beanClass.getConstructors()).length, i = 0; i < length; ++i) {\n+            final Constructor<?> ctor = constructors[i];\n             if (matchesConstructor(ctor, args)) {\n                 final Constructor<T> match = (Constructor<T>)ctor;\n                 result.add(match);\n             }\n         }\n         return result;\n     }\n     \n     private static boolean matchesConstructor(final Constructor<?> ctor, final Collection<ConstructorArg> args) {\n-        final Class<?>[] types = ctor.getParameterTypes();\n+        final Class[] types = ctor.getParameterTypes();\n         if (types.length != args.size()) {\n             return false;\n         }\n         int idx = 0;\n         for (final ConstructorArg arg : args) {\n-            if (!arg.matches((Class)types[idx++])) {\n+            if (!arg.matches(types[idx++])) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n     private static Collection<ConstructorArg> getConstructorArgs(final BeanDeclaration data) {\n@@ -119,12 +125,8 @@\n             throw constructorMatchingException(beanClass, data, \"Multiple matching constructors found\");\n         }\n     }\n     \n     private static ConfigurationRuntimeException constructorMatchingException(final Class<?> beanClass, final BeanDeclaration data, final String msg) {\n         return new ConfigurationRuntimeException(\"%s! Bean class = %s, constructor arguments = %s\", new Object[] { msg, beanClass.getName(), getConstructorArgs(data).toString() });\n     }\n-    \n-    static {\n-        INSTANCE = new DefaultBeanFactory();\n-    }\n }\n"}]}
