{"diffoscope-json-version": 1, "source1": "first/PathUtils.class", "source2": "second/PathUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -30,196 +30,195 @@\n \n public final class PathUtils\n {\n     public static final FileVisitOption[] EMPTY_FILE_VISIT_OPTION_ARRAY;\n     public static final LinkOption[] EMPTY_LINK_OPTION_ARRAY;\n     public static final OpenOption[] EMPTY_OPEN_OPTION_ARRAY;\n     \n-    private static AccumulatorPathVisitor accumulate(final Path directory, final int maxDepth, final LinkOption[] linkOptions, final FileVisitOption[] fileVisitOptions) throws IOException {\n-        return visitFileTree(AccumulatorPathVisitor.withLongCounters(), directory, toFileVisitOptionSet(fileVisitOptions), maxDepth);\n+    private static AccumulatorPathVisitor accumulate(final Path path, final int n, final LinkOption[] array, final FileVisitOption[] array2) throws IOException {\n+        return visitFileTree(AccumulatorPathVisitor.withLongCounters(), path, toFileVisitOptionSet(array2), n);\n     }\n     \n-    public static Counters.PathCounters cleanDirectory(final Path directory) throws IOException {\n-        return ((CountingPathVisitor)visitFileTree(CleaningPathVisitor.withLongCounters(), directory)).getPathCounters();\n+    public static Counters.PathCounters cleanDirectory(final Path path) throws IOException {\n+        return ((CountingPathVisitor)visitFileTree(CleaningPathVisitor.withLongCounters(), path)).getPathCounters();\n     }\n     \n-    public static Counters.PathCounters copyDirectory(final Path sourceDirectory, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n-        return ((CopyDirectoryVisitor)visitFileTree(new CopyDirectoryVisitor(Counters.longPathCounters(), sourceDirectory, targetDirectory, copyOptions), sourceDirectory)).getPathCounters();\n+    public static Counters.PathCounters copyDirectory(final Path path, final Path path2, final CopyOption... array) throws IOException {\n+        return ((CopyDirectoryVisitor)visitFileTree(new CopyDirectoryVisitor(Counters.longPathCounters(), path, path2, array), path)).getPathCounters();\n     }\n     \n-    public static Path copyFile(final URL sourceFile, final Path targetFile, final CopyOption... copyOptions) throws IOException {\n-        try (final InputStream inputStream = sourceFile.openStream()) {\n-            Files.copy(inputStream, targetFile, copyOptions);\n-            return targetFile;\n+    public static Path copyFile(final URL url, final Path target, final CopyOption... options) throws IOException {\n+        try (final InputStream openStream = url.openStream()) {\n+            Files.copy(openStream, target, options);\n+            return target;\n         }\n     }\n     \n-    public static Path copyFileToDirectory(final Path sourceFile, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n-        return Files.copy(sourceFile, targetDirectory.resolve(sourceFile.getFileName()), copyOptions);\n+    public static Path copyFileToDirectory(final Path source, final Path path, final CopyOption... options) throws IOException {\n+        return Files.copy(source, path.resolve(source.getFileName()), options);\n     }\n     \n-    public static Path copyFileToDirectory(final URL sourceFile, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n-        try (final InputStream inputStream = sourceFile.openStream()) {\n-            Files.copy(inputStream, targetDirectory.resolve(sourceFile.getFile()), copyOptions);\n-            return targetDirectory;\n+    public static Path copyFileToDirectory(final URL url, final Path path, final CopyOption... options) throws IOException {\n+        try (final InputStream openStream = url.openStream()) {\n+            Files.copy(openStream, path.resolve(url.getFile()), options);\n+            return path;\n         }\n     }\n     \n-    public static Counters.PathCounters countDirectory(final Path directory) throws IOException {\n-        return ((CountingPathVisitor)visitFileTree(new CountingPathVisitor(Counters.longPathCounters()), directory)).getPathCounters();\n+    public static Counters.PathCounters countDirectory(final Path path) throws IOException {\n+        return ((CountingPathVisitor)visitFileTree(new CountingPathVisitor(Counters.longPathCounters()), path)).getPathCounters();\n     }\n     \n     public static Counters.PathCounters delete(final Path path) throws IOException {\n         return Files.isDirectory(path, new LinkOption[0]) ? deleteDirectory(path) : deleteFile(path);\n     }\n     \n-    public static Counters.PathCounters deleteDirectory(final Path directory) throws IOException {\n-        return ((DeletingPathVisitor)visitFileTree(DeletingPathVisitor.withLongCounters(), directory)).getPathCounters();\n+    public static Counters.PathCounters deleteDirectory(final Path path) throws IOException {\n+        return ((DeletingPathVisitor)visitFileTree(DeletingPathVisitor.withLongCounters(), path)).getPathCounters();\n     }\n     \n-    public static Counters.PathCounters deleteFile(final Path file) throws IOException {\n-        if (Files.isDirectory(file, new LinkOption[0])) {\n-            throw new NotDirectoryException(file.toString());\n+    public static Counters.PathCounters deleteFile(final Path path) throws IOException {\n+        if (Files.isDirectory(path, new LinkOption[0])) {\n+            throw new NotDirectoryException(path.toString());\n         }\n-        final Counters.PathCounters pathCounts = Counters.longPathCounters();\n-        final long size = Files.exists(file, new LinkOption[0]) ? Files.size(file) : 0L;\n-        if (Files.deleteIfExists(file)) {\n-            pathCounts.getFileCounter().increment();\n-            pathCounts.getByteCounter().add(size);\n+        final Counters.PathCounters longPathCounters = Counters.longPathCounters();\n+        final long n = Files.exists(path, new LinkOption[0]) ? Files.size(path) : 0L;\n+        if (Files.deleteIfExists(path)) {\n+            longPathCounters.getFileCounter().increment();\n+            longPathCounters.getByteCounter().add(n);\n         }\n-        return pathCounts;\n+        return longPathCounters;\n     }\n     \n-    public static boolean directoryAndFileContentEquals(final Path path1, final Path path2) throws IOException {\n-        return directoryAndFileContentEquals(path1, path2, PathUtils.EMPTY_LINK_OPTION_ARRAY, PathUtils.EMPTY_OPEN_OPTION_ARRAY, PathUtils.EMPTY_FILE_VISIT_OPTION_ARRAY);\n+    public static boolean directoryAndFileContentEquals(final Path path, final Path path2) throws IOException {\n+        return directoryAndFileContentEquals(path, path2, PathUtils.EMPTY_LINK_OPTION_ARRAY, PathUtils.EMPTY_OPEN_OPTION_ARRAY, PathUtils.EMPTY_FILE_VISIT_OPTION_ARRAY);\n     }\n     \n-    public static boolean directoryAndFileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions, final FileVisitOption[] fileVisitOption) throws IOException {\n-        if (path1 == null && path2 == null) {\n+    public static boolean directoryAndFileContentEquals(final Path path, final Path path2, final LinkOption[] array, final OpenOption[] array2, final FileVisitOption[] array3) throws IOException {\n+        if (path == null && path2 == null) {\n             return true;\n         }\n-        if (path1 == null ^ path2 == null) {\n+        if (path == null ^ path2 == null) {\n             return false;\n         }\n-        if (!Files.exists(path1, new LinkOption[0]) && !Files.exists(path2, new LinkOption[0])) {\n+        if (!Files.exists(path, new LinkOption[0]) && !Files.exists(path2, new LinkOption[0])) {\n             return true;\n         }\n-        final PathUtils.RelativeSortedPaths relativeSortedPaths = new PathUtils.RelativeSortedPaths(path1, path2, Integer.MAX_VALUE, linkOptions, fileVisitOption, (PathUtils.PathUtils$1)null);\n+        final PathUtils.RelativeSortedPaths relativeSortedPaths = new PathUtils.RelativeSortedPaths(path, path2, Integer.MAX_VALUE, array, array3, (PathUtils.PathUtils$1)null);\n         if (!relativeSortedPaths.equals) {\n             return false;\n         }\n-        final List<Path> fileList1 = relativeSortedPaths.relativeFileList1;\n-        final List<Path> fileList2 = relativeSortedPaths.relativeFileList2;\n-        for (final Path path3 : fileList1) {\n-            final int binarySearch = Collections.binarySearch(fileList2, path3);\n-            if (binarySearch <= -1) {\n+        final List relativeFileList1 = relativeSortedPaths.relativeFileList1;\n+        final List relativeFileList2 = relativeSortedPaths.relativeFileList2;\n+        for (final Path key : relativeFileList1) {\n+            if (Collections.binarySearch(relativeFileList2, key) <= -1) {\n                 throw new IllegalStateException(String.format(\"Unexpected mismatch.\", new Object[0]));\n             }\n-            if (!fileContentEquals(path1.resolve(path3), path2.resolve(path3), linkOptions, openOptions)) {\n+            if (!fileContentEquals(path.resolve(key), path2.resolve(key), array, array2)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    public static boolean directoryContentEquals(final Path path1, final Path path2) throws IOException {\n-        return directoryContentEquals(path1, path2, Integer.MAX_VALUE, PathUtils.EMPTY_LINK_OPTION_ARRAY, PathUtils.EMPTY_FILE_VISIT_OPTION_ARRAY);\n+    public static boolean directoryContentEquals(final Path path, final Path path2) throws IOException {\n+        return directoryContentEquals(path, path2, Integer.MAX_VALUE, PathUtils.EMPTY_LINK_OPTION_ARRAY, PathUtils.EMPTY_FILE_VISIT_OPTION_ARRAY);\n     }\n     \n-    public static boolean directoryContentEquals(final Path path1, final Path path2, final int maxDepth, final LinkOption[] linkOptions, final FileVisitOption[] fileVisitOptions) throws IOException {\n-        return new PathUtils.RelativeSortedPaths(path1, path2, maxDepth, linkOptions, fileVisitOptions, (PathUtils.PathUtils$1)null).equals;\n+    public static boolean directoryContentEquals(final Path path, final Path path2, final int n, final LinkOption[] array, final FileVisitOption[] array2) throws IOException {\n+        return new PathUtils.RelativeSortedPaths(path, path2, n, array, array2, (PathUtils.PathUtils$1)null).equals;\n     }\n     \n-    public static boolean fileContentEquals(final Path path1, final Path path2) throws IOException {\n-        return fileContentEquals(path1, path2, PathUtils.EMPTY_LINK_OPTION_ARRAY, PathUtils.EMPTY_OPEN_OPTION_ARRAY);\n+    public static boolean fileContentEquals(final Path path, final Path path2) throws IOException {\n+        return fileContentEquals(path, path2, PathUtils.EMPTY_LINK_OPTION_ARRAY, PathUtils.EMPTY_OPEN_OPTION_ARRAY);\n     }\n     \n-    public static boolean fileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions) throws IOException {\n-        if (path1 == null && path2 == null) {\n+    public static boolean fileContentEquals(final Path path, final Path path2, final LinkOption[] array, final OpenOption[] array2) throws IOException {\n+        if (path == null && path2 == null) {\n             return true;\n         }\n-        if (path1 == null ^ path2 == null) {\n+        if (path == null ^ path2 == null) {\n             return false;\n         }\n-        final Path nPath1 = path1.normalize();\n-        final Path nPath2 = path2.normalize();\n-        final boolean path1Exists = Files.exists(nPath1, linkOptions);\n-        if (path1Exists != Files.exists(nPath2, linkOptions)) {\n+        final Path normalize = path.normalize();\n+        final Path normalize2 = path2.normalize();\n+        final boolean exists = Files.exists(normalize, array);\n+        if (exists != Files.exists(normalize2, array)) {\n             return false;\n         }\n-        if (!path1Exists) {\n+        if (!exists) {\n             return true;\n         }\n-        if (Files.isDirectory(nPath1, linkOptions)) {\n-            throw new IOException(\"Can't compare directories, only files: \" + nPath1);\n+        if (Files.isDirectory(normalize, array)) {\n+            throw new IOException(\"Can't compare directories, only files: \" + normalize);\n         }\n-        if (Files.isDirectory(nPath2, linkOptions)) {\n-            throw new IOException(\"Can't compare directories, only files: \" + nPath2);\n+        if (Files.isDirectory(normalize2, array)) {\n+            throw new IOException(\"Can't compare directories, only files: \" + normalize2);\n         }\n-        if (Files.size(nPath1) != Files.size(nPath2)) {\n+        if (Files.size(normalize) != Files.size(normalize2)) {\n             return false;\n         }\n-        if (path1.equals(path2)) {\n+        if (path.equals(path2)) {\n             return true;\n         }\n-        try (final InputStream inputStream1 = Files.newInputStream(nPath1, openOptions);\n-             final InputStream inputStream2 = Files.newInputStream(nPath2, openOptions)) {\n-            return IOUtils.contentEquals(inputStream1, inputStream2);\n+        try (final InputStream inputStream = Files.newInputStream(normalize, array2);\n+             final InputStream inputStream2 = Files.newInputStream(normalize2, array2)) {\n+            return IOUtils.contentEquals(inputStream, inputStream2);\n         }\n     }\n     \n     public static boolean isEmpty(final Path path) throws IOException {\n         return Files.isDirectory(path, new LinkOption[0]) ? isEmptyDirectory(path) : isEmptyFile(path);\n     }\n     \n-    public static boolean isEmptyDirectory(final Path directory) throws IOException {\n-        try (final DirectoryStream<Path> directoryStream = Files.newDirectoryStream(directory)) {\n+    public static boolean isEmptyDirectory(final Path dir) throws IOException {\n+        try (final DirectoryStream<Path> directoryStream = Files.newDirectoryStream(dir)) {\n             if (directoryStream.iterator().hasNext()) {\n                 final boolean b = false;\n                 if (directoryStream != null) {\n                     directoryStream.close();\n                 }\n                 return b;\n             }\n         }\n         return true;\n     }\n     \n-    public static boolean isEmptyFile(final Path file) throws IOException {\n-        return Files.size(file) <= 0L;\n+    public static boolean isEmptyFile(final Path path) throws IOException {\n+        return Files.size(path) <= 0L;\n     }\n     \n-    static List<Path> relativize(final Collection<Path> collection, final Path parent, final boolean sort, final Comparator<? super Path> comparator) {\n-        Stream<Path> stream = collection.stream().map(e -> parent.relativize(e));\n-        if (sort) {\n-            stream = ((comparator == null) ? stream.sorted() : stream.sorted(comparator));\n+    static List<Path> relativize(final Collection<Path> collection, final Path path, final boolean b, final Comparator<? super Path> comparator) {\n+        Stream<Object> map = collection.stream().map(path3 -> path2.relativize(path3));\n+        if (b) {\n+            map = ((comparator == null) ? map.sorted() : map.sorted((Comparator<? super Object>)comparator));\n         }\n-        return stream.collect((Collector<? super Path, ?, List<Path>>)Collectors.toList());\n+        return map.collect((Collector<? super Object, ?, List<Path>>)Collectors.toList());\n     }\n     \n-    static Set<FileVisitOption> toFileVisitOptionSet(final FileVisitOption... fileVisitOptions) {\n-        return (Set<FileVisitOption>)((fileVisitOptions == null) ? EnumSet.noneOf(FileVisitOption.class) : ((Set<? super FileVisitOption>)Arrays.stream(fileVisitOptions).collect((Collector<? super FileVisitOption, ?, Set<? super FileVisitOption>>)Collectors.toSet())));\n+    static Set<FileVisitOption> toFileVisitOptionSet(final FileVisitOption... array) {\n+        return (Set<FileVisitOption>)((array == null) ? EnumSet.noneOf(FileVisitOption.class) : ((Set<? super FileVisitOption>)Arrays.stream(array).collect((Collector<? super FileVisitOption, ?, Set<? super FileVisitOption>>)Collectors.toSet())));\n     }\n     \n-    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final Path directory) throws IOException {\n-        Files.walkFileTree(directory, visitor);\n+    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final Path start) throws IOException {\n+        Files.walkFileTree(start, visitor);\n         return visitor;\n     }\n     \n     public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final Path start, final Set<FileVisitOption> options, final int maxDepth) throws IOException {\n         Files.walkFileTree(start, options, maxDepth, visitor);\n         return visitor;\n     }\n     \n-    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final String first, final String... more) throws IOException {\n-        return visitFileTree(visitor, Paths.get(first, more));\n+    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T t, final String first, final String... more) throws IOException {\n+        return visitFileTree(t, Paths.get(first, more));\n     }\n     \n-    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final URI uri) throws IOException {\n-        return visitFileTree(visitor, Paths.get(uri));\n+    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T t, final URI uri) throws IOException {\n+        return visitFileTree(t, Paths.get(uri));\n     }\n     \n     private PathUtils() {\n     }\n     \n     static {\n         EMPTY_FILE_VISIT_OPTION_ARRAY = new FileVisitOption[0];\n"}]}
