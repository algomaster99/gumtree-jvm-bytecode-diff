{"diffoscope-json-version": 1, "source1": "first/CSVRecord.class", "source2": "second/CSVRecord.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -15,44 +15,44 @@\n     private static final long serialVersionUID = 1L;\n     private final long characterPosition;\n     private final String comment;\n     private final long recordNumber;\n     private final String[] values;\n     private final transient CSVParser parser;\n     \n-    CSVRecord(final CSVParser parser, final String[] values, final String comment, final long recordNumber, final long characterPosition) {\n+    CSVRecord(final CSVParser parser, final String[] array, final String comment, final long recordNumber, final long characterPosition) {\n         this.recordNumber = recordNumber;\n-        this.values = ((values != null) ? values : Constants.EMPTY_STRING_ARRAY);\n+        this.values = ((array != null) ? array : Constants.EMPTY_STRING_ARRAY);\n         this.parser = parser;\n         this.comment = comment;\n         this.characterPosition = characterPosition;\n     }\n     \n-    public String get(final Enum<?> e) {\n-        return this.get(Objects.toString((Object)e, (String)null));\n+    public String get(final Enum<?> o) {\n+        return this.get(Objects.toString((Object)o, (String)null));\n     }\n     \n-    public String get(final int i) {\n-        return this.values[i];\n+    public String get(final int n) {\n+        return this.values[n];\n     }\n     \n-    public String get(final String name) {\n-        final Map<String, Integer> headerMap = this.getHeaderMapRaw();\n-        if (headerMap == null) {\n+    public String get(final String s) {\n+        final Map<String, Integer> headerMapRaw = this.getHeaderMapRaw();\n+        if (headerMapRaw == null) {\n             throw new IllegalStateException(\"No header mapping was specified, the record values can't be accessed by name\");\n         }\n-        final Integer index = Integer.valueOf(headerMap.get((Object)name));\n-        if (index == null) {\n-            throw new IllegalArgumentException(String.format(\"Mapping for %s not found, expected one of %s\", name, headerMap.keySet()));\n+        final Integer n = Integer.valueOf(headerMapRaw.get((Object)s));\n+        if (n == null) {\n+            throw new IllegalArgumentException(String.format(\"Mapping for %s not found, expected one of %s\", s, headerMapRaw.keySet()));\n         }\n         try {\n-            return this.values[(int)index];\n+            return this.values[(int)n];\n         }\n-        catch (final ArrayIndexOutOfBoundsException e) {\n-            throw new IllegalArgumentException(String.format(\"Index for header '%s' is %d but CSVRecord only has %d values!\", name, index, Integer.valueOf(this.values.length)));\n+        catch (final ArrayIndexOutOfBoundsException ex) {\n+            throw new IllegalArgumentException(String.format(\"Index for header '%s' is %d but CSVRecord only has %d values!\", s, n, Integer.valueOf(this.values.length)));\n         }\n     }\n     \n     public long getCharacterPosition() {\n         return this.characterPosition;\n     }\n     \n@@ -73,48 +73,49 @@\n     }\n     \n     public boolean hasComment() {\n         return this.comment != null;\n     }\n     \n     public boolean isConsistent() {\n-        final Map<String, Integer> headerMap = this.getHeaderMapRaw();\n-        return headerMap == null || headerMap.size() == this.values.length;\n+        final Map<String, Integer> headerMapRaw = this.getHeaderMapRaw();\n+        return headerMapRaw == null || headerMapRaw.size() == this.values.length;\n     }\n     \n-    public boolean isMapped(final String name) {\n-        final Map<String, Integer> headerMap = this.getHeaderMapRaw();\n-        return headerMap != null && headerMap.containsKey(name);\n+    public boolean isMapped(final String s) {\n+        final Map<String, Integer> headerMapRaw = this.getHeaderMapRaw();\n+        return headerMapRaw != null && headerMapRaw.containsKey(s);\n     }\n     \n-    public boolean isSet(final int index) {\n-        return 0 <= index && index < this.values.length;\n+    public boolean isSet(final int n) {\n+        return 0 <= n && n < this.values.length;\n     }\n     \n-    public boolean isSet(final String name) {\n-        return this.isMapped(name) && Integer.valueOf(this.getHeaderMapRaw().get((Object)name)) < this.values.length;\n+    public boolean isSet(final String s) {\n+        return this.isMapped(s) && Integer.valueOf(this.getHeaderMapRaw().get((Object)s)) < this.values.length;\n     }\n     \n     @Override\n     public Iterator<String> iterator() {\n         return this.toList().iterator();\n     }\n     \n-    public <M extends Map<String, String>> M putIn(final M map) {\n+    public <M extends Map<String, String>> M putIn(final M m) {\n         if (this.getHeaderMapRaw() == null) {\n-            return map;\n+            return m;\n         }\n         this.getHeaderMapRaw().entrySet().forEach(entry -> {\n-            final int col = (int)Integer.valueOf(entry.getValue());\n-            if (col < this.values.length) {\n-                map.put(entry.getKey(), this.values[col]);\n+            Integer.valueOf(entry.getValue()).intValue();\n+            final int n;\n+            if (n < this.values.length) {\n+                map.put(entry.getKey(), this.values[n]);\n             }\n             return;\n         });\n-        return map;\n+        return m;\n     }\n     \n     public int size() {\n         return this.values.length;\n     }\n     \n     public Stream<String> stream() {\n"}]}
