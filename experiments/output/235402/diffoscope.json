{"diffoscope-json-version": 1, "source1": "first/IOStream.class", "source2": "second/IOStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,17 +1,17 @@\n \n package org.apache.commons.io.function;\n \n import java.util.function.IntFunction;\n import java.util.function.ToLongFunction;\n import java.util.function.ToIntFunction;\n import java.util.function.ToDoubleFunction;\n+import java.util.List;\n import java.util.ArrayList;\n import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.List;\n import java.util.concurrent.atomic.AtomicReference;\n import java.util.function.BiFunction;\n import org.apache.commons.io.IOExceptionList;\n import java.util.stream.LongStream;\n import java.util.stream.IntStream;\n import java.util.stream.DoubleStream;\n import java.util.stream.BaseStream;\n@@ -32,180 +32,179 @@\n         return IOStreamAdapter.adapt((Stream)stream);\n     }\n     \n     default <T> IOStream<T> empty() {\n         return IOStreamAdapter.adapt((Stream)Stream.empty());\n     }\n     \n-    default <T> IOStream<T> iterate(final T seed, final IOUnaryOperator<T> f) {\n-        Objects.requireNonNull(f);\n-        final Iterator<T> iterator = (Iterator<T>)new IOStream.IOStream$1((Object)seed, (IOUnaryOperator)f);\n-        return adapt((Stream<T>)StreamSupport.stream(Spliterators.spliteratorUnknownSize((Iterator<? extends T>)iterator, 1040), false));\n+    default <T> IOStream<T> iterate(final T t, final IOUnaryOperator<T> obj) {\n+        Objects.requireNonNull(obj);\n+        return adapt((Stream<T>)StreamSupport.stream(Spliterators.spliteratorUnknownSize((Iterator<? extends T>)new IOStream.IOStream$1((Object)t, (IOUnaryOperator)obj), 1040), false));\n     }\n     \n-    default <T> IOStream<T> of(final Iterable<T> values) {\n-        return (values == null) ? empty() : adapt((Stream<T>)StreamSupport.stream((Spliterator<T>)values.spliterator(), false));\n+    default <T> IOStream<T> of(final Iterable<T> iterable) {\n+        return (iterable == null) ? empty() : adapt((Stream<T>)StreamSupport.stream((Spliterator<T>)iterable.spliterator(), false));\n     }\n     \n     @SafeVarargs\n-    default <T> IOStream<T> of(final T... values) {\n-        return (values == null || values.length == 0) ? empty() : adapt((Stream<T>)Arrays.stream((T[])values));\n+    default <T> IOStream<T> of(final T... array) {\n+        return (array == null || array.length == 0) ? empty() : adapt((Stream<T>)Arrays.stream((T[])array));\n     }\n     \n     default <T> IOStream<T> of(final T t) {\n         return adapt((Stream<T>)Stream.of((T)t));\n     }\n     \n-    default boolean allMatch(final IOPredicate<? super T> predicate) throws IOException {\n-        return ((Stream)this.unwrap()).allMatch(t -> Erase.test(predicate, t));\n+    default boolean allMatch(final IOPredicate<? super T> ioPredicate) throws IOException {\n+        return ((Stream)this.unwrap()).allMatch(o -> Erase.test(ioPredicate2, o));\n     }\n     \n-    default boolean anyMatch(final IOPredicate<? super T> predicate) throws IOException {\n-        return ((Stream)this.unwrap()).anyMatch(t -> Erase.test(predicate, t));\n+    default boolean anyMatch(final IOPredicate<? super T> ioPredicate) throws IOException {\n+        return ((Stream)this.unwrap()).anyMatch(o -> Erase.test(ioPredicate2, o));\n     }\n     \n     default <R, A> R collect(final Collector<? super T, A, R> collector) {\n         return ((Stream)this.unwrap()).collect(collector);\n     }\n     \n-    default <R> R collect(final IOSupplier<R> supplier, final IOBiConsumer<R, ? super T> accumulator, final IOBiConsumer<R, R> combiner) throws IOException {\n-        return ((Stream)this.unwrap()).collect(() -> Erase.get(supplier), (t, u) -> Erase.accept(accumulator, t, u), (t, u) -> Erase.accept(combiner, t, u));\n+    default <R> R collect(final IOSupplier<R> ioSupplier, final IOBiConsumer<R, ? super T> ioBiConsumer, final IOBiConsumer<R, R> ioBiConsumer2) throws IOException {\n+        return ((Stream)this.unwrap()).collect(() -> Erase.get(ioSupplier2), (o, o2) -> Erase.accept(ioBiConsumer3, o, o2), (o3, o4) -> Erase.accept(ioBiConsumer4, o3, o4));\n     }\n     \n     default long count() {\n         return ((Stream)this.unwrap()).count();\n     }\n     \n     default IOStream<T> distinct() {\n         return adapt(((Stream)this.unwrap()).distinct());\n     }\n     \n-    default IOStream<T> filter(final IOPredicate<? super T> predicate) throws IOException {\n-        return adapt(((Stream)this.unwrap()).filter(t -> Erase.test(predicate, t)));\n+    default IOStream<T> filter(final IOPredicate<? super T> ioPredicate) throws IOException {\n+        return adapt(((Stream)this.unwrap()).filter(o -> Erase.test(ioPredicate2, o)));\n     }\n     \n     default Optional<T> findAny() {\n         return ((Stream)this.unwrap()).findAny();\n     }\n     \n     default Optional<T> findFirst() {\n         return ((Stream)this.unwrap()).findFirst();\n     }\n     \n-    default <R> IOStream<R> flatMap(final IOFunction<? super T, ? extends IOStream<? extends R>> mapper) throws IOException {\n-        return adapt(((Stream)this.unwrap()).flatMap(t -> (BaseStream)((IOStream)Erase.apply(mapper, t)).unwrap()));\n+    default <R> IOStream<R> flatMap(final IOFunction<? super T, ? extends IOStream<? extends R>> ioFunction) throws IOException {\n+        return adapt(((Stream)this.unwrap()).flatMap(o2 -> (BaseStream)((IOStream)Erase.apply(ioFunction2, o2)).unwrap()));\n     }\n     \n-    default DoubleStream flatMapToDouble(final IOFunction<? super T, ? extends DoubleStream> mapper) throws IOException {\n-        return ((Stream)this.unwrap()).flatMapToDouble(t -> (Object)Erase.apply(mapper, t));\n+    default DoubleStream flatMapToDouble(final IOFunction<? super T, ? extends DoubleStream> ioFunction) throws IOException {\n+        return ((Stream)this.unwrap()).flatMapToDouble(o2 -> (Object)Erase.apply(ioFunction2, o2));\n     }\n     \n-    default IntStream flatMapToInt(final IOFunction<? super T, ? extends IntStream> mapper) throws IOException {\n-        return ((Stream)this.unwrap()).flatMapToInt(t -> (Object)Erase.apply(mapper, t));\n+    default IntStream flatMapToInt(final IOFunction<? super T, ? extends IntStream> ioFunction) throws IOException {\n+        return ((Stream)this.unwrap()).flatMapToInt(o2 -> (Object)Erase.apply(ioFunction2, o2));\n     }\n     \n-    default LongStream flatMapToLong(final IOFunction<? super T, ? extends LongStream> mapper) throws IOException {\n-        return ((Stream)this.unwrap()).flatMapToLong(t -> (Object)Erase.apply(mapper, t));\n+    default LongStream flatMapToLong(final IOFunction<? super T, ? extends LongStream> ioFunction) throws IOException {\n+        return ((Stream)this.unwrap()).flatMapToLong(o2 -> (Object)Erase.apply(ioFunction2, o2));\n     }\n     \n-    default void forAll(final IOConsumer<T> action) throws IOExceptionList {\n-        this.forAll(action, (i, e) -> e);\n+    default void forAll(final IOConsumer<T> ioConsumer) throws IOExceptionList {\n+        this.forAll(ioConsumer, (p0, ex) -> ex);\n     }\n     \n-    default void forAll(final IOConsumer<T> action, final BiFunction<Integer, IOException, IOException> exSupplier) throws IOExceptionList {\n-        final AtomicReference<List<IOException>> causeList = new AtomicReference<List<IOException>>();\n-        final AtomicInteger index = new AtomicInteger();\n-        final IOConsumer<T> safeAction = (IOConsumer<T>)IOStreams.toIOConsumer((IOConsumer)action);\n-        ((Stream)this.unwrap()).forEach(e -> {\n+    default void forAll(final IOConsumer<T> ioConsumer, final BiFunction<Integer, IOException, IOException> biFunction) throws IOExceptionList {\n+        final AtomicReference atomicReference = new AtomicReference();\n+        ((Stream)this.unwrap()).forEach(o -> {\n+            IOStreams.toIOConsumer((IOConsumer)ioConsumer3);\n+            final Object o2 = new AtomicInteger();\n             try {\n-                safeAction.accept(e);\n+                ioConsumer2.accept(o);\n             }\n-            catch (final IOException innerEx) {\n-                if (causeList.get() == null) {\n-                    causeList.set(new ArrayList());\n+            catch (final IOException ex) {\n+                if (atomicReference2.get() == null) {\n+                    atomicReference2.set(new ArrayList());\n                 }\n-                if (exSupplier != null) {\n-                    ((List<IOException>)causeList.get()).add(exSupplier.apply(Integer.valueOf(index.get()), innerEx));\n+                if (biFunction2 != null) {\n+                    ((List<IOException>)atomicReference2.get()).add(biFunction2.apply(Integer.valueOf(atomicInteger.get()), ex));\n                 }\n             }\n-            index.incrementAndGet();\n+            atomicInteger.incrementAndGet();\n             return;\n         });\n-        IOExceptionList.checkEmpty((List)(List)causeList.get(), (Object)null);\n+        IOExceptionList.checkEmpty((List)(List)atomicReference.get(), (Object)null);\n     }\n     \n-    default void forEach(final IOConsumer<? super T> action) throws IOException {\n-        ((Stream)this.unwrap()).forEach(e -> Erase.accept(action, e));\n+    default void forEach(final IOConsumer<? super T> ioConsumer) throws IOException {\n+        ((Stream)this.unwrap()).forEach(o -> Erase.accept(ioConsumer2, o));\n     }\n     \n-    default void forEachOrdered(final IOConsumer<? super T> action) throws IOException {\n-        ((Stream)this.unwrap()).forEachOrdered(e -> Erase.accept(action, e));\n+    default void forEachOrdered(final IOConsumer<? super T> ioConsumer) throws IOException {\n+        ((Stream)this.unwrap()).forEachOrdered(o -> Erase.accept(ioConsumer2, o));\n     }\n     \n-    default IOStream<T> limit(final long maxSize) {\n-        return adapt(((Stream)this.unwrap()).limit(maxSize));\n+    default IOStream<T> limit(final long n) {\n+        return adapt(((Stream)this.unwrap()).limit(n));\n     }\n     \n-    default <R> IOStream<R> map(final IOFunction<? super T, ? extends R> mapper) throws IOException {\n-        return adapt(((Stream)this.unwrap()).map(t -> Erase.apply(mapper, t)));\n+    default <R> IOStream<R> map(final IOFunction<? super T, ? extends R> ioFunction) throws IOException {\n+        return adapt(((Stream)this.unwrap()).map(o2 -> Erase.apply(ioFunction2, o2)));\n     }\n     \n-    default DoubleStream mapToDouble(final ToDoubleFunction<? super T> mapper) {\n-        return ((Stream)this.unwrap()).mapToDouble(mapper);\n+    default DoubleStream mapToDouble(final ToDoubleFunction<? super T> toDoubleFunction) {\n+        return ((Stream)this.unwrap()).mapToDouble(toDoubleFunction);\n     }\n     \n-    default IntStream mapToInt(final ToIntFunction<? super T> mapper) {\n-        return ((Stream)this.unwrap()).mapToInt(mapper);\n+    default IntStream mapToInt(final ToIntFunction<? super T> toIntFunction) {\n+        return ((Stream)this.unwrap()).mapToInt(toIntFunction);\n     }\n     \n-    default LongStream mapToLong(final ToLongFunction<? super T> mapper) {\n-        return ((Stream)this.unwrap()).mapToLong(mapper);\n+    default LongStream mapToLong(final ToLongFunction<? super T> toLongFunction) {\n+        return ((Stream)this.unwrap()).mapToLong(toLongFunction);\n     }\n     \n-    default Optional<T> max(final IOComparator<? super T> comparator) throws IOException {\n-        return ((Stream)this.unwrap()).max((t, u) -> Erase.compare(comparator, t, u));\n+    default Optional<T> max(final IOComparator<? super T> ioComparator) throws IOException {\n+        return ((Stream)this.unwrap()).max((o, o2) -> Erase.compare(ioComparator2, o, o2));\n     }\n     \n-    default Optional<T> min(final IOComparator<? super T> comparator) throws IOException {\n-        return ((Stream)this.unwrap()).min((t, u) -> Erase.compare(comparator, t, u));\n+    default Optional<T> min(final IOComparator<? super T> ioComparator) throws IOException {\n+        return ((Stream)this.unwrap()).min((o, o2) -> Erase.compare(ioComparator2, o, o2));\n     }\n     \n-    default boolean noneMatch(final IOPredicate<? super T> predicate) throws IOException {\n-        return ((Stream)this.unwrap()).noneMatch(t -> Erase.test(predicate, t));\n+    default boolean noneMatch(final IOPredicate<? super T> ioPredicate) throws IOException {\n+        return ((Stream)this.unwrap()).noneMatch(o -> Erase.test(ioPredicate2, o));\n     }\n     \n-    default IOStream<T> peek(final IOConsumer<? super T> action) throws IOException {\n-        return adapt(((Stream)this.unwrap()).peek(t -> Erase.accept(action, t)));\n+    default IOStream<T> peek(final IOConsumer<? super T> ioConsumer) throws IOException {\n+        return adapt(((Stream)this.unwrap()).peek(o -> Erase.accept(ioConsumer2, o)));\n     }\n     \n-    default Optional<T> reduce(final IOBinaryOperator<T> accumulator) throws IOException {\n-        return ((Stream)this.unwrap()).reduce((t, u) -> Erase.apply((IOBiFunction)accumulator, t, u));\n+    default Optional<T> reduce(final IOBinaryOperator<T> ioBinaryOperator) throws IOException {\n+        return ((Stream)this.unwrap()).reduce((o2, o4) -> Erase.apply((IOBiFunction)ioBinaryOperator2, o2, o4));\n     }\n     \n-    default T reduce(final T identity, final IOBinaryOperator<T> accumulator) throws IOException {\n-        return ((Stream)this.unwrap()).reduce(identity, (t, u) -> Erase.apply((IOBiFunction)accumulator, t, u));\n+    default T reduce(final T t, final IOBinaryOperator<T> ioBinaryOperator) throws IOException {\n+        return ((Stream)this.unwrap()).reduce(t, (o2, o4) -> Erase.apply((IOBiFunction)ioBinaryOperator2, o2, o4));\n     }\n     \n-    default <U> U reduce(final U identity, final IOBiFunction<U, ? super T, U> accumulator, final IOBinaryOperator<U> combiner) throws IOException {\n-        return ((Stream)this.unwrap()).reduce(identity, (t, u) -> Erase.apply(accumulator, t, u), (t, u) -> Erase.apply((IOBiFunction)combiner, t, u));\n+    default <U> U reduce(final U u, final IOBiFunction<U, ? super T, U> ioBiFunction, final IOBinaryOperator<U> ioBinaryOperator) throws IOException {\n+        return ((Stream)this.unwrap()).reduce(u, (o2, o4) -> Erase.apply(ioBiFunction2, o2, o4), (o6, o8) -> Erase.apply((IOBiFunction)ioBinaryOperator2, o6, o8));\n     }\n     \n     default IOStream<T> skip(final long n) {\n         return adapt(((Stream)this.unwrap()).skip(n));\n     }\n     \n     default IOStream<T> sorted() {\n         return adapt(((Stream)this.unwrap()).sorted());\n     }\n     \n-    default IOStream<T> sorted(final IOComparator<? super T> comparator) throws IOException {\n-        return adapt(((Stream)this.unwrap()).sorted((t, u) -> Erase.compare(comparator, t, u)));\n+    default IOStream<T> sorted(final IOComparator<? super T> ioComparator) throws IOException {\n+        return adapt(((Stream)this.unwrap()).sorted((o, o2) -> Erase.compare(ioComparator2, o, o2)));\n     }\n     \n     default Object[] toArray() {\n         return ((Stream)this.unwrap()).toArray();\n     }\n     \n-    default <A> A[] toArray(final IntFunction<A[]> generator) {\n-        return ((Stream)this.unwrap()).toArray(generator);\n+    default <A> A[] toArray(final IntFunction<A[]> intFunction) {\n+        return ((Stream)this.unwrap()).toArray(intFunction);\n     }\n }\n"}]}
