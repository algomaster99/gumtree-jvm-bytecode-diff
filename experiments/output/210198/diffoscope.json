{"diffoscope-json-version": 1, "source1": "first/FastDateParser.class", "source2": "second/FastDateParser.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -46,49 +46,49 @@\n     private static final FastDateParser.Strategy HOUR24_OF_DAY_STRATEGY;\n     private static final FastDateParser.Strategy HOUR12_STRATEGY;\n     private static final FastDateParser.Strategy HOUR_STRATEGY;\n     private static final FastDateParser.Strategy MINUTE_STRATEGY;\n     private static final FastDateParser.Strategy SECOND_STRATEGY;\n     private static final FastDateParser.Strategy MILLISECOND_STRATEGY;\n     \n-    protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale) {\n-        this(pattern, timeZone, locale, null);\n+    protected FastDateParser(final String s, final TimeZone timeZone, final Locale locale) {\n+        this(s, timeZone, locale, null);\n     }\n     \n-    protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale, final Date centuryStart) {\n+    protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale, final Date time) {\n         this.pattern = pattern;\n         this.timeZone = timeZone;\n         this.locale = locale;\n-        final Calendar definingCalendar = Calendar.getInstance(timeZone, locale);\n-        int centuryStartYear;\n-        if (centuryStart != null) {\n-            definingCalendar.setTime(centuryStart);\n-            centuryStartYear = definingCalendar.get(1);\n+        final Calendar instance = Calendar.getInstance(timeZone, locale);\n+        int value;\n+        if (time != null) {\n+            instance.setTime(time);\n+            value = instance.get(1);\n         }\n         else if (locale.equals(FastDateParser.JAPANESE_IMPERIAL)) {\n-            centuryStartYear = 0;\n+            value = 0;\n         }\n         else {\n-            definingCalendar.setTime(new Date());\n-            centuryStartYear = definingCalendar.get(1) - 80;\n+            instance.setTime(new Date());\n+            value = instance.get(1) - 80;\n         }\n-        this.century = centuryStartYear / 100 * 100;\n-        this.startYear = centuryStartYear - this.century;\n-        this.init(definingCalendar);\n+        this.century = value / 100 * 100;\n+        this.startYear = value - this.century;\n+        this.init(instance);\n     }\n     \n-    private void init(final Calendar definingCalendar) {\n+    private void init(final Calendar calendar) {\n         this.patterns = new ArrayList<FastDateParser.StrategyAndWidth>();\n-        final FastDateParser.StrategyParser fm = new FastDateParser.StrategyParser(this, definingCalendar);\n+        final FastDateParser.StrategyParser strategyParser = new FastDateParser.StrategyParser(this, calendar);\n         while (true) {\n-            final FastDateParser.StrategyAndWidth field = fm.getNextStrategy();\n-            if (field == null) {\n+            final FastDateParser.StrategyAndWidth nextStrategy = strategyParser.getNextStrategy();\n+            if (nextStrategy == null) {\n                 break;\n             }\n-            this.patterns.add(field);\n+            this.patterns.add(nextStrategy);\n         }\n     }\n     \n     private static boolean isFormatLetter(final char c) {\n         return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n     }\n     \n@@ -101,159 +101,158 @@\n     }\n     \n     public Locale getLocale() {\n         return this.locale;\n     }\n     \n     @Override\n-    public boolean equals(final Object obj) {\n-        if (!(obj instanceof FastDateParser)) {\n+    public boolean equals(final Object o) {\n+        if (!(o instanceof FastDateParser)) {\n             return false;\n         }\n-        final FastDateParser other = (FastDateParser)obj;\n-        return this.pattern.equals(other.pattern) && this.timeZone.equals(other.timeZone) && this.locale.equals(other.locale);\n+        final FastDateParser fastDateParser = (FastDateParser)o;\n+        return this.pattern.equals(fastDateParser.pattern) && this.timeZone.equals(fastDateParser.timeZone) && this.locale.equals(fastDateParser.locale);\n     }\n     \n     @Override\n     public int hashCode() {\n         return this.pattern.hashCode() + 13 * (this.timeZone.hashCode() + 13 * this.locale.hashCode());\n     }\n     \n     @Override\n     public String toString() {\n         return \"FastDateParser[\" + this.pattern + \",\" + this.locale + \",\" + this.timeZone.getID() + \"]\";\n     }\n     \n-    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n-        in.defaultReadObject();\n-        final Calendar definingCalendar = Calendar.getInstance(this.timeZone, this.locale);\n-        this.init(definingCalendar);\n+    private void readObject(final ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {\n+        objectInputStream.defaultReadObject();\n+        this.init(Calendar.getInstance(this.timeZone, this.locale));\n     }\n     \n-    public Object parseObject(final String source) throws ParseException {\n-        return this.parse(source);\n+    public Object parseObject(final String s) throws ParseException {\n+        return this.parse(s);\n     }\n     \n-    public Date parse(final String source) throws ParseException {\n-        final ParsePosition pp = new ParsePosition(0);\n-        final Date date = this.parse(source, pp);\n-        if (date != null) {\n-            return date;\n+    public Date parse(final String s) throws ParseException {\n+        final ParsePosition parsePosition = new ParsePosition(0);\n+        final Date parse = this.parse(s, parsePosition);\n+        if (parse != null) {\n+            return parse;\n         }\n         if (this.locale.equals(FastDateParser.JAPANESE_IMPERIAL)) {\n-            throw new ParseException(\"(The \" + this.locale + \" locale does not support dates before 1868 AD)\\nUnparseable date: \\\"\" + source, pp.getErrorIndex());\n+            throw new ParseException(\"(The \" + this.locale + \" locale does not support dates before 1868 AD)\\nUnparseable date: \\\"\" + s, parsePosition.getErrorIndex());\n         }\n-        throw new ParseException(\"Unparseable date: \" + source, pp.getErrorIndex());\n+        throw new ParseException(\"Unparseable date: \" + s, parsePosition.getErrorIndex());\n     }\n     \n-    public Object parseObject(final String source, final ParsePosition pos) {\n-        return this.parse(source, pos);\n+    public Object parseObject(final String s, final ParsePosition parsePosition) {\n+        return this.parse(s, parsePosition);\n     }\n     \n-    public Date parse(final String source, final ParsePosition pos) {\n-        final Calendar cal = Calendar.getInstance(this.timeZone, this.locale);\n-        cal.clear();\n-        return this.parse(source, pos, cal) ? cal.getTime() : null;\n+    public Date parse(final String s, final ParsePosition parsePosition) {\n+        final Calendar instance = Calendar.getInstance(this.timeZone, this.locale);\n+        instance.clear();\n+        return this.parse(s, parsePosition, instance) ? instance.getTime() : null;\n     }\n     \n-    public boolean parse(final String source, final ParsePosition pos, final Calendar calendar) {\n-        final ListIterator<FastDateParser.StrategyAndWidth> lt = this.patterns.listIterator();\n-        while (lt.hasNext()) {\n-            final FastDateParser.StrategyAndWidth strategyAndWidth = (FastDateParser.StrategyAndWidth)lt.next();\n-            final int maxWidth = strategyAndWidth.getMaxWidth((ListIterator)lt);\n-            if (!strategyAndWidth.strategy.parse(this, calendar, source, pos, maxWidth)) {\n+    public boolean parse(final String s, final ParsePosition parsePosition, final Calendar calendar) {\n+        final ListIterator<FastDateParser.StrategyAndWidth> listIterator = this.patterns.listIterator();\n+        while (listIterator.hasNext()) {\n+            final FastDateParser.StrategyAndWidth strategyAndWidth = (FastDateParser.StrategyAndWidth)listIterator.next();\n+            if (!strategyAndWidth.strategy.parse(this, calendar, s, parsePosition, strategyAndWidth.getMaxWidth((ListIterator)listIterator))) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    private static StringBuilder simpleQuote(final StringBuilder sb, final String value) {\n-        for (int i = 0; i < value.length(); ++i) {\n-            final char c = value.charAt(i);\n-            switch (c) {\n-                case '$':\n-                case '(':\n-                case ')':\n-                case '*':\n-                case '+':\n-                case '.':\n-                case '?':\n-                case '[':\n-                case '\\\\':\n-                case '^':\n-                case '{':\n-                case '|': {\n+    private static StringBuilder simpleQuote(final StringBuilder sb, final String s) {\n+        for (int i = 0; i < s.length(); ++i) {\n+            final char char1 = s.charAt(i);\n+            switch (char1) {\n+                case 36:\n+                case 40:\n+                case 41:\n+                case 42:\n+                case 43:\n+                case 46:\n+                case 63:\n+                case 91:\n+                case 92:\n+                case 94:\n+                case 123:\n+                case 124: {\n                     sb.append('\\\\');\n                     break;\n                 }\n             }\n-            sb.append(c);\n+            sb.append(char1);\n         }\n         if (sb.charAt() == '.') {\n             sb.append('?');\n         }\n         return sb;\n     }\n     \n-    private static Map<String, Integer> appendDisplayNames(final Calendar cal, final Locale locale, final int field, final StringBuilder regex) {\n-        final Map<String, Integer> values = new HashMap<String, Integer>();\n-        final Map<String, Integer> displayNames = cal.getDisplayNames(field, 0, locale);\n-        final TreeSet<String> sorted = new TreeSet<String>(FastDateParser.LONGER_FIRST_LOWERCASE);\n-        for (final Map.Entry<String, Integer> displayName : displayNames.entrySet()) {\n-            final String key = ((String)displayName.getKey()).toLowerCase(locale);\n-            if (sorted.add(key)) {\n-                values.put(key, displayName.getValue());\n+    private static Map<String, Integer> appendDisplayNames(final Calendar calendar, final Locale locale, final int field, final StringBuilder sb) {\n+        final HashMap hashMap = new HashMap();\n+        final Map<String, Integer> displayNames = calendar.getDisplayNames(field, 0, locale);\n+        final TreeSet set = new TreeSet((Comparator<? super E>)FastDateParser.LONGER_FIRST_LOWERCASE);\n+        for (final Map.Entry entry : displayNames.entrySet()) {\n+            final String lowerCase = ((String)entry.getKey()).toLowerCase(locale);\n+            if (set.add(lowerCase)) {\n+                hashMap.put(lowerCase, entry.getValue());\n             }\n         }\n-        for (final String symbol : sorted) {\n-            simpleQuote(regex, symbol).append('|');\n+        final Iterator iterator2 = set.iterator();\n+        while (iterator2.hasNext()) {\n+            simpleQuote(sb, (String)iterator2.next()).append('|');\n         }\n-        return values;\n+        return hashMap;\n     }\n     \n-    private int adjustYear(final int twoDigitYear) {\n-        final int trial = this.century + twoDigitYear;\n-        return (twoDigitYear >= this.startYear) ? trial : (trial + 100);\n+    private int adjustYear(final int n) {\n+        final int n2 = this.century + n;\n+        return (n >= this.startYear) ? n2 : (n2 + 100);\n     }\n     \n-    private FastDateParser.Strategy getStrategy(final char f, final int width, final Calendar definingCalendar) {\n-        switch (f) {\n+    private FastDateParser.Strategy getStrategy(final char c, final int n, final Calendar calendar) {\n+        switch (c) {\n             default: {\n-                throw new IllegalArgumentException(\"Format '\" + f + \"' not supported\");\n+                throw new IllegalArgumentException(\"Format '\" + c + \"' not supported\");\n             }\n             case 'D': {\n                 return FastDateParser.DAY_OF_YEAR_STRATEGY;\n             }\n             case 'E': {\n-                return this.getLocaleSpecificStrategy(7, definingCalendar);\n+                return this.getLocaleSpecificStrategy(7, calendar);\n             }\n             case 'F': {\n                 return FastDateParser.DAY_OF_WEEK_IN_MONTH_STRATEGY;\n             }\n             case 'G': {\n-                return this.getLocaleSpecificStrategy(0, definingCalendar);\n+                return this.getLocaleSpecificStrategy(0, calendar);\n             }\n             case 'H': {\n                 return FastDateParser.HOUR_OF_DAY_STRATEGY;\n             }\n             case 'K': {\n                 return FastDateParser.HOUR_STRATEGY;\n             }\n             case 'M': {\n-                return (width >= 3) ? this.getLocaleSpecificStrategy(2, definingCalendar) : FastDateParser.NUMBER_MONTH_STRATEGY;\n+                return (n >= 3) ? this.getLocaleSpecificStrategy(2, calendar) : FastDateParser.NUMBER_MONTH_STRATEGY;\n             }\n             case 'S': {\n                 return FastDateParser.MILLISECOND_STRATEGY;\n             }\n             case 'W': {\n                 return FastDateParser.WEEK_OF_MONTH_STRATEGY;\n             }\n             case 'a': {\n-                return this.getLocaleSpecificStrategy(9, definingCalendar);\n+                return this.getLocaleSpecificStrategy(9, calendar);\n             }\n             case 'd': {\n                 return FastDateParser.DAY_OF_MONTH_STRATEGY;\n             }\n             case 'h': {\n                 return FastDateParser.HOUR12_STRATEGY;\n             }\n@@ -270,56 +269,56 @@\n                 return FastDateParser.DAY_OF_WEEK_STRATEGY;\n             }\n             case 'w': {\n                 return FastDateParser.WEEK_OF_YEAR_STRATEGY;\n             }\n             case 'Y':\n             case 'y': {\n-                return (width > 2) ? FastDateParser.LITERAL_YEAR_STRATEGY : FastDateParser.ABBREVIATED_YEAR_STRATEGY;\n+                return (n > 2) ? FastDateParser.LITERAL_YEAR_STRATEGY : FastDateParser.ABBREVIATED_YEAR_STRATEGY;\n             }\n             case 'X': {\n-                return FastDateParser.ISO8601TimeZoneStrategy.getStrategy(width);\n+                return FastDateParser.ISO8601TimeZoneStrategy.getStrategy(n);\n             }\n             case 'Z': {\n-                if (width == 2) {\n+                if (n == 2) {\n                     return FastDateParser.ISO8601TimeZoneStrategy.access$400();\n                 }\n-                return this.getLocaleSpecificStrategy(15, definingCalendar);\n+                return this.getLocaleSpecificStrategy(15, calendar);\n             }\n             case 'z': {\n-                return this.getLocaleSpecificStrategy(15, definingCalendar);\n+                return this.getLocaleSpecificStrategy(15, calendar);\n             }\n         }\n     }\n     \n-    private static ConcurrentMap<Locale, FastDateParser.Strategy> getCache(final int field) {\n+    private static ConcurrentMap<Locale, FastDateParser.Strategy> getCache(final int n) {\n         synchronized (FastDateParser.caches) {\n-            if (FastDateParser.caches[field] == null) {\n-                FastDateParser.caches[field] = new ConcurrentHashMap<Locale, FastDateParser.Strategy>(3);\n+            if (FastDateParser.caches[n] == null) {\n+                FastDateParser.caches[n] = new ConcurrentHashMap<Locale, FastDateParser.Strategy>(3);\n             }\n-            return FastDateParser.caches[field];\n+            return FastDateParser.caches[n];\n         }\n     }\n     \n-    private FastDateParser.Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar) {\n-        final ConcurrentMap<Locale, FastDateParser.Strategy> cache = getCache(field);\n-        FastDateParser.Strategy strategy = (FastDateParser.Strategy)cache.get(this.locale);\n-        if (strategy == null) {\n-            strategy = (FastDateParser.Strategy)((field == 15) ? new FastDateParser.TimeZoneStrategy(this.locale) : new FastDateParser.CaseInsensitiveTextStrategy(field, definingCalendar, this.locale));\n-            final FastDateParser.Strategy inCache = (FastDateParser.Strategy)cache.putIfAbsent(this.locale, strategy);\n-            if (inCache != null) {\n-                return inCache;\n+    private FastDateParser.Strategy getLocaleSpecificStrategy(final int n, final Calendar calendar) {\n+        final ConcurrentMap<Locale, FastDateParser.Strategy> cache = getCache(n);\n+        Object o = (Object)cache.get(this.locale);\n+        if (o == null) {\n+            o = ((n == 15) ? new FastDateParser.TimeZoneStrategy(this.locale) : new FastDateParser.CaseInsensitiveTextStrategy(n, calendar, this.locale));\n+            final FastDateParser.Strategy strategy = (FastDateParser.Strategy)cache.putIfAbsent(this.locale, (FastDateParser.Strategy)o);\n+            if (strategy != null) {\n+                return strategy;\n             }\n         }\n-        return strategy;\n+        return (FastDateParser.Strategy)o;\n     }\n     \n     static {\n         JAPANESE_IMPERIAL = new Locale(\"ja\", \"JP\", \"JP\");\n-        LONGER_FIRST_LOWERCASE = ((left, right) -> right.compareTo(left));\n+        LONGER_FIRST_LOWERCASE = ((anotherString, s) -> s.compareTo(anotherString));\n         caches = new ConcurrentMap[17];\n         ABBREVIATED_YEAR_STRATEGY = (FastDateParser.Strategy)new FastDateParser.FastDateParser$1(1);\n         NUMBER_MONTH_STRATEGY = (FastDateParser.Strategy)new FastDateParser.FastDateParser$2(2);\n         LITERAL_YEAR_STRATEGY = (FastDateParser.Strategy)new FastDateParser.NumberStrategy(1);\n         WEEK_OF_YEAR_STRATEGY = (FastDateParser.Strategy)new FastDateParser.NumberStrategy(3);\n         WEEK_OF_MONTH_STRATEGY = (FastDateParser.Strategy)new FastDateParser.NumberStrategy(4);\n         DAY_OF_YEAR_STRATEGY = (FastDateParser.Strategy)new FastDateParser.NumberStrategy(6);\n"}]}
