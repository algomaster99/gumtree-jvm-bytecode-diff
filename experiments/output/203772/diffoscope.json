{"diffoscope-json-version": 1, "source1": "first/GzipCompressorInputStream.class", "source2": "second/GzipCompressorInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,16 +1,16 @@\n \n package org.apache.commons.compress.compressors.gzip;\n \n import org.apache.commons.compress.utils.IOUtils;\n import java.util.zip.DataFormatException;\n import java.io.EOFException;\n import java.io.ByteArrayOutputStream;\n-import java.io.DataInput;\n import java.nio.charset.StandardCharsets;\n+import java.io.DataInput;\n import org.apache.commons.compress.utils.ByteUtils;\n import java.io.DataInputStream;\n import java.io.BufferedInputStream;\n import java.io.IOException;\n import java.util.zip.CRC32;\n import java.util.zip.Inflater;\n import java.io.InputStream;\n@@ -57,138 +57,135 @@\n         this.init(true);\n     }\n     \n     public GzipParameters getMetaData() {\n         return this.parameters;\n     }\n     \n-    private boolean init(final boolean isFirstMember) throws IOException {\n-        assert isFirstMember || this.decompressConcatenated;\n-        final int magic0 = this.in.read();\n-        if (magic0 == -1 && !isFirstMember) {\n+    private boolean init(final boolean b) throws IOException {\n+        assert b || this.decompressConcatenated;\n+        final int read = this.in.read();\n+        if (read == -1 && !b) {\n             return false;\n         }\n-        if (magic0 != 31 || this.in.read() != 139) {\n-            throw new IOException(isFirstMember ? \"Input is not in the .gz format\" : \"Garbage after a valid .gz stream\");\n+        if (read != 31 || this.in.read() != 139) {\n+            throw new IOException(b ? \"Input is not in the .gz format\" : \"Garbage after a valid .gz stream\");\n         }\n-        final DataInput inData = new DataInputStream(this.in);\n-        final int method = inData.readUnsignedByte();\n-        if (method != 8) {\n-            throw new IOException(\"Unsupported compression method \" + method + \" in the .gz header\");\n+        final DataInputStream dataInputStream = new DataInputStream(this.in);\n+        final int unsignedByte = dataInputStream.readUnsignedByte();\n+        if (unsignedByte != 8) {\n+            throw new IOException(\"Unsupported compression method \" + unsignedByte + \" in the .gz header\");\n         }\n-        final int flg = inData.readUnsignedByte();\n-        if ((flg & 0xE0) != 0x0) {\n+        final int unsignedByte2 = dataInputStream.readUnsignedByte();\n+        if ((unsignedByte2 & 0xE0) != 0x0) {\n             throw new IOException(\"Reserved flags are set in the .gz header\");\n         }\n-        this.parameters.setModificationTime(ByteUtils.fromLittleEndian(inData, 4) * 1000L);\n-        switch (inData.readUnsignedByte()) {\n+        this.parameters.setModificationTime(ByteUtils.fromLittleEndian((DataInput)dataInputStream, 4) * 1000L);\n+        switch (dataInputStream.readUnsignedByte()) {\n             case 2: {\n                 this.parameters.setCompressionLevel(9);\n                 break;\n             }\n             case 4: {\n                 this.parameters.setCompressionLevel(1);\n                 break;\n             }\n         }\n-        this.parameters.setOperatingSystem(inData.readUnsignedByte());\n-        if ((flg & 0x4) != 0x0) {\n-            int xlen = inData.readUnsignedByte();\n-            xlen |= inData.readUnsignedByte() << 8;\n-            while (xlen-- > 0) {\n-                inData.readUnsignedByte();\n+        this.parameters.setOperatingSystem(dataInputStream.readUnsignedByte());\n+        if ((unsignedByte2 & 0x4) != 0x0) {\n+            int n = dataInputStream.readUnsignedByte() | dataInputStream.readUnsignedByte() << 8;\n+            while (n-- > 0) {\n+                dataInputStream.readUnsignedByte();\n             }\n         }\n-        if ((flg & 0x8) != 0x0) {\n-            this.parameters.setFilename(new String(readToNull(inData), StandardCharsets.ISO_8859_1));\n+        if ((unsignedByte2 & 0x8) != 0x0) {\n+            this.parameters.setFilename(new String(readToNull(dataInputStream), StandardCharsets.ISO_8859_1));\n         }\n-        if ((flg & 0x10) != 0x0) {\n-            this.parameters.setComment(new String(readToNull(inData), StandardCharsets.ISO_8859_1));\n+        if ((unsignedByte2 & 0x10) != 0x0) {\n+            this.parameters.setComment(new String(readToNull(dataInputStream), StandardCharsets.ISO_8859_1));\n         }\n-        if ((flg & 0x2) != 0x0) {\n-            inData.readShort();\n+        if ((unsignedByte2 & 0x2) != 0x0) {\n+            dataInputStream.readShort();\n         }\n         this.inf.reset();\n         this.crc.reset();\n         return true;\n     }\n     \n-    private static byte[] readToNull(final DataInput inData) throws IOException {\n-        try (final ByteArrayOutputStream bos = new ByteArrayOutputStream()) {\n-            int b = 0;\n-            while ((b = inData.readUnsignedByte()) != 0) {\n-                bos.write(b);\n+    private static byte[] readToNull(final DataInput dataInput) throws IOException {\n+        try (final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) {\n+            int unsignedByte;\n+            while ((unsignedByte = dataInput.readUnsignedByte()) != 0) {\n+                byteArrayOutputStream.write(unsignedByte);\n             }\n-            return bos.toByteArray();\n+            return byteArrayOutputStream.toByteArray();\n         }\n     }\n     \n     public int read() throws IOException {\n         return (this.read(this.oneByte, 0, 1) == -1) ? -1 : (this.oneByte[0] & 0xFF);\n     }\n     \n-    public int read(final byte[] b, int off, int len) throws IOException {\n-        if (len == 0) {\n+    public int read(final byte[] array, int n, int i) throws IOException {\n+        if (i == 0) {\n             return 0;\n         }\n         if (this.endReached) {\n             return -1;\n         }\n-        int size = 0;\n-        while (len > 0) {\n+        int n2 = 0;\n+        while (i > 0) {\n             if (this.inf.needsInput()) {\n                 this.in.mark(this.buf.length);\n                 this.bufUsed = this.in.read(this.buf);\n                 if (this.bufUsed == -1) {\n                     throw new EOFException();\n                 }\n                 this.inf.setInput(this.buf, 0, this.bufUsed);\n             }\n-            int ret;\n+            int inflate;\n             try {\n-                ret = this.inf.inflate(b, off, len);\n+                inflate = this.inf.inflate(array, n, i);\n             }\n-            catch (final DataFormatException e) {\n+            catch (final DataFormatException ex) {\n                 throw new IOException(\"Gzip-compressed data is corrupt\");\n             }\n-            this.crc.update(b, off, ret);\n-            off += ret;\n-            len -= ret;\n-            size += ret;\n-            this.count(ret);\n+            this.crc.update(array, n, inflate);\n+            n += inflate;\n+            i -= inflate;\n+            n2 += inflate;\n+            this.count(inflate);\n             if (this.inf.finished()) {\n                 this.in.reset();\n-                final int skipAmount = this.bufUsed - this.inf.getRemaining();\n-                if (IOUtils.skip(this.in, (long)skipAmount) != skipAmount) {\n+                final int n3 = this.bufUsed - this.inf.getRemaining();\n+                if (IOUtils.skip(this.in, (long)n3) != n3) {\n                     throw new IOException();\n                 }\n                 this.bufUsed = 0;\n-                final DataInput inData = new DataInputStream(this.in);\n-                final long crcStored = ByteUtils.fromLittleEndian(inData, 4);\n-                if (crcStored != this.crc.getValue()) {\n+                final DataInputStream dataInputStream = new DataInputStream(this.in);\n+                if (ByteUtils.fromLittleEndian((DataInput)dataInputStream, 4) != this.crc.getValue()) {\n                     throw new IOException(\"Gzip-compressed data is corrupt (CRC32 error)\");\n                 }\n-                final long isize = ByteUtils.fromLittleEndian(inData, 4);\n-                if (isize != (this.inf.getBytesWritten() & 0xFFFFFFFFL)) {\n+                if (ByteUtils.fromLittleEndian((DataInput)dataInputStream, 4) != (this.inf.getBytesWritten() & 0xFFFFFFFFL)) {\n                     throw new IOException(\"Gzip-compressed data is corrupt(uncompressed size mismatch)\");\n                 }\n                 if (!this.decompressConcatenated || !this.init(false)) {\n                     this.inf.end();\n                     this.inf = null;\n                     this.endReached = true;\n-                    return (size == 0) ? -1 : size;\n+                    return (n2 == 0) ? -1 : n2;\n                 }\n                 continue;\n             }\n         }\n-        return size;\n+        return n2;\n     }\n     \n-    public static boolean matches(final byte[] signature, final int length) {\n-        return length >= 2 && signature[0] == 31 && signature[1] == -117;\n+    public static boolean matches(final byte[] array, final int n) {\n+        return n >= 2 && array[0] == 31 && array[1] == -117;\n     }\n     \n     public void close() throws IOException {\n         if (this.inf != null) {\n             this.inf.end();\n             this.inf = null;\n         }\n"}]}
