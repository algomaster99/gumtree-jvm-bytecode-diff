{"diffoscope-json-version": 1, "source1": "first/ZipArchiveOutputStream.class", "source2": "second/ZipArchiveOutputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -99,14 +99,27 @@\n     static final byte[] LFH_SIG;\n     static final byte[] DD_SIG;\n     static final byte[] CFH_SIG;\n     static final byte[] EOCD_SIG;\n     static final byte[] ZIP64_EOCD_SIG;\n     static final byte[] ZIP64_EOCD_LOC_SIG;\n     \n+    static {\n+        EMPTY = new byte[0];\n+        ZERO = new byte[2];\n+        LZERO = new byte[4];\n+        ONE = ZipLong.getBytes(1L);\n+        LFH_SIG = ZipLong.LFH_SIG.getBytes();\n+        DD_SIG = ZipLong.DD_SIG.getBytes();\n+        CFH_SIG = ZipLong.CFH_SIG.getBytes();\n+        EOCD_SIG = ZipLong.getBytes(101010256L);\n+        ZIP64_EOCD_SIG = ZipLong.getBytes(101075792L);\n+        ZIP64_EOCD_LOC_SIG = ZipLong.getBytes(117853008L);\n+    }\n+    \n     public ZipArchiveOutputStream(final OutputStream out) {\n         this.finished = false;\n         this.comment = \"\";\n         this.level = -1;\n         this.hasCompressionLevelChanged = false;\n         this.method = 8;\n         this.entries = new LinkedList<ZipArchiveEntry>();\n@@ -308,49 +321,49 @@\n         }\n         this.writeCounted(byteArrayOutputStream.toByteArray());\n     }\n     \n     public void closeArchiveEntry() throws IOException {\n         this.preClose();\n         this.flushDeflater();\n-        final long bytesWritten = this.streamCompressor.getTotalBytesWritten() - ZipArchiveOutputStream.CurrentEntry.access$000(this.entry);\n+        final long bytesWritten = this.streamCompressor.getTotalBytesWritten() - ZipArchiveOutputStream.CurrentEntry.access$0(this.entry);\n         final long realCrc = this.streamCompressor.getCrc32();\n-        ZipArchiveOutputStream.CurrentEntry.access$102(this.entry, this.streamCompressor.getBytesRead());\n-        final Zip64Mode effectiveMode = this.getEffectiveZip64Mode(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n+        ZipArchiveOutputStream.CurrentEntry.access$1(this.entry, this.streamCompressor.getBytesRead());\n+        final Zip64Mode effectiveMode = this.getEffectiveZip64Mode(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry));\n         final boolean actuallyNeedsZip64 = this.handleSizesAndCrc(bytesWritten, realCrc, effectiveMode);\n         this.closeEntry(actuallyNeedsZip64, false);\n         this.streamCompressor.reset();\n     }\n     \n     private void closeCopiedEntry(final boolean phased) throws IOException {\n         this.preClose();\n-        ZipArchiveOutputStream.CurrentEntry.access$102(this.entry, ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize());\n-        final Zip64Mode effectiveMode = this.getEffectiveZip64Mode(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n+        ZipArchiveOutputStream.CurrentEntry.access$1(this.entry, ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getSize());\n+        final Zip64Mode effectiveMode = this.getEffectiveZip64Mode(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry));\n         final boolean actuallyNeedsZip64 = this.checkIfNeedsZip64(effectiveMode);\n         this.closeEntry(actuallyNeedsZip64, phased);\n     }\n     \n     private void closeEntry(final boolean actuallyNeedsZip64, final boolean phased) throws IOException {\n         if (!phased && this.channel != null) {\n             this.rewriteSizesAndCrc(actuallyNeedsZip64);\n         }\n         if (!phased) {\n-            this.writeDataDescriptor(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n+            this.writeDataDescriptor(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry));\n         }\n         this.entry = null;\n     }\n     \n     private void preClose() throws IOException {\n         if (this.finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n         if (this.entry == null) {\n             throw new IOException(\"No current entry to close\");\n         }\n-        if (!ZipArchiveOutputStream.CurrentEntry.access$300(this.entry)) {\n+        if (!ZipArchiveOutputStream.CurrentEntry.access$3(this.entry)) {\n             this.write(ZipArchiveOutputStream.EMPTY, 0, 0);\n         }\n     }\n     \n     public void addRawArchiveEntry(final ZipArchiveEntry entry, final InputStream rawStream) throws IOException {\n         final ZipArchiveEntry ae = new ZipArchiveEntry(entry);\n         if (this.hasZip64Extra(ae)) {\n@@ -359,81 +372,81 @@\n         final boolean is2PhaseSource = ae.getCrc() != -1L && ae.getSize() != -1L && ae.getCompressedSize() != -1L;\n         this.putArchiveEntry((ArchiveEntry)ae, is2PhaseSource);\n         this.copyFromZipInputStream(rawStream);\n         this.closeCopiedEntry(is2PhaseSource);\n     }\n     \n     private void flushDeflater() throws IOException {\n-        if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getMethod() == 8) {\n+        if (ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getMethod() == 8) {\n             this.streamCompressor.flushDeflater();\n         }\n     }\n     \n     private boolean handleSizesAndCrc(final long bytesWritten, final long crc, final Zip64Mode effectiveMode) throws ZipException {\n-        if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getMethod() == 8) {\n-            ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setSize(ZipArchiveOutputStream.CurrentEntry.access$100(this.entry));\n-            ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setCompressedSize(bytesWritten);\n-            ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setCrc(crc);\n+        if (ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getMethod() == 8) {\n+            ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).setSize(ZipArchiveOutputStream.CurrentEntry.access$4(this.entry));\n+            ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).setCompressedSize(bytesWritten);\n+            ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).setCrc(crc);\n         }\n         else if (this.channel == null) {\n-            if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getCrc() != crc) {\n-                throw new ZipException(\"Bad CRC checksum for entry \" + ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getName() + \": \" + Long.toHexString(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getCrc()) + \" instead of \" + Long.toHexString(crc));\n+            if (ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getCrc() != crc) {\n+                throw new ZipException(\"Bad CRC checksum for entry \" + ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getName() + \": \" + Long.toHexString(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getCrc()) + \" instead of \" + Long.toHexString(crc));\n             }\n-            if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize() != bytesWritten) {\n-                throw new ZipException(\"Bad size for entry \" + ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getName() + \": \" + ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize() + \" instead of \" + bytesWritten);\n+            if (ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getSize() != bytesWritten) {\n+                throw new ZipException(\"Bad size for entry \" + ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getName() + \": \" + ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getSize() + \" instead of \" + bytesWritten);\n             }\n         }\n         else {\n-            ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setSize(bytesWritten);\n-            ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setCompressedSize(bytesWritten);\n-            ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setCrc(crc);\n+            ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).setSize(bytesWritten);\n+            ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).setCompressedSize(bytesWritten);\n+            ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).setCrc(crc);\n         }\n         return this.checkIfNeedsZip64(effectiveMode);\n     }\n     \n     private boolean checkIfNeedsZip64(final Zip64Mode effectiveMode) throws ZipException {\n-        final boolean actuallyNeedsZip64 = this.isZip64Required(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry), effectiveMode);\n+        final boolean actuallyNeedsZip64 = this.isZip64Required(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry), effectiveMode);\n         if (actuallyNeedsZip64 && effectiveMode == Zip64Mode.Never) {\n-            throw new Zip64RequiredException(Zip64RequiredException.getEntryTooBigMessage(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry)));\n+            throw new Zip64RequiredException(Zip64RequiredException.getEntryTooBigMessage(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry)));\n         }\n         return actuallyNeedsZip64;\n     }\n     \n     private boolean isZip64Required(final ZipArchiveEntry entry1, final Zip64Mode requestedMode) {\n         return requestedMode == Zip64Mode.Always || this.isTooLageForZip32(entry1);\n     }\n     \n     private boolean isTooLageForZip32(final ZipArchiveEntry zipArchiveEntry) {\n         return zipArchiveEntry.getSize() >= 4294967295L || zipArchiveEntry.getCompressedSize() >= 4294967295L;\n     }\n     \n     private void rewriteSizesAndCrc(final boolean actuallyNeedsZip64) throws IOException {\n         final long save = this.channel.position();\n-        this.channel.position(ZipArchiveOutputStream.CurrentEntry.access$400(this.entry));\n-        this.writeOut(ZipLong.getBytes(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getCrc()));\n-        if (!this.hasZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry)) || !actuallyNeedsZip64) {\n-            this.writeOut(ZipLong.getBytes(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getCompressedSize()));\n-            this.writeOut(ZipLong.getBytes(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize()));\n+        this.channel.position(ZipArchiveOutputStream.CurrentEntry.access$5(this.entry));\n+        this.writeOut(ZipLong.getBytes(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getCrc()));\n+        if (!this.hasZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry)) || !actuallyNeedsZip64) {\n+            this.writeOut(ZipLong.getBytes(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getCompressedSize()));\n+            this.writeOut(ZipLong.getBytes(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getSize()));\n         }\n         else {\n             this.writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n             this.writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n         }\n-        if (this.hasZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry))) {\n-            final ByteBuffer name = this.getName(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n+        if (this.hasZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry))) {\n+            final ByteBuffer name = this.getName(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry));\n             final int nameLen = name.limit() - name.position();\n-            this.channel.position(ZipArchiveOutputStream.CurrentEntry.access$400(this.entry) + 12L + 4L + nameLen + 4L);\n-            this.writeOut(ZipEightByteInteger.getBytes(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize()));\n-            this.writeOut(ZipEightByteInteger.getBytes(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getCompressedSize()));\n+            this.channel.position(ZipArchiveOutputStream.CurrentEntry.access$5(this.entry) + 12L + 4L + nameLen + 4L);\n+            this.writeOut(ZipEightByteInteger.getBytes(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getSize()));\n+            this.writeOut(ZipEightByteInteger.getBytes(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getCompressedSize()));\n             if (!actuallyNeedsZip64) {\n-                this.channel.position(ZipArchiveOutputStream.CurrentEntry.access$400(this.entry) - 10L);\n-                this.writeOut(ZipShort.getBytes(this.versionNeededToExtract(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getMethod(), false, false)));\n-                ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).removeExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n-                ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setExtra();\n-                if (ZipArchiveOutputStream.CurrentEntry.access$500(this.entry)) {\n+                this.channel.position(ZipArchiveOutputStream.CurrentEntry.access$5(this.entry) - 10L);\n+                this.writeOut(ZipShort.getBytes(this.versionNeededToExtract(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getMethod(), false, false)));\n+                ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).removeExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n+                ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).setExtra();\n+                if (ZipArchiveOutputStream.CurrentEntry.access$6(this.entry)) {\n                     this.hasUsedZip64 = false;\n                 }\n             }\n         }\n         this.channel.position(save);\n     }\n     \n@@ -444,38 +457,38 @@\n     private void putArchiveEntry(final ArchiveEntry archiveEntry, final boolean phased) throws IOException {\n         if (this.finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n         if (this.entry != null) {\n             this.closeArchiveEntry();\n         }\n-        this.entry = new ZipArchiveOutputStream.CurrentEntry((ZipArchiveEntry)archiveEntry, (ZipArchiveOutputStream.ZipArchiveOutputStream$1)null);\n-        this.entries.add(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n-        this.setDefaults(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n-        final Zip64Mode effectiveMode = this.getEffectiveZip64Mode(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n+        this.entry = new ZipArchiveOutputStream.CurrentEntry((ZipArchiveEntry)archiveEntry, (ZipArchiveOutputStream.CurrentEntry)null);\n+        this.entries.add(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry));\n+        this.setDefaults(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry));\n+        final Zip64Mode effectiveMode = this.getEffectiveZip64Mode(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry));\n         this.validateSizeInformation(effectiveMode);\n-        if (this.shouldAddZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry), effectiveMode)) {\n-            final Zip64ExtendedInformationExtraField z64 = this.getZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n+        if (this.shouldAddZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry), effectiveMode)) {\n+            final Zip64ExtendedInformationExtraField z64 = this.getZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry));\n             ZipEightByteInteger size;\n             ZipEightByteInteger compressedSize;\n             if (phased) {\n-                size = new ZipEightByteInteger(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize());\n-                compressedSize = new ZipEightByteInteger(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getCompressedSize());\n+                size = new ZipEightByteInteger(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getSize());\n+                compressedSize = new ZipEightByteInteger(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getCompressedSize());\n             }\n-            else if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getMethod() == 0 && ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize() != -1L) {\n-                size = (compressedSize = new ZipEightByteInteger(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize()));\n+            else if (ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getMethod() == 0 && ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getSize() != -1L) {\n+                size = (compressedSize = new ZipEightByteInteger(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getSize()));\n             }\n             else {\n                 size = (compressedSize = ZipEightByteInteger.ZERO);\n             }\n             z64.setSize(size);\n             z64.setCompressedSize(compressedSize);\n-            ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setExtra();\n+            ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).setExtra();\n         }\n-        if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getMethod() == 8 && this.hasCompressionLevelChanged) {\n+        if (ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getMethod() == 8 && this.hasCompressionLevelChanged) {\n             this.def.setLevel(this.level);\n             this.hasCompressionLevelChanged = false;\n         }\n         this.writeLocalFileHeader((ZipArchiveEntry)archiveEntry, phased);\n     }\n     \n     private void setDefaults(final ZipArchiveEntry entry) {\n@@ -484,25 +497,25 @@\n         }\n         if (entry.getTime() == -1L) {\n             entry.setTime(System.currentTimeMillis());\n         }\n     }\n     \n     private void validateSizeInformation(final Zip64Mode effectiveMode) throws ZipException {\n-        if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getMethod() == 0 && this.channel == null) {\n-            if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize() == -1L) {\n+        if (ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getMethod() == 0 && this.channel == null) {\n+            if (ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getSize() == -1L) {\n                 throw new ZipException(\"Uncompressed size is required for STORED method when not writing to a file\");\n             }\n-            if (ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getCrc() == -1L) {\n+            if (ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getCrc() == -1L) {\n                 throw new ZipException(\"CRC checksum is required for STORED method when not writing to a file\");\n             }\n-            ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).setCompressedSize(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize());\n+            ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).setCompressedSize(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getSize());\n         }\n-        if ((ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getSize() >= 4294967295L || ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getCompressedSize() >= 4294967295L) && effectiveMode == Zip64Mode.Never) {\n-            throw new Zip64RequiredException(Zip64RequiredException.getEntryTooBigMessage(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry)));\n+        if ((ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getSize() >= 4294967295L || ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getCompressedSize() >= 4294967295L) && effectiveMode == Zip64Mode.Never) {\n+            throw new Zip64RequiredException(Zip64RequiredException.getEntryTooBigMessage(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry)));\n         }\n     }\n     \n     private boolean shouldAddZip64Extra(final ZipArchiveEntry entry, final Zip64Mode mode) {\n         return mode == Zip64Mode.Always || entry.getSize() >= 4294967295L || entry.getCompressedSize() >= 4294967295L || (entry.getSize() == -1L && this.channel != null && mode != Zip64Mode.Never);\n     }\n     \n@@ -533,29 +546,29 @@\n         return false;\n     }\n     \n     public void write(final byte[] b, final int offset, final int length) throws IOException {\n         if (this.entry == null) {\n             throw new IllegalStateException(\"No current entry\");\n         }\n-        ZipUtil.checkRequestedFeatures(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n-        final long writtenThisTime = this.streamCompressor.write(b, offset, length, ZipArchiveOutputStream.CurrentEntry.access$200(this.entry).getMethod());\n+        ZipUtil.checkRequestedFeatures(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry));\n+        final long writtenThisTime = this.streamCompressor.write(b, offset, length, ZipArchiveOutputStream.CurrentEntry.access$2(this.entry).getMethod());\n         this.count(writtenThisTime);\n     }\n     \n     private void writeCounted(final byte[] data) throws IOException {\n         this.streamCompressor.writeCounted(data);\n     }\n     \n     private void copyFromZipInputStream(final InputStream src) throws IOException {\n         if (this.entry == null) {\n             throw new IllegalStateException(\"No current entry\");\n         }\n-        ZipUtil.checkRequestedFeatures(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry));\n-        ZipArchiveOutputStream.CurrentEntry.access$302(this.entry, true);\n+        ZipUtil.checkRequestedFeatures(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry));\n+        ZipArchiveOutputStream.CurrentEntry.access$8(this.entry, true);\n         int length;\n         while ((length = src.read(this.copyBuffer)) >= 0) {\n             this.streamCompressor.writeCounted(this.copyBuffer, 0, length);\n             this.count(length);\n         }\n     }\n     \n@@ -564,14 +577,15 @@\n             if (!this.finished) {\n                 this.finish();\n             }\n         }\n         finally {\n             this.destroy();\n         }\n+        this.destroy();\n     }\n     \n     public void flush() throws IOException {\n         if (this.out != null) {\n             this.out.flush();\n         }\n     }\n@@ -593,18 +607,18 @@\n         long localHeaderStart = this.streamCompressor.getTotalBytesWritten();\n         if (this.isSplitZip) {\n             final ZipSplitOutputStream splitOutputStream = (ZipSplitOutputStream)this.out;\n             ze.setDiskNumberStart((long)splitOutputStream.getCurrentSplitSegmentIndex());\n             localHeaderStart = splitOutputStream.getCurrentSplitSegmentBytesWritten();\n         }\n         final byte[] localHeader = this.createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n-        this.metaData.put(ze, new ZipArchiveOutputStream.EntryMetaData(localHeaderStart, this.usesDataDescriptor(ze.getMethod(), phased), (ZipArchiveOutputStream.ZipArchiveOutputStream$1)null));\n-        ZipArchiveOutputStream.CurrentEntry.access$402(this.entry, localHeaderStart + 14L);\n+        this.metaData.put(ze, new ZipArchiveOutputStream.EntryMetaData(localHeaderStart, this.usesDataDescriptor(ze.getMethod(), phased), (ZipArchiveOutputStream.EntryMetaData)null));\n+        ZipArchiveOutputStream.CurrentEntry.access$9(this.entry, localHeaderStart + 14L);\n         this.writeCounted(localHeader);\n-        ZipArchiveOutputStream.CurrentEntry.access$002(this.entry, this.streamCompressor.getTotalBytesWritten());\n+        ZipArchiveOutputStream.CurrentEntry.access$10(this.entry, this.streamCompressor.getTotalBytesWritten());\n     }\n     \n     private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, final long archiveOffset) {\n         final ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField)ze.getExtraField(ResourceAlignmentExtraField.ID);\n         if (oldAlignmentEx != null) {\n             ze.removeExtraField(ResourceAlignmentExtraField.ID);\n         }\n@@ -634,15 +648,15 @@\n         }\n         else if (zipMethod == 8 || this.channel != null) {\n             System.arraycopy(ZipArchiveOutputStream.LZERO, 0, buf, 14, 4);\n         }\n         else {\n             ZipLong.putLong(ze.getCrc(), buf, 14);\n         }\n-        if (this.hasZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$200(this.entry))) {\n+        if (this.hasZip64Extra(ZipArchiveOutputStream.CurrentEntry.access$2(this.entry))) {\n             ZipLong.ZIP64_MAGIC.putLong(buf, 18);\n             ZipLong.ZIP64_MAGIC.putLong(buf, 22);\n         }\n         else if (phased) {\n             ZipLong.putLong(ze.getCompressedSize(), buf, 18);\n             ZipLong.putLong(ze.getSize(), buf, 22);\n         }\n@@ -694,19 +708,19 @@\n     protected void writeCentralFileHeader(final ZipArchiveEntry ze) throws IOException {\n         final byte[] centralFileHeader = this.createCentralFileHeader(ze);\n         this.writeCounted(centralFileHeader);\n     }\n     \n     private byte[] createCentralFileHeader(final ZipArchiveEntry ze) throws IOException {\n         final ZipArchiveOutputStream.EntryMetaData entryMetaData = (ZipArchiveOutputStream.EntryMetaData)this.metaData.get(ze);\n-        final boolean needsZip64Extra = this.hasZip64Extra(ze) || ze.getCompressedSize() >= 4294967295L || ze.getSize() >= 4294967295L || ZipArchiveOutputStream.EntryMetaData.access$800(entryMetaData) >= 4294967295L || ze.getDiskNumberStart() >= 65535L || this.zip64Mode == Zip64Mode.Always;\n+        final boolean needsZip64Extra = this.hasZip64Extra(ze) || ze.getCompressedSize() >= 4294967295L || ze.getSize() >= 4294967295L || ZipArchiveOutputStream.EntryMetaData.access$1(entryMetaData) >= 4294967295L || ze.getDiskNumberStart() >= 65535L || this.zip64Mode == Zip64Mode.Always;\n         if (needsZip64Extra && this.zip64Mode == Zip64Mode.Never) {\n             throw new Zip64RequiredException(\"Archive's size exceeds the limit of 4GByte.\");\n         }\n-        this.handleZip64Extra(ze, ZipArchiveOutputStream.EntryMetaData.access$800(entryMetaData), needsZip64Extra);\n+        this.handleZip64Extra(ze, ZipArchiveOutputStream.EntryMetaData.access$1(entryMetaData), needsZip64Extra);\n         return this.createCentralFileHeader(ze, this.getName(ze), entryMetaData, needsZip64Extra);\n     }\n     \n     private byte[] createCentralFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final ZipArchiveOutputStream.EntryMetaData entryMetaData, final boolean needsZip64Extra) throws IOException {\n         if (this.isSplitZip) {\n             final int currentSplitSegment = ((ZipSplitOutputStream)this.out).getCurrentSplitSegmentIndex();\n             if (this.numberOfCDInDiskData.get(Integer.valueOf(currentSplitSegment)) == null) {\n@@ -727,16 +741,16 @@\n         final int commentLen = commentB.limit() - commentB.position();\n         final int len = 46 + nameLen + extra.length + commentLen;\n         final byte[] buf = new byte[len];\n         System.arraycopy(ZipArchiveOutputStream.CFH_SIG, 0, buf, 0, 4);\n         ZipShort.putShort(ze.getPlatform() << 8 | (this.hasUsedZip64 ? 45 : 20), buf, 4);\n         final int zipMethod = ze.getMethod();\n         final boolean encodable = this.zipEncoding.canEncode(ze.getName());\n-        ZipShort.putShort(this.versionNeededToExtract(zipMethod, needsZip64Extra, ZipArchiveOutputStream.EntryMetaData.access$900(entryMetaData)), buf, 6);\n-        this.getGeneralPurposeBits(!encodable && this.fallbackToUTF8, ZipArchiveOutputStream.EntryMetaData.access$900(entryMetaData)).encode(buf, 8);\n+        ZipShort.putShort(this.versionNeededToExtract(zipMethod, needsZip64Extra, ZipArchiveOutputStream.EntryMetaData.access$2(entryMetaData)), buf, 6);\n+        this.getGeneralPurposeBits(!encodable && this.fallbackToUTF8, ZipArchiveOutputStream.EntryMetaData.access$2(entryMetaData)).encode(buf, 8);\n         ZipShort.putShort(zipMethod, buf, 10);\n         ZipUtil.toDosTime(this.calendarInstance, ze.getTime(), buf, 12);\n         ZipLong.putLong(ze.getCrc(), buf, 16);\n         if (ze.getCompressedSize() >= 4294967295L || ze.getSize() >= 4294967295L || this.zip64Mode == Zip64Mode.Always) {\n             ZipLong.ZIP64_MAGIC.putLong(buf, 20);\n             ZipLong.ZIP64_MAGIC.putLong(buf, 24);\n         }\n@@ -756,19 +770,19 @@\n             }\n         }\n         else {\n             System.arraycopy(ZipArchiveOutputStream.ZERO, 0, buf, 34, 2);\n         }\n         ZipShort.putShort(ze.getInternalAttributes(), buf, 36);\n         ZipLong.putLong(ze.getExternalAttributes(), buf, 38);\n-        if (ZipArchiveOutputStream.EntryMetaData.access$800(entryMetaData) >= 4294967295L || this.zip64Mode == Zip64Mode.Always) {\n+        if (ZipArchiveOutputStream.EntryMetaData.access$1(entryMetaData) >= 4294967295L || this.zip64Mode == Zip64Mode.Always) {\n             ZipLong.putLong(4294967295L, buf, 42);\n         }\n         else {\n-            ZipLong.putLong(Math.min(ZipArchiveOutputStream.EntryMetaData.access$800(entryMetaData), 4294967295L), buf, 42);\n+            ZipLong.putLong(Math.min(ZipArchiveOutputStream.EntryMetaData.access$1(entryMetaData), 4294967295L), buf, 42);\n         }\n         System.arraycopy(name.array(), name.arrayOffset(), buf, 46, nameLen);\n         final int extraStart = 46 + nameLen;\n         System.arraycopy(extra, 0, buf, extraStart, extra.length);\n         final int commentStart = extraStart + extra.length;\n         System.arraycopy(commentB.array(), commentB.arrayOffset(), buf, commentStart, commentLen);\n         return buf;\n@@ -950,15 +964,15 @@\n             throw new IOException(\"Stream has already been finished\");\n         }\n         return (ArchiveEntry)new ZipArchiveEntry(inputFile, entryName);\n     }\n     \n     private Zip64ExtendedInformationExtraField getZip64Extra(final ZipArchiveEntry ze) {\n         if (this.entry != null) {\n-            ZipArchiveOutputStream.CurrentEntry.access$502(this.entry, !this.hasUsedZip64);\n+            ZipArchiveOutputStream.CurrentEntry.access$11(this.entry, !this.hasUsedZip64);\n         }\n         this.hasUsedZip64 = true;\n         Zip64ExtendedInformationExtraField z64 = (Zip64ExtendedInformationExtraField)ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n         if (z64 == null) {\n             z64 = new Zip64ExtendedInformationExtraField();\n         }\n         ze.addAsFirstExtraField((ZipExtraField)z64);\n@@ -992,22 +1006,12 @@\n             }\n         }\n         finally {\n             if (this.out != null) {\n                 this.out.close();\n             }\n         }\n-    }\n-    \n-    static {\n-        EMPTY = new byte[0];\n-        ZERO = new byte[] { 0, 0 };\n-        LZERO = new byte[] { 0, 0, 0, 0 };\n-        ONE = ZipLong.getBytes(1L);\n-        LFH_SIG = ZipLong.LFH_SIG.getBytes();\n-        DD_SIG = ZipLong.DD_SIG.getBytes();\n-        CFH_SIG = ZipLong.CFH_SIG.getBytes();\n-        EOCD_SIG = ZipLong.getBytes(101010256L);\n-        ZIP64_EOCD_SIG = ZipLong.getBytes(101075792L);\n-        ZIP64_EOCD_LOC_SIG = ZipLong.getBytes(117853008L);\n+        if (this.out != null) {\n+            this.out.close();\n+        }\n     }\n }\n"}]}
