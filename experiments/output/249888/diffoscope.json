{"diffoscope-json-version": 1, "source1": "first/DesignForExtensionCheck.class", "source2": "second/DesignForExtensionCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,16 +1,13 @@\n \n package com.puppycrawl.tools.checkstyle.checks.design;\n \n import java.util.Objects;\n import com.puppycrawl.tools.checkstyle.api.Scope;\n-import java.util.Optional;\n-import java.util.function.Predicate;\n import com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n-import java.util.regex.Matcher;\n import com.puppycrawl.tools.checkstyle.utils.JavadocUtil;\n import com.puppycrawl.tools.checkstyle.utils.ScopeUtil;\n import com.puppycrawl.tools.checkstyle.api.DetailAST;\n import java.util.stream.Collector;\n import java.util.stream.Collectors;\n import java.util.Arrays;\n import java.util.regex.Pattern;\n@@ -26,16 +23,16 @@\n     private Pattern requiredJavadocPhrase;\n     \n     public DesignForExtensionCheck() {\n         this.ignoredAnnotations = Arrays.stream(new String[] { \"Test\", \"Before\", \"After\", \"BeforeClass\", \"AfterClass\" }).collect((Collector<? super String, ?, Set<String>>)Collectors.toSet());\n         this.requiredJavadocPhrase = Pattern.compile(\".*\");\n     }\n     \n-    public void setIgnoredAnnotations(final String... ignoredAnnotations) {\n-        this.ignoredAnnotations = Arrays.stream(ignoredAnnotations).collect((Collector<? super String, ?, Set<String>>)Collectors.toSet());\n+    public void setIgnoredAnnotations(final String... array) {\n+        this.ignoredAnnotations = Arrays.stream(array).collect((Collector<? super String, ?, Set<String>>)Collectors.toSet());\n     }\n     \n     public void setRequiredJavadocPhrase(final Pattern requiredJavadocPhrase) {\n         this.requiredJavadocPhrase = requiredJavadocPhrase;\n     }\n     \n     public int[] getDefaultTokens() {\n@@ -50,108 +47,97 @@\n         return new int[] { 9 };\n     }\n     \n     public boolean isCommentNodesRequired() {\n         return true;\n     }\n     \n-    public void visitToken(final DetailAST ast) {\n-        if (!this.hasJavadocComment(ast) && canBeOverridden(ast) && (isNativeMethod(ast) || !hasEmptyImplementation(ast)) && !hasIgnoredAnnotation(ast, this.ignoredAnnotations) && !ScopeUtil.isInRecordBlock(ast)) {\n-            final DetailAST classDef = getNearestClassOrEnumDefinition(ast);\n-            if (canBeSubclassed(classDef)) {\n-                final String className = classDef.findFirstToken(58).getText();\n-                final String methodName = ast.findFirstToken(58).getText();\n-                this.log(ast, \"design.forExtension\", new Object[] { className, methodName });\n+    public void visitToken(final DetailAST detailAST) {\n+        if (!this.hasJavadocComment(detailAST) && canBeOverridden(detailAST) && (isNativeMethod(detailAST) || !hasEmptyImplementation(detailAST)) && !hasIgnoredAnnotation(detailAST, this.ignoredAnnotations) && !ScopeUtil.isInRecordBlock(detailAST)) {\n+            final DetailAST nearestClassOrEnumDefinition = getNearestClassOrEnumDefinition(detailAST);\n+            if (canBeSubclassed(nearestClassOrEnumDefinition)) {\n+                this.log(detailAST, \"design.forExtension\", new Object[] { nearestClassOrEnumDefinition.findFirstToken(58).getText(), detailAST.findFirstToken(58).getText() });\n             }\n         }\n     }\n     \n-    private boolean hasJavadocComment(final DetailAST methodDef) {\n-        return this.hasJavadocCommentOnToken(methodDef, 5) || this.hasJavadocCommentOnToken(methodDef, 13);\n+    private boolean hasJavadocComment(final DetailAST detailAST) {\n+        return this.hasJavadocCommentOnToken(detailAST, 5) || this.hasJavadocCommentOnToken(detailAST, 13);\n     }\n     \n-    private boolean hasJavadocCommentOnToken(final DetailAST methodDef, final int tokenType) {\n-        final DetailAST token = methodDef.findFirstToken(tokenType);\n-        return this.branchContainsJavadocComment(token);\n+    private boolean hasJavadocCommentOnToken(final DetailAST detailAST, final int n) {\n+        return this.branchContainsJavadocComment(detailAST.findFirstToken(n));\n     }\n     \n-    private boolean branchContainsJavadocComment(final DetailAST token) {\n-        boolean result = false;\n-        DetailAST toVisit;\n-        for (DetailAST curNode = token; curNode != null; curNode = toVisit) {\n-            if (curNode.getType() == 145 && JavadocUtil.isJavadocComment(curNode)) {\n-                result = this.hasValidJavadocComment(curNode);\n+    private boolean branchContainsJavadocComment(final DetailAST detailAST) {\n+        boolean hasValidJavadocComment = false;\n+        DetailAST detailAST2;\n+        for (DetailAST parent = detailAST; parent != null; parent = detailAST2) {\n+            if (parent.getType() == 145 && JavadocUtil.isJavadocComment(parent)) {\n+                hasValidJavadocComment = this.hasValidJavadocComment(parent);\n                 break;\n             }\n-            for (toVisit = curNode.getFirstChild(); toVisit == null && curNode != token; toVisit = curNode.getNextSibling(), curNode = curNode.getParent()) {}\n+            for (detailAST2 = parent.getFirstChild(); detailAST2 == null && parent != detailAST; detailAST2 = parent.getNextSibling(), parent = parent.getParent()) {}\n         }\n-        return result;\n+        return hasValidJavadocComment;\n     }\n     \n     private boolean hasValidJavadocComment(final DetailAST detailAST) {\n-        final String javadocString = JavadocUtil.getBlockCommentContent(detailAST);\n-        final Matcher requiredJavadocPhraseMatcher = this.requiredJavadocPhrase.matcher(javadocString);\n-        return requiredJavadocPhraseMatcher.find();\n-    }\n-    \n-    private static boolean isNativeMethod(final DetailAST ast) {\n-        final DetailAST mods = ast.findFirstToken(5);\n-        return mods.findFirstToken(66) != null;\n-    }\n-    \n-    private static boolean hasEmptyImplementation(final DetailAST ast) {\n-        boolean hasEmptyBody = true;\n-        final DetailAST methodImplOpenBrace = ast.findFirstToken(7);\n-        final DetailAST methodImplCloseBrace = methodImplOpenBrace.getLastChild();\n-        final Predicate<DetailAST> predicate = currentNode -> currentNode != methodImplCloseBrace && !TokenUtil.isCommentType(currentNode.getType());\n-        final Optional<DetailAST> methodBody = TokenUtil.findFirstTokenByPredicate(methodImplOpenBrace, (Predicate)predicate);\n-        if (methodBody.isPresent()) {\n-            hasEmptyBody = false;\n+        return this.requiredJavadocPhrase.matcher(JavadocUtil.getBlockCommentContent(detailAST)).find();\n+    }\n+    \n+    private static boolean isNativeMethod(final DetailAST detailAST) {\n+        return detailAST.findFirstToken(5).findFirstToken(66) != null;\n+    }\n+    \n+    private static boolean hasEmptyImplementation(final DetailAST detailAST) {\n+        boolean b = true;\n+        if (TokenUtil.findFirstTokenByPredicate(detailAST.findFirstToken(7), detailAST3 -> {\n+            final DetailAST detailAST4;\n+            detailAST4.getLastChild();\n+            return detailAST3 != detailAST2 && !TokenUtil.isCommentType(detailAST3.getType());\n+        }).isPresent()) {\n+            b = false;\n         }\n-        return hasEmptyBody;\n+        return b;\n     }\n     \n-    private static boolean canBeOverridden(final DetailAST methodDef) {\n-        final DetailAST modifiers = methodDef.findFirstToken(5);\n-        return ScopeUtil.getSurroundingScope(methodDef).isIn(Scope.PROTECTED) && !ScopeUtil.isInInterfaceOrAnnotationBlock(methodDef) && modifiers.findFirstToken(61) == null && modifiers.findFirstToken(40) == null && modifiers.findFirstToken(39) == null && modifiers.findFirstToken(64) == null;\n+    private static boolean canBeOverridden(final DetailAST detailAST) {\n+        final DetailAST firstToken = detailAST.findFirstToken(5);\n+        return ScopeUtil.getSurroundingScope(detailAST).isIn(Scope.PROTECTED) && !ScopeUtil.isInInterfaceOrAnnotationBlock(detailAST) && firstToken.findFirstToken(61) == null && firstToken.findFirstToken(40) == null && firstToken.findFirstToken(39) == null && firstToken.findFirstToken(64) == null;\n     }\n     \n-    private static boolean hasIgnoredAnnotation(final DetailAST methodDef, final Set<String> annotations) {\n-        final DetailAST modifiers = methodDef.findFirstToken(5);\n-        final Optional<DetailAST> annotation = TokenUtil.findFirstTokenByPredicate(modifiers, currentToken -> currentToken.getType() == 159 && annotations.contains(getAnnotationName(currentToken)));\n-        return annotation.isPresent();\n+    private static boolean hasIgnoredAnnotation(final DetailAST detailAST, final Set<String> set) {\n+        return TokenUtil.findFirstTokenByPredicate(detailAST.findFirstToken(5), detailAST2 -> detailAST2.getType() == 159 && set2.contains(getAnnotationName(detailAST2))).isPresent();\n     }\n     \n-    private static String getAnnotationName(final DetailAST annotation) {\n-        final DetailAST dotAst = annotation.findFirstToken(59);\n-        final DetailAST parent = (DetailAST)Objects.requireNonNullElse(dotAst, annotation);\n-        return parent.findFirstToken(58).getText();\n+    private static String getAnnotationName(final DetailAST defaultObj) {\n+        return ((DetailAST)Objects.requireNonNullElse(defaultObj.findFirstToken(59), defaultObj)).findFirstToken(58).getText();\n     }\n     \n-    private static DetailAST getNearestClassOrEnumDefinition(final DetailAST ast) {\n-        DetailAST searchAST;\n-        for (searchAST = ast; searchAST.getType() != 14 && searchAST.getType() != 154; searchAST = searchAST.getParent()) {}\n-        return searchAST;\n+    private static DetailAST getNearestClassOrEnumDefinition(final DetailAST detailAST) {\n+        DetailAST parent;\n+        for (parent = detailAST; parent.getType() != 14 && parent.getType() != 154; parent = parent.getParent()) {}\n+        return parent;\n     }\n     \n-    private static boolean canBeSubclassed(final DetailAST classDef) {\n-        final DetailAST modifiers = classDef.findFirstToken(5);\n-        return classDef.getType() != 154 && modifiers.findFirstToken(39) == null && hasDefaultOrExplicitNonPrivateCtor(classDef);\n+    private static boolean canBeSubclassed(final DetailAST detailAST) {\n+        final DetailAST firstToken = detailAST.findFirstToken(5);\n+        return detailAST.getType() != 154 && firstToken.findFirstToken(39) == null && hasDefaultOrExplicitNonPrivateCtor(detailAST);\n     }\n     \n-    private static boolean hasDefaultOrExplicitNonPrivateCtor(final DetailAST classDef) {\n-        final DetailAST objBlock = classDef.findFirstToken(6);\n-        boolean hasDefaultConstructor = true;\n-        boolean hasExplicitNonPrivateCtor = false;\n-        for (DetailAST candidate = objBlock.getFirstChild(); candidate != null; candidate = candidate.getNextSibling()) {\n-            if (candidate.getType() == 8) {\n-                hasDefaultConstructor = false;\n-                final DetailAST ctorMods = candidate.findFirstToken(5);\n-                if (ctorMods.findFirstToken(61) == null) {\n-                    hasExplicitNonPrivateCtor = true;\n+    private static boolean hasDefaultOrExplicitNonPrivateCtor(final DetailAST detailAST) {\n+        final DetailAST firstToken = detailAST.findFirstToken(6);\n+        boolean b = true;\n+        boolean b2 = false;\n+        for (DetailAST detailAST2 = firstToken.getFirstChild(); detailAST2 != null; detailAST2 = detailAST2.getNextSibling()) {\n+            if (detailAST2.getType() == 8) {\n+                b = false;\n+                if (detailAST2.findFirstToken(5).findFirstToken(61) == null) {\n+                    b2 = true;\n                     break;\n                 }\n             }\n         }\n-        return hasDefaultConstructor || hasExplicitNonPrivateCtor;\n+        return b || b2;\n     }\n }\n"}]}
