{"diffoscope-json-version": 1, "source1": "first/MultiReadOnlySeekableByteChannel.class", "source2": "second/MultiReadOnlySeekableByteChannel.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -23,14 +23,18 @@\n public class MultiReadOnlySeekableByteChannel implements SeekableByteChannel\n {\n     private static final Path[] EMPTY_PATH_ARRAY;\n     private final List<SeekableByteChannel> channels;\n     private long globalPosition;\n     private int currentChannelIdx;\n     \n+    static {\n+        EMPTY_PATH_ARRAY = new Path[0];\n+    }\n+    \n     public MultiReadOnlySeekableByteChannel(final List<SeekableByteChannel> channels) {\n         this.channels = Collections.unmodifiableList((List<? extends SeekableByteChannel>)new ArrayList<SeekableByteChannel>(Objects.requireNonNull(channels, \"channels must not be null\")));\n     }\n     \n     @Override\n     public synchronized int read(final ByteBuffer dst) throws IOException {\n         if (!this.isOpen()) {\n@@ -159,28 +163,28 @@\n             return channels[0];\n         }\n         return new MultiReadOnlySeekableByteChannel(Arrays.asList(channels));\n     }\n     \n     public static SeekableByteChannel forFiles(final File... files) throws IOException {\n         final List<Path> paths = new ArrayList<Path>();\n-        for (final File f : (File[])Objects.requireNonNull(files, \"files must not be null\")) {\n+        File[] array;\n+        for (int length = (array = Objects.requireNonNull(files, \"files must not be null\")).length, i = 0; i < length; ++i) {\n+            final File f = array[i];\n             paths.add(f.toPath());\n         }\n         return forPaths((Path[])paths.toArray(MultiReadOnlySeekableByteChannel.EMPTY_PATH_ARRAY));\n     }\n     \n     public static SeekableByteChannel forPaths(final Path... paths) throws IOException {\n         final List<SeekableByteChannel> channels = new ArrayList<SeekableByteChannel>();\n-        for (final Path path : (Path[])Objects.requireNonNull(paths, \"paths must not be null\")) {\n+        Path[] array;\n+        for (int length = (array = Objects.requireNonNull(paths, \"paths must not be null\")).length, i = 0; i < length; ++i) {\n+            final Path path = array[i];\n             channels.add(Files.newByteChannel(path, StandardOpenOption.READ));\n         }\n         if (channels.size() == 1) {\n             return channels.get(0);\n         }\n         return new MultiReadOnlySeekableByteChannel(channels);\n     }\n-    \n-    static {\n-        EMPTY_PATH_ARRAY = new Path[0];\n-    }\n }\n"}]}
