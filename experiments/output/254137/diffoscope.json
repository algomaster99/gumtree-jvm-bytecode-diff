{"diffoscope-json-version": 1, "source1": "first/SiteUtil.class", "source2": "second/SiteUtil.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,15 +1,17 @@\n \n package com.puppycrawl.tools.checkstyle.site;\n \n+import com.puppycrawl.tools.checkstyle.ModuleFactory;\n import java.util.HashMap;\n import com.puppycrawl.tools.checkstyle.api.BeforeExecutionFileFilter;\n import com.puppycrawl.tools.checkstyle.api.Filter;\n import com.puppycrawl.tools.checkstyle.TreeWalkerFilter;\n import java.nio.file.attribute.BasicFileAttributes;\n+import java.lang.reflect.AccessibleObject;\n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.InvocationTargetException;\n import java.util.BitSet;\n import java.util.function.ToIntFunction;\n import java.util.stream.IntStream;\n import java.util.function.IntFunction;\n import com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n@@ -43,15 +45,14 @@\n import java.util.stream.Collectors;\n import java.nio.file.Files;\n import java.nio.file.FileVisitOption;\n import java.nio.file.Paths;\n import java.nio.file.Path;\n import com.puppycrawl.tools.checkstyle.PackageNamesLoader;\n import com.puppycrawl.tools.checkstyle.PackageObjectFactory;\n-import com.puppycrawl.tools.checkstyle.ModuleFactory;\n import com.puppycrawl.tools.checkstyle.api.CheckstyleException;\n import java.util.Locale;\n import com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck;\n import com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck;\n import com.puppycrawl.tools.checkstyle.checks.regexp.RegexpMultilineCheck;\n import java.util.Collection;\n import java.util.HashSet;\n@@ -91,532 +92,505 @@\n     private static final Map<String, DetailNode> SUPER_CLASS_PROPERTIES_JAVADOCS;\n     private static final String MAIN_FOLDER_PATH;\n     private static final List<File> MODULE_SUPER_CLASS_FILES;\n     \n     private SiteUtil() {\n     }\n     \n-    public static Set<String> getMessageKeys(final Class<?> module) throws MacroExecutionException {\n-        final Set<Field> messageKeyFields = getCheckMessageKeys(module);\n-        final Set<String> messageKeys = new TreeSet<String>();\n-        for (final Field field : messageKeyFields) {\n-            messageKeys.add(getFieldValue(field, module).toString());\n+    public static Set<String> getMessageKeys(final Class<?> clazz) throws MacroExecutionException {\n+        final Set<Field> checkMessageKeys = getCheckMessageKeys(clazz);\n+        final TreeSet set = new TreeSet();\n+        final Iterator<Field> iterator = checkMessageKeys.iterator();\n+        while (iterator.hasNext()) {\n+            set.add(getFieldValue(iterator.next(), clazz).toString());\n         }\n-        return messageKeys;\n+        return set;\n     }\n     \n-    private static Set<Field> getCheckMessageKeys(final Class<?> module) throws MacroExecutionException {\n+    private static Set<Field> getCheckMessageKeys(final Class<?> clazz) throws MacroExecutionException {\n         try {\n-            final Set<Field> checkstyleMessages = new HashSet<Field>();\n-            final Field[] declaredFields;\n-            final Field[] fields = declaredFields = module.getDeclaredFields();\n-            for (final Field field : declaredFields) {\n+            final HashSet set = new HashSet();\n+            for (final Field field : clazz.getDeclaredFields()) {\n                 if (field.getName().startsWith(\"MSG_\")) {\n-                    checkstyleMessages.add(field);\n+                    set.add(field);\n                 }\n             }\n-            final Class<?> superModule = module.getSuperclass();\n-            if (superModule != null) {\n-                checkstyleMessages.addAll(getCheckMessageKeys(superModule));\n+            final Class superclass = clazz.getSuperclass();\n+            if (superclass != null) {\n+                set.addAll(getCheckMessageKeys(superclass));\n             }\n-            if (module == RegexpMultilineCheck.class) {\n-                checkstyleMessages.addAll(getCheckMessageKeys(Class.forName(\"com.puppycrawl.tools.checkstyle.checks.regexp.MultilineDetector\")));\n+            if (clazz == RegexpMultilineCheck.class) {\n+                set.addAll(getCheckMessageKeys(Class.forName(\"com.puppycrawl.tools.checkstyle.checks.regexp.MultilineDetector\")));\n             }\n-            else if (module == RegexpSinglelineCheck.class || module == RegexpSinglelineJavaCheck.class) {\n-                checkstyleMessages.addAll(getCheckMessageKeys(Class.forName(\"com.puppycrawl.tools.checkstyle.checks.regexp.SinglelineDetector\")));\n+            else if (clazz == RegexpSinglelineCheck.class || clazz == RegexpSinglelineJavaCheck.class) {\n+                set.addAll(getCheckMessageKeys(Class.forName(\"com.puppycrawl.tools.checkstyle.checks.regexp.SinglelineDetector\")));\n             }\n-            return checkstyleMessages;\n+            return set;\n         }\n         catch (final ClassNotFoundException ex) {\n-            final String message = String.format(Locale.ROOT, \"Couldn't find class: %s\", module.getName());\n-            throw new MacroExecutionException(message, (Throwable)ex);\n+            throw new MacroExecutionException(String.format(Locale.ROOT, \"Couldn't find class: %s\", clazz.getName()), (Throwable)ex);\n         }\n     }\n     \n-    public static Object getFieldValue(final Field field, final Object instance) throws MacroExecutionException {\n+    public static Object getFieldValue(final Field field, final Object obj) throws MacroExecutionException {\n         try {\n             field.trySetAccessible();\n-            return field.get(instance);\n+            return field.get(obj);\n         }\n         catch (final IllegalAccessException ex) {\n             throw new MacroExecutionException(\"Couldn't get field value\", (Throwable)ex);\n         }\n     }\n     \n-    public static Object getModuleInstance(final String moduleName) throws MacroExecutionException {\n-        final ModuleFactory factory = (ModuleFactory)getPackageObjectFactory();\n+    public static Object getModuleInstance(final String s) throws MacroExecutionException {\n+        final PackageObjectFactory packageObjectFactory = getPackageObjectFactory();\n         try {\n-            return factory.createModule(moduleName);\n+            return ((ModuleFactory)packageObjectFactory).createModule(s);\n         }\n         catch (final CheckstyleException ex) {\n-            throw new MacroExecutionException(\"Couldn't find class: \" + moduleName, (Throwable)ex);\n+            throw new MacroExecutionException(\"Couldn't find class: \" + s, (Throwable)ex);\n         }\n     }\n     \n     private static PackageObjectFactory getPackageObjectFactory() throws MacroExecutionException {\n         try {\n-            final ClassLoader cl = ViolationMessagesMacro.class.getClassLoader();\n-            final Set<String> packageNames = PackageNamesLoader.getPackageNames(cl);\n-            return new PackageObjectFactory((Set)packageNames, cl);\n+            final ClassLoader classLoader = ViolationMessagesMacro.class.getClassLoader();\n+            return new PackageObjectFactory(PackageNamesLoader.getPackageNames(classLoader), classLoader);\n         }\n         catch (final CheckstyleException ex) {\n             throw new MacroExecutionException(\"Couldn't load checkstyle modules\", (Throwable)ex);\n         }\n     }\n     \n-    public static String getNewlineAndIndentSpaces(final int amountOfSpaces) {\n-        return System.lineSeparator() + \" \".repeat(amountOfSpaces);\n+    public static String getNewlineAndIndentSpaces(final int count) {\n+        return System.lineSeparator() + \" \".repeat(count);\n     }\n     \n-    public static Path getTemplatePath(final String moduleName) throws MacroExecutionException {\n-        final String fileNamePattern = \".*[\\\\\\\\/]\" + moduleName.toLowerCase(Locale.ROOT) + \"\\\\..*\";\n-        return getXdocsTemplatesFilePaths().stream().filter(path -> path.toString().matches(fileNamePattern)).findFirst().orElse(null);\n+    public static Path getTemplatePath(final String s) throws MacroExecutionException {\n+        return getXdocsTemplatesFilePaths().stream().filter(path -> {\n+            \".*[\\\\\\\\/]\" + s2.toLowerCase(Locale.ROOT) + \"\\\\..*\";\n+            return path.toString().matches(regex);\n+        }).findFirst().orElse(null);\n     }\n     \n     public static Set<Path> getXdocsTemplatesFilePaths() throws MacroExecutionException {\n-        final Path directory = Paths.get(\"src/xdocs\", new String[0]);\n-        try (final Stream<Path> stream = Files.find(directory, Integer.MAX_VALUE, (path, attr) -> attr.isRegularFile() && path.toString().endsWith(\".xml.template\"), new FileVisitOption[0])) {\n-            final Set<? super Path> set = (Set<? super Path>)stream.collect((Collector<? super Path, ?, Set<? super Path>>)Collectors.toSet());\n+        final Path value = Paths.get(\"src/xdocs\", new String[0]);\n+        try (final Stream<Path> find = Files.find(value, Integer.MAX_VALUE, (path, basicFileAttributes) -> basicFileAttributes.isRegularFile() && path.toString().endsWith(\".xml.template\"), new FileVisitOption[0])) {\n+            final Set<Object> set = (Set<Object>)find.collect(Collectors.toSet());\n             return (Set<Path>)set;\n         }\n-        catch (final IOException ioException) {\n-            throw new MacroExecutionException(\"Failed to find xdocs templates\", (Throwable)ioException);\n+        catch (final IOException ex) {\n+            throw new MacroExecutionException(\"Failed to find xdocs templates\", (Throwable)ex);\n         }\n     }\n     \n-    public static String getParentModule(final Class<?> moduleClass) throws MacroExecutionException {\n-        String parentModuleName = \"\";\n-        for (Class<?> parentClass = moduleClass.getSuperclass(); parentClass != null; parentClass = parentClass.getSuperclass()) {\n-            parentModuleName = SiteUtil.CLASS_TO_PARENT_MODULE.get(parentClass);\n-            if (parentModuleName != null) {\n+    public static String getParentModule(final Class<?> clazz) throws MacroExecutionException {\n+        String s = \"\";\n+        for (Class<?> clazz2 = clazz.getSuperclass(); clazz2 != null; clazz2 = clazz2.getSuperclass()) {\n+            s = SiteUtil.CLASS_TO_PARENT_MODULE.get(clazz2);\n+            if (s != null) {\n                 break;\n             }\n         }\n-        if (parentModuleName == null || parentModuleName.isEmpty()) {\n-            final Class<?>[] interfaces2;\n-            final Class<?>[] interfaces = interfaces2 = moduleClass.getInterfaces();\n-            for (final Class<?> interfaceClass : interfaces2) {\n-                parentModuleName = SiteUtil.CLASS_TO_PARENT_MODULE.get(interfaceClass);\n-                if (parentModuleName != null) {\n+        if (s == null || s.isEmpty()) {\n+            final Class[] interfaces = clazz.getInterfaces();\n+            for (int length = interfaces.length, i = 0; i < length; ++i) {\n+                s = SiteUtil.CLASS_TO_PARENT_MODULE.get(interfaces[i]);\n+                if (s != null) {\n                     break;\n                 }\n             }\n         }\n-        if (parentModuleName == null || parentModuleName.isEmpty()) {\n-            final String message = String.format(Locale.ROOT, \"Failed to find parent module for %s\", moduleClass.getSimpleName());\n-            throw new MacroExecutionException(message);\n+        if (s == null || s.isEmpty()) {\n+            throw new MacroExecutionException(String.format(Locale.ROOT, \"Failed to find parent module for %s\", clazz.getSimpleName()));\n         }\n-        return parentModuleName;\n+        return s;\n     }\n     \n-    public static Set<String> getPropertiesForDocumentation(final Class<?> clss, final Object instance) {\n-        final Set<String> properties = (Set<String>)getProperties(clss).stream().filter(prop -> !isGlobalProperty(clss, prop) && !isUndocumentedProperty(clss, prop)).collect((Collector<? super Object, ?, Set<String>>)Collectors.toSet());\n-        properties.addAll(getNonExplicitProperties(instance, clss));\n-        return new TreeSet<String>(properties);\n+    public static Set<String> getPropertiesForDocumentation(final Class<?> clazz, final Object o) {\n+        final Set<? super Object> c = (Set<? super Object>)getProperties(clazz).stream().filter(s -> !isGlobalProperty(clazz2, s) && !isUndocumentedProperty(clazz2, s)).collect((Collector<? super Object, ?, Set<? super Object>>)Collectors.toSet());\n+        c.addAll(getNonExplicitProperties(o, clazz));\n+        return new TreeSet<String>((Collection<? extends String>)c);\n     }\n     \n-    public static Map<String, DetailNode> getPropertiesJavadocs(final Set<String> properties, final String moduleName, final File moduleFile) throws MacroExecutionException {\n+    public static Map<String, DetailNode> getPropertiesJavadocs(final Set<String> set, final String s, final File file) throws MacroExecutionException {\n         if (SiteUtil.SUPER_CLASS_PROPERTIES_JAVADOCS.isEmpty()) {\n             processSuperclasses();\n         }\n-        processModule(moduleName, moduleFile);\n-        final Map<String, DetailNode> unmodifiableJavadocs = ClassAndPropertiesSettersJavadocScraper.getJavadocsForModuleOrProperty();\n-        final Map<String, DetailNode> javadocs = new LinkedHashMap<String, DetailNode>(unmodifiableJavadocs);\n-        properties.forEach(property -> {\n-            final DetailNode superClassPropertyJavadoc = (DetailNode)SiteUtil.SUPER_CLASS_PROPERTIES_JAVADOCS.get(property);\n-            if (superClassPropertyJavadoc != null) {\n-                javadocs.putIfAbsent(property, superClassPropertyJavadoc);\n+        processModule(s, file);\n+        final LinkedHashMap linkedHashMap = new LinkedHashMap(ClassAndPropertiesSettersJavadocScraper.getJavadocsForModuleOrProperty());\n+        set.forEach(key -> {\n+            final DetailNode value = (DetailNode)SiteUtil.SUPER_CLASS_PROPERTIES_JAVADOCS.get(key);\n+            if (value != null) {\n+                map.putIfAbsent(key, value);\n             }\n             return;\n         });\n-        assertAllPropertySetterJavadocsAreFound(properties, moduleName, javadocs);\n-        return javadocs;\n+        assertAllPropertySetterJavadocsAreFound(set, s, linkedHashMap);\n+        return linkedHashMap;\n     }\n     \n-    private static void assertAllPropertySetterJavadocsAreFound(final Set<String> properties, final String moduleName, final Map<String, DetailNode> javadocs) throws MacroExecutionException {\n-        for (final String property : properties) {\n-            final boolean isPropertySetterJavadocFound = javadocs.containsKey(property) || \"tokens\".equals(property) || \"javadocTokens\".equals(property);\n-            if (!isPropertySetterJavadocFound) {\n-                final String message = String.format(Locale.ROOT, \"%s: Failed to find setter javadoc for property '%s'\", moduleName, property);\n-                throw new MacroExecutionException(message);\n+    private static void assertAllPropertySetterJavadocsAreFound(final Set<String> set, final String s, final Map<String, DetailNode> map) throws MacroExecutionException {\n+        for (final String s2 : set) {\n+            if (!map.containsKey(s2) && !\"tokens\".equals(s2) && !\"javadocTokens\".equals(s2)) {\n+                throw new MacroExecutionException(String.format(Locale.ROOT, \"%s: Failed to find setter javadoc for property '%s'\", s, s2));\n             }\n         }\n     }\n     \n     private static void processSuperclasses() throws MacroExecutionException {\n-        for (final File superclassFile : SiteUtil.MODULE_SUPER_CLASS_FILES) {\n-            final String superclassName = CommonUtil.getFileNameWithoutExtension(superclassFile.getName());\n-            processModule(superclassName, superclassFile);\n-            final Map<String, DetailNode> superclassJavadocs = ClassAndPropertiesSettersJavadocScraper.getJavadocsForModuleOrProperty();\n-            SiteUtil.SUPER_CLASS_PROPERTIES_JAVADOCS.putAll(superclassJavadocs);\n+        for (final File file : SiteUtil.MODULE_SUPER_CLASS_FILES) {\n+            processModule(CommonUtil.getFileNameWithoutExtension(file.getName()), file);\n+            SiteUtil.SUPER_CLASS_PROPERTIES_JAVADOCS.putAll(ClassAndPropertiesSettersJavadocScraper.getJavadocsForModuleOrProperty());\n         }\n     }\n     \n-    private static void processModule(final String moduleName, final File moduleFile) throws MacroExecutionException {\n-        if (!moduleFile.isFile()) {\n-            final String message = String.format(Locale.ROOT, \"File %s is not a file. Please check the 'modulePath' property.\", moduleFile);\n-            throw new MacroExecutionException(message);\n+    private static void processModule(final String s, final File e1) throws MacroExecutionException {\n+        if (!e1.isFile()) {\n+            throw new MacroExecutionException(String.format(Locale.ROOT, \"File %s is not a file. Please check the 'modulePath' property.\", e1));\n         }\n-        ClassAndPropertiesSettersJavadocScraper.initialize(moduleName);\n+        ClassAndPropertiesSettersJavadocScraper.initialize(s);\n         final Checker checker = new Checker();\n         checker.setModuleClassLoader(Checker.class.getClassLoader());\n-        final DefaultConfiguration scraperCheckConfig = new DefaultConfiguration(ClassAndPropertiesSettersJavadocScraper.class.getName());\n-        final DefaultConfiguration defaultConfiguration = new DefaultConfiguration(\"configuration\");\n-        final DefaultConfiguration treeWalkerConfig = new DefaultConfiguration(TreeWalker.class.getName());\n-        defaultConfiguration.addProperty(\"charset\", StandardCharsets.UTF_8.name());\n-        defaultConfiguration.addChild((Configuration)treeWalkerConfig);\n-        treeWalkerConfig.addChild((Configuration)scraperCheckConfig);\n+        final DefaultConfiguration defaultConfiguration = new DefaultConfiguration(ClassAndPropertiesSettersJavadocScraper.class.getName());\n+        final DefaultConfiguration defaultConfiguration2 = new DefaultConfiguration(\"configuration\");\n+        final DefaultConfiguration defaultConfiguration3 = new DefaultConfiguration(TreeWalker.class.getName());\n+        defaultConfiguration2.addProperty(\"charset\", StandardCharsets.UTF_8.name());\n+        defaultConfiguration2.addChild((Configuration)defaultConfiguration3);\n+        defaultConfiguration3.addChild((Configuration)defaultConfiguration);\n         try {\n-            checker.configure((Configuration)defaultConfiguration);\n-            final List<File> filesToProcess = List.of(moduleFile);\n-            checker.process((List)filesToProcess);\n+            checker.configure((Configuration)defaultConfiguration2);\n+            checker.process((List)List.of(e1));\n             checker.destroy();\n         }\n-        catch (final CheckstyleException checkstyleException) {\n-            final String message2 = String.format(Locale.ROOT, \"Failed processing %s\", moduleName);\n-            throw new MacroExecutionException(message2, (Throwable)checkstyleException);\n+        catch (final CheckstyleException ex) {\n+            throw new MacroExecutionException(String.format(Locale.ROOT, \"Failed processing %s\", s), (Throwable)ex);\n         }\n     }\n     \n-    public static Set<String> getProperties(final Class<?> clss) {\n-        final Set<String> result = new TreeSet<String>();\n-        final PropertyDescriptor[] propertyDescriptors2;\n-        final PropertyDescriptor[] propertyDescriptors = propertyDescriptors2 = PropertyUtils.getPropertyDescriptors((Class)clss);\n-        for (final PropertyDescriptor propertyDescriptor : propertyDescriptors2) {\n+    public static Set<String> getProperties(final Class<?> clazz) {\n+        final TreeSet set = new TreeSet();\n+        for (final PropertyDescriptor propertyDescriptor : PropertyUtils.getPropertyDescriptors((Class)clazz)) {\n             if (propertyDescriptor.getWriteMethod() != null) {\n-                result.add(propertyDescriptor.getName());\n+                set.add(propertyDescriptor.getName());\n             }\n         }\n-        return result;\n+        return set;\n     }\n     \n-    private static boolean isGlobalProperty(final Class<?> clss, final String propertyName) {\n-        return (AbstractCheck.class.isAssignableFrom(clss) && SiteUtil.CHECK_PROPERTIES.contains(propertyName)) || (AbstractJavadocCheck.class.isAssignableFrom(clss) && SiteUtil.JAVADOC_CHECK_PROPERTIES.contains(propertyName)) || (AbstractFileSetCheck.class.isAssignableFrom(clss) && SiteUtil.FILESET_PROPERTIES.contains(propertyName));\n+    private static boolean isGlobalProperty(final Class<?> clazz, final String s) {\n+        return (AbstractCheck.class.isAssignableFrom(clazz) && SiteUtil.CHECK_PROPERTIES.contains(s)) || (AbstractJavadocCheck.class.isAssignableFrom(clazz) && SiteUtil.JAVADOC_CHECK_PROPERTIES.contains(s)) || (AbstractFileSetCheck.class.isAssignableFrom(clazz) && SiteUtil.FILESET_PROPERTIES.contains(s));\n     }\n     \n-    private static boolean isUndocumentedProperty(final Class<?> clss, final String propertyName) {\n-        return SiteUtil.UNDOCUMENTED_PROPERTIES.contains(clss.getSimpleName() + \".\" + propertyName);\n+    private static boolean isUndocumentedProperty(final Class<?> clazz, final String s) {\n+        return SiteUtil.UNDOCUMENTED_PROPERTIES.contains(clazz.getSimpleName() + \".\" + s);\n     }\n     \n-    private static Set<String> getNonExplicitProperties(final Object instance, final Class<?> clss) {\n-        final Set<String> result = new TreeSet<String>();\n-        if (AbstractCheck.class.isAssignableFrom(clss)) {\n-            final AbstractCheck check = (AbstractCheck)instance;\n-            final int[] acceptableTokens = check.getAcceptableTokens();\n+    private static Set<String> getNonExplicitProperties(final Object o, final Class<?> clazz) {\n+        final TreeSet set = new TreeSet();\n+        if (AbstractCheck.class.isAssignableFrom(clazz)) {\n+            final AbstractCheck abstractCheck = (AbstractCheck)o;\n+            final int[] acceptableTokens = abstractCheck.getAcceptableTokens();\n             Arrays.sort(acceptableTokens);\n-            final int[] defaultTokens = check.getDefaultTokens();\n+            final int[] defaultTokens = abstractCheck.getDefaultTokens();\n             Arrays.sort(defaultTokens);\n-            final int[] requiredTokens = check.getRequiredTokens();\n+            final int[] requiredTokens = abstractCheck.getRequiredTokens();\n             Arrays.sort(requiredTokens);\n             if (!Arrays.equals(acceptableTokens, defaultTokens) || !Arrays.equals(acceptableTokens, requiredTokens)) {\n-                result.add(\"tokens\");\n+                set.add(\"tokens\");\n             }\n         }\n-        if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n-            final AbstractJavadocCheck check2 = (AbstractJavadocCheck)instance;\n-            result.add(\"violateExecutionOnNonTightHtml\");\n-            final int[] acceptableJavadocTokens = check2.getAcceptableJavadocTokens();\n+        if (AbstractJavadocCheck.class.isAssignableFrom(clazz)) {\n+            final AbstractJavadocCheck abstractJavadocCheck = (AbstractJavadocCheck)o;\n+            set.add(\"violateExecutionOnNonTightHtml\");\n+            final int[] acceptableJavadocTokens = abstractJavadocCheck.getAcceptableJavadocTokens();\n             Arrays.sort(acceptableJavadocTokens);\n-            final int[] defaultJavadocTokens = check2.getDefaultJavadocTokens();\n+            final int[] defaultJavadocTokens = abstractJavadocCheck.getDefaultJavadocTokens();\n             Arrays.sort(defaultJavadocTokens);\n-            final int[] requiredJavadocTokens = check2.getRequiredJavadocTokens();\n+            final int[] requiredJavadocTokens = abstractJavadocCheck.getRequiredJavadocTokens();\n             Arrays.sort(requiredJavadocTokens);\n             if (!Arrays.equals(acceptableJavadocTokens, defaultJavadocTokens) || !Arrays.equals(acceptableJavadocTokens, requiredJavadocTokens)) {\n-                result.add(\"javadocTokens\");\n+                set.add(\"javadocTokens\");\n             }\n         }\n-        if (AbstractFileSetCheck.class.isAssignableFrom(clss)) {\n-            result.add(\"fileExtensions\");\n+        if (AbstractFileSetCheck.class.isAssignableFrom(clazz)) {\n+            set.add(\"fileExtensions\");\n         }\n-        return result;\n+        return set;\n     }\n     \n-    public static String getPropertyDescription(final String propertyName, final DetailNode javadoc, final String moduleName) throws MacroExecutionException {\n-        String description;\n-        if (\"tokens\".equals(propertyName)) {\n-            description = \"tokens to check\";\n+    public static String getPropertyDescription(final String s, final DetailNode detailNode, final String s2) throws MacroExecutionException {\n+        String s3;\n+        if (\"tokens\".equals(s)) {\n+            s3 = \"tokens to check\";\n         }\n-        else if (\"javadocTokens\".equals(propertyName)) {\n-            description = \"javadoc tokens to check\";\n+        else if (\"javadocTokens\".equals(s)) {\n+            s3 = \"javadoc tokens to check\";\n         }\n         else {\n-            final String descriptionString = SiteUtil.DescriptionExtractor.getDescriptionFromJavadoc(javadoc, moduleName).substring(\"Setter to \".length());\n-            final String firstLetterCapitalized = descriptionString.substring(0, 1).toUpperCase(Locale.ROOT);\n-            description = firstLetterCapitalized + descriptionString.substring(1);\n+            final String substring = SiteUtil.DescriptionExtractor.getDescriptionFromJavadoc(detailNode, s2).substring(\"Setter to \".length());\n+            s3 = substring.substring(0, 1).toUpperCase(Locale.ROOT) + substring.substring(1);\n         }\n-        return description;\n+        return s3;\n     }\n     \n-    public static String getSinceVersion(final String moduleName, final DetailNode moduleJavadoc, final String propertyName, final DetailNode propertyJavadoc) throws MacroExecutionException {\n-        String sinceVersion;\n-        if (SiteUtil.SINCE_VERSION_FOR_INHERITED_PROPERTY.containsKey(moduleName + \".\" + propertyName)) {\n-            sinceVersion = SiteUtil.SINCE_VERSION_FOR_INHERITED_PROPERTY.get(moduleName + \".\" + propertyName);\n+    public static String getSinceVersion(final String s, final DetailNode detailNode, final String s2, final DetailNode detailNode2) throws MacroExecutionException {\n+        String s3;\n+        if (SiteUtil.SINCE_VERSION_FOR_INHERITED_PROPERTY.containsKey(s + \".\" + s2)) {\n+            s3 = SiteUtil.SINCE_VERSION_FOR_INHERITED_PROPERTY.get(s + \".\" + s2);\n         }\n-        else if (SiteUtil.SUPER_CLASS_PROPERTIES_JAVADOCS.containsKey(propertyName) || \"tokens\".equals(propertyName) || \"javadocTokens\".equals(propertyName)) {\n-            sinceVersion = getSinceVersionFromJavadoc(moduleJavadoc);\n+        else if (SiteUtil.SUPER_CLASS_PROPERTIES_JAVADOCS.containsKey(s2) || \"tokens\".equals(s2) || \"javadocTokens\".equals(s2)) {\n+            s3 = getSinceVersionFromJavadoc(detailNode);\n         }\n         else {\n-            sinceVersion = getSinceVersionFromJavadoc(propertyJavadoc);\n+            s3 = getSinceVersionFromJavadoc(detailNode2);\n         }\n-        if (sinceVersion == null) {\n-            final String message = String.format(Locale.ROOT, \"Failed to find since version for %s\", propertyName);\n-            throw new MacroExecutionException(message);\n-        }\n-        return sinceVersion;\n-    }\n-    \n-    private static String getSinceVersionFromJavadoc(final DetailNode javadoc) {\n-        final DetailNode sinceJavadocTag = getSinceJavadocTag(javadoc);\n-        final DetailNode description = JavadocUtil.findFirstToken(sinceJavadocTag, 10068);\n-        final DetailNode text = JavadocUtil.findFirstToken(description, 10074);\n-        return text.getText();\n-    }\n-    \n-    private static DetailNode getSinceJavadocTag(final DetailNode javadoc) {\n-        final DetailNode[] children = javadoc.getChildren();\n-        DetailNode javadocTagWithSince = null;\n-        for (final DetailNode child : children) {\n-            if (child.getType() == 10071) {\n-                final DetailNode sinceNode = JavadocUtil.findFirstToken(child, 16);\n-                if (sinceNode != null) {\n-                    javadocTagWithSince = child;\n-                    break;\n-                }\n+        if (s3 == null) {\n+            throw new MacroExecutionException(String.format(Locale.ROOT, \"Failed to find since version for %s\", s2));\n+        }\n+        return s3;\n+    }\n+    \n+    private static String getSinceVersionFromJavadoc(final DetailNode detailNode) {\n+        return JavadocUtil.findFirstToken(JavadocUtil.findFirstToken(getSinceJavadocTag(detailNode), 10068), 10074).getText();\n+    }\n+    \n+    private static DetailNode getSinceJavadocTag(final DetailNode detailNode) {\n+        final DetailNode[] children = detailNode.getChildren();\n+        DetailNode detailNode2 = null;\n+        for (final DetailNode detailNode3 : children) {\n+            if (detailNode3.getType() == 10071 && JavadocUtil.findFirstToken(detailNode3, 16) != null) {\n+                detailNode2 = detailNode3;\n+                break;\n             }\n         }\n-        return javadocTagWithSince;\n+        return detailNode2;\n     }\n     \n-    public static String getType(final Field field, final String propertyName, final String moduleName, final Object instance) throws MacroExecutionException {\n-        final Class<?> fieldClass = getFieldClass(field, propertyName, moduleName, instance);\n-        final Optional<Object> map = Optional.ofNullable(field).map(nonNullField -> (XdocsPropertyType)nonNullField.getAnnotation(XdocsPropertyType.class)).map(propertyType -> propertyType.value().getDescription());\n+    public static String getType(final Field value, final String s, final String s2, final Object o) throws MacroExecutionException {\n+        final Class<?> fieldClass = getFieldClass(value, s, s2, o);\n+        final Optional<Object> map = Optional.ofNullable(value).map(field -> (XdocsPropertyType)field.getAnnotation(XdocsPropertyType.class)).map(xdocsPropertyType -> xdocsPropertyType.value().getDescription());\n         final Class<?> obj = fieldClass;\n         Objects.requireNonNull(obj);\n         return map.orElseGet(obj::getSimpleName);\n     }\n     \n-    public static String getDefaultValue(final String propertyName, final Field field, final Object classInstance, final String moduleName) throws MacroExecutionException {\n-        final Object value = getFieldValue(field, classInstance);\n-        final Class<?> fieldClass = getFieldClass(field, propertyName, moduleName, classInstance);\n-        String result = null;\n-        if (\"charset\".equals(propertyName)) {\n-            result = \"the charset property of the parent Checker module\";\n+    public static String getDefaultValue(final String anObject, final Field field, final Object o, final String s) throws MacroExecutionException {\n+        final Object fieldValue = getFieldValue(field, o);\n+        final Class<?> fieldClass = getFieldClass(field, anObject, s, o);\n+        String s2 = null;\n+        if (\"charset\".equals(anObject)) {\n+            s2 = \"the charset property of the parent Checker module\";\n         }\n-        else if (classInstance instanceof PropertyCacheFile) {\n-            result = \"null (no cache file)\";\n+        else if (o instanceof PropertyCacheFile) {\n+            s2 = \"null (no cache file)\";\n         }\n         else if (fieldClass == Boolean.TYPE) {\n-            result = value.toString();\n+            s2 = fieldValue.toString();\n         }\n         else if (fieldClass == Integer.TYPE) {\n-            result = value.toString();\n+            s2 = fieldValue.toString();\n         }\n         else if (fieldClass == int[].class) {\n-            result = getIntArrayPropertyValue(value);\n+            s2 = getIntArrayPropertyValue(fieldValue);\n         }\n         else if (fieldClass == double[].class) {\n-            result = removeSquareBrackets(Arrays.toString((double[])value).replace((CharSequence)\".0\", (CharSequence)\"\"));\n-            if (result.isEmpty()) {\n-                result = \"{}\";\n+            s2 = removeSquareBrackets(Arrays.toString((double[])fieldValue).replace((CharSequence)\".0\", (CharSequence)\"\"));\n+            if (s2.isEmpty()) {\n+                s2 = \"{}\";\n             }\n         }\n         else if (fieldClass == String[].class) {\n-            result = getStringArrayPropertyValue(propertyName, value);\n+            s2 = getStringArrayPropertyValue(anObject, fieldValue);\n         }\n         else if (fieldClass == URI.class || fieldClass == String.class) {\n-            if (value != null) {\n-                result = \"\\\"\" + value.toString();\n+            if (fieldValue != null) {\n+                s2 = \"\\\"\" + fieldValue.toString();\n             }\n         }\n         else if (fieldClass == Pattern.class) {\n-            if (value != null) {\n-                result = \"\\\"\" + value.toString().replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\").replace(\"\\r\", \"\\\\r\").replace((CharSequence)\"\\f\", (CharSequence)\"\\\\f\");\n+            if (fieldValue != null) {\n+                s2 = \"\\\"\" + fieldValue.toString().replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\").replace(\"\\r\", \"\\\\r\").replace((CharSequence)\"\\f\", (CharSequence)\"\\\\f\");\n             }\n         }\n         else if (fieldClass == Pattern[].class) {\n-            result = getPatternArrayPropertyValue(value);\n+            s2 = getPatternArrayPropertyValue(fieldValue);\n         }\n         else if (fieldClass.isEnum()) {\n-            if (value != null) {\n-                result = value.toString().toLowerCase(Locale.ENGLISH);\n+            if (fieldValue != null) {\n+                s2 = fieldValue.toString().toLowerCase(Locale.ENGLISH);\n             }\n         }\n         else {\n             if (fieldClass != AccessModifierOption[].class) {\n-                final String message = String.format(Locale.ROOT, \"Unknown property type: %s\", fieldClass.getSimpleName());\n-                throw new MacroExecutionException(message);\n+                throw new MacroExecutionException(String.format(Locale.ROOT, \"Unknown property type: %s\", fieldClass.getSimpleName()));\n             }\n-            result = removeSquareBrackets(Arrays.toString((Object[])value));\n+            s2 = removeSquareBrackets(Arrays.toString((Object[])fieldValue));\n         }\n-        if (result == null) {\n-            result = \"null\";\n+        if (s2 == null) {\n+            s2 = \"null\";\n         }\n-        return result;\n+        return s2;\n     }\n     \n-    private static String getPatternArrayPropertyValue(final Object fieldValue) {\n-        Object value = fieldValue;\n-        if (value instanceof Collection) {\n-            final Collection<?> collection = (Collection)value;\n-            final Stream<?> stream = collection.stream();\n+    private static String getPatternArrayPropertyValue(final Object o) {\n+        Object array = o;\n+        if (array instanceof Collection) {\n+            final Stream stream = ((Collection)array).stream();\n             final Class<Pattern> obj = Pattern.class;\n             Objects.requireNonNull(obj);\n-            value = stream.map((Function<?, ?>)obj::cast).toArray(Pattern[]::new);\n+            array = stream.map(obj::cast).toArray(Pattern[]::new);\n         }\n-        String result = \"\";\n-        if (value != null && Array.getLength(value) > 0) {\n-            result = removeSquareBrackets(Arrays.stream((Pattern[])value).map((Function<? super Pattern, ?>)Pattern::pattern).collect((Collector<? super Object, ?, String>)Collectors.joining(\", \")));\n+        String removeSquareBrackets = \"\";\n+        if (array != null && Array.getLength(array) > 0) {\n+            removeSquareBrackets = removeSquareBrackets(Arrays.stream((Object[])(T[])array).map((Function<? super Object, ?>)Pattern::pattern).collect((Collector<? super Object, ?, String>)Collectors.joining(\", \")));\n         }\n-        if (result.isEmpty()) {\n-            result = \"{}\";\n+        if (removeSquareBrackets.isEmpty()) {\n+            removeSquareBrackets = \"{}\";\n         }\n-        return result;\n+        return removeSquareBrackets;\n     }\n     \n-    private static String removeSquareBrackets(final String value) {\n-        return value.replace(\"[\", \"\").replace(\"]\", \"\");\n+    private static String removeSquareBrackets(final String s) {\n+        return s.replace(\"[\", \"\").replace(\"]\", \"\");\n     }\n     \n-    private static String getStringArrayPropertyValue(final String propertyName, final Object value) {\n-        String result;\n-        if (value == null) {\n-            result = \"\";\n+    private static String getStringArrayPropertyValue(final String anObject, final Object o) {\n+        String s;\n+        if (o == null) {\n+            s = \"\";\n         }\n         else {\n-            try (final Stream<?> valuesStream = getValuesStream(value)) {\n+            try (final Stream<?> valuesStream = getValuesStream(o)) {\n                 final Stream<?> stream = valuesStream;\n                 final Class<String> obj = String.class;\n                 Objects.requireNonNull(obj);\n-                result = stream.map((Function<?, ?>)obj::cast).sorted().collect((Collector<? super Object, ?, String>)Collectors.joining(\", \"));\n+                s = stream.map((Function<?, ?>)obj::cast).sorted().collect((Collector<? super Object, ?, String>)Collectors.joining(\", \"));\n             }\n         }\n-        if (result.isEmpty()) {\n-            if (\"fileExtensions\".equals(propertyName)) {\n-                result = \"all files\";\n+        if (s.isEmpty()) {\n+            if (\"fileExtensions\".equals(anObject)) {\n+                s = \"all files\";\n             }\n             else {\n-                result = \"{}\";\n+                s = \"{}\";\n             }\n         }\n-        return result;\n+        return s;\n     }\n     \n-    private static Stream<?> getValuesStream(final Object value) {\n-        Stream<?> valuesStream;\n-        if (value instanceof Collection) {\n-            final Collection<?> collection = (Collection)value;\n-            valuesStream = collection.stream();\n+    private static Stream<?> getValuesStream(final Object o) {\n+        Stream<Object> stream;\n+        if (o instanceof Collection) {\n+            stream = ((Collection)o).stream();\n         }\n         else {\n-            final Object[] array = (Object[])value;\n-            valuesStream = Arrays.stream(array);\n+            stream = Arrays.stream((Object[])o);\n         }\n-        return valuesStream;\n+        return stream;\n     }\n     \n-    private static String getIntArrayPropertyValue(final Object value) {\n-        try (final IntStream stream = getIntStream(value)) {\n-            String result = (String)stream.mapToObj((IntFunction<?>)TokenUtil::getTokenName).sorted().collect((Collector<? super Object, ?, String>)Collectors.joining(\", \"));\n-            if (result.isEmpty()) {\n-                result = \"{}\";\n+    private static String getIntArrayPropertyValue(final Object o) {\n+        try (final IntStream intStream = getIntStream(o)) {\n+            String s = (String)intStream.mapToObj((IntFunction<?>)TokenUtil::getTokenName).sorted().collect((Collector<? super Object, ?, String>)Collectors.joining(\", \"));\n+            if (s.isEmpty()) {\n+                s = \"{}\";\n             }\n-            return result;\n+            return s;\n         }\n     }\n     \n-    private static IntStream getIntStream(final Object value) {\n-        IntStream stream;\n-        if (value instanceof Collection) {\n-            final Collection<?> collection = (Collection)value;\n-            final Stream<?> stream2 = collection.stream();\n+    private static IntStream getIntStream(final Object o) {\n+        IntStream intStream;\n+        if (o instanceof Collection) {\n+            final Stream stream = ((Collection)o).stream();\n             final Class<Integer> type = Integer.TYPE;\n             Objects.requireNonNull(type);\n-            stream = stream2.mapToInt(type::cast);\n+            intStream = stream.mapToInt(type::cast);\n         }\n-        else if (value instanceof BitSet) {\n-            stream = ((BitSet)value).stream();\n+        else if (o instanceof BitSet) {\n+            intStream = ((BitSet)o).stream();\n         }\n         else {\n-            stream = Arrays.stream((int[])value);\n+            intStream = Arrays.stream((int[])o);\n         }\n-        return stream;\n+        return intStream;\n     }\n     \n-    private static Class<?> getFieldClass(final Field field, final String propertyName, final String moduleName, final Object instance) throws MacroExecutionException {\n-        Class<?> result = null;\n+    private static Class<?> getFieldClass(final Field field, final String s, final String s2, final Object o) throws MacroExecutionException {\n+        Class<?> clazz = null;\n         if (field != null) {\n-            result = field.getType();\n+            clazz = field.getType();\n         }\n-        if (result == null) {\n-            if (!SiteUtil.PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD.contains(moduleName + \".\" + propertyName)) {\n-                throw new MacroExecutionException(\"Could not find field \" + propertyName + \" in class \" + moduleName);\n+        if (clazz == null) {\n+            if (!SiteUtil.PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD.contains(s2 + \".\" + s)) {\n+                throw new MacroExecutionException(\"Could not find field \" + s + \" in class \" + s2);\n             }\n             try {\n-                final PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(instance, propertyName);\n-                result = descriptor.getPropertyType();\n+                clazz = PropertyUtils.getPropertyDescriptor(o, s).getPropertyType();\n             }\n-            catch (final IllegalAccessException | InvocationTargetException | NoSuchMethodException exc) {\n-                throw new MacroExecutionException(exc.getMessage(), (Throwable)exc);\n+            catch (final IllegalAccessException | InvocationTargetException | NoSuchMethodException ex) {\n+                throw new MacroExecutionException(((Throwable)ex).getMessage(), (Throwable)ex);\n             }\n         }\n-        if (field != null && (result == List.class || result == Set.class)) {\n-            final ParameterizedType type = (ParameterizedType)field.getGenericType();\n-            final Class<?> parameterClass = (Class)type.getActualTypeArguments()[0];\n-            if (parameterClass == Integer.class) {\n-                result = int[].class;\n+        if (field != null && (clazz == List.class || clazz == Set.class)) {\n+            final Class clazz2 = (Class)((ParameterizedType)field.getGenericType()).getActualTypeArguments()[0];\n+            if (clazz2 == Integer.class) {\n+                clazz = int[].class;\n             }\n-            else if (parameterClass == String.class) {\n-                result = String[].class;\n+            else if (clazz2 == String.class) {\n+                clazz = String[].class;\n             }\n             else {\n-                if (parameterClass != Pattern.class) {\n-                    final String message = \"Unknown parameterized type: \" + parameterClass.getSimpleName();\n-                    throw new MacroExecutionException(message);\n+                if (clazz2 != Pattern.class) {\n+                    throw new MacroExecutionException(\"Unknown parameterized type: \" + clazz2.getSimpleName());\n                 }\n-                result = Pattern[].class;\n+                clazz = Pattern[].class;\n             }\n         }\n-        else if (result == BitSet.class) {\n-            result = int[].class;\n+        else if (clazz == BitSet.class) {\n+            clazz = int[].class;\n         }\n-        return result;\n+        return clazz;\n     }\n     \n-    public static List<Integer> getDifference(final int[] tokens, final int... subtractions) {\n-        final Set<Integer> subtractionsSet = (Set<Integer>)Arrays.stream(subtractions).boxed().collect((Collector<? super Integer, ?, Set<Integer>>)Collectors.toSet());\n-        return Arrays.stream(tokens).boxed().filter(token -> !subtractionsSet.contains(token)).collect((Collector<? super Integer, ?, List<Integer>>)Collectors.toList());\n+    public static List<Integer> getDifference(final int[] array, final int... array2) {\n+        return Arrays.stream(array).boxed().filter(n -> {\n+            final Object o = (Set<? super Integer>)Arrays.stream(array3).boxed().collect((Collector<? super Integer, ?, Set<? super Integer>>)Collectors.toSet());\n+            return !set.contains(n);\n+        }).collect((Collector<? super Integer, ?, List<Integer>>)Collectors.toList());\n     }\n     \n-    public static Field getField(final Class<?> fieldClass, final String propertyName) {\n-        Field result = null;\n-        Class<?> currentClass = fieldClass;\n-        while (!Object.class.equals(currentClass)) {\n+    public static Field getField(final Class<?> clazz, final String name) {\n+        AccessibleObject declaredField = null;\n+        Class<?> superclass = clazz;\n+        while (!Object.class.equals(superclass)) {\n             try {\n-                result = currentClass.getDeclaredField(propertyName);\n-                result.trySetAccessible();\n+                declaredField = superclass.getDeclaredField(name);\n+                declaredField.trySetAccessible();\n             }\n-            catch (final NoSuchFieldException ignored) {\n-                currentClass = currentClass.getSuperclass();\n+            catch (final NoSuchFieldException ex) {\n+                superclass = superclass.getSuperclass();\n                 continue;\n             }\n             break;\n         }\n-        return result;\n+        return (Field)declaredField;\n     }\n     \n-    public static String getLinkToDocument(final String moduleName, final String document) throws MacroExecutionException {\n-        final Path templatePath = getTemplatePath(moduleName.replace((CharSequence)\"Check\", (CharSequence)\"\"));\n+    public static String getLinkToDocument(final String s, final String s2) throws MacroExecutionException {\n+        final Path templatePath = getTemplatePath(s.replace((CharSequence)\"Check\", (CharSequence)\"\"));\n         if (templatePath == null) {\n-            throw new MacroExecutionException(String.format(Locale.ROOT, \"Could not find template for %s\", moduleName));\n+            throw new MacroExecutionException(String.format(Locale.ROOT, \"Could not find template for %s\", s));\n         }\n-        final Path templatePathParent = templatePath.getParent();\n-        if (templatePathParent == null) {\n+        final Path parent = templatePath.getParent();\n+        if (parent == null) {\n             throw new MacroExecutionException(\"Failed to get parent path for \" + templatePath);\n         }\n-        return templatePathParent.relativize(Paths.get(\"src\", \"xdocs\", document)).toString().replace(\".xml\", \".html\").replace('\\\\', '/');\n+        return parent.relativize(Paths.get(\"src\", \"xdocs\", s2)).toString().replace(\".xml\", \".html\").replace('\\\\', '/');\n     }\n     \n     static {\n         CLASS_TO_PARENT_MODULE = Map.ofEntries(Map.entry(AbstractCheck.class, TreeWalker.class.getSimpleName()), Map.entry(TreeWalkerFilter.class, TreeWalker.class.getSimpleName()), Map.entry(AbstractFileSetCheck.class, Checker.class.getSimpleName()), Map.entry(Filter.class, Checker.class.getSimpleName()), Map.entry(BeforeExecutionFileFilter.class, Checker.class.getSimpleName()));\n         CHECK_PROPERTIES = getProperties(AbstractCheck.class);\n         JAVADOC_CHECK_PROPERTIES = getProperties(AbstractJavadocCheck.class);\n         FILESET_PROPERTIES = getProperties(AbstractFileSetCheck.class);\n"}]}
