{"diffoscope-json-version": 1, "source1": "first/RegexpHeaderCheck.class", "source2": "second/RegexpHeaderCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -19,14 +19,18 @@\n     public static final String MSG_HEADER_MISSING = \"header.missing\";\n     public static final String MSG_HEADER_MISMATCH = \"header.mismatch\";\n     private static final String EMPTY_LINE_PATTERN = \"^$\";\n     private static final Pattern BLANK_LINE;\n     private final List<Pattern> headerRegexps;\n     private BitSet multiLines;\n     \n+    static {\n+        BLANK_LINE = Pattern.compile(\"^$\");\n+    }\n+    \n     public RegexpHeaderCheck() {\n         this.headerRegexps = new ArrayList<Pattern>();\n         this.multiLines = new BitSet();\n     }\n     \n     public void setMultiLines(final int... list) {\n         this.multiLines = TokenUtil.asBitSet(list);\n@@ -92,25 +96,21 @@\n                     this.headerRegexps.add(RegexpHeaderCheck.BLANK_LINE);\n                 }\n                 else {\n                     this.headerRegexps.add(Pattern.compile(line));\n                 }\n             }\n             catch (final PatternSyntaxException ex) {\n-                throw new IllegalArgumentException(\"line \" + (this.headerRegexps.size() + 1) + \" in header specification is not a regular expression\", (Throwable)ex);\n+                throw new IllegalArgumentException(\"line \" + (this.headerRegexps.size() + 1) + \" in header specification\" + \" is not a regular expression\", ex);\n             }\n         }\n     }\n     \n     public void setHeader(final String header) {\n         if (!CommonUtil.isBlank(header)) {\n             if (!CommonUtil.isPatternValid(header)) {\n                 throw new IllegalArgumentException(\"Unable to parse format: \" + header);\n             }\n             super.setHeader(header);\n         }\n     }\n-    \n-    static {\n-        BLANK_LINE = Pattern.compile(\"^$\");\n-    }\n }\n"}]}
