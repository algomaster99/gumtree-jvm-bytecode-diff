{"diffoscope-json-version": 1, "source1": "first/FileText.class", "source2": "second/FileText.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,13 +1,12 @@\n \n package com.puppycrawl.tools.checkstyle.api;\n \n import java.util.regex.Matcher;\n import java.util.Arrays;\n-import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.nio.file.Files;\n import java.nio.file.OpenOption;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.nio.charset.CharsetDecoder;\n import java.util.ArrayList;\n@@ -39,73 +38,72 @@\n         this.fullText = fileText.fullText;\n         this.lines = fileText.lines.clone();\n         if (fileText.lineBreaks != null) {\n             this.lineBreaks = fileText.lineBreaks.clone();\n         }\n     }\n     \n-    public FileText(final File file, final List<String> lines) {\n-        final StringBuilder buf = new StringBuilder(1024);\n-        for (final String line : lines) {\n-            buf.append(line).append('\\n');\n+    public FileText(final File file, final List<String> list) {\n+        final StringBuilder sb = new StringBuilder(1024);\n+        final Iterator<String> iterator = list.iterator();\n+        while (iterator.hasNext()) {\n+            sb.append(iterator.next()).append('\\n');\n         }\n         this.file = file;\n         this.charset = null;\n-        this.fullText = buf.toString();\n-        this.lines = lines.toArray(CommonUtil.EMPTY_STRING_ARRAY);\n+        this.fullText = sb.toString();\n+        this.lines = list.toArray(CommonUtil.EMPTY_STRING_ARRAY);\n     }\n     \n     public FileText(final File file, final String charsetName) throws IOException {\n         this.file = file;\n         CharsetDecoder decoder;\n         try {\n             this.charset = Charset.forName(charsetName);\n             decoder = this.charset.newDecoder();\n             decoder.onMalformedInput(CodingErrorAction.REPLACE);\n             decoder.onUnmappableCharacter(CodingErrorAction.REPLACE);\n         }\n-        catch (final UnsupportedCharsetException ex) {\n-            final String message = \"Unsupported charset: \" + charsetName;\n-            throw new IllegalStateException(message, ex);\n+        catch (final UnsupportedCharsetException cause) {\n+            throw new IllegalStateException(\"Unsupported charset: \" + charsetName, (Throwable)cause);\n         }\n         this.fullText = readFile(file, decoder);\n-        try (final BufferedReader reader = new BufferedReader(new StringReader(this.fullText))) {\n-            final ArrayList<String> textLines = new ArrayList<String>();\n+        try (final BufferedReader bufferedReader = new BufferedReader(new StringReader(this.fullText))) {\n+            final ArrayList list = new ArrayList();\n             while (true) {\n-                final String line = reader.readLine();\n+                final String line = bufferedReader.readLine();\n                 if (line == null) {\n                     break;\n                 }\n-                textLines.add(line);\n+                list.add(line);\n             }\n-            this.lines = textLines.toArray(CommonUtil.EMPTY_STRING_ARRAY);\n+            this.lines = list.toArray(CommonUtil.EMPTY_STRING_ARRAY);\n         }\n     }\n     \n-    private static String readFile(final File inputFile, final CharsetDecoder decoder) throws IOException {\n-        if (!inputFile.exists()) {\n-            throw new FileNotFoundException(inputFile.getPath() + \" (No such file or directory)\");\n+    private static String readFile(final File file, final CharsetDecoder dec) throws IOException {\n+        if (!file.exists()) {\n+            throw new FileNotFoundException(file.getPath() + \" (No such file or directory)\");\n         }\n-        final StringBuilder buf = new StringBuilder(1024);\n-        final InputStream stream = Files.newInputStream(inputFile.toPath(), new OpenOption[0]);\n-        try (final Reader reader = new InputStreamReader(stream, decoder)) {\n-            final char[] chars = new char[1024];\n+        final StringBuilder sb = new StringBuilder(1024);\n+        try (final InputStreamReader inputStreamReader = new InputStreamReader(Files.newInputStream(file.toPath(), new OpenOption[0]), dec)) {\n+            final char[] array = new char[1024];\n             while (true) {\n-                final int len = reader.read(chars);\n-                if (len == -1) {\n+                final int read = inputStreamReader.read(array);\n+                if (read == -1) {\n                     break;\n                 }\n-                buf.append(chars, 0, len);\n+                sb.append(array, 0, read);\n             }\n         }\n-        return buf.toString();\n+        return sb.toString();\n     }\n     \n-    public String get(final int lineNo) {\n-        return this.lines[lineNo];\n+    public String get(final int n) {\n+        return this.lines[n];\n     }\n     \n     public File getFile() {\n         return this.file;\n     }\n     \n     public Charset getCharset() {\n@@ -116,39 +114,37 @@\n         return this.fullText;\n     }\n     \n     public String[] toLinesArray() {\n         return this.lines.clone();\n     }\n     \n-    public LineColumn lineColumn(final int pos) {\n-        final int[] lineBreakPositions = this.findLineBreaks();\n-        int lineNo = Arrays.binarySearch(lineBreakPositions, pos);\n-        if (lineNo < 0) {\n-            lineNo = -lineNo - 2;\n-        }\n-        final int startOfLine = lineBreakPositions[lineNo];\n-        final int columnNo = pos - startOfLine;\n-        return new LineColumn(lineNo + 1, columnNo);\n+    public LineColumn lineColumn(final int key) {\n+        final int[] lineBreaks = this.findLineBreaks();\n+        int binarySearch = Arrays.binarySearch(lineBreaks, key);\n+        if (binarySearch < 0) {\n+            binarySearch = -binarySearch - 2;\n+        }\n+        return new LineColumn(binarySearch + 1, key - lineBreaks[binarySearch]);\n     }\n     \n     private int[] findLineBreaks() {\n         if (this.lineBreaks == null) {\n-            final int[] lineBreakPositions = new int[this.size() + 1];\n-            lineBreakPositions[0] = 0;\n-            int lineNo = 1;\n+            final int[] lineBreaks = new int[this.size() + 1];\n+            lineBreaks[0] = 0;\n+            int n = 1;\n             final Matcher matcher = FileText.LINE_TERMINATOR.matcher(this.fullText);\n             while (matcher.find()) {\n-                lineBreakPositions[lineNo] = matcher.end();\n-                ++lineNo;\n+                lineBreaks[n] = matcher.end();\n+                ++n;\n             }\n-            if (lineNo < lineBreakPositions.length) {\n-                lineBreakPositions[lineNo] = this.fullText.length();\n+            if (n < lineBreaks.length) {\n+                lineBreaks[n] = this.fullText.length();\n             }\n-            this.lineBreaks = lineBreakPositions;\n+            this.lineBreaks = lineBreaks;\n         }\n         return this.lineBreaks;\n     }\n     \n     public int size() {\n         return this.lines.length;\n     }\n"}]}
