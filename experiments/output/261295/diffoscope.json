{"diffoscope-json-version": 1, "source1": "first/Range.class", "source2": "second/Range.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -9,78 +9,78 @@\n     private static final long serialVersionUID = 1L;\n     private final Comparator<T> comparator;\n     private transient int hashCode;\n     private final T maximum;\n     private final T minimum;\n     private transient String toString;\n     \n-    public static <T extends Comparable<T>> Range<T> between(final T fromInclusive, final T toInclusive) {\n-        return between(fromInclusive, toInclusive, null);\n+    public static <T extends Comparable<T>> Range<T> between(final T t, final T t2) {\n+        return between(t, t2, null);\n     }\n     \n-    public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {\n-        return new Range<T>(fromInclusive, toInclusive, comparator);\n+    public static <T> Range<T> between(final T t, final T t2, final Comparator<T> comparator) {\n+        return new Range<T>(t, t2, comparator);\n     }\n     \n-    public static <T extends Comparable<T>> Range<T> is(final T element) {\n-        return between(element, element, null);\n+    public static <T extends Comparable<T>> Range<T> is(final T t) {\n+        return between(t, t, null);\n     }\n     \n-    public static <T> Range<T> is(final T element, final Comparator<T> comparator) {\n-        return between(element, element, comparator);\n+    public static <T> Range<T> is(final T t, final Comparator<T> comparator) {\n+        return between(t, t, comparator);\n     }\n     \n-    private Range(final T element1, final T element2, final Comparator<T> comp) {\n-        if (element1 == null || element2 == null) {\n-            throw new IllegalArgumentException(\"Elements in a range must not be null: element1=\" + element1 + \", element2=\" + element2);\n+    private Range(final T maximum, final T minimum, final Comparator<T> comparator) {\n+        if (maximum == null || minimum == null) {\n+            throw new IllegalArgumentException(\"Elements in a range must not be null: element1=\" + maximum + \", element2=\" + minimum);\n         }\n-        if (comp == null) {\n+        if (comparator == null) {\n             this.comparator = (Comparator<T>)Range.ComparableComparator.INSTANCE;\n         }\n         else {\n-            this.comparator = comp;\n+            this.comparator = comparator;\n         }\n-        if (this.comparator.compare(element1, element2) < 1) {\n-            this.minimum = element1;\n-            this.maximum = element2;\n+        if (this.comparator.compare(maximum, minimum) < 1) {\n+            this.minimum = maximum;\n+            this.maximum = minimum;\n         }\n         else {\n-            this.minimum = element2;\n-            this.maximum = element1;\n+            this.minimum = minimum;\n+            this.maximum = maximum;\n         }\n     }\n     \n-    public boolean contains(final T element) {\n-        return element != null && this.comparator.compare(element, this.minimum) > -1 && this.comparator.compare(element, this.maximum) < 1;\n+    public boolean contains(final T t) {\n+        return t != null && this.comparator.compare(t, this.minimum) > -1 && this.comparator.compare(t, this.maximum) < 1;\n     }\n     \n-    public boolean containsRange(final Range<T> otherRange) {\n-        return otherRange != null && this.contains(otherRange.minimum) && this.contains(otherRange.maximum);\n+    public boolean containsRange(final Range<T> range) {\n+        return range != null && this.contains(range.minimum) && this.contains(range.maximum);\n     }\n     \n-    public int elementCompareTo(final T element) {\n-        Validate.notNull((Object)element, \"Element is null\", new Object[0]);\n-        if (this.isAfter(element)) {\n+    public int elementCompareTo(final T t) {\n+        Validate.notNull((Object)t, \"Element is null\", new Object[0]);\n+        if (this.isAfter(t)) {\n             return -1;\n         }\n-        if (this.isBefore(element)) {\n+        if (this.isBefore(t)) {\n             return 1;\n         }\n         return 0;\n     }\n     \n     @Override\n-    public boolean equals(final Object obj) {\n-        if (obj == this) {\n+    public boolean equals(final Object o) {\n+        if (o == this) {\n             return true;\n         }\n-        if (obj == null || obj.getClass() != this.getClass()) {\n+        if (o == null || o.getClass() != this.getClass()) {\n             return false;\n         }\n-        final Range<T> range = (Range)obj;\n+        final Range range = (Range)o;\n         return this.minimum.equals(range.minimum) && this.maximum.equals(range.maximum);\n     }\n     \n     public Comparator<T> getComparator() {\n         return this.comparator;\n     }\n     \n@@ -90,78 +90,73 @@\n     \n     public T getMinimum() {\n         return this.minimum;\n     }\n     \n     @Override\n     public int hashCode() {\n-        int result = this.hashCode;\n+        int hashCode = this.hashCode;\n         if (this.hashCode == 0) {\n-            result = 17;\n-            result = 37 * result + this.getClass().hashCode();\n-            result = 37 * result + this.minimum.hashCode();\n-            result = 37 * result + this.maximum.hashCode();\n-            this.hashCode = result;\n+            hashCode = 37 * (37 * (37 * 17 + this.getClass().hashCode()) + this.minimum.hashCode()) + this.maximum.hashCode();\n+            this.hashCode = hashCode;\n         }\n-        return result;\n+        return hashCode;\n     }\n     \n-    public Range<T> intersectionWith(final Range<T> other) {\n-        if (!this.isOverlappedBy(other)) {\n-            throw new IllegalArgumentException(String.format(\"Cannot calculate intersection with non-overlapping range %s\", other));\n+    public Range<T> intersectionWith(final Range<T> range) {\n+        if (!this.isOverlappedBy(range)) {\n+            throw new IllegalArgumentException(String.format(\"Cannot calculate intersection with non-overlapping range %s\", range));\n         }\n-        if (this.equals(other)) {\n+        if (this.equals(range)) {\n             return this;\n         }\n-        final T min = (this.getComparator().compare(this.minimum, other.minimum) < 0) ? other.minimum : this.minimum;\n-        final T max = (this.getComparator().compare(this.maximum, other.maximum) < 0) ? this.maximum : other.maximum;\n-        return between(min, max, this.getComparator());\n+        return between((this.getComparator().compare(this.minimum, range.minimum) < 0) ? range.minimum : this.minimum, (this.getComparator().compare(this.maximum, range.maximum) < 0) ? this.maximum : range.maximum, this.getComparator());\n     }\n     \n-    public boolean isAfter(final T element) {\n-        return element != null && this.comparator.compare(element, this.minimum) < 0;\n+    public boolean isAfter(final T t) {\n+        return t != null && this.comparator.compare(t, this.minimum) < 0;\n     }\n     \n-    public boolean isAfterRange(final Range<T> otherRange) {\n-        return otherRange != null && this.isAfter(otherRange.maximum);\n+    public boolean isAfterRange(final Range<T> range) {\n+        return range != null && this.isAfter(range.maximum);\n     }\n     \n-    public boolean isBefore(final T element) {\n-        return element != null && this.comparator.compare(element, this.maximum) > 0;\n+    public boolean isBefore(final T t) {\n+        return t != null && this.comparator.compare(t, this.maximum) > 0;\n     }\n     \n-    public boolean isBeforeRange(final Range<T> otherRange) {\n-        return otherRange != null && this.isBefore(otherRange.minimum);\n+    public boolean isBeforeRange(final Range<T> range) {\n+        return range != null && this.isBefore(range.minimum);\n     }\n     \n-    public boolean isEndedBy(final T element) {\n-        return element != null && this.comparator.compare(element, this.maximum) == 0;\n+    public boolean isEndedBy(final T t) {\n+        return t != null && this.comparator.compare(t, this.maximum) == 0;\n     }\n     \n     public boolean isNaturalOrdering() {\n         return this.comparator == Range.ComparableComparator.INSTANCE;\n     }\n     \n-    public boolean isOverlappedBy(final Range<T> otherRange) {\n-        return otherRange != null && (otherRange.contains(this.minimum) || otherRange.contains(this.maximum) || this.contains(otherRange.minimum));\n+    public boolean isOverlappedBy(final Range<T> range) {\n+        return range != null && (range.contains(this.minimum) || range.contains(this.maximum) || this.contains(range.minimum));\n     }\n     \n-    public boolean isStartedBy(final T element) {\n-        return element != null && this.comparator.compare(element, this.minimum) == 0;\n+    public boolean isStartedBy(final T t) {\n+        return t != null && this.comparator.compare(t, this.minimum) == 0;\n     }\n     \n-    public T fit(final T element) {\n-        Validate.notNull((Object)element, \"element\", new Object[0]);\n-        if (this.isAfter(element)) {\n+    public T fit(final T t) {\n+        Validate.notNull((Object)t, \"element\", new Object[0]);\n+        if (this.isAfter(t)) {\n             return this.minimum;\n         }\n-        if (this.isBefore(element)) {\n+        if (this.isBefore(t)) {\n             return this.maximum;\n         }\n-        return element;\n+        return t;\n     }\n     \n     @Override\n     public String toString() {\n         if (this.toString == null) {\n             this.toString = \"[\" + this.minimum + \"..\" + this.maximum + \"]\";\n         }\n"}]}
