{"diffoscope-json-version": 1, "source1": "first/MethodUtils.class", "source2": "second/MethodUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,11 +1,10 @@\n \n package org.apache.commons.lang3.reflect;\n \n-import java.util.function.Function;\n import java.lang.annotation.Annotation;\n import java.lang.reflect.TypeVariable;\n import java.util.Map;\n import java.lang.reflect.Type;\n import java.util.Arrays;\n import java.util.LinkedHashSet;\n import java.util.Set;\n@@ -17,59 +16,64 @@\n import java.lang.reflect.AccessibleObject;\n import java.lang.reflect.Modifier;\n import java.lang.reflect.Member;\n import java.lang.reflect.Array;\n import org.apache.commons.lang3.ClassUtils;\n import java.lang.reflect.InvocationTargetException;\n import org.apache.commons.lang3.ArrayUtils;\n+import java.util.function.Function;\n import java.lang.reflect.Method;\n import java.util.Comparator;\n \n public class MethodUtils\n {\n     private static final Comparator<Method> METHOD_BY_SIGNATURE;\n     \n+    static {\n+        METHOD_BY_SIGNATURE = Comparator.comparing((Function<? super Method, ? extends Comparable>)Method::toString);\n+    }\n+    \n     public static Object invokeMethod(final Object object, final String methodName) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n         return invokeMethod(object, methodName, ArrayUtils.EMPTY_OBJECT_ARRAY, null);\n     }\n     \n     public static Object invokeMethod(final Object object, final boolean forceAccess, final String methodName) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n         return invokeMethod(object, forceAccess, methodName, ArrayUtils.EMPTY_OBJECT_ARRAY, null);\n     }\n     \n     public static Object invokeMethod(final Object object, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n         args = ArrayUtils.nullToEmpty(args);\n-        final Class<?>[] parameterTypes = ClassUtils.toClass(args);\n+        final Class[] parameterTypes = ClassUtils.toClass(args);\n         return invokeMethod(object, methodName, args, parameterTypes);\n     }\n     \n     public static Object invokeMethod(final Object object, final boolean forceAccess, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n         args = ArrayUtils.nullToEmpty(args);\n-        final Class<?>[] parameterTypes = ClassUtils.toClass(args);\n+        final Class[] parameterTypes = ClassUtils.toClass(args);\n         return invokeMethod(object, forceAccess, methodName, args, parameterTypes);\n     }\n     \n     public static Object invokeMethod(final Object object, final boolean forceAccess, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n-        parameterTypes = ArrayUtils.nullToEmpty((Class[])parameterTypes);\n+        parameterTypes = ArrayUtils.nullToEmpty(parameterTypes);\n         args = ArrayUtils.nullToEmpty(args);\n         Method method = null;\n         String messagePrefix;\n         if (forceAccess) {\n             messagePrefix = \"No such method: \";\n-            method = getMatchingMethod(object.getClass(), methodName, parameterTypes);\n+            method = getMatchingMethod(object.getClass(), methodName, (Class<?>[])parameterTypes);\n             if (method != null && !method.isAccessible()) {\n                 method.setAccessible(true);\n             }\n         }\n         else {\n             messagePrefix = \"No such accessible method: \";\n-            method = getMatchingAccessibleMethod(object.getClass(), methodName, parameterTypes);\n+            method = getMatchingAccessibleMethod(object.getClass(), methodName, (Class<?>[])parameterTypes);\n         }\n         if (method == null) {\n-            throw new NoSuchMethodException(messagePrefix + methodName + \"() on object: \" + object.getClass().getName());\n+            throw new NoSuchMethodException(String.valueOf(messagePrefix) + methodName + \"() on object: \" + object.getClass().getName());\n         }\n         args = toVarArgs(method, args);\n         return method.invoke(object, args);\n     }\n     \n     public static Object invokeMethod(final Object object, final String methodName, final Object[] args, final Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n         return invokeMethod(object, false, methodName, args, parameterTypes);\n@@ -77,58 +81,58 @@\n     \n     public static Object invokeExactMethod(final Object object, final String methodName) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n         return invokeExactMethod(object, methodName, ArrayUtils.EMPTY_OBJECT_ARRAY, null);\n     }\n     \n     public static Object invokeExactMethod(final Object object, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n         args = ArrayUtils.nullToEmpty(args);\n-        final Class<?>[] parameterTypes = ClassUtils.toClass(args);\n+        final Class[] parameterTypes = ClassUtils.toClass(args);\n         return invokeExactMethod(object, methodName, args, parameterTypes);\n     }\n     \n     public static Object invokeExactMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n         args = ArrayUtils.nullToEmpty(args);\n-        parameterTypes = ArrayUtils.nullToEmpty((Class[])parameterTypes);\n-        final Method method = getAccessibleMethod(object.getClass(), methodName, parameterTypes);\n+        parameterTypes = ArrayUtils.nullToEmpty(parameterTypes);\n+        final Method method = getAccessibleMethod(object.getClass(), methodName, (Class<?>[])parameterTypes);\n         if (method == null) {\n             throw new NoSuchMethodException(\"No such accessible method: \" + methodName + \"() on object: \" + object.getClass().getName());\n         }\n         return method.invoke(object, args);\n     }\n     \n     public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n         args = ArrayUtils.nullToEmpty(args);\n-        parameterTypes = ArrayUtils.nullToEmpty((Class[])parameterTypes);\n-        final Method method = getAccessibleMethod(cls, methodName, parameterTypes);\n+        parameterTypes = ArrayUtils.nullToEmpty(parameterTypes);\n+        final Method method = getAccessibleMethod(cls, methodName, (Class<?>[])parameterTypes);\n         if (method == null) {\n             throw new NoSuchMethodException(\"No such accessible method: \" + methodName + \"() on class: \" + cls.getName());\n         }\n         return method.invoke(null, args);\n     }\n     \n     public static Object invokeStaticMethod(final Class<?> cls, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n         args = ArrayUtils.nullToEmpty(args);\n-        final Class<?>[] parameterTypes = ClassUtils.toClass(args);\n+        final Class[] parameterTypes = ClassUtils.toClass(args);\n         return invokeStaticMethod(cls, methodName, args, parameterTypes);\n     }\n     \n     public static Object invokeStaticMethod(final Class<?> cls, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n         args = ArrayUtils.nullToEmpty(args);\n-        parameterTypes = ArrayUtils.nullToEmpty((Class[])parameterTypes);\n-        final Method method = getMatchingAccessibleMethod(cls, methodName, parameterTypes);\n+        parameterTypes = ArrayUtils.nullToEmpty(parameterTypes);\n+        final Method method = getMatchingAccessibleMethod(cls, methodName, (Class<?>[])parameterTypes);\n         if (method == null) {\n             throw new NoSuchMethodException(\"No such accessible method: \" + methodName + \"() on class: \" + cls.getName());\n         }\n         args = toVarArgs(method, args);\n         return method.invoke(null, args);\n     }\n     \n     private static Object[] toVarArgs(final Method method, Object[] args) {\n         if (method.isVarArgs()) {\n-            final Class<?>[] methodParameterTypes = method.getParameterTypes();\n+            final Class[] methodParameterTypes = method.getParameterTypes();\n             args = getVarArgs(args, methodParameterTypes);\n         }\n         return args;\n     }\n     \n     static Object[] getVarArgs(final Object[] args, final Class<?>[] methodParameterTypes) {\n         if (args.length == methodParameterTypes.length && (args[args.length - 1] == null || args[args.length - 1].getClass().equals(methodParameterTypes[methodParameterTypes.length - 1]))) {\n@@ -145,15 +149,15 @@\n         }\n         newArgs[methodParameterTypes.length - 1] = varArgsArray;\n         return newArgs;\n     }\n     \n     public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n         args = ArrayUtils.nullToEmpty(args);\n-        final Class<?>[] parameterTypes = ClassUtils.toClass(args);\n+        final Class[] parameterTypes = ClassUtils.toClass(args);\n         return invokeExactStaticMethod(cls, methodName, args, parameterTypes);\n     }\n     \n     public static Method getAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) {\n         try {\n             return getAccessibleMethod(cls.getMethod(methodName, parameterTypes));\n         }\n@@ -167,18 +171,18 @@\n             return null;\n         }\n         final Class<?> cls = method.getDeclaringClass();\n         if (Modifier.isPublic(cls.getModifiers())) {\n             return method;\n         }\n         final String methodName = method.getName();\n-        final Class<?>[] parameterTypes = method.getParameterTypes();\n-        method = getAccessibleMethodFromInterfaceNest(cls, methodName, parameterTypes);\n+        final Class[] parameterTypes = method.getParameterTypes();\n+        method = getAccessibleMethodFromInterfaceNest(cls, methodName, (Class<?>[])parameterTypes);\n         if (method == null) {\n-            method = getAccessibleMethodFromSuperclass(cls, methodName, parameterTypes);\n+            method = getAccessibleMethodFromSuperclass(cls, methodName, (Class<?>[])parameterTypes);\n         }\n         return method;\n     }\n     \n     private static Method getAccessibleMethodFromSuperclass(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) {\n         for (Class<?> parentClass = cls.getSuperclass(); parentClass != null; parentClass = parentClass.getSuperclass()) {\n             if (Modifier.isPublic(parentClass.getModifiers())) {\n@@ -191,17 +195,18 @@\n             }\n         }\n         return null;\n     }\n     \n     private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls, final String methodName, final Class<?>... parameterTypes) {\n         while (cls != null) {\n-            final Class<?>[] interfaces2;\n-            final Class<?>[] interfaces = interfaces2 = cls.getInterfaces();\n-            for (final Class<?> anInterface : interfaces2) {\n+            final Class[] interfaces = cls.getInterfaces();\n+            Class[] array;\n+            for (int length = (array = interfaces).length, i = 0; i < length; ++i) {\n+                final Class<?> anInterface = array[i];\n                 if (Modifier.isPublic(anInterface.getModifiers())) {\n                     try {\n                         return anInterface.getDeclaredMethod(methodName, parameterTypes);\n                     }\n                     catch (final NoSuchMethodException ex) {\n                         final Method method = getAccessibleMethodFromInterfaceNest(anInterface, methodName, parameterTypes);\n                         if (method != null) {\n@@ -220,15 +225,17 @@\n             final Method method = cls.getMethod(methodName, parameterTypes);\n             MemberUtils.setAccessibleWorkaround((AccessibleObject)method);\n             return method;\n         }\n         catch (final NoSuchMethodException ex) {\n             final Method[] methods = cls.getMethods();\n             final List<Method> matchingMethods = new ArrayList<Method>();\n-            for (final Method method2 : methods) {\n+            Method[] array;\n+            for (int length = (array = methods).length, i = 0; i < length; ++i) {\n+                final Method method2 = array[i];\n                 if (method2.getName().equals(methodName) && MemberUtils.isMatchingMethod(method2, (Class[])parameterTypes)) {\n                     matchingMethods.add(method2);\n                 }\n             }\n             matchingMethods.sort(MethodUtils.METHOD_BY_SIGNATURE);\n             Method bestMatch = null;\n             for (final Method method3 : matchingMethods) {\n@@ -237,15 +244,15 @@\n                     bestMatch = accessibleMethod;\n                 }\n             }\n             if (bestMatch != null) {\n                 MemberUtils.setAccessibleWorkaround((AccessibleObject)bestMatch);\n             }\n             if (bestMatch != null && bestMatch.isVarArgs() && bestMatch.getParameterTypes().length > 0 && parameterTypes.length > 0) {\n-                final Class<?>[] methodParameterTypes = bestMatch.getParameterTypes();\n+                final Class[] methodParameterTypes = bestMatch.getParameterTypes();\n                 final Class<?> methodParameterComponentType = methodParameterTypes[methodParameterTypes.length - 1].getComponentType();\n                 final String methodParameterComponentTypeName = ClassUtils.primitiveToWrapper((Class)methodParameterComponentType).getName();\n                 final Class<?> lastParameterType = parameterTypes[parameterTypes.length - 1];\n                 final String parameterTypeName = (lastParameterType == null) ? null : lastParameterType.getName();\n                 final String parameterTypeSuperClassName = (lastParameterType == null) ? null : lastParameterType.getSuperclass().getName();\n                 if (parameterTypeName != null && parameterTypeSuperClassName != null && !methodParameterComponentTypeName.equals(parameterTypeName) && !methodParameterComponentTypeName.equals(parameterTypeSuperClassName)) {\n                     return null;\n@@ -260,15 +267,17 @@\n         Validate.notEmpty((CharSequence)methodName, \"Null or blank methodName not allowed.\", new Object[0]);\n         Method[] methodArray = cls.getDeclaredMethods();\n         final List<Class<?>> superclassList = ClassUtils.getAllSuperclasses((Class)cls);\n         for (final Class<?> klass : superclassList) {\n             methodArray = (Method[])ArrayUtils.addAll((Object[])methodArray, (Object[])klass.getDeclaredMethods());\n         }\n         Method inexactMatch = null;\n-        for (final Method method : methodArray) {\n+        Method[] array;\n+        for (int length = (array = methodArray).length, i = 0; i < length; ++i) {\n+            final Method method = array[i];\n             if (methodName.equals(method.getName()) && Objects.deepEquals(parameterTypes, method.getParameterTypes())) {\n                 return method;\n             }\n             if (methodName.equals(method.getName()) && ClassUtils.isAssignable((Class[])parameterTypes, (Class[])method.getParameterTypes(), true) && (inexactMatch == null || distance(parameterTypes, method.getParameterTypes()) < distance(parameterTypes, inexactMatch.getParameterTypes()))) {\n                 inexactMatch = method;\n             }\n         }\n@@ -293,35 +302,35 @@\n         return answer;\n     }\n     \n     public static Set<Method> getOverrideHierarchy(final Method method, final ClassUtils.Interfaces interfacesBehavior) {\n         Validate.notNull((Object)method);\n         final Set<Method> result = new LinkedHashSet<Method>();\n         result.add(method);\n-        final Class<?>[] parameterTypes = method.getParameterTypes();\n+        final Class[] parameterTypes = method.getParameterTypes();\n         final Class<?> declaringClass = method.getDeclaringClass();\n         final Iterator<Class<?>> hierarchy = ClassUtils.hierarchy((Class)declaringClass, interfacesBehavior).iterator();\n         hierarchy.next();\n-    Label_0053:\n+    Label_0191:\n         while (hierarchy.hasNext()) {\n             final Class<?> c = (Class<?>)hierarchy.next();\n-            final Method m = getMatchingAccessibleMethod(c, method.getName(), parameterTypes);\n+            final Method m = getMatchingAccessibleMethod(c, method.getName(), (Class<?>[])parameterTypes);\n             if (m == null) {\n                 continue;\n             }\n             if (Arrays.equals(m.getParameterTypes(), parameterTypes)) {\n                 result.add(m);\n             }\n             else {\n                 final Map<TypeVariable<?>, Type> typeArguments = TypeUtils.getTypeArguments((Type)declaringClass, (Class)m.getDeclaringClass());\n                 for (int i = 0; i < parameterTypes.length; ++i) {\n                     final Type childType = TypeUtils.unrollVariables((Map)typeArguments, method.getGenericParameterTypes()[i]);\n                     final Type parentType = TypeUtils.unrollVariables((Map)typeArguments, m.getGenericParameterTypes()[i]);\n                     if (!TypeUtils.equals(childType, parentType)) {\n-                        continue Label_0053;\n+                        continue Label_0191;\n                     }\n                 }\n                 result.add(m);\n             }\n         }\n         return result;\n     }\n@@ -342,17 +351,18 @@\n     public static List<Method> getMethodsListWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls, final boolean searchSupers, final boolean ignoreAccess) {\n         Validate.notNull((Object)cls, \"The class must not be null\", new Object[0]);\n         Validate.notNull((Object)annotationCls, \"The annotation class must not be null\", new Object[0]);\n         final List<Class<?>> classes = searchSupers ? getAllSuperclassesAndInterfaces(cls) : new ArrayList<Class<?>>();\n         classes.add(0, cls);\n         final List<Method> annotatedMethods = new ArrayList<Method>();\n         for (final Class<?> acls : classes) {\n-            final Method[] array;\n-            final Method[] methods = array = (ignoreAccess ? acls.getDeclaredMethods() : acls.getMethods());\n-            for (final Method method : array) {\n+            final Method[] methods = ignoreAccess ? acls.getDeclaredMethods() : acls.getMethods();\n+            Method[] array;\n+            for (int length = (array = methods).length, i = 0; i < length; ++i) {\n+                final Method method = array[i];\n                 if (method.getAnnotation(annotationCls) != null) {\n                     annotatedMethods.add(method);\n                 }\n             }\n         }\n         return annotatedMethods;\n     }\n@@ -401,12 +411,8 @@\n             else {\n                 acls = allSuperclasses.get(superClassIndex++);\n             }\n             allSuperClassesAndInterfaces.add(acls);\n         }\n         return allSuperClassesAndInterfaces;\n     }\n-    \n-    static {\n-        METHOD_BY_SIGNATURE = Comparator.comparing((Function<? super Method, ? extends Comparable>)Method::toString);\n-    }\n }\n"}]}
