{"diffoscope-json-version": 1, "source1": "first/Base64.class", "source2": "second/Base64.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -19,278 +19,276 @@\n     private final int decodeSize;\n     private final int encodeSize;\n     \n     public Base64() {\n         this(0);\n     }\n     \n-    public Base64(final boolean urlSafe) {\n-        this(76, Base64.CHUNK_SEPARATOR, urlSafe);\n+    public Base64(final boolean b) {\n+        this(76, Base64.CHUNK_SEPARATOR, b);\n     }\n     \n-    public Base64(final int lineLength) {\n-        this(lineLength, Base64.CHUNK_SEPARATOR);\n+    public Base64(final int n) {\n+        this(n, Base64.CHUNK_SEPARATOR);\n     }\n     \n-    public Base64(final int lineLength, final byte[] lineSeparator) {\n-        this(lineLength, lineSeparator, false);\n+    public Base64(final int n, final byte[] array) {\n+        this(n, array, false);\n     }\n     \n-    public Base64(final int lineLength, final byte[] lineSeparator, final boolean urlSafe) {\n-        super(3, 4, lineLength, (lineSeparator == null) ? 0 : lineSeparator.length);\n+    public Base64(final int n, final byte[] array, final boolean b) {\n+        super(3, 4, n, (array == null) ? 0 : array.length);\n         this.decodeTable = Base64.DECODE_TABLE;\n-        if (lineSeparator != null) {\n-            if (this.containsAlphabetOrPad(lineSeparator)) {\n-                final String sep = StringUtils.newStringUtf8(lineSeparator);\n-                throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + sep + \"]\");\n-            }\n-            if (lineLength > 0) {\n-                this.encodeSize = 4 + lineSeparator.length;\n-                System.arraycopy(lineSeparator, 0, this.lineSeparator = new byte[lineSeparator.length], 0, lineSeparator.length);\n+        if (array != null) {\n+            if (this.containsAlphabetOrPad(array)) {\n+                throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + StringUtils.newStringUtf8(array) + \"]\");\n+            }\n+            if (n > 0) {\n+                this.encodeSize = 4 + array.length;\n+                System.arraycopy(array, 0, this.lineSeparator = new byte[array.length], 0, array.length);\n             }\n             else {\n                 this.encodeSize = 4;\n                 this.lineSeparator = null;\n             }\n         }\n         else {\n             this.encodeSize = 4;\n             this.lineSeparator = null;\n         }\n         this.decodeSize = this.encodeSize - 1;\n-        this.encodeTable = (urlSafe ? Base64.URL_SAFE_ENCODE_TABLE : Base64.STANDARD_ENCODE_TABLE);\n+        this.encodeTable = (b ? Base64.URL_SAFE_ENCODE_TABLE : Base64.STANDARD_ENCODE_TABLE);\n     }\n     \n     public boolean isUrlSafe() {\n         return this.encodeTable == Base64.URL_SAFE_ENCODE_TABLE;\n     }\n     \n-    void encode(final byte[] in, int inPos, final int inAvail, final BaseNCodec.Context context) {\n+    void encode(final byte[] array, int n, final int n2, final BaseNCodec.Context context) {\n         if (context.eof) {\n             return;\n         }\n-        if (inAvail < 0) {\n+        if (n2 < 0) {\n             context.eof = true;\n             if (0 == context.modulus && this.lineLength == 0) {\n                 return;\n             }\n-            final byte[] buffer = this.ensureBufferSize(this.encodeSize, context);\n-            final int savedPos = context.pos;\n+            final byte[] ensureBufferSize = this.ensureBufferSize(this.encodeSize, context);\n+            final int pos = context.pos;\n             switch (context.modulus) {\n                 case 0: {\n                     break;\n                 }\n                 case 1: {\n-                    buffer[context.pos++] = this.encodeTable[context.ibitWorkArea >> 2 & 0x3F];\n-                    buffer[context.pos++] = this.encodeTable[context.ibitWorkArea << 4 & 0x3F];\n+                    ensureBufferSize[context.pos++] = this.encodeTable[context.ibitWorkArea >> 2 & 0x3F];\n+                    ensureBufferSize[context.pos++] = this.encodeTable[context.ibitWorkArea << 4 & 0x3F];\n                     if (this.encodeTable == Base64.STANDARD_ENCODE_TABLE) {\n-                        buffer[context.pos++] = this.pad;\n-                        buffer[context.pos++] = this.pad;\n+                        ensureBufferSize[context.pos++] = this.pad;\n+                        ensureBufferSize[context.pos++] = this.pad;\n                         break;\n                     }\n                     break;\n                 }\n                 case 2: {\n-                    buffer[context.pos++] = this.encodeTable[context.ibitWorkArea >> 10 & 0x3F];\n-                    buffer[context.pos++] = this.encodeTable[context.ibitWorkArea >> 4 & 0x3F];\n-                    buffer[context.pos++] = this.encodeTable[context.ibitWorkArea << 2 & 0x3F];\n+                    ensureBufferSize[context.pos++] = this.encodeTable[context.ibitWorkArea >> 10 & 0x3F];\n+                    ensureBufferSize[context.pos++] = this.encodeTable[context.ibitWorkArea >> 4 & 0x3F];\n+                    ensureBufferSize[context.pos++] = this.encodeTable[context.ibitWorkArea << 2 & 0x3F];\n                     if (this.encodeTable == Base64.STANDARD_ENCODE_TABLE) {\n-                        buffer[context.pos++] = this.pad;\n+                        ensureBufferSize[context.pos++] = this.pad;\n                         break;\n                     }\n                     break;\n                 }\n                 default: {\n                     throw new IllegalStateException(\"Impossible modulus \" + context.modulus);\n                 }\n             }\n-            context.currentLinePos += context.pos - savedPos;\n+            context.currentLinePos += context.pos - pos;\n             if (this.lineLength > 0 && context.currentLinePos > 0) {\n-                System.arraycopy(this.lineSeparator, 0, buffer, context.pos, this.lineSeparator.length);\n+                System.arraycopy(this.lineSeparator, 0, ensureBufferSize, context.pos, this.lineSeparator.length);\n                 context.pos += this.lineSeparator.length;\n             }\n         }\n         else {\n-            for (int i = 0; i < inAvail; ++i) {\n-                final byte[] buffer2 = this.ensureBufferSize(this.encodeSize, context);\n+            for (int i = 0; i < n2; ++i) {\n+                final byte[] ensureBufferSize2 = this.ensureBufferSize(this.encodeSize, context);\n                 context.modulus = (context.modulus + 1) % 3;\n-                int b = in[inPos++];\n-                if (b < 0) {\n-                    b += 256;\n+                int n3 = array[n++];\n+                if (n3 < 0) {\n+                    n3 += 256;\n                 }\n-                context.ibitWorkArea = (context.ibitWorkArea << 8) + b;\n+                context.ibitWorkArea = (context.ibitWorkArea << 8) + n3;\n                 if (0 == context.modulus) {\n-                    buffer2[context.pos++] = this.encodeTable[context.ibitWorkArea >> 18 & 0x3F];\n-                    buffer2[context.pos++] = this.encodeTable[context.ibitWorkArea >> 12 & 0x3F];\n-                    buffer2[context.pos++] = this.encodeTable[context.ibitWorkArea >> 6 & 0x3F];\n-                    buffer2[context.pos++] = this.encodeTable[context.ibitWorkArea & 0x3F];\n+                    ensureBufferSize2[context.pos++] = this.encodeTable[context.ibitWorkArea >> 18 & 0x3F];\n+                    ensureBufferSize2[context.pos++] = this.encodeTable[context.ibitWorkArea >> 12 & 0x3F];\n+                    ensureBufferSize2[context.pos++] = this.encodeTable[context.ibitWorkArea >> 6 & 0x3F];\n+                    ensureBufferSize2[context.pos++] = this.encodeTable[context.ibitWorkArea & 0x3F];\n                     context.currentLinePos += 4;\n                     if (this.lineLength > 0 && this.lineLength <= context.currentLinePos) {\n-                        System.arraycopy(this.lineSeparator, 0, buffer2, context.pos, this.lineSeparator.length);\n+                        System.arraycopy(this.lineSeparator, 0, ensureBufferSize2, context.pos, this.lineSeparator.length);\n                         context.pos += this.lineSeparator.length;\n                         context.currentLinePos = 0;\n                     }\n                 }\n             }\n         }\n     }\n     \n-    void decode(final byte[] in, int inPos, final int inAvail, final BaseNCodec.Context context) {\n+    void decode(final byte[] array, int n, final int n2, final BaseNCodec.Context context) {\n         if (context.eof) {\n             return;\n         }\n-        if (inAvail < 0) {\n+        if (n2 < 0) {\n             context.eof = true;\n         }\n-        for (int i = 0; i < inAvail; ++i) {\n-            final byte[] buffer = this.ensureBufferSize(this.decodeSize, context);\n-            final byte b = in[inPos++];\n+        for (int i = 0; i < n2; ++i) {\n+            final byte[] ensureBufferSize = this.ensureBufferSize(this.decodeSize, context);\n+            final byte b = array[n++];\n             if (b == this.pad) {\n                 context.eof = true;\n                 break;\n             }\n             if (b >= 0 && b < Base64.DECODE_TABLE.length) {\n-                final int result = Base64.DECODE_TABLE[b];\n-                if (result >= 0) {\n+                final byte b2 = Base64.DECODE_TABLE[b];\n+                if (b2 >= 0) {\n                     context.modulus = (context.modulus + 1) % 4;\n-                    context.ibitWorkArea = (context.ibitWorkArea << 6) + result;\n+                    context.ibitWorkArea = (context.ibitWorkArea << 6) + b2;\n                     if (context.modulus == 0) {\n-                        buffer[context.pos++] = (byte)(context.ibitWorkArea >> 16 & 0xFF);\n-                        buffer[context.pos++] = (byte)(context.ibitWorkArea >> 8 & 0xFF);\n-                        buffer[context.pos++] = (byte)(context.ibitWorkArea & 0xFF);\n+                        ensureBufferSize[context.pos++] = (byte)(context.ibitWorkArea >> 16 & 0xFF);\n+                        ensureBufferSize[context.pos++] = (byte)(context.ibitWorkArea >> 8 & 0xFF);\n+                        ensureBufferSize[context.pos++] = (byte)(context.ibitWorkArea & 0xFF);\n                     }\n                 }\n             }\n         }\n         if (context.eof && context.modulus != 0) {\n-            final byte[] buffer2 = this.ensureBufferSize(this.decodeSize, context);\n+            final byte[] ensureBufferSize2 = this.ensureBufferSize(this.decodeSize, context);\n             switch (context.modulus) {\n                 case 1: {\n                     break;\n                 }\n                 case 2: {\n                     context.ibitWorkArea >>= 4;\n-                    buffer2[context.pos++] = (byte)(context.ibitWorkArea & 0xFF);\n+                    ensureBufferSize2[context.pos++] = (byte)(context.ibitWorkArea & 0xFF);\n                     break;\n                 }\n                 case 3: {\n                     context.ibitWorkArea >>= 2;\n-                    buffer2[context.pos++] = (byte)(context.ibitWorkArea >> 8 & 0xFF);\n-                    buffer2[context.pos++] = (byte)(context.ibitWorkArea & 0xFF);\n+                    ensureBufferSize2[context.pos++] = (byte)(context.ibitWorkArea >> 8 & 0xFF);\n+                    ensureBufferSize2[context.pos++] = (byte)(context.ibitWorkArea & 0xFF);\n                     break;\n                 }\n                 default: {\n                     throw new IllegalStateException(\"Impossible modulus \" + context.modulus);\n                 }\n             }\n         }\n     }\n     \n     @Deprecated\n-    public static boolean isArrayByteBase64(final byte[] arrayOctet) {\n-        return isBase64(arrayOctet);\n+    public static boolean isArrayByteBase64(final byte[] array) {\n+        return isBase64(array);\n     }\n     \n-    public static boolean isBase64(final byte octet) {\n-        return octet == 61 || (octet >= 0 && octet < Base64.DECODE_TABLE.length && Base64.DECODE_TABLE[octet] != -1);\n+    public static boolean isBase64(final byte b) {\n+        return b == 61 || (b >= 0 && b < Base64.DECODE_TABLE.length && Base64.DECODE_TABLE[b] != -1);\n     }\n     \n-    public static boolean isBase64(final String base64) {\n-        return isBase64(StringUtils.getBytesUtf8(base64));\n+    public static boolean isBase64(final String s) {\n+        return isBase64(StringUtils.getBytesUtf8(s));\n     }\n     \n-    public static boolean isBase64(final byte[] arrayOctet) {\n-        for (int i = 0; i < arrayOctet.length; ++i) {\n-            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n+    public static boolean isBase64(final byte[] array) {\n+        for (int i = 0; i < array.length; ++i) {\n+            if (!isBase64(array[i]) && !isWhiteSpace(array[i])) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    public static byte[] encodeBase64(final byte[] binaryData) {\n-        return encodeBase64(binaryData, false);\n+    public static byte[] encodeBase64(final byte[] array) {\n+        return encodeBase64(array, false);\n     }\n     \n-    public static String encodeBase64String(final byte[] binaryData) {\n-        return StringUtils.newStringUsAscii(encodeBase64(binaryData, false));\n+    public static String encodeBase64String(final byte[] array) {\n+        return StringUtils.newStringUsAscii(encodeBase64(array, false));\n     }\n     \n-    public static byte[] encodeBase64URLSafe(final byte[] binaryData) {\n-        return encodeBase64(binaryData, false, true);\n+    public static byte[] encodeBase64URLSafe(final byte[] array) {\n+        return encodeBase64(array, false, true);\n     }\n     \n-    public static String encodeBase64URLSafeString(final byte[] binaryData) {\n-        return StringUtils.newStringUsAscii(encodeBase64(binaryData, false, true));\n+    public static String encodeBase64URLSafeString(final byte[] array) {\n+        return StringUtils.newStringUsAscii(encodeBase64(array, false, true));\n     }\n     \n-    public static byte[] encodeBase64Chunked(final byte[] binaryData) {\n-        return encodeBase64(binaryData, true);\n+    public static byte[] encodeBase64Chunked(final byte[] array) {\n+        return encodeBase64(array, true);\n     }\n     \n-    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked) {\n-        return encodeBase64(binaryData, isChunked, false);\n+    public static byte[] encodeBase64(final byte[] array, final boolean b) {\n+        return encodeBase64(array, b, false);\n     }\n     \n-    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked, final boolean urlSafe) {\n-        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n+    public static byte[] encodeBase64(final byte[] array, final boolean b, final boolean b2) {\n+        return encodeBase64(array, b, b2, Integer.MAX_VALUE);\n     }\n     \n-    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked, final boolean urlSafe, final int maxResultSize) {\n-        if (binaryData == null || binaryData.length == 0) {\n-            return binaryData;\n+    public static byte[] encodeBase64(final byte[] array, final boolean b, final boolean b2, final int i) {\n+        if (array == null || array.length == 0) {\n+            return array;\n         }\n-        final Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, Base64.CHUNK_SEPARATOR, urlSafe);\n-        final long len = b64.getEncodedLength(binaryData);\n-        if (len > maxResultSize) {\n-            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" + len + \") than the specified maximum size of \" + maxResultSize);\n+        final Base64 base64 = b ? new Base64(b2) : new Base64(0, Base64.CHUNK_SEPARATOR, b2);\n+        final long encodedLength = base64.getEncodedLength(array);\n+        if (encodedLength > i) {\n+            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" + encodedLength + \") than the specified maximum size of \" + i);\n         }\n-        return b64.encode(binaryData);\n+        return base64.encode(array);\n     }\n     \n-    public static byte[] decodeBase64(final String base64String) {\n-        return new Base64().decode(base64String);\n+    public static byte[] decodeBase64(final String s) {\n+        return new Base64().decode(s);\n     }\n     \n-    public static byte[] decodeBase64(final byte[] base64Data) {\n-        return new Base64().decode(base64Data);\n+    public static byte[] decodeBase64(final byte[] array) {\n+        return new Base64().decode(array);\n     }\n     \n-    public static BigInteger decodeInteger(final byte[] pArray) {\n-        return new BigInteger(1, decodeBase64(pArray));\n+    public static BigInteger decodeInteger(final byte[] array) {\n+        return new BigInteger(1, decodeBase64(array));\n     }\n     \n-    public static byte[] encodeInteger(final BigInteger bigInt) {\n-        if (bigInt == null) {\n+    public static byte[] encodeInteger(final BigInteger bigInteger) {\n+        if (bigInteger == null) {\n             throw new NullPointerException(\"encodeInteger called with null parameter\");\n         }\n-        return encodeBase64(toIntegerBytes(bigInt), false);\n+        return encodeBase64(toIntegerBytes(bigInteger), false);\n     }\n     \n-    static byte[] toIntegerBytes(final BigInteger bigInt) {\n-        int bitlen = bigInt.bitLength();\n-        bitlen = bitlen + 7 >> 3 << 3;\n-        final byte[] bigBytes = bigInt.toByteArray();\n-        if (bigInt.bitLength() % 8 != 0 && bigInt.bitLength() / 8 + 1 == bitlen / 8) {\n-            return bigBytes;\n-        }\n-        int startSrc = 0;\n-        int len = bigBytes.length;\n-        if (bigInt.bitLength() % 8 == 0) {\n-            startSrc = 1;\n-            --len;\n-        }\n-        final int startDst = bitlen / 8 - len;\n-        final byte[] resizedBytes = new byte[bitlen / 8];\n-        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n-        return resizedBytes;\n+    static byte[] toIntegerBytes(final BigInteger bigInteger) {\n+        final int n = bigInteger.bitLength() + 7 >> 3 << 3;\n+        final byte[] byteArray = bigInteger.toByteArray();\n+        if (bigInteger.bitLength() % 8 != 0 && bigInteger.bitLength() / 8 + 1 == n / 8) {\n+            return byteArray;\n+        }\n+        int n2 = 0;\n+        int length = byteArray.length;\n+        if (bigInteger.bitLength() % 8 == 0) {\n+            n2 = 1;\n+            --length;\n+        }\n+        final int n3 = n / 8 - length;\n+        final byte[] array = new byte[n / 8];\n+        System.arraycopy(byteArray, n2, array, n3, length);\n+        return array;\n     }\n     \n-    protected boolean isInAlphabet(final byte octet) {\n-        return octet >= 0 && octet < this.decodeTable.length && this.decodeTable[octet] != -1;\n+    protected boolean isInAlphabet(final byte b) {\n+        return b >= 0 && b < this.decodeTable.length && this.decodeTable[b] != -1;\n     }\n     \n     static {\n         CHUNK_SEPARATOR = new byte[] { 13, 10 };\n         STANDARD_ENCODE_TABLE = new byte[] { 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47 };\n         URL_SAFE_ENCODE_TABLE = new byte[] { 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 45, 95 };\n         DECODE_TABLE = new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51 };\n"}]}
