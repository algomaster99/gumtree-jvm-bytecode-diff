{"diffoscope-json-version": 1, "source1": "first/Blake3.class", "source2": "second/Blake3.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -20,165 +20,164 @@\n     private static final int ROOT = 8;\n     private static final int KEYED_HASH = 16;\n     private static final int DERIVE_KEY_CONTEXT = 32;\n     private static final int DERIVE_KEY_MATERIAL = 64;\n     private static final byte[][] MSG_SCHEDULE;\n     private final Blake3.EngineState engineState;\n     \n-    private Blake3(final int[] key, final int flags) {\n-        this.engineState = new Blake3.EngineState(key, flags, (Blake3.Blake3$1)null);\n+    private Blake3(final int[] array, final int n) {\n+        this.engineState = new Blake3.EngineState(array, n, (Blake3.Blake3$1)null);\n     }\n     \n     public Blake3 reset() {\n         Blake3.EngineState.access$100(this.engineState);\n         return this;\n     }\n     \n-    public Blake3 update(final byte[] in) {\n-        return this.update(in, 0, in.length);\n+    public Blake3 update(final byte[] array) {\n+        return this.update(array, 0, array.length);\n     }\n     \n-    public Blake3 update(final byte[] in, final int offset, final int length) {\n-        checkBufferArgs(in, offset, length);\n-        Blake3.EngineState.access$200(this.engineState, in, offset, length);\n+    public Blake3 update(final byte[] array, final int n, final int n2) {\n+        checkBufferArgs(array, n, n2);\n+        Blake3.EngineState.access$200(this.engineState, array, n, n2);\n         return this;\n     }\n     \n-    public Blake3 doFinalize(final byte[] out) {\n-        return this.doFinalize(out, 0, out.length);\n+    public Blake3 doFinalize(final byte[] array) {\n+        return this.doFinalize(array, 0, array.length);\n     }\n     \n-    public Blake3 doFinalize(final byte[] out, final int offset, final int length) {\n-        checkBufferArgs(out, offset, length);\n-        Blake3.EngineState.access$300(this.engineState, out, offset, length);\n+    public Blake3 doFinalize(final byte[] array, final int n, final int n2) {\n+        checkBufferArgs(array, n, n2);\n+        Blake3.EngineState.access$300(this.engineState, array, n, n2);\n         return this;\n     }\n     \n-    public byte[] doFinalize(final int nrBytes) {\n-        if (nrBytes < 0) {\n+    public byte[] doFinalize(final int n) {\n+        if (n < 0) {\n             throw new IllegalArgumentException(\"Requested bytes must be non-negative\");\n         }\n-        final byte[] hash = new byte[nrBytes];\n-        this.doFinalize(hash);\n-        return hash;\n+        final byte[] array = new byte[n];\n+        this.doFinalize(array);\n+        return array;\n     }\n     \n     public static Blake3 initHash() {\n         return new Blake3(Blake3.IV, 0);\n     }\n     \n-    public static Blake3 initKeyedHash(final byte[] key) {\n-        Objects.requireNonNull(key);\n-        if (key.length != 32) {\n+    public static Blake3 initKeyedHash(final byte[] obj) {\n+        Objects.requireNonNull(obj);\n+        if (obj.length != 32) {\n             throw new IllegalArgumentException(\"Blake3 keys must be 32 bytes\");\n         }\n-        return new Blake3(unpackInts(key, 8), 16);\n+        return new Blake3(unpackInts(obj, 8), 16);\n     }\n     \n-    public static Blake3 initKeyDerivationFunction(final byte[] kdfContext) {\n-        Objects.requireNonNull(kdfContext);\n-        final Blake3.EngineState kdf = new Blake3.EngineState(Blake3.IV, 32, (Blake3.Blake3$1)null);\n-        Blake3.EngineState.access$200(kdf, kdfContext, 0, kdfContext.length);\n-        final byte[] key = new byte[32];\n-        Blake3.EngineState.access$300(kdf, key, 0, key.length);\n-        return new Blake3(unpackInts(key, 8), 64);\n+    public static Blake3 initKeyDerivationFunction(final byte[] obj) {\n+        Objects.requireNonNull(obj);\n+        final Blake3.EngineState engineState = new Blake3.EngineState(Blake3.IV, 32, (Blake3.Blake3$1)null);\n+        Blake3.EngineState.access$200(engineState, obj, 0, obj.length);\n+        final byte[] array = new byte[32];\n+        Blake3.EngineState.access$300(engineState, array, 0, array.length);\n+        return new Blake3(unpackInts(array, 8), 64);\n     }\n     \n-    public static byte[] hash(final byte[] data) {\n-        return initHash().update(data).doFinalize(32);\n+    public static byte[] hash(final byte[] array) {\n+        return initHash().update(array).doFinalize(32);\n     }\n     \n-    public static byte[] keyedHash(final byte[] key, final byte[] data) {\n-        return initKeyedHash(key).update(data).doFinalize(32);\n+    public static byte[] keyedHash(final byte[] array, final byte[] array2) {\n+        return initKeyedHash(array).update(array2).doFinalize(32);\n     }\n     \n-    private static void checkBufferArgs(final byte[] buffer, final int offset, final int length) {\n-        Objects.requireNonNull(buffer);\n-        if (offset < 0) {\n+    private static void checkBufferArgs(final byte[] obj, final int i, final int j) {\n+        Objects.requireNonNull(obj);\n+        if (i < 0) {\n             throw new IndexOutOfBoundsException(\"Offset must be non-negative\");\n         }\n-        if (length < 0) {\n+        if (j < 0) {\n             throw new IndexOutOfBoundsException(\"Length must be non-negative\");\n         }\n-        final int bufferLength = buffer.length;\n-        if (offset > bufferLength - length) {\n-            throw new IndexOutOfBoundsException(\"Offset \" + offset + \" and length \" + length + \" out of bounds with buffer length \" + bufferLength);\n+        final int length = obj.length;\n+        if (i > length - j) {\n+            throw new IndexOutOfBoundsException(\"Offset \" + i + \" and length \" + j + \" out of bounds with buffer length \" + length);\n         }\n     }\n     \n-    private static void packInt(final int value, final byte[] dst, final int off, final int len) {\n-        for (int i = 0; i < len; ++i) {\n-            dst[off + i] = (byte)(value >>> i * 8);\n+    private static void packInt(final int n, final byte[] array, final int n2, final int n3) {\n+        for (int i = 0; i < n3; ++i) {\n+            array[n2 + i] = (byte)(n >>> i * 8);\n         }\n     }\n     \n-    private static int unpackInt(final byte[] buf, final int off) {\n-        return (buf[off] & 0xFF) | (buf[off + 1] & 0xFF) << 8 | (buf[off + 2] & 0xFF) << 16 | (buf[off + 3] & 0xFF) << 24;\n+    private static int unpackInt(final byte[] array, final int n) {\n+        return (array[n] & 0xFF) | (array[n + 1] & 0xFF) << 8 | (array[n + 2] & 0xFF) << 16 | (array[n + 3] & 0xFF) << 24;\n     }\n     \n-    private static int[] unpackInts(final byte[] buf, final int nrInts) {\n-        final int[] values = new int[nrInts];\n-        for (int i = 0, off = 0; i < nrInts; ++i, off += 4) {\n-            values[i] = unpackInt(buf, off);\n+    private static int[] unpackInts(final byte[] array, final int n) {\n+        final int[] array2 = new int[n];\n+        for (int i = 0, n2 = 0; i < n; ++i, n2 += 4) {\n+            array2[i] = unpackInt(array, n2);\n         }\n-        return values;\n+        return array2;\n     }\n     \n-    private static void g(final int[] state, final int a, final int b, final int c, final int d, final int mx, final int my) {\n-        state[a] += state[b] + mx;\n-        state[d] = Integer.rotateRight(state[d] ^ state[a], 16);\n-        state[c] += state[d];\n-        state[b] = Integer.rotateRight(state[b] ^ state[c], 12);\n-        state[a] += state[b] + my;\n-        state[d] = Integer.rotateRight(state[d] ^ state[a], 8);\n-        state[c] += state[d];\n-        state[b] = Integer.rotateRight(state[b] ^ state[c], 7);\n+    private static void g(final int[] array, final int n, final int n2, final int n3, final int n4, final int n5, final int n6) {\n+        array[n] += array[n2] + n5;\n+        array[n4] = Integer.rotateRight(array[n4] ^ array[n], 16);\n+        array[n3] += array[n4];\n+        array[n2] = Integer.rotateRight(array[n2] ^ array[n3], 12);\n+        array[n] += array[n2] + n6;\n+        array[n4] = Integer.rotateRight(array[n4] ^ array[n], 8);\n+        array[n3] += array[n4];\n+        array[n2] = Integer.rotateRight(array[n2] ^ array[n3], 7);\n     }\n     \n-    private static void round(final int[] state, final int[] msg, final byte[] schedule) {\n-        g(state, 0, 4, 8, 12, msg[schedule[0]], msg[schedule[1]]);\n-        g(state, 1, 5, 9, 13, msg[schedule[2]], msg[schedule[3]]);\n-        g(state, 2, 6, 10, 14, msg[schedule[4]], msg[schedule[5]]);\n-        g(state, 3, 7, 11, 15, msg[schedule[6]], msg[schedule[7]]);\n-        g(state, 0, 5, 10, 15, msg[schedule[8]], msg[schedule[9]]);\n-        g(state, 1, 6, 11, 12, msg[schedule[10]], msg[schedule[11]]);\n-        g(state, 2, 7, 8, 13, msg[schedule[12]], msg[schedule[13]]);\n-        g(state, 3, 4, 9, 14, msg[schedule[14]], msg[schedule[15]]);\n+    private static void round(final int[] array, final int[] array2, final byte[] array3) {\n+        g(array, 0, 4, 8, 12, array2[array3[0]], array2[array3[1]]);\n+        g(array, 1, 5, 9, 13, array2[array3[2]], array2[array3[3]]);\n+        g(array, 2, 6, 10, 14, array2[array3[4]], array2[array3[5]]);\n+        g(array, 3, 7, 11, 15, array2[array3[6]], array2[array3[7]]);\n+        g(array, 0, 5, 10, 15, array2[array3[8]], array2[array3[9]]);\n+        g(array, 1, 6, 11, 12, array2[array3[10]], array2[array3[11]]);\n+        g(array, 2, 7, 8, 13, array2[array3[12]], array2[array3[13]]);\n+        g(array, 3, 4, 9, 14, array2[array3[14]], array2[array3[15]]);\n     }\n     \n-    private static int[] compress(final int[] chainingValue, final int[] blockWords, final int blockLength, final long counter, final int flags) {\n-        final int[] state = Arrays.copyOf(chainingValue, 16);\n-        System.arraycopy(Blake3.IV, 0, state, 8, 4);\n-        state[12] = (int)counter;\n-        state[13] = (int)(counter >> 32);\n-        state[14] = blockLength;\n-        state[15] = flags;\n+    private static int[] compress(final int[] original, final int[] array, final int n, final long n2, final int n3) {\n+        final int[] copy = Arrays.copyOf(original, 16);\n+        System.arraycopy(Blake3.IV, 0, copy, 8, 4);\n+        copy[12] = (int)n2;\n+        copy[13] = (int)(n2 >> 32);\n+        copy[14] = n;\n+        copy[15] = n3;\n         for (int i = 0; i < 7; ++i) {\n-            final byte[] schedule = Blake3.MSG_SCHEDULE[i];\n-            round(state, blockWords, schedule);\n+            round(copy, array, Blake3.MSG_SCHEDULE[i]);\n         }\n-        for (int i = 0; i < state.length / 2; ++i) {\n-            final int[] array = state;\n-            final int n = i;\n-            array[n] ^= state[i + 8];\n-            final int[] array2 = state;\n-            final int n2 = i + 8;\n-            array2[n2] ^= chainingValue[i];\n+        for (int j = 0; j < copy.length / 2; ++j) {\n+            final int[] array2 = copy;\n+            final int n4 = j;\n+            array2[n4] ^= copy[j + 8];\n+            final int[] array3 = copy;\n+            final int n5 = j + 8;\n+            array3[n5] ^= original[j];\n         }\n-        return state;\n+        return copy;\n     }\n     \n-    private static Blake3.Output parentOutput(final int[] leftChildCV, final int[] rightChildCV, final int[] key, final int flags) {\n-        final int[] blockWords = Arrays.copyOf(leftChildCV, 16);\n-        System.arraycopy(rightChildCV, 0, blockWords, 8, 8);\n-        return new Blake3.Output((int[])key.clone(), blockWords, 0L, 64, flags | 0x4, (Blake3.Blake3$1)null);\n+    private static Blake3.Output parentOutput(final int[] original, final int[] array, final int[] array2, final int n) {\n+        final int[] copy = Arrays.copyOf(original, 16);\n+        System.arraycopy(array, 0, copy, 8, 8);\n+        return new Blake3.Output((int[])array2.clone(), copy, 0L, 64, n | 0x4, (Blake3.Blake3$1)null);\n     }\n     \n-    private static int[] parentChainingValue(final int[] leftChildCV, final int[] rightChildCV, final int[] key, final int flags) {\n-        return Blake3.Output.access$500(parentOutput(leftChildCV, rightChildCV, key, flags));\n+    private static int[] parentChainingValue(final int[] array, final int[] array2, final int[] array3, final int n) {\n+        return Blake3.Output.access$500(parentOutput(array, array2, array3, n));\n     }\n     \n     static {\n         IV = new int[] { 1779033703, -1150833019, 1013904242, -1521486534, 1359893119, -1694144372, 528734635, 1541459225 };\n         MSG_SCHEDULE = new byte[][] { { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }, { 2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8 }, { 3, 4, 10, 12, 13, 2, 7, 14, 6, 5, 9, 0, 11, 15, 8, 1 }, { 10, 7, 12, 9, 14, 3, 13, 15, 4, 0, 11, 2, 5, 8, 1, 6 }, { 12, 13, 9, 11, 15, 10, 14, 8, 7, 2, 5, 3, 0, 1, 6, 4 }, { 9, 14, 11, 5, 8, 12, 15, 1, 13, 3, 0, 10, 2, 6, 4, 7 }, { 11, 15, 5, 0, 1, 9, 8, 6, 14, 10, 2, 12, 3, 4, 7, 13 } };\n     }\n }\n"}]}
