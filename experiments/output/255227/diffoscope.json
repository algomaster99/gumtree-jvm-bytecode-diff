{"diffoscope-json-version": 1, "source1": "first/X7875_NewUnix.class", "source2": "second/X7875_NewUnix.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -29,88 +29,86 @@\n         return ZipUtil.bigToLong(this.uid);\n     }\n     \n     public long getGID() {\n         return ZipUtil.bigToLong(this.gid);\n     }\n     \n-    public void setUID(final long l) {\n-        this.uid = ZipUtil.longToBig(l);\n+    public void setUID(final long n) {\n+        this.uid = ZipUtil.longToBig(n);\n     }\n     \n-    public void setGID(final long l) {\n-        this.gid = ZipUtil.longToBig(l);\n+    public void setGID(final long n) {\n+        this.gid = ZipUtil.longToBig(n);\n     }\n     \n     public ZipShort getLocalFileDataLength() {\n-        byte[] b = trimLeadingZeroesForceMinLength(this.uid.toByteArray());\n-        final int uidSize = (b == null) ? 0 : b.length;\n-        b = trimLeadingZeroesForceMinLength(this.gid.toByteArray());\n-        final int gidSize = (b == null) ? 0 : b.length;\n-        return new ZipShort(3 + uidSize + gidSize);\n+        final byte[] trimLeadingZeroesForceMinLength = trimLeadingZeroesForceMinLength(this.uid.toByteArray());\n+        final int n = (trimLeadingZeroesForceMinLength == null) ? 0 : trimLeadingZeroesForceMinLength.length;\n+        final byte[] trimLeadingZeroesForceMinLength2 = trimLeadingZeroesForceMinLength(this.gid.toByteArray());\n+        return new ZipShort(3 + n + ((trimLeadingZeroesForceMinLength2 == null) ? 0 : trimLeadingZeroesForceMinLength2.length));\n     }\n     \n     public ZipShort getCentralDirectoryLength() {\n         return X7875_NewUnix.ZERO;\n     }\n     \n     public byte[] getLocalFileDataData() {\n-        byte[] uidBytes = this.uid.toByteArray();\n-        byte[] gidBytes = this.gid.toByteArray();\n-        uidBytes = trimLeadingZeroesForceMinLength(uidBytes);\n-        final int uidBytesLen = (uidBytes != null) ? uidBytes.length : 0;\n-        gidBytes = trimLeadingZeroesForceMinLength(gidBytes);\n-        final int gidBytesLen = (gidBytes != null) ? gidBytes.length : 0;\n-        final byte[] data = new byte[3 + uidBytesLen + gidBytesLen];\n-        if (uidBytes != null) {\n-            ZipUtil.reverse(uidBytes);\n-        }\n-        if (gidBytes != null) {\n-            ZipUtil.reverse(gidBytes);\n-        }\n-        int pos = 0;\n-        data[pos++] = ZipUtil.unsignedIntToSignedByte(this.version);\n-        data[pos++] = ZipUtil.unsignedIntToSignedByte(uidBytesLen);\n-        if (uidBytes != null) {\n-            System.arraycopy(uidBytes, 0, data, pos, uidBytesLen);\n-        }\n-        pos += uidBytesLen;\n-        data[pos++] = ZipUtil.unsignedIntToSignedByte(gidBytesLen);\n-        if (gidBytes != null) {\n-            System.arraycopy(gidBytes, 0, data, pos, gidBytesLen);\n+        final byte[] byteArray = this.uid.toByteArray();\n+        final byte[] byteArray2 = this.gid.toByteArray();\n+        final byte[] trimLeadingZeroesForceMinLength = trimLeadingZeroesForceMinLength(byteArray);\n+        final int n = (trimLeadingZeroesForceMinLength != null) ? trimLeadingZeroesForceMinLength.length : 0;\n+        final byte[] trimLeadingZeroesForceMinLength2 = trimLeadingZeroesForceMinLength(byteArray2);\n+        final int n2 = (trimLeadingZeroesForceMinLength2 != null) ? trimLeadingZeroesForceMinLength2.length : 0;\n+        final byte[] array = new byte[3 + n + n2];\n+        if (trimLeadingZeroesForceMinLength != null) {\n+            ZipUtil.reverse(trimLeadingZeroesForceMinLength);\n+        }\n+        if (trimLeadingZeroesForceMinLength2 != null) {\n+            ZipUtil.reverse(trimLeadingZeroesForceMinLength2);\n+        }\n+        int n3 = 0;\n+        array[n3++] = ZipUtil.unsignedIntToSignedByte(this.version);\n+        array[n3++] = ZipUtil.unsignedIntToSignedByte(n);\n+        if (trimLeadingZeroesForceMinLength != null) {\n+            System.arraycopy(trimLeadingZeroesForceMinLength, 0, array, n3, n);\n+        }\n+        int n4 = n3 + n;\n+        array[n4++] = ZipUtil.unsignedIntToSignedByte(n2);\n+        if (trimLeadingZeroesForceMinLength2 != null) {\n+            System.arraycopy(trimLeadingZeroesForceMinLength2, 0, array, n4, n2);\n         }\n-        return data;\n+        return array;\n     }\n     \n     public byte[] getCentralDirectoryData() {\n         return new byte[0];\n     }\n     \n-    public void parseFromLocalFileData(final byte[] data, int offset, final int length) throws ZipException {\n+    public void parseFromLocalFileData(final byte[] array, int n, final int n2) throws ZipException {\n         this.reset();\n-        if (length < 3) {\n-            throw new ZipException(\"X7875_NewUnix length is too short, only \" + length + \" bytes\");\n+        if (n2 < 3) {\n+            throw new ZipException(\"X7875_NewUnix length is too short, only \" + n2 + \" bytes\");\n         }\n-        this.version = ZipUtil.signedByteToUnsignedInt(data[offset++]);\n-        final int uidSize = ZipUtil.signedByteToUnsignedInt(data[offset++]);\n-        if (uidSize + 3 > length) {\n-            throw new ZipException(\"X7875_NewUnix invalid: uidSize \" + uidSize + \" doesn't fit into \" + length + \" bytes\");\n-        }\n-        final byte[] uidBytes = Arrays.copyOfRange(data, offset, offset + uidSize);\n-        offset += uidSize;\n-        this.uid = new BigInteger(1, ZipUtil.reverse(uidBytes));\n-        final int gidSize = ZipUtil.signedByteToUnsignedInt(data[offset++]);\n-        if (uidSize + 3 + gidSize > length) {\n-            throw new ZipException(\"X7875_NewUnix invalid: gidSize \" + gidSize + \" doesn't fit into \" + length + \" bytes\");\n+        this.version = ZipUtil.signedByteToUnsignedInt(array[n++]);\n+        final int signedByteToUnsignedInt = ZipUtil.signedByteToUnsignedInt(array[n++]);\n+        if (signedByteToUnsignedInt + 3 > n2) {\n+            throw new ZipException(\"X7875_NewUnix invalid: uidSize \" + signedByteToUnsignedInt + \" doesn't fit into \" + n2 + \" bytes\");\n         }\n-        final byte[] gidBytes = Arrays.copyOfRange(data, offset, offset + gidSize);\n-        this.gid = new BigInteger(1, ZipUtil.reverse(gidBytes));\n+        final byte[] copyOfRange = Arrays.copyOfRange(array, n, n + signedByteToUnsignedInt);\n+        n += signedByteToUnsignedInt;\n+        this.uid = new BigInteger(1, ZipUtil.reverse(copyOfRange));\n+        final int signedByteToUnsignedInt2 = ZipUtil.signedByteToUnsignedInt(array[n++]);\n+        if (signedByteToUnsignedInt + 3 + signedByteToUnsignedInt2 > n2) {\n+            throw new ZipException(\"X7875_NewUnix invalid: gidSize \" + signedByteToUnsignedInt2 + \" doesn't fit into \" + n2 + \" bytes\");\n+        }\n+        this.gid = new BigInteger(1, ZipUtil.reverse(Arrays.copyOfRange(array, n, n + signedByteToUnsignedInt2)));\n     }\n     \n-    public void parseFromCentralDirectoryData(final byte[] buffer, final int offset, final int length) throws ZipException {\n+    public void parseFromCentralDirectoryData(final byte[] array, final int n, final int n2) throws ZipException {\n     }\n     \n     private void reset() {\n         this.uid = X7875_NewUnix.ONE_THOUSAND;\n         this.gid = X7875_NewUnix.ONE_THOUSAND;\n     }\n     \n@@ -122,44 +120,37 @@\n     public Object clone() throws CloneNotSupportedException {\n         return super.clone();\n     }\n     \n     @Override\n     public boolean equals(final Object o) {\n         if (o instanceof X7875_NewUnix) {\n-            final X7875_NewUnix xf = (X7875_NewUnix)o;\n-            return this.version == xf.version && this.uid.equals(xf.uid) && this.gid.equals(xf.gid);\n+            final X7875_NewUnix x7875_NewUnix = (X7875_NewUnix)o;\n+            return this.version == x7875_NewUnix.version && this.uid.equals(x7875_NewUnix.uid) && this.gid.equals(x7875_NewUnix.gid);\n         }\n         return false;\n     }\n     \n     @Override\n     public int hashCode() {\n-        int hc = -1234567 * this.version;\n-        hc ^= Integer.rotateLeft(this.uid.hashCode(), 16);\n-        hc ^= this.gid.hashCode();\n-        return hc;\n+        return -1234567 * this.version ^ Integer.rotateLeft(this.uid.hashCode(), 16) ^ this.gid.hashCode();\n     }\n     \n     static byte[] trimLeadingZeroesForceMinLength(final byte[] array) {\n         if (array == null) {\n             return array;\n         }\n-        int pos = 0;\n-        for (final byte b : array) {\n-            if (b != 0) {\n-                break;\n-            }\n-            ++pos;\n-        }\n-        final int MIN_LENGTH = 1;\n-        final byte[] trimmedArray = new byte[Math.max(1, array.length - pos)];\n-        final int startPos = trimmedArray.length - (array.length - pos);\n-        System.arraycopy(array, pos, trimmedArray, startPos, trimmedArray.length - startPos);\n-        return trimmedArray;\n+        int n = 0;\n+        for (int length = array.length, n2 = 0; n2 < length && array[n2] == 0; ++n2) {\n+            ++n;\n+        }\n+        final byte[] array2 = new byte[Math.max(1, array.length - n)];\n+        final int n3 = array2.length - (array.length - n);\n+        System.arraycopy(array, n, array2, n3, array2.length - n3);\n+        return array2;\n     }\n     \n     static {\n         HEADER_ID = new ZipShort(30837);\n         ZERO = new ZipShort(0);\n         ONE_THOUSAND = BigInteger.valueOf(1000L);\n     }\n"}]}
