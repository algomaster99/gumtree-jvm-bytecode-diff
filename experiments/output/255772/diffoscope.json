{"diffoscope-json-version": 1, "source1": "first/BlockSort.class", "source2": "second/BlockSort.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -35,685 +35,681 @@\n         this.mainSort_runningOrder = new int[256];\n         this.mainSort_copy = new int[256];\n         this.mainSort_bigDone = new boolean[256];\n         this.ftab = new int[65537];\n         this.quadrant = data.sfmap;\n     }\n     \n-    void blockSort(final BZip2CompressorOutputStream.Data data, final int last) {\n-        this.workLimit = 30 * last;\n+    void blockSort(final BZip2CompressorOutputStream.Data data, final int n) {\n+        this.workLimit = 30 * n;\n         this.workDone = 0;\n         this.firstAttempt = true;\n-        if (last + 1 < 10000) {\n-            this.fallbackSort(data, last);\n+        if (n + 1 < 10000) {\n+            this.fallbackSort(data, n);\n         }\n         else {\n-            this.mainSort(data, last);\n+            this.mainSort(data, n);\n             if (this.firstAttempt && this.workDone > this.workLimit) {\n-                this.fallbackSort(data, last);\n+                this.fallbackSort(data, n);\n             }\n         }\n         final int[] fmap = data.fmap;\n         data.origPtr = -1;\n-        for (int i = 0; i <= last; ++i) {\n+        for (int i = 0; i <= n; ++i) {\n             if (fmap[i] == 0) {\n                 data.origPtr = i;\n                 break;\n             }\n         }\n     }\n     \n-    final void fallbackSort(final BZip2CompressorOutputStream.Data data, final int last) {\n-        data.block[0] = data.block[last + 1];\n-        this.fallbackSort(data.fmap, data.block, last + 1);\n-        for (int i = 0; i < last + 1; ++i) {\n+    final void fallbackSort(final BZip2CompressorOutputStream.Data data, final int n) {\n+        data.block[0] = data.block[n + 1];\n+        this.fallbackSort(data.fmap, data.block, n + 1);\n+        for (int i = 0; i < n + 1; ++i) {\n             final int[] fmap = data.fmap;\n-            final int n = i;\n-            --fmap[n];\n+            final int n2 = i;\n+            --fmap[n2];\n         }\n-        for (int i = 0; i < last + 1; ++i) {\n-            if (data.fmap[i] == -1) {\n-                data.fmap[i] = last;\n+        for (int j = 0; j < n + 1; ++j) {\n+            if (data.fmap[j] == -1) {\n+                data.fmap[j] = n;\n                 break;\n             }\n         }\n     }\n     \n-    private void fallbackSimpleSort(final int[] fmap, final int[] eclass, final int lo, final int hi) {\n-        if (lo == hi) {\n+    private void fallbackSimpleSort(final int[] array, final int[] array2, final int n, final int n2) {\n+        if (n == n2) {\n             return;\n         }\n-        if (hi - lo > 3) {\n-            for (int i = hi - 4; i >= lo; --i) {\n-                final int tmp = fmap[i];\n-                int ec_tmp;\n-                int j;\n-                for (ec_tmp = eclass[tmp], j = i + 4; j <= hi && ec_tmp > eclass[fmap[j]]; j += 4) {\n-                    fmap[j - 4] = fmap[j];\n+        if (n2 - n > 3) {\n+            for (int i = n2 - 4; i >= n; --i) {\n+                final int n3 = array[i];\n+                int n4;\n+                int n5;\n+                for (n4 = array2[n3], n5 = i + 4; n5 <= n2 && n4 > array2[array[n5]]; n5 += 4) {\n+                    array[n5 - 4] = array[n5];\n                 }\n-                fmap[j - 4] = tmp;\n+                array[n5 - 4] = n3;\n             }\n         }\n-        for (int i = hi - 1; i >= lo; --i) {\n-            final int tmp = fmap[i];\n-            int ec_tmp;\n-            int j;\n-            for (ec_tmp = eclass[tmp], j = i + 1; j <= hi && ec_tmp > eclass[fmap[j]]; ++j) {\n-                fmap[j - 1] = fmap[j];\n+        for (int j = n2 - 1; j >= n; --j) {\n+            final int n6 = array[j];\n+            int n7;\n+            int n8;\n+            for (n7 = array2[n6], n8 = j + 1; n8 <= n2 && n7 > array2[array[n8]]; ++n8) {\n+                array[n8 - 1] = array[n8];\n             }\n-            fmap[j - 1] = tmp;\n+            array[n8 - 1] = n6;\n         }\n     }\n     \n-    private void fswap(final int[] fmap, final int zz1, final int zz2) {\n-        final int zztmp = fmap[zz1];\n-        fmap[zz1] = fmap[zz2];\n-        fmap[zz2] = zztmp;\n+    private void fswap(final int[] array, final int n, final int n2) {\n+        final int n3 = array[n];\n+        array[n] = array[n2];\n+        array[n2] = n3;\n     }\n     \n-    private void fvswap(final int[] fmap, int yyp1, int yyp2, int yyn) {\n-        while (yyn > 0) {\n-            this.fswap(fmap, yyp1, yyp2);\n-            ++yyp1;\n-            ++yyp2;\n-            --yyn;\n+    private void fvswap(final int[] array, int n, int n2, int i) {\n+        while (i > 0) {\n+            this.fswap(array, n, n2);\n+            ++n;\n+            ++n2;\n+            --i;\n         }\n     }\n     \n-    private int fmin(final int a, final int b) {\n-        return (a < b) ? a : b;\n+    private int fmin(final int n, final int n2) {\n+        return (n < n2) ? n : n2;\n     }\n     \n-    private void fpush(final int sp, final int lz, final int hz) {\n-        this.stack_ll[sp] = lz;\n-        this.stack_hh[sp] = hz;\n+    private void fpush(final int n, final int n2, final int n3) {\n+        this.stack_ll[n] = n2;\n+        this.stack_hh[n] = n3;\n     }\n     \n-    private int[] fpop(final int sp) {\n-        return new int[] { this.stack_ll[sp], this.stack_hh[sp] };\n+    private int[] fpop(final int n) {\n+        return new int[] { this.stack_ll[n], this.stack_hh[n] };\n     }\n     \n-    private void fallbackQSort3(final int[] fmap, final int[] eclass, final int loSt, final int hiSt) {\n-        long r = 0L;\n-        int sp = 0;\n-        this.fpush(sp++, loSt, hiSt);\n-        while (sp > 0) {\n-            final int[] s = this.fpop(--sp);\n-            final int lo = s[0];\n-            final int hi = s[1];\n-            if (hi - lo < 10) {\n-                this.fallbackSimpleSort(fmap, eclass, lo, hi);\n+    private void fallbackQSort3(final int[] array, final int[] array2, final int n, final int n2) {\n+        long n3 = 0L;\n+        int i = 0;\n+        this.fpush(i++, n, n2);\n+        while (i > 0) {\n+            final int[] fpop = this.fpop(--i);\n+            final int n4 = fpop[0];\n+            final int n5 = fpop[1];\n+            if (n5 - n4 < 10) {\n+                this.fallbackSimpleSort(array, array2, n4, n5);\n             }\n             else {\n-                r = (r * 7621L + 1L) % 32768L;\n-                final long r2 = r % 3L;\n-                long med;\n-                if (r2 == 0L) {\n-                    med = eclass[fmap[lo]];\n+                n3 = (n3 * 7621L + 1L) % 32768L;\n+                final long n6 = n3 % 3L;\n+                long n7;\n+                if (n6 == 0L) {\n+                    n7 = array2[array[n4]];\n                 }\n-                else if (r2 == 1L) {\n-                    med = eclass[fmap[lo + hi >>> 1]];\n+                else if (n6 == 1L) {\n+                    n7 = array2[array[n4 + n5 >>> 1]];\n                 }\n                 else {\n-                    med = eclass[fmap[hi]];\n+                    n7 = array2[array[n5]];\n                 }\n-                int unLo;\n-                int ltLo = unLo = lo;\n-                int unHi;\n-                int gtHi = unHi = hi;\n+                int j;\n+                int n8 = j = n4;\n+                int n10;\n+                int n9 = n10 = n5;\n             Label_0275_Outer:\n                 while (true) {\n-                    if (unLo <= unHi) {\n-                        final int n = eclass[fmap[unLo]] - (int)med;\n-                        if (n == 0) {\n-                            this.fswap(fmap, unLo, ltLo);\n-                            ++ltLo;\n-                            ++unLo;\n+                    if (j <= n10) {\n+                        final int n11 = array2[array[j]] - (int)n7;\n+                        if (n11 == 0) {\n+                            this.fswap(array, j, n8);\n+                            ++n8;\n+                            ++j;\n                             continue Label_0275_Outer;\n                         }\n-                        if (n <= 0) {\n-                            ++unLo;\n+                        if (n11 <= 0) {\n+                            ++j;\n                             continue Label_0275_Outer;\n                         }\n                     }\n                     while (true) {\n-                        while (unLo <= unHi) {\n-                            final int n = eclass[fmap[unHi]] - (int)med;\n-                            if (n == 0) {\n-                                this.fswap(fmap, unHi, gtHi);\n-                                --gtHi;\n-                                --unHi;\n+                        while (j <= n10) {\n+                            final int n12 = array2[array[n10]] - (int)n7;\n+                            if (n12 == 0) {\n+                                this.fswap(array, n10, n9);\n+                                --n9;\n+                                --n10;\n                             }\n-                            else if (n < 0) {\n-                                if (unLo > unHi) {\n+                            else if (n12 < 0) {\n+                                if (j > n10) {\n                                     break Label_0275_Outer;\n                                 }\n-                                this.fswap(fmap, unLo, unHi);\n-                                ++unLo;\n-                                --unHi;\n+                                this.fswap(array, j, n10);\n+                                ++j;\n+                                --n10;\n                                 continue Label_0275_Outer;\n                             }\n                             else {\n-                                --unHi;\n+                                --n10;\n                             }\n                         }\n                         continue;\n                     }\n                 }\n-                if (gtHi < ltLo) {\n+                if (n9 < n8) {\n                     continue;\n                 }\n-                int n = this.fmin(ltLo - lo, unLo - ltLo);\n-                this.fvswap(fmap, lo, unLo - n, n);\n-                int m = this.fmin(hi - gtHi, gtHi - unHi);\n-                this.fvswap(fmap, unHi + 1, hi - m + 1, m);\n-                n = lo + unLo - ltLo - 1;\n-                m = hi - (gtHi - unHi) + 1;\n-                if (n - lo > hi - m) {\n-                    this.fpush(sp++, lo, n);\n-                    this.fpush(sp++, m, hi);\n+                final int fmin = this.fmin(n8 - n4, j - n8);\n+                this.fvswap(array, n4, j - fmin, fmin);\n+                final int fmin2 = this.fmin(n5 - n9, n9 - n10);\n+                this.fvswap(array, n10 + 1, n5 - fmin2 + 1, fmin2);\n+                final int n13 = n4 + j - n8 - 1;\n+                final int n14 = n5 - (n9 - n10) + 1;\n+                if (n13 - n4 > n5 - n14) {\n+                    this.fpush(i++, n4, n13);\n+                    this.fpush(i++, n14, n5);\n                 }\n                 else {\n-                    this.fpush(sp++, m, hi);\n-                    this.fpush(sp++, lo, n);\n+                    this.fpush(i++, n14, n5);\n+                    this.fpush(i++, n4, n13);\n                 }\n             }\n         }\n     }\n     \n     private int[] getEclass() {\n         if (this.eclass == null) {\n             this.eclass = new int[this.quadrant.length / 2];\n         }\n         return this.eclass;\n     }\n     \n-    final void fallbackSort(final int[] fmap, final byte[] block, final int nblock) {\n-        final int[] ftab = new int[257];\n+    final void fallbackSort(final int[] array, final byte[] array2, final int n) {\n+        final int[] array3 = new int[257];\n         final int[] eclass = this.getEclass();\n-        for (int i = 0; i < nblock; ++i) {\n+        for (int i = 0; i < n; ++i) {\n             eclass[i] = 0;\n         }\n-        for (int i = 0; i < nblock; ++i) {\n-            final int[] array = ftab;\n-            final int n = block[i] & 0xFF;\n-            ++array[n];\n+        for (int j = 0; j < n; ++j) {\n+            final int[] array4 = array3;\n+            final int n2 = array2[j] & 0xFF;\n+            ++array4[n2];\n+        }\n+        for (int k = 1; k < 257; ++k) {\n+            final int[] array5 = array3;\n+            final int n3 = k;\n+            array5[n3] += array3[k - 1];\n+        }\n+        for (int l = 0; l < n; ++l) {\n+            final int n4 = array2[l] & 0xFF;\n+            array[--array3[n4]] = l;\n+        }\n+        final BitSet set = new BitSet(64 + n);\n+        for (int n5 = 0; n5 < 256; ++n5) {\n+            set.set(array3[n5]);\n+        }\n+        for (int n6 = 0; n6 < 32; ++n6) {\n+            set.set(n + 2 * n6);\n+            set.clear(n + 2 * n6 + 1);\n         }\n-        for (int i = 1; i < 257; ++i) {\n-            final int[] array2 = ftab;\n-            final int n2 = i;\n-            array2[n2] += ftab[i - 1];\n-        }\n-        for (int i = 0; i < nblock; ++i) {\n-            final int j = block[i] & 0xFF;\n-            final int k = ftab[j] - 1;\n-            fmap[ftab[j] = k] = i;\n-        }\n-        final int nBhtab = 64 + nblock;\n-        final BitSet bhtab = new BitSet(nBhtab);\n-        for (int i = 0; i < 256; ++i) {\n-            bhtab.set(ftab[i]);\n-        }\n-        for (int i = 0; i < 32; ++i) {\n-            bhtab.set(nblock + 2 * i);\n-            bhtab.clear(nblock + 2 * i + 1);\n-        }\n-        int H = 1;\n-        int nNotDone;\n+        int n7 = 1;\n+        int n8;\n         do {\n-            int j = 0;\n-            for (int i = 0; i < nblock; ++i) {\n-                if (bhtab.get(i)) {\n-                    j = i;\n-                }\n-                int k = fmap[i] - H;\n-                if (k < 0) {\n-                    k += nblock;\n+            int n9 = 0;\n+            for (int bitIndex = 0; bitIndex < n; ++bitIndex) {\n+                if (set.get(bitIndex)) {\n+                    n9 = bitIndex;\n+                }\n+                int n10 = array[bitIndex] - n7;\n+                if (n10 < 0) {\n+                    n10 += n;\n                 }\n-                eclass[k] = j;\n+                eclass[n10] = n9;\n             }\n-            nNotDone = 0;\n-            int r = -1;\n+            n8 = 0;\n+            int n11 = -1;\n             while (true) {\n-                int k = r + 1;\n-                k = bhtab.nextClearBit(k);\n-                final int l = k - 1;\n-                if (l >= nblock) {\n+                final int nextClearBit = set.nextClearBit(n11 + 1);\n+                final int n12 = nextClearBit - 1;\n+                if (n12 >= n) {\n                     break;\n                 }\n-                k = bhtab.nextSetBit(k + 1);\n-                r = k - 1;\n-                if (r >= nblock) {\n+                n11 = set.nextSetBit(nextClearBit + 1) - 1;\n+                if (n11 >= n) {\n                     break;\n                 }\n-                if (r <= l) {\n+                if (n11 <= n12) {\n                     continue;\n                 }\n-                nNotDone += r - l + 1;\n-                this.fallbackQSort3(fmap, eclass, l, r);\n-                int cc = -1;\n-                for (int i = l; i <= r; ++i) {\n-                    final int cc2 = eclass[fmap[i]];\n-                    if (cc != cc2) {\n-                        bhtab.set(i);\n-                        cc = cc2;\n+                n8 += n11 - n12 + 1;\n+                this.fallbackQSort3(array, eclass, n12, n11);\n+                int n13 = -1;\n+                for (int bitIndex2 = n12; bitIndex2 <= n11; ++bitIndex2) {\n+                    final int n14 = eclass[array[bitIndex2]];\n+                    if (n13 != n14) {\n+                        set.set(bitIndex2);\n+                        n13 = n14;\n                     }\n                 }\n             }\n-            H *= 2;\n-        } while (H <= nblock && nNotDone != 0);\n+            n7 *= 2;\n+        } while (n7 <= n && n8 != 0);\n     }\n     \n-    private boolean mainSimpleSort(final BZip2CompressorOutputStream.Data dataShadow, final int lo, final int hi, final int d, final int lastShadow) {\n-        final int bigN = hi - lo + 1;\n-        if (bigN < 2) {\n+    private boolean mainSimpleSort(final BZip2CompressorOutputStream.Data data, final int n, final int n2, final int n3, final int n4) {\n+        final int n5 = n2 - n + 1;\n+        if (n5 < 2) {\n             return this.firstAttempt && this.workDone > this.workLimit;\n         }\n-        int hp;\n-        for (hp = 0; BlockSort.INCS[hp] < bigN; ++hp) {}\n-        final int[] fmap = dataShadow.fmap;\n+        int n6;\n+        for (n6 = 0; BlockSort.INCS[n6] < n5; ++n6) {}\n+        final int[] fmap = data.fmap;\n         final char[] quadrant = this.quadrant;\n-        final byte[] block = dataShadow.block;\n-        final int lastPlus1 = lastShadow + 1;\n-        final boolean firstAttemptShadow = this.firstAttempt;\n-        final int workLimitShadow = this.workLimit;\n-        int workDoneShadow = this.workDone;\n+        final byte[] block = data.block;\n+        final int n7 = n4 + 1;\n+        final boolean firstAttempt = this.firstAttempt;\n+        final int workLimit = this.workLimit;\n+        int workDone = this.workDone;\n     Label_0905:\n-        while (--hp >= 0) {\n-            final int h = BlockSort.INCS[hp];\n-            final int mj = lo + h - 1;\n-            int i = lo + h;\n-            while (i <= hi) {\n-                for (int k = 3; i <= hi && --k >= 0; ++i) {\n-                    final int v = fmap[i];\n-                    final int vd = v + d;\n-                    int j = i;\n-                    boolean onceRunned = false;\n-                    int a = 0;\n+        while (--n6 >= 0) {\n+            final int n8 = BlockSort.INCS[n6];\n+            final int n9 = n + n8 - 1;\n+            int i = n + n8;\n+            while (i <= n2) {\n+                for (int n10 = 3; i <= n2 && --n10 >= 0; ++i) {\n+                    final int n11 = fmap[i];\n+                    final int n12 = n11 + n3;\n+                    int n13 = i;\n+                    int n14 = 0;\n+                    int n15 = 0;\n                 Label_0176:\n                     while (true) {\n-                        if (onceRunned) {\n-                            fmap[j] = a;\n-                            if ((j -= h) <= mj) {\n+                        if (n14 != 0) {\n+                            fmap[n13] = n15;\n+                            if ((n13 -= n8) <= n9) {\n                                 break;\n                             }\n                         }\n                         else {\n-                            onceRunned = true;\n+                            n14 = 1;\n                         }\n-                        a = fmap[j - h];\n-                        int i2 = a + d;\n-                        int i3 = vd;\n-                        if (block[i2 + 1] == block[i3 + 1]) {\n-                            if (block[i2 + 2] == block[i3 + 2]) {\n-                                if (block[i2 + 3] == block[i3 + 3]) {\n-                                    if (block[i2 + 4] == block[i3 + 4]) {\n-                                        if (block[i2 + 5] == block[i3 + 5]) {\n+                        n15 = fmap[n13 - n8];\n+                        int n16 = n15 + n3;\n+                        int n17 = n12;\n+                        if (block[n16 + 1] == block[n17 + 1]) {\n+                            if (block[n16 + 2] == block[n17 + 2]) {\n+                                if (block[n16 + 3] == block[n17 + 3]) {\n+                                    if (block[n16 + 4] == block[n17 + 4]) {\n+                                        if (block[n16 + 5] == block[n17 + 5]) {\n                                             final byte[] array = block;\n-                                            i2 += 6;\n-                                            final byte b = array[i2];\n+                                            n16 += 6;\n+                                            final byte b = array[n16];\n                                             final byte[] array2 = block;\n-                                            i3 += 6;\n-                                            if (b == array2[i3]) {\n-                                                int x = lastShadow;\n-                                                while (x > 0) {\n-                                                    x -= 4;\n-                                                    if (block[i2 + 1] == block[i3 + 1]) {\n-                                                        if (quadrant[i2] == quadrant[i3]) {\n-                                                            if (block[i2 + 2] == block[i3 + 2]) {\n-                                                                if (quadrant[i2 + 1] == quadrant[i3 + 1]) {\n-                                                                    if (block[i2 + 3] == block[i3 + 3]) {\n-                                                                        if (quadrant[i2 + 2] == quadrant[i3 + 2]) {\n-                                                                            if (block[i2 + 4] == block[i3 + 4]) {\n-                                                                                if (quadrant[i2 + 3] == quadrant[i3 + 3]) {\n-                                                                                    i2 += 4;\n-                                                                                    if (i2 >= lastPlus1) {\n-                                                                                        i2 -= lastPlus1;\n+                                            n17 += 6;\n+                                            if (b == array2[n17]) {\n+                                                int j = n4;\n+                                                while (j > 0) {\n+                                                    j -= 4;\n+                                                    if (block[n16 + 1] == block[n17 + 1]) {\n+                                                        if (quadrant[n16] == quadrant[n17]) {\n+                                                            if (block[n16 + 2] == block[n17 + 2]) {\n+                                                                if (quadrant[n16 + 1] == quadrant[n17 + 1]) {\n+                                                                    if (block[n16 + 3] == block[n17 + 3]) {\n+                                                                        if (quadrant[n16 + 2] == quadrant[n17 + 2]) {\n+                                                                            if (block[n16 + 4] == block[n17 + 4]) {\n+                                                                                if (quadrant[n16 + 3] == quadrant[n17 + 3]) {\n+                                                                                    n16 += 4;\n+                                                                                    if (n16 >= n7) {\n+                                                                                        n16 -= n7;\n                                                                                     }\n-                                                                                    i3 += 4;\n-                                                                                    if (i3 >= lastPlus1) {\n-                                                                                        i3 -= lastPlus1;\n+                                                                                    n17 += 4;\n+                                                                                    if (n17 >= n7) {\n+                                                                                        n17 -= n7;\n                                                                                     }\n-                                                                                    ++workDoneShadow;\n+                                                                                    ++workDone;\n                                                                                 }\n                                                                                 else {\n-                                                                                    if (quadrant[i2 + 3] > quadrant[i3 + 3]) {\n+                                                                                    if (quadrant[n16 + 3] > quadrant[n17 + 3]) {\n                                                                                         continue Label_0176;\n                                                                                     }\n                                                                                     break;\n                                                                                 }\n                                                                             }\n                                                                             else {\n-                                                                                if ((block[i2 + 4] & 0xFF) > (block[i3 + 4] & 0xFF)) {\n+                                                                                if ((block[n16 + 4] & 0xFF) > (block[n17 + 4] & 0xFF)) {\n                                                                                     continue Label_0176;\n                                                                                 }\n                                                                                 break;\n                                                                             }\n                                                                         }\n                                                                         else {\n-                                                                            if (quadrant[i2 + 2] > quadrant[i3 + 2]) {\n+                                                                            if (quadrant[n16 + 2] > quadrant[n17 + 2]) {\n                                                                                 continue Label_0176;\n                                                                             }\n                                                                             break;\n                                                                         }\n                                                                     }\n                                                                     else {\n-                                                                        if ((block[i2 + 3] & 0xFF) > (block[i3 + 3] & 0xFF)) {\n+                                                                        if ((block[n16 + 3] & 0xFF) > (block[n17 + 3] & 0xFF)) {\n                                                                             continue Label_0176;\n                                                                         }\n                                                                         break;\n                                                                     }\n                                                                 }\n                                                                 else {\n-                                                                    if (quadrant[i2 + 1] > quadrant[i3 + 1]) {\n+                                                                    if (quadrant[n16 + 1] > quadrant[n17 + 1]) {\n                                                                         continue Label_0176;\n                                                                     }\n                                                                     break;\n                                                                 }\n                                                             }\n                                                             else {\n-                                                                if ((block[i2 + 2] & 0xFF) > (block[i3 + 2] & 0xFF)) {\n+                                                                if ((block[n16 + 2] & 0xFF) > (block[n17 + 2] & 0xFF)) {\n                                                                     continue Label_0176;\n                                                                 }\n                                                                 break;\n                                                             }\n                                                         }\n                                                         else {\n-                                                            if (quadrant[i2] > quadrant[i3]) {\n+                                                            if (quadrant[n16] > quadrant[n17]) {\n                                                                 continue Label_0176;\n                                                             }\n                                                             break;\n                                                         }\n                                                     }\n                                                     else {\n-                                                        if ((block[i2 + 1] & 0xFF) > (block[i3 + 1] & 0xFF)) {\n+                                                        if ((block[n16 + 1] & 0xFF) > (block[n17 + 1] & 0xFF)) {\n                                                             continue Label_0176;\n                                                         }\n                                                         break;\n                                                     }\n                                                 }\n                                                 break;\n                                             }\n-                                            if ((block[i2] & 0xFF) > (block[i3] & 0xFF)) {\n+                                            if ((block[n16] & 0xFF) > (block[n17] & 0xFF)) {\n                                                 continue;\n                                             }\n                                             break;\n                                         }\n                                         else {\n-                                            if ((block[i2 + 5] & 0xFF) > (block[i3 + 5] & 0xFF)) {\n+                                            if ((block[n16 + 5] & 0xFF) > (block[n17 + 5] & 0xFF)) {\n                                                 continue;\n                                             }\n                                             break;\n                                         }\n                                     }\n                                     else {\n-                                        if ((block[i2 + 4] & 0xFF) > (block[i3 + 4] & 0xFF)) {\n+                                        if ((block[n16 + 4] & 0xFF) > (block[n17 + 4] & 0xFF)) {\n                                             continue;\n                                         }\n                                         break;\n                                     }\n                                 }\n                                 else {\n-                                    if ((block[i2 + 3] & 0xFF) > (block[i3 + 3] & 0xFF)) {\n+                                    if ((block[n16 + 3] & 0xFF) > (block[n17 + 3] & 0xFF)) {\n                                         continue;\n                                     }\n                                     break;\n                                 }\n                             }\n                             else {\n-                                if ((block[i2 + 2] & 0xFF) > (block[i3 + 2] & 0xFF)) {\n+                                if ((block[n16 + 2] & 0xFF) > (block[n17 + 2] & 0xFF)) {\n                                     continue;\n                                 }\n                                 break;\n                             }\n                         }\n                         else {\n-                            if ((block[i2 + 1] & 0xFF) > (block[i3 + 1] & 0xFF)) {\n+                            if ((block[n16 + 1] & 0xFF) > (block[n17 + 1] & 0xFF)) {\n                                 continue;\n                             }\n                             break;\n                         }\n                     }\n-                    fmap[j] = v;\n+                    fmap[n13] = n11;\n                 }\n-                if (firstAttemptShadow && i <= hi && workDoneShadow > workLimitShadow) {\n+                if (firstAttempt && i <= n2 && workDone > workLimit) {\n                     break Label_0905;\n                 }\n             }\n         }\n-        this.workDone = workDoneShadow;\n-        return firstAttemptShadow && workDoneShadow > workLimitShadow;\n+        this.workDone = workDone;\n+        return firstAttempt && workDone > workLimit;\n     }\n     \n-    private static void vswap(final int[] fmap, int p1, int p2, int n) {\n-        int t;\n-        for (n += p1; p1 < n; fmap[p1++] = fmap[p2], fmap[p2++] = t) {\n-            t = fmap[p1];\n+    private static void vswap(final int[] array, int i, int n, int n2) {\n+        int n3;\n+        for (n2 += i; i < n2; array[i++] = array[n], array[n++] = n3) {\n+            n3 = array[i];\n         }\n     }\n     \n-    private static byte med3(final byte a, final byte b, final byte c) {\n-        return (a < b) ? ((b < c) ? b : ((a < c) ? c : a)) : ((b > c) ? b : ((a > c) ? c : a));\n+    private static byte med3(final byte b, final byte b2, final byte b3) {\n+        return (b < b2) ? ((b2 < b3) ? b2 : ((b < b3) ? b3 : b)) : ((b2 > b3) ? b2 : ((b > b3) ? b3 : b));\n     }\n     \n-    private void mainQSort3(final BZip2CompressorOutputStream.Data dataShadow, final int loSt, final int hiSt, final int dSt, final int last) {\n+    private void mainQSort3(final BZip2CompressorOutputStream.Data data, final int n, final int n2, final int n3, final int n4) {\n         final int[] stack_ll = this.stack_ll;\n         final int[] stack_hh = this.stack_hh;\n         final int[] stack_dd = this.stack_dd;\n-        final int[] fmap = dataShadow.fmap;\n-        final byte[] block = dataShadow.block;\n-        stack_ll[0] = loSt;\n-        stack_hh[0] = hiSt;\n-        stack_dd[0] = dSt;\n-        int sp = 1;\n-        while (--sp >= 0) {\n-            final int lo = stack_ll[sp];\n-            final int hi = stack_hh[sp];\n-            final int d = stack_dd[sp];\n-            if (hi - lo < 20 || d > 10) {\n-                if (this.mainSimpleSort(dataShadow, lo, hi, d, last)) {\n+        final int[] fmap = data.fmap;\n+        final byte[] block = data.block;\n+        stack_ll[0] = n;\n+        stack_hh[0] = n2;\n+        stack_dd[0] = n3;\n+        int n5 = 1;\n+        while (--n5 >= 0) {\n+            final int n6 = stack_ll[n5];\n+            final int n7 = stack_hh[n5];\n+            final int n8 = stack_dd[n5];\n+            if (n7 - n6 < 20 || n8 > 10) {\n+                if (this.mainSimpleSort(data, n6, n7, n8, n4)) {\n                     return;\n                 }\n                 continue;\n             }\n             else {\n-                final int d2 = d + 1;\n-                final int med = med3(block[fmap[lo] + d2], block[fmap[hi] + d2], block[fmap[lo + hi >>> 1] + d2]) & 0xFF;\n-                int unLo = lo;\n-                int unHi = hi;\n-                int ltLo = lo;\n-                int gtHi = hi;\n+                final int n9 = n8 + 1;\n+                final int n10 = med3(block[fmap[n6] + n9], block[fmap[n7] + n9], block[fmap[n6 + n7 >>> 1] + n9]) & 0xFF;\n+                int i = n6;\n+                int n11 = n7;\n+                int n12 = n6;\n+                int n13 = n7;\n                 while (true) {\n                     Label_0257: {\n-                        if (unLo <= unHi) {\n-                            final int n = (block[fmap[unLo] + d2] & 0xFF) - med;\n-                            if (n == 0) {\n-                                final int temp = fmap[unLo];\n-                                fmap[unLo++] = fmap[ltLo];\n-                                fmap[ltLo++] = temp;\n+                        if (i <= n11) {\n+                            final int n14 = (block[fmap[i] + n9] & 0xFF) - n10;\n+                            if (n14 == 0) {\n+                                final int n15 = fmap[i];\n+                                fmap[i++] = fmap[n12];\n+                                fmap[n12++] = n15;\n                             }\n                             else {\n-                                if (n >= 0) {\n+                                if (n14 >= 0) {\n                                     break Label_0257;\n                                 }\n-                                ++unLo;\n+                                ++i;\n                             }\n                             continue;\n                         }\n                     }\n-                    while (unLo <= unHi) {\n-                        final int n = (block[fmap[unHi] + d2] & 0xFF) - med;\n-                        if (n == 0) {\n-                            final int temp = fmap[unHi];\n-                            fmap[unHi--] = fmap[gtHi];\n-                            fmap[gtHi--] = temp;\n+                    while (i <= n11) {\n+                        final int n16 = (block[fmap[n11] + n9] & 0xFF) - n10;\n+                        if (n16 == 0) {\n+                            final int n17 = fmap[n11];\n+                            fmap[n11--] = fmap[n13];\n+                            fmap[n13--] = n17;\n                         }\n                         else {\n-                            if (n <= 0) {\n+                            if (n16 <= 0) {\n                                 break;\n                             }\n-                            --unHi;\n+                            --n11;\n                         }\n                     }\n-                    if (unLo > unHi) {\n+                    if (i > n11) {\n                         break;\n                     }\n-                    final int temp2 = fmap[unLo];\n-                    fmap[unLo++] = fmap[unHi];\n-                    fmap[unHi--] = temp2;\n-                }\n-                if (gtHi < ltLo) {\n-                    stack_ll[sp] = lo;\n-                    stack_hh[sp] = hi;\n-                    stack_dd[sp] = d2;\n-                    ++sp;\n+                    final int n18 = fmap[i];\n+                    fmap[i++] = fmap[n11];\n+                    fmap[n11--] = n18;\n+                }\n+                if (n13 < n12) {\n+                    stack_ll[n5] = n6;\n+                    stack_hh[n5] = n7;\n+                    stack_dd[n5] = n9;\n+                    ++n5;\n                 }\n                 else {\n-                    int n = (ltLo - lo < unLo - ltLo) ? (ltLo - lo) : (unLo - ltLo);\n-                    vswap(fmap, lo, unLo - n, n);\n-                    int m = (hi - gtHi < gtHi - unHi) ? (hi - gtHi) : (gtHi - unHi);\n-                    vswap(fmap, unLo, hi - m + 1, m);\n-                    n = lo + unLo - ltLo - 1;\n-                    m = hi - (gtHi - unHi) + 1;\n-                    stack_ll[sp] = lo;\n-                    stack_hh[sp] = n;\n-                    stack_dd[sp] = d;\n-                    ++sp;\n-                    stack_ll[sp] = n + 1;\n-                    stack_hh[sp] = m - 1;\n-                    stack_dd[sp] = d2;\n-                    ++sp;\n-                    stack_ll[sp] = m;\n-                    stack_hh[sp] = hi;\n-                    stack_dd[sp] = d;\n-                    ++sp;\n+                    final int n19 = (n12 - n6 < i - n12) ? (n12 - n6) : (i - n12);\n+                    vswap(fmap, n6, i - n19, n19);\n+                    final int n20 = (n7 - n13 < n13 - n11) ? (n7 - n13) : (n13 - n11);\n+                    vswap(fmap, i, n7 - n20 + 1, n20);\n+                    final int n21 = n6 + i - n12 - 1;\n+                    final int n22 = n7 - (n13 - n11) + 1;\n+                    stack_ll[n5] = n6;\n+                    stack_hh[n5] = n21;\n+                    stack_dd[n5] = n8;\n+                    ++n5;\n+                    stack_ll[n5] = n21 + 1;\n+                    stack_hh[n5] = n22 - 1;\n+                    stack_dd[n5] = n9;\n+                    ++n5;\n+                    stack_ll[n5] = n22;\n+                    stack_hh[n5] = n7;\n+                    stack_dd[n5] = n8;\n+                    ++n5;\n                 }\n             }\n         }\n     }\n     \n-    final void mainSort(final BZip2CompressorOutputStream.Data dataShadow, final int lastShadow) {\n-        final int[] runningOrder = this.mainSort_runningOrder;\n-        final int[] copy = this.mainSort_copy;\n-        final boolean[] bigDone = this.mainSort_bigDone;\n+    final void mainSort(final BZip2CompressorOutputStream.Data data, final int n) {\n+        final int[] mainSort_runningOrder = this.mainSort_runningOrder;\n+        final int[] mainSort_copy = this.mainSort_copy;\n+        final boolean[] mainSort_bigDone = this.mainSort_bigDone;\n         final int[] ftab = this.ftab;\n-        final byte[] block = dataShadow.block;\n-        final int[] fmap = dataShadow.fmap;\n+        final byte[] block = data.block;\n+        final int[] fmap = data.fmap;\n         final char[] quadrant = this.quadrant;\n-        final int workLimitShadow = this.workLimit;\n-        final boolean firstAttemptShadow = this.firstAttempt;\n-        int i = 65537;\n-        while (--i >= 0) {\n-            ftab[i] = 0;\n-        }\n-        for (i = 0; i < 20; ++i) {\n-            block[lastShadow + i + 2] = block[i % (lastShadow + 1) + 1];\n-        }\n-        i = lastShadow + 20 + 1;\n-        while (--i >= 0) {\n-            quadrant[i] = '\\0';\n-        }\n-        block[0] = block[lastShadow + 1];\n-        int c1 = block[0] & 0xFF;\n-        for (int j = 0; j <= lastShadow; ++j) {\n-            final int c2 = block[j + 1] & 0xFF;\n+        final int workLimit = this.workLimit;\n+        final boolean firstAttempt = this.firstAttempt;\n+        int n2 = 65537;\n+        while (--n2 >= 0) {\n+            ftab[n2] = 0;\n+        }\n+        for (int i = 0; i < 20; ++i) {\n+            block[n + i + 2] = block[i % (n + 1) + 1];\n+        }\n+        int n3 = n + 20 + 1;\n+        while (--n3 >= 0) {\n+            quadrant[n3] = '\\0';\n+        }\n+        block[0] = block[n + 1];\n+        int n4 = block[0] & 0xFF;\n+        for (int j = 0; j <= n; ++j) {\n+            final int n5 = block[j + 1] & 0xFF;\n             final int[] array = ftab;\n-            final int n = (c1 << 8) + c2;\n-            ++array[n];\n-            c1 = c2;\n+            final int n6 = (n4 << 8) + n5;\n+            ++array[n6];\n+            n4 = n5;\n         }\n-        for (int j = 1; j <= 65536; ++j) {\n+        for (int k = 1; k <= 65536; ++k) {\n             final int[] array2 = ftab;\n-            final int n2 = j;\n-            array2[n2] += ftab[j - 1];\n+            final int n7 = k;\n+            array2[n7] += ftab[k - 1];\n         }\n-        c1 = (block[1] & 0xFF);\n-        for (int j = 0; j < lastShadow; ++j) {\n-            final int c2 = block[j + 2] & 0xFF;\n+        int n8 = block[1] & 0xFF;\n+        for (int l = 0; l < n; ++l) {\n+            final int n9 = block[l + 2] & 0xFF;\n             final int[] array3 = fmap;\n             final int[] array4 = ftab;\n-            final int n3 = (c1 << 8) + c2;\n-            array3[--array4[n3]] = j;\n-            c1 = c2;\n+            final int n10 = (n8 << 8) + n9;\n+            array3[--array4[n10]] = l;\n+            n8 = n9;\n         }\n         final int[] array5 = fmap;\n         final int[] array6 = ftab;\n-        final int n4 = ((block[lastShadow + 1] & 0xFF) << 8) + (block[1] & 0xFF);\n-        array5[--array6[n4]] = lastShadow;\n-        int j = 256;\n-        while (--j >= 0) {\n-            bigDone[j] = false;\n-            runningOrder[j] = j;\n-        }\n-        int h = 364;\n-        while (h != 1) {\n-            int k;\n-            for (h = (k = h / 3); k <= 255; ++k) {\n-                final int vv = runningOrder[k];\n-                final int a = ftab[vv + 1 << 8] - ftab[vv << 8];\n-                final int b = h - 1;\n-                int l = k;\n-                for (int ro = runningOrder[l - h]; ftab[ro + 1 << 8] - ftab[ro << 8] > a; ro = runningOrder[l - h]) {\n-                    runningOrder[l] = ro;\n-                    l -= h;\n-                    if (l <= b) {\n+        final int n11 = ((block[n + 1] & 0xFF) << 8) + (block[1] & 0xFF);\n+        array5[--array6[n11]] = n;\n+        int n12 = 256;\n+        while (--n12 >= 0) {\n+            mainSort_bigDone[n12] = false;\n+            mainSort_runningOrder[n12] = n12;\n+        }\n+        int n13 = 364;\n+        while (n13 != 1) {\n+            int n14;\n+            for (n13 = (n14 = n13 / 3); n14 <= 255; ++n14) {\n+                final int n15 = mainSort_runningOrder[n14];\n+                final int n16 = ftab[n15 + 1 << 8] - ftab[n15 << 8];\n+                final int n17 = n13 - 1;\n+                int n18 = n14;\n+                for (int n19 = mainSort_runningOrder[n18 - n13]; ftab[n19 + 1 << 8] - ftab[n19 << 8] > n16; n19 = mainSort_runningOrder[n18 - n13]) {\n+                    mainSort_runningOrder[n18] = n19;\n+                    n18 -= n13;\n+                    if (n18 <= n17) {\n                         break;\n                     }\n                 }\n-                runningOrder[l] = vv;\n+                mainSort_runningOrder[n18] = n15;\n             }\n         }\n-        for (j = 0; j <= 255; ++j) {\n-            final int ss = runningOrder[j];\n-            for (int m = 0; m <= 255; ++m) {\n-                final int sb = (ss << 8) + m;\n-                final int ftab_sb = ftab[sb];\n-                if ((ftab_sb & 0x200000) != 0x200000) {\n-                    final int lo = ftab_sb & 0xFFDFFFFF;\n-                    final int hi = (ftab[sb + 1] & 0xFFDFFFFF) - 1;\n-                    if (hi > lo) {\n-                        this.mainQSort3(dataShadow, lo, hi, 2, lastShadow);\n-                        if (firstAttemptShadow && this.workDone > workLimitShadow) {\n+        for (int n20 = 0; n20 <= 255; ++n20) {\n+            final int n21 = mainSort_runningOrder[n20];\n+            for (int n22 = 0; n22 <= 255; ++n22) {\n+                final int n23 = (n21 << 8) + n22;\n+                final int n24 = ftab[n23];\n+                if ((n24 & 0x200000) != 0x200000) {\n+                    final int n25 = n24 & 0xFFDFFFFF;\n+                    final int n26 = (ftab[n23 + 1] & 0xFFDFFFFF) - 1;\n+                    if (n26 > n25) {\n+                        this.mainQSort3(data, n25, n26, 2, n);\n+                        if (firstAttempt && this.workDone > workLimit) {\n                             return;\n                         }\n                     }\n-                    ftab[sb] = (ftab_sb | 0x200000);\n+                    ftab[n23] = (n24 | 0x200000);\n                 }\n             }\n-            for (int m = 0; m <= 255; ++m) {\n-                copy[m] = (ftab[(m << 8) + ss] & 0xFFDFFFFF);\n+            for (int n27 = 0; n27 <= 255; ++n27) {\n+                mainSort_copy[n27] = (ftab[(n27 << 8) + n21] & 0xFFDFFFFF);\n             }\n-            for (int m = ftab[ss << 8] & 0xFFDFFFFF, hj = ftab[ss + 1 << 8] & 0xFFDFFFFF; m < hj; ++m) {\n-                final int fmap_j = fmap[m];\n-                c1 = (block[fmap_j] & 0xFF);\n-                if (!bigDone[c1]) {\n-                    fmap[copy[c1]] = ((fmap_j == 0) ? lastShadow : (fmap_j - 1));\n-                    final int[] array7 = copy;\n-                    final int n5 = c1;\n-                    ++array7[n5];\n+            for (int n28 = ftab[n21 << 8] & 0xFFDFFFFF; n28 < (ftab[n21 + 1 << 8] & 0xFFDFFFFF); ++n28) {\n+                final int n29 = fmap[n28];\n+                final int n30 = block[n29] & 0xFF;\n+                if (!mainSort_bigDone[n30]) {\n+                    fmap[mainSort_copy[n30]] = ((n29 == 0) ? n : (n29 - 1));\n+                    final int[] array7 = mainSort_copy;\n+                    final int n31 = n30;\n+                    ++array7[n31];\n                 }\n             }\n-            int m = 256;\n-            while (--m >= 0) {\n+            int n32 = 256;\n+            while (--n32 >= 0) {\n                 final int[] array8 = ftab;\n-                final int n6 = (m << 8) + ss;\n-                array8[n6] |= 0x200000;\n+                final int n33 = (n32 << 8) + n21;\n+                array8[n33] |= 0x200000;\n             }\n-            bigDone[ss] = true;\n-            if (j < 255) {\n-                final int bbStart = ftab[ss << 8] & 0xFFDFFFFF;\n-                int bbSize;\n-                int shifts;\n-                for (bbSize = (ftab[ss + 1 << 8] & 0xFFDFFFFF) - bbStart, shifts = 0; bbSize >> shifts > 65534; ++shifts) {}\n-                for (int l = 0; l < bbSize; ++l) {\n-                    final int a2update = fmap[bbStart + l];\n-                    final char qVal = (char)(l >> shifts);\n-                    quadrant[a2update] = qVal;\n-                    if (a2update < 20) {\n-                        quadrant[a2update + lastShadow + 1] = qVal;\n+            mainSort_bigDone[n21] = true;\n+            if (n20 < 255) {\n+                final int n34 = ftab[n21 << 8] & 0xFFDFFFFF;\n+                int n35;\n+                int n36;\n+                for (n35 = (ftab[n21 + 1 << 8] & 0xFFDFFFFF) - n34, n36 = 0; n35 >> n36 > 65534; ++n36) {}\n+                for (int n37 = 0; n37 < n35; ++n37) {\n+                    final int n38 = fmap[n34 + n37];\n+                    final char c = (char)(n37 >> n36);\n+                    quadrant[n38] = c;\n+                    if (n38 < 20) {\n+                        quadrant[n38 + n + 1] = c;\n                     }\n                 }\n             }\n         }\n     }\n     \n     static {\n"}]}
