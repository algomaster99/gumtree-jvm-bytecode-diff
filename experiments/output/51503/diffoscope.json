{"diffoscope-json-version": 1, "source1": "first/ZipFile.class", "source2": "second/ZipFile.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -67,14 +67,19 @@\n     private static final int CFD_LOCATOR_OFFSET = 16;\n     private static final int ZIP64_EOCDL_LENGTH = 20;\n     private static final int ZIP64_EOCDL_LOCATOR_OFFSET = 8;\n     private static final int ZIP64_EOCD_CFD_LOCATOR_OFFSET = 48;\n     private static final long LFH_OFFSET_FOR_FILENAME_LENGTH = 26L;\n     private final Comparator<ZipArchiveEntry> offsetComparator;\n     \n+    static {\n+        ONE_ZERO_BYTE = new byte[1];\n+        CFH_SIG = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n+    }\n+    \n     public ZipFile(final File f) throws IOException {\n         this(f, \"UTF8\");\n     }\n     \n     public ZipFile(final String name) throws IOException {\n         this(new File(name), \"UTF8\");\n     }\n@@ -110,15 +115,15 @@\n         this.dwordBuf = new byte[8];\n         this.wordBuf = new byte[4];\n         this.cfhBuf = new byte[42];\n         this.shortBuf = new byte[2];\n         this.dwordBbuf = ByteBuffer.wrap(this.dwordBuf);\n         this.wordBbuf = ByteBuffer.wrap(this.wordBuf);\n         this.cfhBbuf = ByteBuffer.wrap(this.cfhBuf);\n-        this.offsetComparator = (Comparator<ZipArchiveEntry>)new ZipFile.ZipFile$2(this);\n+        this.offsetComparator = (Comparator<ZipArchiveEntry>)new ZipFile.ZipFile$1(this);\n         this.archiveName = archiveName;\n         this.encoding = encoding;\n         this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n         this.useUnicodeExtraFields = useUnicodeExtraFields;\n         this.archive = channel;\n         boolean success = false;\n         try {\n@@ -128,14 +133,18 @@\n         }\n         finally {\n             this.closed = !success;\n             if (!success && closeOnError) {\n                 IOUtils.closeQuietly((Closeable)this.archive);\n             }\n         }\n+        this.closed = !success;\n+        if (!success && closeOnError) {\n+            IOUtils.closeQuietly((Closeable)this.archive);\n+        }\n     }\n     \n     public String getEncoding() {\n         return this.encoding;\n     }\n     \n     @Override\n@@ -202,44 +211,65 @@\n     public InputStream getInputStream(final ZipArchiveEntry ze) throws IOException {\n         if (!(ze instanceof ZipFile.Entry)) {\n             return null;\n         }\n         ZipUtil.checkRequestedFeatures(ze);\n         final long start = ze.getDataOffset();\n         final InputStream is = new BufferedInputStream((InputStream)this.createBoundedInputStream(start, ze.getCompressedSize()));\n-        switch (ZipFile.ZipFile$3.$SwitchMap$org$apache$commons$compress$archivers$zip$ZipMethod[ZipMethod.getMethodByCode(ze.getMethod()).ordinal()]) {\n-            case 1: {\n+        switch (ZipMethod.getMethodByCode(ze.getMethod())) {\n+            case STORED: {\n                 return is;\n             }\n-            case 2: {\n+            case UNSHRINKING: {\n                 return (InputStream)new UnshrinkingInputStream(is);\n             }\n-            case 3: {\n+            case IMPLODING: {\n                 return (InputStream)new ExplodingInputStream(ze.getGeneralPurposeBit().getSlidingDictionarySize(), ze.getGeneralPurposeBit().getNumberOfShannonFanoTrees(), is);\n             }\n-            case 4: {\n+            case DEFLATED: {\n                 final Inflater inflater = new Inflater(true);\n-                return (InputStream)new ZipFile.ZipFile$1(this, (InputStream)new SequenceInputStream(is, new ByteArrayInputStream(ZipFile.ONE_ZERO_BYTE)), inflater, inflater);\n+                return (InputStream)new ZipFile.ZipFile$2(this, (InputStream)new SequenceInputStream(is, new ByteArrayInputStream(ZipFile.ONE_ZERO_BYTE)), inflater, inflater);\n             }\n-            case 5: {\n+            case BZIP2: {\n                 return (InputStream)new BZip2CompressorInputStream(is);\n             }\n-            case 6: {\n+            case ENHANCED_DEFLATED: {\n                 return (InputStream)new Deflate64CompressorInputStream(is);\n             }\n             default: {\n                 throw new ZipException(\"Found unsupported compression method \" + ze.getMethod());\n             }\n         }\n     }\n     \n     public String getUnixSymlink(final ZipArchiveEntry entry) throws IOException {\n         if (entry != null && entry.isUnixSymlink()) {\n-            try (final InputStream in = this.getInputStream(entry)) {\n-                return this.zipEncoding.decode(IOUtils.toByteArray(in));\n+            Throwable t = null;\n+            try {\n+                final InputStream in = this.getInputStream(entry);\n+                try {\n+                    return this.zipEncoding.decode(IOUtils.toByteArray(in));\n+                }\n+                finally {\n+                    if (in != null) {\n+                        in.close();\n+                    }\n+                }\n+            }\n+            finally {\n+                if (t == null) {\n+                    final Throwable exception;\n+                    t = exception;\n+                }\n+                else {\n+                    final Throwable exception;\n+                    if (t != exception) {\n+                        t.addSuppressed(exception);\n+                    }\n+                }\n             }\n         }\n         return null;\n     }\n     \n     @Override\n     protected void finalize() throws Throwable {\n@@ -248,14 +278,15 @@\n                 System.err.println(\"Cleaning up unclosed ZipFile for archive \" + this.archiveName);\n                 this.close();\n             }\n         }\n         finally {\n             super.finalize();\n         }\n+        super.finalize();\n     }\n     \n     private Map<ZipArchiveEntry, ZipFile.NameAndComment> populateFromCentralDirectory() throws IOException {\n         final HashMap<ZipArchiveEntry, ZipFile.NameAndComment> noUTF8Flag = new HashMap<ZipArchiveEntry, ZipFile.NameAndComment>();\n         this.positionAtCentralDirectory();\n         this.wordBbuf.rewind();\n         IOUtils.readFully((ReadableByteChannel)this.archive, this.wordBbuf);\n@@ -324,15 +355,15 @@\n         IOUtils.readFully((ReadableByteChannel)this.archive, ByteBuffer.wrap(cdExtraData));\n         ze.setCentralDirectoryExtra(cdExtraData);\n         this.setSizesAndOffsetFromZip64Extra((ZipArchiveEntry)ze, diskStart);\n         final byte[] comment = new byte[commentLen];\n         IOUtils.readFully((ReadableByteChannel)this.archive, ByteBuffer.wrap(comment));\n         ze.setComment(entryEncoding.decode(comment));\n         if (!hasUTF8Flag && this.useUnicodeExtraFields) {\n-            noUTF8Flag.put((ZipArchiveEntry)ze, new ZipFile.NameAndComment(fileName, comment, (ZipFile.ZipFile$1)null));\n+            noUTF8Flag.put((ZipArchiveEntry)ze, new ZipFile.NameAndComment(fileName, comment, (ZipFile.NameAndComment)null));\n         }\n     }\n     \n     private void setSizesAndOffsetFromZip64Extra(final ZipArchiveEntry ze, final int diskStart) throws IOException {\n         final Zip64ExtendedInformationExtraField z64 = (Zip64ExtendedInformationExtraField)ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n         if (z64 != null) {\n             final boolean hasUncompressedSize = ze.getSize() == 4294967295L;\n@@ -471,15 +502,15 @@\n             final byte[] localExtraData = new byte[extraFieldLen];\n             IOUtils.readFully((ReadableByteChannel)this.archive, ByteBuffer.wrap(localExtraData));\n             ze.setExtra(localExtraData);\n             ze.setDataOffset(offset + 26L + 2L + 2L + fileNameLen + (long)extraFieldLen);\n             ze.setStreamContiguous(true);\n             if (entriesWithoutUTF8Flag.containsKey(ze)) {\n                 final ZipFile.NameAndComment nc = (ZipFile.NameAndComment)entriesWithoutUTF8Flag.get(ze);\n-                ZipUtil.setNameAndCommentFromExtraFields((ZipArchiveEntry)ze, ZipFile.NameAndComment.access$100(nc), ZipFile.NameAndComment.access$200(nc));\n+                ZipUtil.setNameAndCommentFromExtraFields((ZipArchiveEntry)ze, ZipFile.NameAndComment.access$1(nc), ZipFile.NameAndComment.access$2(nc));\n             }\n             final String name = ze.getName();\n             LinkedList<ZipArchiveEntry> entriesOfThatName = (LinkedList<ZipArchiveEntry>)this.nameMap.get(name);\n             if (entriesOfThatName == null) {\n                 entriesOfThatName = new LinkedList<ZipArchiveEntry>();\n                 this.nameMap.put(name, entriesOfThatName);\n             }\n@@ -493,13 +524,8 @@\n         IOUtils.readFully((ReadableByteChannel)this.archive, this.wordBbuf);\n         return Arrays.equals(this.wordBuf, ZipArchiveOutputStream.LFH_SIG);\n     }\n     \n     private ZipFile.BoundedInputStream createBoundedInputStream(final long start, final long remaining) {\n         return (ZipFile.BoundedInputStream)((this.archive instanceof FileChannel) ? new ZipFile.BoundedFileChannelInputStream(this, start, remaining) : new ZipFile.BoundedInputStream(this, start, remaining));\n     }\n-    \n-    static {\n-        ONE_ZERO_BYTE = new byte[1];\n-        CFH_SIG = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n-    }\n }\n"}]}
