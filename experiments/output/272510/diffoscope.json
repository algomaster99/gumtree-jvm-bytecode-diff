{"diffoscope-json-version": 1, "source1": "first/TreeWalker.class", "source2": "second/TreeWalker.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -55,190 +55,189 @@\n     }\n     \n     public void setModuleFactory(final ModuleFactory moduleFactory) {\n         this.moduleFactory = moduleFactory;\n     }\n     \n     public void finishLocalSetup() {\n-        final DefaultContext checkContext = new DefaultContext();\n-        checkContext.add(\"severity\", (Object)this.getSeverity());\n-        checkContext.add(\"tabWidth\", (Object)String.valueOf(this.getTabWidth()));\n-        this.childContext = (Context)checkContext;\n+        final DefaultContext childContext = new DefaultContext();\n+        childContext.add(\"severity\", (Object)this.getSeverity());\n+        childContext.add(\"tabWidth\", (Object)String.valueOf(this.getTabWidth()));\n+        this.childContext = (Context)childContext;\n     }\n     \n-    public void setupChild(final Configuration childConf) throws CheckstyleException {\n-        final String name = childConf.getName();\n+    public void setupChild(final Configuration configuration) throws CheckstyleException {\n+        final String name = configuration.getName();\n         Object module;\n         try {\n             module = this.moduleFactory.createModule(name);\n             if (module instanceof AbstractAutomaticBean) {\n-                final AbstractAutomaticBean bean = (AbstractAutomaticBean)module;\n-                bean.contextualize(this.childContext);\n-                bean.configure(childConf);\n+                final AbstractAutomaticBean abstractAutomaticBean = (AbstractAutomaticBean)module;\n+                abstractAutomaticBean.contextualize(this.childContext);\n+                abstractAutomaticBean.configure(configuration);\n             }\n         }\n         catch (final CheckstyleException ex) {\n             throw new CheckstyleException(\"cannot initialize module \" + name + \" - \" + ex.getMessage(), (Throwable)ex);\n         }\n         if (module instanceof AbstractCheck) {\n-            final AbstractCheck check = (AbstractCheck)module;\n-            check.init();\n-            this.registerCheck(check);\n+            final AbstractCheck abstractCheck = (AbstractCheck)module;\n+            abstractCheck.init();\n+            this.registerCheck(abstractCheck);\n         }\n         else {\n             if (!(module instanceof TreeWalkerFilter)) {\n                 throw new CheckstyleException(\"TreeWalker is not allowed as a parent of \" + name + \" Please review 'Parent Module' section for this Check in web documentation if Check is standard.\");\n             }\n-            final TreeWalkerFilter filter = (TreeWalkerFilter)module;\n-            this.filters.add(filter);\n+            this.filters.add((TreeWalkerFilter)module);\n         }\n     }\n     \n     protected void processFiltered(final File file, final FileText fileText) throws CheckstyleException {\n         if (!this.ordinaryChecks.isEmpty() || !this.commentChecks.isEmpty()) {\n-            final FileContents contents = this.getFileContents();\n-            final DetailAST rootAST = JavaParser.parse(contents);\n+            final FileContents fileContents = this.getFileContents();\n+            final DetailAST parse = JavaParser.parse(fileContents);\n             if (!this.ordinaryChecks.isEmpty()) {\n-                this.walk(rootAST, contents, TreeWalker.AstState.ORDINARY);\n+                this.walk(parse, fileContents, TreeWalker.AstState.ORDINARY);\n             }\n             if (!this.commentChecks.isEmpty()) {\n-                final DetailAST astWithComments = JavaParser.appendHiddenCommentNodes(rootAST);\n-                this.walk(astWithComments, contents, TreeWalker.AstState.WITH_COMMENTS);\n+                this.walk(JavaParser.appendHiddenCommentNodes(parse), fileContents, TreeWalker.AstState.WITH_COMMENTS);\n             }\n             if (this.filters.isEmpty()) {\n                 this.addViolations((SortedSet)this.violations);\n             }\n             else {\n-                final SortedSet<Violation> filteredViolations = this.getFilteredViolations(file.getAbsolutePath(), contents, rootAST);\n-                this.addViolations((SortedSet)filteredViolations);\n+                this.addViolations((SortedSet)this.getFilteredViolations(file.getAbsolutePath(), fileContents, parse));\n             }\n             this.violations.clear();\n         }\n     }\n     \n-    private SortedSet<Violation> getFilteredViolations(final String fileName, final FileContents fileContents, final DetailAST rootAST) {\n-        final SortedSet<Violation> result = new TreeSet<Violation>(this.violations);\n-        for (final Violation element : this.violations) {\n-            final TreeWalkerAuditEvent event = new TreeWalkerAuditEvent(fileContents, fileName, element, rootAST);\n-            for (final TreeWalkerFilter filter : this.filters) {\n-                if (!filter.accept(event)) {\n-                    result.remove(element);\n+    private SortedSet<Violation> getFilteredViolations(final String s, final FileContents fileContents, final DetailAST detailAST) {\n+        final TreeSet set = new TreeSet((SortedSet<E>)this.violations);\n+        for (final Violation violation : this.violations) {\n+            final TreeWalkerAuditEvent treeWalkerAuditEvent = new TreeWalkerAuditEvent(fileContents, s, violation, detailAST);\n+            final Iterator<TreeWalkerFilter> iterator2 = this.filters.iterator();\n+            while (iterator2.hasNext()) {\n+                if (!((TreeWalkerFilter)iterator2.next()).accept(treeWalkerAuditEvent)) {\n+                    set.remove(violation);\n                     break;\n                 }\n             }\n         }\n-        return result;\n+        return set;\n     }\n     \n-    private void registerCheck(final AbstractCheck check) throws CheckstyleException {\n-        final Set<String> checkTokens = check.getTokenNames();\n-        int[] tokens;\n-        if (checkTokens.isEmpty()) {\n-            tokens = check.getDefaultTokens();\n+    private void registerCheck(final AbstractCheck abstractCheck) throws CheckstyleException {\n+        final Set tokenNames = abstractCheck.getTokenNames();\n+        int[] array;\n+        if (tokenNames.isEmpty()) {\n+            array = abstractCheck.getDefaultTokens();\n         }\n         else {\n-            tokens = check.getRequiredTokens();\n-            final int[] acceptableTokens = check.getAcceptableTokens();\n+            array = abstractCheck.getRequiredTokens();\n+            final int[] acceptableTokens = abstractCheck.getAcceptableTokens();\n             Arrays.sort(acceptableTokens);\n-            for (final String token : checkTokens) {\n-                final int tokenId = TokenUtil.getTokenId(token);\n+            for (final String s : tokenNames) {\n+                final int tokenId = TokenUtil.getTokenId(s);\n                 if (Arrays.binarySearch(acceptableTokens, tokenId) < 0) {\n-                    final String message = String.format(Locale.ROOT, \"Token \\\"%s\\\" was not found in Acceptable tokens list in check %s\", token, check.getClass().getName());\n-                    throw new CheckstyleException(message);\n+                    throw new CheckstyleException(String.format(Locale.ROOT, \"Token \\\"%s\\\" was not found in Acceptable tokens list in check %s\", s, abstractCheck.getClass().getName()));\n                 }\n-                this.registerCheck(tokenId, check);\n+                this.registerCheck(tokenId, abstractCheck);\n             }\n         }\n-        for (final int element : tokens) {\n-            this.registerCheck(element, check);\n+        final int[] array2 = array;\n+        for (int length = array2.length, i = 0; i < length; ++i) {\n+            this.registerCheck(array2[i], abstractCheck);\n         }\n-        if (check.isCommentNodesRequired()) {\n-            this.commentChecks.add(check);\n+        if (abstractCheck.isCommentNodesRequired()) {\n+            this.commentChecks.add(abstractCheck);\n         }\n         else {\n-            this.ordinaryChecks.add(check);\n+            this.ordinaryChecks.add(abstractCheck);\n         }\n     }\n     \n-    private void registerCheck(final int tokenId, final AbstractCheck check) throws CheckstyleException {\n-        if (check.isCommentNodesRequired()) {\n-            ((Set<AbstractCheck>)this.tokenToCommentChecks.computeIfAbsent(Integer.valueOf(tokenId), empty -> createNewCheckSortedSet())).add(check);\n+    private void registerCheck(final int n, final AbstractCheck abstractCheck) throws CheckstyleException {\n+        if (abstractCheck.isCommentNodesRequired()) {\n+            ((Set<AbstractCheck>)this.tokenToCommentChecks.computeIfAbsent(Integer.valueOf(n), p0 -> createNewCheckSortedSet())).add(abstractCheck);\n         }\n         else {\n-            if (TokenUtil.isCommentType(tokenId)) {\n-                final String message = String.format(Locale.ROOT, \"Check '%s' waits for comment type token ('%s') and should override 'isCommentNodesRequired()' method to return 'true'\", check.getClass().getName(), TokenUtil.getTokenName(tokenId));\n-                throw new CheckstyleException(message);\n+            if (TokenUtil.isCommentType(n)) {\n+                throw new CheckstyleException(String.format(Locale.ROOT, \"Check '%s' waits for comment type token ('%s') and should override 'isCommentNodesRequired()' method to return 'true'\", abstractCheck.getClass().getName(), TokenUtil.getTokenName(n)));\n             }\n-            ((Set<AbstractCheck>)this.tokenToOrdinaryChecks.computeIfAbsent(Integer.valueOf(tokenId), empty -> createNewCheckSortedSet())).add(check);\n+            ((Set<AbstractCheck>)this.tokenToOrdinaryChecks.computeIfAbsent(Integer.valueOf(n), p0 -> createNewCheckSortedSet())).add(abstractCheck);\n         }\n     }\n     \n-    private void walk(final DetailAST ast, final FileContents contents, final TreeWalker.AstState astState) {\n-        this.notifyBegin(ast, contents, astState);\n-        this.processIter(ast, astState);\n-        this.notifyEnd(ast, astState);\n+    private void walk(final DetailAST detailAST, final FileContents fileContents, final TreeWalker.AstState astState) {\n+        this.notifyBegin(detailAST, fileContents, astState);\n+        this.processIter(detailAST, astState);\n+        this.notifyEnd(detailAST, astState);\n     }\n     \n-    private void notifyBegin(final DetailAST rootAST, final FileContents contents, final TreeWalker.AstState astState) {\n-        Set<AbstractCheck> checks;\n+    private void notifyBegin(final DetailAST detailAST, final FileContents fileContents, final TreeWalker.AstState astState) {\n+        Set<AbstractCheck> set;\n         if (astState == TreeWalker.AstState.WITH_COMMENTS) {\n-            checks = this.commentChecks;\n+            set = this.commentChecks;\n         }\n         else {\n-            checks = this.ordinaryChecks;\n+            set = this.ordinaryChecks;\n         }\n-        for (final AbstractCheck check : checks) {\n-            check.setFileContents(contents);\n-            check.clearViolations();\n-            check.beginTree(rootAST);\n+        for (final AbstractCheck abstractCheck : set) {\n+            abstractCheck.setFileContents(fileContents);\n+            abstractCheck.clearViolations();\n+            abstractCheck.beginTree(detailAST);\n         }\n     }\n     \n-    private void notifyEnd(final DetailAST rootAST, final TreeWalker.AstState astState) {\n-        Set<AbstractCheck> checks;\n+    private void notifyEnd(final DetailAST detailAST, final TreeWalker.AstState astState) {\n+        Set<AbstractCheck> set;\n         if (astState == TreeWalker.AstState.WITH_COMMENTS) {\n-            checks = this.commentChecks;\n+            set = this.commentChecks;\n         }\n         else {\n-            checks = this.ordinaryChecks;\n+            set = this.ordinaryChecks;\n         }\n-        for (final AbstractCheck check : checks) {\n-            check.finishTree(rootAST);\n-            this.violations.addAll((Collection<?>)check.getViolations());\n+        for (final AbstractCheck abstractCheck : set) {\n+            abstractCheck.finishTree(detailAST);\n+            this.violations.addAll((Collection<?>)abstractCheck.getViolations());\n         }\n     }\n     \n-    private void notifyVisit(final DetailAST ast, final TreeWalker.AstState astState) {\n-        final Collection<AbstractCheck> visitors = this.getListOfChecks(ast, astState);\n-        if (visitors != null) {\n-            for (final AbstractCheck check : visitors) {\n-                check.visitToken(ast);\n+    private void notifyVisit(final DetailAST detailAST, final TreeWalker.AstState astState) {\n+        final Collection<AbstractCheck> listOfChecks = this.getListOfChecks(detailAST, astState);\n+        if (listOfChecks != null) {\n+            final Iterator<AbstractCheck> iterator = listOfChecks.iterator();\n+            while (iterator.hasNext()) {\n+                ((AbstractCheck)iterator.next()).visitToken(detailAST);\n             }\n         }\n     }\n     \n-    private void notifyLeave(final DetailAST ast, final TreeWalker.AstState astState) {\n-        final Collection<AbstractCheck> visitors = this.getListOfChecks(ast, astState);\n-        if (visitors != null) {\n-            for (final AbstractCheck check : visitors) {\n-                check.leaveToken(ast);\n+    private void notifyLeave(final DetailAST detailAST, final TreeWalker.AstState astState) {\n+        final Collection<AbstractCheck> listOfChecks = this.getListOfChecks(detailAST, astState);\n+        if (listOfChecks != null) {\n+            final Iterator<AbstractCheck> iterator = listOfChecks.iterator();\n+            while (iterator.hasNext()) {\n+                ((AbstractCheck)iterator.next()).leaveToken(detailAST);\n             }\n         }\n     }\n     \n-    private Collection<AbstractCheck> getListOfChecks(final DetailAST ast, final TreeWalker.AstState astState) {\n-        final int tokenId = ast.getType();\n-        Collection<AbstractCheck> visitors;\n+    private Collection<AbstractCheck> getListOfChecks(final DetailAST detailAST, final TreeWalker.AstState astState) {\n+        final int type = detailAST.getType();\n+        Collection collection;\n         if (astState == TreeWalker.AstState.WITH_COMMENTS) {\n-            visitors = this.tokenToCommentChecks.get(Integer.valueOf(tokenId));\n+            collection = this.tokenToCommentChecks.get(Integer.valueOf(type));\n         }\n         else {\n-            visitors = this.tokenToOrdinaryChecks.get(Integer.valueOf(tokenId));\n+            collection = this.tokenToOrdinaryChecks.get(Integer.valueOf(type));\n         }\n-        return visitors;\n+        return collection;\n     }\n     \n     public void destroy() {\n         this.ordinaryChecks.forEach(AbstractCheck::destroy);\n         this.commentChecks.forEach(AbstractCheck::destroy);\n         super.destroy();\n     }\n@@ -246,24 +245,24 @@\n     public Set<String> getExternalResourceLocations() {\n         final Stream<Object> concat = Stream.concat(this.filters.stream(), Stream.concat(this.ordinaryChecks.stream(), this.commentChecks.stream()));\n         final Class<ExternalResourceHolder> obj = ExternalResourceHolder.class;\n         Objects.requireNonNull(obj);\n         final Stream<Object> filter = concat.filter(obj::isInstance);\n         final Class<ExternalResourceHolder> obj2 = ExternalResourceHolder.class;\n         Objects.requireNonNull(obj2);\n-        return filter.map((Function<? super Object, ?>)obj2::cast).flatMap(resource -> resource.getExternalResourceLocations().stream()).collect((Collector<? super Object, ?, Set<String>>)Collectors.toSet());\n+        return filter.map((Function<? super Object, ?>)obj2::cast).flatMap(externalResourceHolder -> externalResourceHolder.getExternalResourceLocations().stream()).collect((Collector<? super Object, ?, Set<String>>)Collectors.toSet());\n     }\n     \n-    private void processIter(final DetailAST root, final TreeWalker.AstState astState) {\n-        DetailAST toVisit;\n-        for (DetailAST curNode = root; curNode != null; curNode = toVisit) {\n-            this.notifyVisit(curNode, astState);\n-            for (toVisit = curNode.getFirstChild(); curNode != null && toVisit == null; toVisit = curNode.getNextSibling(), curNode = curNode.getParent()) {\n-                this.notifyLeave(curNode, astState);\n+    private void processIter(final DetailAST detailAST, final TreeWalker.AstState astState) {\n+        DetailAST detailAST2;\n+        for (DetailAST parent = detailAST; parent != null; parent = detailAST2) {\n+            this.notifyVisit(parent, astState);\n+            for (detailAST2 = parent.getFirstChild(); parent != null && detailAST2 == null; detailAST2 = parent.getNextSibling(), parent = parent.getParent()) {\n+                this.notifyLeave(parent, astState);\n             }\n         }\n     }\n     \n     private static SortedSet<AbstractCheck> createNewCheckSortedSet() {\n-        return new TreeSet<AbstractCheck>(Comparator.comparing(check -> check.getClass().getName()).thenComparing((Function<? super Object, ?>)AbstractViolationReporter::getId, Comparator.nullsLast(Comparator.naturalOrder())).thenComparing((Function<? super Object, ? extends Comparable>)Object::hashCode));\n+        return new TreeSet<AbstractCheck>(Comparator.comparing(abstractCheck -> abstractCheck.getClass().getName()).thenComparing((Function<? super Object, ?>)AbstractViolationReporter::getId, Comparator.nullsLast(Comparator.naturalOrder())).thenComparing((Function<? super Object, ? extends Comparable>)Object::hashCode));\n     }\n }\n"}]}
