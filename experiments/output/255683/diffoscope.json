{"diffoscope-json-version": 1, "source1": "first/BinaryTree.class", "source2": "second/BinaryTree.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -9,113 +9,112 @@\n \n class BinaryTree\n {\n     private static final int UNDEFINED = -1;\n     private static final int NODE = -2;\n     private final int[] tree;\n     \n-    public BinaryTree(final int depth) {\n-        if (depth < 0 || depth > 30) {\n-            throw new IllegalArgumentException(\"depth must be bigger than 0 and not bigger than 30 but is \" + depth);\n+    public BinaryTree(final int n) {\n+        if (n < 0 || n > 30) {\n+            throw new IllegalArgumentException(\"depth must be bigger than 0 and not bigger than 30 but is \" + n);\n         }\n-        Arrays.fill(this.tree = new int[(int)((1L << depth + 1) - 1L)], -1);\n+        Arrays.fill(this.tree = new int[(int)((1L << n + 1) - 1L)], -1);\n     }\n     \n-    public void addLeaf(final int node, final int path, final int depth, final int value) {\n-        if (depth == 0) {\n-            if (this.tree[node] != -1) {\n-                throw new IllegalArgumentException(\"Tree value at index \" + node + \" has already been assigned (\" + this.tree[node]);\n+    public void addLeaf(final int n, final int n2, final int n3, final int n4) {\n+        if (n3 == 0) {\n+            if (this.tree[n] != -1) {\n+                throw new IllegalArgumentException(\"Tree value at index \" + n + \" has already been assigned (\" + this.tree[n]);\n             }\n-            this.tree[node] = value;\n+            this.tree[n] = n4;\n         }\n         else {\n-            this.tree[node] = -2;\n-            final int nextChild = 2 * node + 1 + (path & 0x1);\n-            this.addLeaf(nextChild, path >>> 1, depth - 1, value);\n+            this.tree[n] = -2;\n+            this.addLeaf(2 * n + 1 + (n2 & 0x1), n2 >>> 1, n3 - 1, n4);\n         }\n     }\n     \n-    public int read(final BitStream stream) throws IOException {\n-        int currentIndex = 0;\n+    public int read(final BitStream bitStream) throws IOException {\n+        int n = 0;\n         while (true) {\n-            final int bit = stream.nextBit();\n-            if (bit == -1) {\n+            final int nextBit = bitStream.nextBit();\n+            if (nextBit == -1) {\n                 return -1;\n             }\n-            final int childIndex = 2 * currentIndex + 1 + bit;\n-            final int value = this.tree[childIndex];\n-            if (value == -2) {\n-                currentIndex = childIndex;\n+            final int n2 = 2 * n + 1 + nextBit;\n+            final int n3 = this.tree[n2];\n+            if (n3 == -2) {\n+                n = n2;\n             }\n             else {\n-                if (value != -1) {\n-                    return value;\n+                if (n3 != -1) {\n+                    return n3;\n                 }\n-                throw new IOException(\"The child \" + bit + \" of node at index \" + currentIndex + \" is not defined\");\n+                throw new IOException(\"The child \" + nextBit + \" of node at index \" + n + \" is not defined\");\n             }\n         }\n     }\n     \n-    static BinaryTree decode(final InputStream inputStream, final int totalNumberOfValues) throws IOException {\n-        if (totalNumberOfValues < 0) {\n-            throw new IllegalArgumentException(\"totalNumberOfValues must be bigger than 0, is \" + totalNumberOfValues);\n+    static BinaryTree decode(final InputStream inputStream, final int n) throws IOException {\n+        if (n < 0) {\n+            throw new IllegalArgumentException(\"totalNumberOfValues must be bigger than 0, is \" + n);\n         }\n-        final int size = inputStream.read() + 1;\n-        if (size == 0) {\n+        final int n2 = inputStream.read() + 1;\n+        if (n2 == 0) {\n             throw new IOException(\"Cannot read the size of the encoded tree, unexpected end of stream\");\n         }\n-        final byte[] encodedTree = IOUtils.readRange(inputStream, size);\n-        if (encodedTree.length != size) {\n+        final byte[] range = IOUtils.readRange(inputStream, n2);\n+        if (range.length != n2) {\n             throw new EOFException();\n         }\n-        int maxLength = 0;\n-        final int[] originalBitLengths = new int[totalNumberOfValues];\n-        int pos = 0;\n-        for (final byte b : encodedTree) {\n-            final int numberOfValues = ((b & 0xF0) >> 4) + 1;\n-            if (pos + numberOfValues > totalNumberOfValues) {\n+        int max = 0;\n+        final int[] array = new int[n];\n+        int n3 = 0;\n+        for (final byte b : range) {\n+            final int n4 = ((b & 0xF0) >> 4) + 1;\n+            if (n3 + n4 > n) {\n                 throw new IOException(\"Number of values exceeds given total number of values\");\n             }\n-            final int bitLength = (b & 0xF) + 1;\n-            for (int j = 0; j < numberOfValues; ++j) {\n-                originalBitLengths[pos++] = bitLength;\n-            }\n-            maxLength = Math.max(maxLength, bitLength);\n-        }\n-        final int oBitLengths = originalBitLengths.length;\n-        final int[] permutation = new int[oBitLengths];\n-        for (int k = 0; k < permutation.length; ++k) {\n-            permutation[k] = k;\n-        }\n-        int c = 0;\n-        final int[] sortedBitLengths = new int[oBitLengths];\n-        for (int i = 0; i < oBitLengths; ++i) {\n-            for (int l = 0; l < oBitLengths; ++l) {\n-                if (originalBitLengths[l] == i) {\n-                    sortedBitLengths[c] = i;\n-                    permutation[c] = l;\n-                    ++c;\n+            final int b2 = (b & 0xF) + 1;\n+            for (int j = 0; j < n4; ++j) {\n+                array[n3++] = b2;\n+            }\n+            max = Math.max(max, b2);\n+        }\n+        final int length2 = array.length;\n+        final int[] array3 = new int[length2];\n+        for (int k = 0; k < array3.length; ++k) {\n+            array3[k] = k;\n+        }\n+        int n5 = 0;\n+        final int[] array4 = new int[length2];\n+        for (int l = 0; l < length2; ++l) {\n+            for (int n6 = 0; n6 < length2; ++n6) {\n+                if (array[n6] == l) {\n+                    array4[n5] = l;\n+                    array3[n5] = n6;\n+                    ++n5;\n                 }\n             }\n         }\n-        int code = 0;\n-        int codeIncrement = 0;\n-        int lastBitLength = 0;\n-        final int[] codes = new int[totalNumberOfValues];\n-        for (int m = totalNumberOfValues - 1; m >= 0; --m) {\n-            code += codeIncrement;\n-            if (sortedBitLengths[m] != lastBitLength) {\n-                lastBitLength = sortedBitLengths[m];\n-                codeIncrement = 1 << 16 - lastBitLength;\n-            }\n-            codes[permutation[m]] = code;\n-        }\n-        final BinaryTree tree = new BinaryTree(maxLength);\n-        for (int k2 = 0; k2 < codes.length; ++k2) {\n-            final int bitLength2 = originalBitLengths[k2];\n-            if (bitLength2 > 0) {\n-                tree.addLeaf(0, Integer.reverse(codes[k2] << 16), bitLength2, k2);\n+        int n7 = 0;\n+        int n8 = 0;\n+        int n9 = 0;\n+        final int[] array5 = new int[n];\n+        for (int n10 = n - 1; n10 >= 0; --n10) {\n+            n7 += n8;\n+            if (array4[n10] != n9) {\n+                n9 = array4[n10];\n+                n8 = 1 << 16 - n9;\n+            }\n+            array5[array3[n10]] = n7;\n+        }\n+        final BinaryTree binaryTree = new BinaryTree(max);\n+        for (int n11 = 0; n11 < array5.length; ++n11) {\n+            final int n12 = array[n11];\n+            if (n12 > 0) {\n+                binaryTree.addLeaf(0, Integer.reverse(array5[n11] << 16), n12, n11);\n             }\n         }\n-        return tree;\n+        return binaryTree;\n     }\n }\n"}]}
