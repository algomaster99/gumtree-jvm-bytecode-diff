{"diffoscope-json-version": 1, "source1": "first/ClassConstantPool.class", "source2": "second/ClassConstantPool.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -26,170 +26,167 @@\n         this.entriesContainsSet = new HashSet();\n         this.othersContainsSet = new HashSet();\n         this.mustStartClassPool = new HashSet();\n         this.others = new ArrayList(500);\n         this.entries = new ArrayList(500);\n     }\n     \n-    public ClassFileEntry add(final ClassFileEntry entry) {\n-        if (entry instanceof ByteCode) {\n+    public ClassFileEntry add(final ClassFileEntry classFileEntry) {\n+        if (classFileEntry instanceof ByteCode) {\n             return null;\n         }\n-        if (entry instanceof ConstantPoolEntry) {\n-            if (this.entriesContainsSet.add(entry)) {\n-                this.entries.add(entry);\n+        if (classFileEntry instanceof ConstantPoolEntry) {\n+            if (this.entriesContainsSet.add(classFileEntry)) {\n+                this.entries.add(classFileEntry);\n             }\n         }\n-        else if (this.othersContainsSet.add(entry)) {\n-            this.others.add(entry);\n+        else if (this.othersContainsSet.add(classFileEntry)) {\n+            this.others.add(classFileEntry);\n         }\n-        return entry;\n+        return classFileEntry;\n     }\n     \n     public void addNestedEntries() {\n-        boolean added = true;\n-        final ArrayList parents = new ArrayList(512);\n-        final ArrayList children = new ArrayList(512);\n-        parents.addAll(this.entries);\n-        parents.addAll(this.others);\n-        while (added || parents.size() > 0) {\n-            children.clear();\n-            final int entriesOriginalSize = this.entries.size();\n-            final int othersOriginalSize = this.others.size();\n-            for (int indexParents = 0; indexParents < parents.size(); ++indexParents) {\n-                final ClassFileEntry entry = (ClassFileEntry)parents.get(indexParents);\n-                final ClassFileEntry[] entryChildren = entry.getNestedClassFileEntries();\n-                children.addAll(Arrays.asList(entryChildren));\n-                final boolean isAtStart = entry instanceof ByteCode && ((ByteCode)entry).nestedMustStartClassPool();\n-                if (isAtStart) {\n-                    this.mustStartClassPool.addAll(Arrays.asList(entryChildren));\n+        boolean b = true;\n+        final ArrayList list = new ArrayList(512);\n+        final ArrayList c = new ArrayList(512);\n+        list.addAll(this.entries);\n+        list.addAll(this.others);\n+        while (b || list.size() > 0) {\n+            c.clear();\n+            final int size = this.entries.size();\n+            final int size2 = this.others.size();\n+            for (int i = 0; i < list.size(); ++i) {\n+                final ClassFileEntry classFileEntry = (ClassFileEntry)list.get(i);\n+                final ClassFileEntry[] nestedClassFileEntries = classFileEntry.getNestedClassFileEntries();\n+                c.addAll(Arrays.asList(nestedClassFileEntries));\n+                if (classFileEntry instanceof ByteCode && ((ByteCode)classFileEntry).nestedMustStartClassPool()) {\n+                    this.mustStartClassPool.addAll(Arrays.asList(nestedClassFileEntries));\n                 }\n-                this.add(entry);\n+                this.add(classFileEntry);\n             }\n-            added = (this.entries.size() != entriesOriginalSize || this.others.size() != othersOriginalSize);\n-            parents.clear();\n-            parents.addAll(children);\n+            b = (this.entries.size() != size || this.others.size() != size2);\n+            list.clear();\n+            list.addAll(c);\n         }\n     }\n     \n-    public int indexOf(final ClassFileEntry entry) {\n+    public int indexOf(final ClassFileEntry classFileEntry) {\n         if (!this.resolved) {\n             throw new IllegalStateException(\"Constant pool is not yet resolved; this does not make any sense\");\n         }\n         if (null == this.indexCache) {\n             throw new IllegalStateException(\"Index cache is not initialized!\");\n         }\n-        final Integer entryIndex = Integer.valueOf(this.indexCache.get((Object)entry));\n-        if (entryIndex != null) {\n-            return entryIndex + 1;\n+        final Integer n = Integer.valueOf(this.indexCache.get((Object)classFileEntry));\n+        if (n != null) {\n+            return n + 1;\n         }\n         return -1;\n     }\n     \n     public int size() {\n         return this.entries.size();\n     }\n     \n-    public ClassFileEntry get(int i) {\n+    public ClassFileEntry get(int n) {\n         if (!this.resolved) {\n             throw new IllegalStateException(\"Constant pool is not yet resolved; this does not make any sense\");\n         }\n-        return this.entries.get(--i);\n+        return this.entries.get(--n);\n     }\n     \n     public void resolve(final Segment segment) {\n         this.initialSort();\n         this.sortClassPool();\n         this.resolved = true;\n-        for (int it = 0; it < this.entries.size(); ++it) {\n-            final ClassFileEntry entry = (ClassFileEntry)this.entries.get(it);\n-            entry.resolve(this);\n-        }\n-        for (int it = 0; it < this.others.size(); ++it) {\n-            final ClassFileEntry entry = (ClassFileEntry)this.others.get(it);\n-            entry.resolve(this);\n+        for (int i = 0; i < this.entries.size(); ++i) {\n+            ((ClassFileEntry)this.entries.get(i)).resolve(this);\n+        }\n+        for (int j = 0; j < this.others.size(); ++j) {\n+            ((ClassFileEntry)this.others.get(j)).resolve(this);\n         }\n     }\n     \n     private void initialSort() {\n-        final TreeSet inCpAll = new TreeSet((arg0, arg1) -> ((ConstantPoolEntry)arg0).getGlobalIndex() - ((ConstantPoolEntry)arg1).getGlobalIndex());\n-        final TreeSet cpUtf8sNotInCpAll = new TreeSet((arg0, arg1) -> ((CPUTF8)arg0).underlyingString().compareTo(((CPUTF8)arg1).underlyingString()));\n-        final TreeSet cpClassesNotInCpAll = new TreeSet((arg0, arg1) -> ((CPClass)arg0).getName().compareTo(((CPClass)arg1).getName()));\n-        for (int index = 0; index < this.entries.size(); ++index) {\n-            final ConstantPoolEntry entry = (ConstantPoolEntry)this.entries.get(index);\n-            if (entry.getGlobalIndex() == -1) {\n-                if (entry instanceof CPUTF8) {\n-                    cpUtf8sNotInCpAll.add(entry);\n+        final TreeSet set = new TreeSet((o, o2) -> ((ConstantPoolEntry)o).getGlobalIndex() - ((ConstantPoolEntry)o2).getGlobalIndex());\n+        final TreeSet set2 = new TreeSet((o3, o4) -> ((CPUTF8)o3).underlyingString().compareTo(((CPUTF8)o4).underlyingString()));\n+        final TreeSet set3 = new TreeSet((o5, o6) -> ((CPClass)o5).getName().compareTo(((CPClass)o6).getName()));\n+        for (int i = 0; i < this.entries.size(); ++i) {\n+            final ConstantPoolEntry e = (ConstantPoolEntry)this.entries.get(i);\n+            if (e.getGlobalIndex() == -1) {\n+                if (e instanceof CPUTF8) {\n+                    set2.add(e);\n                 }\n                 else {\n-                    if (!(entry instanceof CPClass)) {\n+                    if (!(e instanceof CPClass)) {\n                         throw new Error(\"error\");\n                     }\n-                    cpClassesNotInCpAll.add(entry);\n+                    set3.add(e);\n                 }\n             }\n             else {\n-                inCpAll.add(entry);\n+                set.add(e);\n             }\n         }\n         this.entries.clear();\n-        this.entries.addAll(inCpAll);\n-        this.entries.addAll(cpUtf8sNotInCpAll);\n-        this.entries.addAll(cpClassesNotInCpAll);\n+        this.entries.addAll(set);\n+        this.entries.addAll(set2);\n+        this.entries.addAll(set3);\n     }\n     \n     public List entries() {\n         return Collections.unmodifiableList((List<?>)this.entries);\n     }\n     \n     protected void sortClassPool() {\n-        final ArrayList startOfPool = new ArrayList(this.entries.size());\n-        final ArrayList finalSort = new ArrayList(this.entries.size());\n+        final ArrayList list = new ArrayList(this.entries.size());\n+        final ArrayList list2 = new ArrayList(this.entries.size());\n         for (int i = 0; i < this.entries.size(); ++i) {\n-            final ClassFileEntry nextEntry = (ClassFileEntry)this.entries.get(i);\n-            if (this.mustStartClassPool.contains(nextEntry)) {\n-                startOfPool.add(nextEntry);\n+            final ClassFileEntry e = (ClassFileEntry)this.entries.get(i);\n+            if (this.mustStartClassPool.contains(e)) {\n+                list.add(e);\n             }\n             else {\n-                finalSort.add(nextEntry);\n+                list2.add(e);\n             }\n         }\n         this.indexCache = new HashMap(this.entries.size());\n-        int index = 0;\n+        int n = 0;\n         this.entries.clear();\n-        for (int itIndex = 0; itIndex < startOfPool.size(); ++itIndex) {\n-            final ClassFileEntry entry = (ClassFileEntry)startOfPool.get(itIndex);\n-            this.indexCache.put(entry, Integer.valueOf(index));\n-            if (entry instanceof CPLong || entry instanceof CPDouble) {\n-                this.entries.add(entry);\n-                this.entries.add(entry);\n-                index += 2;\n+        for (int j = 0; j < list.size(); ++j) {\n+            final ClassFileEntry classFileEntry = (ClassFileEntry)list.get(j);\n+            this.indexCache.put(classFileEntry, Integer.valueOf(n));\n+            if (classFileEntry instanceof CPLong || classFileEntry instanceof CPDouble) {\n+                this.entries.add(classFileEntry);\n+                this.entries.add(classFileEntry);\n+                n += 2;\n             }\n             else {\n-                this.entries.add(entry);\n-                ++index;\n+                this.entries.add(classFileEntry);\n+                ++n;\n             }\n         }\n-        for (int itFinal = 0; itFinal < finalSort.size(); ++itFinal) {\n-            final ClassFileEntry entry = (ClassFileEntry)finalSort.get(itFinal);\n-            this.indexCache.put(entry, Integer.valueOf(index));\n-            if (entry instanceof CPLong || entry instanceof CPDouble) {\n-                this.entries.add(entry);\n-                this.entries.add(entry);\n-                index += 2;\n+        for (int k = 0; k < list2.size(); ++k) {\n+            final ClassFileEntry classFileEntry2 = (ClassFileEntry)list2.get(k);\n+            this.indexCache.put(classFileEntry2, Integer.valueOf(n));\n+            if (classFileEntry2 instanceof CPLong || classFileEntry2 instanceof CPDouble) {\n+                this.entries.add(classFileEntry2);\n+                this.entries.add(classFileEntry2);\n+                n += 2;\n             }\n             else {\n-                this.entries.add(entry);\n-                ++index;\n+                this.entries.add(classFileEntry2);\n+                ++n;\n             }\n         }\n     }\n     \n-    public ClassFileEntry addWithNestedEntries(final ClassFileEntry entry) {\n-        this.add(entry);\n-        final ClassFileEntry[] nestedEntries = entry.getNestedClassFileEntries();\n-        for (int i = 0; i < nestedEntries.length; ++i) {\n-            this.addWithNestedEntries(nestedEntries[i]);\n+    public ClassFileEntry addWithNestedEntries(final ClassFileEntry classFileEntry) {\n+        this.add(classFileEntry);\n+        final ClassFileEntry[] nestedClassFileEntries = classFileEntry.getNestedClassFileEntries();\n+        for (int i = 0; i < nestedClassFileEntries.length; ++i) {\n+            this.addWithNestedEntries(nestedClassFileEntries[i]);\n         }\n-        return entry;\n+        return classFileEntry;\n     }\n }\n"}]}
