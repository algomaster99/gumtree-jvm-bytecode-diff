{"diffoscope-json-version": 1, "source1": "first/ByteOrderMark.class", "source2": "second/ByteOrderMark.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -12,14 +12,22 @@\n     public static final ByteOrderMark UTF_16LE;\n     public static final ByteOrderMark UTF_32BE;\n     public static final ByteOrderMark UTF_32LE;\n     public static final char UTF_BOM = '\\ufeff';\n     private final String charsetName;\n     private final int[] bytes;\n     \n+    static {\n+        UTF_8 = new ByteOrderMark(\"UTF-8\", new int[] { 239, 187, 191 });\n+        UTF_16BE = new ByteOrderMark(\"UTF-16BE\", new int[] { 254, 255 });\n+        UTF_16LE = new ByteOrderMark(\"UTF-16LE\", new int[] { 255, 254 });\n+        UTF_32BE = new ByteOrderMark(\"UTF-32BE\", new int[] { 0, 0, 254, 255 });\n+        UTF_32LE = new ByteOrderMark(\"UTF-32LE\", new int[] { 255, 254, 0, 0 });\n+    }\n+    \n     public ByteOrderMark(final String charsetName, final int... bytes) {\n         if (charsetName == null || charsetName.isEmpty()) {\n             throw new IllegalArgumentException(\"No charsetName specified\");\n         }\n         if (bytes == null || bytes.length == 0) {\n             throw new IllegalArgumentException(\"No bytes specified\");\n         }\n@@ -63,15 +71,17 @@\n         }\n         return true;\n     }\n     \n     @Override\n     public int hashCode() {\n         int hashCode = this.getClass().hashCode();\n-        for (final int b : this.bytes) {\n+        int[] bytes;\n+        for (int length = (bytes = this.bytes).length, i = 0; i < length; ++i) {\n+            final int b = bytes[i];\n             hashCode += b;\n         }\n         return hashCode;\n     }\n     \n     @Override\n     public String toString() {\n@@ -86,16 +96,8 @@\n             }\n             builder.append(\"0x\");\n             builder.append(Integer.toHexString(0xFF & this.bytes[i]).toUpperCase(Locale.ROOT));\n         }\n         builder.append(']');\n         return builder.toString();\n     }\n-    \n-    static {\n-        UTF_8 = new ByteOrderMark(\"UTF-8\", new int[] { 239, 187, 191 });\n-        UTF_16BE = new ByteOrderMark(\"UTF-16BE\", new int[] { 254, 255 });\n-        UTF_16LE = new ByteOrderMark(\"UTF-16LE\", new int[] { 255, 254 });\n-        UTF_32BE = new ByteOrderMark(\"UTF-32BE\", new int[] { 0, 0, 254, 255 });\n-        UTF_32LE = new ByteOrderMark(\"UTF-32LE\", new int[] { 255, 254, 0, 0 });\n-    }\n }\n"}]}
