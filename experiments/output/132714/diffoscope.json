{"diffoscope-json-version": 1, "source1": "first/MemberUtils.class", "source2": "second/MemberUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -9,14 +9,18 @@\n import java.lang.reflect.AccessibleObject;\n \n abstract class MemberUtils\n {\n     private static final int ACCESS_TEST = 7;\n     private static final Class<?>[] ORDERED_PRIMITIVE_TYPES;\n     \n+    static {\n+        ORDERED_PRIMITIVE_TYPES = new Class[] { Byte.TYPE, Short.TYPE, Character.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE };\n+    }\n+    \n     static boolean setAccessibleWorkaround(final AccessibleObject o) {\n         if (o == null || o.isAccessible()) {\n             return false;\n         }\n         final Member m = (Member)o;\n         if (!o.isAccessible() && Modifier.isPublic(m.getModifiers()) && isPackageAccess(m.getDeclaringClass().getModifiers())) {\n             try {\n@@ -33,32 +37,32 @@\n     }\n     \n     static boolean isAccessible(final Member m) {\n         return m != null && Modifier.isPublic(m.getModifiers()) && !m.isSynthetic();\n     }\n     \n     static int compareConstructorFit(final Constructor<?> left, final Constructor<?> right, final Class<?>[] actual) {\n-        return compareParameterTypes(MemberUtils.Executable.access$000((Constructor)left), MemberUtils.Executable.access$000((Constructor)right), actual);\n+        return compareParameterTypes(MemberUtils.Executable.access$0((Constructor)left), MemberUtils.Executable.access$0((Constructor)right), actual);\n     }\n     \n     static int compareMethodFit(final Method left, final Method right, final Class<?>[] actual) {\n-        return compareParameterTypes(MemberUtils.Executable.access$100(left), MemberUtils.Executable.access$100(right), actual);\n+        return compareParameterTypes(MemberUtils.Executable.access$1(left), MemberUtils.Executable.access$1(right), actual);\n     }\n     \n     private static int compareParameterTypes(final MemberUtils.Executable left, final MemberUtils.Executable right, final Class<?>[] actual) {\n         final float leftCost = getTotalTransformationCost(actual, left);\n         final float rightCost = getTotalTransformationCost(actual, right);\n         return (leftCost < rightCost) ? -1 : ((rightCost < leftCost) ? 1 : 0);\n     }\n     \n     private static float getTotalTransformationCost(final Class<?>[] srcArgs, final MemberUtils.Executable executable) {\n-        final Class<?>[] destArgs = executable.getParameterTypes();\n+        final Class[] destArgs = executable.getParameterTypes();\n         final boolean isVarArgs = executable.isVarArgs();\n         float totalCost = 0.0f;\n-        final long normalArgsLen = isVarArgs ? ((long)(destArgs.length - 1)) : ((long)destArgs.length);\n+        final long normalArgsLen = (long)(isVarArgs ? (destArgs.length - 1) : destArgs.length);\n         if (srcArgs.length < normalArgsLen) {\n             return Float.MAX_VALUE;\n         }\n         for (int i = 0; i < normalArgsLen; ++i) {\n             totalCost += getObjectTransformationCost(srcArgs[i], destArgs[i]);\n         }\n         if (isVarArgs) {\n@@ -117,42 +121,38 @@\n                 }\n             }\n         }\n         return cost;\n     }\n     \n     static boolean isMatchingMethod(final Method method, final Class<?>[] parameterTypes) {\n-        return isMatchingExecutable(MemberUtils.Executable.access$100(method), parameterTypes);\n+        return isMatchingExecutable(MemberUtils.Executable.access$1(method), parameterTypes);\n     }\n     \n     static boolean isMatchingConstructor(final Constructor<?> method, final Class<?>[] parameterTypes) {\n-        return isMatchingExecutable(MemberUtils.Executable.access$000((Constructor)method), parameterTypes);\n+        return isMatchingExecutable(MemberUtils.Executable.access$0((Constructor)method), parameterTypes);\n     }\n     \n     private static boolean isMatchingExecutable(final MemberUtils.Executable method, final Class<?>[] parameterTypes) {\n-        final Class<?>[] methodParameterTypes = method.getParameterTypes();\n-        if (ClassUtils.isAssignable((Class[])parameterTypes, (Class[])methodParameterTypes, true)) {\n+        final Class[] methodParameterTypes = method.getParameterTypes();\n+        if (ClassUtils.isAssignable((Class[])parameterTypes, methodParameterTypes, true)) {\n             return true;\n         }\n         if (method.isVarArgs()) {\n             int i;\n             for (i = 0; i < methodParameterTypes.length - 1 && i < parameterTypes.length; ++i) {\n-                if (!ClassUtils.isAssignable((Class)parameterTypes[i], (Class)methodParameterTypes[i], true)) {\n+                if (!ClassUtils.isAssignable((Class)parameterTypes[i], methodParameterTypes[i], true)) {\n                     return false;\n                 }\n             }\n             final Class<?> varArgParameterType = methodParameterTypes[methodParameterTypes.length - 1].getComponentType();\n             while (i < parameterTypes.length) {\n                 if (!ClassUtils.isAssignable((Class)parameterTypes[i], (Class)varArgParameterType, true)) {\n                     return false;\n                 }\n                 ++i;\n             }\n             return true;\n         }\n         return false;\n     }\n-    \n-    static {\n-        ORDERED_PRIMITIVE_TYPES = new Class[] { Byte.TYPE, Short.TYPE, Character.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE };\n-    }\n }\n"}]}
