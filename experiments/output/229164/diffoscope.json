{"diffoscope-json-version": 1, "source1": "first/TarUtils.class", "source2": "second/TarUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -12,253 +12,247 @@\n     private static final int BYTE_MASK = 255;\n     static final ZipEncoding DEFAULT_ENCODING;\n     static final ZipEncoding FALLBACK_ENCODING;\n     \n     private TarUtils() {\n     }\n     \n-    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n-        long result = 0L;\n-        int end = offset + length;\n-        int start = offset;\n-        if (length < 2) {\n-            throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n+    public static long parseOctal(final byte[] array, final int n, final int i) {\n+        long n2 = 0L;\n+        int n3 = n + i;\n+        int j = n;\n+        if (i < 2) {\n+            throw new IllegalArgumentException(\"Length \" + i + \" must be at least 2\");\n         }\n-        if (buffer[start] == 0) {\n+        if (array[j] == 0) {\n             return 0L;\n         }\n-        while (start < end && buffer[start] == 32) {\n-            ++start;\n+        while (j < n3 && array[j] == 32) {\n+            ++j;\n         }\n-        for (byte trailer = buffer[end - 1]; start < end && (trailer == 0 || trailer == 32); --end, trailer = buffer[end - 1]) {}\n-        while (start < end) {\n-            final byte currentByte = buffer[start];\n-            if (currentByte < 48 || currentByte > 55) {\n-                throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));\n+        for (byte b = array[n3 - 1]; j < n3 && (b == 0 || b == 32); --n3, b = array[n3 - 1]) {}\n+        while (j < n3) {\n+            final byte b2 = array[j];\n+            if (b2 < 48 || b2 > 55) {\n+                throw new IllegalArgumentException(exceptionMessage(array, n, i, j, b2));\n             }\n-            result = (result << 3) + (currentByte - 48);\n-            ++start;\n+            n2 = (n2 << 3) + (b2 - 48);\n+            ++j;\n         }\n-        return result;\n+        return n2;\n     }\n     \n-    public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length) {\n-        if ((buffer[offset] & 0x80) == 0x0) {\n-            return parseOctal(buffer, offset, length);\n+    public static long parseOctalOrBinary(final byte[] array, final int n, final int n2) {\n+        if ((array[n] & 0x80) == 0x0) {\n+            return parseOctal(array, n, n2);\n         }\n-        final boolean negative = buffer[offset] == -1;\n-        if (length < 9) {\n-            return parseBinaryLong(buffer, offset, length, negative);\n+        final boolean b = array[n] == -1;\n+        if (n2 < 9) {\n+            return parseBinaryLong(array, n, n2, b);\n         }\n-        return parseBinaryBigInteger(buffer, offset, length, negative);\n+        return parseBinaryBigInteger(array, n, n2, b);\n     }\n     \n-    private static long parseBinaryLong(final byte[] buffer, final int offset, final int length, final boolean negative) {\n-        if (length >= 9) {\n-            throw new IllegalArgumentException(\"At offset \" + offset + \", \" + length + \" byte binary number exceeds maximum signed long value\");\n+    private static long parseBinaryLong(final byte[] array, final int i, final int j, final boolean b) {\n+        if (j >= 9) {\n+            throw new IllegalArgumentException(\"At offset \" + i + \", \" + j + \" byte binary number exceeds maximum signed long value\");\n         }\n-        long val = 0L;\n-        for (int i = 1; i < length; ++i) {\n-            val = (val << 8) + (buffer[offset + i] & 0xFF);\n+        long n = 0L;\n+        for (int k = 1; k < j; ++k) {\n+            n = (n << 8) + (array[i + k] & 0xFF);\n         }\n-        if (negative) {\n-            --val;\n-            val ^= (long)Math.pow(2.0, (double)(length - 1) * 8.0) - 1L;\n+        if (b) {\n+            n = (n - 1L ^ (long)Math.pow(2.0, (double)(j - 1) * 8.0) - 1L);\n         }\n-        return negative ? (-val) : val;\n+        return b ? (-n) : n;\n     }\n     \n-    private static long parseBinaryBigInteger(final byte[] buffer, final int offset, final int length, final boolean negative) {\n-        final byte[] remainder = new byte[length - 1];\n-        System.arraycopy(buffer, offset + 1, remainder, 0, length - 1);\n-        BigInteger val = new BigInteger(remainder);\n-        if (negative) {\n-            val = val.add(BigInteger.valueOf(-1L)).not();\n+    private static long parseBinaryBigInteger(final byte[] array, final int i, final int j, final boolean b) {\n+        final byte[] val = new byte[j - 1];\n+        System.arraycopy(array, i + 1, val, 0, j - 1);\n+        BigInteger not = new BigInteger(val);\n+        if (b) {\n+            not = not.add(BigInteger.valueOf(-1L)).not();\n         }\n-        if (val.bitLength() > 63) {\n-            throw new IllegalArgumentException(\"At offset \" + offset + \", \" + length + \" byte binary number exceeds maximum signed long value\");\n+        if (not.bitLength() > 63) {\n+            throw new IllegalArgumentException(\"At offset \" + i + \", \" + j + \" byte binary number exceeds maximum signed long value\");\n         }\n-        return negative ? (-val.longValue()) : val.longValue();\n+        return b ? (-not.longValue()) : not.longValue();\n     }\n     \n-    public static boolean parseBoolean(final byte[] buffer, final int offset) {\n-        return buffer[offset] == 1;\n+    public static boolean parseBoolean(final byte[] array, final int n) {\n+        return array[n] == 1;\n     }\n     \n-    private static String exceptionMessage(final byte[] buffer, final int offset, final int length, final int current, final byte currentByte) {\n-        String string = new String(buffer, offset, length);\n-        string = string.replaceAll(\"\\u0000\", \"{NUL}\");\n-        return \"Invalid byte \" + currentByte + \" at offset \" + (current - offset) + \" in '\" + string + \"' len=\" + length;\n+    private static String exceptionMessage(final byte[] bytes, final int offset, final int n, final int n2, final byte i) {\n+        return \"Invalid byte \" + i + \" at offset \" + (n2 - offset) + \" in '\" + new String(bytes, offset, n).replaceAll(\"\\u0000\", \"{NUL}\") + \"' len=\" + n;\n     }\n     \n-    public static String parseName(final byte[] buffer, final int offset, final int length) {\n+    public static String parseName(final byte[] array, final int n, final int n2) {\n         try {\n-            return parseName(buffer, offset, length, TarUtils.DEFAULT_ENCODING);\n+            return parseName(array, n, n2, TarUtils.DEFAULT_ENCODING);\n         }\n         catch (final IOException ex) {\n             try {\n-                return parseName(buffer, offset, length, TarUtils.FALLBACK_ENCODING);\n+                return parseName(array, n, n2, TarUtils.FALLBACK_ENCODING);\n             }\n-            catch (final IOException ex2) {\n-                throw new RuntimeException(ex2);\n+            catch (final IOException cause) {\n+                throw new RuntimeException(cause);\n             }\n         }\n     }\n     \n-    public static String parseName(final byte[] buffer, final int offset, final int length, final ZipEncoding encoding) throws IOException {\n-        int len = 0;\n-        for (int i = offset; len < length && buffer[i] != 0; ++len, ++i) {}\n-        if (len > 0) {\n-            final byte[] b = new byte[len];\n-            System.arraycopy(buffer, offset, b, 0, len);\n-            return encoding.decode(b);\n+    public static String parseName(final byte[] array, final int n, final int n2, final ZipEncoding zipEncoding) throws IOException {\n+        int n3 = 0;\n+        for (int n4 = n; n3 < n2 && array[n4] != 0; ++n3, ++n4) {}\n+        if (n3 > 0) {\n+            final byte[] array2 = new byte[n3];\n+            System.arraycopy(array, n, array2, 0, n3);\n+            return zipEncoding.decode(array2);\n         }\n         return \"\";\n     }\n     \n-    public static int formatNameBytes(final String name, final byte[] buf, final int offset, final int length) {\n+    public static int formatNameBytes(final String s, final byte[] array, final int n, final int n2) {\n         try {\n-            return formatNameBytes(name, buf, offset, length, TarUtils.DEFAULT_ENCODING);\n+            return formatNameBytes(s, array, n, n2, TarUtils.DEFAULT_ENCODING);\n         }\n         catch (final IOException ex) {\n             try {\n-                return formatNameBytes(name, buf, offset, length, TarUtils.FALLBACK_ENCODING);\n+                return formatNameBytes(s, array, n, n2, TarUtils.FALLBACK_ENCODING);\n             }\n-            catch (final IOException ex2) {\n-                throw new RuntimeException(ex2);\n+            catch (final IOException cause) {\n+                throw new RuntimeException(cause);\n             }\n         }\n     }\n     \n-    public static int formatNameBytes(final String name, final byte[] buf, final int offset, final int length, final ZipEncoding encoding) throws IOException {\n-        int len;\n-        ByteBuffer b;\n-        for (len = name.length(), b = encoding.encode(name); b.limit() > length && len > 0; b = encoding.encode(name.substring(0, --len))) {}\n-        final int limit = b.limit() - b.position();\n-        System.arraycopy(b.array(), b.arrayOffset(), buf, offset, limit);\n-        for (int i = limit; i < length; ++i) {\n-            buf[offset + i] = 0;\n+    public static int formatNameBytes(final String s, final byte[] array, final int n, final int n2, final ZipEncoding zipEncoding) throws IOException {\n+        int length;\n+        ByteBuffer byteBuffer;\n+        for (length = s.length(), byteBuffer = zipEncoding.encode(s); byteBuffer.limit() > n2 && length > 0; byteBuffer = zipEncoding.encode(s.substring(0, --length))) {}\n+        final int n3 = byteBuffer.limit() - byteBuffer.position();\n+        System.arraycopy(byteBuffer.array(), byteBuffer.arrayOffset(), array, n, n3);\n+        for (int i = n3; i < n2; ++i) {\n+            array[n + i] = 0;\n         }\n-        return offset + length;\n+        return n + n2;\n     }\n     \n-    public static void formatUnsignedOctalString(final long value, final byte[] buffer, final int offset, final int length) {\n-        int remaining = length;\n-        --remaining;\n-        if (value == 0L) {\n-            buffer[offset + remaining--] = 48;\n+    public static void formatUnsignedOctalString(final long n, final byte[] array, final int n2, final int i) {\n+        int j = i;\n+        --j;\n+        if (n == 0L) {\n+            array[n2 + j--] = 48;\n         }\n         else {\n-            long val;\n-            for (val = value; remaining >= 0 && val != 0L; val >>>= 3, --remaining) {\n-                buffer[offset + remaining] = (byte)(48 + (byte)(val & 0x7L));\n+            long n3;\n+            for (n3 = n; j >= 0 && n3 != 0L; n3 >>>= 3, --j) {\n+                array[n2 + j] = (byte)(48 + (byte)(n3 & 0x7L));\n             }\n-            if (val != 0L) {\n-                throw new IllegalArgumentException(value + \"=\" + Long.toOctalString(value) + \" will not fit in octal number buffer of length \" + length);\n+            if (n3 != 0L) {\n+                throw new IllegalArgumentException(n + \"=\" + Long.toOctalString(n) + \" will not fit in octal number buffer of length \" + i);\n             }\n         }\n-        while (remaining >= 0) {\n-            buffer[offset + remaining] = 48;\n-            --remaining;\n+        while (j >= 0) {\n+            array[n2 + j] = 48;\n+            --j;\n         }\n     }\n     \n-    public static int formatOctalBytes(final long value, final byte[] buf, final int offset, final int length) {\n-        int idx = length - 2;\n-        formatUnsignedOctalString(value, buf, offset, idx);\n-        buf[offset + idx++] = 32;\n-        buf[offset + idx] = 0;\n-        return offset + length;\n+    public static int formatOctalBytes(final long n, final byte[] array, final int n2, final int n3) {\n+        int n4 = n3 - 2;\n+        formatUnsignedOctalString(n, array, n2, n4);\n+        array[n2 + n4++] = 32;\n+        array[n2 + n4] = 0;\n+        return n2 + n3;\n     }\n     \n-    public static int formatLongOctalBytes(final long value, final byte[] buf, final int offset, final int length) {\n-        final int idx = length - 1;\n-        formatUnsignedOctalString(value, buf, offset, idx);\n-        buf[offset + idx] = 32;\n-        return offset + length;\n+    public static int formatLongOctalBytes(final long n, final byte[] array, final int n2, final int n3) {\n+        final int n4 = n3 - 1;\n+        formatUnsignedOctalString(n, array, n2, n4);\n+        array[n2 + n4] = 32;\n+        return n2 + n3;\n     }\n     \n-    public static int formatLongOctalOrBinaryBytes(final long value, final byte[] buf, final int offset, final int length) {\n-        final long maxAsOctalChar = (length == 8) ? 2097151L : 8589934591L;\n-        final boolean negative = value < 0L;\n-        if (!negative && value <= maxAsOctalChar) {\n-            return formatLongOctalBytes(value, buf, offset, length);\n+    public static int formatLongOctalOrBinaryBytes(final long n, final byte[] array, final int n2, final int n3) {\n+        final long n4 = (n3 == 8) ? 2097151L : 8589934591L;\n+        final boolean b = n < 0L;\n+        if (!b && n <= n4) {\n+            return formatLongOctalBytes(n, array, n2, n3);\n         }\n-        if (length < 9) {\n-            formatLongBinary(value, buf, offset, length, negative);\n+        if (n3 < 9) {\n+            formatLongBinary(n, array, n2, n3, b);\n         }\n         else {\n-            formatBigIntegerBinary(value, buf, offset, length, negative);\n+            formatBigIntegerBinary(n, array, n2, n3, b);\n         }\n-        buf[offset] = (byte)(negative ? 255 : 128);\n-        return offset + length;\n+        array[n2] = (byte)(b ? 255 : 128);\n+        return n2 + n3;\n     }\n     \n-    private static void formatLongBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) {\n-        final int bits = (length - 1) * 8;\n-        final long max = 1L << bits;\n-        long val = Math.abs(value);\n-        if (val < 0L || val >= max) {\n-            throw new IllegalArgumentException(\"Value \" + value + \" is too large for \" + length + \" byte field.\");\n+    private static void formatLongBinary(final long n, final byte[] array, final int n2, final int i, final boolean b) {\n+        final int n3 = (i - 1) * 8;\n+        final long n4 = 1L << n3;\n+        long abs = Math.abs(n);\n+        if (abs < 0L || abs >= n4) {\n+            throw new IllegalArgumentException(\"Value \" + n + \" is too large for \" + i + \" byte field.\");\n         }\n-        if (negative) {\n-            val ^= max - 1L;\n-            ++val;\n-            val |= 255L << bits;\n+        if (b) {\n+            abs = ((abs ^ n4 - 1L) + 1L | 255L << n3);\n         }\n-        for (int i = offset + length - 1; i >= offset; --i) {\n-            buf[i] = (byte)val;\n-            val >>= 8;\n+        for (int j = n2 + i - 1; j >= n2; --j) {\n+            array[j] = (byte)abs;\n+            abs >>= 8;\n         }\n     }\n     \n-    private static void formatBigIntegerBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) {\n-        final BigInteger val = BigInteger.valueOf(value);\n-        final byte[] b = val.toByteArray();\n-        final int len = b.length;\n-        if (len > length - 1) {\n-            throw new IllegalArgumentException(\"Value \" + value + \" is too large for \" + length + \" byte field.\");\n+    private static void formatBigIntegerBinary(final long n, final byte[] array, final int n2, final int i, final boolean b) {\n+        final byte[] byteArray = BigInteger.valueOf(n).toByteArray();\n+        final int length = byteArray.length;\n+        if (length > i - 1) {\n+            throw new IllegalArgumentException(\"Value \" + n + \" is too large for \" + i + \" byte field.\");\n         }\n-        final int off = offset + length - len;\n-        System.arraycopy(b, 0, buf, off, len);\n-        final byte fill = (byte)(negative ? 255 : 0);\n-        for (int i = offset + 1; i < off; ++i) {\n-            buf[i] = fill;\n+        final int n3 = n2 + i - length;\n+        System.arraycopy(byteArray, 0, array, n3, length);\n+        final byte b2 = (byte)(b ? 255 : 0);\n+        for (int j = n2 + 1; j < n3; ++j) {\n+            array[j] = b2;\n         }\n     }\n     \n-    public static int formatCheckSumOctalBytes(final long value, final byte[] buf, final int offset, final int length) {\n-        int idx = length - 2;\n-        formatUnsignedOctalString(value, buf, offset, idx);\n-        buf[offset + idx++] = 0;\n-        buf[offset + idx] = 32;\n-        return offset + length;\n+    public static int formatCheckSumOctalBytes(final long n, final byte[] array, final int n2, final int n3) {\n+        int n4 = n3 - 2;\n+        formatUnsignedOctalString(n, array, n2, n4);\n+        array[n2 + n4++] = 0;\n+        array[n2 + n4] = 32;\n+        return n2 + n3;\n     }\n     \n-    public static long computeCheckSum(final byte[] buf) {\n-        long sum = 0L;\n-        for (final byte element : buf) {\n-            sum += (0xFF & element);\n+    public static long computeCheckSum(final byte[] array) {\n+        long n = 0L;\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            n += (0xFF & array[i]);\n         }\n-        return sum;\n+        return n;\n     }\n     \n-    public static boolean verifyCheckSum(final byte[] header) {\n-        final long storedSum = parseOctal(header, 148, 8);\n-        long unsignedSum = 0L;\n-        long signedSum = 0L;\n-        for (int i = 0; i < header.length; ++i) {\n-            byte b = header[i];\n+    public static boolean verifyCheckSum(final byte[] array) {\n+        final long octal = parseOctal(array, 148, 8);\n+        long n = 0L;\n+        long n2 = 0L;\n+        for (int i = 0; i < array.length; ++i) {\n+            int n3 = array[i];\n             if (148 <= i && i < 156) {\n-                b = 32;\n+                n3 = 32;\n             }\n-            unsignedSum += (0xFF & b);\n-            signedSum += b;\n+            n += (0xFF & n3);\n+            n2 += n3;\n         }\n-        return storedSum == unsignedSum || storedSum == signedSum;\n+        return octal == n || octal == n2;\n     }\n     \n     static {\n         DEFAULT_ENCODING = ZipEncodingHelper.getZipEncoding((String)null);\n         FALLBACK_ENCODING = (ZipEncoding)new TarUtils.TarUtils$1();\n     }\n }\n"}]}
