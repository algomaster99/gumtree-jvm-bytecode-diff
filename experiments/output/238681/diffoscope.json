{"diffoscope-json-version": 1, "source1": "first/WordUtils.class", "source2": "second/WordUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -5,223 +5,222 @@\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n import org.apache.commons.lang3.StringUtils;\n \n @Deprecated\n public class WordUtils\n {\n-    public static String wrap(final String str, final int wrapLength) {\n-        return wrap(str, wrapLength, null, false);\n+    public static String wrap(final String s, final int n) {\n+        return wrap(s, n, null, false);\n     }\n     \n-    public static String wrap(final String str, final int wrapLength, final String newLineStr, final boolean wrapLongWords) {\n-        return wrap(str, wrapLength, newLineStr, wrapLongWords, \" \");\n+    public static String wrap(final String s, final int n, final String s2, final boolean b) {\n+        return wrap(s, n, s2, b, \" \");\n     }\n     \n-    public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords, String wrapOn) {\n-        if (str == null) {\n+    public static String wrap(final String s, int n, String lineSeparator, final boolean b, String regex) {\n+        if (s == null) {\n             return null;\n         }\n-        if (newLineStr == null) {\n-            newLineStr = System.lineSeparator();\n+        if (lineSeparator == null) {\n+            lineSeparator = System.lineSeparator();\n         }\n-        if (wrapLength < 1) {\n-            wrapLength = 1;\n+        if (n < 1) {\n+            n = 1;\n         }\n-        if (StringUtils.isBlank((CharSequence)wrapOn)) {\n-            wrapOn = \" \";\n+        if (StringUtils.isBlank((CharSequence)regex)) {\n+            regex = \" \";\n         }\n-        final Pattern patternToWrapOn = Pattern.compile(wrapOn);\n-        final int inputLineLength = str.length();\n-        int offset = 0;\n-        final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);\n-        while (offset < inputLineLength) {\n-            int spaceToWrapAt = -1;\n-            Matcher matcher = patternToWrapOn.matcher(str.substring(offset, Math.min((int)Math.min(2147483647L, (long)(offset + wrapLength) + 1L), inputLineLength)));\n+        final Pattern compile = Pattern.compile(regex);\n+        final int length = s.length();\n+        int i = 0;\n+        final StringBuilder sb = new StringBuilder(length + 32);\n+        while (i < length) {\n+            int n2 = -1;\n+            final Matcher matcher = compile.matcher(s.substring(i, Math.min((int)Math.min(2147483647L, (long)(i + n) + 1L), length)));\n             if (matcher.find()) {\n                 if (matcher.start() == 0) {\n-                    offset += matcher.end();\n+                    i += matcher.end();\n                     continue;\n                 }\n-                spaceToWrapAt = matcher.start() + offset;\n+                n2 = matcher.start() + i;\n             }\n-            if (inputLineLength - offset <= wrapLength) {\n+            if (length - i <= n) {\n                 break;\n             }\n             while (matcher.find()) {\n-                spaceToWrapAt = matcher.start() + offset;\n+                n2 = matcher.start() + i;\n             }\n-            if (spaceToWrapAt >= offset) {\n-                wrappedLine.append(str, offset, spaceToWrapAt);\n-                wrappedLine.append(newLineStr);\n-                offset = spaceToWrapAt + 1;\n-            }\n-            else if (wrapLongWords) {\n-                wrappedLine.append(str, offset, wrapLength + offset);\n-                wrappedLine.append(newLineStr);\n-                offset += wrapLength;\n+            if (n2 >= i) {\n+                sb.append(s, i, n2);\n+                sb.append(lineSeparator);\n+                i = n2 + 1;\n+            }\n+            else if (b) {\n+                sb.append(s, i, n + i);\n+                sb.append(lineSeparator);\n+                i += n;\n             }\n             else {\n-                matcher = patternToWrapOn.matcher(str.substring(offset + wrapLength));\n-                if (matcher.find()) {\n-                    spaceToWrapAt = matcher.start() + offset + wrapLength;\n-                }\n-                if (spaceToWrapAt >= 0) {\n-                    wrappedLine.append(str, offset, spaceToWrapAt);\n-                    wrappedLine.append(newLineStr);\n-                    offset = spaceToWrapAt + 1;\n+                final Matcher matcher2 = compile.matcher(s.substring(i + n));\n+                if (matcher2.find()) {\n+                    n2 = matcher2.start() + i + n;\n+                }\n+                if (n2 >= 0) {\n+                    sb.append(s, i, n2);\n+                    sb.append(lineSeparator);\n+                    i = n2 + 1;\n                 }\n                 else {\n-                    wrappedLine.append(str, offset, str.length());\n-                    offset = inputLineLength;\n+                    sb.append(s, i, s.length());\n+                    i = length;\n                 }\n             }\n         }\n-        wrappedLine.append(str, offset, str.length());\n-        return wrappedLine.toString();\n+        sb.append(s, i, s.length());\n+        return sb.toString();\n     }\n     \n-    public static String capitalize(final String str) {\n-        return capitalize(str, (char[])null);\n+    public static String capitalize(final String s) {\n+        return capitalize(s, (char[])null);\n     }\n     \n-    public static String capitalize(final String str, final char... delimiters) {\n-        final int delimLen = (delimiters == null) ? -1 : delimiters.length;\n-        if (StringUtils.isEmpty((CharSequence)str) || delimLen == 0) {\n-            return str;\n+    public static String capitalize(final String s, final char... array) {\n+        final int n = (array == null) ? -1 : array.length;\n+        if (StringUtils.isEmpty((CharSequence)s) || n == 0) {\n+            return s;\n         }\n-        final char[] buffer = str.toCharArray();\n-        boolean capitalizeNext = true;\n-        for (int i = 0; i < buffer.length; ++i) {\n-            final char ch = buffer[i];\n-            if (isDelimiter(ch, delimiters)) {\n-                capitalizeNext = true;\n+        final char[] charArray = s.toCharArray();\n+        int n2 = 1;\n+        for (int i = 0; i < charArray.length; ++i) {\n+            final char ch = charArray[i];\n+            if (isDelimiter(ch, array)) {\n+                n2 = 1;\n             }\n-            else if (capitalizeNext) {\n-                buffer[i] = Character.toTitleCase(ch);\n-                capitalizeNext = false;\n+            else if (n2 != 0) {\n+                charArray[i] = Character.toTitleCase(ch);\n+                n2 = 0;\n             }\n         }\n-        return new String(buffer);\n+        return new String(charArray);\n     }\n     \n-    public static String capitalizeFully(final String str) {\n-        return capitalizeFully(str, (char[])null);\n+    public static String capitalizeFully(final String s) {\n+        return capitalizeFully(s, (char[])null);\n     }\n     \n-    public static String capitalizeFully(String str, final char... delimiters) {\n-        final int delimLen = (delimiters == null) ? -1 : delimiters.length;\n-        if (StringUtils.isEmpty((CharSequence)str) || delimLen == 0) {\n-            return str;\n+    public static String capitalizeFully(String lowerCase, final char... array) {\n+        final int n = (array == null) ? -1 : array.length;\n+        if (StringUtils.isEmpty((CharSequence)lowerCase) || n == 0) {\n+            return lowerCase;\n         }\n-        str = str.toLowerCase();\n-        return capitalize(str, delimiters);\n+        lowerCase = lowerCase.toLowerCase();\n+        return capitalize(lowerCase, array);\n     }\n     \n-    public static String uncapitalize(final String str) {\n-        return uncapitalize(str, (char[])null);\n+    public static String uncapitalize(final String s) {\n+        return uncapitalize(s, (char[])null);\n     }\n     \n-    public static String uncapitalize(final String str, final char... delimiters) {\n-        final int delimLen = (delimiters == null) ? -1 : delimiters.length;\n-        if (StringUtils.isEmpty((CharSequence)str) || delimLen == 0) {\n-            return str;\n+    public static String uncapitalize(final String s, final char... array) {\n+        final int n = (array == null) ? -1 : array.length;\n+        if (StringUtils.isEmpty((CharSequence)s) || n == 0) {\n+            return s;\n         }\n-        final char[] buffer = str.toCharArray();\n-        boolean uncapitalizeNext = true;\n-        for (int i = 0; i < buffer.length; ++i) {\n-            final char ch = buffer[i];\n-            if (isDelimiter(ch, delimiters)) {\n-                uncapitalizeNext = true;\n+        final char[] charArray = s.toCharArray();\n+        int n2 = 1;\n+        for (int i = 0; i < charArray.length; ++i) {\n+            final char ch = charArray[i];\n+            if (isDelimiter(ch, array)) {\n+                n2 = 1;\n             }\n-            else if (uncapitalizeNext) {\n-                buffer[i] = Character.toLowerCase(ch);\n-                uncapitalizeNext = false;\n+            else if (n2 != 0) {\n+                charArray[i] = Character.toLowerCase(ch);\n+                n2 = 0;\n             }\n         }\n-        return new String(buffer);\n+        return new String(charArray);\n     }\n     \n-    public static String swapCase(final String str) {\n-        if (StringUtils.isEmpty((CharSequence)str)) {\n-            return str;\n+    public static String swapCase(final String s) {\n+        if (StringUtils.isEmpty((CharSequence)s)) {\n+            return s;\n         }\n-        final char[] buffer = str.toCharArray();\n-        boolean whitespace = true;\n-        for (int i = 0; i < buffer.length; ++i) {\n-            final char ch = buffer[i];\n+        final char[] charArray = s.toCharArray();\n+        int whitespace = 1;\n+        for (int i = 0; i < charArray.length; ++i) {\n+            final char ch = charArray[i];\n             if (Character.isUpperCase(ch) || Character.isTitleCase(ch)) {\n-                buffer[i] = Character.toLowerCase(ch);\n-                whitespace = false;\n+                charArray[i] = Character.toLowerCase(ch);\n+                whitespace = 0;\n             }\n             else if (Character.isLowerCase(ch)) {\n-                if (whitespace) {\n-                    buffer[i] = Character.toTitleCase(ch);\n-                    whitespace = false;\n+                if (whitespace != 0) {\n+                    charArray[i] = Character.toTitleCase(ch);\n+                    whitespace = 0;\n                 }\n                 else {\n-                    buffer[i] = Character.toUpperCase(ch);\n+                    charArray[i] = Character.toUpperCase(ch);\n                 }\n             }\n             else {\n-                whitespace = Character.isWhitespace(ch);\n+                whitespace = (Character.isWhitespace(ch) ? 1 : 0);\n             }\n         }\n-        return new String(buffer);\n+        return new String(charArray);\n     }\n     \n-    public static String initials(final String str) {\n-        return initials(str, (char[])null);\n+    public static String initials(final String s) {\n+        return initials(s, (char[])null);\n     }\n     \n-    public static String initials(final String str, final char... delimiters) {\n-        if (StringUtils.isEmpty((CharSequence)str)) {\n-            return str;\n+    public static String initials(final String s, final char... array) {\n+        if (StringUtils.isEmpty((CharSequence)s)) {\n+            return s;\n         }\n-        if (delimiters != null && delimiters.length == 0) {\n+        if (array != null && array.length == 0) {\n             return \"\";\n         }\n-        final int strLen = str.length();\n-        final char[] buf = new char[strLen / 2 + 1];\n+        final int length = s.length();\n+        final char[] value = new char[length / 2 + 1];\n         int count = 0;\n-        boolean lastWasGap = true;\n-        for (int i = 0; i < strLen; ++i) {\n-            final char ch = str.charAt(i);\n-            if (isDelimiter(ch, delimiters)) {\n-                lastWasGap = true;\n+        int n = 1;\n+        for (int i = 0; i < length; ++i) {\n+            final char char1 = s.charAt(i);\n+            if (isDelimiter(char1, array)) {\n+                n = 1;\n             }\n-            else if (lastWasGap) {\n-                buf[count++] = ch;\n-                lastWasGap = false;\n+            else if (n != 0) {\n+                value[count++] = char1;\n+                n = 0;\n             }\n         }\n-        return new String(buf, 0, count);\n+        return new String(value, 0, count);\n     }\n     \n-    public static boolean containsAllWords(final CharSequence word, final CharSequence... words) {\n-        if (StringUtils.isEmpty(word) || ArrayUtils.isEmpty((Object[])words)) {\n+    public static boolean containsAllWords(final CharSequence input, final CharSequence... array) {\n+        if (StringUtils.isEmpty(input) || ArrayUtils.isEmpty((Object[])array)) {\n             return false;\n         }\n-        for (final CharSequence w : words) {\n-            if (StringUtils.isBlank(w)) {\n+        for (final CharSequence obj : array) {\n+            if (StringUtils.isBlank(obj)) {\n                 return false;\n             }\n-            final Pattern p = Pattern.compile(\".*\\\\b\" + (Object)w + \"\\\\b.*\");\n-            if (!p.matcher(word).matches()) {\n+            if (!Pattern.compile(\".*\\\\b\" + (Object)obj + \"\\\\b.*\").matcher(input).matches()) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    private static boolean isDelimiter(final char ch, final char[] delimiters) {\n-        if (delimiters == null) {\n+    private static boolean isDelimiter(final char ch, final char[] array) {\n+        if (array == null) {\n             return Character.isWhitespace(ch);\n         }\n-        for (final char delimiter : delimiters) {\n-            if (ch == delimiter) {\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            if (ch == array[i]) {\n                 return true;\n             }\n         }\n         return false;\n     }\n }\n"}]}
