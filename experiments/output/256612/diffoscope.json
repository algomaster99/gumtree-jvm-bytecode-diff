{"diffoscope-json-version": 1, "source1": "first/SegmentUtils.class", "source2": "second/SegmentUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,102 +1,101 @@\n \n package org.apache.commons.compress.harmony.unpack200;\n \n public final class SegmentUtils\n {\n-    public static int countArgs(final String descriptor) {\n-        return countArgs(descriptor, 1);\n+    public static int countArgs(final String s) {\n+        return countArgs(s, 1);\n     }\n     \n-    public static int countInvokeInterfaceArgs(final String descriptor) {\n-        return countArgs(descriptor, 2);\n+    public static int countInvokeInterfaceArgs(final String s) {\n+        return countArgs(s, 2);\n     }\n     \n-    protected static int countArgs(final String descriptor, final int widthOfLongsAndDoubles) {\n-        final int bra = descriptor.indexOf(40);\n-        final int ket = descriptor.indexOf(41);\n-        if (bra == -1 || ket == -1 || ket < bra) {\n+    protected static int countArgs(final String s, final int n) {\n+        final int index = s.indexOf(40);\n+        final int index2 = s.indexOf(41);\n+        if (index == -1 || index2 == -1 || index2 < index) {\n             throw new IllegalArgumentException(\"No arguments\");\n         }\n-        boolean inType = false;\n-        boolean consumingNextType = false;\n-        int count = 0;\n-        for (int i = bra + 1; i < ket; ++i) {\n-            final char charAt = descriptor.charAt(i);\n-            if (inType && charAt == ';') {\n-                inType = false;\n-                consumingNextType = false;\n-            }\n-            else if (!inType && charAt == 'L') {\n-                inType = true;\n-                ++count;\n-            }\n-            else if (charAt == '[') {\n-                consumingNextType = true;\n-            }\n-            else if (!inType) {\n-                if (consumingNextType) {\n-                    ++count;\n-                    consumingNextType = false;\n+        int n2 = 0;\n+        int n3 = 0;\n+        int n4 = 0;\n+        for (int i = index + 1; i < index2; ++i) {\n+            final char char1 = s.charAt(i);\n+            if (n2 != 0 && char1 == ';') {\n+                n2 = 0;\n+                n3 = 0;\n+            }\n+            else if (n2 == 0 && char1 == 'L') {\n+                n2 = 1;\n+                ++n4;\n+            }\n+            else if (char1 == '[') {\n+                n3 = 1;\n+            }\n+            else if (n2 == 0) {\n+                if (n3 != 0) {\n+                    ++n4;\n+                    n3 = 0;\n                 }\n-                else if (charAt == 'D' || charAt == 'J') {\n-                    count += widthOfLongsAndDoubles;\n+                else if (char1 == 'D' || char1 == 'J') {\n+                    n4 += n;\n                 }\n                 else {\n-                    ++count;\n+                    ++n4;\n                 }\n             }\n         }\n-        return count;\n+        return n4;\n     }\n     \n-    public static int countMatches(final long[] flags, final IMatcher matcher) {\n-        int count = 0;\n-        for (final long flag : flags) {\n-            if (matcher.matches(flag)) {\n-                ++count;\n+    public static int countMatches(final long[] array, final IMatcher matcher) {\n+        int n = 0;\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            if (matcher.matches(array[i])) {\n+                ++n;\n             }\n         }\n-        return count;\n+        return n;\n     }\n     \n-    public static int countBit16(final int[] flags) {\n-        int count = 0;\n-        for (final int flag : flags) {\n-            if ((flag & 0x10000) != 0x0) {\n-                ++count;\n+    public static int countBit16(final int[] array) {\n+        int n = 0;\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            if ((array[i] & 0x10000) != 0x0) {\n+                ++n;\n             }\n         }\n-        return count;\n+        return n;\n     }\n     \n-    public static int countBit16(final long[] flags) {\n-        int count = 0;\n-        for (final long flag : flags) {\n-            if ((flag & 0x10000L) != 0x0L) {\n-                ++count;\n+    public static int countBit16(final long[] array) {\n+        int n = 0;\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            if ((array[i] & 0x10000L) != 0x0L) {\n+                ++n;\n             }\n         }\n-        return count;\n+        return n;\n     }\n     \n-    public static int countBit16(final long[][] flags) {\n-        int count = 0;\n-        for (final long[] array : flags) {\n-            final long[] flag = array;\n-            for (final long element : array) {\n-                if ((element & 0x10000L) != 0x0L) {\n-                    ++count;\n+    public static int countBit16(final long[][] array) {\n+        int n = 0;\n+        for (final long[] array2 : array) {\n+            for (int length2 = array2.length, j = 0; j < length2; ++j) {\n+                if ((array2[j] & 0x10000L) != 0x0L) {\n+                    ++n;\n                 }\n             }\n         }\n-        return count;\n+        return n;\n     }\n     \n-    public static int countMatches(final long[][] flags, final IMatcher matcher) {\n-        int count = 0;\n-        for (final long[] flag : flags) {\n-            count += countMatches(flag, matcher);\n+    public static int countMatches(final long[][] array, final IMatcher matcher) {\n+        int n = 0;\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            n += countMatches(array[i], matcher);\n         }\n-        return count;\n+        return n;\n     }\n }\n"}]}
