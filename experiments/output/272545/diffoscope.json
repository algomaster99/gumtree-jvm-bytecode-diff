{"diffoscope-json-version": 1, "source1": "first/AvoidEscapedUnicodeCharactersCheck.class", "source2": "second/AvoidEscapedUnicodeCharactersCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,11 +1,10 @@\n \n package com.puppycrawl.tools.checkstyle.checks;\n \n-import java.util.regex.Matcher;\n import com.puppycrawl.tools.checkstyle.utils.CodePointUtil;\n import java.util.Arrays;\n import com.puppycrawl.tools.checkstyle.utils.CheckUtil;\n import com.puppycrawl.tools.checkstyle.api.DetailAST;\n import java.util.List;\n import com.puppycrawl.tools.checkstyle.api.TextBlock;\n import java.util.Map;\n@@ -25,100 +24,94 @@\n     private Map<Integer, TextBlock> singlelineComments;\n     private Map<Integer, List<TextBlock>> blockComments;\n     private boolean allowEscapesForControlCharacters;\n     private boolean allowByTailComment;\n     private boolean allowIfAllCharactersEscaped;\n     private boolean allowNonPrintableEscapes;\n     \n-    public final void setAllowEscapesForControlCharacters(final boolean allow) {\n-        this.allowEscapesForControlCharacters = allow;\n+    public final void setAllowEscapesForControlCharacters(final boolean allowEscapesForControlCharacters) {\n+        this.allowEscapesForControlCharacters = allowEscapesForControlCharacters;\n     }\n     \n-    public final void setAllowByTailComment(final boolean allow) {\n-        this.allowByTailComment = allow;\n+    public final void setAllowByTailComment(final boolean allowByTailComment) {\n+        this.allowByTailComment = allowByTailComment;\n     }\n     \n-    public final void setAllowIfAllCharactersEscaped(final boolean allow) {\n-        this.allowIfAllCharactersEscaped = allow;\n+    public final void setAllowIfAllCharactersEscaped(final boolean allowIfAllCharactersEscaped) {\n+        this.allowIfAllCharactersEscaped = allowIfAllCharactersEscaped;\n     }\n     \n-    public final void setAllowNonPrintableEscapes(final boolean allow) {\n-        this.allowNonPrintableEscapes = allow;\n+    public final void setAllowNonPrintableEscapes(final boolean allowNonPrintableEscapes) {\n+        this.allowNonPrintableEscapes = allowNonPrintableEscapes;\n     }\n     \n     public int[] getDefaultTokens() {\n         return this.getRequiredTokens();\n     }\n     \n     public int[] getAcceptableTokens() {\n         return this.getRequiredTokens();\n     }\n     \n     public int[] getRequiredTokens() {\n         return new int[] { 139, 138, 205 };\n     }\n     \n-    public void beginTree(final DetailAST rootAST) {\n+    public void beginTree(final DetailAST detailAST) {\n         this.singlelineComments = this.getFileContents().getSingleLineComments();\n         this.blockComments = this.getFileContents().getBlockComments();\n     }\n     \n-    public void visitToken(final DetailAST ast) {\n-        final String literal = CheckUtil.stripIndentAndInitialNewLineFromTextBlock(ast.getText());\n-        if (hasUnicodeChar(literal) && (!this.allowByTailComment || !this.hasTrailComment(ast)) && !this.isAllCharactersEscaped(literal) && (!this.allowEscapesForControlCharacters || !isOnlyUnicodeValidChars(literal, AvoidEscapedUnicodeCharactersCheck.UNICODE_CONTROL)) && (!this.allowNonPrintableEscapes || !isOnlyUnicodeValidChars(literal, AvoidEscapedUnicodeCharactersCheck.NON_PRINTABLE_CHARS))) {\n-            this.log(ast, \"forbid.escaped.unicode.char\", new Object[0]);\n+    public void visitToken(final DetailAST detailAST) {\n+        final String stripIndentAndInitialNewLineFromTextBlock = CheckUtil.stripIndentAndInitialNewLineFromTextBlock(detailAST.getText());\n+        if (hasUnicodeChar(stripIndentAndInitialNewLineFromTextBlock) && (!this.allowByTailComment || !this.hasTrailComment(detailAST)) && !this.isAllCharactersEscaped(stripIndentAndInitialNewLineFromTextBlock) && (!this.allowEscapesForControlCharacters || !isOnlyUnicodeValidChars(stripIndentAndInitialNewLineFromTextBlock, AvoidEscapedUnicodeCharactersCheck.UNICODE_CONTROL)) && (!this.allowNonPrintableEscapes || !isOnlyUnicodeValidChars(stripIndentAndInitialNewLineFromTextBlock, AvoidEscapedUnicodeCharactersCheck.NON_PRINTABLE_CHARS))) {\n+            this.log(detailAST, \"forbid.escaped.unicode.char\", new Object[0]);\n         }\n     }\n     \n-    private static boolean hasUnicodeChar(final String literal) {\n-        final String literalWithoutEscapedBackslashes = AvoidEscapedUnicodeCharactersCheck.ESCAPED_BACKSLASH.matcher(literal).replaceAll(\"\");\n-        return AvoidEscapedUnicodeCharactersCheck.UNICODE_REGEXP.matcher(literalWithoutEscapedBackslashes).find();\n+    private static boolean hasUnicodeChar(final String input) {\n+        return AvoidEscapedUnicodeCharactersCheck.UNICODE_REGEXP.matcher(AvoidEscapedUnicodeCharactersCheck.ESCAPED_BACKSLASH.matcher(input).replaceAll(\"\")).find();\n     }\n     \n-    private static boolean isOnlyUnicodeValidChars(final String literal, final Pattern pattern) {\n-        final int unicodeMatchesCounter = countMatches(AvoidEscapedUnicodeCharactersCheck.UNICODE_REGEXP, literal);\n-        final int unicodeValidMatchesCounter = countMatches(pattern, literal);\n-        return unicodeMatchesCounter - unicodeValidMatchesCounter == 0;\n+    private static boolean isOnlyUnicodeValidChars(final String s, final Pattern pattern) {\n+        return countMatches(AvoidEscapedUnicodeCharactersCheck.UNICODE_REGEXP, s) - countMatches(pattern, s) == 0;\n     }\n     \n-    private boolean hasTrailComment(final DetailAST ast) {\n-        int lineNo = ast.getLineNo();\n-        if (ast.getType() == 205) {\n-            lineNo = ast.getNextSibling().getLineNo();\n+    private boolean hasTrailComment(final DetailAST detailAST) {\n+        int n = detailAST.getLineNo();\n+        if (detailAST.getType() == 205) {\n+            n = detailAST.getNextSibling().getLineNo();\n         }\n-        boolean result = false;\n-        if (this.singlelineComments.containsKey(Integer.valueOf(lineNo))) {\n-            result = true;\n+        boolean trailingBlockComment = false;\n+        if (this.singlelineComments.containsKey(Integer.valueOf(n))) {\n+            trailingBlockComment = true;\n         }\n         else {\n-            final List<TextBlock> commentList = (List<TextBlock>)this.blockComments.get(Integer.valueOf(lineNo));\n-            if (commentList != null) {\n-                final TextBlock comment = (TextBlock)commentList.get(commentList.size() - 1);\n-                final int[] codePoints = this.getLineCodePoints(lineNo - 1);\n-                result = isTrailingBlockComment(comment, codePoints);\n+            final List list = (List)this.blockComments.get(Integer.valueOf(n));\n+            if (list != null) {\n+                trailingBlockComment = isTrailingBlockComment((TextBlock)list.get(list.size() - 1), this.getLineCodePoints(n - 1));\n             }\n         }\n-        return result;\n+        return trailingBlockComment;\n     }\n     \n-    private static boolean isTrailingBlockComment(final TextBlock comment, final int... codePoints) {\n-        return comment.getText().length != 1 || CodePointUtil.isBlank(Arrays.copyOfRange(codePoints, comment.getEndColNo() + 1, codePoints.length));\n+    private static boolean isTrailingBlockComment(final TextBlock textBlock, final int... original) {\n+        return textBlock.getText().length != 1 || CodePointUtil.isBlank(Arrays.copyOfRange(original, textBlock.getEndColNo() + 1, original.length));\n     }\n     \n-    private static int countMatches(final Pattern pattern, final String target) {\n-        int matcherCounter = 0;\n-        final Matcher matcher = pattern.matcher(target);\n-        while (matcher.find()) {\n-            ++matcherCounter;\n+    private static int countMatches(final Pattern pattern, final String input) {\n+        int n = 0;\n+        while (pattern.matcher(input).find()) {\n+            ++n;\n         }\n-        return matcherCounter;\n+        return n;\n     }\n     \n-    private boolean isAllCharactersEscaped(final String literal) {\n-        return this.allowIfAllCharactersEscaped && AvoidEscapedUnicodeCharactersCheck.ALL_ESCAPED_CHARS.matcher(literal).find();\n+    private boolean isAllCharactersEscaped(final String input) {\n+        return this.allowIfAllCharactersEscaped && AvoidEscapedUnicodeCharactersCheck.ALL_ESCAPED_CHARS.matcher(input).find();\n     }\n     \n     static {\n         UNICODE_REGEXP = Pattern.compile(\"\\\\\\\\u+[a-fA-F\\\\d]{4}\");\n         UNICODE_CONTROL = Pattern.compile(\"\\\\\\\\u+(00[0-1][\\\\dA-Fa-f]|00[8-9][\\\\dA-Fa-f]|00[aA][dD]|034[fF]|070[fF]|180[eE]|200[b-fB-F]|202[a-eA-E]|206[0-4a-fA-F]|[fF]{3}[9a-bA-B]|[fF][eE][fF]{2})\");\n         ALL_ESCAPED_CHARS = Pattern.compile(\"^(\" + AvoidEscapedUnicodeCharactersCheck.UNICODE_REGEXP.pattern() + \"|\\\"|'|\\\\\\\\|\\\\\\\\b|\\\\\\\\f|\\\\\\\\n|\\\\R|\\\\\\\\r|\\\\\\\\s|\\\\\\\\t)+$\");\n         ESCAPED_BACKSLASH = Pattern.compile(\"\\\\\\\\\\\\\\\\\");\n"}]}
