{"diffoscope-json-version": 1, "source1": "first/Validate.class", "source2": "second/Validate.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -26,308 +26,306 @@\n     private static final String DEFAULT_VALID_INDEX_ARRAY_EX_MESSAGE = \"The validated array index is invalid: %d\";\n     private static final String DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE = \"The validated character sequence index is invalid: %d\";\n     private static final String DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE = \"The validated collection index is invalid: %d\";\n     private static final String DEFAULT_VALID_STATE_EX_MESSAGE = \"The validated state is false\";\n     private static final String DEFAULT_IS_ASSIGNABLE_EX_MESSAGE = \"Cannot assign a %s to a %s\";\n     private static final String DEFAULT_IS_INSTANCE_OF_EX_MESSAGE = \"Expected type: %s, actual: %s\";\n     \n-    public static void isTrue(final boolean expression, final String message, final long value) {\n-        if (!expression) {\n-            throw new IllegalArgumentException(String.format(message, Long.valueOf(value)));\n+    public static void isTrue(final boolean b, final String format, final long l) {\n+        if (!b) {\n+            throw new IllegalArgumentException(String.format(format, Long.valueOf(l)));\n         }\n     }\n     \n-    public static void isTrue(final boolean expression, final String message, final double value) {\n-        if (!expression) {\n-            throw new IllegalArgumentException(String.format(message, Double.valueOf(value)));\n+    public static void isTrue(final boolean b, final String format, final double d) {\n+        if (!b) {\n+            throw new IllegalArgumentException(String.format(format, Double.valueOf(d)));\n         }\n     }\n     \n-    public static void isTrue(final boolean expression, final String message, final Object... values) {\n-        if (!expression) {\n-            throw new IllegalArgumentException(String.format(message, values));\n+    public static void isTrue(final boolean b, final String format, final Object... args) {\n+        if (!b) {\n+            throw new IllegalArgumentException(String.format(format, args));\n         }\n     }\n     \n-    public static void isTrue(final boolean expression) {\n-        if (!expression) {\n+    public static void isTrue(final boolean b) {\n+        if (!b) {\n             throw new IllegalArgumentException(\"The validated expression is false\");\n         }\n     }\n     \n-    public static <T> T notNull(final T object) {\n-        return notNull(object, \"The validated object is null\", new Object[0]);\n+    public static <T> T notNull(final T t) {\n+        return notNull(t, \"The validated object is null\", new Object[0]);\n     }\n     \n-    public static <T> T notNull(final T object, final String message, final Object... values) {\n-        return Objects.requireNonNull(object, () -> String.format(message, values));\n+    public static <T> T notNull(final T obj, final String s, final Object... array) {\n+        return Objects.requireNonNull(obj, () -> String.format(format, args));\n     }\n     \n-    public static <T> T[] notEmpty(final T[] array, final String message, final Object... values) {\n-        Objects.requireNonNull(array, () -> String.format(message, values));\n-        if (array.length == 0) {\n-            throw new IllegalArgumentException(String.format(message, values));\n+    public static <T> T[] notEmpty(final T[] obj, final String format, final Object... args) {\n+        Objects.requireNonNull(obj, () -> String.format(format2, args2));\n+        if (obj.length == 0) {\n+            throw new IllegalArgumentException(String.format(format, args));\n         }\n-        return array;\n+        return obj;\n     }\n     \n     public static <T> T[] notEmpty(final T[] array) {\n         return notEmpty(array, \"The validated array is empty\", new Object[0]);\n     }\n     \n-    public static <T extends Collection<?>> T notEmpty(final T collection, final String message, final Object... values) {\n-        Objects.requireNonNull(collection, () -> String.format(message, values));\n-        if (collection.isEmpty()) {\n-            throw new IllegalArgumentException(String.format(message, values));\n+    public static <T extends Collection<?>> T notEmpty(final T obj, final String format, final Object... args) {\n+        Objects.requireNonNull(obj, () -> String.format(format2, args2));\n+        if (obj.isEmpty()) {\n+            throw new IllegalArgumentException(String.format(format, args));\n         }\n-        return collection;\n+        return obj;\n     }\n     \n-    public static <T extends Collection<?>> T notEmpty(final T collection) {\n-        return notEmpty(collection, \"The validated collection is empty\", new Object[0]);\n+    public static <T extends Collection<?>> T notEmpty(final T t) {\n+        return notEmpty(t, \"The validated collection is empty\", new Object[0]);\n     }\n     \n-    public static <T extends Map<?, ?>> T notEmpty(final T map, final String message, final Object... values) {\n-        Objects.requireNonNull(map, () -> String.format(message, values));\n-        if (map.isEmpty()) {\n-            throw new IllegalArgumentException(String.format(message, values));\n+    public static <T extends Map<?, ?>> T notEmpty(final T obj, final String format, final Object... args) {\n+        Objects.requireNonNull(obj, () -> String.format(format2, args2));\n+        if (obj.isEmpty()) {\n+            throw new IllegalArgumentException(String.format(format, args));\n         }\n-        return map;\n+        return obj;\n     }\n     \n-    public static <T extends Map<?, ?>> T notEmpty(final T map) {\n-        return notEmpty(map, \"The validated map is empty\", new Object[0]);\n+    public static <T extends Map<?, ?>> T notEmpty(final T t) {\n+        return notEmpty(t, \"The validated map is empty\", new Object[0]);\n     }\n     \n-    public static <T extends CharSequence> T notEmpty(final T chars, final String message, final Object... values) {\n-        Objects.requireNonNull(chars, () -> String.format(message, values));\n-        if (chars.length() == 0) {\n-            throw new IllegalArgumentException(String.format(message, values));\n+    public static <T extends CharSequence> T notEmpty(final T obj, final String format, final Object... args) {\n+        Objects.requireNonNull(obj, () -> String.format(format2, args2));\n+        if (obj.length() == 0) {\n+            throw new IllegalArgumentException(String.format(format, args));\n         }\n-        return chars;\n+        return obj;\n     }\n     \n-    public static <T extends CharSequence> T notEmpty(final T chars) {\n-        return notEmpty(chars, \"The validated character sequence is empty\", new Object[0]);\n+    public static <T extends CharSequence> T notEmpty(final T t) {\n+        return notEmpty(t, \"The validated character sequence is empty\", new Object[0]);\n     }\n     \n-    public static <T extends CharSequence> T notBlank(final T chars, final String message, final Object... values) {\n-        Objects.requireNonNull(chars, () -> String.format(message, values));\n-        if (StringUtils.isBlank((CharSequence)chars)) {\n-            throw new IllegalArgumentException(String.format(message, values));\n+    public static <T extends CharSequence> T notBlank(final T obj, final String format, final Object... args) {\n+        Objects.requireNonNull(obj, () -> String.format(format2, args2));\n+        if (StringUtils.isBlank((CharSequence)obj)) {\n+            throw new IllegalArgumentException(String.format(format, args));\n         }\n-        return chars;\n+        return obj;\n     }\n     \n-    public static <T extends CharSequence> T notBlank(final T chars) {\n-        return notBlank(chars, \"The validated character sequence is blank\", new Object[0]);\n+    public static <T extends CharSequence> T notBlank(final T t) {\n+        return notBlank(t, \"The validated character sequence is blank\", new Object[0]);\n     }\n     \n-    public static <T> T[] noNullElements(final T[] array, final String message, final Object... values) {\n+    public static <T> T[] noNullElements(final T[] array, final String format, final Object... array2) {\n         notNull(array);\n         for (int i = 0; i < array.length; ++i) {\n             if (array[i] == null) {\n-                final Object[] values2 = ArrayUtils.add(values, (Object)Integer.valueOf(i));\n-                throw new IllegalArgumentException(String.format(message, values2));\n+                throw new IllegalArgumentException(String.format(format, ArrayUtils.add(array2, (Object)Integer.valueOf(i))));\n             }\n         }\n         return array;\n     }\n     \n     public static <T> T[] noNullElements(final T[] array) {\n         return noNullElements(array, \"The validated array contains null element at index: %d\", new Object[0]);\n     }\n     \n-    public static <T extends Iterable<?>> T noNullElements(final T iterable, final String message, final Object... values) {\n-        notNull(iterable);\n+    public static <T extends Iterable<?>> T noNullElements(final T t, final String format, final Object... array) {\n+        notNull(t);\n         int i = 0;\n-        final Iterator<?> it = iterable.iterator();\n-        while (it.hasNext()) {\n-            if (it.next() == null) {\n-                final Object[] values2 = ArrayUtils.addAll(values, new Object[] { Integer.valueOf(i) });\n-                throw new IllegalArgumentException(String.format(message, values2));\n+        final Iterator<?> iterator = t.iterator();\n+        while (iterator.hasNext()) {\n+            if (iterator.next() == null) {\n+                throw new IllegalArgumentException(String.format(format, ArrayUtils.addAll(array, new Object[] { Integer.valueOf(i) })));\n             }\n             ++i;\n         }\n-        return iterable;\n+        return t;\n     }\n     \n-    public static <T extends Iterable<?>> T noNullElements(final T iterable) {\n-        return noNullElements(iterable, \"The validated collection contains null element at index: %d\", new Object[0]);\n+    public static <T extends Iterable<?>> T noNullElements(final T t) {\n+        return noNullElements(t, \"The validated collection contains null element at index: %d\", new Object[0]);\n     }\n     \n-    public static <T> T[] validIndex(final T[] array, final int index, final String message, final Object... values) {\n+    public static <T> T[] validIndex(final T[] array, final int n, final String format, final Object... args) {\n         notNull(array);\n-        if (index < 0 || index >= array.length) {\n-            throw new IndexOutOfBoundsException(String.format(message, values));\n+        if (n < 0 || n >= array.length) {\n+            throw new IndexOutOfBoundsException(String.format(format, args));\n         }\n         return array;\n     }\n     \n-    public static <T> T[] validIndex(final T[] array, final int index) {\n-        return validIndex(array, index, \"The validated array index is invalid: %d\", new Object[] { Integer.valueOf(index) });\n+    public static <T> T[] validIndex(final T[] array, final int i) {\n+        return validIndex(array, i, \"The validated array index is invalid: %d\", new Object[] { Integer.valueOf(i) });\n     }\n     \n-    public static <T extends Collection<?>> T validIndex(final T collection, final int index, final String message, final Object... values) {\n-        notNull(collection);\n-        if (index < 0 || index >= collection.size()) {\n-            throw new IndexOutOfBoundsException(String.format(message, values));\n+    public static <T extends Collection<?>> T validIndex(final T t, final int n, final String format, final Object... args) {\n+        notNull(t);\n+        if (n < 0 || n >= t.size()) {\n+            throw new IndexOutOfBoundsException(String.format(format, args));\n         }\n-        return collection;\n+        return t;\n     }\n     \n-    public static <T extends Collection<?>> T validIndex(final T collection, final int index) {\n-        return validIndex(collection, index, \"The validated collection index is invalid: %d\", new Object[] { Integer.valueOf(index) });\n+    public static <T extends Collection<?>> T validIndex(final T t, final int i) {\n+        return validIndex(t, i, \"The validated collection index is invalid: %d\", new Object[] { Integer.valueOf(i) });\n     }\n     \n-    public static <T extends CharSequence> T validIndex(final T chars, final int index, final String message, final Object... values) {\n-        notNull(chars);\n-        if (index < 0 || index >= chars.length()) {\n-            throw new IndexOutOfBoundsException(String.format(message, values));\n+    public static <T extends CharSequence> T validIndex(final T t, final int n, final String format, final Object... args) {\n+        notNull(t);\n+        if (n < 0 || n >= t.length()) {\n+            throw new IndexOutOfBoundsException(String.format(format, args));\n         }\n-        return chars;\n+        return t;\n     }\n     \n-    public static <T extends CharSequence> T validIndex(final T chars, final int index) {\n-        return validIndex(chars, index, \"The validated character sequence index is invalid: %d\", new Object[] { Integer.valueOf(index) });\n+    public static <T extends CharSequence> T validIndex(final T t, final int i) {\n+        return validIndex(t, i, \"The validated character sequence index is invalid: %d\", new Object[] { Integer.valueOf(i) });\n     }\n     \n-    public static void validState(final boolean expression) {\n-        if (!expression) {\n+    public static void validState(final boolean b) {\n+        if (!b) {\n             throw new IllegalStateException(\"The validated state is false\");\n         }\n     }\n     \n-    public static void validState(final boolean expression, final String message, final Object... values) {\n-        if (!expression) {\n-            throw new IllegalStateException(String.format(message, values));\n+    public static void validState(final boolean b, final String format, final Object... args) {\n+        if (!b) {\n+            throw new IllegalStateException(String.format(format, args));\n         }\n     }\n     \n-    public static void matchesPattern(final CharSequence input, final String pattern) {\n-        if (!Pattern.matches(pattern, input)) {\n-            throw new IllegalArgumentException(String.format(\"The string %s does not match the pattern %s\", input, pattern));\n+    public static void matchesPattern(final CharSequence input, final String regex) {\n+        if (!Pattern.matches(regex, input)) {\n+            throw new IllegalArgumentException(String.format(\"The string %s does not match the pattern %s\", input, regex));\n         }\n     }\n     \n-    public static void matchesPattern(final CharSequence input, final String pattern, final String message, final Object... values) {\n-        if (!Pattern.matches(pattern, input)) {\n-            throw new IllegalArgumentException(String.format(message, values));\n+    public static void matchesPattern(final CharSequence input, final String regex, final String format, final Object... args) {\n+        if (!Pattern.matches(regex, input)) {\n+            throw new IllegalArgumentException(String.format(format, args));\n         }\n     }\n     \n-    public static void notNaN(final double value) {\n-        notNaN(value, \"The validated value is not a number\", new Object[0]);\n+    public static void notNaN(final double n) {\n+        notNaN(n, \"The validated value is not a number\", new Object[0]);\n     }\n     \n-    public static void notNaN(final double value, final String message, final Object... values) {\n-        if (Double.isNaN(value)) {\n-            throw new IllegalArgumentException(String.format(message, values));\n+    public static void notNaN(final double v, final String format, final Object... args) {\n+        if (Double.isNaN(v)) {\n+            throw new IllegalArgumentException(String.format(format, args));\n         }\n     }\n     \n-    public static void finite(final double value) {\n-        finite(value, \"The value is invalid: %f\", Double.valueOf(value));\n+    public static void finite(final double d) {\n+        finite(d, \"The value is invalid: %f\", Double.valueOf(d));\n     }\n     \n-    public static void finite(final double value, final String message, final Object... values) {\n-        if (Double.isNaN(value) || Double.isInfinite(value)) {\n-            throw new IllegalArgumentException(String.format(message, values));\n+    public static void finite(final double n, final String format, final Object... args) {\n+        if (Double.isNaN(n) || Double.isInfinite(n)) {\n+            throw new IllegalArgumentException(String.format(format, args));\n         }\n     }\n     \n-    public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value) {\n-        if (value.compareTo(start) < 0 || value.compareTo(end) > 0) {\n-            throw new IllegalArgumentException(String.format(\"The value %s is not in the specified inclusive range of %s to %s\", value, start, end));\n+    public static <T> void inclusiveBetween(final T t, final T t2, final Comparable<T> comparable) {\n+        if (comparable.compareTo(t) < 0 || comparable.compareTo(t2) > 0) {\n+            throw new IllegalArgumentException(String.format(\"The value %s is not in the specified inclusive range of %s to %s\", comparable, t, t2));\n         }\n     }\n     \n-    public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) {\n-        if (value.compareTo(start) < 0 || value.compareTo(end) > 0) {\n-            throw new IllegalArgumentException(String.format(message, values));\n+    public static <T> void inclusiveBetween(final T t, final T t2, final Comparable<T> comparable, final String format, final Object... args) {\n+        if (comparable.compareTo(t) < 0 || comparable.compareTo(t2) > 0) {\n+            throw new IllegalArgumentException(String.format(format, args));\n         }\n     }\n     \n-    public static void inclusiveBetween(final long start, final long end, final long value) {\n-        if (value < start || value > end) {\n-            throw new IllegalArgumentException(String.format(\"The value %s is not in the specified inclusive range of %s to %s\", Long.valueOf(value), Long.valueOf(start), Long.valueOf(end)));\n+    public static void inclusiveBetween(final long l, final long i, final long j) {\n+        if (j < l || j > i) {\n+            throw new IllegalArgumentException(String.format(\"The value %s is not in the specified inclusive range of %s to %s\", Long.valueOf(j), Long.valueOf(l), Long.valueOf(i)));\n         }\n     }\n     \n-    public static void inclusiveBetween(final long start, final long end, final long value, final String message) {\n-        if (value < start || value > end) {\n-            throw new IllegalArgumentException(message);\n+    public static void inclusiveBetween(final long n, final long n2, final long n3, final String s) {\n+        if (n3 < n || n3 > n2) {\n+            throw new IllegalArgumentException(s);\n         }\n     }\n     \n-    public static void inclusiveBetween(final double start, final double end, final double value) {\n-        if (value < start || value > end) {\n-            throw new IllegalArgumentException(String.format(\"The value %s is not in the specified inclusive range of %s to %s\", Double.valueOf(value), Double.valueOf(start), Double.valueOf(end)));\n+    public static void inclusiveBetween(final double d, final double d2, final double d3) {\n+        if (d3 < d || d3 > d2) {\n+            throw new IllegalArgumentException(String.format(\"The value %s is not in the specified inclusive range of %s to %s\", Double.valueOf(d3), Double.valueOf(d), Double.valueOf(d2)));\n         }\n     }\n     \n-    public static void inclusiveBetween(final double start, final double end, final double value, final String message) {\n-        if (value < start || value > end) {\n-            throw new IllegalArgumentException(message);\n+    public static void inclusiveBetween(final double n, final double n2, final double n3, final String s) {\n+        if (n3 < n || n3 > n2) {\n+            throw new IllegalArgumentException(s);\n         }\n     }\n     \n-    public static <T> void exclusiveBetween(final T start, final T end, final Comparable<T> value) {\n-        if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) {\n-            throw new IllegalArgumentException(String.format(\"The value %s is not in the specified exclusive range of %s to %s\", value, start, end));\n+    public static <T> void exclusiveBetween(final T t, final T t2, final Comparable<T> comparable) {\n+        if (comparable.compareTo(t) <= 0 || comparable.compareTo(t2) >= 0) {\n+            throw new IllegalArgumentException(String.format(\"The value %s is not in the specified exclusive range of %s to %s\", comparable, t, t2));\n         }\n     }\n     \n-    public static <T> void exclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) {\n-        if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) {\n-            throw new IllegalArgumentException(String.format(message, values));\n+    public static <T> void exclusiveBetween(final T t, final T t2, final Comparable<T> comparable, final String format, final Object... args) {\n+        if (comparable.compareTo(t) <= 0 || comparable.compareTo(t2) >= 0) {\n+            throw new IllegalArgumentException(String.format(format, args));\n         }\n     }\n     \n-    public static void exclusiveBetween(final long start, final long end, final long value) {\n-        if (value <= start || value >= end) {\n-            throw new IllegalArgumentException(String.format(\"The value %s is not in the specified exclusive range of %s to %s\", Long.valueOf(value), Long.valueOf(start), Long.valueOf(end)));\n+    public static void exclusiveBetween(final long l, final long i, final long j) {\n+        if (j <= l || j >= i) {\n+            throw new IllegalArgumentException(String.format(\"The value %s is not in the specified exclusive range of %s to %s\", Long.valueOf(j), Long.valueOf(l), Long.valueOf(i)));\n         }\n     }\n     \n-    public static void exclusiveBetween(final long start, final long end, final long value, final String message) {\n-        if (value <= start || value >= end) {\n-            throw new IllegalArgumentException(message);\n+    public static void exclusiveBetween(final long n, final long n2, final long n3, final String s) {\n+        if (n3 <= n || n3 >= n2) {\n+            throw new IllegalArgumentException(s);\n         }\n     }\n     \n-    public static void exclusiveBetween(final double start, final double end, final double value) {\n-        if (value <= start || value >= end) {\n-            throw new IllegalArgumentException(String.format(\"The value %s is not in the specified exclusive range of %s to %s\", Double.valueOf(value), Double.valueOf(start), Double.valueOf(end)));\n+    public static void exclusiveBetween(final double d, final double d2, final double d3) {\n+        if (d3 <= d || d3 >= d2) {\n+            throw new IllegalArgumentException(String.format(\"The value %s is not in the specified exclusive range of %s to %s\", Double.valueOf(d3), Double.valueOf(d), Double.valueOf(d2)));\n         }\n     }\n     \n-    public static void exclusiveBetween(final double start, final double end, final double value, final String message) {\n-        if (value <= start || value >= end) {\n-            throw new IllegalArgumentException(message);\n+    public static void exclusiveBetween(final double n, final double n2, final double n3, final String s) {\n+        if (n3 <= n || n3 >= n2) {\n+            throw new IllegalArgumentException(s);\n         }\n     }\n     \n-    public static void isInstanceOf(final Class<?> type, final Object obj) {\n-        if (!type.isInstance(obj)) {\n-            throw new IllegalArgumentException(String.format(\"Expected type: %s, actual: %s\", type.getName(), (obj == null) ? \"null\" : obj.getClass().getName()));\n+    public static void isInstanceOf(final Class<?> clazz, final Object o) {\n+        if (!clazz.isInstance(o)) {\n+            throw new IllegalArgumentException(String.format(\"Expected type: %s, actual: %s\", clazz.getName(), (o == null) ? \"null\" : o.getClass().getName()));\n         }\n     }\n     \n-    public static void isInstanceOf(final Class<?> type, final Object obj, final String message, final Object... values) {\n-        if (!type.isInstance(obj)) {\n-            throw new IllegalArgumentException(String.format(message, values));\n+    public static void isInstanceOf(final Class<?> clazz, final Object o, final String format, final Object... args) {\n+        if (!clazz.isInstance(o)) {\n+            throw new IllegalArgumentException(String.format(format, args));\n         }\n     }\n     \n-    public static void isAssignableFrom(final Class<?> superType, final Class<?> type) {\n-        if (!superType.isAssignableFrom(type)) {\n-            throw new IllegalArgumentException(String.format(\"Cannot assign a %s to a %s\", (type == null) ? \"null\" : type.getName(), superType.getName()));\n+    public static void isAssignableFrom(final Class<?> clazz, final Class<?> clazz2) {\n+        if (!clazz.isAssignableFrom(clazz2)) {\n+            throw new IllegalArgumentException(String.format(\"Cannot assign a %s to a %s\", (clazz2 == null) ? \"null\" : clazz2.getName(), clazz.getName()));\n         }\n     }\n     \n-    public static void isAssignableFrom(final Class<?> superType, final Class<?> type, final String message, final Object... values) {\n-        if (!superType.isAssignableFrom(type)) {\n-            throw new IllegalArgumentException(String.format(message, values));\n+    public static void isAssignableFrom(final Class<?> clazz, final Class<?> clazz2, final String format, final Object... args) {\n+        if (!clazz.isAssignableFrom(clazz2)) {\n+            throw new IllegalArgumentException(String.format(format, args));\n         }\n     }\n }\n"}]}
