{"diffoscope-json-version": 1, "source1": "first/FileUtils.class", "source2": "second/FileUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,15 +1,14 @@\n \n package org.apache.commons.io;\n \n import java.io.BufferedOutputStream;\n import java.nio.file.FileVisitOption;\n import org.apache.commons.io.filefilter.SuffixFileFilter;\n import org.apache.commons.io.filefilter.FileFileFilter;\n-import java.io.FileOutputStream;\n import java.io.FileInputStream;\n import java.util.stream.Collector;\n import java.util.stream.Collectors;\n import java.util.function.Function;\n import java.nio.file.FileVisitor;\n import java.util.Collections;\n import org.apache.commons.io.file.PathFilter;\n@@ -33,20 +32,21 @@\n import org.apache.commons.io.file.StandardDeleteOption;\n import org.apache.commons.io.file.DeleteOption;\n import org.apache.commons.io.file.PathUtils;\n import java.nio.charset.StandardCharsets;\n import java.nio.ByteBuffer;\n import java.net.URLConnection;\n import java.net.URL;\n+import java.io.FileOutputStream;\n import java.util.Iterator;\n import java.io.FileNotFoundException;\n import java.io.OutputStream;\n import java.util.Collection;\n-import java.io.Reader;\n import java.nio.charset.Charset;\n+import java.io.Reader;\n import java.io.InputStreamReader;\n import java.util.List;\n import java.util.ArrayList;\n import java.io.FileFilter;\n import java.util.zip.CRC32;\n import java.io.IOException;\n import java.io.InputStream;\n@@ -75,350 +75,362 @@\n     public static final BigInteger ONE_PB_BI;\n     public static final long ONE_EB = 1152921504606846976L;\n     public static final BigInteger ONE_EB_BI;\n     public static final BigInteger ONE_ZB;\n     public static final BigInteger ONE_YB;\n     public static final File[] EMPTY_FILE_ARRAY;\n     \n-    private static CopyOption[] addCopyAttributes(final CopyOption... copyOptions) {\n-        final CopyOption[] actual = (CopyOption[])Arrays.copyOf(copyOptions, copyOptions.length + 1);\n-        Arrays.sort(actual, 0, copyOptions.length);\n-        if (Arrays.binarySearch(copyOptions, 0, copyOptions.length, StandardCopyOption.COPY_ATTRIBUTES) >= 0) {\n-            return copyOptions;\n+    private static CopyOption[] addCopyAttributes(final CopyOption... array) {\n+        final CopyOption[] a = (CopyOption[])Arrays.copyOf(array, array.length + 1);\n+        Arrays.sort(a, 0, array.length);\n+        if (Arrays.binarySearch(array, 0, array.length, StandardCopyOption.COPY_ATTRIBUTES) >= 0) {\n+            return array;\n         }\n-        actual[actual.length - 1] = StandardCopyOption.COPY_ATTRIBUTES;\n-        return actual;\n+        a[a.length - 1] = StandardCopyOption.COPY_ATTRIBUTES;\n+        return a;\n     }\n     \n-    public static String byteCountToDisplaySize(final BigInteger size) {\n-        Objects.requireNonNull(size, \"size\");\n-        String displaySize;\n-        if (size.divide(FileUtils.ONE_EB_BI).compareTo(BigInteger.ZERO) > 0) {\n-            displaySize = size.divide(FileUtils.ONE_EB_BI) + \" EB\";\n+    public static String byteCountToDisplaySize(final BigInteger bigInteger) {\n+        Objects.requireNonNull(bigInteger, \"size\");\n+        String s;\n+        if (bigInteger.divide(FileUtils.ONE_EB_BI).compareTo(BigInteger.ZERO) > 0) {\n+            s = bigInteger.divide(FileUtils.ONE_EB_BI) + \" EB\";\n         }\n-        else if (size.divide(FileUtils.ONE_PB_BI).compareTo(BigInteger.ZERO) > 0) {\n-            displaySize = size.divide(FileUtils.ONE_PB_BI) + \" PB\";\n+        else if (bigInteger.divide(FileUtils.ONE_PB_BI).compareTo(BigInteger.ZERO) > 0) {\n+            s = bigInteger.divide(FileUtils.ONE_PB_BI) + \" PB\";\n         }\n-        else if (size.divide(FileUtils.ONE_TB_BI).compareTo(BigInteger.ZERO) > 0) {\n-            displaySize = size.divide(FileUtils.ONE_TB_BI) + \" TB\";\n+        else if (bigInteger.divide(FileUtils.ONE_TB_BI).compareTo(BigInteger.ZERO) > 0) {\n+            s = bigInteger.divide(FileUtils.ONE_TB_BI) + \" TB\";\n         }\n-        else if (size.divide(FileUtils.ONE_GB_BI).compareTo(BigInteger.ZERO) > 0) {\n-            displaySize = size.divide(FileUtils.ONE_GB_BI) + \" GB\";\n+        else if (bigInteger.divide(FileUtils.ONE_GB_BI).compareTo(BigInteger.ZERO) > 0) {\n+            s = bigInteger.divide(FileUtils.ONE_GB_BI) + \" GB\";\n         }\n-        else if (size.divide(FileUtils.ONE_MB_BI).compareTo(BigInteger.ZERO) > 0) {\n-            displaySize = size.divide(FileUtils.ONE_MB_BI) + \" MB\";\n+        else if (bigInteger.divide(FileUtils.ONE_MB_BI).compareTo(BigInteger.ZERO) > 0) {\n+            s = bigInteger.divide(FileUtils.ONE_MB_BI) + \" MB\";\n         }\n-        else if (size.divide(FileUtils.ONE_KB_BI).compareTo(BigInteger.ZERO) > 0) {\n-            displaySize = size.divide(FileUtils.ONE_KB_BI) + \" KB\";\n+        else if (bigInteger.divide(FileUtils.ONE_KB_BI).compareTo(BigInteger.ZERO) > 0) {\n+            s = bigInteger.divide(FileUtils.ONE_KB_BI) + \" KB\";\n         }\n         else {\n-            displaySize = size + \" bytes\";\n+            s = bigInteger + \" bytes\";\n         }\n-        return displaySize;\n+        return s;\n     }\n     \n-    public static String byteCountToDisplaySize(final long size) {\n-        return byteCountToDisplaySize(BigInteger.valueOf(size));\n+    public static String byteCountToDisplaySize(final long val) {\n+        return byteCountToDisplaySize(BigInteger.valueOf(val));\n     }\n     \n     public static Checksum checksum(final File file, final Checksum checksum) throws IOException {\n         requireExistsChecked(file, \"file\");\n         requireFile(file, \"file\");\n         Objects.requireNonNull(checksum, \"checksum\");\n-        try (final InputStream inputStream = new CheckedInputStream(Files.newInputStream(file.toPath(), new OpenOption[0]), checksum)) {\n-            IOUtils.consume(inputStream);\n+        try (final CheckedInputStream checkedInputStream = new CheckedInputStream(Files.newInputStream(file.toPath(), new OpenOption[0]), checksum)) {\n+            IOUtils.consume((InputStream)checkedInputStream);\n         }\n         return checksum;\n     }\n     \n     public static long checksumCRC32(final File file) throws IOException {\n         return checksum(file, new CRC32()).getValue();\n     }\n     \n-    public static void cleanDirectory(final File directory) throws IOException {\n-        final File[] files = listFiles(directory, null);\n-        final List<Exception> causeList = new ArrayList<Exception>();\n-        for (final File file : files) {\n+    public static void cleanDirectory(final File file) throws IOException {\n+        final File[] listFiles = listFiles(file, null);\n+        final ArrayList list = new ArrayList();\n+        for (final File file2 : listFiles) {\n             try {\n-                forceDelete(file);\n+                forceDelete(file2);\n             }\n-            catch (final IOException ioe) {\n-                causeList.add(ioe);\n+            catch (final IOException ex) {\n+                list.add(ex);\n             }\n         }\n-        if (!causeList.isEmpty()) {\n-            throw new IOExceptionList(directory.toString(), (List)causeList);\n+        if (!list.isEmpty()) {\n+            throw new IOExceptionList(file.toString(), (List)list);\n         }\n     }\n     \n-    private static void cleanDirectoryOnExit(final File directory) throws IOException {\n-        final File[] files = listFiles(directory, null);\n-        final List<Exception> causeList = new ArrayList<Exception>();\n-        for (final File file : files) {\n+    private static void cleanDirectoryOnExit(final File file) throws IOException {\n+        final File[] listFiles = listFiles(file, null);\n+        final ArrayList list = new ArrayList();\n+        for (final File file2 : listFiles) {\n             try {\n-                forceDeleteOnExit(file);\n+                forceDeleteOnExit(file2);\n             }\n-            catch (final IOException ioe) {\n-                causeList.add(ioe);\n+            catch (final IOException ex) {\n+                list.add(ex);\n             }\n         }\n-        if (!causeList.isEmpty()) {\n-            throw new IOExceptionList((List)causeList);\n+        if (!list.isEmpty()) {\n+            throw new IOExceptionList((List)list);\n         }\n     }\n     \n-    public static boolean contentEquals(final File file1, final File file2) throws IOException {\n-        if (file1 == null && file2 == null) {\n+    public static boolean contentEquals(final File file, final File file2) throws IOException {\n+        if (file == null && file2 == null) {\n             return true;\n         }\n-        if (file1 == null || file2 == null) {\n+        if (file == null || file2 == null) {\n             return false;\n         }\n-        final boolean file1Exists = file1.exists();\n-        if (file1Exists != file2.exists()) {\n+        final boolean exists = file.exists();\n+        if (exists != file2.exists()) {\n             return false;\n         }\n-        if (!file1Exists) {\n+        if (!exists) {\n             return true;\n         }\n-        requireFile(file1, \"file1\");\n+        requireFile(file, \"file1\");\n         requireFile(file2, \"file2\");\n-        if (file1.length() != file2.length()) {\n+        if (file.length() != file2.length()) {\n             return false;\n         }\n-        if (file1.getCanonicalFile().equals(file2.getCanonicalFile())) {\n+        if (file.getCanonicalFile().equals(file2.getCanonicalFile())) {\n             return true;\n         }\n-        try (final InputStream input1 = Files.newInputStream(file1.toPath(), new OpenOption[0]);\n-             final InputStream input2 = Files.newInputStream(file2.toPath(), new OpenOption[0])) {\n-            return IOUtils.contentEquals(input1, input2);\n+        try (final InputStream inputStream = Files.newInputStream(file.toPath(), new OpenOption[0]);\n+             final InputStream inputStream2 = Files.newInputStream(file2.toPath(), new OpenOption[0])) {\n+            return IOUtils.contentEquals(inputStream, inputStream2);\n         }\n     }\n     \n-    public static boolean contentEqualsIgnoreEOL(final File file1, final File file2, final String charsetName) throws IOException {\n-        if (file1 == null && file2 == null) {\n+    public static boolean contentEqualsIgnoreEOL(final File file, final File file2, final String s) throws IOException {\n+        if (file == null && file2 == null) {\n             return true;\n         }\n-        if (file1 == null || file2 == null) {\n+        if (file == null || file2 == null) {\n             return false;\n         }\n-        final boolean file1Exists = file1.exists();\n-        if (file1Exists != file2.exists()) {\n+        final boolean exists = file.exists();\n+        if (exists != file2.exists()) {\n             return false;\n         }\n-        if (!file1Exists) {\n+        if (!exists) {\n             return true;\n         }\n-        requireFile(file1, \"file1\");\n+        requireFile(file, \"file1\");\n         requireFile(file2, \"file2\");\n-        if (file1.getCanonicalFile().equals(file2.getCanonicalFile())) {\n+        if (file.getCanonicalFile().equals(file2.getCanonicalFile())) {\n             return true;\n         }\n-        final Charset charset = Charsets.toCharset(charsetName);\n-        try (final Reader input1 = new InputStreamReader(Files.newInputStream(file1.toPath(), new OpenOption[0]), charset);\n-             final Reader input2 = new InputStreamReader(Files.newInputStream(file2.toPath(), new OpenOption[0]), charset)) {\n-            return IOUtils.contentEqualsIgnoreEOL(input1, input2);\n+        final Charset charset = Charsets.toCharset(s);\n+        try (final InputStreamReader inputStreamReader = new InputStreamReader(Files.newInputStream(file.toPath(), new OpenOption[0]), charset);\n+             final InputStreamReader inputStreamReader2 = new InputStreamReader(Files.newInputStream(file2.toPath(), new OpenOption[0]), charset)) {\n+            return IOUtils.contentEqualsIgnoreEOL((Reader)inputStreamReader, (Reader)inputStreamReader2);\n         }\n     }\n     \n-    public static File[] convertFileCollectionToFileArray(final Collection<File> files) {\n-        return files.toArray(FileUtils.EMPTY_FILE_ARRAY);\n+    public static File[] convertFileCollectionToFileArray(final Collection<File> collection) {\n+        return collection.toArray(FileUtils.EMPTY_FILE_ARRAY);\n     }\n     \n-    public static void copyDirectory(final File srcDir, final File destDir) throws IOException {\n-        copyDirectory(srcDir, destDir, true);\n+    public static void copyDirectory(final File file, final File file2) throws IOException {\n+        copyDirectory(file, file2, true);\n     }\n     \n-    public static void copyDirectory(final File srcDir, final File destDir, final boolean preserveFileDate) throws IOException {\n-        copyDirectory(srcDir, destDir, null, preserveFileDate);\n+    public static void copyDirectory(final File file, final File file2, final boolean b) throws IOException {\n+        copyDirectory(file, file2, null, b);\n     }\n     \n-    public static void copyDirectory(final File srcDir, final File destDir, final FileFilter filter) throws IOException {\n-        copyDirectory(srcDir, destDir, filter, true);\n+    public static void copyDirectory(final File file, final File file2, final FileFilter fileFilter) throws IOException {\n+        copyDirectory(file, file2, fileFilter, true);\n     }\n     \n-    public static void copyDirectory(final File srcDir, final File destDir, final FileFilter filter, final boolean preserveFileDate) throws IOException {\n-        copyDirectory(srcDir, destDir, filter, preserveFileDate, StandardCopyOption.REPLACE_EXISTING);\n+    public static void copyDirectory(final File file, final File file2, final FileFilter fileFilter, final boolean b) throws IOException {\n+        copyDirectory(file, file2, fileFilter, b, StandardCopyOption.REPLACE_EXISTING);\n     }\n     \n-    public static void copyDirectory(final File srcDir, final File destDir, final FileFilter fileFilter, final boolean preserveFileDate, final CopyOption... copyOptions) throws IOException {\n-        requireFileCopy(srcDir, destDir);\n-        requireDirectory(srcDir, \"srcDir\");\n-        requireCanonicalPathsNotEquals(srcDir, destDir);\n-        List<String> exclusionList = null;\n-        final String srcDirCanonicalPath = srcDir.getCanonicalPath();\n-        final String destDirCanonicalPath = destDir.getCanonicalPath();\n-        if (destDirCanonicalPath.startsWith(srcDirCanonicalPath)) {\n-            final File[] srcFiles = listFiles(srcDir, fileFilter);\n-            if (srcFiles.length > 0) {\n-                exclusionList = new ArrayList<String>(srcFiles.length);\n-                for (final File srcFile : srcFiles) {\n-                    final File copiedFile = new File(destDir, srcFile.getName());\n-                    exclusionList.add(copiedFile.getCanonicalPath());\n+    public static void copyDirectory(final File file, final File parent, final FileFilter fileFilter, final boolean b, final CopyOption... array) throws IOException {\n+        requireFileCopy(file, parent);\n+        requireDirectory(file, \"srcDir\");\n+        requireCanonicalPathsNotEquals(file, parent);\n+        List list = null;\n+        if (parent.getCanonicalPath().startsWith(file.getCanonicalPath())) {\n+            final File[] listFiles = listFiles(file, fileFilter);\n+            if (listFiles.length > 0) {\n+                list = new ArrayList(listFiles.length);\n+                final File[] array2 = listFiles;\n+                for (int length = array2.length, i = 0; i < length; ++i) {\n+                    list.add(new File(parent, array2[i].getName()).getCanonicalPath());\n                 }\n             }\n         }\n-        doCopyDirectory(srcDir, destDir, fileFilter, exclusionList, preserveFileDate, preserveFileDate ? addCopyAttributes(copyOptions) : copyOptions);\n+        doCopyDirectory(file, parent, fileFilter, list, b, b ? addCopyAttributes(array) : array);\n     }\n     \n-    public static void copyDirectoryToDirectory(final File sourceDir, final File destinationDir) throws IOException {\n-        requireDirectoryIfExists(sourceDir, \"sourceDir\");\n-        requireDirectoryIfExists(destinationDir, \"destinationDir\");\n-        copyDirectory(sourceDir, new File(destinationDir, sourceDir.getName()), true);\n+    public static void copyDirectoryToDirectory(final File file, final File parent) throws IOException {\n+        requireDirectoryIfExists(file, \"sourceDir\");\n+        requireDirectoryIfExists(parent, \"destinationDir\");\n+        copyDirectory(file, new File(parent, file.getName()), true);\n     }\n     \n-    public static void copyFile(final File srcFile, final File destFile) throws IOException {\n-        copyFile(srcFile, destFile, StandardCopyOption.COPY_ATTRIBUTES, StandardCopyOption.REPLACE_EXISTING);\n+    public static void copyFile(final File file, final File file2) throws IOException {\n+        copyFile(file, file2, StandardCopyOption.COPY_ATTRIBUTES, StandardCopyOption.REPLACE_EXISTING);\n     }\n     \n-    public static void copyFile(final File srcFile, final File destFile, final boolean preserveFileDate) throws IOException {\n-        copyFile(srcFile, destFile, preserveFileDate ? new CopyOption[] { StandardCopyOption.COPY_ATTRIBUTES, StandardCopyOption.REPLACE_EXISTING } : new CopyOption[] { StandardCopyOption.REPLACE_EXISTING });\n+    public static void copyFile(final File file, final File file2, final boolean b) throws IOException {\n+        copyFile(file, file2, b ? new CopyOption[] { StandardCopyOption.COPY_ATTRIBUTES, StandardCopyOption.REPLACE_EXISTING } : new CopyOption[] { StandardCopyOption.REPLACE_EXISTING });\n     }\n     \n-    public static void copyFile(final File srcFile, final File destFile, final boolean preserveFileDate, final CopyOption... copyOptions) throws IOException {\n-        copyFile(srcFile, destFile, preserveFileDate ? addCopyAttributes(copyOptions) : copyOptions);\n+    public static void copyFile(final File file, final File file2, final boolean b, final CopyOption... array) throws IOException {\n+        copyFile(file, file2, b ? addCopyAttributes(array) : array);\n     }\n     \n-    public static void copyFile(final File srcFile, final File destFile, final CopyOption... copyOptions) throws IOException {\n-        requireFileCopy(srcFile, destFile);\n-        requireFile(srcFile, \"srcFile\");\n-        requireCanonicalPathsNotEquals(srcFile, destFile);\n-        createParentDirectories(destFile);\n-        requireFileIfExists(destFile, \"destFile\");\n-        if (destFile.exists()) {\n-            requireCanWrite(destFile, \"destFile\");\n+    public static void copyFile(final File file, final File file2, final CopyOption... options) throws IOException {\n+        requireFileCopy(file, file2);\n+        requireFile(file, \"srcFile\");\n+        requireCanonicalPathsNotEquals(file, file2);\n+        createParentDirectories(file2);\n+        requireFileIfExists(file2, \"destFile\");\n+        if (file2.exists()) {\n+            requireCanWrite(file2, \"destFile\");\n         }\n-        Files.copy(srcFile.toPath(), destFile.toPath(), copyOptions);\n-        requireEqualSizes(srcFile, destFile, srcFile.length(), destFile.length());\n+        Files.copy(file.toPath(), file2.toPath(), options);\n+        requireEqualSizes(file, file2, file.length(), file2.length());\n     }\n     \n-    public static long copyFile(final File input, final OutputStream output) throws IOException {\n-        try (final InputStream fis = Files.newInputStream(input.toPath(), new OpenOption[0])) {\n-            return IOUtils.copyLarge(fis, output);\n+    public static long copyFile(final File file, final OutputStream outputStream) throws IOException {\n+        try (final InputStream inputStream = Files.newInputStream(file.toPath(), new OpenOption[0])) {\n+            return IOUtils.copyLarge(inputStream, outputStream);\n         }\n     }\n     \n-    public static void copyFileToDirectory(final File srcFile, final File destDir) throws IOException {\n-        copyFileToDirectory(srcFile, destDir, true);\n+    public static void copyFileToDirectory(final File file, final File file2) throws IOException {\n+        copyFileToDirectory(file, file2, true);\n     }\n     \n-    public static void copyFileToDirectory(final File sourceFile, final File destinationDir, final boolean preserveFileDate) throws IOException {\n-        Objects.requireNonNull(sourceFile, \"sourceFile\");\n-        requireDirectoryIfExists(destinationDir, \"destinationDir\");\n-        copyFile(sourceFile, new File(destinationDir, sourceFile.getName()), preserveFileDate);\n+    public static void copyFileToDirectory(final File obj, final File parent, final boolean b) throws IOException {\n+        Objects.requireNonNull(obj, \"sourceFile\");\n+        requireDirectoryIfExists(parent, \"destinationDir\");\n+        copyFile(obj, new File(parent, obj.getName()), b);\n     }\n     \n-    public static void copyInputStreamToFile(final InputStream source, final File destination) throws IOException {\n-        try (final InputStream inputStream = source) {\n-            copyToFile(inputStream, destination);\n+    public static void copyInputStreamToFile(final InputStream inputStream, final File file) throws IOException {\n+        try {\n+            copyToFile(inputStream, file);\n+            if (inputStream != null) {\n+                inputStream.close();\n+            }\n+        }\n+        catch (final Throwable t) {\n+            if (inputStream != null) {\n+                try {\n+                    inputStream.close();\n+                }\n+                catch (final Throwable exception) {\n+                    t.addSuppressed(exception);\n+                }\n+            }\n+            throw t;\n         }\n     }\n     \n-    public static void copyToDirectory(final File sourceFile, final File destinationDir) throws IOException {\n-        Objects.requireNonNull(sourceFile, \"sourceFile\");\n-        if (sourceFile.isFile()) {\n-            copyFileToDirectory(sourceFile, destinationDir);\n+    public static void copyToDirectory(final File file, final File file2) throws IOException {\n+        Objects.requireNonNull(file, \"sourceFile\");\n+        if (file.isFile()) {\n+            copyFileToDirectory(file, file2);\n         }\n         else {\n-            if (!sourceFile.isDirectory()) {\n-                throw new FileNotFoundException(\"The source \" + sourceFile + \" does not exist\");\n+            if (!file.isDirectory()) {\n+                throw new FileNotFoundException(\"The source \" + file + \" does not exist\");\n             }\n-            copyDirectoryToDirectory(sourceFile, destinationDir);\n+            copyDirectoryToDirectory(file, file2);\n         }\n     }\n     \n-    public static void copyToDirectory(final Iterable<File> sourceIterable, final File destinationDir) throws IOException {\n-        Objects.requireNonNull(sourceIterable, \"sourceIterable\");\n-        for (final File src : sourceIterable) {\n-            copyFileToDirectory(src, destinationDir);\n+    public static void copyToDirectory(final Iterable<File> obj, final File file) throws IOException {\n+        Objects.requireNonNull(obj, \"sourceIterable\");\n+        final Iterator<File> iterator = obj.iterator();\n+        while (iterator.hasNext()) {\n+            copyFileToDirectory(iterator.next(), file);\n         }\n     }\n     \n     public static void copyToFile(final InputStream inputStream, final File file) throws IOException {\n-        try (final OutputStream out = openOutputStream(file)) {\n-            IOUtils.copy(inputStream, out);\n+        try (final FileOutputStream openOutputStream = openOutputStream(file)) {\n+            IOUtils.copy(inputStream, (OutputStream)openOutputStream);\n         }\n     }\n     \n-    public static void copyURLToFile(final URL source, final File destination) throws IOException {\n-        try (final InputStream stream = source.openStream()) {\n-            copyInputStreamToFile(stream, destination);\n+    public static void copyURLToFile(final URL url, final File file) throws IOException {\n+        try (final InputStream openStream = url.openStream()) {\n+            copyInputStreamToFile(openStream, file);\n         }\n     }\n     \n-    public static void copyURLToFile(final URL source, final File destination, final int connectionTimeoutMillis, final int readTimeoutMillis) throws IOException {\n-        final URLConnection connection = source.openConnection();\n-        connection.setConnectTimeout(connectionTimeoutMillis);\n-        connection.setReadTimeout(readTimeoutMillis);\n-        try (final InputStream stream = connection.getInputStream()) {\n-            copyInputStreamToFile(stream, destination);\n+    public static void copyURLToFile(final URL url, final File file, final int connectTimeout, final int readTimeout) throws IOException {\n+        final URLConnection openConnection = url.openConnection();\n+        openConnection.setConnectTimeout(connectTimeout);\n+        openConnection.setReadTimeout(readTimeout);\n+        try (final InputStream inputStream = openConnection.getInputStream()) {\n+            copyInputStreamToFile(inputStream, file);\n         }\n     }\n     \n     public static File createParentDirectories(final File file) throws IOException {\n         return mkdirs(getParentFile(file));\n     }\n     \n-    static String decodeUrl(final String url) {\n-        String decoded = url;\n-        if (url != null && url.indexOf(37) >= 0) {\n-            final int n = url.length();\n-            final StringBuilder buffer = new StringBuilder();\n-            final ByteBuffer bytes = ByteBuffer.allocate(n);\n+    static String decodeUrl(final String s) {\n+        String string = s;\n+        if (s != null && s.indexOf(37) >= 0) {\n+            final int length = s.length();\n+            final StringBuilder sb = new StringBuilder();\n+            final ByteBuffer allocate = ByteBuffer.allocate(length);\n             int i = 0;\n-            while (i < n) {\n-                if (url.charAt(i) == '%') {\n+            while (i < length) {\n+                if (s.charAt(i) == '%') {\n                     try {\n                         do {\n-                            final byte octet = (byte)Integer.parseInt(url.substring(i + 1, i + 3), 16);\n-                            bytes.put(octet);\n+                            allocate.put((byte)Integer.parseInt(s.substring(i + 1, i + 3), 16));\n                             i += 3;\n-                        } while (i < n && url.charAt(i) == '%');\n+                        } while (i < length && s.charAt(i) == '%');\n                         continue;\n                     }\n                     catch (final RuntimeException ex) {}\n                     finally {\n-                        if (bytes.position() > 0) {\n-                            bytes.flip();\n-                            buffer.append(StandardCharsets.UTF_8.decode(bytes).toString());\n-                            bytes.clear();\n+                        if (allocate.position() > 0) {\n+                            allocate.flip();\n+                            sb.append(StandardCharsets.UTF_8.decode(allocate).toString());\n+                            allocate.clear();\n                         }\n                     }\n                 }\n-                buffer.append(url.charAt(i++));\n+                sb.append(s.charAt(i++));\n             }\n-            decoded = buffer.toString();\n+            string = sb.toString();\n         }\n-        return decoded;\n+        return string;\n     }\n     \n-    public static File delete(final File file) throws IOException {\n-        Objects.requireNonNull(file, \"file\");\n-        Files.delete(file.toPath());\n-        return file;\n+    public static File delete(final File obj) throws IOException {\n+        Objects.requireNonNull(obj, \"file\");\n+        Files.delete(obj.toPath());\n+        return obj;\n     }\n     \n-    public static void deleteDirectory(final File directory) throws IOException {\n-        Objects.requireNonNull(directory, \"directory\");\n-        if (!directory.exists()) {\n+    public static void deleteDirectory(final File obj) throws IOException {\n+        Objects.requireNonNull(obj, \"directory\");\n+        if (!obj.exists()) {\n             return;\n         }\n-        if (!isSymlink(directory)) {\n-            cleanDirectory(directory);\n+        if (!isSymlink(obj)) {\n+            cleanDirectory(obj);\n         }\n-        delete(directory);\n+        delete(obj);\n     }\n     \n-    private static void deleteDirectoryOnExit(final File directory) throws IOException {\n-        if (!directory.exists()) {\n+    private static void deleteDirectoryOnExit(final File file) throws IOException {\n+        if (!file.exists()) {\n             return;\n         }\n-        directory.deleteOnExit();\n-        if (!isSymlink(directory)) {\n-            cleanDirectoryOnExit(directory);\n+        file.deleteOnExit();\n+        if (!isSymlink(file)) {\n+            cleanDirectoryOnExit(file);\n         }\n     }\n     \n     public static boolean deleteQuietly(final File file) {\n         if (file == null) {\n             return false;\n         }\n@@ -427,104 +439,104 @@\n                 cleanDirectory(file);\n             }\n         }\n         catch (final Exception ex) {}\n         try {\n             return file.delete();\n         }\n-        catch (final Exception ignored) {\n+        catch (final Exception ex2) {\n             return false;\n         }\n     }\n     \n-    public static boolean directoryContains(final File directory, final File child) throws IOException {\n-        requireDirectoryExists(directory, \"directory\");\n-        return child != null && directory.exists() && child.exists() && FilenameUtils.directoryContains(directory.getCanonicalPath(), child.getCanonicalPath());\n+    public static boolean directoryContains(final File file, final File file2) throws IOException {\n+        requireDirectoryExists(file, \"directory\");\n+        return file2 != null && file.exists() && file2.exists() && FilenameUtils.directoryContains(file.getCanonicalPath(), file2.getCanonicalPath());\n     }\n     \n-    private static void doCopyDirectory(final File srcDir, final File destDir, final FileFilter fileFilter, final List<String> exclusionList, final boolean preserveDirDate, final CopyOption... copyOptions) throws IOException {\n-        final File[] srcFiles = listFiles(srcDir, fileFilter);\n-        requireDirectoryIfExists(destDir, \"destDir\");\n-        mkdirs(destDir);\n-        requireCanWrite(destDir, \"destDir\");\n-        for (final File srcFile : srcFiles) {\n-            final File dstFile = new File(destDir, srcFile.getName());\n-            if (exclusionList == null || !exclusionList.contains(srcFile.getCanonicalPath())) {\n-                if (srcFile.isDirectory()) {\n-                    doCopyDirectory(srcFile, dstFile, fileFilter, exclusionList, preserveDirDate, copyOptions);\n+    private static void doCopyDirectory(final File file, final File parent, final FileFilter fileFilter, final List<String> list, final boolean b, final CopyOption... array) throws IOException {\n+        final File[] listFiles = listFiles(file, fileFilter);\n+        requireDirectoryIfExists(parent, \"destDir\");\n+        mkdirs(parent);\n+        requireCanWrite(parent, \"destDir\");\n+        for (final File file2 : listFiles) {\n+            final File file3 = new File(parent, file2.getName());\n+            if (list == null || !list.contains(file2.getCanonicalPath())) {\n+                if (file2.isDirectory()) {\n+                    doCopyDirectory(file2, file3, fileFilter, list, b, array);\n                 }\n                 else {\n-                    copyFile(srcFile, dstFile, copyOptions);\n+                    copyFile(file2, file3, array);\n                 }\n             }\n         }\n-        if (preserveDirDate) {\n-            setLastModified(srcDir, destDir);\n+        if (b) {\n+            setLastModified(file, parent);\n         }\n     }\n     \n-    public static void forceDelete(final File file) throws IOException {\n-        Objects.requireNonNull(file, \"file\");\n-        Counters.PathCounters deleteCounters;\n+    public static void forceDelete(final File obj) throws IOException {\n+        Objects.requireNonNull(obj, \"file\");\n+        Counters.PathCounters delete;\n         try {\n-            deleteCounters = PathUtils.delete(file.toPath(), PathUtils.EMPTY_LINK_OPTION_ARRAY, new DeleteOption[] { (DeleteOption)StandardDeleteOption.OVERRIDE_READ_ONLY });\n+            delete = PathUtils.delete(obj.toPath(), PathUtils.EMPTY_LINK_OPTION_ARRAY, new DeleteOption[] { (DeleteOption)StandardDeleteOption.OVERRIDE_READ_ONLY });\n         }\n-        catch (final IOException e) {\n-            throw new IOException(\"Cannot delete file: \" + file, e);\n+        catch (final IOException cause) {\n+            throw new IOException(\"Cannot delete file: \" + obj, cause);\n         }\n-        if (deleteCounters.getFileCounter().get() < 1L && deleteCounters.getDirectoryCounter().get() < 1L) {\n-            throw new FileNotFoundException(\"File does not exist: \" + file);\n+        if (delete.getFileCounter().get() < 1L && delete.getDirectoryCounter().get() < 1L) {\n+            throw new FileNotFoundException(\"File does not exist: \" + obj);\n         }\n     }\n     \n-    public static void forceDeleteOnExit(final File file) throws IOException {\n-        Objects.requireNonNull(file, \"file\");\n-        if (file.isDirectory()) {\n-            deleteDirectoryOnExit(file);\n+    public static void forceDeleteOnExit(final File obj) throws IOException {\n+        Objects.requireNonNull(obj, \"file\");\n+        if (obj.isDirectory()) {\n+            deleteDirectoryOnExit(obj);\n         }\n         else {\n-            file.deleteOnExit();\n+            obj.deleteOnExit();\n         }\n     }\n     \n-    public static void forceMkdir(final File directory) throws IOException {\n-        mkdirs(directory);\n+    public static void forceMkdir(final File file) throws IOException {\n+        mkdirs(file);\n     }\n     \n-    public static void forceMkdirParent(final File file) throws IOException {\n-        Objects.requireNonNull(file, \"file\");\n-        final File parent = getParentFile(file);\n-        if (parent == null) {\n+    public static void forceMkdirParent(final File obj) throws IOException {\n+        Objects.requireNonNull(obj, \"file\");\n+        final File parentFile = getParentFile(obj);\n+        if (parentFile == null) {\n             return;\n         }\n-        forceMkdir(parent);\n+        forceMkdir(parentFile);\n     }\n     \n-    public static File getFile(final File directory, final String... names) {\n-        Objects.requireNonNull(directory, \"directory\");\n-        Objects.requireNonNull(names, \"names\");\n-        File file = directory;\n-        for (final String name : names) {\n-            file = new File(file, name);\n+    public static File getFile(final File obj, final String... obj2) {\n+        Objects.requireNonNull(obj, \"directory\");\n+        Objects.requireNonNull(obj2, \"names\");\n+        File parent = obj;\n+        for (int length = obj2.length, i = 0; i < length; ++i) {\n+            parent = new File(parent, obj2[i]);\n         }\n-        return file;\n+        return parent;\n     }\n     \n-    public static File getFile(final String... names) {\n-        Objects.requireNonNull(names, \"names\");\n-        File file = null;\n-        for (final String name : names) {\n-            if (file == null) {\n-                file = new File(name);\n+    public static File getFile(final String... obj) {\n+        Objects.requireNonNull(obj, \"names\");\n+        File parent = null;\n+        for (final String s : obj) {\n+            if (parent == null) {\n+                parent = new File(s);\n             }\n             else {\n-                file = new File(file, name);\n+                parent = new File(parent, s);\n             }\n         }\n-        return file;\n+        return parent;\n     }\n     \n     private static File getParentFile(final File file) {\n         return (file == null) ? null : file.getParentFile();\n     }\n     \n     public static File getTempDirectory() {\n@@ -543,286 +555,283 @@\n         return System.getProperty(\"user.home\");\n     }\n     \n     public static boolean isDirectory(final File file, final LinkOption... options) {\n         return file != null && Files.isDirectory(file.toPath(), options);\n     }\n     \n-    public static boolean isEmptyDirectory(final File directory) throws IOException {\n-        return PathUtils.isEmptyDirectory(directory.toPath());\n+    public static boolean isEmptyDirectory(final File file) throws IOException {\n+        return PathUtils.isEmptyDirectory(file.toPath());\n     }\n     \n     public static boolean isFileNewer(final File file, final ChronoLocalDate chronoLocalDate) {\n         return isFileNewer(file, chronoLocalDate, LocalTime.now());\n     }\n     \n-    public static boolean isFileNewer(final File file, final ChronoLocalDate chronoLocalDate, final LocalTime localTime) {\n-        Objects.requireNonNull(chronoLocalDate, \"chronoLocalDate\");\n+    public static boolean isFileNewer(final File file, final ChronoLocalDate obj, final LocalTime localTime) {\n+        Objects.requireNonNull(obj, \"chronoLocalDate\");\n         Objects.requireNonNull(localTime, \"localTime\");\n-        return isFileNewer(file, chronoLocalDate.atTime(localTime));\n+        return isFileNewer(file, obj.atTime(localTime));\n     }\n     \n     public static boolean isFileNewer(final File file, final ChronoLocalDateTime<?> chronoLocalDateTime) {\n         return isFileNewer(file, chronoLocalDateTime, ZoneId.systemDefault());\n     }\n     \n-    public static boolean isFileNewer(final File file, final ChronoLocalDateTime<?> chronoLocalDateTime, final ZoneId zoneId) {\n-        Objects.requireNonNull(chronoLocalDateTime, \"chronoLocalDateTime\");\n-        Objects.requireNonNull(zoneId, \"zoneId\");\n-        return isFileNewer(file, chronoLocalDateTime.atZone(zoneId));\n+    public static boolean isFileNewer(final File file, final ChronoLocalDateTime<?> obj, final ZoneId obj2) {\n+        Objects.requireNonNull(obj, \"chronoLocalDateTime\");\n+        Objects.requireNonNull(obj2, \"zoneId\");\n+        return isFileNewer(file, obj.atZone(obj2));\n     }\n     \n-    public static boolean isFileNewer(final File file, final ChronoZonedDateTime<?> chronoZonedDateTime) {\n-        Objects.requireNonNull(chronoZonedDateTime, \"chronoZonedDateTime\");\n-        return isFileNewer(file, chronoZonedDateTime.toInstant());\n+    public static boolean isFileNewer(final File file, final ChronoZonedDateTime<?> obj) {\n+        Objects.requireNonNull(obj, \"chronoZonedDateTime\");\n+        return isFileNewer(file, obj.toInstant());\n     }\n     \n-    public static boolean isFileNewer(final File file, final Date date) {\n-        Objects.requireNonNull(date, \"date\");\n-        return isFileNewer(file, date.getTime());\n+    public static boolean isFileNewer(final File file, final Date obj) {\n+        Objects.requireNonNull(obj, \"date\");\n+        return isFileNewer(file, obj.getTime());\n     }\n     \n-    public static boolean isFileNewer(final File file, final File reference) {\n-        requireExists(reference, \"reference\");\n-        return isFileNewer(file, lastModifiedUnchecked(reference));\n+    public static boolean isFileNewer(final File file, final File file2) {\n+        requireExists(file2, \"reference\");\n+        return isFileNewer(file, lastModifiedUnchecked(file2));\n     }\n     \n-    public static boolean isFileNewer(final File file, final Instant instant) {\n-        Objects.requireNonNull(instant, \"instant\");\n-        return isFileNewer(file, instant.toEpochMilli());\n+    public static boolean isFileNewer(final File file, final Instant obj) {\n+        Objects.requireNonNull(obj, \"instant\");\n+        return isFileNewer(file, obj.toEpochMilli());\n     }\n     \n-    public static boolean isFileNewer(final File file, final long timeMillis) {\n-        Objects.requireNonNull(file, \"file\");\n-        return file.exists() && lastModifiedUnchecked(file) > timeMillis;\n+    public static boolean isFileNewer(final File obj, final long n) {\n+        Objects.requireNonNull(obj, \"file\");\n+        return obj.exists() && lastModifiedUnchecked(obj) > n;\n     }\n     \n     public static boolean isFileOlder(final File file, final ChronoLocalDate chronoLocalDate) {\n         return isFileOlder(file, chronoLocalDate, LocalTime.now());\n     }\n     \n-    public static boolean isFileOlder(final File file, final ChronoLocalDate chronoLocalDate, final LocalTime localTime) {\n-        Objects.requireNonNull(chronoLocalDate, \"chronoLocalDate\");\n+    public static boolean isFileOlder(final File file, final ChronoLocalDate obj, final LocalTime localTime) {\n+        Objects.requireNonNull(obj, \"chronoLocalDate\");\n         Objects.requireNonNull(localTime, \"localTime\");\n-        return isFileOlder(file, chronoLocalDate.atTime(localTime));\n+        return isFileOlder(file, obj.atTime(localTime));\n     }\n     \n     public static boolean isFileOlder(final File file, final ChronoLocalDateTime<?> chronoLocalDateTime) {\n         return isFileOlder(file, chronoLocalDateTime, ZoneId.systemDefault());\n     }\n     \n-    public static boolean isFileOlder(final File file, final ChronoLocalDateTime<?> chronoLocalDateTime, final ZoneId zoneId) {\n-        Objects.requireNonNull(chronoLocalDateTime, \"chronoLocalDateTime\");\n-        Objects.requireNonNull(zoneId, \"zoneId\");\n-        return isFileOlder(file, chronoLocalDateTime.atZone(zoneId));\n+    public static boolean isFileOlder(final File file, final ChronoLocalDateTime<?> obj, final ZoneId obj2) {\n+        Objects.requireNonNull(obj, \"chronoLocalDateTime\");\n+        Objects.requireNonNull(obj2, \"zoneId\");\n+        return isFileOlder(file, obj.atZone(obj2));\n     }\n     \n-    public static boolean isFileOlder(final File file, final ChronoZonedDateTime<?> chronoZonedDateTime) {\n-        Objects.requireNonNull(chronoZonedDateTime, \"chronoZonedDateTime\");\n-        return isFileOlder(file, chronoZonedDateTime.toInstant());\n+    public static boolean isFileOlder(final File file, final ChronoZonedDateTime<?> obj) {\n+        Objects.requireNonNull(obj, \"chronoZonedDateTime\");\n+        return isFileOlder(file, obj.toInstant());\n     }\n     \n-    public static boolean isFileOlder(final File file, final Date date) {\n-        Objects.requireNonNull(date, \"date\");\n-        return isFileOlder(file, date.getTime());\n+    public static boolean isFileOlder(final File file, final Date obj) {\n+        Objects.requireNonNull(obj, \"date\");\n+        return isFileOlder(file, obj.getTime());\n     }\n     \n-    public static boolean isFileOlder(final File file, final File reference) {\n-        requireExists(reference, \"reference\");\n-        return isFileOlder(file, lastModifiedUnchecked(reference));\n+    public static boolean isFileOlder(final File file, final File file2) {\n+        requireExists(file2, \"reference\");\n+        return isFileOlder(file, lastModifiedUnchecked(file2));\n     }\n     \n-    public static boolean isFileOlder(final File file, final Instant instant) {\n-        Objects.requireNonNull(instant, \"instant\");\n-        return isFileOlder(file, instant.toEpochMilli());\n+    public static boolean isFileOlder(final File file, final Instant obj) {\n+        Objects.requireNonNull(obj, \"instant\");\n+        return isFileOlder(file, obj.toEpochMilli());\n     }\n     \n-    public static boolean isFileOlder(final File file, final long timeMillis) {\n-        Objects.requireNonNull(file, \"file\");\n-        return file.exists() && lastModifiedUnchecked(file) < timeMillis;\n+    public static boolean isFileOlder(final File obj, final long n) {\n+        Objects.requireNonNull(obj, \"file\");\n+        return obj.exists() && lastModifiedUnchecked(obj) < n;\n     }\n     \n     public static boolean isRegularFile(final File file, final LinkOption... options) {\n         return file != null && Files.isRegularFile(file.toPath(), options);\n     }\n     \n     public static boolean isSymlink(final File file) {\n         return file != null && Files.isSymbolicLink(file.toPath());\n     }\n     \n-    public static Iterator<File> iterateFiles(final File directory, final IOFileFilter fileFilter, final IOFileFilter dirFilter) {\n-        return listFiles(directory, fileFilter, dirFilter).iterator();\n+    public static Iterator<File> iterateFiles(final File file, final IOFileFilter ioFileFilter, final IOFileFilter ioFileFilter2) {\n+        return listFiles(file, ioFileFilter, ioFileFilter2).iterator();\n     }\n     \n-    public static Iterator<File> iterateFiles(final File directory, final String[] extensions, final boolean recursive) {\n+    public static Iterator<File> iterateFiles(final File file, final String[] array, final boolean b) {\n         try {\n-            return StreamIterator.iterator((Stream)streamFiles(directory, recursive, extensions));\n+            return StreamIterator.iterator((Stream)streamFiles(file, b, array));\n         }\n-        catch (final IOException e) {\n-            throw new UncheckedIOException(directory.toString(), e);\n+        catch (final IOException cause) {\n+            throw new UncheckedIOException(file.toString(), cause);\n         }\n     }\n     \n-    public static Iterator<File> iterateFilesAndDirs(final File directory, final IOFileFilter fileFilter, final IOFileFilter dirFilter) {\n-        return listFilesAndDirs(directory, fileFilter, dirFilter).iterator();\n+    public static Iterator<File> iterateFilesAndDirs(final File file, final IOFileFilter ioFileFilter, final IOFileFilter ioFileFilter2) {\n+        return listFilesAndDirs(file, ioFileFilter, ioFileFilter2).iterator();\n     }\n     \n     public static long lastModified(final File file) throws IOException {\n         return Files.getLastModifiedTime(Objects.requireNonNull(file.toPath(), \"file\"), new LinkOption[0]).toMillis();\n     }\n     \n     public static long lastModifiedUnchecked(final File file) {\n         try {\n             return lastModified(file);\n         }\n-        catch (final IOException e) {\n-            throw new UncheckedIOException(file.toString(), e);\n+        catch (final IOException cause) {\n+            throw new UncheckedIOException(file.toString(), cause);\n         }\n     }\n     \n     public static LineIterator lineIterator(final File file) throws IOException {\n         return lineIterator(file, null);\n     }\n     \n-    public static LineIterator lineIterator(final File file, final String charsetName) throws IOException {\n-        InputStream inputStream = null;\n+    public static LineIterator lineIterator(final File file, final String s) throws IOException {\n+        InputStream openInputStream = null;\n         try {\n-            inputStream = openInputStream(file);\n-            return IOUtils.lineIterator(inputStream, charsetName);\n+            openInputStream = openInputStream(file);\n+            return IOUtils.lineIterator(openInputStream, s);\n         }\n         catch (final IOException | RuntimeException ex) {\n-            final InputStream inputStream2 = inputStream;\n-            final Exception obj = ex;\n-            Objects.requireNonNull((IOException | RuntimeException)obj);\n-            IOUtils.closeQuietly((Closeable)inputStream2, (Consumer)obj::addSuppressed);\n+            final InputStream inputStream = openInputStream;\n+            final IOException | RuntimeException obj = ex;\n+            Objects.requireNonNull(obj);\n+            IOUtils.closeQuietly((Closeable)inputStream, (Consumer)obj::addSuppressed);\n             throw ex;\n         }\n     }\n     \n-    private static AccumulatorPathVisitor listAccumulate(final File directory, final IOFileFilter fileFilter, final IOFileFilter dirFilter) throws IOException {\n-        final boolean isDirFilterSet = dirFilter != null;\n-        final FileEqualsFileFilter rootDirFilter = new FileEqualsFileFilter(directory);\n-        final PathFilter dirPathFilter = (PathFilter)(isDirFilterSet ? rootDirFilter.or(dirFilter) : rootDirFilter);\n-        final AccumulatorPathVisitor visitor = new AccumulatorPathVisitor(Counters.noopPathCounters(), (PathFilter)fileFilter, dirPathFilter);\n-        Files.walkFileTree(directory.toPath(), Collections.emptySet(), toMaxDepth(isDirFilterSet), (FileVisitor<? super Path>)visitor);\n+    private static AccumulatorPathVisitor listAccumulate(final File file, final IOFileFilter ioFileFilter, final IOFileFilter ioFileFilter2) throws IOException {\n+        final boolean b = ioFileFilter2 != null;\n+        final FileEqualsFileFilter fileEqualsFileFilter = new FileEqualsFileFilter(file);\n+        final AccumulatorPathVisitor visitor = new AccumulatorPathVisitor(Counters.noopPathCounters(), (PathFilter)ioFileFilter, (PathFilter)(b ? fileEqualsFileFilter.or(ioFileFilter2) : fileEqualsFileFilter));\n+        Files.walkFileTree(file.toPath(), Collections.emptySet(), toMaxDepth(b), (FileVisitor<? super Path>)visitor);\n         return visitor;\n     }\n     \n-    private static File[] listFiles(final File directory, final FileFilter fileFilter) throws IOException {\n-        requireDirectoryExists(directory, \"directory\");\n-        final File[] files = (fileFilter == null) ? directory.listFiles() : directory.listFiles(fileFilter);\n-        if (files == null) {\n-            throw new IOException(\"Unknown I/O error listing contents of directory: \" + directory);\n+    private static File[] listFiles(final File obj, final FileFilter filter) throws IOException {\n+        requireDirectoryExists(obj, \"directory\");\n+        final File[] array = (filter == null) ? obj.listFiles() : obj.listFiles(filter);\n+        if (array == null) {\n+            throw new IOException(\"Unknown I/O error listing contents of directory: \" + obj);\n         }\n-        return files;\n+        return array;\n     }\n     \n-    public static Collection<File> listFiles(final File directory, final IOFileFilter fileFilter, final IOFileFilter dirFilter) {\n+    public static Collection<File> listFiles(final File file, final IOFileFilter ioFileFilter, final IOFileFilter ioFileFilter2) {\n         try {\n-            final AccumulatorPathVisitor visitor = listAccumulate(directory, fileFilter, dirFilter);\n-            return (Collection)visitor.getFileList().stream().map(Path::toFile).collect(Collectors.toList());\n+            return (Collection)listAccumulate(file, ioFileFilter, ioFileFilter2).getFileList().stream().map(Path::toFile).collect(Collectors.toList());\n         }\n-        catch (final IOException e) {\n-            throw new UncheckedIOException(directory.toString(), e);\n+        catch (final IOException cause) {\n+            throw new UncheckedIOException(file.toString(), cause);\n         }\n     }\n     \n-    public static Collection<File> listFiles(final File directory, final String[] extensions, final boolean recursive) {\n+    public static Collection<File> listFiles(final File file, final String[] array, final boolean b) {\n         try {\n-            return toList(streamFiles(directory, recursive, extensions));\n+            return toList(streamFiles(file, b, array));\n         }\n-        catch (final IOException e) {\n-            throw new UncheckedIOException(directory.toString(), e);\n+        catch (final IOException cause) {\n+            throw new UncheckedIOException(file.toString(), cause);\n         }\n     }\n     \n-    public static Collection<File> listFilesAndDirs(final File directory, final IOFileFilter fileFilter, final IOFileFilter dirFilter) {\n+    public static Collection<File> listFilesAndDirs(final File file, final IOFileFilter ioFileFilter, final IOFileFilter ioFileFilter2) {\n         try {\n-            final AccumulatorPathVisitor visitor = listAccumulate(directory, fileFilter, dirFilter);\n-            final List<Path> list = visitor.getFileList();\n-            list.addAll(visitor.getDirList());\n-            return list.stream().map((Function<? super Object, ?>)Path::toFile).collect((Collector<? super Object, ?, Collection<File>>)Collectors.toList());\n+            final AccumulatorPathVisitor listAccumulate = listAccumulate(file, ioFileFilter, ioFileFilter2);\n+            final List fileList = listAccumulate.getFileList();\n+            fileList.addAll(listAccumulate.getDirList());\n+            return (Collection)fileList.stream().map(Path::toFile).collect(Collectors.toList());\n         }\n-        catch (final IOException e) {\n-            throw new UncheckedIOException(directory.toString(), e);\n+        catch (final IOException cause) {\n+            throw new UncheckedIOException(file.toString(), cause);\n         }\n     }\n     \n-    private static File mkdirs(final File directory) throws IOException {\n-        if (directory != null && !directory.mkdirs() && !directory.isDirectory()) {\n-            throw new IOException(\"Cannot create directory '\" + directory + \"'.\");\n+    private static File mkdirs(final File obj) throws IOException {\n+        if (obj != null && !obj.mkdirs() && !obj.isDirectory()) {\n+            throw new IOException(\"Cannot create directory '\" + obj + \"'.\");\n         }\n-        return directory;\n+        return obj;\n     }\n     \n-    public static void moveDirectory(final File srcDir, final File destDir) throws IOException {\n-        validateMoveParameters(srcDir, destDir);\n-        requireDirectory(srcDir, \"srcDir\");\n-        requireAbsent(destDir, \"destDir\");\n-        if (!srcDir.renameTo(destDir)) {\n-            if (destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator)) {\n-                throw new IOException(\"Cannot move directory: \" + srcDir + \" to a subdirectory of itself: \" + destDir);\n+    public static void moveDirectory(final File file, final File obj) throws IOException {\n+        validateMoveParameters(file, obj);\n+        requireDirectory(file, \"srcDir\");\n+        requireAbsent(obj, \"destDir\");\n+        if (!file.renameTo(obj)) {\n+            if (obj.getCanonicalPath().startsWith(file.getCanonicalPath() + File.separator)) {\n+                throw new IOException(\"Cannot move directory: \" + file + \" to a subdirectory of itself: \" + obj);\n             }\n-            copyDirectory(srcDir, destDir);\n-            deleteDirectory(srcDir);\n-            if (srcDir.exists()) {\n-                throw new IOException(\"Failed to delete original directory '\" + srcDir + \"' after copy to '\" + destDir + \"'\");\n+            copyDirectory(file, obj);\n+            deleteDirectory(file);\n+            if (file.exists()) {\n+                throw new IOException(\"Failed to delete original directory '\" + file + \"' after copy to '\" + obj + \"'\");\n             }\n         }\n     }\n     \n-    public static void moveDirectoryToDirectory(final File src, final File destDir, final boolean createDestDir) throws IOException {\n-        validateMoveParameters(src, destDir);\n-        if (!destDir.isDirectory()) {\n-            if (destDir.exists()) {\n-                throw new IOException(\"Destination '\" + destDir + \"' is not a directory\");\n+    public static void moveDirectoryToDirectory(final File file, final File parent, final boolean b) throws IOException {\n+        validateMoveParameters(file, parent);\n+        if (!parent.isDirectory()) {\n+            if (parent.exists()) {\n+                throw new IOException(\"Destination '\" + parent + \"' is not a directory\");\n             }\n-            if (!createDestDir) {\n-                throw new FileNotFoundException(\"Destination directory '\" + destDir + \"' does not exist [createDestDir=\" + false + \"]\");\n+            if (!b) {\n+                throw new FileNotFoundException(\"Destination directory '\" + parent + \"' does not exist [createDestDir=\" + false + \"]\");\n             }\n-            mkdirs(destDir);\n+            mkdirs(parent);\n         }\n-        moveDirectory(src, new File(destDir, src.getName()));\n+        moveDirectory(file, new File(parent, file.getName()));\n     }\n     \n-    public static void moveFile(final File srcFile, final File destFile) throws IOException {\n-        moveFile(srcFile, destFile, StandardCopyOption.COPY_ATTRIBUTES);\n+    public static void moveFile(final File file, final File file2) throws IOException {\n+        moveFile(file, file2, StandardCopyOption.COPY_ATTRIBUTES);\n     }\n     \n-    public static void moveFile(final File srcFile, final File destFile, final CopyOption... copyOptions) throws IOException {\n-        validateMoveParameters(srcFile, destFile);\n-        requireFile(srcFile, \"srcFile\");\n-        requireAbsent(destFile, null);\n-        final boolean rename = srcFile.renameTo(destFile);\n-        if (!rename) {\n-            copyFile(srcFile, destFile, copyOptions);\n-            if (!srcFile.delete()) {\n-                deleteQuietly(destFile);\n-                throw new IOException(\"Failed to delete original file '\" + srcFile + \"' after copy to '\" + destFile + \"'\");\n+    public static void moveFile(final File obj, final File file, final CopyOption... array) throws IOException {\n+        validateMoveParameters(obj, file);\n+        requireFile(obj, \"srcFile\");\n+        requireAbsent(file, null);\n+        if (!obj.renameTo(file)) {\n+            copyFile(obj, file, array);\n+            if (!obj.delete()) {\n+                deleteQuietly(file);\n+                throw new IOException(\"Failed to delete original file '\" + obj + \"' after copy to '\" + file + \"'\");\n             }\n         }\n     }\n     \n-    public static void moveFileToDirectory(final File srcFile, final File destDir, final boolean createDestDir) throws IOException {\n-        validateMoveParameters(srcFile, destDir);\n-        if (!destDir.exists() && createDestDir) {\n-            mkdirs(destDir);\n+    public static void moveFileToDirectory(final File file, final File parent, final boolean b) throws IOException {\n+        validateMoveParameters(file, parent);\n+        if (!parent.exists() && b) {\n+            mkdirs(parent);\n         }\n-        requireExistsChecked(destDir, \"destDir\");\n-        requireDirectory(destDir, \"destDir\");\n-        moveFile(srcFile, new File(destDir, srcFile.getName()));\n+        requireExistsChecked(parent, \"destDir\");\n+        requireDirectory(parent, \"destDir\");\n+        moveFile(file, new File(parent, file.getName()));\n     }\n     \n-    public static void moveToDirectory(final File src, final File destDir, final boolean createDestDir) throws IOException {\n-        validateMoveParameters(src, destDir);\n-        if (src.isDirectory()) {\n-            moveDirectoryToDirectory(src, destDir, createDestDir);\n+    public static void moveToDirectory(final File file, final File file2, final boolean b) throws IOException {\n+        validateMoveParameters(file, file2);\n+        if (file.isDirectory()) {\n+            moveDirectoryToDirectory(file, file2, b);\n         }\n         else {\n-            moveFileToDirectory(src, destDir, createDestDir);\n+            moveFileToDirectory(file, file2, b);\n         }\n     }\n     \n     public static FileInputStream openInputStream(final File file) throws IOException {\n         Objects.requireNonNull(file, \"file\");\n         return new FileInputStream(file);\n     }\n@@ -840,413 +849,411 @@\n         else {\n             createParentDirectories(file);\n         }\n         return new FileOutputStream(file, append);\n     }\n     \n     public static byte[] readFileToByteArray(final File file) throws IOException {\n-        try (final InputStream inputStream = openInputStream(file)) {\n-            final long fileLength = file.length();\n-            return (fileLength > 0L) ? IOUtils.toByteArray(inputStream, fileLength) : IOUtils.toByteArray(inputStream);\n+        try (final FileInputStream openInputStream = openInputStream(file)) {\n+            final long length = file.length();\n+            return (length > 0L) ? IOUtils.toByteArray((InputStream)openInputStream, length) : IOUtils.toByteArray((InputStream)openInputStream);\n         }\n     }\n     \n     @Deprecated\n     public static String readFileToString(final File file) throws IOException {\n         return readFileToString(file, Charset.defaultCharset());\n     }\n     \n-    public static String readFileToString(final File file, final Charset charsetName) throws IOException {\n-        try (final InputStream inputStream = openInputStream(file)) {\n-            return IOUtils.toString(inputStream, Charsets.toCharset(charsetName));\n+    public static String readFileToString(final File file, final Charset charset) throws IOException {\n+        try (final FileInputStream openInputStream = openInputStream(file)) {\n+            return IOUtils.toString((InputStream)openInputStream, Charsets.toCharset(charset));\n         }\n     }\n     \n-    public static String readFileToString(final File file, final String charsetName) throws IOException {\n-        return readFileToString(file, Charsets.toCharset(charsetName));\n+    public static String readFileToString(final File file, final String s) throws IOException {\n+        return readFileToString(file, Charsets.toCharset(s));\n     }\n     \n     @Deprecated\n     public static List<String> readLines(final File file) throws IOException {\n         return readLines(file, Charset.defaultCharset());\n     }\n     \n     public static List<String> readLines(final File file, final Charset charset) throws IOException {\n-        try (final InputStream inputStream = openInputStream(file)) {\n-            return IOUtils.readLines(inputStream, Charsets.toCharset(charset));\n+        try (final FileInputStream openInputStream = openInputStream(file)) {\n+            return IOUtils.readLines((InputStream)openInputStream, Charsets.toCharset(charset));\n         }\n     }\n     \n-    public static List<String> readLines(final File file, final String charsetName) throws IOException {\n-        return readLines(file, Charsets.toCharset(charsetName));\n+    public static List<String> readLines(final File file, final String s) throws IOException {\n+        return readLines(file, Charsets.toCharset(s));\n     }\n     \n-    private static void requireAbsent(final File file, final String name) throws FileExistsException {\n+    private static void requireAbsent(final File file, final String s) throws FileExistsException {\n         if (file.exists()) {\n-            throw new FileExistsException(String.format(\"File element in parameter '%s' already exists: '%s'\", name, file));\n+            throw new FileExistsException(String.format(\"File element in parameter '%s' already exists: '%s'\", s, file));\n         }\n     }\n     \n-    private static void requireCanonicalPathsNotEquals(final File file1, final File file2) throws IOException {\n-        final String canonicalPath = file1.getCanonicalPath();\n+    private static void requireCanonicalPathsNotEquals(final File file, final File file2) throws IOException {\n+        final String canonicalPath = file.getCanonicalPath();\n         if (canonicalPath.equals(file2.getCanonicalPath())) {\n-            throw new IllegalArgumentException(String.format(\"File canonical paths are equal: '%s' (file1='%s', file2='%s')\", canonicalPath, file1, file2));\n+            throw new IllegalArgumentException(String.format(\"File canonical paths are equal: '%s' (file1='%s', file2='%s')\", canonicalPath, file, file2));\n         }\n     }\n     \n-    private static void requireCanWrite(final File file, final String name) {\n+    private static void requireCanWrite(final File file, final String str) {\n         Objects.requireNonNull(file, \"file\");\n         if (!file.canWrite()) {\n-            throw new IllegalArgumentException(\"File parameter '\" + name + \" is not writable: '\" + file + \"'\");\n+            throw new IllegalArgumentException(\"File parameter '\" + str + \" is not writable: '\" + file + \"'\");\n         }\n     }\n     \n-    private static File requireDirectory(final File directory, final String name) {\n-        Objects.requireNonNull(directory, name);\n-        if (!directory.isDirectory()) {\n-            throw new IllegalArgumentException(\"Parameter '\" + name + \"' is not a directory: '\" + directory + \"'\");\n+    private static File requireDirectory(final File file, final String s) {\n+        Objects.requireNonNull(file, s);\n+        if (!file.isDirectory()) {\n+            throw new IllegalArgumentException(\"Parameter '\" + s + \"' is not a directory: '\" + file + \"'\");\n         }\n-        return directory;\n+        return file;\n     }\n     \n-    private static File requireDirectoryExists(final File directory, final String name) {\n-        requireExists(directory, name);\n-        requireDirectory(directory, name);\n-        return directory;\n+    private static File requireDirectoryExists(final File file, final String s) {\n+        requireExists(file, s);\n+        requireDirectory(file, s);\n+        return file;\n     }\n     \n-    private static File requireDirectoryIfExists(final File directory, final String name) {\n-        Objects.requireNonNull(directory, name);\n-        if (directory.exists()) {\n-            requireDirectory(directory, name);\n+    private static File requireDirectoryIfExists(final File obj, final String message) {\n+        Objects.requireNonNull(obj, message);\n+        if (obj.exists()) {\n+            requireDirectory(obj, message);\n         }\n-        return directory;\n+        return obj;\n     }\n     \n-    private static void requireEqualSizes(final File srcFile, final File destFile, final long srcLen, final long dstLen) throws IOException {\n-        if (srcLen != dstLen) {\n-            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"' Expected length: \" + srcLen + \" Actual: \" + dstLen);\n+    private static void requireEqualSizes(final File obj, final File obj2, final long lng, final long lng2) throws IOException {\n+        if (lng != lng2) {\n+            throw new IOException(\"Failed to copy full contents from '\" + obj + \"' to '\" + obj2 + \"' Expected length: \" + lng + \" Actual: \" + lng2);\n         }\n     }\n     \n-    private static File requireExists(final File file, final String fileParamName) {\n-        Objects.requireNonNull(file, fileParamName);\n+    private static File requireExists(final File file, final String s) {\n+        Objects.requireNonNull(file, s);\n         if (!file.exists()) {\n-            throw new IllegalArgumentException(\"File system element for parameter '\" + fileParamName + \"' does not exist: '\" + file + \"'\");\n+            throw new IllegalArgumentException(\"File system element for parameter '\" + s + \"' does not exist: '\" + file + \"'\");\n         }\n         return file;\n     }\n     \n-    private static File requireExistsChecked(final File file, final String fileParamName) throws FileNotFoundException {\n-        Objects.requireNonNull(file, fileParamName);\n+    private static File requireExistsChecked(final File file, final String s) throws FileNotFoundException {\n+        Objects.requireNonNull(file, s);\n         if (!file.exists()) {\n-            throw new FileNotFoundException(\"File system element for parameter '\" + fileParamName + \"' does not exist: '\" + file + \"'\");\n+            throw new FileNotFoundException(\"File system element for parameter '\" + s + \"' does not exist: '\" + file + \"'\");\n         }\n         return file;\n     }\n     \n-    private static File requireFile(final File file, final String name) {\n-        Objects.requireNonNull(file, name);\n+    private static File requireFile(final File file, final String s) {\n+        Objects.requireNonNull(file, s);\n         if (!file.isFile()) {\n-            throw new IllegalArgumentException(\"Parameter '\" + name + \"' is not a file: \" + file);\n+            throw new IllegalArgumentException(\"Parameter '\" + s + \"' is not a file: \" + file);\n         }\n         return file;\n     }\n     \n-    private static void requireFileCopy(final File source, final File destination) throws FileNotFoundException {\n-        requireExistsChecked(source, \"source\");\n-        Objects.requireNonNull(destination, \"destination\");\n+    private static void requireFileCopy(final File file, final File obj) throws FileNotFoundException {\n+        requireExistsChecked(file, \"source\");\n+        Objects.requireNonNull(obj, \"destination\");\n     }\n     \n-    private static File requireFileIfExists(final File file, final String name) {\n-        Objects.requireNonNull(file, name);\n-        return file.exists() ? requireFile(file, name) : file;\n+    private static File requireFileIfExists(final File obj, final String message) {\n+        Objects.requireNonNull(obj, message);\n+        return obj.exists() ? requireFile(obj, message) : obj;\n     }\n     \n-    private static void setLastModified(final File sourceFile, final File targetFile) throws IOException {\n-        Objects.requireNonNull(sourceFile, \"sourceFile\");\n-        setLastModified(targetFile, lastModified(sourceFile));\n+    private static void setLastModified(final File obj, final File file) throws IOException {\n+        Objects.requireNonNull(obj, \"sourceFile\");\n+        setLastModified(file, lastModified(obj));\n     }\n     \n-    private static void setLastModified(final File file, final long timeMillis) throws IOException {\n-        Objects.requireNonNull(file, \"file\");\n-        if (!file.setLastModified(timeMillis)) {\n-            throw new IOException(String.format(\"Failed setLastModified(%s) on '%s'\", Long.valueOf(timeMillis), file));\n+    private static void setLastModified(final File obj, final long n) throws IOException {\n+        Objects.requireNonNull(obj, \"file\");\n+        if (!obj.setLastModified(n)) {\n+            throw new IOException(String.format(\"Failed setLastModified(%s) on '%s'\", Long.valueOf(n), obj));\n         }\n     }\n     \n     public static long sizeOf(final File file) {\n         requireExists(file, \"file\");\n         return file.isDirectory() ? sizeOfDirectory0(file) : file.length();\n     }\n     \n-    private static long sizeOf0(final File file) {\n-        Objects.requireNonNull(file, \"file\");\n-        if (file.isDirectory()) {\n-            return sizeOfDirectory0(file);\n+    private static long sizeOf0(final File obj) {\n+        Objects.requireNonNull(obj, \"file\");\n+        if (obj.isDirectory()) {\n+            return sizeOfDirectory0(obj);\n         }\n-        return file.length();\n+        return obj.length();\n     }\n     \n     public static BigInteger sizeOfAsBigInteger(final File file) {\n         requireExists(file, \"file\");\n         return file.isDirectory() ? sizeOfDirectoryBig0(file) : BigInteger.valueOf(file.length());\n     }\n     \n-    private static BigInteger sizeOfBig0(final File file) {\n-        Objects.requireNonNull(file, \"fileOrDir\");\n-        return file.isDirectory() ? sizeOfDirectoryBig0(file) : BigInteger.valueOf(file.length());\n+    private static BigInteger sizeOfBig0(final File obj) {\n+        Objects.requireNonNull(obj, \"fileOrDir\");\n+        return obj.isDirectory() ? sizeOfDirectoryBig0(obj) : BigInteger.valueOf(obj.length());\n     }\n     \n-    public static long sizeOfDirectory(final File directory) {\n-        return sizeOfDirectory0(requireDirectoryExists(directory, \"directory\"));\n+    public static long sizeOfDirectory(final File file) {\n+        return sizeOfDirectory0(requireDirectoryExists(file, \"directory\"));\n     }\n     \n-    private static long sizeOfDirectory0(final File directory) {\n-        Objects.requireNonNull(directory, \"directory\");\n-        final File[] files = directory.listFiles();\n-        if (files == null) {\n+    private static long sizeOfDirectory0(final File obj) {\n+        Objects.requireNonNull(obj, \"directory\");\n+        final File[] listFiles = obj.listFiles();\n+        if (listFiles == null) {\n             return 0L;\n         }\n-        long size = 0L;\n-        for (final File file : files) {\n+        long n = 0L;\n+        for (final File file : listFiles) {\n             if (!isSymlink(file)) {\n-                size += sizeOf0(file);\n-                if (size < 0L) {\n+                n += sizeOf0(file);\n+                if (n < 0L) {\n                     break;\n                 }\n             }\n         }\n-        return size;\n+        return n;\n     }\n     \n-    public static BigInteger sizeOfDirectoryAsBigInteger(final File directory) {\n-        return sizeOfDirectoryBig0(requireDirectoryExists(directory, \"directory\"));\n+    public static BigInteger sizeOfDirectoryAsBigInteger(final File file) {\n+        return sizeOfDirectoryBig0(requireDirectoryExists(file, \"directory\"));\n     }\n     \n-    private static BigInteger sizeOfDirectoryBig0(final File directory) {\n-        Objects.requireNonNull(directory, \"directory\");\n-        final File[] files = directory.listFiles();\n-        if (files == null) {\n+    private static BigInteger sizeOfDirectoryBig0(final File obj) {\n+        Objects.requireNonNull(obj, \"directory\");\n+        final File[] listFiles = obj.listFiles();\n+        if (listFiles == null) {\n             return BigInteger.ZERO;\n         }\n-        BigInteger size = BigInteger.ZERO;\n-        for (final File file : files) {\n+        BigInteger bigInteger = BigInteger.ZERO;\n+        for (final File file : listFiles) {\n             if (!isSymlink(file)) {\n-                size = size.add(sizeOfBig0(file));\n+                bigInteger = bigInteger.add(sizeOfBig0(file));\n             }\n         }\n-        return size;\n+        return bigInteger;\n     }\n     \n-    public static Stream<File> streamFiles(final File directory, final boolean recursive, final String... extensions) throws IOException {\n-        final IOFileFilter filter = (extensions == null) ? FileFileFilter.INSTANCE : FileFileFilter.INSTANCE.and((IOFileFilter)new SuffixFileFilter(toSuffixes(extensions)));\n-        return PathUtils.walk(directory.toPath(), (PathFilter)filter, toMaxDepth(recursive), false, new FileVisitOption[] { FileVisitOption.FOLLOW_LINKS }).map(Path::toFile);\n+    public static Stream<File> streamFiles(final File file, final boolean b, final String... array) throws IOException {\n+        return PathUtils.walk(file.toPath(), (PathFilter)((array == null) ? FileFileFilter.INSTANCE : FileFileFilter.INSTANCE.and((IOFileFilter)new SuffixFileFilter(toSuffixes(array)))), toMaxDepth(b), false, new FileVisitOption[] { FileVisitOption.FOLLOW_LINKS }).map(Path::toFile);\n     }\n     \n     public static File toFile(final URL url) {\n         if (url == null || !\"file\".equalsIgnoreCase(url.getProtocol())) {\n             return null;\n         }\n-        final String filename = url.getFile().replace('/', File.separatorChar);\n-        return new File(decodeUrl(filename));\n+        return new File(decodeUrl(url.getFile().replace('/', File.separatorChar)));\n     }\n     \n-    public static File[] toFiles(final URL... urls) {\n-        if (IOUtils.length((Object[])urls) == 0) {\n+    public static File[] toFiles(final URL... array) {\n+        if (IOUtils.length((Object[])array) == 0) {\n             return FileUtils.EMPTY_FILE_ARRAY;\n         }\n-        final File[] files = new File[urls.length];\n-        for (int i = 0; i < urls.length; ++i) {\n-            final URL url = urls[i];\n-            if (url != null) {\n-                if (!\"file\".equalsIgnoreCase(url.getProtocol())) {\n-                    throw new IllegalArgumentException(\"Can only convert file URL to a File: \" + url);\n+        final File[] array2 = new File[array.length];\n+        for (int i = 0; i < array.length; ++i) {\n+            final URL obj = array[i];\n+            if (obj != null) {\n+                if (!\"file\".equalsIgnoreCase(obj.getProtocol())) {\n+                    throw new IllegalArgumentException(\"Can only convert file URL to a File: \" + obj);\n                 }\n-                files[i] = toFile(url);\n+                array2[i] = toFile(obj);\n             }\n         }\n-        return files;\n+        return array2;\n     }\n     \n     private static List<File> toList(final Stream<File> stream) {\n         return stream.collect((Collector<? super File, ?, List<File>>)Collectors.toList());\n     }\n     \n-    private static int toMaxDepth(final boolean recursive) {\n-        return recursive ? Integer.MAX_VALUE : 1;\n+    private static int toMaxDepth(final boolean b) {\n+        return b ? Integer.MAX_VALUE : 1;\n     }\n     \n-    private static String[] toSuffixes(final String... extensions) {\n-        Objects.requireNonNull(extensions, \"extensions\");\n-        final String[] suffixes = new String[extensions.length];\n-        for (int i = 0; i < extensions.length; ++i) {\n-            suffixes[i] = \".\" + extensions[i];\n+    private static String[] toSuffixes(final String... obj) {\n+        Objects.requireNonNull(obj, \"extensions\");\n+        final String[] array = new String[obj.length];\n+        for (int i = 0; i < obj.length; ++i) {\n+            array[i] = \".\" + obj[i];\n         }\n-        return suffixes;\n+        return array;\n     }\n     \n-    public static void touch(final File file) throws IOException {\n-        Objects.requireNonNull(file, \"file\");\n-        if (!file.exists()) {\n-            openOutputStream(file).close();\n+    public static void touch(final File obj) throws IOException {\n+        Objects.requireNonNull(obj, \"file\");\n+        if (!obj.exists()) {\n+            openOutputStream(obj).close();\n         }\n-        setLastModified(file, System.currentTimeMillis());\n+        setLastModified(obj, System.currentTimeMillis());\n     }\n     \n-    public static URL[] toURLs(final File... files) throws IOException {\n-        Objects.requireNonNull(files, \"files\");\n-        final URL[] urls = new URL[files.length];\n-        for (int i = 0; i < urls.length; ++i) {\n-            urls[i] = files[i].toURI().toURL();\n+    public static URL[] toURLs(final File... obj) throws IOException {\n+        Objects.requireNonNull(obj, \"files\");\n+        final URL[] array = new URL[obj.length];\n+        for (int i = 0; i < array.length; ++i) {\n+            array[i] = obj[i].toURI().toURL();\n         }\n-        return urls;\n+        return array;\n     }\n     \n-    private static void validateMoveParameters(final File source, final File destination) throws FileNotFoundException {\n-        Objects.requireNonNull(source, \"source\");\n-        Objects.requireNonNull(destination, \"destination\");\n-        if (!source.exists()) {\n-            throw new FileNotFoundException(\"Source '\" + source + \"' does not exist\");\n+    private static void validateMoveParameters(final File file, final File obj) throws FileNotFoundException {\n+        Objects.requireNonNull(file, \"source\");\n+        Objects.requireNonNull(obj, \"destination\");\n+        if (!file.exists()) {\n+            throw new FileNotFoundException(\"Source '\" + file + \"' does not exist\");\n         }\n     }\n     \n-    public static boolean waitFor(final File file, final int seconds) {\n-        Objects.requireNonNull(file, \"file\");\n-        final long finishAtMillis = System.currentTimeMillis() + seconds * 1000L;\n-        boolean wasInterrupted = false;\n+    public static boolean waitFor(final File obj, final int n) {\n+        Objects.requireNonNull(obj, \"file\");\n+        final long n2 = System.currentTimeMillis() + n * 1000L;\n+        boolean b = false;\n         try {\n-            while (!file.exists()) {\n-                final long remainingMillis = finishAtMillis - System.currentTimeMillis();\n-                if (remainingMillis < 0L) {\n+            while (!obj.exists()) {\n+                final long b2 = n2 - System.currentTimeMillis();\n+                if (b2 < 0L) {\n                     return false;\n                 }\n                 try {\n-                    Thread.sleep(Math.min(100L, remainingMillis));\n+                    Thread.sleep(Math.min(100L, b2));\n                 }\n-                catch (final InterruptedException ignore) {\n-                    wasInterrupted = true;\n+                catch (final InterruptedException ex) {\n+                    b = true;\n                 }\n-                catch (final Exception ex) {\n+                catch (final Exception ex2) {\n                     break;\n                 }\n             }\n         }\n         finally {\n-            if (wasInterrupted) {\n+            if (b) {\n                 Thread.currentThread().interrupt();\n             }\n         }\n         return true;\n     }\n     \n     @Deprecated\n-    public static void write(final File file, final CharSequence data) throws IOException {\n-        write(file, data, Charset.defaultCharset(), false);\n+    public static void write(final File file, final CharSequence charSequence) throws IOException {\n+        write(file, charSequence, Charset.defaultCharset(), false);\n     }\n     \n     @Deprecated\n-    public static void write(final File file, final CharSequence data, final boolean append) throws IOException {\n-        write(file, data, Charset.defaultCharset(), append);\n+    public static void write(final File file, final CharSequence charSequence, final boolean b) throws IOException {\n+        write(file, charSequence, Charset.defaultCharset(), b);\n     }\n     \n-    public static void write(final File file, final CharSequence data, final Charset charset) throws IOException {\n-        write(file, data, charset, false);\n+    public static void write(final File file, final CharSequence charSequence, final Charset charset) throws IOException {\n+        write(file, charSequence, charset, false);\n     }\n     \n-    public static void write(final File file, final CharSequence data, final Charset charset, final boolean append) throws IOException {\n-        writeStringToFile(file, Objects.toString((Object)data, (String)null), charset, append);\n+    public static void write(final File file, final CharSequence o, final Charset charset, final boolean b) throws IOException {\n+        writeStringToFile(file, Objects.toString((Object)o, (String)null), charset, b);\n     }\n     \n-    public static void write(final File file, final CharSequence data, final String charsetName) throws IOException {\n-        write(file, data, charsetName, false);\n+    public static void write(final File file, final CharSequence charSequence, final String s) throws IOException {\n+        write(file, charSequence, s, false);\n     }\n     \n-    public static void write(final File file, final CharSequence data, final String charsetName, final boolean append) throws IOException {\n-        write(file, data, Charsets.toCharset(charsetName), append);\n+    public static void write(final File file, final CharSequence charSequence, final String s, final boolean b) throws IOException {\n+        write(file, charSequence, Charsets.toCharset(s), b);\n     }\n     \n-    public static void writeByteArrayToFile(final File file, final byte[] data) throws IOException {\n-        writeByteArrayToFile(file, data, false);\n+    public static void writeByteArrayToFile(final File file, final byte[] array) throws IOException {\n+        writeByteArrayToFile(file, array, false);\n     }\n     \n-    public static void writeByteArrayToFile(final File file, final byte[] data, final boolean append) throws IOException {\n-        writeByteArrayToFile(file, data, 0, data.length, append);\n+    public static void writeByteArrayToFile(final File file, final byte[] array, final boolean b) throws IOException {\n+        writeByteArrayToFile(file, array, 0, array.length, b);\n     }\n     \n-    public static void writeByteArrayToFile(final File file, final byte[] data, final int off, final int len) throws IOException {\n-        writeByteArrayToFile(file, data, off, len, false);\n+    public static void writeByteArrayToFile(final File file, final byte[] array, final int n, final int n2) throws IOException {\n+        writeByteArrayToFile(file, array, n, n2, false);\n     }\n     \n-    public static void writeByteArrayToFile(final File file, final byte[] data, final int off, final int len, final boolean append) throws IOException {\n-        try (final OutputStream out = openOutputStream(file, append)) {\n-            out.write(data, off, len);\n+    public static void writeByteArrayToFile(final File file, final byte[] b, final int off, final int len, final boolean b2) throws IOException {\n+        try (final FileOutputStream openOutputStream = openOutputStream(file, b2)) {\n+            openOutputStream.write(b, off, len);\n         }\n     }\n     \n-    public static void writeLines(final File file, final Collection<?> lines) throws IOException {\n-        writeLines(file, null, lines, null, false);\n+    public static void writeLines(final File file, final Collection<?> collection) throws IOException {\n+        writeLines(file, null, collection, null, false);\n     }\n     \n-    public static void writeLines(final File file, final Collection<?> lines, final boolean append) throws IOException {\n-        writeLines(file, null, lines, null, append);\n+    public static void writeLines(final File file, final Collection<?> collection, final boolean b) throws IOException {\n+        writeLines(file, null, collection, null, b);\n     }\n     \n-    public static void writeLines(final File file, final Collection<?> lines, final String lineEnding) throws IOException {\n-        writeLines(file, null, lines, lineEnding, false);\n+    public static void writeLines(final File file, final Collection<?> collection, final String s) throws IOException {\n+        writeLines(file, null, collection, s, false);\n     }\n     \n-    public static void writeLines(final File file, final Collection<?> lines, final String lineEnding, final boolean append) throws IOException {\n-        writeLines(file, null, lines, lineEnding, append);\n+    public static void writeLines(final File file, final Collection<?> collection, final String s, final boolean b) throws IOException {\n+        writeLines(file, null, collection, s, b);\n     }\n     \n-    public static void writeLines(final File file, final String charsetName, final Collection<?> lines) throws IOException {\n-        writeLines(file, charsetName, lines, null, false);\n+    public static void writeLines(final File file, final String s, final Collection<?> collection) throws IOException {\n+        writeLines(file, s, collection, null, false);\n     }\n     \n-    public static void writeLines(final File file, final String charsetName, final Collection<?> lines, final boolean append) throws IOException {\n-        writeLines(file, charsetName, lines, null, append);\n+    public static void writeLines(final File file, final String s, final Collection<?> collection, final boolean b) throws IOException {\n+        writeLines(file, s, collection, null, b);\n     }\n     \n-    public static void writeLines(final File file, final String charsetName, final Collection<?> lines, final String lineEnding) throws IOException {\n-        writeLines(file, charsetName, lines, lineEnding, false);\n+    public static void writeLines(final File file, final String s, final Collection<?> collection, final String s2) throws IOException {\n+        writeLines(file, s, collection, s2, false);\n     }\n     \n-    public static void writeLines(final File file, final String charsetName, final Collection<?> lines, final String lineEnding, final boolean append) throws IOException {\n-        try (final OutputStream out = new BufferedOutputStream(openOutputStream(file, append))) {\n-            IOUtils.writeLines((Collection)lines, lineEnding, out, charsetName);\n+    public static void writeLines(final File file, final String s, final Collection<?> collection, final String s2, final boolean b) throws IOException {\n+        try (final BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(openOutputStream(file, b))) {\n+            IOUtils.writeLines((Collection)collection, s2, (OutputStream)bufferedOutputStream, s);\n         }\n     }\n     \n     @Deprecated\n-    public static void writeStringToFile(final File file, final String data) throws IOException {\n-        writeStringToFile(file, data, Charset.defaultCharset(), false);\n+    public static void writeStringToFile(final File file, final String s) throws IOException {\n+        writeStringToFile(file, s, Charset.defaultCharset(), false);\n     }\n     \n     @Deprecated\n-    public static void writeStringToFile(final File file, final String data, final boolean append) throws IOException {\n-        writeStringToFile(file, data, Charset.defaultCharset(), append);\n+    public static void writeStringToFile(final File file, final String s, final boolean b) throws IOException {\n+        writeStringToFile(file, s, Charset.defaultCharset(), b);\n     }\n     \n-    public static void writeStringToFile(final File file, final String data, final Charset charset) throws IOException {\n-        writeStringToFile(file, data, charset, false);\n+    public static void writeStringToFile(final File file, final String s, final Charset charset) throws IOException {\n+        writeStringToFile(file, s, charset, false);\n     }\n     \n-    public static void writeStringToFile(final File file, final String data, final Charset charset, final boolean append) throws IOException {\n-        try (final OutputStream out = openOutputStream(file, append)) {\n-            IOUtils.write(data, out, charset);\n+    public static void writeStringToFile(final File file, final String s, final Charset charset, final boolean b) throws IOException {\n+        try (final FileOutputStream openOutputStream = openOutputStream(file, b)) {\n+            IOUtils.write(s, (OutputStream)openOutputStream, charset);\n         }\n     }\n     \n-    public static void writeStringToFile(final File file, final String data, final String charsetName) throws IOException {\n-        writeStringToFile(file, data, charsetName, false);\n+    public static void writeStringToFile(final File file, final String s, final String s2) throws IOException {\n+        writeStringToFile(file, s, s2, false);\n     }\n     \n-    public static void writeStringToFile(final File file, final String data, final String charsetName, final boolean append) throws IOException {\n-        writeStringToFile(file, data, Charsets.toCharset(charsetName), append);\n+    public static void writeStringToFile(final File file, final String s, final String s2, final boolean b) throws IOException {\n+        writeStringToFile(file, s, Charsets.toCharset(s2), b);\n     }\n     \n     @Deprecated\n     public FileUtils() {\n     }\n     \n     static {\n"}]}
