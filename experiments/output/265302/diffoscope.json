{"diffoscope-json-version": 1, "source1": "first/JavaClass.class", "source2": "second/JavaClass.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,15 +1,13 @@\n \n package org.apache.bcel.classfile;\n \n-import java.util.List;\n import java.util.ArrayList;\n import org.apache.bcel.generic.Type;\n import java.io.ByteArrayOutputStream;\n-import java.util.Set;\n import java.util.TreeSet;\n import org.apache.bcel.util.ClassQueue;\n import java.io.OutputStream;\n import java.io.FileOutputStream;\n import java.io.File;\n import java.io.IOException;\n import java.io.DataOutputStream;\n@@ -46,246 +44,248 @@\n     private AnnotationEntry[] annotations;\n     private byte source;\n     private boolean isAnonymous;\n     private boolean isNested;\n     private boolean computedNestedTypeStatus;\n     private transient Repository repository;\n     \n-    static void Debug(final String str) {\n+    static void Debug(final String x) {\n         if (JavaClass.debug) {\n-            System.out.println(str);\n+            System.out.println(x);\n         }\n     }\n     \n     public static BCELComparator getComparator() {\n         return JavaClass.bcelComparator;\n     }\n     \n-    private static String indent(final Object obj) {\n-        final StringTokenizer tokenizer = new StringTokenizer(obj.toString(), \"\\n\");\n-        final StringBuilder buf = new StringBuilder();\n-        while (tokenizer.hasMoreTokens()) {\n-            buf.append(\"\\t\").append(tokenizer.nextToken()).append(\"\\n\");\n+    private static String indent(final Object o) {\n+        final StringTokenizer stringTokenizer = new StringTokenizer(o.toString(), \"\\n\");\n+        final StringBuilder sb = new StringBuilder();\n+        while (stringTokenizer.hasMoreTokens()) {\n+            sb.append(\"\\t\").append(stringTokenizer.nextToken()).append(\"\\n\");\n         }\n-        return buf.toString();\n+        return sb.toString();\n     }\n     \n-    public static void setComparator(final BCELComparator comparator) {\n-        JavaClass.bcelComparator = comparator;\n+    public static void setComparator(final BCELComparator bcelComparator) {\n+        JavaClass.bcelComparator = bcelComparator;\n     }\n     \n-    public JavaClass(final int classNameIndex, final int superclassNameIndex, final String fileName, final int major, final int minor, final int accessFlags, final ConstantPool constantPool, final int[] interfaces, final Field[] fields, final Method[] methods, final Attribute[] attributes) {\n-        this(classNameIndex, superclassNameIndex, fileName, major, minor, accessFlags, constantPool, interfaces, fields, methods, attributes, (byte)1);\n+    public JavaClass(final int n, final int n2, final String s, final int n3, final int n4, final int n5, final ConstantPool constantPool, final int[] array, final Field[] array2, final Method[] array3, final Attribute[] array4) {\n+        this(n, n2, s, n3, n4, n5, constantPool, array, array2, array3, array4, (byte)1);\n     }\n     \n-    public JavaClass(final int classNameIndex, final int superclassNameIndex, final String fileName, final int major, final int minor, final int accessFlags, final ConstantPool constantPool, int[] interfaces, Field[] fields, Method[] methods, Attribute[] attributes, final byte source) {\n-        super(accessFlags);\n+    public JavaClass(final int classNameIndex, final int superclassNameIndex, final String fileName, final int major, final int minor, final int n, final ConstantPool constantPool, int[] empty_INT_ARRAY, Field[] empty_FIELD_ARRAY, Method[] empty_METHOD_ARRAY, Attribute[] empty_ARRAY, final byte source) {\n+        super(n);\n         this.sourceFileName = \"<Unknown>\";\n         this.source = 1;\n         this.repository = (Repository)SyntheticRepository.getInstance();\n-        if (interfaces == null) {\n-            interfaces = ArrayUtils.EMPTY_INT_ARRAY;\n+        if (empty_INT_ARRAY == null) {\n+            empty_INT_ARRAY = ArrayUtils.EMPTY_INT_ARRAY;\n         }\n-        if (attributes == null) {\n-            attributes = Attribute.EMPTY_ARRAY;\n+        if (empty_ARRAY == null) {\n+            empty_ARRAY = Attribute.EMPTY_ARRAY;\n         }\n-        if (fields == null) {\n-            fields = Field.EMPTY_FIELD_ARRAY;\n+        if (empty_FIELD_ARRAY == null) {\n+            empty_FIELD_ARRAY = Field.EMPTY_FIELD_ARRAY;\n         }\n-        if (methods == null) {\n-            methods = Method.EMPTY_METHOD_ARRAY;\n+        if (empty_METHOD_ARRAY == null) {\n+            empty_METHOD_ARRAY = Method.EMPTY_METHOD_ARRAY;\n         }\n         this.classNameIndex = classNameIndex;\n         this.superclassNameIndex = superclassNameIndex;\n         this.fileName = fileName;\n         this.major = major;\n         this.minor = minor;\n         this.constantPool = constantPool;\n-        this.interfaces = interfaces;\n-        this.fields = fields;\n-        this.methods = methods;\n-        this.attributes = attributes;\n+        this.interfaces = empty_INT_ARRAY;\n+        this.fields = empty_FIELD_ARRAY;\n+        this.methods = empty_METHOD_ARRAY;\n+        this.attributes = empty_ARRAY;\n         this.source = source;\n-        for (final Attribute attribute : attributes) {\n+        for (final Attribute attribute : empty_ARRAY) {\n             if (attribute instanceof SourceFile) {\n                 this.sourceFileName = ((SourceFile)attribute).getSourceFileName();\n                 break;\n             }\n         }\n         this.className = constantPool.getConstantString(classNameIndex, (byte)7);\n         this.className = Utility.compactClassName(this.className, false);\n-        final int index = this.className.lastIndexOf(46);\n-        if (index < 0) {\n+        final int lastIndex = this.className.lastIndexOf(46);\n+        if (lastIndex < 0) {\n             this.packageName = \"\";\n         }\n         else {\n-            this.packageName = this.className.substring(0, index);\n+            this.packageName = this.className.substring(0, lastIndex);\n         }\n         if (superclassNameIndex > 0) {\n             this.superclassName = constantPool.getConstantString(superclassNameIndex, (byte)7);\n             this.superclassName = Utility.compactClassName(this.superclassName, false);\n         }\n         else {\n             this.superclassName = \"java.lang.Object\";\n         }\n-        this.interfaceNames = new String[interfaces.length];\n-        for (int i = 0; i < interfaces.length; ++i) {\n-            final String str = constantPool.getConstantString(interfaces[i], (byte)7);\n-            this.interfaceNames[i] = Utility.compactClassName(str, false);\n+        this.interfaceNames = new String[empty_INT_ARRAY.length];\n+        for (int j = 0; j < empty_INT_ARRAY.length; ++j) {\n+            this.interfaceNames[j] = Utility.compactClassName(constantPool.getConstantString(empty_INT_ARRAY[j], (byte)7), false);\n         }\n     }\n     \n-    public void accept(final Visitor v) {\n-        v.visitJavaClass(this);\n+    public void accept(final Visitor visitor) {\n+        visitor.visitJavaClass(this);\n     }\n     \n-    public int compareTo(final JavaClass obj) {\n-        return this.getClassName().compareTo(obj.getClassName());\n+    public int compareTo(final JavaClass javaClass) {\n+        return this.getClassName().compareTo(javaClass.getClassName());\n     }\n     \n     private void computeNestedTypeStatus() {\n         if (this.computedNestedTypeStatus) {\n             return;\n         }\n         for (final Attribute attribute : this.attributes) {\n             if (attribute instanceof InnerClasses) {\n                 ((InnerClasses)attribute).forEach(innerClass -> {\n-                    boolean innerClassAttributeRefersToMe = false;\n-                    final String innerClassName = this.constantPool.getConstantString(innerClass.getInnerClassIndex(), (byte)7);\n-                    final String innerClassName2 = Utility.compactClassName(innerClassName, false);\n-                    if (innerClassName2.equals(this.getClassName())) {\n-                        innerClassAttributeRefersToMe = true;\n+                    boolean b = false;\n+                    if (Utility.compactClassName(this.constantPool.getConstantString(innerClass.getInnerClassIndex(), (byte)7), (boolean)(0 != 0)).equals(this.getClassName())) {\n+                        b = (1 != 0);\n                     }\n-                    if (innerClassAttributeRefersToMe) {\n-                        this.isNested = true;\n+                    if (b) {\n+                        this.isNested = (1 != 0);\n                         if (innerClass.getInnerNameIndex() == 0) {\n-                            this.isAnonymous = true;\n+                            this.isAnonymous = (1 != 0);\n                         }\n                     }\n                     return;\n                 });\n             }\n         }\n         this.computedNestedTypeStatus = true;\n     }\n     \n     public JavaClass copy() {\n         try {\n-            final JavaClass c = (JavaClass)this.clone();\n-            c.constantPool = this.constantPool.copy();\n-            c.interfaces = this.interfaces.clone();\n-            c.interfaceNames = this.interfaceNames.clone();\n-            Arrays.setAll(c.fields = new Field[this.fields.length], i -> this.fields[i].copy(c.constantPool));\n-            Arrays.setAll(c.methods = new Method[this.methods.length], i -> this.methods[i].copy(c.constantPool));\n-            Arrays.setAll(c.attributes = new Attribute[this.attributes.length], i -> this.attributes[i].copy(c.constantPool));\n-            return c;\n+            final JavaClass javaClass = (JavaClass)this.clone();\n+            javaClass.constantPool = this.constantPool.copy();\n+            javaClass.interfaces = this.interfaces.clone();\n+            javaClass.interfaceNames = this.interfaceNames.clone();\n+            Arrays.setAll(javaClass.fields = new Field[this.fields.length], n2 -> this.fields[n2].copy(javaClass2.constantPool));\n+            Arrays.setAll(javaClass.methods = new Method[this.methods.length], n4 -> this.methods[n4].copy(javaClass3.constantPool));\n+            Arrays.setAll(javaClass.attributes = new Attribute[this.attributes.length], n6 -> this.attributes[n6].copy(javaClass4.constantPool));\n+            return javaClass;\n         }\n-        catch (final CloneNotSupportedException e) {\n+        catch (final CloneNotSupportedException ex) {\n             return null;\n         }\n     }\n     \n-    public void dump(final DataOutputStream file) throws IOException {\n-        file.writeInt(-889275714);\n-        file.writeShort(this.minor);\n-        file.writeShort(this.major);\n-        this.constantPool.dump(file);\n-        file.writeShort(super.getAccessFlags());\n-        file.writeShort(this.classNameIndex);\n-        file.writeShort(this.superclassNameIndex);\n-        file.writeShort(this.interfaces.length);\n-        for (final int interface1 : this.interfaces) {\n-            file.writeShort(interface1);\n-        }\n-        file.writeShort(this.fields.length);\n-        for (final Field field : this.fields) {\n-            field.dump(file);\n-        }\n-        file.writeShort(this.methods.length);\n-        for (final Method method : this.methods) {\n-            method.dump(file);\n+    public void dump(final DataOutputStream dataOutputStream) throws IOException {\n+        dataOutputStream.writeInt(-889275714);\n+        dataOutputStream.writeShort(this.minor);\n+        dataOutputStream.writeShort(this.major);\n+        this.constantPool.dump(dataOutputStream);\n+        dataOutputStream.writeShort(super.getAccessFlags());\n+        dataOutputStream.writeShort(this.classNameIndex);\n+        dataOutputStream.writeShort(this.superclassNameIndex);\n+        dataOutputStream.writeShort(this.interfaces.length);\n+        final int[] interfaces = this.interfaces;\n+        for (int length = interfaces.length, i = 0; i < length; ++i) {\n+            dataOutputStream.writeShort(interfaces[i]);\n+        }\n+        dataOutputStream.writeShort(this.fields.length);\n+        final Field[] fields = this.fields;\n+        for (int length2 = fields.length, j = 0; j < length2; ++j) {\n+            fields[j].dump(dataOutputStream);\n+        }\n+        dataOutputStream.writeShort(this.methods.length);\n+        final Method[] methods = this.methods;\n+        for (int length3 = methods.length, k = 0; k < length3; ++k) {\n+            methods[k].dump(dataOutputStream);\n         }\n         if (this.attributes != null) {\n-            file.writeShort(this.attributes.length);\n-            for (final Attribute attribute : this.attributes) {\n-                attribute.dump(file);\n+            dataOutputStream.writeShort(this.attributes.length);\n+            final Attribute[] attributes = this.attributes;\n+            for (int length4 = attributes.length, l = 0; l < length4; ++l) {\n+                attributes[l].dump(dataOutputStream);\n             }\n         }\n         else {\n-            file.writeShort(0);\n+            dataOutputStream.writeShort(0);\n         }\n-        file.flush();\n+        dataOutputStream.flush();\n     }\n     \n     public void dump(final File file) throws IOException {\n         final String parent = file.getParent();\n         if (parent != null) {\n-            final File dir = new File(parent);\n-            if (!dir.mkdirs() && !dir.isDirectory()) {\n-                throw new IOException(\"Could not create the directory \" + dir);\n+            final File obj = new File(parent);\n+            if (!obj.mkdirs() && !obj.isDirectory()) {\n+                throw new IOException(\"Could not create the directory \" + obj);\n             }\n         }\n-        try (final DataOutputStream dos = new DataOutputStream(new FileOutputStream(file))) {\n-            this.dump(dos);\n+        try (final DataOutputStream dataOutputStream = new DataOutputStream(new FileOutputStream(file))) {\n+            this.dump(dataOutputStream);\n         }\n     }\n     \n-    public void dump(final OutputStream file) throws IOException {\n-        this.dump(new DataOutputStream(file));\n+    public void dump(final OutputStream out) throws IOException {\n+        this.dump(new DataOutputStream(out));\n     }\n     \n-    public void dump(final String fileName) throws IOException {\n-        this.dump(new File(fileName));\n+    public void dump(final String pathname) throws IOException {\n+        this.dump(new File(pathname));\n     }\n     \n-    public boolean equals(final Object obj) {\n-        return JavaClass.bcelComparator.equals((Object)this, obj);\n+    public boolean equals(final Object o) {\n+        return JavaClass.bcelComparator.equals((Object)this, o);\n     }\n     \n     public JavaClass[] getAllInterfaces() throws ClassNotFoundException {\n-        final ClassQueue queue = new ClassQueue();\n-        final Set<JavaClass> allInterfaces = new TreeSet<JavaClass>();\n-        queue.enqueue(this);\n-        while (!queue.empty()) {\n-            final JavaClass clazz = queue.dequeue();\n-            final JavaClass souper = clazz.getSuperClass();\n-            final JavaClass[] interfaces = clazz.getInterfaces();\n-            if (clazz.isInterface()) {\n-                allInterfaces.add(clazz);\n-            }\n-            else if (souper != null) {\n-                queue.enqueue(souper);\n-            }\n-            for (final JavaClass iface : interfaces) {\n-                queue.enqueue(iface);\n+        final ClassQueue classQueue = new ClassQueue();\n+        final TreeSet set = new TreeSet();\n+        classQueue.enqueue(this);\n+        while (!classQueue.empty()) {\n+            final JavaClass dequeue = classQueue.dequeue();\n+            final JavaClass superClass = dequeue.getSuperClass();\n+            final JavaClass[] interfaces = dequeue.getInterfaces();\n+            if (dequeue.isInterface()) {\n+                set.add(dequeue);\n+            }\n+            else if (superClass != null) {\n+                classQueue.enqueue(superClass);\n+            }\n+            final JavaClass[] array = interfaces;\n+            for (int length = array.length, i = 0; i < length; ++i) {\n+                classQueue.enqueue(array[i]);\n             }\n         }\n-        return allInterfaces.toArray(JavaClass.EMPTY_ARRAY);\n+        return (JavaClass[])set.toArray(JavaClass.EMPTY_ARRAY);\n     }\n     \n     public AnnotationEntry[] getAnnotationEntries() {\n         if (this.annotations == null) {\n             this.annotations = AnnotationEntry.createAnnotationEntries(this.getAttributes());\n         }\n         return this.annotations;\n     }\n     \n     public Attribute[] getAttributes() {\n         return this.attributes;\n     }\n     \n     public byte[] getBytes() {\n-        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        try (final DataOutputStream dos = new DataOutputStream(baos)) {\n-            this.dump(dos);\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        try (final DataOutputStream dataOutputStream = new DataOutputStream(out)) {\n+            this.dump(dataOutputStream);\n         }\n-        catch (final IOException e) {\n-            e.printStackTrace();\n+        catch (final IOException ex) {\n+            ex.printStackTrace();\n         }\n-        return baos.toByteArray();\n+        return out.toByteArray();\n     }\n     \n     public String getClassName() {\n         return this.className;\n     }\n     \n     public int getClassNameIndex() {\n@@ -309,30 +309,30 @@\n     }\n     \n     public String[] getInterfaceNames() {\n         return this.interfaceNames;\n     }\n     \n     public JavaClass[] getInterfaces() throws ClassNotFoundException {\n-        final String[] interfaces = this.getInterfaceNames();\n-        final JavaClass[] classes = new JavaClass[interfaces.length];\n-        for (int i = 0; i < interfaces.length; ++i) {\n-            classes[i] = this.repository.loadClass(interfaces[i]);\n+        final String[] interfaceNames = this.getInterfaceNames();\n+        final JavaClass[] array = new JavaClass[interfaceNames.length];\n+        for (int i = 0; i < interfaceNames.length; ++i) {\n+            array[i] = this.repository.loadClass(interfaceNames[i]);\n         }\n-        return classes;\n+        return array;\n     }\n     \n     public int getMajor() {\n         return this.major;\n     }\n     \n-    public Method getMethod(final java.lang.reflect.Method m) {\n-        for (final Method method : this.methods) {\n-            if (m.getName().equals(method.getName()) && m.getModifiers() == method.getModifiers() && Type.getSignature(m).equals(method.getSignature())) {\n-                return method;\n+    public Method getMethod(final java.lang.reflect.Method method) {\n+        for (final Method method2 : this.methods) {\n+            if (method.getName().equals(method2.getName()) && method.getModifiers() == method2.getModifiers() && Type.getSignature(method).equals(method2.getSignature())) {\n+                return method2;\n             }\n         }\n         return null;\n     }\n     \n     public Method[] getMethods() {\n         return this.methods;\n@@ -362,61 +362,60 @@\n         if (\"java.lang.Object\".equals(this.getClassName())) {\n             return null;\n         }\n         return this.repository.loadClass(this.getSuperclassName());\n     }\n     \n     public JavaClass[] getSuperClasses() throws ClassNotFoundException {\n-        JavaClass clazz = this;\n-        final List<JavaClass> allSuperClasses = new ArrayList<JavaClass>();\n-        for (clazz = clazz.getSuperClass(); clazz != null; clazz = clazz.getSuperClass()) {\n-            allSuperClasses.add(clazz);\n+        final ArrayList list = new ArrayList();\n+        for (JavaClass javaClass = this.getSuperClass(); javaClass != null; javaClass = javaClass.getSuperClass()) {\n+            list.add(javaClass);\n         }\n-        return allSuperClasses.toArray(JavaClass.EMPTY_ARRAY);\n+        return (JavaClass[])list.toArray(JavaClass.EMPTY_ARRAY);\n     }\n     \n     public String getSuperclassName() {\n         return this.superclassName;\n     }\n     \n     public int getSuperclassNameIndex() {\n         return this.superclassNameIndex;\n     }\n     \n     public int hashCode() {\n         return JavaClass.bcelComparator.hashCode((Object)this);\n     }\n     \n-    public boolean implementationOf(final JavaClass inter) throws ClassNotFoundException {\n-        if (!inter.isInterface()) {\n-            throw new IllegalArgumentException(inter.getClassName() + \" is no interface\");\n+    public boolean implementationOf(final JavaClass javaClass) throws ClassNotFoundException {\n+        if (!javaClass.isInterface()) {\n+            throw new IllegalArgumentException(javaClass.getClassName() + \" is no interface\");\n         }\n-        if (this.equals(inter)) {\n+        if (this.equals(javaClass)) {\n             return true;\n         }\n-        final JavaClass[] allInterfaces;\n-        final JavaClass[] superInterfaces = allInterfaces = this.getAllInterfaces();\n-        for (final JavaClass superInterface : allInterfaces) {\n-            if (superInterface.equals(inter)) {\n+        final JavaClass[] allInterfaces = this.getAllInterfaces();\n+        for (int length = allInterfaces.length, i = 0; i < length; ++i) {\n+            if (allInterfaces[i].equals(javaClass)) {\n                 return true;\n             }\n         }\n         return false;\n     }\n     \n-    public final boolean instanceOf(final JavaClass superclass) throws ClassNotFoundException {\n-        if (this.equals(superclass)) {\n+    public final boolean instanceOf(final JavaClass javaClass) throws ClassNotFoundException {\n+        if (this.equals(javaClass)) {\n             return true;\n         }\n-        for (final JavaClass clazz : this.getSuperClasses()) {\n-            if (clazz.equals(superclass)) {\n+        final JavaClass[] superClasses = this.getSuperClasses();\n+        for (int length = superClasses.length, i = 0; i < length; ++i) {\n+            if (superClasses[i].equals(javaClass)) {\n                 return true;\n             }\n         }\n-        return superclass.isInterface() && this.implementationOf(superclass);\n+        return javaClass.isInterface() && this.implementationOf(javaClass);\n     }\n     \n     public final boolean isAnonymous() {\n         this.computeNestedTypeStatus();\n         return this.isAnonymous;\n     }\n     \n@@ -490,61 +489,65 @@\n     }\n     \n     public void setSuperclassNameIndex(final int superclassNameIndex) {\n         this.superclassNameIndex = superclassNameIndex;\n     }\n     \n     public String toString() {\n-        String access = Utility.accessToString(super.getAccessFlags(), true);\n-        access = (access.isEmpty() ? \"\" : (access + \" \"));\n-        final StringBuilder buf = new StringBuilder(128);\n-        buf.append(access).append(Utility.classOrInterface(super.getAccessFlags())).append(\" \").append(this.className).append(\" extends \").append(Utility.compactClassName(this.superclassName, false)).append('\\n');\n-        final int size = this.interfaces.length;\n-        if (size > 0) {\n-            buf.append(\"implements\\t\\t\");\n-            for (int i = 0; i < size; ++i) {\n-                buf.append(this.interfaceNames[i]);\n-                if (i < size - 1) {\n-                    buf.append(\", \");\n+        final String accessToString = Utility.accessToString(super.getAccessFlags(), true);\n+        final String str = accessToString.isEmpty() ? \"\" : (accessToString + \" \");\n+        final StringBuilder sb = new StringBuilder(128);\n+        sb.append(str).append(Utility.classOrInterface(super.getAccessFlags())).append(\" \").append(this.className).append(\" extends \").append(Utility.compactClassName(this.superclassName, false)).append('\\n');\n+        final int length = this.interfaces.length;\n+        if (length > 0) {\n+            sb.append(\"implements\\t\\t\");\n+            for (int i = 0; i < length; ++i) {\n+                sb.append(this.interfaceNames[i]);\n+                if (i < length - 1) {\n+                    sb.append(\", \");\n                 }\n             }\n-            buf.append('\\n');\n+            sb.append('\\n');\n         }\n-        buf.append(\"file name\\t\\t\").append(this.fileName).append('\\n');\n-        buf.append(\"compiled from\\t\\t\").append(this.sourceFileName).append('\\n');\n-        buf.append(\"compiler version\\t\").append(this.major).append(\".\").append(this.minor).append('\\n');\n-        buf.append(\"access flags\\t\\t\").append(super.getAccessFlags()).append('\\n');\n-        buf.append(\"constant pool\\t\\t\").append(this.constantPool.getLength()).append(\" entries\\n\");\n-        buf.append(\"ACC_SUPER flag\\t\\t\").append(this.isSuper()).append(\"\\n\");\n+        sb.append(\"file name\\t\\t\").append(this.fileName).append('\\n');\n+        sb.append(\"compiled from\\t\\t\").append(this.sourceFileName).append('\\n');\n+        sb.append(\"compiler version\\t\").append(this.major).append(\".\").append(this.minor).append('\\n');\n+        sb.append(\"access flags\\t\\t\").append(super.getAccessFlags()).append('\\n');\n+        sb.append(\"constant pool\\t\\t\").append(this.constantPool.getLength()).append(\" entries\\n\");\n+        sb.append(\"ACC_SUPER flag\\t\\t\").append(this.isSuper()).append(\"\\n\");\n         if (this.attributes.length > 0) {\n-            buf.append(\"\\nAttribute(s):\\n\");\n-            for (final Attribute attribute : this.attributes) {\n-                buf.append(indent((Object)attribute));\n+            sb.append(\"\\nAttribute(s):\\n\");\n+            final Attribute[] attributes = this.attributes;\n+            for (int length2 = attributes.length, j = 0; j < length2; ++j) {\n+                sb.append(indent((Object)attributes[j]));\n             }\n         }\n-        final AnnotationEntry[] annotations = this.getAnnotationEntries();\n-        if (annotations != null && annotations.length > 0) {\n-            buf.append(\"\\nAnnotation(s):\\n\");\n-            for (final AnnotationEntry annotation : annotations) {\n-                buf.append(indent((Object)annotation));\n+        final AnnotationEntry[] annotationEntries = this.getAnnotationEntries();\n+        if (annotationEntries != null && annotationEntries.length > 0) {\n+            sb.append(\"\\nAnnotation(s):\\n\");\n+            final AnnotationEntry[] array = annotationEntries;\n+            for (int length3 = array.length, k = 0; k < length3; ++k) {\n+                sb.append(indent((Object)array[k]));\n             }\n         }\n         if (this.fields.length > 0) {\n-            buf.append(\"\\n\").append(this.fields.length).append(\" fields:\\n\");\n-            for (final Field field : this.fields) {\n-                buf.append(\"\\t\").append(field).append('\\n');\n+            sb.append(\"\\n\").append(this.fields.length).append(\" fields:\\n\");\n+            final Field[] fields = this.fields;\n+            for (int length4 = fields.length, l = 0; l < length4; ++l) {\n+                sb.append(\"\\t\").append(fields[l]).append('\\n');\n             }\n         }\n         if (this.methods.length > 0) {\n-            buf.append(\"\\n\").append(this.methods.length).append(\" methods:\\n\");\n-            for (final Method method : this.methods) {\n-                buf.append(\"\\t\").append(method).append('\\n');\n+            sb.append(\"\\n\").append(this.methods.length).append(\" methods:\\n\");\n+            final Method[] methods = this.methods;\n+            for (int length5 = methods.length, n = 0; n < length5; ++n) {\n+                sb.append(\"\\t\").append(methods[n]).append('\\n');\n             }\n         }\n-        return buf.toString();\n+        return sb.toString();\n     }\n     \n     static {\n         EMPTY_ARRAY = new JavaClass[0];\n         debug = Boolean.getBoolean(\"JavaClass.debug\");\n         JavaClass.bcelComparator = (BCELComparator)new JavaClass.JavaClass$1();\n     }\n"}]}
