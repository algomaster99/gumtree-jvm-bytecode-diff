{"diffoscope-json-version": 1, "source1": "first/ModifiedControlVariableCheck.class", "source2": "second/ModifiedControlVariableCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -6,16 +6,16 @@\n import java.util.List;\n import java.util.HashSet;\n import java.util.stream.Stream;\n import java.util.stream.Collector;\n import java.util.stream.Collectors;\n import java.util.function.Predicate;\n import java.util.Objects;\n-import java.util.Iterator;\n import java.util.Set;\n+import java.util.Iterator;\n import com.puppycrawl.tools.checkstyle.api.DetailAST;\n import java.util.ArrayDeque;\n import java.util.Deque;\n import java.util.BitSet;\n import com.puppycrawl.tools.checkstyle.FileStatefulCheck;\n import com.puppycrawl.tools.checkstyle.api.AbstractCheck;\n \n@@ -44,20 +44,20 @@\n         return new int[] { 6, 91, 37, 156, 80, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 129, 25, 130, 26 };\n     }\n     \n     public int[] getAcceptableTokens() {\n         return this.getRequiredTokens();\n     }\n     \n-    public void beginTree(final DetailAST rootAST) {\n+    public void beginTree(final DetailAST detailAST) {\n         this.variableStack.clear();\n     }\n     \n-    public void visitToken(final DetailAST ast) {\n-        switch (ast.getType()) {\n+    public void visitToken(final DetailAST detailAST) {\n+        switch (detailAST.getType()) {\n             case 6: {\n                 this.enterBlock();\n                 break;\n             }\n             case 37:\n             case 91:\n             case 156: {\n@@ -75,39 +75,38 @@\n             case 104:\n             case 105:\n             case 106:\n             case 107:\n             case 108:\n             case 129:\n             case 130: {\n-                this.checkIdent(ast);\n+                this.checkIdent(detailAST);\n                 break;\n             }\n             default: {\n-                throw new IllegalStateException(\"Illegal type of token: \" + ast);\n+                throw new IllegalStateException(\"Illegal type of token: \" + detailAST);\n             }\n         }\n     }\n     \n-    public void leaveToken(final DetailAST ast) {\n-        switch (ast.getType()) {\n+    public void leaveToken(final DetailAST detailAST) {\n+        switch (detailAST.getType()) {\n             case 37: {\n-                this.leaveForIter(ast.getParent());\n+                this.leaveForIter(detailAST.getParent());\n                 break;\n             }\n             case 156: {\n                 if (!this.skipEnhancedForLoopVariable) {\n-                    final DetailAST paramDef = ast.findFirstToken(10);\n-                    this.leaveForEach(paramDef);\n+                    this.leaveForEach(detailAST.findFirstToken(10));\n                     break;\n                 }\n                 break;\n             }\n             case 91: {\n-                this.leaveForDef(ast);\n+                this.leaveForDef(detailAST);\n                 break;\n             }\n             case 6: {\n                 this.exitBlock();\n                 break;\n             }\n             case 25:\n@@ -125,15 +124,15 @@\n             case 107:\n             case 108:\n             case 129:\n             case 130: {\n                 break;\n             }\n             default: {\n-                throw new IllegalStateException(\"Illegal type of token: \" + ast);\n+                throw new IllegalStateException(\"Illegal type of token: \" + detailAST);\n             }\n         }\n     }\n     \n     private void enterBlock() {\n         this.variableStack.push(new ArrayDeque<String>());\n     }\n@@ -142,95 +141,84 @@\n         this.variableStack.pop();\n     }\n     \n     private Deque<String> getCurrentVariables() {\n         return this.variableStack.peek();\n     }\n     \n-    private void checkIdent(final DetailAST ast) {\n+    private void checkIdent(final DetailAST detailAST) {\n         final Deque<String> currentVariables = this.getCurrentVariables();\n-        final DetailAST identAST = ast.getFirstChild();\n-        if (identAST != null && identAST.getType() == 58 && currentVariables.contains(identAST.getText())) {\n-            this.log(ast, \"modified.control.variable\", new Object[] { identAST.getText() });\n+        final DetailAST firstChild = detailAST.getFirstChild();\n+        if (firstChild != null && firstChild.getType() == 58 && currentVariables.contains(firstChild.getText())) {\n+            this.log(detailAST, \"modified.control.variable\", new Object[] { firstChild.getText() });\n         }\n     }\n     \n-    private void leaveForIter(final DetailAST ast) {\n-        final Set<String> variablesToPutInScope = getVariablesManagedByForLoop(ast);\n-        for (final String variableName : variablesToPutInScope) {\n-            this.getCurrentVariables().push(variableName);\n+    private void leaveForIter(final DetailAST detailAST) {\n+        final Iterator<String> iterator = getVariablesManagedByForLoop(detailAST).iterator();\n+        while (iterator.hasNext()) {\n+            this.getCurrentVariables().push(iterator.next());\n         }\n     }\n     \n-    private static Set<String> getVariablesManagedByForLoop(final DetailAST ast) {\n-        final Set<String> initializedVariables = getForInitVariables(ast);\n-        final Set<String> iteratingVariables = getForIteratorVariables(ast);\n-        final Stream<Object> stream = initializedVariables.stream();\n-        final Set<String> obj = iteratingVariables;\n+    private static Set<String> getVariablesManagedByForLoop(final DetailAST detailAST) {\n+        final Set<String> forInitVariables = getForInitVariables(detailAST);\n+        final Set<String> forIteratorVariables = getForIteratorVariables(detailAST);\n+        final Stream<Object> stream = forInitVariables.stream();\n+        final Set<String> obj = forIteratorVariables;\n         Objects.requireNonNull(obj);\n         return stream.filter(obj::contains).collect((Collector<? super Object, ?, Set<String>>)Collectors.toSet());\n     }\n     \n-    private void leaveForEach(final DetailAST paramDef) {\n-        final DetailAST paramName = paramDef.findFirstToken(58);\n-        this.getCurrentVariables().push(paramName.getText());\n+    private void leaveForEach(final DetailAST detailAST) {\n+        this.getCurrentVariables().push(detailAST.findFirstToken(58).getText());\n     }\n     \n-    private void leaveForDef(final DetailAST ast) {\n-        final DetailAST forInitAST = ast.findFirstToken(35);\n-        if (forInitAST == null) {\n+    private void leaveForDef(final DetailAST detailAST) {\n+        if (detailAST.findFirstToken(35) == null) {\n             if (!this.skipEnhancedForLoopVariable) {\n                 this.getCurrentVariables().pop();\n             }\n         }\n         else {\n-            final Set<String> variablesManagedByForLoop = getVariablesManagedByForLoop(ast);\n-            this.popCurrentVariables(variablesManagedByForLoop.size());\n+            this.popCurrentVariables(getVariablesManagedByForLoop(detailAST).size());\n         }\n     }\n     \n-    private void popCurrentVariables(final int count) {\n-        for (int i = 0; i < count; ++i) {\n+    private void popCurrentVariables(final int n) {\n+        for (int i = 0; i < n; ++i) {\n             this.getCurrentVariables().pop();\n         }\n     }\n     \n-    private static Set<String> getForInitVariables(final DetailAST ast) {\n-        final Set<String> initializedVariables = new HashSet<String>();\n-        final DetailAST forInitAST = ast.findFirstToken(35);\n-        for (DetailAST parameterDefAST = forInitAST.findFirstToken(10); parameterDefAST != null; parameterDefAST = parameterDefAST.getNextSibling()) {\n-            if (parameterDefAST.getType() == 10) {\n-                final DetailAST param = parameterDefAST.findFirstToken(58);\n-                initializedVariables.add(param.getText());\n-            }\n-        }\n-        return initializedVariables;\n-    }\n-    \n-    private static Set<String> getForIteratorVariables(final DetailAST ast) {\n-        final Set<String> iteratorVariables = new HashSet<String>();\n-        final DetailAST forIteratorAST = ast.findFirstToken(37);\n-        final DetailAST forUpdateListAST = forIteratorAST.findFirstToken(34);\n-        findChildrenOfExpressionType(forUpdateListAST).stream().filter(iteratingExpressionAST -> ModifiedControlVariableCheck.MUTATION_OPERATIONS.get(iteratingExpressionAST.getType())).forEach(iteratingExpressionAST -> {\n-            final DetailAST oneVariableOperatorChild = iteratingExpressionAST.getFirstChild();\n-            iteratorVariables.add(oneVariableOperatorChild.getText());\n-            return;\n-        });\n-        return iteratorVariables;\n-    }\n-    \n-    private static List<DetailAST> findChildrenOfExpressionType(final DetailAST ast) {\n-        final List<DetailAST> foundExpressions = new LinkedList<DetailAST>();\n-        if (ast != null) {\n-            for (DetailAST iteratingExpressionAST = ast.findFirstToken(28); iteratingExpressionAST != null; iteratingExpressionAST = iteratingExpressionAST.getNextSibling()) {\n-                if (iteratingExpressionAST.getType() == 28) {\n-                    foundExpressions.add(iteratingExpressionAST.getFirstChild());\n+    private static Set<String> getForInitVariables(final DetailAST detailAST) {\n+        final HashSet set = new HashSet();\n+        for (DetailAST detailAST2 = detailAST.findFirstToken(35).findFirstToken(10); detailAST2 != null; detailAST2 = detailAST2.getNextSibling()) {\n+            if (detailAST2.getType() == 10) {\n+                set.add(detailAST2.findFirstToken(58).getText());\n+            }\n+        }\n+        return set;\n+    }\n+    \n+    private static Set<String> getForIteratorVariables(final DetailAST detailAST) {\n+        final HashSet set = new HashSet();\n+        findChildrenOfExpressionType(detailAST.findFirstToken(37).findFirstToken(34)).stream().filter(detailAST2 -> ModifiedControlVariableCheck.MUTATION_OPERATIONS.get(detailAST2.getType())).forEach(detailAST3 -> set2.add(detailAST3.getFirstChild().getText()));\n+        return set;\n+    }\n+    \n+    private static List<DetailAST> findChildrenOfExpressionType(final DetailAST detailAST) {\n+        final LinkedList list = new LinkedList();\n+        if (detailAST != null) {\n+            for (DetailAST detailAST2 = detailAST.findFirstToken(28); detailAST2 != null; detailAST2 = detailAST2.getNextSibling()) {\n+                if (detailAST2.getType() == 28) {\n+                    list.add(detailAST2.getFirstChild());\n                 }\n             }\n         }\n-        return foundExpressions;\n+        return list;\n     }\n     \n     static {\n         MUTATION_OPERATIONS = TokenUtil.asBitSet(new int[] { 25, 26, 130, 129, 80 });\n     }\n }\n"}]}
