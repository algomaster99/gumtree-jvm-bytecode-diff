{"diffoscope-json-version": 1, "source1": "first/SerializationUtils.class", "source2": "second/SerializationUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -8,63 +8,60 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.ByteArrayInputStream;\n import java.io.Serializable;\n \n public class SerializationUtils\n {\n-    public static <T extends Serializable> T clone(final T object) {\n-        if (object == null) {\n+    public static <T extends Serializable> T clone(final T t) {\n+        if (t == null) {\n             return null;\n         }\n-        final byte[] objectData = serialize(object);\n-        final ByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n-        try (final SerializationUtils.ClassLoaderAwareObjectInputStream in = new SerializationUtils.ClassLoaderAwareObjectInputStream((InputStream)bais, object.getClass().getClassLoader())) {\n-            final Serializable s;\n-            final T readObject = (T)(s = (Serializable)in.readObject());\n+        final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(serialize(t));\n+        try (final SerializationUtils.ClassLoaderAwareObjectInputStream classLoaderAwareObjectInputStream = new SerializationUtils.ClassLoaderAwareObjectInputStream((InputStream)byteArrayInputStream, t.getClass().getClassLoader())) {\n+            final Serializable s = (Serializable)classLoaderAwareObjectInputStream.readObject();\n             return (T)s;\n         }\n         catch (final ClassNotFoundException ex) {\n             throw new SerializationException(\"ClassNotFoundException while reading cloned object data\", (Throwable)ex);\n         }\n         catch (final IOException ex2) {\n             throw new SerializationException(\"IOException while reading or closing cloned object data\", (Throwable)ex2);\n         }\n     }\n     \n-    public static <T extends Serializable> T roundtrip(final T msg) {\n-        return deserialize(serialize((Serializable)msg));\n+    public static <T extends Serializable> T roundtrip(final T t) {\n+        return deserialize(serialize((Serializable)t));\n     }\n     \n-    public static void serialize(final Serializable obj, final OutputStream outputStream) {\n-        Validate.isTrue(outputStream != null, \"The OutputStream must not be null\", new Object[0]);\n-        try (final ObjectOutputStream out = new ObjectOutputStream(outputStream)) {\n-            out.writeObject(obj);\n+    public static void serialize(final Serializable obj, final OutputStream out) {\n+        Validate.isTrue(out != null, \"The OutputStream must not be null\", new Object[0]);\n+        try (final ObjectOutputStream objectOutputStream = new ObjectOutputStream(out)) {\n+            objectOutputStream.writeObject(obj);\n         }\n         catch (final IOException ex) {\n             throw new SerializationException((Throwable)ex);\n         }\n     }\n     \n-    public static byte[] serialize(final Serializable obj) {\n-        final ByteArrayOutputStream baos = new ByteArrayOutputStream(512);\n-        serialize(obj, baos);\n-        return baos.toByteArray();\n+    public static byte[] serialize(final Serializable s) {\n+        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(512);\n+        serialize(s, byteArrayOutputStream);\n+        return byteArrayOutputStream.toByteArray();\n     }\n     \n-    public static <T> T deserialize(final InputStream inputStream) {\n-        Validate.isTrue(inputStream != null, \"The InputStream must not be null\", new Object[0]);\n-        try (final ObjectInputStream in = new ObjectInputStream(inputStream)) {\n-            final Object object;\n-            final T obj = (T)(object = in.readObject());\n+    public static <T> T deserialize(final InputStream in) {\n+        Validate.isTrue(in != null, \"The InputStream must not be null\", new Object[0]);\n+        try (final ObjectInputStream objectInputStream = new ObjectInputStream(in)) {\n+            final Object object = objectInputStream.readObject();\n             return (T)object;\n         }\n         catch (final ClassNotFoundException | IOException ex) {\n             throw new SerializationException((Throwable)ex);\n         }\n     }\n     \n-    public static <T> T deserialize(final byte[] objectData) {\n-        Validate.isTrue(objectData != null, \"The byte[] must not be null\", new Object[0]);\n-        return deserialize(new ByteArrayInputStream(objectData));\n+    public static <T> T deserialize(final byte[] buf) {\n+        Validate.isTrue(buf != null, \"The byte[] must not be null\", new Object[0]);\n+        return deserialize(new ByteArrayInputStream(buf));\n     }\n }\n"}]}
