{"diffoscope-json-version": 1, "source1": "first/InstructionFactory.class", "source2": "second/InstructionFactory.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -199,30 +199,30 @@\n             default: {\n                 throw new IllegalArgumentException(\"Invalid operand \" + op);\n             }\n         }\n     }\n     \n     public static ArithmeticInstruction createBinaryOperation(final String op, final Type type) {\n-        final char first = op.charAt(0);\n+        final char char1 = op.charAt(0);\n         switch (type.getType()) {\n             case 5:\n             case 8:\n             case 9:\n             case 10: {\n-                return createBinaryIntOp(first, op);\n+                return createBinaryIntOp(char1, op);\n             }\n             case 11: {\n-                return createBinaryLongOp(first, op);\n+                return createBinaryLongOp(char1, op);\n             }\n             case 6: {\n-                return createBinaryFloatOp(first);\n+                return createBinaryFloatOp(char1);\n             }\n             case 7: {\n-                return createBinaryDoubleOp(first);\n+                return createBinaryDoubleOp(char1);\n             }\n             default: {\n                 throw new IllegalArgumentException(\"Invalid type \" + type);\n             }\n         }\n     }\n     \n@@ -446,55 +446,55 @@\n     }\n     \n     public InstructionFactory(final ConstantPoolGen cp) {\n         this(null, cp);\n     }\n     \n     public Instruction createAppend(final Type type) {\n-        final byte t = type.getType();\n+        final byte type2 = type.getType();\n         if (isString(type)) {\n             return (Instruction)this.createInvoke(InstructionFactory.appendMethodObjects[0], (short)182);\n         }\n-        switch (t) {\n+        switch (type2) {\n             case 4:\n             case 5:\n             case 6:\n             case 7:\n             case 8:\n             case 9:\n             case 10:\n             case 11: {\n-                return (Instruction)this.createInvoke(InstructionFactory.appendMethodObjects[t], (short)182);\n+                return (Instruction)this.createInvoke(InstructionFactory.appendMethodObjects[type2], (short)182);\n             }\n             case 13:\n             case 14: {\n                 return (Instruction)this.createInvoke(InstructionFactory.appendMethodObjects[1], (short)182);\n             }\n             default: {\n                 throw new IllegalArgumentException(\"No append for this type? \" + type);\n             }\n         }\n     }\n     \n     public Instruction createCast(final Type srcType, final Type destType) {\n         if (srcType instanceof BasicType && destType instanceof BasicType) {\n-            final byte dest = destType.getType();\n-            byte src = srcType.getType();\n-            if (dest == 11 && (src == 5 || src == 8 || src == 9)) {\n-                src = 10;\n+            final byte type = destType.getType();\n+            int type2 = srcType.getType();\n+            if (type == 11 && (type2 == 5 || type2 == 8 || type2 == 9)) {\n+                type2 = 10;\n             }\n-            final String name = \"org.apache.bcel.generic.\" + InstructionFactory.shortNames[src - 5] + \"2\" + InstructionFactory.shortNames[dest - 5];\n-            Instruction i = null;\n+            final String string = \"org.apache.bcel.generic.\" + InstructionFactory.shortNames[type2 - 5] + \"2\" + InstructionFactory.shortNames[type - 5];\n+            Instruction instruction;\n             try {\n-                i = (Instruction)Class.forName(name).newInstance();\n+                instruction = (Instruction)Class.forName(string).newInstance();\n             }\n-            catch (final Exception e) {\n-                throw new IllegalArgumentException(\"Could not find instruction: \" + name, e);\n+            catch (final Exception cause) {\n+                throw new IllegalArgumentException(\"Could not find instruction: \" + string, cause);\n             }\n-            return i;\n+            return instruction;\n         }\n         if (!(srcType instanceof ReferenceType) || !(destType instanceof ReferenceType)) {\n             throw new IllegalArgumentException(\"Cannot cast \" + srcType + \" to \" + destType);\n         }\n         if (destType instanceof ArrayType) {\n             return (Instruction)new CHECKCAST(this.cp.addArrayClass((ArrayType)destType));\n         }\n@@ -525,28 +525,27 @@\n             }\n             push = new PUSH(this.cp, (Character)value);\n         }\n         return push.getInstruction();\n     }\n     \n     public FieldInstruction createFieldAccess(final String className, final String name, final Type type, final short kind) {\n-        final String signature = type.getSignature();\n-        final int index = this.cp.addFieldref(className, name, signature);\n+        final int addFieldref = this.cp.addFieldref(className, name, type.getSignature());\n         switch (kind) {\n             case 180: {\n-                return (FieldInstruction)new GETFIELD(index);\n+                return (FieldInstruction)new GETFIELD(addFieldref);\n             }\n             case 181: {\n-                return (FieldInstruction)new PUTFIELD(index);\n+                return (FieldInstruction)new PUTFIELD(addFieldref);\n             }\n             case 178: {\n-                return (FieldInstruction)new GETSTATIC(index);\n+                return (FieldInstruction)new GETSTATIC(addFieldref);\n             }\n             case 179: {\n-                return (FieldInstruction)new PUTSTATIC(index);\n+                return (FieldInstruction)new PUTSTATIC(addFieldref);\n             }\n             default: {\n                 throw new IllegalArgumentException(\"Unknown getfield kind:\" + kind);\n             }\n         }\n     }\n     \n@@ -573,41 +572,41 @@\n         return this.createInvoke(className, name, retType, argTypes, kind, kind == 185);\n     }\n     \n     public InvokeInstruction createInvoke(final String className, final String name, final Type retType, final Type[] argTypes, final short kind, final boolean useInterface) {\n         if (kind != 183 && kind != 182 && kind != 184 && kind != 185 && kind != 186) {\n             throw new IllegalArgumentException(\"Unknown invoke kind: \" + kind);\n         }\n-        int nargs = 0;\n-        final String signature = Type.getMethodSignature(retType, argTypes);\n-        for (final Type argType : argTypes) {\n-            nargs += argType.getSize();\n+        int n = 0;\n+        final String methodSignature = Type.getMethodSignature(retType, argTypes);\n+        for (int length = argTypes.length, i = 0; i < length; ++i) {\n+            n += argTypes[i].getSize();\n         }\n-        int index;\n+        int n2;\n         if (useInterface) {\n-            index = this.cp.addInterfaceMethodref(className, name, signature);\n+            n2 = this.cp.addInterfaceMethodref(className, name, methodSignature);\n         }\n         else {\n-            index = this.cp.addMethodref(className, name, signature);\n+            n2 = this.cp.addMethodref(className, name, methodSignature);\n         }\n         switch (kind) {\n             case 183: {\n-                return (InvokeInstruction)new INVOKESPECIAL(index);\n+                return (InvokeInstruction)new INVOKESPECIAL(n2);\n             }\n             case 182: {\n-                return (InvokeInstruction)new INVOKEVIRTUAL(index);\n+                return (InvokeInstruction)new INVOKEVIRTUAL(n2);\n             }\n             case 184: {\n-                return (InvokeInstruction)new INVOKESTATIC(index);\n+                return (InvokeInstruction)new INVOKESTATIC(n2);\n             }\n             case 185: {\n-                return (InvokeInstruction)new INVOKEINTERFACE(index, nargs + 1);\n+                return (InvokeInstruction)new INVOKEINTERFACE(n2, n + 1);\n             }\n             case 186: {\n-                return (InvokeInstruction)new INVOKEDYNAMIC(index);\n+                return (InvokeInstruction)new INVOKEDYNAMIC(n2);\n             }\n             default: {\n                 throw new IllegalStateException(\"Unknown invoke kind: \" + kind);\n             }\n         }\n     }\n     \n@@ -617,39 +616,38 @@\n     \n     public NEW createNew(final String s) {\n         return this.createNew(ObjectType.getInstance(s));\n     }\n     \n     public Instruction createNewArray(final Type t, final short dim) {\n         if (dim != 1) {\n-            ArrayType at;\n+            ArrayType arrayType;\n             if (t instanceof ArrayType) {\n-                at = (ArrayType)t;\n+                arrayType = (ArrayType)t;\n             }\n             else {\n-                at = new ArrayType(t, (int)dim);\n+                arrayType = new ArrayType(t, (int)dim);\n             }\n-            return (Instruction)new MULTIANEWARRAY(this.cp.addArrayClass(at), dim);\n+            return (Instruction)new MULTIANEWARRAY(this.cp.addArrayClass(arrayType), dim);\n         }\n         if (t instanceof ObjectType) {\n             return (Instruction)new ANEWARRAY(this.cp.addClass((ObjectType)t));\n         }\n         if (t instanceof ArrayType) {\n             return (Instruction)new ANEWARRAY(this.cp.addArrayClass((ArrayType)t));\n         }\n         return (Instruction)new NEWARRAY(t.getType());\n     }\n     \n     public InstructionList createPrintln(final String s) {\n-        final InstructionList il = new InstructionList();\n-        il.append((Instruction)this.createGetStatic(\"java.lang.System\", \"out\", Type.getType(\"Ljava/io/PrintStream;\")));\n-        il.append((CompoundInstruction)new PUSH(this.cp, s));\n-        final InstructionFactory.MethodObject methodObject = new InstructionFactory.MethodObject(\"java.io.PrintStream\", \"println\", (Type)Type.VOID, new Type[] { Type.getType(\"Ljava/lang/String;\") });\n-        il.append((Instruction)this.createInvoke(methodObject, (short)182));\n-        return il;\n+        final InstructionList list = new InstructionList();\n+        list.append((Instruction)this.createGetStatic(\"java.lang.System\", \"out\", Type.getType(\"Ljava/io/PrintStream;\")));\n+        list.append((CompoundInstruction)new PUSH(this.cp, s));\n+        list.append((Instruction)this.createInvoke(new InstructionFactory.MethodObject(\"java.io.PrintStream\", \"println\", (Type)Type.VOID, new Type[] { Type.getType(\"Ljava/lang/String;\") }), (short)182));\n+        return list;\n     }\n     \n     public PUTFIELD createPutField(final String className, final String name, final Type t) {\n         return new PUTFIELD(this.cp.addFieldref(className, name, t.getSignature()));\n     }\n     \n     public PUTSTATIC createPutStatic(final String className, final String name, final Type t) {\n"}]}
