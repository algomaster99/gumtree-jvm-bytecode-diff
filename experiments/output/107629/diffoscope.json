{"diffoscope-json-version": 1, "source1": "first/SerializationUtils.class", "source2": "second/SerializationUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -14,18 +14,40 @@\n {\n     public static <T extends Serializable> T clone(final T object) {\n         if (object == null) {\n             return null;\n         }\n         final byte[] objectData = serialize(object);\n         final ByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n-        try (final SerializationUtils.ClassLoaderAwareObjectInputStream in = new SerializationUtils.ClassLoaderAwareObjectInputStream((InputStream)bais, object.getClass().getClassLoader())) {\n-            final Serializable s;\n-            final T readObject = (T)(s = (Serializable)in.readObject());\n-            return (T)s;\n+        try {\n+            Throwable t = null;\n+            try {\n+                final SerializationUtils.ClassLoaderAwareObjectInputStream in = new SerializationUtils.ClassLoaderAwareObjectInputStream((InputStream)bais, object.getClass().getClassLoader());\n+                try {\n+                    final T readObject = (T)in.readObject();\n+                    return readObject;\n+                }\n+                finally {\n+                    if (in != null) {\n+                        in.close();\n+                    }\n+                }\n+            }\n+            finally {\n+                if (t == null) {\n+                    final Throwable exception;\n+                    t = exception;\n+                }\n+                else {\n+                    final Throwable exception;\n+                    if (t != exception) {\n+                        t.addSuppressed(exception);\n+                    }\n+                }\n+            }\n         }\n         catch (final ClassNotFoundException ex) {\n             throw new SerializationException(\"ClassNotFoundException while reading cloned object data\", (Throwable)ex);\n         }\n         catch (final IOException ex2) {\n             throw new SerializationException(\"IOException while reading or closing cloned object data\", (Throwable)ex2);\n         }\n@@ -33,34 +55,79 @@\n     \n     public static <T extends Serializable> T roundtrip(final T msg) {\n         return deserialize(serialize((Serializable)msg));\n     }\n     \n     public static void serialize(final Serializable obj, final OutputStream outputStream) {\n         Validate.notNull((Object)outputStream, \"The OutputStream must not be null\", new Object[0]);\n-        try (final ObjectOutputStream out = new ObjectOutputStream(outputStream)) {\n-            out.writeObject(obj);\n+        try {\n+            Throwable t = null;\n+            try {\n+                final ObjectOutputStream out = new ObjectOutputStream(outputStream);\n+                try {\n+                    out.writeObject(obj);\n+                }\n+                finally {\n+                    if (out != null) {\n+                        out.close();\n+                    }\n+                }\n+            }\n+            finally {\n+                if (t == null) {\n+                    final Throwable exception;\n+                    t = exception;\n+                }\n+                else {\n+                    final Throwable exception;\n+                    if (t != exception) {\n+                        t.addSuppressed(exception);\n+                    }\n+                }\n+            }\n         }\n         catch (final IOException ex) {\n             throw new SerializationException((Throwable)ex);\n         }\n     }\n     \n     public static byte[] serialize(final Serializable obj) {\n         final ByteArrayOutputStream baos = new ByteArrayOutputStream(512);\n         serialize(obj, baos);\n         return baos.toByteArray();\n     }\n     \n     public static <T> T deserialize(final InputStream inputStream) {\n         Validate.notNull((Object)inputStream, \"The InputStream must not be null\", new Object[0]);\n-        try (final ObjectInputStream in = new ObjectInputStream(inputStream)) {\n-            final Object object;\n-            final T obj = (T)(object = in.readObject());\n-            return (T)object;\n+        try {\n+            Throwable t = null;\n+            try {\n+                final ObjectInputStream in = new ObjectInputStream(inputStream);\n+                try {\n+                    final T obj = (T)in.readObject();\n+                    return obj;\n+                }\n+                finally {\n+                    if (in != null) {\n+                        in.close();\n+                    }\n+                }\n+            }\n+            finally {\n+                if (t == null) {\n+                    final Throwable exception;\n+                    t = exception;\n+                }\n+                else {\n+                    final Throwable exception;\n+                    if (t != exception) {\n+                        t.addSuppressed(exception);\n+                    }\n+                }\n+            }\n         }\n         catch (final ClassNotFoundException | IOException ex) {\n             throw new SerializationException((Throwable)ex);\n         }\n     }\n     \n     public static <T> T deserialize(final byte[] objectData) {\n"}]}
