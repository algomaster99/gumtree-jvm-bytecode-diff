{"diffoscope-json-version": 1, "source1": "first/InstConstraintVisitor.class", "source2": "second/InstConstraintVisitor.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -175,15 +175,14 @@\n import org.apache.bcel.classfile.ConstantFieldref;\n import org.apache.bcel.generic.FieldInstruction;\n import org.apache.bcel.verifier.exc.AssertionViolatedException;\n import org.apache.bcel.generic.CPInstruction;\n import org.apache.bcel.generic.StackProducer;\n import org.apache.bcel.generic.StackConsumer;\n import org.apache.bcel.verifier.VerificationResult;\n-import org.apache.bcel.verifier.Verifier;\n import org.apache.bcel.verifier.VerifierFactory;\n import org.apache.bcel.generic.LoadClass;\n import org.apache.bcel.generic.ArrayType;\n import org.apache.bcel.generic.ReferenceType;\n import org.apache.bcel.generic.Type;\n import org.apache.bcel.verifier.exc.StructuralCodeConstraintException;\n import org.apache.bcel.generic.Instruction;\n@@ -209,1758 +208,1721 @@\n         return this.frame.getStack();\n     }\n     \n     private LocalVariables locals() {\n         return this.frame.getLocals();\n     }\n     \n-    private void constraintViolated(final Instruction violator, final String description) {\n-        final String fq_classname = violator.getClass().getName();\n-        throw new StructuralCodeConstraintException(\"Instruction \" + fq_classname.substring(fq_classname.lastIndexOf(46) + 1) + \" constraint violated: \" + description);\n+    private void constraintViolated(final Instruction instruction, final String str) {\n+        final String name = instruction.getClass().getName();\n+        throw new StructuralCodeConstraintException(\"Instruction \" + name.substring(name.lastIndexOf(46) + 1) + \" constraint violated: \" + str);\n     }\n     \n-    public void setFrame(final Frame f) {\n-        this.frame = f;\n+    public void setFrame(final Frame frame) {\n+        this.frame = frame;\n     }\n     \n     public void setConstantPoolGen(final ConstantPoolGen cpg) {\n         this.cpg = cpg;\n     }\n     \n     public void setMethodGen(final MethodGen mg) {\n         this.mg = mg;\n     }\n     \n-    private void indexOfInt(final Instruction o, final Type index) {\n-        if (!index.equals((Object)Type.INT)) {\n-            this.constraintViolated(o, \"The 'index' is not of type int but of type \" + index + \".\");\n+    private void indexOfInt(final Instruction instruction, final Type obj) {\n+        if (!obj.equals((Object)Type.INT)) {\n+            this.constraintViolated(instruction, \"The 'index' is not of type int but of type \" + obj + \".\");\n         }\n     }\n     \n-    private void referenceTypeIsInitialized(final Instruction o, final ReferenceType r) {\n-        if (r instanceof UninitializedObjectType) {\n-            this.constraintViolated(o, \"Working on an uninitialized object '\" + r + \"'.\");\n+    private void referenceTypeIsInitialized(final Instruction instruction, final ReferenceType obj) {\n+        if (obj instanceof UninitializedObjectType) {\n+            this.constraintViolated(instruction, \"Working on an uninitialized object '\" + obj + \"'.\");\n         }\n     }\n     \n-    private void valueOfInt(final Instruction o, final Type value) {\n-        if (!value.equals((Object)Type.INT)) {\n-            this.constraintViolated(o, \"The 'value' is not of type int but of type \" + value + \".\");\n+    private void valueOfInt(final Instruction instruction, final Type obj) {\n+        if (!obj.equals((Object)Type.INT)) {\n+            this.constraintViolated(instruction, \"The 'value' is not of type int but of type \" + obj + \".\");\n         }\n     }\n     \n-    private boolean arrayrefOfArrayType(final Instruction o, final Type arrayref) {\n-        if (!(arrayref instanceof ArrayType) && !arrayref.equals((Object)Type.NULL)) {\n-            this.constraintViolated(o, \"The 'arrayref' does not refer to an array but is of type \" + arrayref + \".\");\n+    private boolean arrayrefOfArrayType(final Instruction instruction, final Type obj) {\n+        if (!(obj instanceof ArrayType) && !obj.equals((Object)Type.NULL)) {\n+            this.constraintViolated(instruction, \"The 'arrayref' does not refer to an array but is of type \" + obj + \".\");\n         }\n-        return arrayref instanceof ArrayType;\n+        return obj instanceof ArrayType;\n     }\n     \n-    private void _visitStackAccessor(final Instruction o) {\n-        final int consume = o.consumeStack(this.cpg);\n-        if (consume > this.stack().slotsUsed()) {\n-            this.constraintViolated(o, \"Cannot consume \" + consume + \" stack slots: only \" + this.stack().slotsUsed() + \" slot(s) left on stack!\\nStack:\\n\" + this.stack());\n+    private void _visitStackAccessor(final Instruction instruction) {\n+        final int consumeStack = instruction.consumeStack(this.cpg);\n+        if (consumeStack > this.stack().slotsUsed()) {\n+            this.constraintViolated(instruction, \"Cannot consume \" + consumeStack + \" stack slots: only \" + this.stack().slotsUsed() + \" slot(s) left on stack!\\nStack:\\n\" + this.stack());\n         }\n-        final int produce = o.produceStack(this.cpg) - o.consumeStack(this.cpg);\n-        if (produce + this.stack().slotsUsed() > this.stack().maxStack()) {\n-            this.constraintViolated(o, \"Cannot produce \" + produce + \" stack slots: only \" + (this.stack().maxStack() - this.stack().slotsUsed()) + \" free stack slot(s) left.\\nStack:\\n\" + this.stack());\n+        final int i = instruction.produceStack(this.cpg) - instruction.consumeStack(this.cpg);\n+        if (i + this.stack().slotsUsed() > this.stack().maxStack()) {\n+            this.constraintViolated(instruction, \"Cannot produce \" + i + \" stack slots: only \" + (this.stack().maxStack() - this.stack().slotsUsed()) + \" free stack slot(s) left.\\nStack:\\n\" + this.stack());\n         }\n     }\n     \n-    public void visitLoadClass(final LoadClass o) {\n-        final ObjectType t = o.getLoadClassType(this.cpg);\n-        if (t != null) {\n-            final Verifier v = VerifierFactory.getVerifier(t.getClassName());\n-            final VerificationResult vr = v.doPass2();\n-            if (vr.getStatus() != 1) {\n-                this.constraintViolated((Instruction)o, \"Class '\" + o.getLoadClassType(this.cpg).getClassName() + \"' is referenced, but cannot be loaded and resolved: '\" + vr + \"'.\");\n+    public void visitLoadClass(final LoadClass loadClass) {\n+        final ObjectType loadClassType = loadClass.getLoadClassType(this.cpg);\n+        if (loadClassType != null) {\n+            final VerificationResult doPass2 = VerifierFactory.getVerifier(loadClassType.getClassName()).doPass2();\n+            if (doPass2.getStatus() != 1) {\n+                this.constraintViolated((Instruction)loadClass, \"Class '\" + loadClass.getLoadClassType(this.cpg).getClassName() + \"' is referenced, but cannot be loaded and resolved: '\" + doPass2 + \"'.\");\n             }\n         }\n     }\n     \n-    public void visitStackConsumer(final StackConsumer o) {\n-        this._visitStackAccessor((Instruction)o);\n+    public void visitStackConsumer(final StackConsumer stackConsumer) {\n+        this._visitStackAccessor((Instruction)stackConsumer);\n     }\n     \n-    public void visitStackProducer(final StackProducer o) {\n-        this._visitStackAccessor((Instruction)o);\n+    public void visitStackProducer(final StackProducer stackProducer) {\n+        this._visitStackAccessor((Instruction)stackProducer);\n     }\n     \n-    public void visitCPInstruction(final CPInstruction o) {\n-        final int idx = o.getIndex();\n-        if (idx < 0 || idx >= this.cpg.getSize()) {\n-            throw new AssertionViolatedException(\"Huh?! Constant pool index of instruction '\" + o + \"' illegal? Pass 3a should have checked this!\");\n+    public void visitCPInstruction(final CPInstruction obj) {\n+        final int index = obj.getIndex();\n+        if (index < 0 || index >= this.cpg.getSize()) {\n+            throw new AssertionViolatedException(\"Huh?! Constant pool index of instruction '\" + obj + \"' illegal? Pass 3a should have checked this!\");\n         }\n     }\n     \n-    public void visitFieldInstruction(final FieldInstruction o) {\n-        final Constant c = this.cpg.getConstant(o.getIndex());\n-        if (!(c instanceof ConstantFieldref)) {\n-            this.constraintViolated((Instruction)o, \"Index '\" + o.getIndex() + \"' should refer to a CONSTANT_Fieldref_info structure, but refers to '\" + c + \"'.\");\n+    public void visitFieldInstruction(final FieldInstruction fieldInstruction) {\n+        final Constant constant = this.cpg.getConstant(fieldInstruction.getIndex());\n+        if (!(constant instanceof ConstantFieldref)) {\n+            this.constraintViolated((Instruction)fieldInstruction, \"Index '\" + fieldInstruction.getIndex() + \"' should refer to a CONSTANT_Fieldref_info structure, but refers to '\" + constant + \"'.\");\n         }\n-        final Type t = o.getType(this.cpg);\n-        if (t instanceof ObjectType) {\n-            final String name = ((ObjectType)t).getClassName();\n-            final Verifier v = VerifierFactory.getVerifier(name);\n-            final VerificationResult vr = v.doPass2();\n-            if (vr.getStatus() != 1) {\n-                this.constraintViolated((Instruction)o, \"Class '\" + name + \"' is referenced, but cannot be loaded and resolved: '\" + vr + \"'.\");\n+        final Type type = fieldInstruction.getType(this.cpg);\n+        if (type instanceof ObjectType) {\n+            final String className = ((ObjectType)type).getClassName();\n+            final VerificationResult doPass2 = VerifierFactory.getVerifier(className).doPass2();\n+            if (doPass2.getStatus() != 1) {\n+                this.constraintViolated((Instruction)fieldInstruction, \"Class '\" + className + \"' is referenced, but cannot be loaded and resolved: '\" + doPass2 + \"'.\");\n             }\n         }\n     }\n     \n-    public void visitInvokeInstruction(final InvokeInstruction o) {\n+    public void visitInvokeInstruction(final InvokeInstruction invokeInstruction) {\n     }\n     \n-    public void visitStackInstruction(final StackInstruction o) {\n-        this._visitStackAccessor((Instruction)o);\n+    public void visitStackInstruction(final StackInstruction stackInstruction) {\n+        this._visitStackAccessor((Instruction)stackInstruction);\n     }\n     \n-    public void visitLocalVariableInstruction(final LocalVariableInstruction o) {\n-        if (this.locals().maxLocals() <= ((o.getType(this.cpg).getSize() == 1) ? o.getIndex() : (o.getIndex() + 1))) {\n-            this.constraintViolated((Instruction)o, \"The 'index' is not a valid index into the local variable array.\");\n+    public void visitLocalVariableInstruction(final LocalVariableInstruction localVariableInstruction) {\n+        if (this.locals().maxLocals() <= ((localVariableInstruction.getType(this.cpg).getSize() == 1) ? localVariableInstruction.getIndex() : (localVariableInstruction.getIndex() + 1))) {\n+            this.constraintViolated((Instruction)localVariableInstruction, \"The 'index' is not a valid index into the local variable array.\");\n         }\n     }\n     \n-    public void visitLoadInstruction(final LoadInstruction o) {\n-        if (this.locals().get(o.getIndex()) == Type.UNKNOWN) {\n-            this.constraintViolated((Instruction)o, \"Read-Access on local variable \" + o.getIndex() + \" with unknown content.\");\n+    public void visitLoadInstruction(final LoadInstruction loadInstruction) {\n+        if (this.locals().get(loadInstruction.getIndex()) == Type.UNKNOWN) {\n+            this.constraintViolated((Instruction)loadInstruction, \"Read-Access on local variable \" + loadInstruction.getIndex() + \" with unknown content.\");\n         }\n-        if (o.getType(this.cpg).getSize() == 2 && this.locals().get(o.getIndex() + 1) != Type.UNKNOWN) {\n-            this.constraintViolated((Instruction)o, \"Reading a two-locals value from local variables \" + o.getIndex() + \" and \" + (o.getIndex() + 1) + \" where the latter one is destroyed.\");\n+        if (loadInstruction.getType(this.cpg).getSize() == 2 && this.locals().get(loadInstruction.getIndex() + 1) != Type.UNKNOWN) {\n+            this.constraintViolated((Instruction)loadInstruction, \"Reading a two-locals value from local variables \" + loadInstruction.getIndex() + \" and \" + (loadInstruction.getIndex() + 1) + \" where the latter one is destroyed.\");\n         }\n-        if (!(o instanceof ALOAD)) {\n-            if (this.locals().get(o.getIndex()) != o.getType(this.cpg)) {\n-                this.constraintViolated((Instruction)o, \"Local Variable type and LOADing Instruction type mismatch: Local Variable: '\" + this.locals().get(o.getIndex()) + \"'; Instruction type: '\" + o.getType(this.cpg) + \"'.\");\n+        if (!(loadInstruction instanceof ALOAD)) {\n+            if (this.locals().get(loadInstruction.getIndex()) != loadInstruction.getType(this.cpg)) {\n+                this.constraintViolated((Instruction)loadInstruction, \"Local Variable type and LOADing Instruction type mismatch: Local Variable: '\" + this.locals().get(loadInstruction.getIndex()) + \"'; Instruction type: '\" + loadInstruction.getType(this.cpg) + \"'.\");\n             }\n         }\n-        else if (!(this.locals().get(o.getIndex()) instanceof ReferenceType)) {\n-            this.constraintViolated((Instruction)o, \"Local Variable type and LOADing Instruction type mismatch: Local Variable: '\" + this.locals().get(o.getIndex()) + \"'; Instruction expects a ReferenceType.\");\n+        else if (!(this.locals().get(loadInstruction.getIndex()) instanceof ReferenceType)) {\n+            this.constraintViolated((Instruction)loadInstruction, \"Local Variable type and LOADing Instruction type mismatch: Local Variable: '\" + this.locals().get(loadInstruction.getIndex()) + \"'; Instruction expects a ReferenceType.\");\n         }\n-        if (this.stack().maxStack() - this.stack().slotsUsed() < o.getType(this.cpg).getSize()) {\n-            this.constraintViolated((Instruction)o, \"Not enough free stack slots to load a '\" + o.getType(this.cpg) + \"' onto the OperandStack.\");\n+        if (this.stack().maxStack() - this.stack().slotsUsed() < loadInstruction.getType(this.cpg).getSize()) {\n+            this.constraintViolated((Instruction)loadInstruction, \"Not enough free stack slots to load a '\" + loadInstruction.getType(this.cpg) + \"' onto the OperandStack.\");\n         }\n     }\n     \n-    public void visitStoreInstruction(final StoreInstruction o) {\n+    public void visitStoreInstruction(final StoreInstruction storeInstruction) {\n         if (this.stack().isEmpty()) {\n-            this.constraintViolated((Instruction)o, \"Cannot STORE: Stack to read from is empty.\");\n+            this.constraintViolated((Instruction)storeInstruction, \"Cannot STORE: Stack to read from is empty.\");\n         }\n-        if (!(o instanceof ASTORE)) {\n-            if (this.stack().peek() != o.getType(this.cpg)) {\n-                this.constraintViolated((Instruction)o, \"Stack top type and STOREing Instruction type mismatch: Stack top: '\" + this.stack().peek() + \"'; Instruction type: '\" + o.getType(this.cpg) + \"'.\");\n+        if (!(storeInstruction instanceof ASTORE)) {\n+            if (this.stack().peek() != storeInstruction.getType(this.cpg)) {\n+                this.constraintViolated((Instruction)storeInstruction, \"Stack top type and STOREing Instruction type mismatch: Stack top: '\" + this.stack().peek() + \"'; Instruction type: '\" + storeInstruction.getType(this.cpg) + \"'.\");\n             }\n         }\n         else {\n-            final Type stacktop = this.stack().peek();\n-            if (!(stacktop instanceof ReferenceType) && !(stacktop instanceof ReturnaddressType)) {\n-                this.constraintViolated((Instruction)o, \"Stack top type and STOREing Instruction type mismatch: Stack top: '\" + this.stack().peek() + \"'; Instruction expects a ReferenceType or a ReturnadressType.\");\n+            final Type peek = this.stack().peek();\n+            if (!(peek instanceof ReferenceType) && !(peek instanceof ReturnaddressType)) {\n+                this.constraintViolated((Instruction)storeInstruction, \"Stack top type and STOREing Instruction type mismatch: Stack top: '\" + this.stack().peek() + \"'; Instruction expects a ReferenceType or a ReturnadressType.\");\n             }\n         }\n     }\n     \n-    public void visitReturnInstruction(final ReturnInstruction o) {\n-        Type method_type = this.mg.getType();\n-        if (method_type == Type.BOOLEAN || method_type == Type.BYTE || method_type == Type.SHORT || method_type == Type.CHAR) {\n-            method_type = (Type)Type.INT;\n+    public void visitReturnInstruction(final ReturnInstruction returnInstruction) {\n+        Object obj = this.mg.getType();\n+        if (obj == Type.BOOLEAN || obj == Type.BYTE || obj == Type.SHORT || obj == Type.CHAR) {\n+            obj = Type.INT;\n         }\n-        if (o instanceof RETURN) {\n-            if (method_type == Type.VOID) {\n+        if (returnInstruction instanceof RETURN) {\n+            if (obj == Type.VOID) {\n                 return;\n             }\n-            this.constraintViolated((Instruction)o, \"RETURN instruction in non-void method.\");\n+            this.constraintViolated((Instruction)returnInstruction, \"RETURN instruction in non-void method.\");\n         }\n-        if (o instanceof ARETURN) {\n-            if (method_type == Type.VOID) {\n-                this.constraintViolated((Instruction)o, \"ARETURN instruction in void method.\");\n+        if (returnInstruction instanceof ARETURN) {\n+            if (obj == Type.VOID) {\n+                this.constraintViolated((Instruction)returnInstruction, \"ARETURN instruction in void method.\");\n             }\n             if (this.stack().peek() == Type.NULL) {\n                 return;\n             }\n             if (!(this.stack().peek() instanceof ReferenceType)) {\n-                this.constraintViolated((Instruction)o, \"Reference type expected on top of stack, but is: '\" + this.stack().peek() + \"'.\");\n+                this.constraintViolated((Instruction)returnInstruction, \"Reference type expected on top of stack, but is: '\" + this.stack().peek() + \"'.\");\n             }\n-            this.referenceTypeIsInitialized((Instruction)o, (ReferenceType)this.stack().peek());\n+            this.referenceTypeIsInitialized((Instruction)returnInstruction, (ReferenceType)this.stack().peek());\n         }\n-        else if (!method_type.equals((Object)this.stack().peek())) {\n-            this.constraintViolated((Instruction)o, \"Current method has return type of '\" + this.mg.getType() + \"' expecting a '\" + method_type + \"' on top of the stack. But stack top is a '\" + this.stack().peek() + \"'.\");\n+        else if (!((Type)obj).equals((Object)this.stack().peek())) {\n+            this.constraintViolated((Instruction)returnInstruction, \"Current method has return type of '\" + this.mg.getType() + \"' expecting a '\" + obj + \"' on top of the stack. But stack top is a '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitAALOAD(final AALOAD o) {\n-        final Type arrayref = this.stack().peek(1);\n-        final Type index = this.stack().peek(0);\n-        this.indexOfInt((Instruction)o, index);\n-        if (this.arrayrefOfArrayType((Instruction)o, arrayref) && !(((ArrayType)arrayref).getElementType() instanceof ReferenceType)) {\n-            this.constraintViolated((Instruction)o, \"The 'arrayref' does not refer to an array with elements of a ReferenceType but to an array of \" + ((ArrayType)arrayref).getElementType() + \".\");\n+    public void visitAALOAD(final AALOAD aaload) {\n+        final Type peek = this.stack().peek(1);\n+        this.indexOfInt((Instruction)aaload, this.stack().peek(0));\n+        if (this.arrayrefOfArrayType((Instruction)aaload, peek) && !(((ArrayType)peek).getElementType() instanceof ReferenceType)) {\n+            this.constraintViolated((Instruction)aaload, \"The 'arrayref' does not refer to an array with elements of a ReferenceType but to an array of \" + ((ArrayType)peek).getElementType() + \".\");\n         }\n     }\n     \n-    public void visitAASTORE(final AASTORE o) {\n-        final Type arrayref = this.stack().peek(2);\n-        final Type index = this.stack().peek(1);\n-        final Type value = this.stack().peek(0);\n-        this.indexOfInt((Instruction)o, index);\n-        if (!(value instanceof ReferenceType)) {\n-            this.constraintViolated((Instruction)o, \"The 'value' is not of a ReferenceType but of type \" + value + \".\");\n+    public void visitAASTORE(final AASTORE aastore) {\n+        final Type peek = this.stack().peek(2);\n+        final Type peek2 = this.stack().peek(1);\n+        final Type peek3 = this.stack().peek(0);\n+        this.indexOfInt((Instruction)aastore, peek2);\n+        if (!(peek3 instanceof ReferenceType)) {\n+            this.constraintViolated((Instruction)aastore, \"The 'value' is not of a ReferenceType but of type \" + peek3 + \".\");\n         }\n-        if (this.arrayrefOfArrayType((Instruction)o, arrayref) && !(((ArrayType)arrayref).getElementType() instanceof ReferenceType)) {\n-            this.constraintViolated((Instruction)o, \"The 'arrayref' does not refer to an array with elements of a ReferenceType but to an array of \" + ((ArrayType)arrayref).getElementType() + \".\");\n+        if (this.arrayrefOfArrayType((Instruction)aastore, peek) && !(((ArrayType)peek).getElementType() instanceof ReferenceType)) {\n+            this.constraintViolated((Instruction)aastore, \"The 'arrayref' does not refer to an array with elements of a ReferenceType but to an array of \" + ((ArrayType)peek).getElementType() + \".\");\n         }\n     }\n     \n-    public void visitACONST_NULL(final ACONST_NULL o) {\n+    public void visitACONST_NULL(final ACONST_NULL aconst_NULL) {\n     }\n     \n-    public void visitALOAD(final ALOAD o) {\n+    public void visitALOAD(final ALOAD aload) {\n     }\n     \n-    public void visitANEWARRAY(final ANEWARRAY o) {\n+    public void visitANEWARRAY(final ANEWARRAY anewarray) {\n         if (!this.stack().peek().equals((Object)Type.INT)) {\n-            this.constraintViolated((Instruction)o, \"The 'count' at the stack top is not of type '\" + Type.INT + \"' but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)anewarray, \"The 'count' at the stack top is not of type '\" + Type.INT + \"' but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitARETURN(final ARETURN o) {\n+    public void visitARETURN(final ARETURN areturn) {\n         if (!(this.stack().peek() instanceof ReferenceType)) {\n-            this.constraintViolated((Instruction)o, \"The 'objectref' at the stack top is not of a ReferenceType but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)areturn, \"The 'objectref' at the stack top is not of a ReferenceType but of type '\" + this.stack().peek() + \"'.\");\n         }\n-        final ReferenceType objectref = (ReferenceType)this.stack().peek();\n-        this.referenceTypeIsInitialized((Instruction)o, objectref);\n+        this.referenceTypeIsInitialized((Instruction)areturn, (ReferenceType)this.stack().peek());\n     }\n     \n-    public void visitARRAYLENGTH(final ARRAYLENGTH o) {\n-        final Type arrayref = this.stack().peek(0);\n-        this.arrayrefOfArrayType((Instruction)o, arrayref);\n+    public void visitARRAYLENGTH(final ARRAYLENGTH arraylength) {\n+        this.arrayrefOfArrayType((Instruction)arraylength, this.stack().peek(0));\n     }\n     \n-    public void visitASTORE(final ASTORE o) {\n+    public void visitASTORE(final ASTORE astore) {\n         if (!(this.stack().peek() instanceof ReferenceType) && !(this.stack().peek() instanceof ReturnaddressType)) {\n-            this.constraintViolated((Instruction)o, \"The 'objectref' is not of a ReferenceType or of ReturnaddressType but of \" + this.stack().peek() + \".\");\n+            this.constraintViolated((Instruction)astore, \"The 'objectref' is not of a ReferenceType or of ReturnaddressType but of \" + this.stack().peek() + \".\");\n         }\n     }\n     \n-    public void visitATHROW(final ATHROW o) {\n+    public void visitATHROW(final ATHROW athrow) {\n         try {\n             if (!(this.stack().peek() instanceof ObjectType) && !this.stack().peek().equals((Object)Type.NULL)) {\n-                this.constraintViolated((Instruction)o, \"The 'objectref' is not of an (initialized) ObjectType but of type \" + this.stack().peek() + \".\");\n+                this.constraintViolated((Instruction)athrow, \"The 'objectref' is not of an (initialized) ObjectType but of type \" + this.stack().peek() + \".\");\n             }\n             if (this.stack().peek().equals((Object)Type.NULL)) {\n                 return;\n             }\n-            final ObjectType exc = (ObjectType)this.stack().peek();\n-            final ObjectType throwable = (ObjectType)Type.getType(\"Ljava/lang/Throwable;\");\n-            if (!exc.subclassOf(throwable) && !exc.equals((Object)throwable)) {\n-                this.constraintViolated((Instruction)o, \"The 'objectref' is not of class Throwable or of a subclass of Throwable, but of '\" + this.stack().peek() + \"'.\");\n+            final ObjectType objectType = (ObjectType)this.stack().peek();\n+            final ObjectType objectType2 = (ObjectType)Type.getType(\"Ljava/lang/Throwable;\");\n+            if (!objectType.subclassOf(objectType2) && !objectType.equals((Object)objectType2)) {\n+                this.constraintViolated((Instruction)athrow, \"The 'objectref' is not of class Throwable or of a subclass of Throwable, but of '\" + this.stack().peek() + \"'.\");\n             }\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj, (Throwable)obj);\n         }\n     }\n     \n-    public void visitBALOAD(final BALOAD o) {\n-        final Type arrayref = this.stack().peek(1);\n-        final Type index = this.stack().peek(0);\n-        this.indexOfInt((Instruction)o, index);\n-        if (this.arrayrefOfArrayType((Instruction)o, arrayref) && !((ArrayType)arrayref).getElementType().equals((Object)Type.BOOLEAN) && !((ArrayType)arrayref).getElementType().equals((Object)Type.BYTE)) {\n-            this.constraintViolated((Instruction)o, \"The 'arrayref' does not refer to an array with elements of a Type.BYTE or Type.BOOLEAN but to an array of '\" + ((ArrayType)arrayref).getElementType() + \"'.\");\n+    public void visitBALOAD(final BALOAD baload) {\n+        final Type peek = this.stack().peek(1);\n+        this.indexOfInt((Instruction)baload, this.stack().peek(0));\n+        if (this.arrayrefOfArrayType((Instruction)baload, peek) && !((ArrayType)peek).getElementType().equals((Object)Type.BOOLEAN) && !((ArrayType)peek).getElementType().equals((Object)Type.BYTE)) {\n+            this.constraintViolated((Instruction)baload, \"The 'arrayref' does not refer to an array with elements of a Type.BYTE or Type.BOOLEAN but to an array of '\" + ((ArrayType)peek).getElementType() + \"'.\");\n         }\n     }\n     \n-    public void visitBASTORE(final BASTORE o) {\n-        final Type arrayref = this.stack().peek(2);\n-        final Type index = this.stack().peek(1);\n-        final Type value = this.stack().peek(0);\n-        this.indexOfInt((Instruction)o, index);\n-        this.valueOfInt((Instruction)o, value);\n-        if (this.arrayrefOfArrayType((Instruction)o, arrayref) && !((ArrayType)arrayref).getElementType().equals((Object)Type.BOOLEAN) && !((ArrayType)arrayref).getElementType().equals((Object)Type.BYTE)) {\n-            this.constraintViolated((Instruction)o, \"The 'arrayref' does not refer to an array with elements of a Type.BYTE or Type.BOOLEAN but to an array of '\" + ((ArrayType)arrayref).getElementType() + \"'.\");\n+    public void visitBASTORE(final BASTORE bastore) {\n+        final Type peek = this.stack().peek(2);\n+        final Type peek2 = this.stack().peek(1);\n+        final Type peek3 = this.stack().peek(0);\n+        this.indexOfInt((Instruction)bastore, peek2);\n+        this.valueOfInt((Instruction)bastore, peek3);\n+        if (this.arrayrefOfArrayType((Instruction)bastore, peek) && !((ArrayType)peek).getElementType().equals((Object)Type.BOOLEAN) && !((ArrayType)peek).getElementType().equals((Object)Type.BYTE)) {\n+            this.constraintViolated((Instruction)bastore, \"The 'arrayref' does not refer to an array with elements of a Type.BYTE or Type.BOOLEAN but to an array of '\" + ((ArrayType)peek).getElementType() + \"'.\");\n         }\n     }\n     \n-    public void visitBIPUSH(final BIPUSH o) {\n+    public void visitBIPUSH(final BIPUSH bipush) {\n     }\n     \n-    public void visitBREAKPOINT(final BREAKPOINT o) {\n+    public void visitBREAKPOINT(final BREAKPOINT breakpoint) {\n         throw new AssertionViolatedException(\"In this JustIce verification pass there should not occur an illegal instruction such as BREAKPOINT.\");\n     }\n     \n-    public void visitCALOAD(final CALOAD o) {\n-        final Type arrayref = this.stack().peek(1);\n-        final Type index = this.stack().peek(0);\n-        this.indexOfInt((Instruction)o, index);\n-        this.arrayrefOfArrayType((Instruction)o, arrayref);\n+    public void visitCALOAD(final CALOAD caload) {\n+        final Type peek = this.stack().peek(1);\n+        this.indexOfInt((Instruction)caload, this.stack().peek(0));\n+        this.arrayrefOfArrayType((Instruction)caload, peek);\n     }\n     \n-    public void visitCASTORE(final CASTORE o) {\n-        final Type arrayref = this.stack().peek(2);\n-        final Type index = this.stack().peek(1);\n-        final Type value = this.stack().peek(0);\n-        this.indexOfInt((Instruction)o, index);\n-        this.valueOfInt((Instruction)o, value);\n-        if (this.arrayrefOfArrayType((Instruction)o, arrayref) && !((ArrayType)arrayref).getElementType().equals((Object)Type.CHAR)) {\n-            this.constraintViolated((Instruction)o, \"The 'arrayref' does not refer to an array with elements of type char but to an array of type \" + ((ArrayType)arrayref).getElementType() + \".\");\n+    public void visitCASTORE(final CASTORE castore) {\n+        final Type peek = this.stack().peek(2);\n+        final Type peek2 = this.stack().peek(1);\n+        final Type peek3 = this.stack().peek(0);\n+        this.indexOfInt((Instruction)castore, peek2);\n+        this.valueOfInt((Instruction)castore, peek3);\n+        if (this.arrayrefOfArrayType((Instruction)castore, peek) && !((ArrayType)peek).getElementType().equals((Object)Type.CHAR)) {\n+            this.constraintViolated((Instruction)castore, \"The 'arrayref' does not refer to an array with elements of type char but to an array of type \" + ((ArrayType)peek).getElementType() + \".\");\n         }\n     }\n     \n-    public void visitCHECKCAST(final CHECKCAST o) {\n-        final Type objectref = this.stack().peek(0);\n-        if (!(objectref instanceof ReferenceType)) {\n-            this.constraintViolated((Instruction)o, \"The 'objectref' is not of a ReferenceType but of type \" + objectref + \".\");\n+    public void visitCHECKCAST(final CHECKCAST checkcast) {\n+        final Type peek = this.stack().peek(0);\n+        if (!(peek instanceof ReferenceType)) {\n+            this.constraintViolated((Instruction)checkcast, \"The 'objectref' is not of a ReferenceType but of type \" + peek + \".\");\n         }\n-        final Constant c = this.cpg.getConstant(o.getIndex());\n-        if (!(c instanceof ConstantClass)) {\n-            this.constraintViolated((Instruction)o, \"The Constant at 'index' is not a ConstantClass, but '\" + c + \"'.\");\n+        final Constant constant = this.cpg.getConstant(checkcast.getIndex());\n+        if (!(constant instanceof ConstantClass)) {\n+            this.constraintViolated((Instruction)checkcast, \"The Constant at 'index' is not a ConstantClass, but '\" + constant + \"'.\");\n         }\n     }\n     \n-    public void visitD2F(final D2F o) {\n+    public void visitD2F(final D2F d2F) {\n         if (this.stack().peek() != Type.DOUBLE) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)d2F, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitD2I(final D2I o) {\n+    public void visitD2I(final D2I d2I) {\n         if (this.stack().peek() != Type.DOUBLE) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)d2I, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitD2L(final D2L o) {\n+    public void visitD2L(final D2L d2L) {\n         if (this.stack().peek() != Type.DOUBLE) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)d2L, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitDADD(final DADD o) {\n+    public void visitDADD(final DADD dadd) {\n         if (this.stack().peek() != Type.DOUBLE) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)dadd, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.DOUBLE) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'double', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)dadd, \"The value at the stack next-to-top is not of type 'double', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitDALOAD(final DALOAD o) {\n-        this.indexOfInt((Instruction)o, this.stack().peek());\n+    public void visitDALOAD(final DALOAD daload) {\n+        this.indexOfInt((Instruction)daload, this.stack().peek());\n         if (this.stack().peek(1) == Type.NULL) {\n             return;\n         }\n         if (!(this.stack().peek(1) instanceof ArrayType)) {\n-            this.constraintViolated((Instruction)o, \"Stack next-to-top must be of type double[] but is '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)daload, \"Stack next-to-top must be of type double[] but is '\" + this.stack().peek(1) + \"'.\");\n         }\n-        final Type t = ((ArrayType)this.stack().peek(1)).getBasicType();\n-        if (t != Type.DOUBLE) {\n-            this.constraintViolated((Instruction)o, \"Stack next-to-top must be of type double[] but is '\" + this.stack().peek(1) + \"'.\");\n+        if (((ArrayType)this.stack().peek(1)).getBasicType() != Type.DOUBLE) {\n+            this.constraintViolated((Instruction)daload, \"Stack next-to-top must be of type double[] but is '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitDASTORE(final DASTORE o) {\n+    public void visitDASTORE(final DASTORE dastore) {\n         if (this.stack().peek() != Type.DOUBLE) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)dastore, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n         }\n-        this.indexOfInt((Instruction)o, this.stack().peek(1));\n+        this.indexOfInt((Instruction)dastore, this.stack().peek(1));\n         if (this.stack().peek(2) == Type.NULL) {\n             return;\n         }\n         if (!(this.stack().peek(2) instanceof ArrayType)) {\n-            this.constraintViolated((Instruction)o, \"Stack next-to-next-to-top must be of type double[] but is '\" + this.stack().peek(2) + \"'.\");\n+            this.constraintViolated((Instruction)dastore, \"Stack next-to-next-to-top must be of type double[] but is '\" + this.stack().peek(2) + \"'.\");\n         }\n-        final Type t = ((ArrayType)this.stack().peek(2)).getBasicType();\n-        if (t != Type.DOUBLE) {\n-            this.constraintViolated((Instruction)o, \"Stack next-to-next-to-top must be of type double[] but is '\" + this.stack().peek(2) + \"'.\");\n+        if (((ArrayType)this.stack().peek(2)).getBasicType() != Type.DOUBLE) {\n+            this.constraintViolated((Instruction)dastore, \"Stack next-to-next-to-top must be of type double[] but is '\" + this.stack().peek(2) + \"'.\");\n         }\n     }\n     \n-    public void visitDCMPG(final DCMPG o) {\n+    public void visitDCMPG(final DCMPG dcmpg) {\n         if (this.stack().peek() != Type.DOUBLE) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)dcmpg, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.DOUBLE) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'double', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)dcmpg, \"The value at the stack next-to-top is not of type 'double', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitDCMPL(final DCMPL o) {\n+    public void visitDCMPL(final DCMPL dcmpl) {\n         if (this.stack().peek() != Type.DOUBLE) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)dcmpl, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.DOUBLE) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'double', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)dcmpl, \"The value at the stack next-to-top is not of type 'double', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitDCONST(final DCONST o) {\n+    public void visitDCONST(final DCONST dconst) {\n     }\n     \n-    public void visitDDIV(final DDIV o) {\n+    public void visitDDIV(final DDIV ddiv) {\n         if (this.stack().peek() != Type.DOUBLE) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)ddiv, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.DOUBLE) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'double', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)ddiv, \"The value at the stack next-to-top is not of type 'double', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitDLOAD(final DLOAD o) {\n+    public void visitDLOAD(final DLOAD dload) {\n     }\n     \n-    public void visitDMUL(final DMUL o) {\n+    public void visitDMUL(final DMUL dmul) {\n         if (this.stack().peek() != Type.DOUBLE) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)dmul, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.DOUBLE) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'double', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)dmul, \"The value at the stack next-to-top is not of type 'double', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitDNEG(final DNEG o) {\n+    public void visitDNEG(final DNEG dneg) {\n         if (this.stack().peek() != Type.DOUBLE) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)dneg, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitDREM(final DREM o) {\n+    public void visitDREM(final DREM drem) {\n         if (this.stack().peek() != Type.DOUBLE) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)drem, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.DOUBLE) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'double', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)drem, \"The value at the stack next-to-top is not of type 'double', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitDRETURN(final DRETURN o) {\n+    public void visitDRETURN(final DRETURN dreturn) {\n         if (this.stack().peek() != Type.DOUBLE) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)dreturn, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitDSTORE(final DSTORE o) {\n+    public void visitDSTORE(final DSTORE dstore) {\n     }\n     \n-    public void visitDSUB(final DSUB o) {\n+    public void visitDSUB(final DSUB dsub) {\n         if (this.stack().peek() != Type.DOUBLE) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)dsub, \"The value at the stack top is not of type 'double', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.DOUBLE) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'double', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)dsub, \"The value at the stack next-to-top is not of type 'double', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitDUP(final DUP o) {\n+    public void visitDUP(final DUP dup) {\n         if (this.stack().peek().getSize() != 1) {\n-            this.constraintViolated((Instruction)o, \"Won't DUP type on stack top '\" + this.stack().peek() + \"' because it must occupy exactly one slot, not '\" + this.stack().peek().getSize() + \"'.\");\n+            this.constraintViolated((Instruction)dup, \"Won't DUP type on stack top '\" + this.stack().peek() + \"' because it must occupy exactly one slot, not '\" + this.stack().peek().getSize() + \"'.\");\n         }\n     }\n     \n-    public void visitDUP_X1(final DUP_X1 o) {\n+    public void visitDUP_X1(final DUP_X1 dup_X1) {\n         if (this.stack().peek().getSize() != 1) {\n-            this.constraintViolated((Instruction)o, \"Type on stack top '\" + this.stack().peek() + \"' should occupy exactly one slot, not '\" + this.stack().peek().getSize() + \"'.\");\n+            this.constraintViolated((Instruction)dup_X1, \"Type on stack top '\" + this.stack().peek() + \"' should occupy exactly one slot, not '\" + this.stack().peek().getSize() + \"'.\");\n         }\n         if (this.stack().peek(1).getSize() != 1) {\n-            this.constraintViolated((Instruction)o, \"Type on stack next-to-top '\" + this.stack().peek(1) + \"' should occupy exactly one slot, not '\" + this.stack().peek(1).getSize() + \"'.\");\n+            this.constraintViolated((Instruction)dup_X1, \"Type on stack next-to-top '\" + this.stack().peek(1) + \"' should occupy exactly one slot, not '\" + this.stack().peek(1).getSize() + \"'.\");\n         }\n     }\n     \n-    public void visitDUP_X2(final DUP_X2 o) {\n+    public void visitDUP_X2(final DUP_X2 dup_X2) {\n         if (this.stack().peek().getSize() != 1) {\n-            this.constraintViolated((Instruction)o, \"Stack top type must be of size 1, but is '\" + this.stack().peek() + \"' of size '\" + this.stack().peek().getSize() + \"'.\");\n+            this.constraintViolated((Instruction)dup_X2, \"Stack top type must be of size 1, but is '\" + this.stack().peek() + \"' of size '\" + this.stack().peek().getSize() + \"'.\");\n         }\n         if (this.stack().peek(1).getSize() == 2) {\n             return;\n         }\n         if (this.stack().peek(2).getSize() != 1) {\n-            this.constraintViolated((Instruction)o, \"If stack top's size is 1 and stack next-to-top's size is 1, stack next-to-next-to-top's size must also be 1, but is: '\" + this.stack().peek(2) + \"' of size '\" + this.stack().peek(2).getSize() + \"'.\");\n+            this.constraintViolated((Instruction)dup_X2, \"If stack top's size is 1 and stack next-to-top's size is 1, stack next-to-next-to-top's size must also be 1, but is: '\" + this.stack().peek(2) + \"' of size '\" + this.stack().peek(2).getSize() + \"'.\");\n         }\n     }\n     \n-    public void visitDUP2(final DUP2 o) {\n+    public void visitDUP2(final DUP2 dup2) {\n         if (this.stack().peek().getSize() == 2) {\n             return;\n         }\n         if (this.stack().peek(1).getSize() != 1) {\n-            this.constraintViolated((Instruction)o, \"If stack top's size is 1, then stack next-to-top's size must also be 1. But it is '\" + this.stack().peek(1) + \"' of size '\" + this.stack().peek(1).getSize() + \"'.\");\n+            this.constraintViolated((Instruction)dup2, \"If stack top's size is 1, then stack next-to-top's size must also be 1. But it is '\" + this.stack().peek(1) + \"' of size '\" + this.stack().peek(1).getSize() + \"'.\");\n         }\n     }\n     \n-    public void visitDUP2_X1(final DUP2_X1 o) {\n+    public void visitDUP2_X1(final DUP2_X1 dup2_X1) {\n         if (this.stack().peek().getSize() == 2) {\n             if (this.stack().peek(1).getSize() == 1) {\n                 return;\n             }\n-            this.constraintViolated((Instruction)o, \"If stack top's size is 2, then stack next-to-top's size must be 1. But it is '\" + this.stack().peek(1) + \"' of size '\" + this.stack().peek(1).getSize() + \"'.\");\n+            this.constraintViolated((Instruction)dup2_X1, \"If stack top's size is 2, then stack next-to-top's size must be 1. But it is '\" + this.stack().peek(1) + \"' of size '\" + this.stack().peek(1).getSize() + \"'.\");\n         }\n         else {\n             if (this.stack().peek(1).getSize() != 1) {\n-                this.constraintViolated((Instruction)o, \"If stack top's size is 1, then stack next-to-top's size must also be 1. But it is '\" + this.stack().peek(1) + \"' of size '\" + this.stack().peek(1).getSize() + \"'.\");\n+                this.constraintViolated((Instruction)dup2_X1, \"If stack top's size is 1, then stack next-to-top's size must also be 1. But it is '\" + this.stack().peek(1) + \"' of size '\" + this.stack().peek(1).getSize() + \"'.\");\n             }\n             if (this.stack().peek(2).getSize() != 1) {\n-                this.constraintViolated((Instruction)o, \"If stack top's size is 1, then stack next-to-next-to-top's size must also be 1. But it is '\" + this.stack().peek(2) + \"' of size '\" + this.stack().peek(2).getSize() + \"'.\");\n+                this.constraintViolated((Instruction)dup2_X1, \"If stack top's size is 1, then stack next-to-next-to-top's size must also be 1. But it is '\" + this.stack().peek(2) + \"' of size '\" + this.stack().peek(2).getSize() + \"'.\");\n             }\n         }\n     }\n     \n-    public void visitDUP2_X2(final DUP2_X2 o) {\n+    public void visitDUP2_X2(final DUP2_X2 dup2_X2) {\n         if (this.stack().peek(0).getSize() == 2) {\n             if (this.stack().peek(1).getSize() == 2) {\n                 return;\n             }\n             if (this.stack().peek(2).getSize() == 1) {\n                 return;\n             }\n-            this.constraintViolated((Instruction)o, \"If stack top's size is 2 and stack-next-to-top's size is 1, then stack next-to-next-to-top's size must also be 1. But it is '\" + this.stack().peek(2) + \"' of size '\" + this.stack().peek(2).getSize() + \"'.\");\n+            this.constraintViolated((Instruction)dup2_X2, \"If stack top's size is 2 and stack-next-to-top's size is 1, then stack next-to-next-to-top's size must also be 1. But it is '\" + this.stack().peek(2) + \"' of size '\" + this.stack().peek(2).getSize() + \"'.\");\n         }\n         else if (this.stack().peek(1).getSize() == 1) {\n             if (this.stack().peek(2).getSize() == 2) {\n                 return;\n             }\n             if (this.stack().peek(3).getSize() == 1) {\n                 return;\n             }\n         }\n-        this.constraintViolated((Instruction)o, \"The operand sizes on the stack do not match any of the four forms of usage of this instruction.\");\n+        this.constraintViolated((Instruction)dup2_X2, \"The operand sizes on the stack do not match any of the four forms of usage of this instruction.\");\n     }\n     \n-    public void visitF2D(final F2D o) {\n+    public void visitF2D(final F2D f2D) {\n         if (this.stack().peek() != Type.FLOAT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)f2D, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitF2I(final F2I o) {\n+    public void visitF2I(final F2I f2I) {\n         if (this.stack().peek() != Type.FLOAT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)f2I, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitF2L(final F2L o) {\n+    public void visitF2L(final F2L f2L) {\n         if (this.stack().peek() != Type.FLOAT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)f2L, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitFADD(final FADD o) {\n+    public void visitFADD(final FADD fadd) {\n         if (this.stack().peek() != Type.FLOAT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)fadd, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.FLOAT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'float', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)fadd, \"The value at the stack next-to-top is not of type 'float', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitFALOAD(final FALOAD o) {\n-        this.indexOfInt((Instruction)o, this.stack().peek());\n+    public void visitFALOAD(final FALOAD faload) {\n+        this.indexOfInt((Instruction)faload, this.stack().peek());\n         if (this.stack().peek(1) == Type.NULL) {\n             return;\n         }\n         if (!(this.stack().peek(1) instanceof ArrayType)) {\n-            this.constraintViolated((Instruction)o, \"Stack next-to-top must be of type float[] but is '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)faload, \"Stack next-to-top must be of type float[] but is '\" + this.stack().peek(1) + \"'.\");\n         }\n-        final Type t = ((ArrayType)this.stack().peek(1)).getBasicType();\n-        if (t != Type.FLOAT) {\n-            this.constraintViolated((Instruction)o, \"Stack next-to-top must be of type float[] but is '\" + this.stack().peek(1) + \"'.\");\n+        if (((ArrayType)this.stack().peek(1)).getBasicType() != Type.FLOAT) {\n+            this.constraintViolated((Instruction)faload, \"Stack next-to-top must be of type float[] but is '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitFASTORE(final FASTORE o) {\n+    public void visitFASTORE(final FASTORE fastore) {\n         if (this.stack().peek() != Type.FLOAT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)fastore, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n         }\n-        this.indexOfInt((Instruction)o, this.stack().peek(1));\n+        this.indexOfInt((Instruction)fastore, this.stack().peek(1));\n         if (this.stack().peek(2) == Type.NULL) {\n             return;\n         }\n         if (!(this.stack().peek(2) instanceof ArrayType)) {\n-            this.constraintViolated((Instruction)o, \"Stack next-to-next-to-top must be of type float[] but is '\" + this.stack().peek(2) + \"'.\");\n+            this.constraintViolated((Instruction)fastore, \"Stack next-to-next-to-top must be of type float[] but is '\" + this.stack().peek(2) + \"'.\");\n         }\n-        final Type t = ((ArrayType)this.stack().peek(2)).getBasicType();\n-        if (t != Type.FLOAT) {\n-            this.constraintViolated((Instruction)o, \"Stack next-to-next-to-top must be of type float[] but is '\" + this.stack().peek(2) + \"'.\");\n+        if (((ArrayType)this.stack().peek(2)).getBasicType() != Type.FLOAT) {\n+            this.constraintViolated((Instruction)fastore, \"Stack next-to-next-to-top must be of type float[] but is '\" + this.stack().peek(2) + \"'.\");\n         }\n     }\n     \n-    public void visitFCMPG(final FCMPG o) {\n+    public void visitFCMPG(final FCMPG fcmpg) {\n         if (this.stack().peek() != Type.FLOAT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)fcmpg, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.FLOAT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'float', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)fcmpg, \"The value at the stack next-to-top is not of type 'float', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitFCMPL(final FCMPL o) {\n+    public void visitFCMPL(final FCMPL fcmpl) {\n         if (this.stack().peek() != Type.FLOAT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)fcmpl, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.FLOAT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'float', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)fcmpl, \"The value at the stack next-to-top is not of type 'float', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitFCONST(final FCONST o) {\n+    public void visitFCONST(final FCONST fconst) {\n     }\n     \n-    public void visitFDIV(final FDIV o) {\n+    public void visitFDIV(final FDIV fdiv) {\n         if (this.stack().peek() != Type.FLOAT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)fdiv, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.FLOAT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'float', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)fdiv, \"The value at the stack next-to-top is not of type 'float', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitFLOAD(final FLOAD o) {\n+    public void visitFLOAD(final FLOAD fload) {\n     }\n     \n-    public void visitFMUL(final FMUL o) {\n+    public void visitFMUL(final FMUL fmul) {\n         if (this.stack().peek() != Type.FLOAT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)fmul, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.FLOAT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'float', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)fmul, \"The value at the stack next-to-top is not of type 'float', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitFNEG(final FNEG o) {\n+    public void visitFNEG(final FNEG fneg) {\n         if (this.stack().peek() != Type.FLOAT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)fneg, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitFREM(final FREM o) {\n+    public void visitFREM(final FREM frem) {\n         if (this.stack().peek() != Type.FLOAT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)frem, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.FLOAT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'float', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)frem, \"The value at the stack next-to-top is not of type 'float', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitFRETURN(final FRETURN o) {\n+    public void visitFRETURN(final FRETURN freturn) {\n         if (this.stack().peek() != Type.FLOAT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)freturn, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitFSTORE(final FSTORE o) {\n+    public void visitFSTORE(final FSTORE fstore) {\n     }\n     \n-    public void visitFSUB(final FSUB o) {\n+    public void visitFSUB(final FSUB fsub) {\n         if (this.stack().peek() != Type.FLOAT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)fsub, \"The value at the stack top is not of type 'float', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.FLOAT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'float', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)fsub, \"The value at the stack next-to-top is not of type 'float', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    private ObjectType getObjectType(final FieldInstruction o) {\n-        final ReferenceType rt = o.getReferenceType(this.cpg);\n-        if (rt instanceof ObjectType) {\n-            return (ObjectType)rt;\n+    private ObjectType getObjectType(final FieldInstruction fieldInstruction) {\n+        final ReferenceType referenceType = fieldInstruction.getReferenceType(this.cpg);\n+        if (referenceType instanceof ObjectType) {\n+            return (ObjectType)referenceType;\n         }\n-        this.constraintViolated((Instruction)o, \"expecting ObjectType but got \" + rt);\n+        this.constraintViolated((Instruction)fieldInstruction, \"expecting ObjectType but got \" + referenceType);\n         return null;\n     }\n     \n-    public void visitGETFIELD(final GETFIELD o) {\n+    public void visitGETFIELD(final GETFIELD getfield) {\n         try {\n-            final Type objectref = this.stack().peek();\n-            if (!(objectref instanceof ObjectType) && objectref != Type.NULL) {\n-                this.constraintViolated((Instruction)o, \"Stack top should be an object reference that's not an array reference, but is '\" + objectref + \"'.\");\n-            }\n-            final String field_name = o.getFieldName(this.cpg);\n-            final JavaClass jc = Repository.lookupClass(this.getObjectType((FieldInstruction)o).getClassName());\n-            Field[] fields = jc.getFields();\n-            Field f = null;\n+            final Type peek = this.stack().peek();\n+            if (!(peek instanceof ObjectType) && peek != Type.NULL) {\n+                this.constraintViolated((Instruction)getfield, \"Stack top should be an object reference that's not an array reference, but is '\" + peek + \"'.\");\n+            }\n+            final String fieldName = getfield.getFieldName(this.cpg);\n+            final JavaClass lookupClass = Repository.lookupClass(this.getObjectType((FieldInstruction)getfield).getClassName());\n+            final Field[] fields = lookupClass.getFields();\n+            Field obj = null;\n             for (final Field field : fields) {\n-                if (field.getName().equals(field_name)) {\n-                    final Type f_type = Type.getType(field.getSignature());\n-                    final Type o_type = o.getType(this.cpg);\n-                    if (f_type.equals((Object)o_type)) {\n-                        f = field;\n-                        break;\n-                    }\n+                if (field.getName().equals(fieldName) && Type.getType(field.getSignature()).equals((Object)getfield.getType(this.cpg))) {\n+                    obj = field;\n+                    break;\n                 }\n             }\n-            if (f == null) {\n-                final JavaClass[] superClasses;\n-                final JavaClass[] superclasses = superClasses = jc.getSuperClasses();\n+            if (obj == null) {\n+                final JavaClass[] superClasses = lookupClass.getSuperClasses();\n             Label_0309:\n-                for (final JavaClass superclass : superClasses) {\n-                    final Field[] fields2;\n-                    fields = (fields2 = superclass.getFields());\n-                    for (final Field field2 : fields2) {\n-                        if (field2.getName().equals(field_name)) {\n-                            final Type f_type2 = Type.getType(field2.getSignature());\n-                            final Type o_type2 = o.getType(this.cpg);\n-                            if (f_type2.equals((Object)o_type2)) {\n-                                f = field2;\n-                                if ((f.getAccessFlags() & 0x5) == 0x0) {\n-                                    f = null;\n-                                    break Label_0309;\n-                                }\n+                for (int length2 = superClasses.length, j = 0; j < length2; ++j) {\n+                    final Field[] fields2 = superClasses[j].getFields();\n+                    final int length3 = fields2.length;\n+                    int k = 0;\n+                    while (k < length3) {\n+                        final Field field2 = fields2[k];\n+                        if (field2.getName().equals(fieldName) && Type.getType(field2.getSignature()).equals((Object)getfield.getType(this.cpg))) {\n+                            obj = field2;\n+                            if ((obj.getAccessFlags() & 0x5) == 0x0) {\n+                                obj = null;\n                                 break Label_0309;\n                             }\n+                            break Label_0309;\n+                        }\n+                        else {\n+                            ++k;\n                         }\n                     }\n                 }\n-                if (f == null) {\n-                    throw new AssertionViolatedException(\"Field '\" + field_name + \"' not found in \" + jc.getClassName());\n+                if (obj == null) {\n+                    throw new AssertionViolatedException(\"Field '\" + fieldName + \"' not found in \" + lookupClass.getClassName());\n                 }\n             }\n-            if (f.isProtected()) {\n-                final ObjectType classtype = this.getObjectType((FieldInstruction)o);\n-                final ObjectType curr = ObjectType.getInstance(this.mg.getClassName());\n-                if (classtype.equals((Object)curr) || curr.subclassOf(classtype)) {\n-                    final Type t = this.stack().peek();\n-                    if (t == Type.NULL) {\n+            if (obj.isProtected()) {\n+                final ObjectType objectType = this.getObjectType((FieldInstruction)getfield);\n+                final ObjectType instance = ObjectType.getInstance(this.mg.getClassName());\n+                if (objectType.equals((Object)instance) || instance.subclassOf(objectType)) {\n+                    final Type peek2 = this.stack().peek();\n+                    if (peek2 == Type.NULL) {\n                         return;\n                     }\n-                    if (!(t instanceof ObjectType)) {\n-                        this.constraintViolated((Instruction)o, \"The 'objectref' must refer to an object that's not an array. Found instead: '\" + t + \"'.\");\n+                    if (!(peek2 instanceof ObjectType)) {\n+                        this.constraintViolated((Instruction)getfield, \"The 'objectref' must refer to an object that's not an array. Found instead: '\" + peek2 + \"'.\");\n                     }\n-                    final ObjectType objreftype = (ObjectType)t;\n-                    if (objreftype.equals((Object)curr) || !objreftype.subclassOf(curr)) {}\n+                    final ObjectType objectType2 = (ObjectType)peek2;\n+                    if (objectType2.equals((Object)instance) || !objectType2.subclassOf(instance)) {}\n                 }\n             }\n-            if (f.isStatic()) {\n-                this.constraintViolated((Instruction)o, \"Referenced field '\" + f + \"' is static which it shouldn't be.\");\n+            if (obj.isStatic()) {\n+                this.constraintViolated((Instruction)getfield, \"Referenced field '\" + obj + \"' is static which it shouldn't be.\");\n             }\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj2) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj2, (Throwable)obj2);\n         }\n     }\n     \n-    public void visitGETSTATIC(final GETSTATIC o) {\n+    public void visitGETSTATIC(final GETSTATIC getstatic) {\n     }\n     \n-    public void visitGOTO(final GOTO o) {\n+    public void visitGOTO(final GOTO goto1) {\n     }\n     \n-    public void visitGOTO_W(final GOTO_W o) {\n+    public void visitGOTO_W(final GOTO_W goto_W) {\n     }\n     \n-    public void visitI2B(final I2B o) {\n+    public void visitI2B(final I2B i2B) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)i2B, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitI2C(final I2C o) {\n+    public void visitI2C(final I2C i2C) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)i2C, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitI2D(final I2D o) {\n+    public void visitI2D(final I2D i2D) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)i2D, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitI2F(final I2F o) {\n+    public void visitI2F(final I2F i2F) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)i2F, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitI2L(final I2L o) {\n+    public void visitI2L(final I2L i2L) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)i2L, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitI2S(final I2S o) {\n+    public void visitI2S(final I2S i2S) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)i2S, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitIADD(final IADD o) {\n+    public void visitIADD(final IADD iadd) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)iadd, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)iadd, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitIALOAD(final IALOAD o) {\n-        this.indexOfInt((Instruction)o, this.stack().peek());\n+    public void visitIALOAD(final IALOAD iaload) {\n+        this.indexOfInt((Instruction)iaload, this.stack().peek());\n         if (this.stack().peek(1) == Type.NULL) {\n             return;\n         }\n         if (!(this.stack().peek(1) instanceof ArrayType)) {\n-            this.constraintViolated((Instruction)o, \"Stack next-to-top must be of type int[] but is '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)iaload, \"Stack next-to-top must be of type int[] but is '\" + this.stack().peek(1) + \"'.\");\n         }\n-        final Type t = ((ArrayType)this.stack().peek(1)).getBasicType();\n-        if (t != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"Stack next-to-top must be of type int[] but is '\" + this.stack().peek(1) + \"'.\");\n+        if (((ArrayType)this.stack().peek(1)).getBasicType() != Type.INT) {\n+            this.constraintViolated((Instruction)iaload, \"Stack next-to-top must be of type int[] but is '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitIAND(final IAND o) {\n+    public void visitIAND(final IAND iand) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)iand, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)iand, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitIASTORE(final IASTORE o) {\n+    public void visitIASTORE(final IASTORE iastore) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)iastore, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n-        this.indexOfInt((Instruction)o, this.stack().peek(1));\n+        this.indexOfInt((Instruction)iastore, this.stack().peek(1));\n         if (this.stack().peek(2) == Type.NULL) {\n             return;\n         }\n         if (!(this.stack().peek(2) instanceof ArrayType)) {\n-            this.constraintViolated((Instruction)o, \"Stack next-to-next-to-top must be of type int[] but is '\" + this.stack().peek(2) + \"'.\");\n+            this.constraintViolated((Instruction)iastore, \"Stack next-to-next-to-top must be of type int[] but is '\" + this.stack().peek(2) + \"'.\");\n         }\n-        final Type t = ((ArrayType)this.stack().peek(2)).getBasicType();\n-        if (t != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"Stack next-to-next-to-top must be of type int[] but is '\" + this.stack().peek(2) + \"'.\");\n+        if (((ArrayType)this.stack().peek(2)).getBasicType() != Type.INT) {\n+            this.constraintViolated((Instruction)iastore, \"Stack next-to-next-to-top must be of type int[] but is '\" + this.stack().peek(2) + \"'.\");\n         }\n     }\n     \n-    public void visitICONST(final ICONST o) {\n+    public void visitICONST(final ICONST iconst) {\n     }\n     \n-    public void visitIDIV(final IDIV o) {\n+    public void visitIDIV(final IDIV idiv) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)idiv, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)idiv, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitIF_ACMPEQ(final IF_ACMPEQ o) {\n+    public void visitIF_ACMPEQ(final IF_ACMPEQ if_ACMPEQ) {\n         if (!(this.stack().peek() instanceof ReferenceType)) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of a ReferenceType, but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)if_ACMPEQ, \"The value at the stack top is not of a ReferenceType, but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (!(this.stack().peek(1) instanceof ReferenceType)) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of a ReferenceType, but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)if_ACMPEQ, \"The value at the stack next-to-top is not of a ReferenceType, but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitIF_ACMPNE(final IF_ACMPNE o) {\n+    public void visitIF_ACMPNE(final IF_ACMPNE if_ACMPNE) {\n         if (!(this.stack().peek() instanceof ReferenceType)) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of a ReferenceType, but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)if_ACMPNE, \"The value at the stack top is not of a ReferenceType, but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (!(this.stack().peek(1) instanceof ReferenceType)) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of a ReferenceType, but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)if_ACMPNE, \"The value at the stack next-to-top is not of a ReferenceType, but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitIF_ICMPEQ(final IF_ICMPEQ o) {\n+    public void visitIF_ICMPEQ(final IF_ICMPEQ if_ICMPEQ) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)if_ICMPEQ, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)if_ICMPEQ, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitIF_ICMPGE(final IF_ICMPGE o) {\n+    public void visitIF_ICMPGE(final IF_ICMPGE if_ICMPGE) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)if_ICMPGE, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)if_ICMPGE, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitIF_ICMPGT(final IF_ICMPGT o) {\n+    public void visitIF_ICMPGT(final IF_ICMPGT if_ICMPGT) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)if_ICMPGT, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)if_ICMPGT, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitIF_ICMPLE(final IF_ICMPLE o) {\n+    public void visitIF_ICMPLE(final IF_ICMPLE if_ICMPLE) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)if_ICMPLE, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)if_ICMPLE, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitIF_ICMPLT(final IF_ICMPLT o) {\n+    public void visitIF_ICMPLT(final IF_ICMPLT if_ICMPLT) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)if_ICMPLT, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)if_ICMPLT, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitIF_ICMPNE(final IF_ICMPNE o) {\n+    public void visitIF_ICMPNE(final IF_ICMPNE if_ICMPNE) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)if_ICMPNE, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)if_ICMPNE, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitIFEQ(final IFEQ o) {\n+    public void visitIFEQ(final IFEQ ifeq) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)ifeq, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitIFGE(final IFGE o) {\n+    public void visitIFGE(final IFGE ifge) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)ifge, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitIFGT(final IFGT o) {\n+    public void visitIFGT(final IFGT ifgt) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)ifgt, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitIFLE(final IFLE o) {\n+    public void visitIFLE(final IFLE ifle) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)ifle, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitIFLT(final IFLT o) {\n+    public void visitIFLT(final IFLT iflt) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)iflt, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitIFNE(final IFNE o) {\n+    public void visitIFNE(final IFNE ifne) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)ifne, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitIFNONNULL(final IFNONNULL o) {\n+    public void visitIFNONNULL(final IFNONNULL ifnonnull) {\n         if (!(this.stack().peek() instanceof ReferenceType)) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of a ReferenceType, but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)ifnonnull, \"The value at the stack top is not of a ReferenceType, but of type '\" + this.stack().peek() + \"'.\");\n         }\n-        this.referenceTypeIsInitialized((Instruction)o, (ReferenceType)this.stack().peek());\n+        this.referenceTypeIsInitialized((Instruction)ifnonnull, (ReferenceType)this.stack().peek());\n     }\n     \n-    public void visitIFNULL(final IFNULL o) {\n+    public void visitIFNULL(final IFNULL ifnull) {\n         if (!(this.stack().peek() instanceof ReferenceType)) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of a ReferenceType, but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)ifnull, \"The value at the stack top is not of a ReferenceType, but of type '\" + this.stack().peek() + \"'.\");\n         }\n-        this.referenceTypeIsInitialized((Instruction)o, (ReferenceType)this.stack().peek());\n+        this.referenceTypeIsInitialized((Instruction)ifnull, (ReferenceType)this.stack().peek());\n     }\n     \n-    public void visitIINC(final IINC o) {\n-        if (this.locals().maxLocals() <= ((o.getType(this.cpg).getSize() == 1) ? o.getIndex() : (o.getIndex() + 1))) {\n-            this.constraintViolated((Instruction)o, \"The 'index' is not a valid index into the local variable array.\");\n+    public void visitIINC(final IINC iinc) {\n+        if (this.locals().maxLocals() <= ((iinc.getType(this.cpg).getSize() == 1) ? iinc.getIndex() : (iinc.getIndex() + 1))) {\n+            this.constraintViolated((Instruction)iinc, \"The 'index' is not a valid index into the local variable array.\");\n         }\n-        this.indexOfInt((Instruction)o, this.locals().get(o.getIndex()));\n+        this.indexOfInt((Instruction)iinc, this.locals().get(iinc.getIndex()));\n     }\n     \n-    public void visitILOAD(final ILOAD o) {\n+    public void visitILOAD(final ILOAD iload) {\n     }\n     \n-    public void visitIMPDEP1(final IMPDEP1 o) {\n+    public void visitIMPDEP1(final IMPDEP1 impdep1) {\n         throw new AssertionViolatedException(\"In this JustIce verification pass there should not occur an illegal instruction such as IMPDEP1.\");\n     }\n     \n-    public void visitIMPDEP2(final IMPDEP2 o) {\n+    public void visitIMPDEP2(final IMPDEP2 impdep2) {\n         throw new AssertionViolatedException(\"In this JustIce verification pass there should not occur an illegal instruction such as IMPDEP2.\");\n     }\n     \n-    public void visitIMUL(final IMUL o) {\n+    public void visitIMUL(final IMUL imul) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)imul, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)imul, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitINEG(final INEG o) {\n+    public void visitINEG(final INEG ineg) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)ineg, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitINSTANCEOF(final INSTANCEOF o) {\n-        final Type objectref = this.stack().peek(0);\n-        if (!(objectref instanceof ReferenceType)) {\n-            this.constraintViolated((Instruction)o, \"The 'objectref' is not of a ReferenceType but of type \" + objectref + \".\");\n+    public void visitINSTANCEOF(final INSTANCEOF instanceof1) {\n+        final Type peek = this.stack().peek(0);\n+        if (!(peek instanceof ReferenceType)) {\n+            this.constraintViolated((Instruction)instanceof1, \"The 'objectref' is not of a ReferenceType but of type \" + peek + \".\");\n         }\n-        final Constant c = this.cpg.getConstant(o.getIndex());\n-        if (!(c instanceof ConstantClass)) {\n-            this.constraintViolated((Instruction)o, \"The Constant at 'index' is not a ConstantClass, but '\" + c + \"'.\");\n+        final Constant constant = this.cpg.getConstant(instanceof1.getIndex());\n+        if (!(constant instanceof ConstantClass)) {\n+            this.constraintViolated((Instruction)instanceof1, \"The Constant at 'index' is not a ConstantClass, but '\" + constant + \"'.\");\n         }\n     }\n     \n-    public void visitINVOKEDYNAMIC(final INVOKEDYNAMIC o) {\n+    public void visitINVOKEDYNAMIC(final INVOKEDYNAMIC invokedynamic) {\n         throw new UnsupportedOperationException(\"INVOKEDYNAMIC instruction is not supported at this time\");\n     }\n     \n-    public void visitINVOKEINTERFACE(final INVOKEINTERFACE o) {\n-        final int count = o.getCount();\n+    public void visitINVOKEINTERFACE(final INVOKEINTERFACE invokeinterface) {\n+        final int count = invokeinterface.getCount();\n         if (count == 0) {\n-            this.constraintViolated((Instruction)o, \"The 'count' argument must not be 0.\");\n+            this.constraintViolated((Instruction)invokeinterface, \"The 'count' argument must not be 0.\");\n         }\n-        final Type t = o.getType(this.cpg);\n-        if (t instanceof ObjectType) {\n-            final String name = ((ObjectType)t).getClassName();\n-            final Verifier v = VerifierFactory.getVerifier(name);\n-            final VerificationResult vr = v.doPass2();\n-            if (vr.getStatus() != 1) {\n-                this.constraintViolated((Instruction)o, \"Class '\" + name + \"' is referenced, but cannot be loaded and resolved: '\" + vr + \"'.\");\n-            }\n-        }\n-        final Type[] argtypes = o.getArgumentTypes(this.cpg);\n-        final int nargs = argtypes.length;\n-        for (int i = nargs - 1; i >= 0; --i) {\n-            final Type fromStack = this.stack().peek(nargs - 1 - i);\n-            Type fromDesc = argtypes[i];\n-            if (fromDesc == Type.BOOLEAN || fromDesc == Type.BYTE || fromDesc == Type.CHAR || fromDesc == Type.SHORT) {\n-                fromDesc = (Type)Type.INT;\n-            }\n-            if (!fromStack.equals((Object)fromDesc)) {\n-                if (fromStack instanceof ReferenceType && fromDesc instanceof ReferenceType) {\n-                    final ReferenceType rFromStack = (ReferenceType)fromStack;\n-                    this.referenceTypeIsInitialized((Instruction)o, rFromStack);\n+        final Type type = invokeinterface.getType(this.cpg);\n+        if (type instanceof ObjectType) {\n+            final String className = ((ObjectType)type).getClassName();\n+            final VerificationResult doPass2 = VerifierFactory.getVerifier(className).doPass2();\n+            if (doPass2.getStatus() != 1) {\n+                this.constraintViolated((Instruction)invokeinterface, \"Class '\" + className + \"' is referenced, but cannot be loaded and resolved: '\" + doPass2 + \"'.\");\n+            }\n+        }\n+        final Type[] argumentTypes = invokeinterface.getArgumentTypes(this.cpg);\n+        final int length = argumentTypes.length;\n+        for (int i = length - 1; i >= 0; --i) {\n+            final Type peek = this.stack().peek(length - 1 - i);\n+            Object int1 = argumentTypes[i];\n+            if (int1 == Type.BOOLEAN || int1 == Type.BYTE || int1 == Type.CHAR || int1 == Type.SHORT) {\n+                int1 = Type.INT;\n+            }\n+            if (!peek.equals(int1)) {\n+                if (peek instanceof ReferenceType && int1 instanceof ReferenceType) {\n+                    this.referenceTypeIsInitialized((Instruction)invokeinterface, (ReferenceType)peek);\n                 }\n                 else {\n-                    this.constraintViolated((Instruction)o, \"Expecting a '\" + fromDesc + \"' but found a '\" + fromStack + \"' on the stack.\");\n+                    this.constraintViolated((Instruction)invokeinterface, \"Expecting a '\" + int1 + \"' but found a '\" + peek + \"' on the stack.\");\n                 }\n             }\n         }\n-        Type objref = this.stack().peek(nargs);\n-        if (objref == Type.NULL) {\n+        final Type peek2 = this.stack().peek(length);\n+        if (peek2 == Type.NULL) {\n             return;\n         }\n-        if (!(objref instanceof ReferenceType)) {\n-            this.constraintViolated((Instruction)o, \"Expecting a reference type as 'objectref' on the stack, not a '\" + objref + \"'.\");\n+        if (!(peek2 instanceof ReferenceType)) {\n+            this.constraintViolated((Instruction)invokeinterface, \"Expecting a reference type as 'objectref' on the stack, not a '\" + peek2 + \"'.\");\n         }\n-        this.referenceTypeIsInitialized((Instruction)o, (ReferenceType)objref);\n-        if (!(objref instanceof ObjectType)) {\n-            if (!(objref instanceof ArrayType)) {\n-                this.constraintViolated((Instruction)o, \"Expecting an ObjectType as 'objectref' on the stack, not a '\" + objref + \"'.\");\n+        this.referenceTypeIsInitialized((Instruction)invokeinterface, (ReferenceType)peek2);\n+        if (!(peek2 instanceof ObjectType)) {\n+            if (!(peek2 instanceof ArrayType)) {\n+                this.constraintViolated((Instruction)invokeinterface, \"Expecting an ObjectType as 'objectref' on the stack, not a '\" + peek2 + \"'.\");\n             }\n             else {\n-                objref = (Type)InstConstraintVisitor.GENERIC_ARRAY;\n+                final ObjectType generic_ARRAY = InstConstraintVisitor.GENERIC_ARRAY;\n             }\n         }\n-        int counted_count = 1;\n-        for (int j = 0; j < nargs; ++j) {\n-            counted_count += argtypes[j].getSize();\n+        int j = 1;\n+        for (int k = 0; k < length; ++k) {\n+            j += argumentTypes[k].getSize();\n         }\n-        if (count != counted_count) {\n-            this.constraintViolated((Instruction)o, \"The 'count' argument should probably read '\" + counted_count + \"' but is '\" + count + \"'.\");\n+        if (count != j) {\n+            this.constraintViolated((Instruction)invokeinterface, \"The 'count' argument should probably read '\" + j + \"' but is '\" + count + \"'.\");\n         }\n     }\n     \n-    public void visitINVOKESPECIAL(final INVOKESPECIAL o) {\n+    public void visitINVOKESPECIAL(final INVOKESPECIAL invokespecial) {\n         try {\n-            if (o.getMethodName(this.cpg).equals(\"<init>\") && !(this.stack().peek(o.getArgumentTypes(this.cpg).length) instanceof UninitializedObjectType)) {\n-                this.constraintViolated((Instruction)o, \"Possibly initializing object twice. A valid instruction sequence must not have an uninitialized object on the operand stack or in a local variable during a backwards branch, or in a local variable in code protected by an exception handler. Please see The Java Virtual Machine Specification, Second Edition, 4.9.4 (pages 147 and 148) for details.\");\n+            if (invokespecial.getMethodName(this.cpg).equals(\"<init>\") && !(this.stack().peek(invokespecial.getArgumentTypes(this.cpg).length) instanceof UninitializedObjectType)) {\n+                this.constraintViolated((Instruction)invokespecial, \"Possibly initializing object twice. A valid instruction sequence must not have an uninitialized object on the operand stack or in a local variable during a backwards branch, or in a local variable in code protected by an exception handler. Please see The Java Virtual Machine Specification, Second Edition, 4.9.4 (pages 147 and 148) for details.\");\n             }\n-            final Type t = o.getType(this.cpg);\n-            if (t instanceof ObjectType) {\n-                final String name = ((ObjectType)t).getClassName();\n-                final Verifier v = VerifierFactory.getVerifier(name);\n-                final VerificationResult vr = v.doPass2();\n-                if (vr.getStatus() != 1) {\n-                    this.constraintViolated((Instruction)o, \"Class '\" + name + \"' is referenced, but cannot be loaded and resolved: '\" + vr + \"'.\");\n-                }\n-            }\n-            final Type[] argtypes = o.getArgumentTypes(this.cpg);\n-            final int nargs = argtypes.length;\n-            for (int i = nargs - 1; i >= 0; --i) {\n-                final Type fromStack = this.stack().peek(nargs - 1 - i);\n-                Type fromDesc = argtypes[i];\n-                if (fromDesc == Type.BOOLEAN || fromDesc == Type.BYTE || fromDesc == Type.CHAR || fromDesc == Type.SHORT) {\n-                    fromDesc = (Type)Type.INT;\n-                }\n-                if (!fromStack.equals((Object)fromDesc)) {\n-                    if (fromStack instanceof ReferenceType && fromDesc instanceof ReferenceType) {\n-                        final ReferenceType rFromStack = (ReferenceType)fromStack;\n-                        final ReferenceType rFromDesc = (ReferenceType)fromDesc;\n-                        if (!rFromStack.isAssignmentCompatibleWith((Type)rFromDesc)) {\n-                            this.constraintViolated((Instruction)o, \"Expecting a '\" + fromDesc + \"' but found a '\" + fromStack + \"' on the stack (which is not assignment compatible).\");\n+            final Type type = invokespecial.getType(this.cpg);\n+            if (type instanceof ObjectType) {\n+                final String className = ((ObjectType)type).getClassName();\n+                final VerificationResult doPass2 = VerifierFactory.getVerifier(className).doPass2();\n+                if (doPass2.getStatus() != 1) {\n+                    this.constraintViolated((Instruction)invokespecial, \"Class '\" + className + \"' is referenced, but cannot be loaded and resolved: '\" + doPass2 + \"'.\");\n+                }\n+            }\n+            final Type[] argumentTypes = invokespecial.getArgumentTypes(this.cpg);\n+            final int length = argumentTypes.length;\n+            for (int i = length - 1; i >= 0; --i) {\n+                final Type peek = this.stack().peek(length - 1 - i);\n+                Object int1 = argumentTypes[i];\n+                if (int1 == Type.BOOLEAN || int1 == Type.BYTE || int1 == Type.CHAR || int1 == Type.SHORT) {\n+                    int1 = Type.INT;\n+                }\n+                if (!peek.equals(int1)) {\n+                    if (peek instanceof ReferenceType && int1 instanceof ReferenceType) {\n+                        final ReferenceType referenceType = (ReferenceType)peek;\n+                        if (!referenceType.isAssignmentCompatibleWith((Type)(ReferenceType)int1)) {\n+                            this.constraintViolated((Instruction)invokespecial, \"Expecting a '\" + int1 + \"' but found a '\" + peek + \"' on the stack (which is not assignment compatible).\");\n                         }\n-                        this.referenceTypeIsInitialized((Instruction)o, rFromStack);\n+                        this.referenceTypeIsInitialized((Instruction)invokespecial, referenceType);\n                     }\n                     else {\n-                        this.constraintViolated((Instruction)o, \"Expecting a '\" + fromDesc + \"' but found a '\" + fromStack + \"' on the stack.\");\n+                        this.constraintViolated((Instruction)invokespecial, \"Expecting a '\" + int1 + \"' but found a '\" + peek + \"' on the stack.\");\n                     }\n                 }\n             }\n-            Type objref = this.stack().peek(nargs);\n-            if (objref == Type.NULL) {\n+            Object o = this.stack().peek(length);\n+            if (o == Type.NULL) {\n                 return;\n             }\n-            if (!(objref instanceof ReferenceType)) {\n-                this.constraintViolated((Instruction)o, \"Expecting a reference type as 'objectref' on the stack, not a '\" + objref + \"'.\");\n+            if (!(o instanceof ReferenceType)) {\n+                this.constraintViolated((Instruction)invokespecial, \"Expecting a reference type as 'objectref' on the stack, not a '\" + o + \"'.\");\n             }\n-            String objref_classname = null;\n-            if (!o.getMethodName(this.cpg).equals(\"<init>\")) {\n-                this.referenceTypeIsInitialized((Instruction)o, (ReferenceType)objref);\n-                if (!(objref instanceof ObjectType)) {\n-                    if (!(objref instanceof ArrayType)) {\n-                        this.constraintViolated((Instruction)o, \"Expecting an ObjectType as 'objectref' on the stack, not a '\" + objref + \"'.\");\n+            String s;\n+            if (!invokespecial.getMethodName(this.cpg).equals(\"<init>\")) {\n+                this.referenceTypeIsInitialized((Instruction)invokespecial, (ReferenceType)o);\n+                if (!(o instanceof ObjectType)) {\n+                    if (!(o instanceof ArrayType)) {\n+                        this.constraintViolated((Instruction)invokespecial, \"Expecting an ObjectType as 'objectref' on the stack, not a '\" + o + \"'.\");\n                     }\n                     else {\n-                        objref = (Type)InstConstraintVisitor.GENERIC_ARRAY;\n+                        o = InstConstraintVisitor.GENERIC_ARRAY;\n                     }\n                 }\n-                objref_classname = ((ObjectType)objref).getClassName();\n+                s = ((ObjectType)o).getClassName();\n             }\n             else {\n-                if (!(objref instanceof UninitializedObjectType)) {\n-                    this.constraintViolated((Instruction)o, \"Expecting an UninitializedObjectType as 'objectref' on the stack, not a '\" + objref + \"'. Otherwise, you couldn't invoke a method since an array has no methods (not to speak of a return address).\");\n+                if (!(o instanceof UninitializedObjectType)) {\n+                    this.constraintViolated((Instruction)invokespecial, \"Expecting an UninitializedObjectType as 'objectref' on the stack, not a '\" + o + \"'. Otherwise, you couldn't invoke a method since an array has no methods (not to speak of a return address).\");\n                 }\n-                objref_classname = ((UninitializedObjectType)objref).getInitialized().getClassName();\n+                s = ((UninitializedObjectType)o).getInitialized().getClassName();\n             }\n-            final String theClass = o.getClassName(this.cpg);\n-            if (!Repository.instanceOf(objref_classname, theClass)) {\n-                this.constraintViolated((Instruction)o, \"The 'objref' item '\" + objref + \"' does not implement '\" + theClass + \"' as expected.\");\n+            final String className2 = invokespecial.getClassName(this.cpg);\n+            if (!Repository.instanceOf(s, className2)) {\n+                this.constraintViolated((Instruction)invokespecial, \"The 'objref' item '\" + o + \"' does not implement '\" + className2 + \"' as expected.\");\n             }\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj, (Throwable)obj);\n         }\n     }\n     \n-    public void visitINVOKESTATIC(final INVOKESTATIC o) {\n+    public void visitINVOKESTATIC(final INVOKESTATIC invokestatic) {\n         try {\n-            final Type t = o.getType(this.cpg);\n-            if (t instanceof ObjectType) {\n-                final String name = ((ObjectType)t).getClassName();\n-                final Verifier v = VerifierFactory.getVerifier(name);\n-                final VerificationResult vr = v.doPass2();\n-                if (vr.getStatus() != 1) {\n-                    this.constraintViolated((Instruction)o, \"Class '\" + name + \"' is referenced, but cannot be loaded and resolved: '\" + vr + \"'.\");\n-                }\n-            }\n-            final Type[] argtypes = o.getArgumentTypes(this.cpg);\n-            final int nargs = argtypes.length;\n-            for (int i = nargs - 1; i >= 0; --i) {\n-                final Type fromStack = this.stack().peek(nargs - 1 - i);\n-                Type fromDesc = argtypes[i];\n-                if (fromDesc == Type.BOOLEAN || fromDesc == Type.BYTE || fromDesc == Type.CHAR || fromDesc == Type.SHORT) {\n-                    fromDesc = (Type)Type.INT;\n-                }\n-                if (!fromStack.equals((Object)fromDesc)) {\n-                    if (fromStack instanceof ReferenceType && fromDesc instanceof ReferenceType) {\n-                        final ReferenceType rFromStack = (ReferenceType)fromStack;\n-                        final ReferenceType rFromDesc = (ReferenceType)fromDesc;\n-                        if (!rFromStack.isAssignmentCompatibleWith((Type)rFromDesc)) {\n-                            this.constraintViolated((Instruction)o, \"Expecting a '\" + fromDesc + \"' but found a '\" + fromStack + \"' on the stack (which is not assignment compatible).\");\n+            final Type type = invokestatic.getType(this.cpg);\n+            if (type instanceof ObjectType) {\n+                final String className = ((ObjectType)type).getClassName();\n+                final VerificationResult doPass2 = VerifierFactory.getVerifier(className).doPass2();\n+                if (doPass2.getStatus() != 1) {\n+                    this.constraintViolated((Instruction)invokestatic, \"Class '\" + className + \"' is referenced, but cannot be loaded and resolved: '\" + doPass2 + \"'.\");\n+                }\n+            }\n+            final Type[] argumentTypes = invokestatic.getArgumentTypes(this.cpg);\n+            final int length = argumentTypes.length;\n+            for (int i = length - 1; i >= 0; --i) {\n+                final Type peek = this.stack().peek(length - 1 - i);\n+                Object int1 = argumentTypes[i];\n+                if (int1 == Type.BOOLEAN || int1 == Type.BYTE || int1 == Type.CHAR || int1 == Type.SHORT) {\n+                    int1 = Type.INT;\n+                }\n+                if (!peek.equals(int1)) {\n+                    if (peek instanceof ReferenceType && int1 instanceof ReferenceType) {\n+                        final ReferenceType referenceType = (ReferenceType)peek;\n+                        if (!referenceType.isAssignmentCompatibleWith((Type)(ReferenceType)int1)) {\n+                            this.constraintViolated((Instruction)invokestatic, \"Expecting a '\" + int1 + \"' but found a '\" + peek + \"' on the stack (which is not assignment compatible).\");\n                         }\n-                        this.referenceTypeIsInitialized((Instruction)o, rFromStack);\n+                        this.referenceTypeIsInitialized((Instruction)invokestatic, referenceType);\n                     }\n                     else {\n-                        this.constraintViolated((Instruction)o, \"Expecting a '\" + fromDesc + \"' but found a '\" + fromStack + \"' on the stack.\");\n+                        this.constraintViolated((Instruction)invokestatic, \"Expecting a '\" + int1 + \"' but found a '\" + peek + \"' on the stack.\");\n                     }\n                 }\n             }\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj, (Throwable)obj);\n         }\n     }\n     \n-    public void visitINVOKEVIRTUAL(final INVOKEVIRTUAL o) {\n+    public void visitINVOKEVIRTUAL(final INVOKEVIRTUAL invokevirtual) {\n         try {\n-            final Type t = o.getType(this.cpg);\n-            if (t instanceof ObjectType) {\n-                final String name = ((ObjectType)t).getClassName();\n-                final Verifier v = VerifierFactory.getVerifier(name);\n-                final VerificationResult vr = v.doPass2();\n-                if (vr.getStatus() != 1) {\n-                    this.constraintViolated((Instruction)o, \"Class '\" + name + \"' is referenced, but cannot be loaded and resolved: '\" + vr + \"'.\");\n-                }\n-            }\n-            final Type[] argtypes = o.getArgumentTypes(this.cpg);\n-            final int nargs = argtypes.length;\n-            for (int i = nargs - 1; i >= 0; --i) {\n-                final Type fromStack = this.stack().peek(nargs - 1 - i);\n-                Type fromDesc = argtypes[i];\n-                if (fromDesc == Type.BOOLEAN || fromDesc == Type.BYTE || fromDesc == Type.CHAR || fromDesc == Type.SHORT) {\n-                    fromDesc = (Type)Type.INT;\n-                }\n-                if (!fromStack.equals((Object)fromDesc)) {\n-                    if (fromStack instanceof ReferenceType && fromDesc instanceof ReferenceType) {\n-                        final ReferenceType rFromStack = (ReferenceType)fromStack;\n-                        final ReferenceType rFromDesc = (ReferenceType)fromDesc;\n-                        if (!rFromStack.isAssignmentCompatibleWith((Type)rFromDesc)) {\n-                            this.constraintViolated((Instruction)o, \"Expecting a '\" + fromDesc + \"' but found a '\" + fromStack + \"' on the stack (which is not assignment compatible).\");\n+            final Type type = invokevirtual.getType(this.cpg);\n+            if (type instanceof ObjectType) {\n+                final String className = ((ObjectType)type).getClassName();\n+                final VerificationResult doPass2 = VerifierFactory.getVerifier(className).doPass2();\n+                if (doPass2.getStatus() != 1) {\n+                    this.constraintViolated((Instruction)invokevirtual, \"Class '\" + className + \"' is referenced, but cannot be loaded and resolved: '\" + doPass2 + \"'.\");\n+                }\n+            }\n+            final Type[] argumentTypes = invokevirtual.getArgumentTypes(this.cpg);\n+            final int length = argumentTypes.length;\n+            for (int i = length - 1; i >= 0; --i) {\n+                final Type peek = this.stack().peek(length - 1 - i);\n+                Object int1 = argumentTypes[i];\n+                if (int1 == Type.BOOLEAN || int1 == Type.BYTE || int1 == Type.CHAR || int1 == Type.SHORT) {\n+                    int1 = Type.INT;\n+                }\n+                if (!peek.equals(int1)) {\n+                    if (peek instanceof ReferenceType && int1 instanceof ReferenceType) {\n+                        final ReferenceType referenceType = (ReferenceType)peek;\n+                        if (!referenceType.isAssignmentCompatibleWith((Type)(ReferenceType)int1)) {\n+                            this.constraintViolated((Instruction)invokevirtual, \"Expecting a '\" + int1 + \"' but found a '\" + peek + \"' on the stack (which is not assignment compatible).\");\n                         }\n-                        this.referenceTypeIsInitialized((Instruction)o, rFromStack);\n+                        this.referenceTypeIsInitialized((Instruction)invokevirtual, referenceType);\n                     }\n                     else {\n-                        this.constraintViolated((Instruction)o, \"Expecting a '\" + fromDesc + \"' but found a '\" + fromStack + \"' on the stack.\");\n+                        this.constraintViolated((Instruction)invokevirtual, \"Expecting a '\" + int1 + \"' but found a '\" + peek + \"' on the stack.\");\n                     }\n                 }\n             }\n-            Type objref = this.stack().peek(nargs);\n-            if (objref == Type.NULL) {\n+            Object obj = this.stack().peek(length);\n+            if (obj == Type.NULL) {\n                 return;\n             }\n-            if (!(objref instanceof ReferenceType)) {\n-                this.constraintViolated((Instruction)o, \"Expecting a reference type as 'objectref' on the stack, not a '\" + objref + \"'.\");\n+            if (!(obj instanceof ReferenceType)) {\n+                this.constraintViolated((Instruction)invokevirtual, \"Expecting a reference type as 'objectref' on the stack, not a '\" + obj + \"'.\");\n             }\n-            this.referenceTypeIsInitialized((Instruction)o, (ReferenceType)objref);\n-            if (!(objref instanceof ObjectType)) {\n-                if (!(objref instanceof ArrayType)) {\n-                    this.constraintViolated((Instruction)o, \"Expecting an ObjectType as 'objectref' on the stack, not a '\" + objref + \"'.\");\n+            this.referenceTypeIsInitialized((Instruction)invokevirtual, (ReferenceType)obj);\n+            if (!(obj instanceof ObjectType)) {\n+                if (!(obj instanceof ArrayType)) {\n+                    this.constraintViolated((Instruction)invokevirtual, \"Expecting an ObjectType as 'objectref' on the stack, not a '\" + obj + \"'.\");\n                 }\n                 else {\n-                    objref = (Type)InstConstraintVisitor.GENERIC_ARRAY;\n+                    obj = InstConstraintVisitor.GENERIC_ARRAY;\n                 }\n             }\n-            final String objref_classname = ((ObjectType)objref).getClassName();\n-            final String theClass = o.getClassName(this.cpg);\n-            if (!Repository.instanceOf(objref_classname, theClass)) {\n-                this.constraintViolated((Instruction)o, \"The 'objref' item '\" + objref + \"' does not implement '\" + theClass + \"' as expected.\");\n+            final String className2 = ((ObjectType)obj).getClassName();\n+            final String className3 = invokevirtual.getClassName(this.cpg);\n+            if (!Repository.instanceOf(className2, className3)) {\n+                this.constraintViolated((Instruction)invokevirtual, \"The 'objref' item '\" + obj + \"' does not implement '\" + className3 + \"' as expected.\");\n             }\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj2) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj2, (Throwable)obj2);\n         }\n     }\n     \n-    public void visitIOR(final IOR o) {\n+    public void visitIOR(final IOR ior) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)ior, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)ior, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitIREM(final IREM o) {\n+    public void visitIREM(final IREM irem) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)irem, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)irem, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitIRETURN(final IRETURN o) {\n+    public void visitIRETURN(final IRETURN ireturn) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)ireturn, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitISHL(final ISHL o) {\n+    public void visitISHL(final ISHL ishl) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)ishl, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)ishl, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitISHR(final ISHR o) {\n+    public void visitISHR(final ISHR ishr) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)ishr, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)ishr, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitISTORE(final ISTORE o) {\n+    public void visitISTORE(final ISTORE istore) {\n     }\n     \n-    public void visitISUB(final ISUB o) {\n+    public void visitISUB(final ISUB isub) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)isub, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)isub, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitIUSHR(final IUSHR o) {\n+    public void visitIUSHR(final IUSHR iushr) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)iushr, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)iushr, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitIXOR(final IXOR o) {\n+    public void visitIXOR(final IXOR ixor) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)ixor, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)ixor, \"The value at the stack next-to-top is not of type 'int', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitJSR(final JSR o) {\n+    public void visitJSR(final JSR jsr) {\n     }\n     \n-    public void visitJSR_W(final JSR_W o) {\n+    public void visitJSR_W(final JSR_W jsr_W) {\n     }\n     \n-    public void visitL2D(final L2D o) {\n+    public void visitL2D(final L2D l2D) {\n         if (this.stack().peek() != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)l2D, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitL2F(final L2F o) {\n+    public void visitL2F(final L2F l2F) {\n         if (this.stack().peek() != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)l2F, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitL2I(final L2I o) {\n+    public void visitL2I(final L2I l2I) {\n         if (this.stack().peek() != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)l2I, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitLADD(final LADD o) {\n+    public void visitLADD(final LADD ladd) {\n         if (this.stack().peek() != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)ladd, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'long', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)ladd, \"The value at the stack next-to-top is not of type 'long', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitLALOAD(final LALOAD o) {\n-        this.indexOfInt((Instruction)o, this.stack().peek());\n+    public void visitLALOAD(final LALOAD laload) {\n+        this.indexOfInt((Instruction)laload, this.stack().peek());\n         if (this.stack().peek(1) == Type.NULL) {\n             return;\n         }\n         if (!(this.stack().peek(1) instanceof ArrayType)) {\n-            this.constraintViolated((Instruction)o, \"Stack next-to-top must be of type long[] but is '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)laload, \"Stack next-to-top must be of type long[] but is '\" + this.stack().peek(1) + \"'.\");\n         }\n-        final Type t = ((ArrayType)this.stack().peek(1)).getBasicType();\n-        if (t != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"Stack next-to-top must be of type long[] but is '\" + this.stack().peek(1) + \"'.\");\n+        if (((ArrayType)this.stack().peek(1)).getBasicType() != Type.LONG) {\n+            this.constraintViolated((Instruction)laload, \"Stack next-to-top must be of type long[] but is '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitLAND(final LAND o) {\n+    public void visitLAND(final LAND land) {\n         if (this.stack().peek() != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)land, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'long', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)land, \"The value at the stack next-to-top is not of type 'long', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitLASTORE(final LASTORE o) {\n+    public void visitLASTORE(final LASTORE lastore) {\n         if (this.stack().peek() != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)lastore, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n         }\n-        this.indexOfInt((Instruction)o, this.stack().peek(1));\n+        this.indexOfInt((Instruction)lastore, this.stack().peek(1));\n         if (this.stack().peek(2) == Type.NULL) {\n             return;\n         }\n         if (!(this.stack().peek(2) instanceof ArrayType)) {\n-            this.constraintViolated((Instruction)o, \"Stack next-to-next-to-top must be of type long[] but is '\" + this.stack().peek(2) + \"'.\");\n+            this.constraintViolated((Instruction)lastore, \"Stack next-to-next-to-top must be of type long[] but is '\" + this.stack().peek(2) + \"'.\");\n         }\n-        final Type t = ((ArrayType)this.stack().peek(2)).getBasicType();\n-        if (t != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"Stack next-to-next-to-top must be of type long[] but is '\" + this.stack().peek(2) + \"'.\");\n+        if (((ArrayType)this.stack().peek(2)).getBasicType() != Type.LONG) {\n+            this.constraintViolated((Instruction)lastore, \"Stack next-to-next-to-top must be of type long[] but is '\" + this.stack().peek(2) + \"'.\");\n         }\n     }\n     \n-    public void visitLCMP(final LCMP o) {\n+    public void visitLCMP(final LCMP lcmp) {\n         if (this.stack().peek() != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)lcmp, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'long', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)lcmp, \"The value at the stack next-to-top is not of type 'long', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitLCONST(final LCONST o) {\n+    public void visitLCONST(final LCONST lconst) {\n     }\n     \n-    public void visitLDC(final LDC o) {\n-        final Constant c = this.cpg.getConstant(o.getIndex());\n-        if (!(c instanceof ConstantInteger) && !(c instanceof ConstantFloat) && !(c instanceof ConstantString) && !(c instanceof ConstantClass)) {\n-            this.constraintViolated((Instruction)o, \"Referenced constant should be a CONSTANT_Integer, a CONSTANT_Float, a CONSTANT_String or a CONSTANT_Class, but is '\" + c + \"'.\");\n+    public void visitLDC(final LDC ldc) {\n+        final Constant constant = this.cpg.getConstant(ldc.getIndex());\n+        if (!(constant instanceof ConstantInteger) && !(constant instanceof ConstantFloat) && !(constant instanceof ConstantString) && !(constant instanceof ConstantClass)) {\n+            this.constraintViolated((Instruction)ldc, \"Referenced constant should be a CONSTANT_Integer, a CONSTANT_Float, a CONSTANT_String or a CONSTANT_Class, but is '\" + constant + \"'.\");\n         }\n     }\n     \n-    public void visitLDC_W(final LDC_W o) {\n-        final Constant c = this.cpg.getConstant(o.getIndex());\n-        if (!(c instanceof ConstantInteger) && !(c instanceof ConstantFloat) && !(c instanceof ConstantString) && !(c instanceof ConstantClass)) {\n-            this.constraintViolated((Instruction)o, \"Referenced constant should be a CONSTANT_Integer, a CONSTANT_Float, a CONSTANT_String or a CONSTANT_Class, but is '\" + c + \"'.\");\n+    public void visitLDC_W(final LDC_W ldc_W) {\n+        final Constant constant = this.cpg.getConstant(ldc_W.getIndex());\n+        if (!(constant instanceof ConstantInteger) && !(constant instanceof ConstantFloat) && !(constant instanceof ConstantString) && !(constant instanceof ConstantClass)) {\n+            this.constraintViolated((Instruction)ldc_W, \"Referenced constant should be a CONSTANT_Integer, a CONSTANT_Float, a CONSTANT_String or a CONSTANT_Class, but is '\" + constant + \"'.\");\n         }\n     }\n     \n-    public void visitLDC2_W(final LDC2_W o) {\n-        final Constant c = this.cpg.getConstant(o.getIndex());\n-        if (!(c instanceof ConstantLong) && !(c instanceof ConstantDouble)) {\n-            this.constraintViolated((Instruction)o, \"Referenced constant should be a CONSTANT_Integer, a CONSTANT_Float or a CONSTANT_String, but is '\" + c + \"'.\");\n+    public void visitLDC2_W(final LDC2_W ldc2_W) {\n+        final Constant constant = this.cpg.getConstant(ldc2_W.getIndex());\n+        if (!(constant instanceof ConstantLong) && !(constant instanceof ConstantDouble)) {\n+            this.constraintViolated((Instruction)ldc2_W, \"Referenced constant should be a CONSTANT_Integer, a CONSTANT_Float or a CONSTANT_String, but is '\" + constant + \"'.\");\n         }\n     }\n     \n-    public void visitLDIV(final LDIV o) {\n+    public void visitLDIV(final LDIV ldiv) {\n         if (this.stack().peek() != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)ldiv, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'long', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)ldiv, \"The value at the stack next-to-top is not of type 'long', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitLLOAD(final LLOAD o) {\n+    public void visitLLOAD(final LLOAD lload) {\n     }\n     \n-    public void visitLMUL(final LMUL o) {\n+    public void visitLMUL(final LMUL lmul) {\n         if (this.stack().peek() != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)lmul, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'long', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)lmul, \"The value at the stack next-to-top is not of type 'long', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitLNEG(final LNEG o) {\n+    public void visitLNEG(final LNEG lneg) {\n         if (this.stack().peek() != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)lneg, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitLOOKUPSWITCH(final LOOKUPSWITCH o) {\n+    public void visitLOOKUPSWITCH(final LOOKUPSWITCH lookupswitch) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)lookupswitch, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitLOR(final LOR o) {\n+    public void visitLOR(final LOR lor) {\n         if (this.stack().peek() != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)lor, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'long', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)lor, \"The value at the stack next-to-top is not of type 'long', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitLREM(final LREM o) {\n+    public void visitLREM(final LREM lrem) {\n         if (this.stack().peek() != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)lrem, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'long', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)lrem, \"The value at the stack next-to-top is not of type 'long', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitLRETURN(final LRETURN o) {\n+    public void visitLRETURN(final LRETURN lreturn) {\n         if (this.stack().peek() != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)lreturn, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitLSHL(final LSHL o) {\n+    public void visitLSHL(final LSHL lshl) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)lshl, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'long', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)lshl, \"The value at the stack next-to-top is not of type 'long', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitLSHR(final LSHR o) {\n+    public void visitLSHR(final LSHR lshr) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)lshr, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'long', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)lshr, \"The value at the stack next-to-top is not of type 'long', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitLSTORE(final LSTORE o) {\n+    public void visitLSTORE(final LSTORE lstore) {\n     }\n     \n-    public void visitLSUB(final LSUB o) {\n+    public void visitLSUB(final LSUB lsub) {\n         if (this.stack().peek() != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)lsub, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'long', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)lsub, \"The value at the stack next-to-top is not of type 'long', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitLUSHR(final LUSHR o) {\n+    public void visitLUSHR(final LUSHR lushr) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)lushr, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'long', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)lushr, \"The value at the stack next-to-top is not of type 'long', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitLXOR(final LXOR o) {\n+    public void visitLXOR(final LXOR lxor) {\n         if (this.stack().peek() != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)lxor, \"The value at the stack top is not of type 'long', but of type '\" + this.stack().peek() + \"'.\");\n         }\n         if (this.stack().peek(1) != Type.LONG) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of type 'long', but of type '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)lxor, \"The value at the stack next-to-top is not of type 'long', but of type '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitMONITORENTER(final MONITORENTER o) {\n+    public void visitMONITORENTER(final MONITORENTER monitorenter) {\n         if (!(this.stack().peek() instanceof ReferenceType)) {\n-            this.constraintViolated((Instruction)o, \"The stack top should be of a ReferenceType, but is '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)monitorenter, \"The stack top should be of a ReferenceType, but is '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitMONITOREXIT(final MONITOREXIT o) {\n+    public void visitMONITOREXIT(final MONITOREXIT monitorexit) {\n         if (!(this.stack().peek() instanceof ReferenceType)) {\n-            this.constraintViolated((Instruction)o, \"The stack top should be of a ReferenceType, but is '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)monitorexit, \"The stack top should be of a ReferenceType, but is '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitMULTIANEWARRAY(final MULTIANEWARRAY o) {\n-        for (int dimensions = o.getDimensions(), i = 0; i < dimensions; ++i) {\n-            if (this.stack().peek(i) != Type.INT) {\n-                this.constraintViolated((Instruction)o, \"The '\" + dimensions + \"' upper stack types should be 'int' but aren't.\");\n+    public void visitMULTIANEWARRAY(final MULTIANEWARRAY multianewarray) {\n+        for (short dimensions = multianewarray.getDimensions(), n = 0; n < dimensions; ++n) {\n+            if (this.stack().peek((int)n) != Type.INT) {\n+                this.constraintViolated((Instruction)multianewarray, \"The '\" + dimensions + \"' upper stack types should be 'int' but aren't.\");\n             }\n         }\n     }\n     \n-    public void visitNEW(final NEW o) {\n-        final Type t = o.getType(this.cpg);\n-        if (!(t instanceof ReferenceType)) {\n+    public void visitNEW(final NEW new1) {\n+        final Type type = new1.getType(this.cpg);\n+        if (!(type instanceof ReferenceType)) {\n             throw new AssertionViolatedException(\"NEW.getType() returning a non-reference type?!\");\n         }\n-        if (!(t instanceof ObjectType)) {\n-            this.constraintViolated((Instruction)o, \"Expecting a class type (ObjectType) to work on. Found: '\" + t + \"'.\");\n+        if (!(type instanceof ObjectType)) {\n+            this.constraintViolated((Instruction)new1, \"Expecting a class type (ObjectType) to work on. Found: '\" + type + \"'.\");\n         }\n-        final ObjectType obj = (ObjectType)t;\n+        final ObjectType objectType = (ObjectType)type;\n         try {\n-            if (!obj.referencesClassExact()) {\n-                this.constraintViolated((Instruction)o, \"Expecting a class type (ObjectType) to work on. Found: '\" + obj + \"'.\");\n+            if (!objectType.referencesClassExact()) {\n+                this.constraintViolated((Instruction)new1, \"Expecting a class type (ObjectType) to work on. Found: '\" + objectType + \"'.\");\n             }\n         }\n-        catch (final ClassNotFoundException e) {\n-            this.constraintViolated((Instruction)o, \"Expecting a class type (ObjectType) to work on. Found: '\" + obj + \"'. which threw \" + e);\n+        catch (final ClassNotFoundException obj) {\n+            this.constraintViolated((Instruction)new1, \"Expecting a class type (ObjectType) to work on. Found: '\" + objectType + \"'. which threw \" + obj);\n         }\n     }\n     \n-    public void visitNEWARRAY(final NEWARRAY o) {\n+    public void visitNEWARRAY(final NEWARRAY newarray) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)newarray, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n     }\n     \n-    public void visitNOP(final NOP o) {\n+    public void visitNOP(final NOP nop) {\n     }\n     \n-    public void visitPOP(final POP o) {\n+    public void visitPOP(final POP pop) {\n         if (this.stack().peek().getSize() != 1) {\n-            this.constraintViolated((Instruction)o, \"Stack top size should be 1 but stack top is '\" + this.stack().peek() + \"' of size '\" + this.stack().peek().getSize() + \"'.\");\n+            this.constraintViolated((Instruction)pop, \"Stack top size should be 1 but stack top is '\" + this.stack().peek() + \"' of size '\" + this.stack().peek().getSize() + \"'.\");\n         }\n     }\n     \n-    public void visitPOP2(final POP2 o) {\n+    public void visitPOP2(final POP2 pop2) {\n         if (this.stack().peek().getSize() != 2) {\n-            this.constraintViolated((Instruction)o, \"Stack top size should be 2 but stack top is '\" + this.stack().peek() + \"' of size '\" + this.stack().peek().getSize() + \"'.\");\n+            this.constraintViolated((Instruction)pop2, \"Stack top size should be 2 but stack top is '\" + this.stack().peek() + \"' of size '\" + this.stack().peek().getSize() + \"'.\");\n         }\n     }\n     \n-    public void visitPUTFIELD(final PUTFIELD o) {\n+    public void visitPUTFIELD(final PUTFIELD putfield) {\n         try {\n-            final Type objectref = this.stack().peek(1);\n-            if (!(objectref instanceof ObjectType) && objectref != Type.NULL) {\n-                this.constraintViolated((Instruction)o, \"Stack next-to-top should be an object reference that's not an array reference, but is '\" + objectref + \"'.\");\n-            }\n-            final String field_name = o.getFieldName(this.cpg);\n-            final JavaClass jc = Repository.lookupClass(this.getObjectType((FieldInstruction)o).getClassName());\n-            final Field[] fields = jc.getFields();\n-            Field f = null;\n+            final Type peek = this.stack().peek(1);\n+            if (!(peek instanceof ObjectType) && peek != Type.NULL) {\n+                this.constraintViolated((Instruction)putfield, \"Stack next-to-top should be an object reference that's not an array reference, but is '\" + peek + \"'.\");\n+            }\n+            final String fieldName = putfield.getFieldName(this.cpg);\n+            final JavaClass lookupClass = Repository.lookupClass(this.getObjectType((FieldInstruction)putfield).getClassName());\n+            final Field[] fields = lookupClass.getFields();\n+            Field obj = null;\n             for (final Field field : fields) {\n-                if (field.getName().equals(field_name)) {\n-                    final Type f_type = Type.getType(field.getSignature());\n-                    final Type o_type = o.getType(this.cpg);\n-                    if (f_type.equals((Object)o_type)) {\n-                        f = field;\n-                        break;\n-                    }\n-                }\n-            }\n-            if (f == null) {\n-                throw new AssertionViolatedException(\"Field '\" + field_name + \"' not found in \" + jc.getClassName());\n-            }\n-            final Type value = this.stack().peek();\n-            Type shouldbe;\n-            final Type t = shouldbe = Type.getType(f.getSignature());\n-            if (shouldbe == Type.BOOLEAN || shouldbe == Type.BYTE || shouldbe == Type.CHAR || shouldbe == Type.SHORT) {\n-                shouldbe = (Type)Type.INT;\n-            }\n-            if (t instanceof ReferenceType) {\n-                ReferenceType rvalue = null;\n-                if (value instanceof ReferenceType) {\n-                    rvalue = (ReferenceType)value;\n-                    this.referenceTypeIsInitialized((Instruction)o, rvalue);\n+                if (field.getName().equals(fieldName) && Type.getType(field.getSignature()).equals((Object)putfield.getType(this.cpg))) {\n+                    obj = field;\n+                    break;\n+                }\n+            }\n+            if (obj == null) {\n+                throw new AssertionViolatedException(\"Field '\" + fieldName + \"' not found in \" + lookupClass.getClassName());\n+            }\n+            final Type peek2 = this.stack().peek();\n+            Object o;\n+            final Type type = (Type)(o = Type.getType(obj.getSignature()));\n+            if (o == Type.BOOLEAN || o == Type.BYTE || o == Type.CHAR || o == Type.SHORT) {\n+                o = Type.INT;\n+            }\n+            if (type instanceof ReferenceType) {\n+                ReferenceType referenceType = null;\n+                if (peek2 instanceof ReferenceType) {\n+                    referenceType = (ReferenceType)peek2;\n+                    this.referenceTypeIsInitialized((Instruction)putfield, referenceType);\n                 }\n                 else {\n-                    this.constraintViolated((Instruction)o, \"The stack top type '\" + value + \"' is not of a reference type as expected.\");\n+                    this.constraintViolated((Instruction)putfield, \"The stack top type '\" + peek2 + \"' is not of a reference type as expected.\");\n                 }\n-                if (!rvalue.isAssignmentCompatibleWith(shouldbe)) {\n-                    this.constraintViolated((Instruction)o, \"The stack top type '\" + value + \"' is not assignment compatible with '\" + shouldbe + \"'.\");\n+                if (!referenceType.isAssignmentCompatibleWith((Type)o)) {\n+                    this.constraintViolated((Instruction)putfield, \"The stack top type '\" + peek2 + \"' is not assignment compatible with '\" + o + \"'.\");\n                 }\n             }\n-            else if (shouldbe != value) {\n-                this.constraintViolated((Instruction)o, \"The stack top type '\" + value + \"' is not of type '\" + shouldbe + \"' as expected.\");\n+            else if (o != peek2) {\n+                this.constraintViolated((Instruction)putfield, \"The stack top type '\" + peek2 + \"' is not of type '\" + o + \"' as expected.\");\n             }\n-            if (f.isProtected()) {\n-                final ObjectType classtype = this.getObjectType((FieldInstruction)o);\n-                final ObjectType curr = ObjectType.getInstance(this.mg.getClassName());\n-                if (classtype.equals((Object)curr) || curr.subclassOf(classtype)) {\n-                    final Type tp = this.stack().peek(1);\n-                    if (tp == Type.NULL) {\n+            if (obj.isProtected()) {\n+                final ObjectType objectType = this.getObjectType((FieldInstruction)putfield);\n+                final ObjectType instance = ObjectType.getInstance(this.mg.getClassName());\n+                if (objectType.equals((Object)instance) || instance.subclassOf(objectType)) {\n+                    final Type peek3 = this.stack().peek(1);\n+                    if (peek3 == Type.NULL) {\n                         return;\n                     }\n-                    if (!(tp instanceof ObjectType)) {\n-                        this.constraintViolated((Instruction)o, \"The 'objectref' must refer to an object that's not an array. Found instead: '\" + tp + \"'.\");\n+                    if (!(peek3 instanceof ObjectType)) {\n+                        this.constraintViolated((Instruction)putfield, \"The 'objectref' must refer to an object that's not an array. Found instead: '\" + peek3 + \"'.\");\n                     }\n-                    final ObjectType objreftype = (ObjectType)tp;\n-                    if (!objreftype.equals((Object)curr) && !objreftype.subclassOf(curr)) {\n-                        this.constraintViolated((Instruction)o, \"The referenced field has the ACC_PROTECTED modifier, and it's a member of the current class or a superclass of the current class. However, the referenced object type '\" + this.stack().peek() + \"' is not the current class or a subclass of the current class.\");\n+                    final ObjectType objectType2 = (ObjectType)peek3;\n+                    if (!objectType2.equals((Object)instance) && !objectType2.subclassOf(instance)) {\n+                        this.constraintViolated((Instruction)putfield, \"The referenced field has the ACC_PROTECTED modifier, and it's a member of the current class or a superclass of the current class. However, the referenced object type '\" + this.stack().peek() + \"' is not the current class or a subclass of the current class.\");\n                     }\n                 }\n             }\n-            if (f.isStatic()) {\n-                this.constraintViolated((Instruction)o, \"Referenced field '\" + f + \"' is static which it shouldn't be.\");\n+            if (obj.isStatic()) {\n+                this.constraintViolated((Instruction)putfield, \"Referenced field '\" + obj + \"' is static which it shouldn't be.\");\n             }\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj2) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj2, (Throwable)obj2);\n         }\n     }\n     \n-    public void visitPUTSTATIC(final PUTSTATIC o) {\n+    public void visitPUTSTATIC(final PUTSTATIC putstatic) {\n         try {\n-            final String field_name = o.getFieldName(this.cpg);\n-            final JavaClass jc = Repository.lookupClass(this.getObjectType((FieldInstruction)o).getClassName());\n-            final Field[] fields = jc.getFields();\n-            Field f = null;\n-            for (final Field field : fields) {\n-                if (field.getName().equals(field_name)) {\n-                    final Type f_type = Type.getType(field.getSignature());\n-                    final Type o_type = o.getType(this.cpg);\n-                    if (f_type.equals((Object)o_type)) {\n-                        f = field;\n-                        break;\n-                    }\n-                }\n-            }\n-            if (f == null) {\n-                throw new AssertionViolatedException(\"Field '\" + field_name + \"' not found in \" + jc.getClassName());\n-            }\n-            final Type value = this.stack().peek();\n-            Type shouldbe;\n-            final Type t = shouldbe = Type.getType(f.getSignature());\n-            if (shouldbe == Type.BOOLEAN || shouldbe == Type.BYTE || shouldbe == Type.CHAR || shouldbe == Type.SHORT) {\n-                shouldbe = (Type)Type.INT;\n-            }\n-            if (t instanceof ReferenceType) {\n-                ReferenceType rvalue = null;\n-                if (value instanceof ReferenceType) {\n-                    rvalue = (ReferenceType)value;\n-                    this.referenceTypeIsInitialized((Instruction)o, rvalue);\n+            final String fieldName = putstatic.getFieldName(this.cpg);\n+            final JavaClass lookupClass = Repository.lookupClass(this.getObjectType((FieldInstruction)putstatic).getClassName());\n+            final Field[] fields = lookupClass.getFields();\n+            Field field = null;\n+            for (final Field field2 : fields) {\n+                if (field2.getName().equals(fieldName) && Type.getType(field2.getSignature()).equals((Object)putstatic.getType(this.cpg))) {\n+                    field = field2;\n+                    break;\n+                }\n+            }\n+            if (field == null) {\n+                throw new AssertionViolatedException(\"Field '\" + fieldName + \"' not found in \" + lookupClass.getClassName());\n+            }\n+            final Type peek = this.stack().peek();\n+            Object o;\n+            final Type type = (Type)(o = Type.getType(field.getSignature()));\n+            if (o == Type.BOOLEAN || o == Type.BYTE || o == Type.CHAR || o == Type.SHORT) {\n+                o = Type.INT;\n+            }\n+            if (type instanceof ReferenceType) {\n+                ReferenceType referenceType = null;\n+                if (peek instanceof ReferenceType) {\n+                    referenceType = (ReferenceType)peek;\n+                    this.referenceTypeIsInitialized((Instruction)putstatic, referenceType);\n                 }\n                 else {\n-                    this.constraintViolated((Instruction)o, \"The stack top type '\" + value + \"' is not of a reference type as expected.\");\n+                    this.constraintViolated((Instruction)putstatic, \"The stack top type '\" + peek + \"' is not of a reference type as expected.\");\n                 }\n-                if (!rvalue.isAssignmentCompatibleWith(shouldbe)) {\n-                    this.constraintViolated((Instruction)o, \"The stack top type '\" + value + \"' is not assignment compatible with '\" + shouldbe + \"'.\");\n+                if (!referenceType.isAssignmentCompatibleWith((Type)o)) {\n+                    this.constraintViolated((Instruction)putstatic, \"The stack top type '\" + peek + \"' is not assignment compatible with '\" + o + \"'.\");\n                 }\n             }\n-            else if (shouldbe != value) {\n-                this.constraintViolated((Instruction)o, \"The stack top type '\" + value + \"' is not of type '\" + shouldbe + \"' as expected.\");\n+            else if (o != peek) {\n+                this.constraintViolated((Instruction)putstatic, \"The stack top type '\" + peek + \"' is not of type '\" + o + \"' as expected.\");\n             }\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj, (Throwable)obj);\n         }\n     }\n     \n-    public void visitRET(final RET o) {\n-        if (!(this.locals().get(o.getIndex()) instanceof ReturnaddressType)) {\n-            this.constraintViolated((Instruction)o, \"Expecting a ReturnaddressType in local variable \" + o.getIndex() + \".\");\n+    public void visitRET(final RET ret) {\n+        if (!(this.locals().get(ret.getIndex()) instanceof ReturnaddressType)) {\n+            this.constraintViolated((Instruction)ret, \"Expecting a ReturnaddressType in local variable \" + ret.getIndex() + \".\");\n         }\n-        if (this.locals().get(o.getIndex()) == ReturnaddressType.NO_TARGET) {\n+        if (this.locals().get(ret.getIndex()) == ReturnaddressType.NO_TARGET) {\n             throw new AssertionViolatedException(\"RET expecting a target!\");\n         }\n     }\n     \n-    public void visitRETURN(final RETURN o) {\n+    public void visitRETURN(final RETURN return1) {\n         if (this.mg.getName().equals(\"<init>\") && Frame.getThis() != null && !this.mg.getClassName().equals(Type.OBJECT.getClassName())) {\n-            this.constraintViolated((Instruction)o, \"Leaving a constructor that itself did not call a constructor.\");\n+            this.constraintViolated((Instruction)return1, \"Leaving a constructor that itself did not call a constructor.\");\n         }\n     }\n     \n-    public void visitSALOAD(final SALOAD o) {\n-        this.indexOfInt((Instruction)o, this.stack().peek());\n+    public void visitSALOAD(final SALOAD saload) {\n+        this.indexOfInt((Instruction)saload, this.stack().peek());\n         if (this.stack().peek(1) == Type.NULL) {\n             return;\n         }\n         if (!(this.stack().peek(1) instanceof ArrayType)) {\n-            this.constraintViolated((Instruction)o, \"Stack next-to-top must be of type short[] but is '\" + this.stack().peek(1) + \"'.\");\n+            this.constraintViolated((Instruction)saload, \"Stack next-to-top must be of type short[] but is '\" + this.stack().peek(1) + \"'.\");\n         }\n-        final Type t = ((ArrayType)this.stack().peek(1)).getBasicType();\n-        if (t != Type.SHORT) {\n-            this.constraintViolated((Instruction)o, \"Stack next-to-top must be of type short[] but is '\" + this.stack().peek(1) + \"'.\");\n+        if (((ArrayType)this.stack().peek(1)).getBasicType() != Type.SHORT) {\n+            this.constraintViolated((Instruction)saload, \"Stack next-to-top must be of type short[] but is '\" + this.stack().peek(1) + \"'.\");\n         }\n     }\n     \n-    public void visitSASTORE(final SASTORE o) {\n+    public void visitSASTORE(final SASTORE sastore) {\n         if (this.stack().peek() != Type.INT) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n+            this.constraintViolated((Instruction)sastore, \"The value at the stack top is not of type 'int', but of type '\" + this.stack().peek() + \"'.\");\n         }\n-        this.indexOfInt((Instruction)o, this.stack().peek(1));\n+        this.indexOfInt((Instruction)sastore, this.stack().peek(1));\n         if (this.stack().peek(2) == Type.NULL) {\n             return;\n         }\n         if (!(this.stack().peek(2) instanceof ArrayType)) {\n-            this.constraintViolated((Instruction)o, \"Stack next-to-next-to-top must be of type short[] but is '\" + this.stack().peek(2) + \"'.\");\n+            this.constraintViolated((Instruction)sastore, \"Stack next-to-next-to-top must be of type short[] but is '\" + this.stack().peek(2) + \"'.\");\n         }\n-        final Type t = ((ArrayType)this.stack().peek(2)).getBasicType();\n-        if (t != Type.SHORT) {\n-            this.constraintViolated((Instruction)o, \"Stack next-to-next-to-top must be of type short[] but is '\" + this.stack().peek(2) + \"'.\");\n+        if (((ArrayType)this.stack().peek(2)).getBasicType() != Type.SHORT) {\n+            this.constraintViolated((Instruction)sastore, \"Stack next-to-next-to-top must be of type short[] but is '\" + this.stack().peek(2) + \"'.\");\n         }\n     }\n     \n-    public void visitSIPUSH(final SIPUSH o) {\n+    public void visitSIPUSH(final SIPUSH sipush) {\n     }\n     \n-    public void visitSWAP(final SWAP o) {\n+    public void visitSWAP(final SWAP swap) {\n         if (this.stack().peek().getSize() != 1) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack top is not of size '1', but of size '\" + this.stack().peek().getSize() + \"'.\");\n+            this.constraintViolated((Instruction)swap, \"The value at the stack top is not of size '1', but of size '\" + this.stack().peek().getSize() + \"'.\");\n         }\n         if (this.stack().peek(1).getSize() != 1) {\n-            this.constraintViolated((Instruction)o, \"The value at the stack next-to-top is not of size '1', but of size '\" + this.stack().peek(1).getSize() + \"'.\");\n+            this.constraintViolated((Instruction)swap, \"The value at the stack next-to-top is not of size '1', but of size '\" + this.stack().peek(1).getSize() + \"'.\");\n         }\n     }\n     \n-    public void visitTABLESWITCH(final TABLESWITCH o) {\n-        this.indexOfInt((Instruction)o, this.stack().peek());\n+    public void visitTABLESWITCH(final TABLESWITCH tableswitch) {\n+        this.indexOfInt((Instruction)tableswitch, this.stack().peek());\n     }\n     \n     static {\n         GENERIC_ARRAY = ObjectType.getInstance(GenericArray.class.getName());\n     }\n }\n"}]}
