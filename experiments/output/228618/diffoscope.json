{"diffoscope-json-version": 1, "source1": "first/MurmurHash3$IncrementalHash32x86.class", "source2": "second/MurmurHash3$IncrementalHash32x86.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -9,98 +9,91 @@\n     private int totalLen;\n     private int hash;\n     \n     public IncrementalHash32x86() {\n         this.unprocessed = new byte[3];\n     }\n     \n-    public final void start(final int seed) {\n+    public final void start(final int hash) {\n         final int n = 0;\n         this.totalLen = n;\n         this.unprocessedLength = n;\n-        this.hash = seed;\n+        this.hash = hash;\n     }\n     \n-    public final void add(final byte[] data, final int offset, final int length) {\n-        if (length <= 0) {\n+    public final void add(final byte[] array, final int n, final int n2) {\n+        if (n2 <= 0) {\n             return;\n         }\n-        this.totalLen += length;\n-        if (this.unprocessedLength + length - 4 < 0) {\n-            System.arraycopy(data, offset, this.unprocessed, this.unprocessedLength, length);\n-            this.unprocessedLength += length;\n+        this.totalLen += n2;\n+        if (this.unprocessedLength + n2 - 4 < 0) {\n+            System.arraycopy(array, n, this.unprocessed, this.unprocessedLength, n2);\n+            this.unprocessedLength += n2;\n             return;\n         }\n-        int newOffset;\n-        int newLength;\n+        int n5;\n+        int n6;\n         if (this.unprocessedLength > 0) {\n-            int k = -1;\n+            int n3 = 0;\n             switch (this.unprocessedLength) {\n                 case 1: {\n-                    k = orBytes(this.unprocessed[0], data[offset], data[offset + 1], data[offset + 2]);\n+                    n3 = orBytes(this.unprocessed[0], array[n], array[n + 1], array[n + 2]);\n                     break;\n                 }\n                 case 2: {\n-                    k = orBytes(this.unprocessed[0], this.unprocessed[1], data[offset], data[offset + 1]);\n+                    n3 = orBytes(this.unprocessed[0], this.unprocessed[1], array[n], array[n + 1]);\n                     break;\n                 }\n                 case 3: {\n-                    k = orBytes(this.unprocessed[0], this.unprocessed[1], this.unprocessed[2], data[offset]);\n+                    n3 = orBytes(this.unprocessed[0], this.unprocessed[1], this.unprocessed[2], array[n]);\n                     break;\n                 }\n                 default: {\n                     throw new IllegalStateException(\"Unprocessed length should be 1, 2, or 3: \" + this.unprocessedLength);\n                 }\n             }\n-            this.hash = MurmurHash3.access$000(k, this.hash);\n-            final int consumed = 4 - this.unprocessedLength;\n-            newOffset = offset + consumed;\n-            newLength = length - consumed;\n+            this.hash = MurmurHash3.access$000(n3, this.hash);\n+            final int n4 = 4 - this.unprocessedLength;\n+            n5 = n + n4;\n+            n6 = n2 - n4;\n         }\n         else {\n-            newOffset = offset;\n-            newLength = length;\n+            n5 = n;\n+            n6 = n2;\n         }\n-        final int nblocks = newLength >> 2;\n-        for (int i = 0; i < nblocks; ++i) {\n-            final int index = newOffset + (i << 2);\n-            final int j = MurmurHash3.access$100(data, index);\n-            this.hash = MurmurHash3.access$000(j, this.hash);\n+        final int n7 = n6 >> 2;\n+        for (int i = 0; i < n7; ++i) {\n+            this.hash = MurmurHash3.access$000(MurmurHash3.access$100(array, n5 + (i << 2)), this.hash);\n         }\n-        final int consumed = nblocks << 2;\n-        this.unprocessedLength = newLength - consumed;\n+        final int n8 = n7 << 2;\n+        this.unprocessedLength = n6 - n8;\n         if (this.unprocessedLength != 0) {\n-            System.arraycopy(data, newOffset + consumed, this.unprocessed, 0, this.unprocessedLength);\n+            System.arraycopy(array, n5 + n8, this.unprocessed, 0, this.unprocessedLength);\n         }\n     }\n     \n     public final int end() {\n         return this.finalise(this.hash, this.unprocessedLength, this.unprocessed, this.totalLen);\n     }\n     \n-    int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {\n-        int result = hash;\n-        int k1 = 0;\n-        switch (unprocessedLength) {\n+    int finalise(final int n, final int n2, final byte[] array, final int n3) {\n+        int n4 = n;\n+        int n5 = 0;\n+        switch (n2) {\n             case 3: {\n-                k1 ^= (unprocessed[2] & 0xFF) << 16;\n+                n5 ^= (array[2] & 0xFF) << 16;\n             }\n             case 2: {\n-                k1 ^= (unprocessed[1] & 0xFF) << 8;\n+                n5 ^= (array[1] & 0xFF) << 8;\n             }\n             case 1: {\n-                k1 ^= (unprocessed[0] & 0xFF);\n-                k1 *= -862048943;\n-                k1 = Integer.rotateLeft(k1, 15);\n-                k1 *= 461845907;\n-                result ^= k1;\n+                n4 ^= Integer.rotateLeft((n5 ^ (array[0] & 0xFF)) * -862048943, 15) * 461845907;\n                 break;\n             }\n         }\n-        result ^= totalLen;\n-        return MurmurHash3.access$200(result);\n+        return MurmurHash3.access$200(n4 ^ n3);\n     }\n     \n-    private static int orBytes(final byte b1, final byte b2, final byte b3, final byte b4) {\n-        return (b1 & 0xFF) | (b2 & 0xFF) << 8 | (b3 & 0xFF) << 16 | (b4 & 0xFF) << 24;\n+    private static int orBytes(final byte b, final byte b2, final byte b3, final byte b4) {\n+        return (b & 0xFF) | (b2 & 0xFF) << 8 | (b3 & 0xFF) << 16 | (b4 & 0xFF) << 24;\n     }\n }\n"}]}
