{"diffoscope-json-version": 1, "source1": "first/SnappyCompressorInputStream.class", "source2": "second/SnappyCompressorInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -11,178 +11,176 @@\n     private static final int TAG_MASK = 3;\n     public static final int DEFAULT_BLOCK_SIZE = 32768;\n     private final int size;\n     private int uncompressedBytesRemaining;\n     private SnappyCompressorInputStream.State state;\n     private boolean endReached;\n     \n-    public SnappyCompressorInputStream(final InputStream is) throws IOException {\n-        this(is, 32768);\n+    public SnappyCompressorInputStream(final InputStream inputStream) throws IOException {\n+        this(inputStream, 32768);\n     }\n     \n-    public SnappyCompressorInputStream(final InputStream is, final int blockSize) throws IOException {\n-        super(is, blockSize);\n+    public SnappyCompressorInputStream(final InputStream inputStream, final int n) throws IOException {\n+        super(inputStream, n);\n         this.state = SnappyCompressorInputStream.State.NO_BLOCK;\n         this.endReached = false;\n-        final int n = (int)this.readSize();\n-        this.size = n;\n-        this.uncompressedBytesRemaining = n;\n+        final int n2 = (int)this.readSize();\n+        this.size = n2;\n+        this.uncompressedBytesRemaining = n2;\n     }\n     \n-    public int read(final byte[] b, final int off, final int len) throws IOException {\n-        if (len == 0) {\n+    public int read(final byte[] array, final int n, final int n2) throws IOException {\n+        if (n2 == 0) {\n             return 0;\n         }\n         if (this.endReached) {\n             return -1;\n         }\n         switch (SnappyCompressorInputStream.SnappyCompressorInputStream$1.$SwitchMap$org$apache$commons$compress$compressors$snappy$SnappyCompressorInputStream$State[this.state.ordinal()]) {\n             case 1: {\n                 this.fill();\n-                return this.read(b, off, len);\n+                return this.read(array, n, n2);\n             }\n             case 2: {\n-                final int litLen = this.readLiteral(b, off, len);\n+                final int literal = this.readLiteral(array, n, n2);\n                 if (!this.hasMoreDataInBlock()) {\n                     this.state = SnappyCompressorInputStream.State.NO_BLOCK;\n                 }\n-                return (litLen > 0) ? litLen : this.read(b, off, len);\n+                return (literal > 0) ? literal : this.read(array, n, n2);\n             }\n             case 3: {\n-                final int backReferenceLen = this.readBackReference(b, off, len);\n+                final int backReference = this.readBackReference(array, n, n2);\n                 if (!this.hasMoreDataInBlock()) {\n                     this.state = SnappyCompressorInputStream.State.NO_BLOCK;\n                 }\n-                return (backReferenceLen > 0) ? backReferenceLen : this.read(b, off, len);\n+                return (backReference > 0) ? backReference : this.read(array, n, n2);\n             }\n             default: {\n                 throw new IOException(\"Unknown stream state \" + this.state);\n             }\n         }\n     }\n     \n     private void fill() throws IOException {\n         if (this.uncompressedBytesRemaining == 0) {\n             this.endReached = true;\n             return;\n         }\n-        int b = this.readOneByte();\n-        if (b == -1) {\n+        final int oneByte = this.readOneByte();\n+        if (oneByte == -1) {\n             throw new IOException(\"Premature end of stream reading block start\");\n         }\n-        int length = 0;\n-        int offset = 0;\n-        switch (b & 0x3) {\n+        switch (oneByte & 0x3) {\n             case 0: {\n-                length = this.readLiteralLength(b);\n-                if (length < 0) {\n+                final int literalLength = this.readLiteralLength(oneByte);\n+                if (literalLength < 0) {\n                     throw new IOException(\"Illegal block with a negative literal size found\");\n                 }\n-                this.uncompressedBytesRemaining -= length;\n-                this.startLiteral((long)length);\n+                this.uncompressedBytesRemaining -= literalLength;\n+                this.startLiteral((long)literalLength);\n                 this.state = SnappyCompressorInputStream.State.IN_LITERAL;\n                 break;\n             }\n             case 1: {\n-                length = 4 + (b >> 2 & 0x7);\n-                if (length < 0) {\n+                final int n = 4 + (oneByte >> 2 & 0x7);\n+                if (n < 0) {\n                     throw new IOException(\"Illegal block with a negative match length found\");\n                 }\n-                this.uncompressedBytesRemaining -= length;\n-                offset = (b & 0xE0) << 3;\n-                b = this.readOneByte();\n-                if (b == -1) {\n+                this.uncompressedBytesRemaining -= n;\n+                final int n2 = (oneByte & 0xE0) << 3;\n+                final int oneByte2 = this.readOneByte();\n+                if (oneByte2 == -1) {\n                     throw new IOException(\"Premature end of stream reading back-reference length\");\n                 }\n-                offset |= b;\n+                final int n3 = n2 | oneByte2;\n                 try {\n-                    this.startBackReference(offset, (long)length);\n+                    this.startBackReference(n3, (long)n);\n                 }\n-                catch (final IllegalArgumentException ex) {\n-                    throw new IOException(\"Illegal block with bad offset found\", ex);\n+                catch (final IllegalArgumentException cause) {\n+                    throw new IOException(\"Illegal block with bad offset found\", cause);\n                 }\n                 this.state = SnappyCompressorInputStream.State.IN_BACK_REFERENCE;\n                 break;\n             }\n             case 2: {\n-                length = (b >> 2) + 1;\n-                if (length < 0) {\n+                final int n4 = (oneByte >> 2) + 1;\n+                if (n4 < 0) {\n                     throw new IOException(\"Illegal block with a negative match length found\");\n                 }\n-                this.uncompressedBytesRemaining -= length;\n-                offset = (int)ByteUtils.fromLittleEndian(this.supplier, 2);\n+                this.uncompressedBytesRemaining -= n4;\n+                final int n5 = (int)ByteUtils.fromLittleEndian(this.supplier, 2);\n                 try {\n-                    this.startBackReference(offset, (long)length);\n+                    this.startBackReference(n5, (long)n4);\n                 }\n-                catch (final IllegalArgumentException ex) {\n-                    throw new IOException(\"Illegal block with bad offset found\", ex);\n+                catch (final IllegalArgumentException cause2) {\n+                    throw new IOException(\"Illegal block with bad offset found\", cause2);\n                 }\n                 this.state = SnappyCompressorInputStream.State.IN_BACK_REFERENCE;\n                 break;\n             }\n             case 3: {\n-                length = (b >> 2) + 1;\n-                if (length < 0) {\n+                final int n6 = (oneByte >> 2) + 1;\n+                if (n6 < 0) {\n                     throw new IOException(\"Illegal block with a negative match length found\");\n                 }\n-                this.uncompressedBytesRemaining -= length;\n-                offset = ((int)ByteUtils.fromLittleEndian(this.supplier, 4) & Integer.MAX_VALUE);\n+                this.uncompressedBytesRemaining -= n6;\n+                final int n7 = (int)ByteUtils.fromLittleEndian(this.supplier, 4) & Integer.MAX_VALUE;\n                 try {\n-                    this.startBackReference(offset, (long)length);\n+                    this.startBackReference(n7, (long)n6);\n                 }\n-                catch (final IllegalArgumentException ex) {\n-                    throw new IOException(\"Illegal block with bad offset found\", ex);\n+                catch (final IllegalArgumentException cause3) {\n+                    throw new IOException(\"Illegal block with bad offset found\", cause3);\n                 }\n                 this.state = SnappyCompressorInputStream.State.IN_BACK_REFERENCE;\n                 break;\n             }\n         }\n     }\n     \n-    private int readLiteralLength(final int b) throws IOException {\n-        int length = 0;\n-        switch (b >> 2) {\n+    private int readLiteralLength(final int n) throws IOException {\n+        int oneByte = 0;\n+        switch (n >> 2) {\n             case 60: {\n-                length = this.readOneByte();\n-                if (length == -1) {\n+                oneByte = this.readOneByte();\n+                if (oneByte == -1) {\n                     throw new IOException(\"Premature end of stream reading literal length\");\n                 }\n                 break;\n             }\n             case 61: {\n-                length = (int)ByteUtils.fromLittleEndian(this.supplier, 2);\n+                oneByte = (int)ByteUtils.fromLittleEndian(this.supplier, 2);\n                 break;\n             }\n             case 62: {\n-                length = (int)ByteUtils.fromLittleEndian(this.supplier, 3);\n+                oneByte = (int)ByteUtils.fromLittleEndian(this.supplier, 3);\n                 break;\n             }\n             case 63: {\n-                length = (int)ByteUtils.fromLittleEndian(this.supplier, 4);\n+                oneByte = (int)ByteUtils.fromLittleEndian(this.supplier, 4);\n                 break;\n             }\n             default: {\n-                length = b >> 2;\n+                oneByte = n >> 2;\n                 break;\n             }\n         }\n-        return length + 1;\n+        return oneByte + 1;\n     }\n     \n     private long readSize() throws IOException {\n-        int index = 0;\n-        long sz = 0L;\n-        int b = 0;\n+        int n = 0;\n+        long n2 = 0L;\n+        int oneByte;\n         do {\n-            b = this.readOneByte();\n-            if (b == -1) {\n+            oneByte = this.readOneByte();\n+            if (oneByte == -1) {\n                 throw new IOException(\"Premature end of stream reading size\");\n             }\n-            sz |= (b & 0x7F) << index++ * 7;\n-        } while (0x0 != (b & 0x80));\n-        return sz;\n+            n2 |= (oneByte & 0x7F) << n++ * 7;\n+        } while (0x0 != (oneByte & 0x80));\n+        return n2;\n     }\n     \n     public int getSize() {\n         return this.size;\n     }\n }\n"}]}
