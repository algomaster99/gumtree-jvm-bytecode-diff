{"diffoscope-json-version": 1, "source1": "first/ZipFile.class", "source2": "second/ZipFile.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -78,14 +78,19 @@\n     private static final int ZIP64_EOCDL_LOCATOR_OFFSET = 8;\n     private static final int ZIP64_EOCD_CFD_LOCATOR_OFFSET = 48;\n     private static final int ZIP64_EOCD_CFD_DISK_OFFSET = 20;\n     private static final int ZIP64_EOCD_CFD_LOCATOR_RELATIVE_OFFSET = 24;\n     private static final long LFH_OFFSET_FOR_FILENAME_LENGTH = 26L;\n     private final Comparator<ZipArchiveEntry> offsetComparator;\n     \n+    static {\n+        ONE_ZERO_BYTE = new byte[1];\n+        CFH_SIG = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n+    }\n+    \n     public ZipFile(final File f) throws IOException {\n         this(f, \"UTF8\");\n     }\n     \n     public ZipFile(final String name) throws IOException {\n         this(new File(name), \"UTF8\");\n     }\n@@ -155,14 +160,18 @@\n         }\n         finally {\n             this.closed = !success;\n             if (!success && closeOnError) {\n                 IOUtils.closeQuietly((Closeable)this.archive);\n             }\n         }\n+        this.closed = !success;\n+        if (!success && closeOnError) {\n+            IOUtils.closeQuietly((Closeable)this.archive);\n+        }\n     }\n     \n     public String getEncoding() {\n         return this.encoding;\n     }\n     \n     @Override\n@@ -232,49 +241,70 @@\n     public InputStream getInputStream(final ZipArchiveEntry ze) throws IOException {\n         if (!(ze instanceof ZipFile.Entry)) {\n             return null;\n         }\n         ZipUtil.checkRequestedFeatures(ze);\n         final long start = this.getDataOffset(ze);\n         final InputStream is = new BufferedInputStream((InputStream)this.createBoundedInputStream(start, ze.getCompressedSize()));\n-        switch (ZipFile.ZipFile$2.$SwitchMap$org$apache$commons$compress$archivers$zip$ZipMethod[ZipMethod.getMethodByCode(ze.getMethod()).ordinal()]) {\n-            case 1: {\n+        switch (ZipMethod.getMethodByCode(ze.getMethod())) {\n+            case STORED: {\n                 return (InputStream)new ZipFile.StoredStatisticsStream(is);\n             }\n-            case 2: {\n+            case UNSHRINKING: {\n                 return (InputStream)new UnshrinkingInputStream(is);\n             }\n-            case 3: {\n+            case IMPLODING: {\n                 try {\n                     return (InputStream)new ExplodingInputStream(ze.getGeneralPurposeBit().getSlidingDictionarySize(), ze.getGeneralPurposeBit().getNumberOfShannonFanoTrees(), is);\n                 }\n                 catch (final IllegalArgumentException ex) {\n                     throw new IOException(\"bad IMPLODE data\", ex);\n                 }\n             }\n-            case 4: {\n+            case DEFLATED: {\n                 final Inflater inflater = new Inflater(true);\n                 return (InputStream)new ZipFile.ZipFile$1(this, (InputStream)new SequenceInputStream(is, new ByteArrayInputStream(ZipFile.ONE_ZERO_BYTE)), inflater, inflater);\n             }\n-            case 5: {\n+            case BZIP2: {\n                 return (InputStream)new BZip2CompressorInputStream(is);\n             }\n-            case 6: {\n+            case ENHANCED_DEFLATED: {\n                 return (InputStream)new Deflate64CompressorInputStream(is);\n             }\n             default: {\n                 throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(ze.getMethod()), ze);\n             }\n         }\n     }\n     \n     public String getUnixSymlink(final ZipArchiveEntry entry) throws IOException {\n         if (entry != null && entry.isUnixSymlink()) {\n-            try (final InputStream in = this.getInputStream(entry)) {\n-                return this.zipEncoding.decode(IOUtils.toByteArray(in));\n+            Throwable t = null;\n+            try {\n+                final InputStream in = this.getInputStream(entry);\n+                try {\n+                    return this.zipEncoding.decode(IOUtils.toByteArray(in));\n+                }\n+                finally {\n+                    if (in != null) {\n+                        in.close();\n+                    }\n+                }\n+            }\n+            finally {\n+                if (t == null) {\n+                    final Throwable exception;\n+                    t = exception;\n+                }\n+                else {\n+                    final Throwable exception;\n+                    if (t != exception) {\n+                        t.addSuppressed(exception);\n+                    }\n+                }\n             }\n         }\n         return null;\n     }\n     \n     @Override\n     protected void finalize() throws Throwable {\n@@ -283,14 +313,15 @@\n                 System.err.println(\"Cleaning up unclosed ZipFile for archive \" + this.archiveName);\n                 this.close();\n             }\n         }\n         finally {\n             super.finalize();\n         }\n+        super.finalize();\n     }\n     \n     private Map<ZipArchiveEntry, ZipFile.NameAndComment> populateFromCentralDirectory() throws IOException {\n         final HashMap<ZipArchiveEntry, ZipFile.NameAndComment> noUTF8Flag = new HashMap<ZipArchiveEntry, ZipFile.NameAndComment>();\n         this.positionAtCentralDirectory();\n         this.centralDirectoryStartOffset = this.archive.position();\n         this.wordBbuf.rewind();\n@@ -391,15 +422,15 @@\n         this.sanityCheckLFHOffset((ZipArchiveEntry)ze);\n         final byte[] comment = IOUtils.readRange((ReadableByteChannel)this.archive, commentLen);\n         if (comment.length < commentLen) {\n             throw new EOFException();\n         }\n         ze.setComment(entryEncoding.decode(comment));\n         if (!hasUTF8Flag && this.useUnicodeExtraFields) {\n-            noUTF8Flag.put((ZipArchiveEntry)ze, new ZipFile.NameAndComment(fileName, comment, (ZipFile.ZipFile$1)null));\n+            noUTF8Flag.put((ZipArchiveEntry)ze, new ZipFile.NameAndComment(fileName, comment, (ZipFile.NameAndComment)null));\n         }\n         ze.setStreamContiguous(true);\n     }\n     \n     private void sanityCheckLFHOffset(final ZipArchiveEntry ze) throws IOException {\n         if (ze.getDiskNumberStart() < 0L) {\n             throw new IOException(\"broken archive, entry with negative disk number\");\n@@ -619,15 +650,15 @@\n                 z.initCause(ex);\n                 throw z;\n             }\n             if (!entriesWithoutUTF8Flag.containsKey(ze)) {\n                 continue;\n             }\n             final ZipFile.NameAndComment nc = (ZipFile.NameAndComment)entriesWithoutUTF8Flag.get(ze);\n-            ZipUtil.setNameAndCommentFromExtraFields((ZipArchiveEntry)ze, ZipFile.NameAndComment.access$100(nc), ZipFile.NameAndComment.access$200(nc));\n+            ZipUtil.setNameAndCommentFromExtraFields((ZipArchiveEntry)ze, ZipFile.NameAndComment.access$1(nc), ZipFile.NameAndComment.access$2(nc));\n         }\n     }\n     \n     private void fillNameMap() {\n         for (final ZipArchiveEntry ze : this.entries) {\n             final String name = ze.getName();\n             final LinkedList<ZipArchiveEntry> entriesOfThatName = (LinkedList<ZipArchiveEntry>)this.nameMap.computeIfAbsent(name, k -> new LinkedList());\n@@ -676,13 +707,8 @@\n     \n     private BoundedArchiveInputStream createBoundedInputStream(final long start, final long remaining) {\n         if (start < 0L || remaining < 0L || start + remaining < start) {\n             throw new IllegalArgumentException(\"Corrupted archive, stream boundaries are out of range\");\n         }\n         return (BoundedArchiveInputStream)((this.archive instanceof FileChannel) ? new ZipFile.BoundedFileChannelInputStream(this, start, remaining) : new BoundedSeekableByteChannelInputStream(start, remaining, this.archive));\n     }\n-    \n-    static {\n-        ONE_ZERO_BYTE = new byte[1];\n-        CFH_SIG = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n-    }\n }\n"}]}
