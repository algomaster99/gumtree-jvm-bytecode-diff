{"diffoscope-json-version": 1, "source1": "first/BandSet.class", "source2": "second/BandSet.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -3,27 +3,30 @@\n \n import java.util.Arrays;\n import java.util.Map;\n import java.util.HashMap;\n import java.util.Iterator;\n import java.util.List;\n import java.util.ArrayList;\n-import java.util.Objects;\n import java.util.stream.IntStream;\n import java.io.IOException;\n import java.io.OutputStream;\n \n public abstract class BandSet\n {\n     protected final SegmentHeader segmentHeader;\n     final int effort;\n     private static final int[] effortThresholds;\n     private long[] canonicalLargest;\n     private long[] canonicalSmallest;\n     \n+    static {\n+        effortThresholds = new int[] { 0, 0, 1000, 500, 100, 100, 100, 100, 100, 0 };\n+    }\n+    \n     public BandSet(final int effort, final SegmentHeader header) {\n         this.effort = effort;\n         this.segmentHeader = header;\n     }\n     \n     public abstract void pack(final OutputStream p0) throws IOException, Pack200Exception;\n     \n@@ -35,16 +38,16 @@\n         return codec.encode(value);\n     }\n     \n     public byte[] encodeBandInt(final String name, final int[] ints, final BHSDCodec defaultCodec) throws Pack200Exception {\n         byte[] encodedBand = null;\n         if (this.effort > 1 && ints.length >= BandSet.effortThresholds[this.effort]) {\n             final BandSet.BandAnalysisResults results = this.analyseBand(name, ints, defaultCodec);\n-            final Codec betterCodec = BandSet.BandAnalysisResults.access$000(results);\n-            encodedBand = BandSet.BandAnalysisResults.access$100(results);\n+            final Codec betterCodec = BandSet.BandAnalysisResults.access$0(results);\n+            encodedBand = BandSet.BandAnalysisResults.access$1(results);\n             if (betterCodec != null) {\n                 if (betterCodec instanceof BHSDCodec) {\n                     final int[] specifierBand = CodecEncoding.getSpecifier(betterCodec, (Codec)defaultCodec);\n                     int specifier = specifierBand[0];\n                     if (specifierBand.length > 1) {\n                         for (int i = 1; i < specifierBand.length; ++i) {\n                             this.segmentHeader.appendBandCodingSpecifier(specifierBand[i]);\n@@ -59,21 +62,18 @@\n                     final byte[] specifierEncoded = defaultCodec.encode(new int[] { specifier });\n                     final byte[] band = new byte[specifierEncoded.length + encodedBand.length];\n                     System.arraycopy(specifierEncoded, 0, band, 0, specifierEncoded.length);\n                     System.arraycopy(encodedBand, 0, band, specifierEncoded.length, encodedBand.length);\n                     return band;\n                 }\n                 if (betterCodec instanceof PopulationCodec) {\n-                    final IntStream of = IntStream.of(BandSet.BandAnalysisResults.access$200(results));\n-                    final SegmentHeader segmentHeader = this.segmentHeader;\n-                    Objects.requireNonNull(segmentHeader);\n-                    of.forEach(segmentHeader::appendBandCodingSpecifier);\n+                    IntStream.of(BandSet.BandAnalysisResults.access$2(results)).forEach(this.segmentHeader::appendBandCodingSpecifier);\n                     return encodedBand;\n                 }\n-                if (betterCodec instanceof RunCodec) {}\n+                final boolean b = betterCodec instanceof RunCodec;\n             }\n         }\n         if (ints.length > 0) {\n             if (encodedBand == null) {\n                 encodedBand = defaultCodec.encode(ints);\n             }\n             final int first = ints[0];\n@@ -108,21 +108,21 @@\n             for (int i = 1; i < this.canonicalLargest.length; ++i) {\n                 this.canonicalLargest[i] = CodecEncoding.getCanonicalCodec(i).largest();\n                 this.canonicalSmallest[i] = CodecEncoding.getCanonicalCodec(i).smallest();\n             }\n         }\n         final BandSet.BandData bandData = new BandSet.BandData(this, band);\n         final byte[] encoded = defaultCodec.encode(band);\n-        BandSet.BandAnalysisResults.access$102(results, encoded);\n+        BandSet.BandAnalysisResults.access$3(results, encoded);\n         if (encoded.length <= band.length + 23 - 2 * this.effort) {\n             return results;\n         }\n-        if (!bandData.anyNegatives() && BandSet.BandData.access$300(bandData) <= Codec.BYTE1.largest()) {\n-            BandSet.BandAnalysisResults.access$102(results, Codec.BYTE1.encode(band));\n-            BandSet.BandAnalysisResults.access$002(results, (Codec)Codec.BYTE1);\n+        if (!bandData.anyNegatives() && BandSet.BandData.access$0(bandData) <= Codec.BYTE1.largest()) {\n+            BandSet.BandAnalysisResults.access$3(results, Codec.BYTE1.encode(band));\n+            BandSet.BandAnalysisResults.access$4(results, (Codec)Codec.BYTE1);\n             return results;\n         }\n         if (this.effort > 3 && !name.equals(\"POPULATION\")) {\n             final int numDistinctValues = bandData.numDistinctValues();\n             final float distinctValuesAsProportion = numDistinctValues / (float)band.length;\n             if (numDistinctValues < 100 || distinctValuesAsProportion < 0.02 || (this.effort > 6 && distinctValuesAsProportion < 0.04)) {\n                 this.encodeWithPopulationCodec(name, band, defaultCodec, bandData, results);\n@@ -187,67 +187,67 @@\n             }\n         }\n         return results;\n     }\n     \n     private boolean timeToStop(final BandSet.BandAnalysisResults results) {\n         if (this.effort > 6) {\n-            return BandSet.BandAnalysisResults.access$400(results) >= this.effort * 2;\n+            return BandSet.BandAnalysisResults.access$5(results) >= this.effort * 2;\n         }\n-        return BandSet.BandAnalysisResults.access$400(results) >= this.effort;\n+        return BandSet.BandAnalysisResults.access$5(results) >= this.effort;\n     }\n     \n     private void tryCodecs(final String name, final int[] band, final BHSDCodec defaultCodec, final BandSet.BandData bandData, final BandSet.BandAnalysisResults results, final byte[] encoded, final BHSDCodec[] potentialCodecs) throws Pack200Exception {\n         for (final BHSDCodec potential : potentialCodecs) {\n             if (potential.equals((Object)defaultCodec)) {\n                 return;\n             }\n             if (potential.isDelta()) {\n-                if (potential.largest() >= BandSet.BandData.access$500(bandData) && potential.smallest() <= BandSet.BandData.access$600(bandData) && potential.largest() >= BandSet.BandData.access$300(bandData) && potential.smallest() <= BandSet.BandData.access$700(bandData)) {\n+                if (potential.largest() >= BandSet.BandData.access$1(bandData) && potential.smallest() <= BandSet.BandData.access$2(bandData) && potential.largest() >= BandSet.BandData.access$0(bandData) && potential.smallest() <= BandSet.BandData.access$3(bandData)) {\n                     final byte[] encoded2 = potential.encode(band);\n-                    BandSet.BandAnalysisResults.access$408(results);\n+                    BandSet.BandAnalysisResults.access$6(results, BandSet.BandAnalysisResults.access$5(results) + 1);\n                     final byte[] specifierEncoded = defaultCodec.encode(CodecEncoding.getSpecifier((Codec)potential, (Codec)null));\n                     final int saved = encoded.length - encoded2.length - specifierEncoded.length;\n-                    if (saved > BandSet.BandAnalysisResults.access$800(results)) {\n-                        BandSet.BandAnalysisResults.access$002(results, (Codec)potential);\n-                        BandSet.BandAnalysisResults.access$102(results, encoded2);\n-                        BandSet.BandAnalysisResults.access$802(results, saved);\n+                    if (saved > BandSet.BandAnalysisResults.access$7(results)) {\n+                        BandSet.BandAnalysisResults.access$4(results, (Codec)potential);\n+                        BandSet.BandAnalysisResults.access$3(results, encoded2);\n+                        BandSet.BandAnalysisResults.access$8(results, saved);\n                     }\n                 }\n             }\n-            else if (potential.largest() >= BandSet.BandData.access$300(bandData) && potential.smallest() <= BandSet.BandData.access$700(bandData)) {\n+            else if (potential.largest() >= BandSet.BandData.access$0(bandData) && potential.smallest() <= BandSet.BandData.access$3(bandData)) {\n                 final byte[] encoded2 = potential.encode(band);\n-                BandSet.BandAnalysisResults.access$408(results);\n+                BandSet.BandAnalysisResults.access$6(results, BandSet.BandAnalysisResults.access$5(results) + 1);\n                 final byte[] specifierEncoded = defaultCodec.encode(CodecEncoding.getSpecifier((Codec)potential, (Codec)null));\n                 final int saved = encoded.length - encoded2.length - specifierEncoded.length;\n-                if (saved > BandSet.BandAnalysisResults.access$800(results)) {\n-                    BandSet.BandAnalysisResults.access$002(results, (Codec)potential);\n-                    BandSet.BandAnalysisResults.access$102(results, encoded2);\n-                    BandSet.BandAnalysisResults.access$802(results, saved);\n+                if (saved > BandSet.BandAnalysisResults.access$7(results)) {\n+                    BandSet.BandAnalysisResults.access$4(results, (Codec)potential);\n+                    BandSet.BandAnalysisResults.access$3(results, encoded2);\n+                    BandSet.BandAnalysisResults.access$8(results, saved);\n                 }\n             }\n             if (this.timeToStop(results)) {\n                 return;\n             }\n         }\n     }\n     \n     private void encodeWithPopulationCodec(final String name, final int[] band, final BHSDCodec defaultCodec, final BandSet.BandData bandData, final BandSet.BandAnalysisResults results) throws Pack200Exception {\n-        BandSet.BandAnalysisResults.access$412(results, 3);\n-        final Map<Integer, Integer> distinctValues = BandSet.BandData.access$900(bandData);\n+        BandSet.BandAnalysisResults.access$6(results, BandSet.BandAnalysisResults.access$5(results) + 3);\n+        final Map<Integer, Integer> distinctValues = BandSet.BandData.access$4(bandData);\n         final List<Integer> favored = new ArrayList<Integer>();\n         final int k;\n         distinctValues.forEach((k, v) -> {\n-            if (v > 2 || distinctValues.size() < 256) {\n-                favored.add(k);\n+            if (v > 2 || map.size() < 256) {\n+                list.add(k);\n             }\n             return;\n         });\n         if (distinctValues.size() > 255) {\n-            favored.sort((arg0, arg1) -> Integer.valueOf(distinctValues.get((Object)arg1)).compareTo(Integer.valueOf(distinctValues.get((Object)arg0))));\n+            favored.sort((arg0, arg1) -> Integer.valueOf(map2.get((Object)arg1)).compareTo(Integer.valueOf(map2.get((Object)arg0))));\n         }\n         final Map<Integer, Integer> favoredToIndex = new HashMap<Integer, Integer>();\n         for (int i = 0; i < favored.size(); ++i) {\n             favoredToIndex.put(Integer.valueOf(favored.get(i)), Integer.valueOf(i));\n         }\n         final IntList unfavoured = new IntList();\n         final int[] tokens = new int[band.length];\n@@ -273,16 +273,16 @@\n         byte[] tokensEncoded;\n         if (k < 256) {\n             tdefL = 1;\n             tokensEncoded = Codec.BYTE1.encode(tokens);\n         }\n         else {\n             final BandSet.BandAnalysisResults tokenResults = this.analyseBand(\"POPULATION\", tokens, defaultCodec);\n-            tokenCodec = BandSet.BandAnalysisResults.access$000(tokenResults);\n-            tokensEncoded = BandSet.BandAnalysisResults.access$100(tokenResults);\n+            tokenCodec = BandSet.BandAnalysisResults.access$0(tokenResults);\n+            tokensEncoded = BandSet.BandAnalysisResults.access$1(tokenResults);\n             if (tokenCodec == null) {\n                 tokenCodec = (Codec)defaultCodec;\n             }\n             l = ((BHSDCodec)tokenCodec).getL();\n             final int h = ((BHSDCodec)tokenCodec).getH();\n             final int s = ((BHSDCodec)tokenCodec).getS();\n             final int b = ((BHSDCodec)tokenCodec).getB();\n@@ -341,71 +341,62 @@\n                             tdefL = 11;\n                             break;\n                         }\n                     }\n                 }\n             }\n         }\n-        final byte[] favouredEncoded = BandSet.BandAnalysisResults.access$100(favouredResults);\n-        final byte[] unfavouredEncoded = BandSet.BandAnalysisResults.access$100(unfavouredResults);\n-        final Codec favouredCodec = BandSet.BandAnalysisResults.access$000(favouredResults);\n-        final Codec unfavouredCodec = BandSet.BandAnalysisResults.access$000(unfavouredResults);\n+        final byte[] favouredEncoded = BandSet.BandAnalysisResults.access$1(favouredResults);\n+        final byte[] unfavouredEncoded = BandSet.BandAnalysisResults.access$1(unfavouredResults);\n+        final Codec favouredCodec = BandSet.BandAnalysisResults.access$0(favouredResults);\n+        final Codec unfavouredCodec = BandSet.BandAnalysisResults.access$0(unfavouredResults);\n         int specifier = 141 + ((favouredCodec == null) ? 1 : 0) + 4 * tdefL + ((unfavouredCodec == null) ? 2 : 0);\n         final IntList extraBandMetadata = new IntList(3);\n         if (favouredCodec != null) {\n-            final IntStream of = IntStream.of(CodecEncoding.getSpecifier(favouredCodec, (Codec)null));\n-            final IntList obj = extraBandMetadata;\n-            Objects.requireNonNull(obj);\n-            of.forEach(obj::add);\n+            IntStream.of(CodecEncoding.getSpecifier(favouredCodec, (Codec)null)).forEach(extraBandMetadata::add);\n         }\n         if (tdefL == 0) {\n-            final IntStream of2 = IntStream.of(CodecEncoding.getSpecifier(tokenCodec, (Codec)null));\n-            final IntList obj2 = extraBandMetadata;\n-            Objects.requireNonNull(obj2);\n-            of2.forEach(obj2::add);\n+            IntStream.of(CodecEncoding.getSpecifier(tokenCodec, (Codec)null)).forEach(extraBandMetadata::add);\n         }\n         if (unfavouredCodec != null) {\n-            final IntStream of3 = IntStream.of(CodecEncoding.getSpecifier(unfavouredCodec, (Codec)null));\n-            final IntList obj3 = extraBandMetadata;\n-            Objects.requireNonNull(obj3);\n-            of3.forEach(obj3::add);\n+            IntStream.of(CodecEncoding.getSpecifier(unfavouredCodec, (Codec)null)).forEach(extraBandMetadata::add);\n         }\n         final int[] extraMetadata = extraBandMetadata.toArray();\n         final byte[] extraMetadataEncoded = Codec.UNSIGNED5.encode(extraMetadata);\n         if (defaultCodec.isSigned()) {\n             specifier = -1 - specifier;\n         }\n         else {\n             specifier += defaultCodec.getL();\n         }\n         final byte[] firstValueEncoded = defaultCodec.encode(new int[] { specifier });\n         final int totalBandLength = firstValueEncoded.length + favouredEncoded.length + tokensEncoded.length + unfavouredEncoded.length;\n-        if (totalBandLength + extraMetadataEncoded.length < BandSet.BandAnalysisResults.access$100(results).length) {\n-            BandSet.BandAnalysisResults.access$812(results, BandSet.BandAnalysisResults.access$100(results).length - (totalBandLength + extraMetadataEncoded.length));\n+        if (totalBandLength + extraMetadataEncoded.length < BandSet.BandAnalysisResults.access$1(results).length) {\n+            BandSet.BandAnalysisResults.access$8(results, BandSet.BandAnalysisResults.access$7(results) + (BandSet.BandAnalysisResults.access$1(results).length - (totalBandLength + extraMetadataEncoded.length)));\n             final byte[] encodedBand = new byte[totalBandLength];\n             System.arraycopy(firstValueEncoded, 0, encodedBand, 0, firstValueEncoded.length);\n             System.arraycopy(favouredEncoded, 0, encodedBand, firstValueEncoded.length, favouredEncoded.length);\n             System.arraycopy(tokensEncoded, 0, encodedBand, firstValueEncoded.length + favouredEncoded.length, tokensEncoded.length);\n             System.arraycopy(unfavouredEncoded, 0, encodedBand, firstValueEncoded.length + favouredEncoded.length + tokensEncoded.length, unfavouredEncoded.length);\n-            BandSet.BandAnalysisResults.access$102(results, encodedBand);\n-            BandSet.BandAnalysisResults.access$202(results, extraMetadata);\n+            BandSet.BandAnalysisResults.access$3(results, encodedBand);\n+            BandSet.BandAnalysisResults.access$9(results, extraMetadata);\n             if (l != 0) {\n-                BandSet.BandAnalysisResults.access$002(results, (Codec)new PopulationCodec(favouredCodec, l, unfavouredCodec));\n+                BandSet.BandAnalysisResults.access$4(results, (Codec)new PopulationCodec(favouredCodec, l, unfavouredCodec));\n             }\n             else {\n-                BandSet.BandAnalysisResults.access$002(results, (Codec)new PopulationCodec(favouredCodec, tokenCodec, unfavouredCodec));\n+                BandSet.BandAnalysisResults.access$4(results, (Codec)new PopulationCodec(favouredCodec, tokenCodec, unfavouredCodec));\n             }\n         }\n     }\n     \n     protected byte[] encodeFlags(final String name, final long[] flags, final BHSDCodec loCodec, final BHSDCodec hiCodec, final boolean haveHiFlags) throws Pack200Exception {\n         if (!haveHiFlags) {\n             final int[] loBits = new int[flags.length];\n             final int i;\n-            Arrays.setAll(loBits, i -> (int)flags[i]);\n+            Arrays.setAll(loBits, i -> (int)array[i]);\n             return this.encodeBandInt(name, loBits, loCodec);\n         }\n         final int[] hiBits = new int[flags.length];\n         final int[] loBits2 = new int[flags.length];\n         for (int i = 0; i < flags.length; ++i) {\n             final long l = flags[i];\n             hiBits[i] = (int)(l >> 32);\n@@ -457,21 +448,18 @@\n     private long[] flatten(final long[][] flags) {\n         int totalSize = 0;\n         for (final long[] flag : flags) {\n             totalSize += flag.length;\n         }\n         final long[] flatArray = new long[totalSize];\n         int index = 0;\n-        for (final long[] array : flags) {\n-            final long[] flag2 = array;\n-            for (final long element : array) {\n+        for (final long[] flag2 : flags) {\n+            long[] array;\n+            for (int length3 = (array = flag2).length, k = 0; k < length3; ++k) {\n+                final long element = array[k];\n                 flatArray[index] = element;\n                 ++index;\n             }\n         }\n         return flatArray;\n     }\n-    \n-    static {\n-        effortThresholds = new int[] { 0, 0, 1000, 500, 100, 100, 100, 100, 100, 0 };\n-    }\n }\n"}]}
