{"diffoscope-json-version": 1, "source1": "first/INIConfiguration.class", "source2": "second/INIConfiguration.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,21 +1,21 @@\n \n package org.apache.commons.configuration2;\n \n+import org.apache.commons.configuration2.tree.InMemoryNodeModel;\n import org.apache.commons.configuration2.tree.TrackedNodeModel;\n import org.apache.commons.configuration2.tree.NodeSelector;\n-import org.apache.commons.configuration2.tree.InMemoryNodeModel;\n import org.apache.commons.configuration2.ex.ConfigurationRuntimeException;\n import org.apache.commons.configuration2.tree.InMemoryNodeModelSupport;\n import org.apache.commons.configuration2.tree.NodeKeyResolver;\n import java.util.LinkedHashSet;\n import java.util.Set;\n import org.apache.commons.configuration2.convert.ListDelimiterHandler;\n-import java.util.Map;\n import java.util.Collection;\n+import java.util.Map;\n import java.util.LinkedHashMap;\n import java.io.BufferedReader;\n import java.io.Reader;\n import java.io.IOException;\n import org.apache.commons.configuration2.ex.ConfigurationException;\n import java.util.Iterator;\n import java.io.PrintWriter;\n@@ -36,16 +36,16 @@\n     \n     public INIConfiguration() {\n         this.separatorUsedInOutput = \" = \";\n         this.separatorUsedInInput = \"=:\";\n         this.commentCharsUsedInInput = \"#;\";\n     }\n     \n-    public INIConfiguration(final HierarchicalConfiguration<ImmutableNode> c) {\n-        super((HierarchicalConfiguration)c);\n+    public INIConfiguration(final HierarchicalConfiguration<ImmutableNode> hierarchicalConfiguration) {\n+        super((HierarchicalConfiguration)hierarchicalConfiguration);\n         this.separatorUsedInOutput = \" = \";\n         this.separatorUsedInInput = \"=:\";\n         this.commentCharsUsedInInput = \"#;\";\n     }\n     \n     private INIConfiguration(final boolean sectionInLineCommentsAllowed) {\n         this.separatorUsedInOutput = \" = \";\n@@ -64,18 +64,18 @@\n             return this.separatorUsedInOutput;\n         }\n         finally {\n             this.endRead();\n         }\n     }\n     \n-    public void setSeparatorUsedInOutput(final String separator) {\n+    public void setSeparatorUsedInOutput(final String separatorUsedInOutput) {\n         this.beginWrite(false);\n         try {\n-            this.separatorUsedInOutput = separator;\n+            this.separatorUsedInOutput = separatorUsedInOutput;\n         }\n         finally {\n             this.endWrite();\n         }\n     }\n     \n     public String getSeparatorUsedInInput() {\n@@ -84,18 +84,18 @@\n             return this.separatorUsedInInput;\n         }\n         finally {\n             this.endRead();\n         }\n     }\n     \n-    public void setSeparatorUsedInInput(final String separator) {\n+    public void setSeparatorUsedInInput(final String separatorUsedInInput) {\n         this.beginRead(false);\n         try {\n-            this.separatorUsedInInput = separator;\n+            this.separatorUsedInInput = separatorUsedInInput;\n         }\n         finally {\n             this.endRead();\n         }\n     }\n     \n     public String getCommentLeadingCharsUsedInInput() {\n@@ -104,313 +104,306 @@\n             return this.commentCharsUsedInInput;\n         }\n         finally {\n             this.endRead();\n         }\n     }\n     \n-    public void setCommentLeadingCharsUsedInInput(final String separator) {\n+    public void setCommentLeadingCharsUsedInInput(final String commentCharsUsedInInput) {\n         this.beginRead(false);\n         try {\n-            this.commentCharsUsedInInput = separator;\n+            this.commentCharsUsedInInput = commentCharsUsedInInput;\n         }\n         finally {\n             this.endRead();\n         }\n     }\n     \n-    public void write(final Writer writer) throws ConfigurationException, IOException {\n-        final PrintWriter out = new PrintWriter(writer);\n-        boolean first = true;\n-        final String separator = this.getSeparatorUsedInOutput();\n+    public void write(final Writer out) throws ConfigurationException, IOException {\n+        final PrintWriter printWriter = new PrintWriter(out);\n+        int n = 1;\n+        final String separatorUsedInOutput = this.getSeparatorUsedInOutput();\n         this.beginRead(false);\n         try {\n-            for (final ImmutableNode node : ((ImmutableNode)this.getModel().getNodeHandler().getRootNode()).getChildren()) {\n-                if (isSectionNode(node)) {\n-                    if (!first) {\n-                        out.println();\n+            for (final ImmutableNode immutableNode : ((ImmutableNode)this.getModel().getNodeHandler().getRootNode()).getChildren()) {\n+                if (isSectionNode(immutableNode)) {\n+                    if (n == 0) {\n+                        printWriter.println();\n                     }\n-                    out.print(\"[\");\n-                    out.print(node.getNodeName());\n-                    out.print(\"]\");\n-                    out.println();\n-                    node.forEach(child -> this.writeProperty(out, child.getNodeName(), child.getValue(), separator));\n+                    printWriter.print(\"[\");\n+                    printWriter.print(immutableNode.getNodeName());\n+                    printWriter.print(\"]\");\n+                    printWriter.println();\n+                    immutableNode.forEach(immutableNode2 -> this.writeProperty(printWriter2, immutableNode2.getNodeName(), immutableNode2.getValue(), s));\n                 }\n                 else {\n-                    this.writeProperty(out, node.getNodeName(), node.getValue(), separator);\n+                    this.writeProperty(printWriter, immutableNode.getNodeName(), immutableNode.getValue(), separatorUsedInOutput);\n                 }\n-                first = false;\n+                n = 0;\n             }\n-            out.println();\n-            out.flush();\n+            printWriter.println();\n+            printWriter.flush();\n         }\n         finally {\n             this.endRead();\n         }\n     }\n     \n     public void read(final Reader in) throws ConfigurationException, IOException {\n         final BufferedReader bufferedReader = new BufferedReader(in);\n-        final Map<String, ImmutableNode.Builder> sectionBuilders = new LinkedHashMap<String, ImmutableNode.Builder>();\n-        final ImmutableNode.Builder rootBuilder = new ImmutableNode.Builder();\n-        this.createNodeBuilders(bufferedReader, rootBuilder, sectionBuilders);\n-        final ImmutableNode rootNode = createNewRootNode(rootBuilder, sectionBuilders);\n-        this.addNodes((String)null, (Collection)rootNode.getChildren());\n-    }\n-    \n-    private static ImmutableNode createNewRootNode(final ImmutableNode.Builder rootBuilder, final Map<String, ImmutableNode.Builder> sectionBuilders) {\n-        sectionBuilders.forEach((k, v) -> rootBuilder.addChild(v.name(k).create()));\n-        return rootBuilder.create();\n-    }\n-    \n-    private void createNodeBuilders(final BufferedReader in, final ImmutableNode.Builder rootBuilder, final Map<String, ImmutableNode.Builder> sectionBuilders) throws IOException {\n-        ImmutableNode.Builder sectionBuilder = rootBuilder;\n-        for (String line = in.readLine(); line != null; line = in.readLine()) {\n-            line = line.trim();\n-            if (!this.isCommentLine(line)) {\n-                if (this.isSectionLine(line)) {\n-                    final int length = this.sectionInLineCommentsAllowed ? line.indexOf(\"]\") : (line.length() - 1);\n-                    final String section = line.substring(1, length);\n-                    sectionBuilder = sectionBuilders.get(section);\n-                    if (sectionBuilder == null) {\n-                        sectionBuilder = new ImmutableNode.Builder();\n-                        sectionBuilders.put(section, sectionBuilder);\n+        final LinkedHashMap linkedHashMap = new LinkedHashMap();\n+        final ImmutableNode.Builder builder = new ImmutableNode.Builder();\n+        this.createNodeBuilders(bufferedReader, builder, linkedHashMap);\n+        this.addNodes((String)null, (Collection)createNewRootNode(builder, linkedHashMap).getChildren());\n+    }\n+    \n+    private static ImmutableNode createNewRootNode(final ImmutableNode.Builder builder, final Map<String, ImmutableNode.Builder> map) {\n+        map.forEach((s, builder3) -> builder2.addChild(builder3.name(s).create()));\n+        return builder.create();\n+    }\n+    \n+    private void createNodeBuilders(final BufferedReader bufferedReader, final ImmutableNode.Builder builder, final Map<String, ImmutableNode.Builder> map) throws IOException {\n+        ImmutableNode.Builder builder2 = builder;\n+        for (String s = bufferedReader.readLine(); s != null; s = bufferedReader.readLine()) {\n+            final String trim = s.trim();\n+            if (!this.isCommentLine(trim)) {\n+                if (this.isSectionLine(trim)) {\n+                    final String substring = trim.substring(1, this.sectionInLineCommentsAllowed ? trim.indexOf(\"]\") : (trim.length() - 1));\n+                    builder2 = map.get(substring);\n+                    if (builder2 == null) {\n+                        builder2 = new ImmutableNode.Builder();\n+                        map.put(substring, builder2);\n                     }\n                 }\n                 else {\n                     String value = \"\";\n-                    final int index = this.findSeparator(line);\n-                    String key;\n-                    if (index >= 0) {\n-                        key = line.substring(0, index);\n-                        value = this.parseValue(line.substring(index + 1), in);\n+                    final int separator = this.findSeparator(trim);\n+                    String substring2;\n+                    if (separator >= 0) {\n+                        substring2 = trim.substring(0, separator);\n+                        value = this.parseValue(trim.substring(separator + 1), bufferedReader);\n                     }\n                     else {\n-                        key = line;\n+                        substring2 = trim;\n                     }\n-                    key = key.trim();\n-                    if (key.isEmpty()) {\n-                        key = \" \";\n+                    String trim2 = substring2.trim();\n+                    if (trim2.isEmpty()) {\n+                        trim2 = \" \";\n                     }\n-                    this.createValueNodes(sectionBuilder, key, value);\n+                    this.createValueNodes(builder2, trim2, value);\n                 }\n             }\n         }\n     }\n     \n-    private void createValueNodes(final ImmutableNode.Builder sectionBuilder, final String key, final String value) {\n-        this.getListDelimiterHandler().split(value, false).forEach(v -> sectionBuilder.addChild(new ImmutableNode.Builder().name(key).value((Object)v).create()));\n+    private void createValueNodes(final ImmutableNode.Builder builder, final String s, final String s2) {\n+        this.getListDelimiterHandler().split(s2, false).forEach(s4 -> builder2.addChild(new ImmutableNode.Builder().name(s3).value((Object)s4).create()));\n     }\n     \n-    private void writeProperty(final PrintWriter out, final String key, final Object value, final String separator) {\n-        out.print(key);\n-        out.print(separator);\n-        out.print(this.escapeValue(value.toString()));\n-        out.println();\n+    private void writeProperty(final PrintWriter printWriter, final String s, final Object o, final String s2) {\n+        printWriter.print(s);\n+        printWriter.print(s2);\n+        printWriter.print(this.escapeValue(o.toString()));\n+        printWriter.println();\n     }\n     \n-    private String parseValue(final String val, final BufferedReader reader) throws IOException {\n-        final StringBuilder propertyValue = new StringBuilder();\n-        String value = val.trim();\n-        boolean lineContinues;\n+    private String parseValue(final String s, final BufferedReader bufferedReader) throws IOException {\n+        final StringBuilder sb = new StringBuilder();\n+        String s2 = s.trim();\n+        boolean b;\n         do {\n-            final boolean quoted = value.startsWith(\"\\\"\") || value.startsWith(\"'\");\n-            boolean stop = false;\n-            boolean escape = false;\n-            final char quote = quoted ? value.charAt(0) : '\\0';\n-            int i = quoted ? 1 : 0;\n-            final StringBuilder result = new StringBuilder();\n-            char lastChar = '\\0';\n-            while (i < value.length() && !stop) {\n-                final char c = value.charAt(i);\n-                if (quoted) {\n-                    if ('\\\\' == c && !escape) {\n-                        escape = true;\n+            final int n = (s2.startsWith(\"\\\"\") || s2.startsWith(\"'\")) ? 1 : 0;\n+            int n2 = 0;\n+            int n3 = 0;\n+            final char c = (n != 0) ? s2.charAt(0) : '\\0';\n+            int index = n;\n+            final StringBuilder sb2 = new StringBuilder();\n+            char ch = '\\0';\n+            while (index < s2.length() && n2 == 0) {\n+                final char char1 = s2.charAt(index);\n+                if (n != 0) {\n+                    if ('\\\\' == char1 && n3 == 0) {\n+                        n3 = 1;\n                     }\n-                    else if (!escape && quote == c) {\n-                        stop = true;\n+                    else if (n3 == 0 && c == char1) {\n+                        n2 = 1;\n                     }\n                     else {\n-                        if (escape && quote == c) {\n-                            escape = false;\n+                        if (n3 != 0 && c == char1) {\n+                            n3 = 0;\n                         }\n-                        else if (escape) {\n-                            escape = false;\n-                            result.append('\\\\');\n+                        else if (n3 != 0) {\n+                            n3 = 0;\n+                            sb2.append('\\\\');\n                         }\n-                        result.append(c);\n+                        sb2.append(char1);\n                     }\n                 }\n-                else if (this.isCommentChar(c) && Character.isWhitespace(lastChar)) {\n-                    stop = true;\n+                else if (this.isCommentChar(char1) && Character.isWhitespace(ch)) {\n+                    n2 = 1;\n                 }\n                 else {\n-                    result.append(c);\n+                    sb2.append(char1);\n                 }\n-                ++i;\n-                lastChar = c;\n+                ++index;\n+                ch = char1;\n             }\n-            String v = result.toString();\n-            if (!quoted) {\n-                v = v.trim();\n-                lineContinues = lineContinues(v);\n-                if (lineContinues) {\n-                    v = v.substring(0, v.length() - 1).trim();\n+            String str = sb2.toString();\n+            if (n == 0) {\n+                str = str.trim();\n+                b = lineContinues(str);\n+                if (b) {\n+                    str = str.substring(0, str.length() - 1).trim();\n                 }\n             }\n             else {\n-                lineContinues = this.lineContinues(value, i);\n+                b = this.lineContinues(s2, index);\n             }\n-            propertyValue.append(v);\n-            if (lineContinues) {\n-                propertyValue.append(INIConfiguration.LINE_SEPARATOR);\n-                value = reader.readLine();\n+            sb.append(str);\n+            if (b) {\n+                sb.append(INIConfiguration.LINE_SEPARATOR);\n+                s2 = bufferedReader.readLine();\n             }\n-        } while (lineContinues && value != null);\n-        return propertyValue.toString();\n+        } while (b && s2 != null);\n+        return sb.toString();\n     }\n     \n-    private static boolean lineContinues(final String line) {\n-        final String s = line.trim();\n-        return s.equals(\"\\\\\") || (s.length() > 2 && s.endsWith(\"\\\\\") && Character.isWhitespace(s.charAt(s.length() - 2)));\n+    private static boolean lineContinues(final String s) {\n+        final String trim = s.trim();\n+        return trim.equals(\"\\\\\") || (trim.length() > 2 && trim.endsWith(\"\\\\\") && Character.isWhitespace(trim.charAt(trim.length() - 2)));\n     }\n     \n-    private boolean lineContinues(final String line, final int pos) {\n-        String s;\n-        if (pos >= line.length()) {\n-            s = line;\n+    private boolean lineContinues(final String s, final int beginIndex) {\n+        String substring;\n+        if (beginIndex >= s.length()) {\n+            substring = s;\n         }\n         else {\n-            int end;\n-            for (end = pos; end < line.length() && !this.isCommentChar(line.charAt(end)); ++end) {}\n-            s = line.substring(pos, end);\n+            int n;\n+            for (n = beginIndex; n < s.length() && !this.isCommentChar(s.charAt(n)); ++n) {}\n+            substring = s.substring(beginIndex, n);\n         }\n-        return lineContinues(s);\n+        return lineContinues(substring);\n     }\n     \n-    private boolean isCommentChar(final char c) {\n-        return this.getCommentLeadingCharsUsedInInput().indexOf(c) >= 0;\n+    private boolean isCommentChar(final char ch) {\n+        return this.getCommentLeadingCharsUsedInInput().indexOf(ch) >= 0;\n     }\n     \n-    private int findSeparator(final String line) {\n-        int index = findSeparatorBeforeQuote(line, findFirstOccurrence(line, \"\\\"'\"));\n-        if (index < 0) {\n-            index = findFirstOccurrence(line, this.getSeparatorUsedInInput());\n+    private int findSeparator(final String s) {\n+        int n = findSeparatorBeforeQuote(s, findFirstOccurrence(s, \"\\\"'\"));\n+        if (n < 0) {\n+            n = findFirstOccurrence(s, this.getSeparatorUsedInInput());\n         }\n-        return index;\n+        return n;\n     }\n     \n-    private static int findFirstOccurrence(final String line, final String separators) {\n-        int index = -1;\n-        for (int i = 0; i < separators.length(); ++i) {\n-            final char sep = separators.charAt(i);\n-            final int pos = line.indexOf(sep);\n-            if (pos >= 0 && (index < 0 || pos < index)) {\n-                index = pos;\n+    private static int findFirstOccurrence(final String s, final String s2) {\n+        int n = -1;\n+        for (int i = 0; i < s2.length(); ++i) {\n+            final int index = s.indexOf(s2.charAt(i));\n+            if (index >= 0 && (n < 0 || index < n)) {\n+                n = index;\n             }\n         }\n-        return index;\n+        return n;\n     }\n     \n-    private static int findSeparatorBeforeQuote(final String line, final int quoteIndex) {\n-        int index;\n-        for (index = quoteIndex - 1; index >= 0 && Character.isWhitespace(line.charAt(index)); --index) {}\n-        if (index >= 0 && \"=:\".indexOf(line.charAt(index)) < 0) {\n-            index = -1;\n+    private static int findSeparatorBeforeQuote(final String s, final int n) {\n+        int n2;\n+        for (n2 = n - 1; n2 >= 0 && Character.isWhitespace(s.charAt(n2)); --n2) {}\n+        if (n2 >= 0 && \"=:\".indexOf(s.charAt(n2)) < 0) {\n+            n2 = -1;\n         }\n-        return index;\n+        return n2;\n     }\n     \n-    private String escapeValue(final String value) {\n-        return String.valueOf(this.getListDelimiterHandler().escape((Object)this.escapeComments(value), ListDelimiterHandler.NOOP_TRANSFORMER));\n+    private String escapeValue(final String s) {\n+        return String.valueOf(this.getListDelimiterHandler().escape((Object)this.escapeComments(s), ListDelimiterHandler.NOOP_TRANSFORMER));\n     }\n     \n-    private String escapeComments(final String value) {\n-        final String commentChars = this.getCommentLeadingCharsUsedInInput();\n-        boolean quoted = false;\n-        for (int i = 0; i < commentChars.length(); ++i) {\n-            final char c = commentChars.charAt(i);\n-            if (value.indexOf(c) != -1) {\n-                quoted = true;\n+    private String escapeComments(final String s) {\n+        final String commentLeadingCharsUsedInInput = this.getCommentLeadingCharsUsedInInput();\n+        boolean b = false;\n+        for (int i = 0; i < commentLeadingCharsUsedInInput.length(); ++i) {\n+            if (s.indexOf(commentLeadingCharsUsedInInput.charAt(i)) != -1) {\n+                b = true;\n                 break;\n             }\n         }\n-        if (quoted) {\n-            return '\\\"' + value.replace((CharSequence)\"\\\"\", (CharSequence)\"\\\\\\\"\") + '\\\"';\n+        if (b) {\n+            return '\\\"' + s.replace((CharSequence)\"\\\"\", (CharSequence)\"\\\\\\\"\") + '\\\"';\n         }\n-        return value;\n+        return s;\n     }\n     \n-    protected boolean isCommentLine(final String line) {\n-        return line != null && (line.isEmpty() || this.getCommentLeadingCharsUsedInInput().indexOf(line.charAt(0)) >= 0);\n+    protected boolean isCommentLine(final String s) {\n+        return s != null && (s.isEmpty() || this.getCommentLeadingCharsUsedInInput().indexOf(s.charAt(0)) >= 0);\n     }\n     \n-    protected boolean isSectionLine(final String line) {\n-        return line != null && (this.sectionInLineCommentsAllowed ? isNonStrictSection(line) : isStrictSection(line));\n+    protected boolean isSectionLine(final String s) {\n+        return s != null && (this.sectionInLineCommentsAllowed ? isNonStrictSection(s) : isStrictSection(s));\n     }\n     \n-    private static boolean isStrictSection(final String line) {\n-        return line.startsWith(\"[\") && line.endsWith(\"]\");\n+    private static boolean isStrictSection(final String s) {\n+        return s.startsWith(\"[\") && s.endsWith(\"]\");\n     }\n     \n-    private static boolean isNonStrictSection(final String line) {\n-        return line.startsWith(\"[\") && line.contains(\"]\");\n+    private static boolean isNonStrictSection(final String s) {\n+        return s.startsWith(\"[\") && s.contains(\"]\");\n     }\n     \n     public Set<String> getSections() {\n-        final Set<String> sections = new LinkedHashSet<String>();\n-        boolean globalSection = false;\n-        boolean inSection = false;\n+        final LinkedHashSet set = new LinkedHashSet();\n+        int n = 0;\n+        boolean b = false;\n         this.beginRead(false);\n         try {\n-            for (final ImmutableNode node : ((ImmutableNode)this.getModel().getNodeHandler().getRootNode()).getChildren()) {\n-                if (isSectionNode(node)) {\n-                    inSection = true;\n-                    sections.add(node.getNodeName());\n+            for (final ImmutableNode immutableNode : ((ImmutableNode)this.getModel().getNodeHandler().getRootNode()).getChildren()) {\n+                if (isSectionNode(immutableNode)) {\n+                    b = true;\n+                    set.add(immutableNode.getNodeName());\n                 }\n                 else {\n-                    if (inSection || globalSection) {\n+                    if (b || n != 0) {\n                         continue;\n                     }\n-                    globalSection = true;\n-                    sections.add(null);\n+                    n = 1;\n+                    set.add(null);\n                 }\n             }\n         }\n         finally {\n             this.endRead();\n         }\n-        return sections;\n+        return set;\n     }\n     \n-    public SubnodeConfiguration getSection(final String name) {\n-        if (name == null) {\n+    public SubnodeConfiguration getSection(final String s) {\n+        if (s == null) {\n             return this.getGlobalSection();\n         }\n         try {\n-            return (SubnodeConfiguration)this.configurationAt(name, true);\n+            return (SubnodeConfiguration)this.configurationAt(s, true);\n         }\n-        catch (final ConfigurationRuntimeException iex) {\n-            final InMemoryNodeModel parentModel = this.getSubConfigurationParentModel();\n-            final NodeSelector selector = parentModel.trackChildNodeWithCreation((String)null, name, (NodeKeyResolver)this);\n-            return this.createSubConfigurationForTrackedNode(selector, (InMemoryNodeModelSupport)this);\n+        catch (final ConfigurationRuntimeException ex) {\n+            return this.createSubConfigurationForTrackedNode(this.getSubConfigurationParentModel().trackChildNodeWithCreation((String)null, s, (NodeKeyResolver)this), (InMemoryNodeModelSupport)this);\n         }\n     }\n     \n     private SubnodeConfiguration getGlobalSection() {\n-        final InMemoryNodeModel parentModel = this.getSubConfigurationParentModel();\n-        final NodeSelector selector = new NodeSelector((String)null);\n-        parentModel.trackNode(selector, (NodeKeyResolver)this);\n-        final INIConfiguration.GlobalSectionNodeModel model = new INIConfiguration.GlobalSectionNodeModel((InMemoryNodeModelSupport)this, selector);\n-        final SubnodeConfiguration sub = new SubnodeConfiguration((BaseHierarchicalConfiguration)this, (TrackedNodeModel)model);\n-        this.initSubConfigurationForThisParent(sub);\n-        return sub;\n+        final InMemoryNodeModel subConfigurationParentModel = this.getSubConfigurationParentModel();\n+        final NodeSelector nodeSelector = new NodeSelector((String)null);\n+        subConfigurationParentModel.trackNode(nodeSelector, (NodeKeyResolver)this);\n+        final SubnodeConfiguration subnodeConfiguration = new SubnodeConfiguration((BaseHierarchicalConfiguration)this, (TrackedNodeModel)new INIConfiguration.GlobalSectionNodeModel((InMemoryNodeModelSupport)this, nodeSelector));\n+        this.initSubConfigurationForThisParent(subnodeConfiguration);\n+        return subnodeConfiguration;\n     }\n     \n-    private static boolean isSectionNode(final ImmutableNode node) {\n-        return node.getValue() == null;\n+    private static boolean isSectionNode(final ImmutableNode immutableNode) {\n+        return immutableNode.getValue() == null;\n     }\n     \n     static {\n         LINE_SEPARATOR = System.lineSeparator();\n     }\n }\n"}]}
