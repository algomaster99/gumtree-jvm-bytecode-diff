{"diffoscope-json-version": 1, "source1": "first/ArjArchiveInputStream.class", "source2": "second/ArjArchiveInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -21,219 +21,219 @@\n     private static final int ARJ_MAGIC_2 = 234;\n     private final DataInputStream in;\n     private final String charsetName;\n     private final MainHeader mainHeader;\n     private LocalFileHeader currentLocalFileHeader;\n     private InputStream currentInputStream;\n     \n-    public ArjArchiveInputStream(final InputStream inputStream, final String charsetName) throws ArchiveException {\n+    public ArjArchiveInputStream(final InputStream in, final String charsetName) throws ArchiveException {\n         this.currentLocalFileHeader = null;\n         this.currentInputStream = null;\n-        this.in = new DataInputStream(inputStream);\n+        this.in = new DataInputStream(in);\n         this.charsetName = charsetName;\n         try {\n             this.mainHeader = this.readMainHeader();\n             if ((this.mainHeader.arjFlags & 0x1) != 0x0) {\n                 throw new ArchiveException(\"Encrypted ARJ files are unsupported\");\n             }\n             if ((this.mainHeader.arjFlags & 0x4) != 0x0) {\n                 throw new ArchiveException(\"Multi-volume ARJ files are unsupported\");\n             }\n         }\n-        catch (final IOException ioException) {\n-            throw new ArchiveException(ioException.getMessage(), (Exception)ioException);\n+        catch (final IOException ex) {\n+            throw new ArchiveException(ex.getMessage(), (Exception)ex);\n         }\n     }\n     \n     public ArjArchiveInputStream(final InputStream inputStream) throws ArchiveException {\n         this(inputStream, \"CP437\");\n     }\n     \n     public void close() throws IOException {\n         this.in.close();\n     }\n     \n-    private int read8(final DataInputStream dataIn) throws IOException {\n-        final int value = dataIn.readUnsignedByte();\n+    private int read8(final DataInputStream dataInputStream) throws IOException {\n+        final int unsignedByte = dataInputStream.readUnsignedByte();\n         this.count(1);\n-        return value;\n+        return unsignedByte;\n     }\n     \n-    private int read16(final DataInputStream dataIn) throws IOException {\n-        final int value = dataIn.readUnsignedShort();\n+    private int read16(final DataInputStream dataInputStream) throws IOException {\n+        final int unsignedShort = dataInputStream.readUnsignedShort();\n         this.count(2);\n-        return Integer.reverseBytes(value) >>> 16;\n+        return Integer.reverseBytes(unsignedShort) >>> 16;\n     }\n     \n-    private int read32(final DataInputStream dataIn) throws IOException {\n-        final int value = dataIn.readInt();\n+    private int read32(final DataInputStream dataInputStream) throws IOException {\n+        final int int1 = dataInputStream.readInt();\n         this.count(4);\n-        return Integer.reverseBytes(value);\n+        return Integer.reverseBytes(int1);\n     }\n     \n-    private String readString(final DataInputStream dataIn) throws IOException {\n-        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n-        int nextByte;\n-        while ((nextByte = dataIn.readUnsignedByte()) != 0) {\n-            buffer.write(nextByte);\n+    private String readString(final DataInputStream dataInputStream) throws IOException {\n+        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+        int unsignedByte;\n+        while ((unsignedByte = dataInputStream.readUnsignedByte()) != 0) {\n+            byteArrayOutputStream.write(unsignedByte);\n         }\n         if (this.charsetName != null) {\n-            return new String(buffer.toByteArray(), this.charsetName);\n+            return new String(byteArrayOutputStream.toByteArray(), this.charsetName);\n         }\n-        return new String(buffer.toByteArray());\n+        return new String(byteArrayOutputStream.toByteArray());\n     }\n     \n-    private void readFully(final DataInputStream dataIn, final byte[] b) throws IOException {\n-        dataIn.readFully(b);\n+    private void readFully(final DataInputStream dataInputStream, final byte[] b) throws IOException {\n+        dataInputStream.readFully(b);\n         this.count(b.length);\n     }\n     \n     private byte[] readHeader() throws IOException {\n-        boolean found = false;\n-        byte[] basicHeaderBytes = null;\n+        boolean b = false;\n+        byte[] b2 = null;\n         do {\n-            int first = 0;\n-            int second = this.read8(this.in);\n+            int n = this.read8(this.in);\n+            int n2;\n             do {\n-                first = second;\n-                second = this.read8(this.in);\n-            } while (first != 96 && second != 234);\n-            final int basicHeaderSize = this.read16(this.in);\n-            if (basicHeaderSize == 0) {\n+                n2 = n;\n+                n = this.read8(this.in);\n+            } while (n2 != 96 && n != 234);\n+            final int read16 = this.read16(this.in);\n+            if (read16 == 0) {\n                 return null;\n             }\n-            if (basicHeaderSize > 2600) {\n+            if (read16 > 2600) {\n                 continue;\n             }\n-            basicHeaderBytes = new byte[basicHeaderSize];\n-            this.readFully(this.in, basicHeaderBytes);\n-            final long basicHeaderCrc32 = (long)this.read32(this.in) & 0xFFFFFFFFL;\n+            b2 = new byte[read16];\n+            this.readFully(this.in, b2);\n+            final long n3 = (long)this.read32(this.in) & 0xFFFFFFFFL;\n             final CRC32 crc32 = new CRC32();\n-            crc32.update(basicHeaderBytes);\n-            if (basicHeaderCrc32 != crc32.getValue()) {\n+            crc32.update(b2);\n+            if (n3 != crc32.getValue()) {\n                 continue;\n             }\n-            found = true;\n-        } while (!found);\n-        return basicHeaderBytes;\n+            b = true;\n+        } while (!b);\n+        return b2;\n     }\n     \n     private MainHeader readMainHeader() throws IOException {\n-        final byte[] basicHeaderBytes = this.readHeader();\n-        if (basicHeaderBytes == null) {\n+        final byte[] header = this.readHeader();\n+        if (header == null) {\n             throw new IOException(\"Archive ends without any headers\");\n         }\n-        final DataInputStream basicHeader = new DataInputStream(new ByteArrayInputStream(basicHeaderBytes));\n-        final int firstHeaderSize = basicHeader.readUnsignedByte();\n-        final byte[] firstHeaderBytes = new byte[firstHeaderSize - 1];\n-        basicHeader.readFully(firstHeaderBytes);\n-        final DataInputStream firstHeader = new DataInputStream(new ByteArrayInputStream(firstHeaderBytes));\n-        final MainHeader hdr = new MainHeader();\n-        hdr.archiverVersionNumber = firstHeader.readUnsignedByte();\n-        hdr.minVersionToExtract = firstHeader.readUnsignedByte();\n-        hdr.hostOS = firstHeader.readUnsignedByte();\n-        hdr.arjFlags = firstHeader.readUnsignedByte();\n-        hdr.securityVersion = firstHeader.readUnsignedByte();\n-        hdr.fileType = firstHeader.readUnsignedByte();\n-        hdr.reserved = firstHeader.readUnsignedByte();\n-        hdr.dateTimeCreated = this.read32(firstHeader);\n-        hdr.dateTimeModified = this.read32(firstHeader);\n-        hdr.archiveSize = (0xFFFFFFFFL & (long)this.read32(firstHeader));\n-        hdr.securityEnvelopeFilePosition = this.read32(firstHeader);\n-        hdr.fileSpecPosition = this.read16(firstHeader);\n-        hdr.securityEnvelopeLength = this.read16(firstHeader);\n+        final DataInputStream dataInputStream = new DataInputStream(new ByteArrayInputStream(header));\n+        final int unsignedByte = dataInputStream.readUnsignedByte();\n+        final byte[] array = new byte[unsignedByte - 1];\n+        dataInputStream.readFully(array);\n+        final DataInputStream dataInputStream2 = new DataInputStream(new ByteArrayInputStream(array));\n+        final MainHeader mainHeader = new MainHeader();\n+        mainHeader.archiverVersionNumber = dataInputStream2.readUnsignedByte();\n+        mainHeader.minVersionToExtract = dataInputStream2.readUnsignedByte();\n+        mainHeader.hostOS = dataInputStream2.readUnsignedByte();\n+        mainHeader.arjFlags = dataInputStream2.readUnsignedByte();\n+        mainHeader.securityVersion = dataInputStream2.readUnsignedByte();\n+        mainHeader.fileType = dataInputStream2.readUnsignedByte();\n+        mainHeader.reserved = dataInputStream2.readUnsignedByte();\n+        mainHeader.dateTimeCreated = this.read32(dataInputStream2);\n+        mainHeader.dateTimeModified = this.read32(dataInputStream2);\n+        mainHeader.archiveSize = (0xFFFFFFFFL & (long)this.read32(dataInputStream2));\n+        mainHeader.securityEnvelopeFilePosition = this.read32(dataInputStream2);\n+        mainHeader.fileSpecPosition = this.read16(dataInputStream2);\n+        mainHeader.securityEnvelopeLength = this.read16(dataInputStream2);\n         this.pushedBackBytes(20L);\n-        hdr.encryptionVersion = firstHeader.readUnsignedByte();\n-        hdr.lastChapter = firstHeader.readUnsignedByte();\n-        if (firstHeaderSize >= 33) {\n-            hdr.arjProtectionFactor = firstHeader.readUnsignedByte();\n-            hdr.arjFlags2 = firstHeader.readUnsignedByte();\n-            firstHeader.readUnsignedByte();\n-            firstHeader.readUnsignedByte();\n-        }\n-        hdr.name = this.readString(basicHeader);\n-        hdr.comment = this.readString(basicHeader);\n-        final int extendedHeaderSize = this.read16(this.in);\n-        if (extendedHeaderSize > 0) {\n-            hdr.extendedHeaderBytes = new byte[extendedHeaderSize];\n-            this.readFully(this.in, hdr.extendedHeaderBytes);\n-            final long extendedHeaderCrc32 = 0xFFFFFFFFL & (long)this.read32(this.in);\n+        mainHeader.encryptionVersion = dataInputStream2.readUnsignedByte();\n+        mainHeader.lastChapter = dataInputStream2.readUnsignedByte();\n+        if (unsignedByte >= 33) {\n+            mainHeader.arjProtectionFactor = dataInputStream2.readUnsignedByte();\n+            mainHeader.arjFlags2 = dataInputStream2.readUnsignedByte();\n+            dataInputStream2.readUnsignedByte();\n+            dataInputStream2.readUnsignedByte();\n+        }\n+        mainHeader.name = this.readString(dataInputStream);\n+        mainHeader.comment = this.readString(dataInputStream);\n+        final int read16 = this.read16(this.in);\n+        if (read16 > 0) {\n+            mainHeader.extendedHeaderBytes = new byte[read16];\n+            this.readFully(this.in, mainHeader.extendedHeaderBytes);\n+            final long n = 0xFFFFFFFFL & (long)this.read32(this.in);\n             final CRC32 crc32 = new CRC32();\n-            crc32.update(hdr.extendedHeaderBytes);\n-            if (extendedHeaderCrc32 != crc32.getValue()) {\n+            crc32.update(mainHeader.extendedHeaderBytes);\n+            if (n != crc32.getValue()) {\n                 throw new IOException(\"Extended header CRC32 verification failure\");\n             }\n         }\n-        return hdr;\n+        return mainHeader;\n     }\n     \n     private LocalFileHeader readLocalFileHeader() throws IOException {\n-        final byte[] basicHeaderBytes = this.readHeader();\n-        if (basicHeaderBytes == null) {\n+        final byte[] header = this.readHeader();\n+        if (header == null) {\n             return null;\n         }\n-        try (final DataInputStream basicHeader = new DataInputStream(new ByteArrayInputStream(basicHeaderBytes))) {\n-            final int firstHeaderSize = basicHeader.readUnsignedByte();\n-            final byte[] firstHeaderBytes = new byte[firstHeaderSize - 1];\n-            basicHeader.readFully(firstHeaderBytes);\n-            try (final DataInputStream firstHeader = new DataInputStream(new ByteArrayInputStream(firstHeaderBytes))) {\n+        try (final DataInputStream dataInputStream = new DataInputStream(new ByteArrayInputStream(header))) {\n+            final int unsignedByte = dataInputStream.readUnsignedByte();\n+            final byte[] array = new byte[unsignedByte - 1];\n+            dataInputStream.readFully(array);\n+            try (final DataInputStream dataInputStream2 = new DataInputStream(new ByteArrayInputStream(array))) {\n                 final LocalFileHeader localFileHeader = new LocalFileHeader();\n-                localFileHeader.archiverVersionNumber = firstHeader.readUnsignedByte();\n-                localFileHeader.minVersionToExtract = firstHeader.readUnsignedByte();\n-                localFileHeader.hostOS = firstHeader.readUnsignedByte();\n-                localFileHeader.arjFlags = firstHeader.readUnsignedByte();\n-                localFileHeader.method = firstHeader.readUnsignedByte();\n-                localFileHeader.fileType = firstHeader.readUnsignedByte();\n-                localFileHeader.reserved = firstHeader.readUnsignedByte();\n-                localFileHeader.dateTimeModified = this.read32(firstHeader);\n-                localFileHeader.compressedSize = (0xFFFFFFFFL & (long)this.read32(firstHeader));\n-                localFileHeader.originalSize = (0xFFFFFFFFL & (long)this.read32(firstHeader));\n-                localFileHeader.originalCrc32 = (0xFFFFFFFFL & (long)this.read32(firstHeader));\n-                localFileHeader.fileSpecPosition = this.read16(firstHeader);\n-                localFileHeader.fileAccessMode = this.read16(firstHeader);\n+                localFileHeader.archiverVersionNumber = dataInputStream2.readUnsignedByte();\n+                localFileHeader.minVersionToExtract = dataInputStream2.readUnsignedByte();\n+                localFileHeader.hostOS = dataInputStream2.readUnsignedByte();\n+                localFileHeader.arjFlags = dataInputStream2.readUnsignedByte();\n+                localFileHeader.method = dataInputStream2.readUnsignedByte();\n+                localFileHeader.fileType = dataInputStream2.readUnsignedByte();\n+                localFileHeader.reserved = dataInputStream2.readUnsignedByte();\n+                localFileHeader.dateTimeModified = this.read32(dataInputStream2);\n+                localFileHeader.compressedSize = (0xFFFFFFFFL & (long)this.read32(dataInputStream2));\n+                localFileHeader.originalSize = (0xFFFFFFFFL & (long)this.read32(dataInputStream2));\n+                localFileHeader.originalCrc32 = (0xFFFFFFFFL & (long)this.read32(dataInputStream2));\n+                localFileHeader.fileSpecPosition = this.read16(dataInputStream2);\n+                localFileHeader.fileAccessMode = this.read16(dataInputStream2);\n                 this.pushedBackBytes(20L);\n-                localFileHeader.firstChapter = firstHeader.readUnsignedByte();\n-                localFileHeader.lastChapter = firstHeader.readUnsignedByte();\n-                this.readExtraData(firstHeaderSize, firstHeader, localFileHeader);\n-                localFileHeader.name = this.readString(basicHeader);\n-                localFileHeader.comment = this.readString(basicHeader);\n-                final ArrayList<byte[]> extendedHeaders = new ArrayList<byte[]>();\n-                int extendedHeaderSize;\n-                while ((extendedHeaderSize = this.read16(this.in)) > 0) {\n-                    final byte[] extendedHeaderBytes = new byte[extendedHeaderSize];\n-                    this.readFully(this.in, extendedHeaderBytes);\n-                    final long extendedHeaderCrc32 = 0xFFFFFFFFL & (long)this.read32(this.in);\n+                localFileHeader.firstChapter = dataInputStream2.readUnsignedByte();\n+                localFileHeader.lastChapter = dataInputStream2.readUnsignedByte();\n+                this.readExtraData(unsignedByte, dataInputStream2, localFileHeader);\n+                localFileHeader.name = this.readString(dataInputStream);\n+                localFileHeader.comment = this.readString(dataInputStream);\n+                final ArrayList list = new ArrayList();\n+                int read16;\n+                while ((read16 = this.read16(this.in)) > 0) {\n+                    final byte[] array2 = new byte[read16];\n+                    this.readFully(this.in, array2);\n+                    final long n = 0xFFFFFFFFL & (long)this.read32(this.in);\n                     final CRC32 crc32 = new CRC32();\n-                    crc32.update(extendedHeaderBytes);\n-                    if (extendedHeaderCrc32 != crc32.getValue()) {\n+                    crc32.update(array2);\n+                    if (n != crc32.getValue()) {\n                         throw new IOException(\"Extended header CRC32 verification failure\");\n                     }\n-                    extendedHeaders.add(extendedHeaderBytes);\n+                    list.add(array2);\n                 }\n-                localFileHeader.extendedHeaders = extendedHeaders.toArray(new byte[extendedHeaders.size()][]);\n+                localFileHeader.extendedHeaders = list.toArray(new byte[list.size()][]);\n                 return localFileHeader;\n             }\n         }\n     }\n     \n-    private void readExtraData(final int firstHeaderSize, final DataInputStream firstHeader, final LocalFileHeader localFileHeader) throws IOException {\n-        if (firstHeaderSize >= 33) {\n-            localFileHeader.extendedFilePosition = this.read32(firstHeader);\n-            if (firstHeaderSize >= 45) {\n-                localFileHeader.dateTimeAccessed = this.read32(firstHeader);\n-                localFileHeader.dateTimeCreated = this.read32(firstHeader);\n-                localFileHeader.originalSizeEvenForVolumes = this.read32(firstHeader);\n+    private void readExtraData(final int n, final DataInputStream dataInputStream, final LocalFileHeader localFileHeader) throws IOException {\n+        if (n >= 33) {\n+            localFileHeader.extendedFilePosition = this.read32(dataInputStream);\n+            if (n >= 45) {\n+                localFileHeader.dateTimeAccessed = this.read32(dataInputStream);\n+                localFileHeader.dateTimeCreated = this.read32(dataInputStream);\n+                localFileHeader.originalSizeEvenForVolumes = this.read32(dataInputStream);\n                 this.pushedBackBytes(12L);\n             }\n             this.pushedBackBytes(4L);\n         }\n     }\n     \n-    public static boolean matches(final byte[] signature, final int length) {\n-        return length >= 2 && (0xFF & signature[0]) == 0x60 && (0xFF & signature[1]) == 0xEA;\n+    public static boolean matches(final byte[] array, final int n) {\n+        return n >= 2 && (0xFF & array[0]) == 0x60 && (0xFF & array[1]) == 0xEA;\n     }\n     \n     public String getArchiveName() {\n         return this.mainHeader.name;\n     }\n     \n     public String getArchiveComment() {\n@@ -255,16 +255,16 @@\n             }\n             return new ArjArchiveEntry(this.currentLocalFileHeader);\n         }\n         this.currentInputStream = null;\n         return null;\n     }\n     \n-    public boolean canReadEntryData(final ArchiveEntry ae) {\n-        return ae instanceof ArjArchiveEntry && ((ArjArchiveEntry)ae).getMethod() == 0;\n+    public boolean canReadEntryData(final ArchiveEntry archiveEntry) {\n+        return archiveEntry instanceof ArjArchiveEntry && ((ArjArchiveEntry)archiveEntry).getMethod() == 0;\n     }\n     \n     public int read(final byte[] b, final int off, final int len) throws IOException {\n         if (this.currentLocalFileHeader == null) {\n             throw new IllegalStateException(\"No current arj entry\");\n         }\n         if (this.currentLocalFileHeader.method != 0) {\n"}]}
