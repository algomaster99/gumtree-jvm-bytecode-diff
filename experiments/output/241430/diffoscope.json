{"diffoscope-json-version": 1, "source1": "first/JSONTokener.class", "source2": "second/JSONTokener.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -16,27 +16,27 @@\n     private long index;\n     private long line;\n     private char previous;\n     private final Reader reader;\n     private boolean usePrevious;\n     private long characterPreviousLine;\n     \n-    public JSONTokener(final Reader reader) {\n-        this.reader = (reader.markSupported() ? reader : new BufferedReader(reader));\n+    public JSONTokener(final Reader in) {\n+        this.reader = (in.markSupported() ? in : new BufferedReader(in));\n         this.eof = false;\n         this.usePrevious = false;\n         this.previous = '\\0';\n         this.index = 0L;\n         this.character = 1L;\n         this.characterPreviousLine = 0L;\n         this.line = 1L;\n     }\n     \n-    public JSONTokener(final InputStream inputStream) {\n-        this(new InputStreamReader(inputStream, Charset.forName(\"UTF-8\")));\n+    public JSONTokener(final InputStream in) {\n+        this(new InputStreamReader(in, Charset.forName(\"UTF-8\")));\n     }\n     \n     public JSONTokener(final String s) {\n         this(new StringReader(s));\n     }\n     \n     public void back() throws JSONException {\n@@ -79,282 +79,282 @@\n     public boolean more() throws JSONException {\n         if (this.usePrevious) {\n             return true;\n         }\n         try {\n             this.reader.mark(1);\n         }\n-        catch (final IOException e) {\n-            throw new JSONException(\"Unable to preserve stream position\", (Throwable)e);\n+        catch (final IOException ex) {\n+            throw new JSONException(\"Unable to preserve stream position\", (Throwable)ex);\n         }\n         try {\n             if (this.reader.read() <= 0) {\n                 this.eof = true;\n                 return false;\n             }\n             this.reader.reset();\n         }\n-        catch (final IOException e) {\n-            throw new JSONException(\"Unable to read the next character from the stream\", (Throwable)e);\n+        catch (final IOException ex2) {\n+            throw new JSONException(\"Unable to read the next character from the stream\", (Throwable)ex2);\n         }\n         return true;\n     }\n     \n     public char next() throws JSONException {\n-        int c;\n+        int n;\n         if (this.usePrevious) {\n             this.usePrevious = false;\n-            c = this.previous;\n+            n = this.previous;\n         }\n         else {\n             try {\n-                c = this.reader.read();\n+                n = this.reader.read();\n             }\n-            catch (final IOException exception) {\n-                throw new JSONException((Throwable)exception);\n+            catch (final IOException ex) {\n+                throw new JSONException((Throwable)ex);\n             }\n         }\n-        if (c <= 0) {\n+        if (n <= 0) {\n             this.eof = true;\n             return '\\0';\n         }\n-        this.incrementIndexes(c);\n-        return this.previous = (char)c;\n+        this.incrementIndexes(n);\n+        return this.previous = (char)n;\n     }\n     \n     protected char getPrevious() {\n         return this.previous;\n     }\n     \n-    private void incrementIndexes(final int c) {\n-        if (c > 0) {\n+    private void incrementIndexes(final int n) {\n+        if (n > 0) {\n             ++this.index;\n-            if (c == 13) {\n+            if (n == 13) {\n                 ++this.line;\n                 this.characterPreviousLine = this.character;\n                 this.character = 0L;\n             }\n-            else if (c == 10) {\n+            else if (n == 10) {\n                 if (this.previous != '\\r') {\n                     ++this.line;\n                     this.characterPreviousLine = this.character;\n                 }\n                 this.character = 0L;\n             }\n             else {\n                 ++this.character;\n             }\n         }\n     }\n     \n     public char next(final char c) throws JSONException {\n-        final char n = this.next();\n-        if (n == c) {\n-            return n;\n+        final char next = this.next();\n+        if (next == c) {\n+            return next;\n         }\n-        if (n > '\\0') {\n-            throw this.syntaxError(\"Expected '\" + c + \"' and instead saw '\" + n + \"'\");\n+        if (next > '\\0') {\n+            throw this.syntaxError(\"Expected '\" + c + \"' and instead saw '\" + next + \"'\");\n         }\n         throw this.syntaxError(\"Expected '\" + c + \"' and instead saw ''\");\n     }\n     \n     public String next(final int n) throws JSONException {\n         if (n == 0) {\n             return \"\";\n         }\n-        final char[] chars = new char[n];\n-        for (int pos = 0; pos < n; ++pos) {\n-            chars[pos] = this.next();\n+        final char[] value = new char[n];\n+        for (int i = 0; i < n; ++i) {\n+            value[i] = this.next();\n             if (this.end()) {\n                 throw this.syntaxError(\"Substring bounds error\");\n             }\n         }\n-        return new String(chars);\n+        return new String(value);\n     }\n     \n     public char nextClean() throws JSONException {\n-        char c;\n+        char next;\n         do {\n-            c = this.next();\n-        } while (c != '\\0' && c <= ' ');\n-        return c;\n+            next = this.next();\n+        } while (next != '\\0' && next <= ' ');\n+        return next;\n     }\n     \n-    public String nextString(final char quote) throws JSONException {\n+    public String nextString(final char c) throws JSONException {\n         final StringBuilder sb = new StringBuilder();\n         while (true) {\n-            char c = this.next();\n-            switch (c) {\n-                case '\\0':\n-                case '\\n':\n-                case '\\r': {\n+            final char next = this.next();\n+            switch (next) {\n+                case 0:\n+                case 10:\n+                case 13: {\n                     throw this.syntaxError(\"Unterminated string\");\n                 }\n-                case '\\\\': {\n-                    c = this.next();\n-                    switch (c) {\n-                        case 'b': {\n+                case 92: {\n+                    final char next2 = this.next();\n+                    switch (next2) {\n+                        case 98: {\n                             sb.append('\\b');\n                             continue;\n                         }\n-                        case 't': {\n+                        case 116: {\n                             sb.append('\\t');\n                             continue;\n                         }\n-                        case 'n': {\n+                        case 110: {\n                             sb.append('\\n');\n                             continue;\n                         }\n-                        case 'f': {\n+                        case 102: {\n                             sb.append('\\f');\n                             continue;\n                         }\n-                        case 'r': {\n+                        case 114: {\n                             sb.append('\\r');\n                             continue;\n                         }\n-                        case 'u': {\n+                        case 117: {\n                             try {\n                                 sb.append((char)Integer.parseInt(this.next(4), 16));\n                                 continue;\n                             }\n-                            catch (final NumberFormatException e) {\n-                                throw this.syntaxError(\"Illegal escape.\", e);\n+                            catch (final NumberFormatException ex) {\n+                                throw this.syntaxError(\"Illegal escape.\", ex);\n                             }\n                         }\n-                        case '\\\"':\n-                        case '\\'':\n-                        case '/':\n-                        case '\\\\': {\n-                            sb.append(c);\n+                        case 34:\n+                        case 39:\n+                        case 47:\n+                        case 92: {\n+                            sb.append(next2);\n                             continue;\n                         }\n                         default: {\n                             throw this.syntaxError(\"Illegal escape.\");\n                         }\n                     }\n                     break;\n                 }\n                 default: {\n-                    if (c == quote) {\n+                    if (next == c) {\n                         return sb.toString();\n                     }\n-                    sb.append(c);\n+                    sb.append(next);\n                     continue;\n                 }\n             }\n         }\n     }\n     \n-    public String nextTo(final char delimiter) throws JSONException {\n+    public String nextTo(final char c) throws JSONException {\n         final StringBuilder sb = new StringBuilder();\n-        char c;\n+        char next;\n         while (true) {\n-            c = this.next();\n-            if (c == delimiter || c == '\\0' || c == '\\n' || c == '\\r') {\n+            next = this.next();\n+            if (next == c || next == '\\0' || next == '\\n' || next == '\\r') {\n                 break;\n             }\n-            sb.append(c);\n+            sb.append(next);\n         }\n-        if (c != '\\0') {\n+        if (next != '\\0') {\n             this.back();\n         }\n         return sb.toString().trim();\n     }\n     \n-    public String nextTo(final String delimiters) throws JSONException {\n+    public String nextTo(final String s) throws JSONException {\n         final StringBuilder sb = new StringBuilder();\n-        char c;\n+        char next;\n         while (true) {\n-            c = this.next();\n-            if (delimiters.indexOf(c) >= 0 || c == '\\0' || c == '\\n' || c == '\\r') {\n+            next = this.next();\n+            if (s.indexOf(next) >= 0 || next == '\\0' || next == '\\n' || next == '\\r') {\n                 break;\n             }\n-            sb.append(c);\n+            sb.append(next);\n         }\n-        if (c != '\\0') {\n+        if (next != '\\0') {\n             this.back();\n         }\n         return sb.toString().trim();\n     }\n     \n     public Object nextValue() throws JSONException {\n         char c = this.nextClean();\n         switch (c) {\n-            case '\\\"':\n-            case '\\'': {\n+            case 34:\n+            case 39: {\n                 return this.nextString(c);\n             }\n-            case '{': {\n+            case 123: {\n                 this.back();\n                 try {\n                     return new JSONObject(this);\n                 }\n-                catch (final StackOverflowError e) {\n-                    throw new JSONException(\"JSON Array or Object depth too large to process.\", (Throwable)e);\n+                catch (final StackOverflowError stackOverflowError) {\n+                    throw new JSONException(\"JSON Array or Object depth too large to process.\", (Throwable)stackOverflowError);\n                 }\n             }\n-            case '[': {\n+            case 91: {\n                 this.back();\n                 try {\n                     return new JSONArray(this);\n                 }\n-                catch (final StackOverflowError e) {\n-                    throw new JSONException(\"JSON Array or Object depth too large to process.\", (Throwable)e);\n+                catch (final StackOverflowError stackOverflowError2) {\n+                    throw new JSONException(\"JSON Array or Object depth too large to process.\", (Throwable)stackOverflowError2);\n                 }\n                 break;\n             }\n         }\n         final StringBuilder sb = new StringBuilder();\n         while (c >= ' ' && \",:]}/\\\\\\\"[{;=#\".indexOf(c) < 0) {\n             sb.append(c);\n             c = this.next();\n         }\n         if (!this.eof) {\n             this.back();\n         }\n-        final String string = sb.toString().trim();\n-        if (\"\".equals(string)) {\n+        final String trim = sb.toString().trim();\n+        if (\"\".equals(trim)) {\n             throw this.syntaxError(\"Missing value\");\n         }\n-        return JSONObject.stringToValue(string);\n+        return JSONObject.stringToValue(trim);\n     }\n     \n-    public char skipTo(final char to) throws JSONException {\n-        char c;\n+    public char skipTo(final char c) throws JSONException {\n+        char next;\n         try {\n-            final long startIndex = this.index;\n-            final long startCharacter = this.character;\n-            final long startLine = this.line;\n+            final long index = this.index;\n+            final long character = this.character;\n+            final long line = this.line;\n             this.reader.mark(1000000);\n             do {\n-                c = this.next();\n-                if (c == '\\0') {\n+                next = this.next();\n+                if (next == '\\0') {\n                     this.reader.reset();\n-                    this.index = startIndex;\n-                    this.character = startCharacter;\n-                    this.line = startLine;\n+                    this.index = index;\n+                    this.character = character;\n+                    this.line = line;\n                     return '\\0';\n                 }\n-            } while (c != to);\n+            } while (next != c);\n             this.reader.mark(1);\n         }\n-        catch (final IOException exception) {\n-            throw new JSONException((Throwable)exception);\n+        catch (final IOException ex) {\n+            throw new JSONException((Throwable)ex);\n         }\n         this.back();\n-        return c;\n+        return next;\n     }\n     \n-    public JSONException syntaxError(final String message) {\n-        return new JSONException(message + this.toString());\n+    public JSONException syntaxError(final String str) {\n+        return new JSONException(str + this.toString());\n     }\n     \n-    public JSONException syntaxError(final String message, final Throwable causedBy) {\n-        return new JSONException(message + this.toString(), causedBy);\n+    public JSONException syntaxError(final String str, final Throwable t) {\n+        return new JSONException(str + this.toString(), t);\n     }\n     \n     @Override\n     public String toString() {\n         return \" at \" + this.index + \" [character \" + this.character + \" line \" + this.line + \"]\";\n     }\n     \n"}]}
