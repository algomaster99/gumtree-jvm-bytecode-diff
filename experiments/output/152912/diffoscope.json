{"diffoscope-json-version": 1, "source1": "first/XmlStreamReader.class", "source2": "second/XmlStreamReader.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,31 +1,31 @@\n \n package org.apache.commons.io.input;\n \n-import java.nio.charset.StandardCharsets;\n import java.text.MessageFormat;\n import java.net.HttpURLConnection;\n import java.net.URLConnection;\n import java.net.URL;\n import java.nio.file.Files;\n import java.nio.file.OpenOption;\n import java.nio.file.Path;\n import java.io.InputStreamReader;\n import java.io.BufferedInputStream;\n+import java.util.Objects;\n import java.io.File;\n import java.util.stream.Stream;\n import org.apache.commons.io.function.IOConsumer;\n-import java.util.Objects;\n import java.io.BufferedReader;\n import java.io.StringReader;\n import java.io.IOException;\n import org.apache.commons.io.IOUtils;\n import java.io.InputStream;\n import java.util.regex.Matcher;\n import java.util.Locale;\n+import java.nio.charset.StandardCharsets;\n import java.util.regex.Pattern;\n import org.apache.commons.io.ByteOrderMark;\n import java.io.Reader;\n \n public class XmlStreamReader extends Reader\n {\n     private static final String UTF_8;\n@@ -46,14 +46,26 @@\n     private static final String HTTP_EX_1 = \"Illegal encoding, CT-MIME [{0}] CT-Enc [{1}] BOM [{2}] XML guess [{3}] XML prolog [{4}], BOM must be NULL\";\n     private static final String HTTP_EX_2 = \"Illegal encoding, CT-MIME [{0}] CT-Enc [{1}] BOM [{2}] XML guess [{3}] XML prolog [{4}], encoding mismatch\";\n     private static final String HTTP_EX_3 = \"Illegal encoding, CT-MIME [{0}] CT-Enc [{1}] BOM [{2}] XML guess [{3}] XML prolog [{4}], Illegal MIME\";\n     private final Reader reader;\n     private final String encoding;\n     private final String defaultEncoding;\n     \n+    static {\n+        UTF_8 = StandardCharsets.UTF_8.name();\n+        US_ASCII = StandardCharsets.US_ASCII.name();\n+        UTF_16BE = StandardCharsets.UTF_16BE.name();\n+        UTF_16LE = StandardCharsets.UTF_16LE.name();\n+        UTF_16 = StandardCharsets.UTF_16.name();\n+        BOMS = new ByteOrderMark[] { ByteOrderMark.UTF_8, ByteOrderMark.UTF_16BE, ByteOrderMark.UTF_16LE, ByteOrderMark.UTF_32BE, ByteOrderMark.UTF_32LE };\n+        XML_GUESS_BYTES = new ByteOrderMark[] { new ByteOrderMark(XmlStreamReader.UTF_8, new int[] { 60, 63, 120, 109 }), new ByteOrderMark(XmlStreamReader.UTF_16BE, new int[] { 0, 60, 0, 63 }), new ByteOrderMark(XmlStreamReader.UTF_16LE, new int[] { 60, 0, 63, 0 }), new ByteOrderMark(\"UTF-32BE\", new int[] { 0, 0, 0, 60, 0, 0, 0, 63, 0, 0, 0, 120, 0, 0, 0, 109 }), new ByteOrderMark(\"UTF-32LE\", new int[] { 60, 0, 0, 0, 63, 0, 0, 0, 120, 0, 0, 0, 109, 0, 0, 0 }), new ByteOrderMark(\"CP1047\", new int[] { 76, 111, 167, 148 }) };\n+        CHARSET_PATTERN = Pattern.compile(\"charset=[\\\"']?([.[^; \\\"']]*)[\\\"']?\");\n+        ENCODING_PATTERN = Pattern.compile(\"<\\\\?xml.*encoding[\\\\s]*=[\\\\s]*((?:\\\".[^\\\"]*\\\")|(?:'.[^']*'))\", 8);\n+    }\n+    \n     public static XmlStreamReader.Builder builder() {\n         return new XmlStreamReader.Builder();\n     }\n     \n     static String getContentTypeEncoding(final String httpContentType) {\n         String encoding = null;\n         if (httpContentType != null) {\n@@ -102,18 +114,15 @@\n             }\n             else {\n                 final int bytesRead = offset;\n                 if (bytesRead > 0) {\n                     inputStream.reset();\n                     final BufferedReader bReader = new BufferedReader(new StringReader(xmlProlog.substring(0, firstGT + 1)));\n                     final StringBuilder prolog = new StringBuilder();\n-                    final Stream<String> lines = bReader.lines();\n-                    final StringBuilder obj = prolog;\n-                    Objects.requireNonNull(obj);\n-                    IOConsumer.forEach((Stream)lines, obj::append);\n+                    IOConsumer.forEach((Stream)bReader.lines(), prolog::append);\n                     final Matcher m = XmlStreamReader.ENCODING_PATTERN.matcher(prolog);\n                     if (m.find()) {\n                         encoding = m.group(1).toUpperCase(Locale.ROOT);\n                         encoding = encoding.substring(1, encoding.length() - 1);\n                     }\n                 }\n             }\n@@ -364,20 +373,8 @@\n         }\n     }\n     \n     @Override\n     public int read(final char[] buf, final int offset, final int len) throws IOException {\n         return this.reader.read(buf, offset, len);\n     }\n-    \n-    static {\n-        UTF_8 = StandardCharsets.UTF_8.name();\n-        US_ASCII = StandardCharsets.US_ASCII.name();\n-        UTF_16BE = StandardCharsets.UTF_16BE.name();\n-        UTF_16LE = StandardCharsets.UTF_16LE.name();\n-        UTF_16 = StandardCharsets.UTF_16.name();\n-        BOMS = new ByteOrderMark[] { ByteOrderMark.UTF_8, ByteOrderMark.UTF_16BE, ByteOrderMark.UTF_16LE, ByteOrderMark.UTF_32BE, ByteOrderMark.UTF_32LE };\n-        XML_GUESS_BYTES = new ByteOrderMark[] { new ByteOrderMark(XmlStreamReader.UTF_8, new int[] { 60, 63, 120, 109 }), new ByteOrderMark(XmlStreamReader.UTF_16BE, new int[] { 0, 60, 0, 63 }), new ByteOrderMark(XmlStreamReader.UTF_16LE, new int[] { 60, 0, 63, 0 }), new ByteOrderMark(\"UTF-32BE\", new int[] { 0, 0, 0, 60, 0, 0, 0, 63, 0, 0, 0, 120, 0, 0, 0, 109 }), new ByteOrderMark(\"UTF-32LE\", new int[] { 60, 0, 0, 0, 63, 0, 0, 0, 120, 0, 0, 0, 109, 0, 0, 0 }), new ByteOrderMark(\"CP1047\", new int[] { 76, 111, 167, 148 }) };\n-        CHARSET_PATTERN = Pattern.compile(\"charset=[\\\"']?([.[^; \\\"']]*)[\\\"']?\");\n-        ENCODING_PATTERN = Pattern.compile(\"<\\\\?xml.*encoding[\\\\s]*=[\\\\s]*((?:\\\".[^\\\"]*\\\")|(?:'.[^']*'))\", 8);\n-    }\n }\n"}]}
