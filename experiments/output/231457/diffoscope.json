{"diffoscope-json-version": 1, "source1": "first/TarFile.class", "source2": "second/TarFile.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -39,326 +39,322 @@\n     private final ByteBuffer recordBuffer;\n     private final List<TarArchiveStructSparse> globalSparseHeaders;\n     private boolean hasHitEOF;\n     private TarArchiveEntry currEntry;\n     private Map<String, String> globalPaxHeaders;\n     private final Map<String, List<InputStream>> sparseInputStreams;\n     \n-    public TarFile(final byte[] content) throws IOException {\n-        this((SeekableByteChannel)new SeekableInMemoryByteChannel(content));\n+    public TarFile(final byte[] array) throws IOException {\n+        this((SeekableByteChannel)new SeekableInMemoryByteChannel(array));\n     }\n     \n-    public TarFile(final byte[] content, final boolean lenient) throws IOException {\n-        this(new SeekableInMemoryByteChannel(content), 10240, 512, (String)null, lenient);\n+    public TarFile(final byte[] array, final boolean b) throws IOException {\n+        this(new SeekableInMemoryByteChannel(array), 10240, 512, (String)null, b);\n     }\n     \n-    public TarFile(final byte[] content, final String encoding) throws IOException {\n-        this((SeekableByteChannel)new SeekableInMemoryByteChannel(content), 10240, 512, encoding, false);\n+    public TarFile(final byte[] array, final String s) throws IOException {\n+        this((SeekableByteChannel)new SeekableInMemoryByteChannel(array), 10240, 512, s, false);\n     }\n     \n-    public TarFile(final File archive) throws IOException {\n-        this(archive.toPath());\n+    public TarFile(final File file) throws IOException {\n+        this(file.toPath());\n     }\n     \n-    public TarFile(final File archive, final boolean lenient) throws IOException {\n-        this(archive.toPath(), lenient);\n+    public TarFile(final File file, final boolean b) throws IOException {\n+        this(file.toPath(), b);\n     }\n     \n-    public TarFile(final File archive, final String encoding) throws IOException {\n-        this(archive.toPath(), encoding);\n+    public TarFile(final File file, final String s) throws IOException {\n+        this(file.toPath(), s);\n     }\n     \n-    public TarFile(final Path archivePath) throws IOException {\n-        this(Files.newByteChannel(archivePath, new OpenOption[0]), 10240, 512, null, false);\n+    public TarFile(final Path path) throws IOException {\n+        this(Files.newByteChannel(path, new OpenOption[0]), 10240, 512, null, false);\n     }\n     \n-    public TarFile(final Path archivePath, final boolean lenient) throws IOException {\n-        this(Files.newByteChannel(archivePath, new OpenOption[0]), 10240, 512, null, lenient);\n+    public TarFile(final Path path, final boolean b) throws IOException {\n+        this(Files.newByteChannel(path, new OpenOption[0]), 10240, 512, null, b);\n     }\n     \n-    public TarFile(final Path archivePath, final String encoding) throws IOException {\n-        this(Files.newByteChannel(archivePath, new OpenOption[0]), 10240, 512, encoding, false);\n+    public TarFile(final Path path, final String s) throws IOException {\n+        this(Files.newByteChannel(path, new OpenOption[0]), 10240, 512, s, false);\n     }\n     \n-    public TarFile(final SeekableByteChannel content) throws IOException {\n-        this(content, 10240, 512, null, false);\n+    public TarFile(final SeekableByteChannel seekableByteChannel) throws IOException {\n+        this(seekableByteChannel, 10240, 512, null, false);\n     }\n     \n-    public TarFile(final SeekableByteChannel archive, final int blockSize, final int recordSize, final String encoding, final boolean lenient) throws IOException {\n+    public TarFile(final SeekableByteChannel archive, final int blockSize, final int recordSize, final String s, final boolean lenient) throws IOException {\n         this.smallBuf = new byte[256];\n         this.entries = new LinkedList<TarArchiveEntry>();\n         this.globalSparseHeaders = new ArrayList<TarArchiveStructSparse>();\n         this.globalPaxHeaders = new HashMap<String, String>();\n         this.sparseInputStreams = new HashMap<String, List<InputStream>>();\n         this.archive = archive;\n-        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+        this.zipEncoding = ZipEncodingHelper.getZipEncoding(s);\n         this.recordSize = recordSize;\n         this.recordBuffer = ByteBuffer.allocate(this.recordSize);\n         this.blockSize = blockSize;\n         this.lenient = lenient;\n-        TarArchiveEntry entry;\n-        while ((entry = this.getNextTarEntry()) != null) {\n-            this.entries.add(entry);\n+        TarArchiveEntry nextTarEntry;\n+        while ((nextTarEntry = this.getNextTarEntry()) != null) {\n+            this.entries.add(nextTarEntry);\n         }\n     }\n     \n-    private void applyPaxHeadersToCurrentEntry(final Map<String, String> headers, final List<TarArchiveStructSparse> sparseHeaders) throws IOException {\n-        this.currEntry.updateEntryFromPaxHeaders((Map)headers);\n+    private void applyPaxHeadersToCurrentEntry(final Map<String, String> map, final List<TarArchiveStructSparse> sparseHeaders) throws IOException {\n+        this.currEntry.updateEntryFromPaxHeaders((Map)map);\n         this.currEntry.setSparseHeaders((List)sparseHeaders);\n     }\n     \n     private void buildSparseInputStreams() throws IOException {\n-        final List<InputStream> streams = new ArrayList<InputStream>();\n-        final List<TarArchiveStructSparse> sparseHeaders = this.currEntry.getOrderedSparseHeaders();\n-        final InputStream zeroInputStream = (InputStream)new TarArchiveSparseZeroInputStream();\n-        long offset = 0L;\n-        long numberOfZeroBytesInSparseEntry = 0L;\n-        for (final TarArchiveStructSparse sparseHeader : sparseHeaders) {\n-            final long zeroBlockSize = sparseHeader.getOffset() - offset;\n-            if (zeroBlockSize < 0L) {\n+        final ArrayList list = new ArrayList();\n+        final List orderedSparseHeaders = this.currEntry.getOrderedSparseHeaders();\n+        final TarArchiveSparseZeroInputStream tarArchiveSparseZeroInputStream = new TarArchiveSparseZeroInputStream();\n+        long n = 0L;\n+        long n2 = 0L;\n+        for (final TarArchiveStructSparse tarArchiveStructSparse : orderedSparseHeaders) {\n+            final long n3 = tarArchiveStructSparse.getOffset() - n;\n+            if (n3 < 0L) {\n                 throw new IOException(\"Corrupted struct sparse detected\");\n             }\n-            if (zeroBlockSize > 0L) {\n-                streams.add((InputStream)new BoundedInputStream(zeroInputStream, zeroBlockSize));\n-                numberOfZeroBytesInSparseEntry += zeroBlockSize;\n-            }\n-            if (sparseHeader.getNumbytes() > 0L) {\n-                final long start = this.currEntry.getDataOffset() + sparseHeader.getOffset() - numberOfZeroBytesInSparseEntry;\n-                if (start + sparseHeader.getNumbytes() < start) {\n+            if (n3 > 0L) {\n+                list.add(new BoundedInputStream((InputStream)tarArchiveSparseZeroInputStream, n3));\n+                n2 += n3;\n+            }\n+            if (tarArchiveStructSparse.getNumbytes() > 0L) {\n+                final long n4 = this.currEntry.getDataOffset() + tarArchiveStructSparse.getOffset() - n2;\n+                if (n4 + tarArchiveStructSparse.getNumbytes() < n4) {\n                     throw new IOException(\"Unreadable TAR archive, sparse block offset or length too big\");\n                 }\n-                streams.add((InputStream)new BoundedSeekableByteChannelInputStream(start, sparseHeader.getNumbytes(), this.archive));\n+                list.add(new BoundedSeekableByteChannelInputStream(n4, tarArchiveStructSparse.getNumbytes(), this.archive));\n             }\n-            offset = sparseHeader.getOffset() + sparseHeader.getNumbytes();\n+            n = tarArchiveStructSparse.getOffset() + tarArchiveStructSparse.getNumbytes();\n         }\n-        this.sparseInputStreams.put(this.currEntry.getName(), streams);\n+        this.sparseInputStreams.put(this.currEntry.getName(), list);\n     }\n     \n     @Override\n     public void close() throws IOException {\n         this.archive.close();\n     }\n     \n     private void consumeRemainderOfLastBlock() throws IOException {\n-        final long bytesReadOfLastBlock = this.archive.position() % this.blockSize;\n-        if (bytesReadOfLastBlock > 0L) {\n-            this.repositionForwardBy((long)this.blockSize - bytesReadOfLastBlock);\n+        final long n = this.archive.position() % this.blockSize;\n+        if (n > 0L) {\n+            this.repositionForwardBy((long)this.blockSize - n);\n         }\n     }\n     \n     public List<TarArchiveEntry> getEntries() {\n         return new ArrayList<TarArchiveEntry>(this.entries);\n     }\n     \n-    public InputStream getInputStream(final TarArchiveEntry entry) throws IOException {\n+    public InputStream getInputStream(final TarArchiveEntry tarArchiveEntry) throws IOException {\n         try {\n-            return (InputStream)new TarFile.BoundedTarEntryInputStream(this, entry, this.archive);\n+            return (InputStream)new TarFile.BoundedTarEntryInputStream(this, tarArchiveEntry, this.archive);\n         }\n-        catch (final RuntimeException ex) {\n-            throw new IOException(\"Corrupted TAR archive. Can't read entry\", ex);\n+        catch (final RuntimeException cause) {\n+            throw new IOException(\"Corrupted TAR archive. Can't read entry\", cause);\n         }\n     }\n     \n     private byte[] getLongNameData() throws IOException {\n-        final ByteArrayOutputStream longName = new ByteArrayOutputStream();\n-        try (final InputStream in = this.getInputStream(this.currEntry)) {\n-            int length;\n-            while ((length = in.read(this.smallBuf)) >= 0) {\n-                longName.write(this.smallBuf, 0, length);\n+        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+        try (final InputStream inputStream = this.getInputStream(this.currEntry)) {\n+            int read;\n+            while ((read = inputStream.read(this.smallBuf)) >= 0) {\n+                byteArrayOutputStream.write(this.smallBuf, 0, read);\n             }\n         }\n         this.getNextTarEntry();\n         if (this.currEntry == null) {\n             return null;\n         }\n+        byte[] original;\n         int length;\n-        byte[] longNameData;\n-        for (longNameData = longName.toByteArray(), length = longNameData.length; length > 0 && longNameData[length - 1] == 0; --length) {}\n-        if (length != longNameData.length) {\n-            longNameData = Arrays.copyOf(longNameData, length);\n+        for (original = byteArrayOutputStream.toByteArray(), length = original.length; length > 0 && original[length - 1] == 0; --length) {}\n+        if (length != original.length) {\n+            original = Arrays.copyOf(original, length);\n         }\n-        return longNameData;\n+        return original;\n     }\n     \n     private TarArchiveEntry getNextTarEntry() throws IOException {\n         if (this.isAtEOF()) {\n             return null;\n         }\n         if (this.currEntry != null) {\n             this.repositionForwardTo(this.currEntry.getDataOffset() + this.currEntry.getSize());\n             this.throwExceptionIfPositionIsNotInArchive();\n             this.skipRecordPadding();\n         }\n-        final ByteBuffer headerBuf = this.getRecord();\n-        if (null == headerBuf) {\n+        final ByteBuffer record = this.getRecord();\n+        if (null == record) {\n             return this.currEntry = null;\n         }\n         try {\n-            final long position = this.archive.position();\n-            this.currEntry = new TarArchiveEntry((Map)this.globalPaxHeaders, headerBuf.array(), this.zipEncoding, this.lenient, position);\n+            this.currEntry = new TarArchiveEntry((Map)this.globalPaxHeaders, record.array(), this.zipEncoding, this.lenient, this.archive.position());\n         }\n-        catch (final IllegalArgumentException e) {\n-            throw new IOException(\"Error detected parsing the header\", e);\n+        catch (final IllegalArgumentException cause) {\n+            throw new IOException(\"Error detected parsing the header\", cause);\n         }\n         if (this.currEntry.isGNULongLinkEntry()) {\n-            final byte[] longLinkData = this.getLongNameData();\n-            if (longLinkData == null) {\n+            final byte[] longNameData = this.getLongNameData();\n+            if (longNameData == null) {\n                 return null;\n             }\n-            this.currEntry.setLinkName(this.zipEncoding.decode(longLinkData));\n+            this.currEntry.setLinkName(this.zipEncoding.decode(longNameData));\n         }\n         if (this.currEntry.isGNULongNameEntry()) {\n-            final byte[] longNameData = this.getLongNameData();\n-            if (longNameData == null) {\n+            final byte[] longNameData2 = this.getLongNameData();\n+            if (longNameData2 == null) {\n                 return null;\n             }\n-            final String name = this.zipEncoding.decode(longNameData);\n-            this.currEntry.setName(name);\n-            if (this.currEntry.isDirectory() && !name.endsWith(\"/\")) {\n-                this.currEntry.setName(name + \"/\");\n+            final String decode = this.zipEncoding.decode(longNameData2);\n+            this.currEntry.setName(decode);\n+            if (this.currEntry.isDirectory() && !decode.endsWith(\"/\")) {\n+                this.currEntry.setName(decode + \"/\");\n             }\n         }\n         if (this.currEntry.isGlobalPaxHeader()) {\n             this.readGlobalPaxHeaders();\n         }\n         try {\n             if (this.currEntry.isPaxHeader()) {\n                 this.paxHeaders();\n             }\n             else if (!this.globalPaxHeaders.isEmpty()) {\n                 this.applyPaxHeadersToCurrentEntry(this.globalPaxHeaders, this.globalSparseHeaders);\n             }\n         }\n-        catch (final NumberFormatException e2) {\n-            throw new IOException(\"Error detected parsing the pax header\", e2);\n+        catch (final NumberFormatException cause2) {\n+            throw new IOException(\"Error detected parsing the pax header\", cause2);\n         }\n         if (this.currEntry.isOldGNUSparse()) {\n             this.readOldGNUSparse();\n         }\n         return this.currEntry;\n     }\n     \n     private ByteBuffer getRecord() throws IOException {\n-        ByteBuffer headerBuf = this.readRecord();\n-        this.setAtEOF(this.isEOFRecord(headerBuf));\n-        if (this.isAtEOF() && headerBuf != null) {\n+        ByteBuffer record = this.readRecord();\n+        this.setAtEOF(this.isEOFRecord(record));\n+        if (this.isAtEOF() && record != null) {\n             this.tryToConsumeSecondEOFRecord();\n             this.consumeRemainderOfLastBlock();\n-            headerBuf = null;\n+            record = null;\n         }\n-        return headerBuf;\n+        return record;\n     }\n     \n     protected final boolean isAtEOF() {\n         return this.hasHitEOF;\n     }\n     \n     private boolean isDirectory() {\n         return this.currEntry != null && this.currEntry.isDirectory();\n     }\n     \n-    private boolean isEOFRecord(final ByteBuffer headerBuf) {\n-        return headerBuf == null || ArchiveUtils.isArrayZero(headerBuf.array(), this.recordSize);\n+    private boolean isEOFRecord(final ByteBuffer byteBuffer) {\n+        return byteBuffer == null || ArchiveUtils.isArrayZero(byteBuffer.array(), this.recordSize);\n     }\n     \n     private void paxHeaders() throws IOException {\n-        List<TarArchiveStructSparse> sparseHeaders = new ArrayList<TarArchiveStructSparse>();\n-        Map<String, String> headers;\n-        try (final InputStream input = this.getInputStream(this.currEntry)) {\n-            headers = TarUtils.parsePaxHeaders(input, (List)sparseHeaders, (Map)this.globalPaxHeaders, this.currEntry.getSize());\n+        ArrayList list = new ArrayList();\n+        Map paxHeaders;\n+        try (final InputStream inputStream = this.getInputStream(this.currEntry)) {\n+            paxHeaders = TarUtils.parsePaxHeaders(inputStream, (List)list, (Map)this.globalPaxHeaders, this.currEntry.getSize());\n         }\n-        if (headers.containsKey(\"GNU.sparse.map\")) {\n-            sparseHeaders = new ArrayList<TarArchiveStructSparse>(TarUtils.parseFromPAX01SparseHeaders((String)headers.get(\"GNU.sparse.map\")));\n+        if (paxHeaders.containsKey(\"GNU.sparse.map\")) {\n+            list = new ArrayList(TarUtils.parseFromPAX01SparseHeaders((String)paxHeaders.get(\"GNU.sparse.map\")));\n         }\n         this.getNextTarEntry();\n         if (this.currEntry == null) {\n             throw new IOException(\"premature end of tar archive. Didn't find any entry after PAX header.\");\n         }\n-        this.applyPaxHeadersToCurrentEntry(headers, sparseHeaders);\n+        this.applyPaxHeadersToCurrentEntry(paxHeaders, list);\n         if (this.currEntry.isPaxGNU1XSparse()) {\n-            try (final InputStream input = this.getInputStream(this.currEntry)) {\n-                sparseHeaders = TarUtils.parsePAX1XSparseHeaders(input, this.recordSize);\n+            List pax1XSparseHeaders;\n+            try (final InputStream inputStream2 = this.getInputStream(this.currEntry)) {\n+                pax1XSparseHeaders = TarUtils.parsePAX1XSparseHeaders(inputStream2, this.recordSize);\n             }\n-            this.currEntry.setSparseHeaders((List)sparseHeaders);\n+            this.currEntry.setSparseHeaders(pax1XSparseHeaders);\n             this.currEntry.setDataOffset(this.currEntry.getDataOffset() + (long)this.recordSize);\n         }\n         this.buildSparseInputStreams();\n     }\n     \n     private void readGlobalPaxHeaders() throws IOException {\n-        try (final InputStream input = this.getInputStream(this.currEntry)) {\n-            this.globalPaxHeaders = TarUtils.parsePaxHeaders(input, (List)this.globalSparseHeaders, (Map)this.globalPaxHeaders, this.currEntry.getSize());\n+        try (final InputStream inputStream = this.getInputStream(this.currEntry)) {\n+            this.globalPaxHeaders = TarUtils.parsePaxHeaders(inputStream, (List)this.globalSparseHeaders, (Map)this.globalPaxHeaders, this.currEntry.getSize());\n         }\n         this.getNextTarEntry();\n         if (this.currEntry == null) {\n             throw new IOException(\"Error detected parsing the pax header\");\n         }\n     }\n     \n     private void readOldGNUSparse() throws IOException {\n         if (this.currEntry.isExtended()) {\n-            TarArchiveSparseEntry entry;\n+            TarArchiveSparseEntry tarArchiveSparseEntry;\n             do {\n-                final ByteBuffer headerBuf = this.getRecord();\n-                if (headerBuf == null) {\n+                final ByteBuffer record = this.getRecord();\n+                if (record == null) {\n                     throw new IOException(\"premature end of tar archive. Didn't find extended_header after header with extended flag.\");\n                 }\n-                entry = new TarArchiveSparseEntry(headerBuf.array());\n-                this.currEntry.getSparseHeaders().addAll(entry.getSparseHeaders());\n+                tarArchiveSparseEntry = new TarArchiveSparseEntry(record.array());\n+                this.currEntry.getSparseHeaders().addAll(tarArchiveSparseEntry.getSparseHeaders());\n                 this.currEntry.setDataOffset(this.currEntry.getDataOffset() + (long)this.recordSize);\n-            } while (entry.isExtended());\n+            } while (tarArchiveSparseEntry.isExtended());\n         }\n         this.buildSparseInputStreams();\n     }\n     \n     private ByteBuffer readRecord() throws IOException {\n         this.recordBuffer.rewind();\n-        final int readNow = this.archive.read(this.recordBuffer);\n-        if (readNow != this.recordSize) {\n+        if (this.archive.read(this.recordBuffer) != this.recordSize) {\n             return null;\n         }\n         return this.recordBuffer;\n     }\n     \n-    private void repositionForwardBy(final long offset) throws IOException {\n-        this.repositionForwardTo(this.archive.position() + offset);\n+    private void repositionForwardBy(final long n) throws IOException {\n+        this.repositionForwardTo(this.archive.position() + n);\n     }\n     \n-    private void repositionForwardTo(final long newPosition) throws IOException {\n-        final long currPosition = this.archive.position();\n-        if (newPosition < currPosition) {\n+    private void repositionForwardTo(final long n) throws IOException {\n+        if (n < this.archive.position()) {\n             throw new IOException(\"trying to move backwards inside of the archive\");\n         }\n-        this.archive.position(newPosition);\n+        this.archive.position(n);\n     }\n     \n-    protected final void setAtEOF(final boolean b) {\n-        this.hasHitEOF = b;\n+    protected final void setAtEOF(final boolean hasHitEOF) {\n+        this.hasHitEOF = hasHitEOF;\n     }\n     \n     private void skipRecordPadding() throws IOException {\n         if (!this.isDirectory() && this.currEntry.getSize() > 0L && this.currEntry.getSize() % this.recordSize != 0L) {\n-            final long numRecords = this.currEntry.getSize() / this.recordSize + 1L;\n-            final long padding = numRecords * this.recordSize - this.currEntry.getSize();\n-            this.repositionForwardBy(padding);\n+            this.repositionForwardBy((this.currEntry.getSize() / this.recordSize + 1L) * this.recordSize - this.currEntry.getSize());\n             this.throwExceptionIfPositionIsNotInArchive();\n         }\n     }\n     \n     private void throwExceptionIfPositionIsNotInArchive() throws IOException {\n         if (this.archive.size() < this.archive.position()) {\n             throw new IOException(\"Truncated TAR archive\");\n         }\n     }\n     \n     private void tryToConsumeSecondEOFRecord() throws IOException {\n-        boolean shouldReset = true;\n+        int n = 1;\n         try {\n-            shouldReset = !this.isEOFRecord(this.readRecord());\n+            n = (this.isEOFRecord(this.readRecord()) ? 0 : 1);\n         }\n         finally {\n-            if (shouldReset) {\n+            if (n != 0) {\n                 this.archive.position(this.archive.position() - (long)this.recordSize);\n             }\n         }\n     }\n }\n"}]}
