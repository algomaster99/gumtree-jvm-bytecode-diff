{"diffoscope-json-version": 1, "source1": "first/BaseNCodec.class", "source2": "second/BaseNCodec.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -25,215 +25,213 @@\n     protected final byte pad;\n     private final int unencodedBlockSize;\n     private final int encodedBlockSize;\n     protected final int lineLength;\n     private final int chunkSeparatorLength;\n     private final CodecPolicy decodingPolicy;\n     \n-    private static int compareUnsigned(final int x, final int y) {\n-        return Integer.compare(x + Integer.MIN_VALUE, y + Integer.MIN_VALUE);\n+    private static int compareUnsigned(final int n, final int n2) {\n+        return Integer.compare(n + Integer.MIN_VALUE, n2 + Integer.MIN_VALUE);\n     }\n     \n-    private static int createPositiveCapacity(final int minCapacity) {\n-        if (minCapacity < 0) {\n-            throw new OutOfMemoryError(\"Unable to allocate array size: \" + ((long)minCapacity & 0xFFFFFFFFL));\n+    private static int createPositiveCapacity(final int n) {\n+        if (n < 0) {\n+            throw new OutOfMemoryError(\"Unable to allocate array size: \" + ((long)n & 0xFFFFFFFFL));\n         }\n-        return (minCapacity > 2147483639) ? minCapacity : 2147483639;\n+        return (n > 2147483639) ? n : 2147483639;\n     }\n     \n     public static byte[] getChunkSeparator() {\n         return BaseNCodec.CHUNK_SEPARATOR.clone();\n     }\n     \n-    protected static boolean isWhiteSpace(final byte byteToCheck) {\n-        switch (byteToCheck) {\n+    protected static boolean isWhiteSpace(final byte b) {\n+        switch (b) {\n             case 9:\n             case 10:\n             case 13:\n             case 32: {\n                 return true;\n             }\n             default: {\n                 return false;\n             }\n         }\n     }\n     \n-    private static byte[] resizeBuffer(final BaseNCodec.Context context, final int minCapacity) {\n-        final int oldCapacity = context.buffer.length;\n-        int newCapacity = oldCapacity * 2;\n-        if (compareUnsigned(newCapacity, minCapacity) < 0) {\n-            newCapacity = minCapacity;\n+    private static byte[] resizeBuffer(final BaseNCodec.Context context, final int n) {\n+        int positiveCapacity = context.buffer.length * 2;\n+        if (compareUnsigned(positiveCapacity, n) < 0) {\n+            positiveCapacity = n;\n         }\n-        if (compareUnsigned(newCapacity, 2147483639) > 0) {\n-            newCapacity = createPositiveCapacity(minCapacity);\n+        if (compareUnsigned(positiveCapacity, 2147483639) > 0) {\n+            positiveCapacity = createPositiveCapacity(n);\n         }\n-        final byte[] b = new byte[newCapacity];\n-        System.arraycopy(context.buffer, 0, b, 0, context.buffer.length);\n-        return context.buffer = b;\n+        final byte[] buffer = new byte[positiveCapacity];\n+        System.arraycopy(context.buffer, 0, buffer, 0, context.buffer.length);\n+        return context.buffer = buffer;\n     }\n     \n-    protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize, final int lineLength, final int chunkSeparatorLength) {\n-        this(unencodedBlockSize, encodedBlockSize, lineLength, chunkSeparatorLength, (byte)61);\n+    protected BaseNCodec(final int n, final int n2, final int n3, final int n4) {\n+        this(n, n2, n3, n4, (byte)61);\n     }\n     \n-    protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize, final int lineLength, final int chunkSeparatorLength, final byte pad) {\n-        this(unencodedBlockSize, encodedBlockSize, lineLength, chunkSeparatorLength, pad, BaseNCodec.DECODING_POLICY_DEFAULT);\n+    protected BaseNCodec(final int n, final int n2, final int n3, final int n4, final byte b) {\n+        this(n, n2, n3, n4, b, BaseNCodec.DECODING_POLICY_DEFAULT);\n     }\n     \n-    protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize, final int lineLength, final int chunkSeparatorLength, final byte pad, final CodecPolicy decodingPolicy) {\n+    protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize, final int n, final int chunkSeparatorLength, final byte pad, final CodecPolicy obj) {\n         this.unencodedBlockSize = unencodedBlockSize;\n         this.encodedBlockSize = encodedBlockSize;\n-        final boolean useChunking = lineLength > 0 && chunkSeparatorLength > 0;\n-        this.lineLength = (useChunking ? (lineLength / encodedBlockSize * encodedBlockSize) : 0);\n+        this.lineLength = ((n > 0 && chunkSeparatorLength > 0) ? (n / encodedBlockSize * encodedBlockSize) : 0);\n         this.chunkSeparatorLength = chunkSeparatorLength;\n         this.pad = pad;\n-        this.decodingPolicy = Objects.requireNonNull(decodingPolicy, \"codecPolicy\");\n+        this.decodingPolicy = Objects.requireNonNull(obj, \"codecPolicy\");\n     }\n     \n     int available(final BaseNCodec.Context context) {\n         return (context.buffer != null) ? (context.pos - context.readPos) : 0;\n     }\n     \n-    protected boolean containsAlphabetOrPad(final byte[] arrayOctet) {\n-        if (arrayOctet == null) {\n+    protected boolean containsAlphabetOrPad(final byte[] array) {\n+        if (array == null) {\n             return false;\n         }\n-        for (final byte element : arrayOctet) {\n-            if (this.pad == element || this.isInAlphabet(element)) {\n+        for (final byte b : array) {\n+            if (this.pad == b || this.isInAlphabet(b)) {\n                 return true;\n             }\n         }\n         return false;\n     }\n     \n-    public byte[] decode(final byte[] pArray) {\n-        if (pArray == null || pArray.length == 0) {\n-            return pArray;\n+    public byte[] decode(final byte[] array) {\n+        if (array == null || array.length == 0) {\n+            return array;\n         }\n         final BaseNCodec.Context context = new BaseNCodec.Context();\n-        this.decode(pArray, 0, pArray.length, context);\n-        this.decode(pArray, 0, -1, context);\n-        final byte[] result = new byte[context.pos];\n-        this.readResults(result, 0, result.length, context);\n-        return result;\n+        this.decode(array, 0, array.length, context);\n+        this.decode(array, 0, -1, context);\n+        final byte[] array2 = new byte[context.pos];\n+        this.readResults(array2, 0, array2.length, context);\n+        return array2;\n     }\n     \n     abstract void decode(final byte[] p0, final int p1, final int p2, final BaseNCodec.Context p3);\n     \n-    public Object decode(final Object obj) throws DecoderException {\n-        if (obj instanceof byte[]) {\n-            return this.decode((byte[])obj);\n+    public Object decode(final Object o) throws DecoderException {\n+        if (o instanceof byte[]) {\n+            return this.decode((byte[])o);\n         }\n-        if (obj instanceof String) {\n-            return this.decode((String)obj);\n+        if (o instanceof String) {\n+            return this.decode((String)o);\n         }\n         throw new DecoderException(\"Parameter supplied to Base-N decode is not a byte[] or a String\");\n     }\n     \n-    public byte[] decode(final String pArray) {\n-        return this.decode(StringUtils.getBytesUtf8(pArray));\n+    public byte[] decode(final String s) {\n+        return this.decode(StringUtils.getBytesUtf8(s));\n     }\n     \n-    public byte[] encode(final byte[] pArray) {\n-        if (pArray == null || pArray.length == 0) {\n-            return pArray;\n+    public byte[] encode(final byte[] array) {\n+        if (array == null || array.length == 0) {\n+            return array;\n         }\n-        return this.encode(pArray, 0, pArray.length);\n+        return this.encode(array, 0, array.length);\n     }\n     \n-    public byte[] encode(final byte[] pArray, final int offset, final int length) {\n-        if (pArray == null || pArray.length == 0) {\n-            return pArray;\n+    public byte[] encode(final byte[] array, final int n, final int n2) {\n+        if (array == null || array.length == 0) {\n+            return array;\n         }\n         final BaseNCodec.Context context = new BaseNCodec.Context();\n-        this.encode(pArray, offset, length, context);\n-        this.encode(pArray, offset, -1, context);\n-        final byte[] buf = new byte[context.pos - context.readPos];\n-        this.readResults(buf, 0, buf.length, context);\n-        return buf;\n+        this.encode(array, n, n2, context);\n+        this.encode(array, n, -1, context);\n+        final byte[] array2 = new byte[context.pos - context.readPos];\n+        this.readResults(array2, 0, array2.length, context);\n+        return array2;\n     }\n     \n     abstract void encode(final byte[] p0, final int p1, final int p2, final BaseNCodec.Context p3);\n     \n-    public Object encode(final Object obj) throws EncoderException {\n-        if (!(obj instanceof byte[])) {\n+    public Object encode(final Object o) throws EncoderException {\n+        if (!(o instanceof byte[])) {\n             throw new EncoderException(\"Parameter supplied to Base-N encode is not a byte[]\");\n         }\n-        return this.encode((byte[])obj);\n+        return this.encode((byte[])o);\n     }\n     \n-    public String encodeAsString(final byte[] pArray) {\n-        return StringUtils.newStringUtf8(this.encode(pArray));\n+    public String encodeAsString(final byte[] array) {\n+        return StringUtils.newStringUtf8(this.encode(array));\n     }\n     \n-    public String encodeToString(final byte[] pArray) {\n-        return StringUtils.newStringUtf8(this.encode(pArray));\n+    public String encodeToString(final byte[] array) {\n+        return StringUtils.newStringUtf8(this.encode(array));\n     }\n     \n-    protected byte[] ensureBufferSize(final int size, final BaseNCodec.Context context) {\n+    protected byte[] ensureBufferSize(final int a, final BaseNCodec.Context context) {\n         if (context.buffer == null) {\n-            context.buffer = new byte[Math.max(size, this.getDefaultBufferSize())];\n+            context.buffer = new byte[Math.max(a, this.getDefaultBufferSize())];\n             context.pos = 0;\n             context.readPos = 0;\n         }\n-        else if (context.pos + size - context.buffer.length > 0) {\n-            return resizeBuffer(context, context.pos + size);\n+        else if (context.pos + a - context.buffer.length > 0) {\n+            return resizeBuffer(context, context.pos + a);\n         }\n         return context.buffer;\n     }\n     \n     public CodecPolicy getCodecPolicy() {\n         return this.decodingPolicy;\n     }\n     \n     protected int getDefaultBufferSize() {\n         return 8192;\n     }\n     \n-    public long getEncodedLength(final byte[] pArray) {\n-        long len = (pArray.length + this.unencodedBlockSize - 1) / this.unencodedBlockSize * (long)this.encodedBlockSize;\n+    public long getEncodedLength(final byte[] array) {\n+        long n = (array.length + this.unencodedBlockSize - 1) / this.unencodedBlockSize * (long)this.encodedBlockSize;\n         if (this.lineLength > 0) {\n-            len += (len + this.lineLength - 1L) / this.lineLength * this.chunkSeparatorLength;\n+            n += (n + this.lineLength - 1L) / this.lineLength * this.chunkSeparatorLength;\n         }\n-        return len;\n+        return n;\n     }\n     \n     boolean hasData(final BaseNCodec.Context context) {\n         return context.buffer != null;\n     }\n     \n     protected abstract boolean isInAlphabet(final byte p0);\n     \n-    public boolean isInAlphabet(final byte[] arrayOctet, final boolean allowWSPad) {\n-        for (final byte octet : arrayOctet) {\n-            if (!this.isInAlphabet(octet) && (!allowWSPad || (octet != this.pad && !isWhiteSpace(octet)))) {\n+    public boolean isInAlphabet(final byte[] array, final boolean b) {\n+        for (final byte b2 : array) {\n+            if (!this.isInAlphabet(b2) && (!b || (b2 != this.pad && !isWhiteSpace(b2)))) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    public boolean isInAlphabet(final String basen) {\n-        return this.isInAlphabet(StringUtils.getBytesUtf8(basen), true);\n+    public boolean isInAlphabet(final String s) {\n+        return this.isInAlphabet(StringUtils.getBytesUtf8(s), true);\n     }\n     \n     public boolean isStrictDecoding() {\n         return this.decodingPolicy == CodecPolicy.STRICT;\n     }\n     \n-    int readResults(final byte[] b, final int bPos, final int bAvail, final BaseNCodec.Context context) {\n+    int readResults(final byte[] array, final int n, final int b, final BaseNCodec.Context context) {\n         if (context.buffer != null) {\n-            final int len = Math.min(this.available(context), bAvail);\n-            System.arraycopy(context.buffer, context.readPos, b, bPos, len);\n-            context.readPos += len;\n+            final int min = Math.min(this.available(context), b);\n+            System.arraycopy(context.buffer, context.readPos, array, n, min);\n+            context.readPos += min;\n             if (context.readPos >= context.pos) {\n                 context.buffer = null;\n             }\n-            return len;\n+            return min;\n         }\n         return context.eof ? -1 : 0;\n     }\n     \n     static {\n         DECODING_POLICY_DEFAULT = CodecPolicy.LENIENT;\n         CHUNK_SEPARATOR = new byte[] { 13, 10 };\n"}]}
