{"diffoscope-json-version": 1, "source1": "first/ExceptionUtils.class", "source2": "second/ExceptionUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -20,324 +20,312 @@\n public class ExceptionUtils\n {\n     private static final int NOT_FOUND = -1;\n     private static final String[] CAUSE_METHOD_NAMES;\n     static final String WRAPPED_MARKER = \" [wrapped] \";\n     \n     @Deprecated\n-    public static Throwable getCause(final Throwable throwable) {\n-        return getCause(throwable, null);\n+    public static Throwable getCause(final Throwable t) {\n+        return getCause(t, null);\n     }\n     \n     @Deprecated\n-    public static Throwable getCause(final Throwable throwable, String[] methodNames) {\n-        if (throwable == null) {\n+    public static Throwable getCause(final Throwable t, String[] cause_METHOD_NAMES) {\n+        if (t == null) {\n             return null;\n         }\n-        if (methodNames == null) {\n-            final Throwable cause = throwable.getCause();\n+        if (cause_METHOD_NAMES == null) {\n+            final Throwable cause = t.getCause();\n             if (cause != null) {\n                 return cause;\n             }\n-            methodNames = ExceptionUtils.CAUSE_METHOD_NAMES;\n+            cause_METHOD_NAMES = ExceptionUtils.CAUSE_METHOD_NAMES;\n         }\n-        for (final String methodName : methodNames) {\n-            if (methodName != null) {\n-                final Throwable legacyCause = getCauseUsingMethodName(throwable, methodName);\n-                if (legacyCause != null) {\n-                    return legacyCause;\n+        for (final String s : cause_METHOD_NAMES) {\n+            if (s != null) {\n+                final Throwable causeUsingMethodName = getCauseUsingMethodName(t, s);\n+                if (causeUsingMethodName != null) {\n+                    return causeUsingMethodName;\n                 }\n             }\n         }\n         return null;\n     }\n     \n-    private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName) {\n+    private static Throwable getCauseUsingMethodName(final Throwable obj, final String name) {\n         Method method = null;\n         try {\n-            method = throwable.getClass().getMethod(methodName, (Class<?>[])new Class[0]);\n+            method = obj.getClass().getMethod(name, (Class<?>[])new Class[0]);\n         }\n         catch (final NoSuchMethodException | SecurityException ex) {}\n         if (method != null && Throwable.class.isAssignableFrom(method.getReturnType())) {\n             try {\n-                return (Throwable)method.invoke(throwable, new Object[0]);\n+                return (Throwable)method.invoke(obj, new Object[0]);\n             }\n             catch (final IllegalAccessException | IllegalArgumentException | InvocationTargetException ex2) {}\n         }\n         return null;\n     }\n     \n     @Deprecated\n     public static String[] getDefaultCauseMethodNames() {\n         return (String[])ArrayUtils.clone((Object[])ExceptionUtils.CAUSE_METHOD_NAMES);\n     }\n     \n-    public static String getMessage(final Throwable th) {\n-        if (th == null) {\n+    public static String getMessage(final Throwable t) {\n+        if (t == null) {\n             return \"\";\n         }\n-        final String clsName = ClassUtils.getShortClassName((Object)th, (String)null);\n-        final String msg = th.getMessage();\n-        return clsName + \": \" + StringUtils.defaultString(msg);\n+        return ClassUtils.getShortClassName((Object)t, (String)null) + \": \" + StringUtils.defaultString(t.getMessage());\n     }\n     \n-    public static Throwable getRootCause(final Throwable throwable) {\n-        final List<Throwable> list = getThrowableList(throwable);\n-        return list.isEmpty() ? null : ((Throwable)list.get(list.size() - 1));\n+    public static Throwable getRootCause(final Throwable t) {\n+        final List<Throwable> throwableList = getThrowableList(t);\n+        return throwableList.isEmpty() ? null : ((Throwable)throwableList.get(throwableList.size() - 1));\n     }\n     \n-    public static String getRootCauseMessage(final Throwable th) {\n-        Throwable root = getRootCause(th);\n-        root = ((root == null) ? th : root);\n-        return getMessage(root);\n+    public static String getRootCauseMessage(final Throwable t) {\n+        final Throwable rootCause = getRootCause(t);\n+        return getMessage((rootCause == null) ? t : rootCause);\n     }\n     \n-    public static String[] getRootCauseStackTrace(final Throwable throwable) {\n-        if (throwable == null) {\n+    public static String[] getRootCauseStackTrace(final Throwable t) {\n+        if (t == null) {\n             return ArrayUtils.EMPTY_STRING_ARRAY;\n         }\n-        final Throwable[] throwables = getThrowables(throwable);\n-        final int count = throwables.length;\n-        final List<String> frames = new ArrayList<String>();\n-        List<String> nextTrace = getStackFrameList(throwables[count - 1]);\n-        int i = count;\n-        while (--i >= 0) {\n-            final List<String> trace = nextTrace;\n-            if (i != 0) {\n-                nextTrace = getStackFrameList(throwables[i - 1]);\n-                removeCommonFrames(trace, nextTrace);\n+        final Throwable[] throwables = getThrowables(t);\n+        final int length = throwables.length;\n+        final ArrayList list = new ArrayList();\n+        List<String> list2 = getStackFrameList(throwables[length - 1]);\n+        int n = length;\n+        while (--n >= 0) {\n+            final List<String> list3 = list2;\n+            if (n != 0) {\n+                list2 = getStackFrameList(throwables[n - 1]);\n+                removeCommonFrames(list3, list2);\n             }\n-            if (i == count - 1) {\n-                frames.add(throwables[i].toString());\n+            if (n == length - 1) {\n+                list.add(throwables[n].toString());\n             }\n             else {\n-                frames.add(\" [wrapped] \" + throwables[i].toString());\n+                list.add(\" [wrapped] \" + throwables[n].toString());\n             }\n-            frames.addAll(trace);\n+            list.addAll(list3);\n         }\n-        return frames.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n+        return (String[])list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n     }\n     \n     static List<String> getStackFrameList(final Throwable t) {\n-        final String stackTrace = getStackTrace(t);\n-        final String linebreak = System.lineSeparator();\n-        final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n-        final List<String> list = new ArrayList<String>();\n-        boolean traceStarted = false;\n-        while (frames.hasMoreTokens()) {\n-            final String token = frames.nextToken();\n-            final int at = token.indexOf(\"at\");\n-            if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n-                traceStarted = true;\n-                list.add(token);\n+        final StringTokenizer stringTokenizer = new StringTokenizer(getStackTrace(t), System.lineSeparator());\n+        final ArrayList list = new ArrayList();\n+        boolean b = false;\n+        while (stringTokenizer.hasMoreTokens()) {\n+            final String nextToken = stringTokenizer.nextToken();\n+            final int index = nextToken.indexOf(\"at\");\n+            if (index != -1 && nextToken.substring(0, index).trim().isEmpty()) {\n+                b = true;\n+                list.add(nextToken);\n             }\n             else {\n-                if (traceStarted) {\n+                if (b) {\n                     break;\n                 }\n                 continue;\n             }\n         }\n         return list;\n     }\n     \n-    static String[] getStackFrames(final String stackTrace) {\n-        final String linebreak = System.lineSeparator();\n-        final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n-        final List<String> list = new ArrayList<String>();\n-        while (frames.hasMoreTokens()) {\n-            list.add(frames.nextToken());\n+    static String[] getStackFrames(final String str) {\n+        final StringTokenizer stringTokenizer = new StringTokenizer(str, System.lineSeparator());\n+        final ArrayList list = new ArrayList();\n+        while (stringTokenizer.hasMoreTokens()) {\n+            list.add(stringTokenizer.nextToken());\n         }\n-        return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n+        return (String[])list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n     }\n     \n-    public static String[] getStackFrames(final Throwable throwable) {\n-        if (throwable == null) {\n+    public static String[] getStackFrames(final Throwable t) {\n+        if (t == null) {\n             return ArrayUtils.EMPTY_STRING_ARRAY;\n         }\n-        return getStackFrames(getStackTrace(throwable));\n+        return getStackFrames(getStackTrace(t));\n     }\n     \n-    public static String getStackTrace(final Throwable throwable) {\n-        final StringWriter sw = new StringWriter();\n-        final PrintWriter pw = new PrintWriter(sw, true);\n-        throwable.printStackTrace(pw);\n-        return sw.getBuffer().toString();\n+    public static String getStackTrace(final Throwable t) {\n+        final StringWriter out = new StringWriter();\n+        t.printStackTrace(new PrintWriter((Writer)out, true));\n+        return out.getBuffer().toString();\n     }\n     \n-    public static int getThrowableCount(final Throwable throwable) {\n-        return getThrowableList(throwable).size();\n+    public static int getThrowableCount(final Throwable t) {\n+        return getThrowableList(t).size();\n     }\n     \n-    public static List<Throwable> getThrowableList(Throwable throwable) {\n-        List<Throwable> list;\n-        for (list = new ArrayList<Throwable>(); throwable != null && !list.contains(throwable); throwable = throwable.getCause()) {\n-            list.add(throwable);\n+    public static List<Throwable> getThrowableList(Throwable cause) {\n+        ArrayList list;\n+        for (list = new ArrayList(); cause != null && !list.contains(cause); cause = cause.getCause()) {\n+            list.add(cause);\n         }\n         return list;\n     }\n     \n-    public static Throwable[] getThrowables(final Throwable throwable) {\n-        final List<Throwable> list = getThrowableList(throwable);\n-        return list.toArray(ArrayUtils.EMPTY_THROWABLE_ARRAY);\n+    public static Throwable[] getThrowables(final Throwable t) {\n+        return getThrowableList(t).toArray(ArrayUtils.EMPTY_THROWABLE_ARRAY);\n     }\n     \n-    public static boolean hasCause(Throwable chain, final Class<? extends Throwable> type) {\n-        if (chain instanceof UndeclaredThrowableException) {\n-            chain = chain.getCause();\n+    public static boolean hasCause(Throwable cause, final Class<? extends Throwable> clazz) {\n+        if (cause instanceof UndeclaredThrowableException) {\n+            cause = cause.getCause();\n         }\n-        return type.isInstance(chain);\n+        return clazz.isInstance(cause);\n     }\n     \n-    private static int indexOf(final Throwable throwable, final Class<? extends Throwable> type, int fromIndex, final boolean subclass) {\n-        if (throwable == null || type == null) {\n+    private static int indexOf(final Throwable t, final Class<? extends Throwable> clazz, int n, final boolean b) {\n+        if (t == null || clazz == null) {\n             return -1;\n         }\n-        if (fromIndex < 0) {\n-            fromIndex = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        final Throwable[] throwables = getThrowables(throwable);\n-        if (fromIndex >= throwables.length) {\n+        final Throwable[] throwables = getThrowables(t);\n+        if (n >= throwables.length) {\n             return -1;\n         }\n-        if (subclass) {\n-            for (int i = fromIndex; i < throwables.length; ++i) {\n-                if (type.isAssignableFrom(throwables[i].getClass())) {\n+        if (b) {\n+            for (int i = n; i < throwables.length; ++i) {\n+                if (clazz.isAssignableFrom(throwables[i].getClass())) {\n                     return i;\n                 }\n             }\n         }\n         else {\n-            for (int i = fromIndex; i < throwables.length; ++i) {\n-                if (type.equals(throwables[i].getClass())) {\n-                    return i;\n+            for (int j = n; j < throwables.length; ++j) {\n+                if (clazz.equals(throwables[j].getClass())) {\n+                    return j;\n                 }\n             }\n         }\n         return -1;\n     }\n     \n-    public static int indexOfThrowable(final Throwable throwable, final Class<? extends Throwable> clazz) {\n-        return indexOf(throwable, clazz, 0, false);\n+    public static int indexOfThrowable(final Throwable t, final Class<? extends Throwable> clazz) {\n+        return indexOf(t, clazz, 0, false);\n     }\n     \n-    public static int indexOfThrowable(final Throwable throwable, final Class<? extends Throwable> clazz, final int fromIndex) {\n-        return indexOf(throwable, clazz, fromIndex, false);\n+    public static int indexOfThrowable(final Throwable t, final Class<? extends Throwable> clazz, final int n) {\n+        return indexOf(t, clazz, n, false);\n     }\n     \n-    public static int indexOfType(final Throwable throwable, final Class<? extends Throwable> type) {\n-        return indexOf(throwable, type, 0, true);\n+    public static int indexOfType(final Throwable t, final Class<? extends Throwable> clazz) {\n+        return indexOf(t, clazz, 0, true);\n     }\n     \n-    public static int indexOfType(final Throwable throwable, final Class<? extends Throwable> type, final int fromIndex) {\n-        return indexOf(throwable, type, fromIndex, true);\n+    public static int indexOfType(final Throwable t, final Class<? extends Throwable> clazz, final int n) {\n+        return indexOf(t, clazz, n, true);\n     }\n     \n-    public static void printRootCauseStackTrace(final Throwable throwable) {\n-        printRootCauseStackTrace(throwable, System.err);\n+    public static void printRootCauseStackTrace(final Throwable t) {\n+        printRootCauseStackTrace(t, System.err);\n     }\n     \n-    public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream printStream) {\n-        if (throwable == null) {\n+    public static void printRootCauseStackTrace(final Throwable t, final PrintStream obj) {\n+        if (t == null) {\n             return;\n         }\n-        Objects.requireNonNull(printStream, \"printStream\");\n-        final String[] rootCauseStackTrace;\n-        final String[] trace = rootCauseStackTrace = getRootCauseStackTrace(throwable);\n-        for (final String element : rootCauseStackTrace) {\n-            printStream.println(element);\n+        Objects.requireNonNull(obj, \"printStream\");\n+        final String[] rootCauseStackTrace = getRootCauseStackTrace(t);\n+        for (int length = rootCauseStackTrace.length, i = 0; i < length; ++i) {\n+            obj.println(rootCauseStackTrace[i]);\n         }\n-        printStream.flush();\n+        obj.flush();\n     }\n     \n-    public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter printWriter) {\n-        if (throwable == null) {\n+    public static void printRootCauseStackTrace(final Throwable t, final PrintWriter obj) {\n+        if (t == null) {\n             return;\n         }\n-        Objects.requireNonNull(printWriter, \"printWriter\");\n-        final String[] rootCauseStackTrace;\n-        final String[] trace = rootCauseStackTrace = getRootCauseStackTrace(throwable);\n-        for (final String element : rootCauseStackTrace) {\n-            printWriter.println(element);\n+        Objects.requireNonNull(obj, \"printWriter\");\n+        final String[] rootCauseStackTrace = getRootCauseStackTrace(t);\n+        for (int length = rootCauseStackTrace.length, i = 0; i < length; ++i) {\n+            obj.println(rootCauseStackTrace[i]);\n         }\n-        printWriter.flush();\n+        obj.flush();\n     }\n     \n-    public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames) {\n-        if (causeFrames == null || wrapperFrames == null) {\n+    public static void removeCommonFrames(final List<String> list, final List<String> list2) {\n+        if (list == null || list2 == null) {\n             throw new IllegalArgumentException(\"The List must not be null\");\n         }\n-        for (int causeFrameIndex = causeFrames.size() - 1, wrapperFrameIndex = wrapperFrames.size() - 1; causeFrameIndex >= 0 && wrapperFrameIndex >= 0; --causeFrameIndex, --wrapperFrameIndex) {\n-            final String causeFrame = (String)causeFrames.get(causeFrameIndex);\n-            final String wrapperFrame = (String)wrapperFrames.get(wrapperFrameIndex);\n-            if (causeFrame.equals(wrapperFrame)) {\n-                causeFrames.remove(causeFrameIndex);\n+        for (int n = list.size() - 1, n2 = list2.size() - 1; n >= 0 && n2 >= 0; --n, --n2) {\n+            if (((String)list.get(n)).equals(list2.get(n2))) {\n+                list.remove(n);\n             }\n         }\n     }\n     \n-    public static <R> R rethrow(final Throwable throwable) {\n-        return (R)typeErasure(throwable);\n+    public static <R> R rethrow(final Throwable t) {\n+        return (R)typeErasure(t);\n     }\n     \n-    private static <T extends Throwable> T throwableOf(final Throwable throwable, final Class<T> type, int fromIndex, final boolean subclass) {\n-        if (throwable == null || type == null) {\n+    private static <T extends Throwable> T throwableOf(final Throwable t, final Class<T> clazz, int n, final boolean b) {\n+        if (t == null || clazz == null) {\n             return null;\n         }\n-        if (fromIndex < 0) {\n-            fromIndex = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        final Throwable[] throwables = getThrowables(throwable);\n-        if (fromIndex >= throwables.length) {\n+        final Throwable[] throwables = getThrowables(t);\n+        if (n >= throwables.length) {\n             return null;\n         }\n-        if (subclass) {\n-            for (int i = fromIndex; i < throwables.length; ++i) {\n-                if (type.isAssignableFrom(throwables[i].getClass())) {\n-                    return type.cast(throwables[i]);\n+        if (b) {\n+            for (int i = n; i < throwables.length; ++i) {\n+                if (clazz.isAssignableFrom(throwables[i].getClass())) {\n+                    return (T)clazz.cast(throwables[i]);\n                 }\n             }\n         }\n         else {\n-            for (int i = fromIndex; i < throwables.length; ++i) {\n-                if (type.equals(throwables[i].getClass())) {\n-                    return type.cast(throwables[i]);\n+            for (int j = n; j < throwables.length; ++j) {\n+                if (clazz.equals(throwables[j].getClass())) {\n+                    return (T)clazz.cast(throwables[j]);\n                 }\n             }\n         }\n         return null;\n     }\n     \n-    public static <T extends Throwable> T throwableOfThrowable(final Throwable throwable, final Class<T> clazz) {\n-        return throwableOf(throwable, clazz, 0, false);\n+    public static <T extends Throwable> T throwableOfThrowable(final Throwable t, final Class<T> clazz) {\n+        return throwableOf(t, clazz, 0, false);\n     }\n     \n-    public static <T extends Throwable> T throwableOfThrowable(final Throwable throwable, final Class<T> clazz, final int fromIndex) {\n-        return throwableOf(throwable, clazz, fromIndex, false);\n+    public static <T extends Throwable> T throwableOfThrowable(final Throwable t, final Class<T> clazz, final int n) {\n+        return throwableOf(t, clazz, n, false);\n     }\n     \n-    public static <T extends Throwable> T throwableOfType(final Throwable throwable, final Class<T> type) {\n-        return throwableOf(throwable, type, 0, true);\n+    public static <T extends Throwable> T throwableOfType(final Throwable t, final Class<T> clazz) {\n+        return throwableOf(t, clazz, 0, true);\n     }\n     \n-    public static <T extends Throwable> T throwableOfType(final Throwable throwable, final Class<T> type, final int fromIndex) {\n-        return throwableOf(throwable, type, fromIndex, true);\n+    public static <T extends Throwable> T throwableOfType(final Throwable t, final Class<T> clazz, final int n) {\n+        return throwableOf(t, clazz, n, true);\n     }\n     \n-    private static <R, T extends Throwable> R typeErasure(final Throwable throwable) throws T, Throwable {\n-        throw throwable;\n+    private static <R, T extends Throwable> R typeErasure(final Throwable t) throws T, Throwable {\n+        throw t;\n     }\n     \n-    public static <R> R wrapAndThrow(final Throwable throwable) {\n-        if (throwable instanceof RuntimeException) {\n-            throw (RuntimeException)throwable;\n+    public static <R> R wrapAndThrow(final Throwable undeclaredThrowable) {\n+        if (undeclaredThrowable instanceof RuntimeException) {\n+            throw (RuntimeException)undeclaredThrowable;\n         }\n-        if (throwable instanceof Error) {\n-            throw (Error)throwable;\n+        if (undeclaredThrowable instanceof Error) {\n+            throw (Error)undeclaredThrowable;\n         }\n-        throw new UndeclaredThrowableException(throwable);\n+        throw new UndeclaredThrowableException(undeclaredThrowable);\n     }\n     \n     static {\n         CAUSE_METHOD_NAMES = new String[] { \"getCause\", \"getNextException\", \"getTargetException\", \"getException\", \"getSourceException\", \"getRootCause\", \"getCausedByException\", \"getNested\", \"getLinkedException\", \"getNestedException\", \"getLinkedCause\", \"getThrowable\" };\n     }\n }\n"}]}
