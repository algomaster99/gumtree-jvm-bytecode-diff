{"diffoscope-json-version": 1, "source1": "first/MemberUtils.class", "source2": "second/MemberUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -9,144 +9,141 @@\n import java.lang.reflect.AccessibleObject;\n \n abstract class MemberUtils\n {\n     private static final int ACCESS_TEST = 7;\n     private static final Class<?>[] ORDERED_PRIMITIVE_TYPES;\n     \n-    static boolean setAccessibleWorkaround(final AccessibleObject o) {\n-        if (o == null || o.isAccessible()) {\n+    static boolean setAccessibleWorkaround(final AccessibleObject accessibleObject) {\n+        if (accessibleObject == null || accessibleObject.isAccessible()) {\n             return false;\n         }\n-        final Member m = (Member)o;\n-        if (!o.isAccessible() && Modifier.isPublic(m.getModifiers()) && isPackageAccess(m.getDeclaringClass().getModifiers())) {\n+        final Member member = (Member)accessibleObject;\n+        if (!accessibleObject.isAccessible() && Modifier.isPublic(member.getModifiers()) && isPackageAccess(member.getDeclaringClass().getModifiers())) {\n             try {\n-                o.setAccessible(true);\n+                accessibleObject.setAccessible(true);\n                 return true;\n             }\n             catch (final SecurityException ex) {}\n         }\n         return false;\n     }\n     \n-    static boolean isPackageAccess(final int modifiers) {\n-        return (modifiers & 0x7) == 0x0;\n+    static boolean isPackageAccess(final int n) {\n+        return (n & 0x7) == 0x0;\n     }\n     \n-    static boolean isAccessible(final Member m) {\n-        return m != null && Modifier.isPublic(m.getModifiers()) && !m.isSynthetic();\n+    static boolean isAccessible(final Member member) {\n+        return member != null && Modifier.isPublic(member.getModifiers()) && !member.isSynthetic();\n     }\n     \n-    static int compareConstructorFit(final Constructor<?> left, final Constructor<?> right, final Class<?>[] actual) {\n-        return compareParameterTypes(MemberUtils.Executable.access$000((Constructor)left), MemberUtils.Executable.access$000((Constructor)right), actual);\n+    static int compareConstructorFit(final Constructor<?> constructor, final Constructor<?> constructor2, final Class<?>[] array) {\n+        return compareParameterTypes(MemberUtils.Executable.access$000((Constructor)constructor), MemberUtils.Executable.access$000((Constructor)constructor2), array);\n     }\n     \n-    static int compareMethodFit(final Method left, final Method right, final Class<?>[] actual) {\n-        return compareParameterTypes(MemberUtils.Executable.access$100(left), MemberUtils.Executable.access$100(right), actual);\n+    static int compareMethodFit(final Method method, final Method method2, final Class<?>[] array) {\n+        return compareParameterTypes(MemberUtils.Executable.access$100(method), MemberUtils.Executable.access$100(method2), array);\n     }\n     \n-    private static int compareParameterTypes(final MemberUtils.Executable left, final MemberUtils.Executable right, final Class<?>[] actual) {\n-        final float leftCost = getTotalTransformationCost(actual, left);\n-        final float rightCost = getTotalTransformationCost(actual, right);\n-        return (leftCost < rightCost) ? -1 : ((rightCost < leftCost) ? 1 : 0);\n+    private static int compareParameterTypes(final MemberUtils.Executable executable, final MemberUtils.Executable executable2, final Class<?>[] array) {\n+        final float totalTransformationCost = getTotalTransformationCost(array, executable);\n+        final float totalTransformationCost2 = getTotalTransformationCost(array, executable2);\n+        return (totalTransformationCost < totalTransformationCost2) ? -1 : (totalTransformationCost2 < totalTransformationCost);\n     }\n     \n-    private static float getTotalTransformationCost(final Class<?>[] srcArgs, final MemberUtils.Executable executable) {\n-        final Class<?>[] destArgs = executable.getParameterTypes();\n-        final boolean isVarArgs = executable.isVarArgs();\n-        float totalCost = 0.0f;\n-        final long normalArgsLen = isVarArgs ? ((long)(destArgs.length - 1)) : ((long)destArgs.length);\n-        if (srcArgs.length < normalArgsLen) {\n+    private static float getTotalTransformationCost(final Class<?>[] array, final MemberUtils.Executable executable) {\n+        final Class[] parameterTypes = executable.getParameterTypes();\n+        final boolean varArgs = executable.isVarArgs();\n+        float n = 0.0f;\n+        final long n2 = varArgs ? ((long)(parameterTypes.length - 1)) : ((long)parameterTypes.length);\n+        if (array.length < n2) {\n             return Float.MAX_VALUE;\n         }\n-        for (int i = 0; i < normalArgsLen; ++i) {\n-            totalCost += getObjectTransformationCost(srcArgs[i], destArgs[i]);\n+        for (int n3 = 0; n3 < n2; ++n3) {\n+            n += getObjectTransformationCost(array[n3], parameterTypes[n3]);\n         }\n-        if (isVarArgs) {\n-            final boolean noVarArgsPassed = srcArgs.length < destArgs.length;\n-            final boolean explicitArrayForVarags = srcArgs.length == destArgs.length && srcArgs[srcArgs.length - 1].isArray();\n-            final float varArgsCost = 0.001f;\n-            final Class<?> destClass = destArgs[destArgs.length - 1].getComponentType();\n-            if (noVarArgsPassed) {\n-                totalCost += getObjectTransformationCost(destClass, Object.class) + 0.001f;\n-            }\n-            else if (explicitArrayForVarags) {\n-                final Class<?> sourceClass = srcArgs[srcArgs.length - 1].getComponentType();\n-                totalCost += getObjectTransformationCost(sourceClass, destClass) + 0.001f;\n+        if (varArgs) {\n+            final boolean b = array.length < parameterTypes.length;\n+            final boolean b2 = array.length == parameterTypes.length && array[array.length - 1].isArray();\n+            final Class componentType = parameterTypes[parameterTypes.length - 1].getComponentType();\n+            if (b) {\n+                n += getObjectTransformationCost(componentType, Object.class) + 0.001f;\n+            }\n+            else if (b2) {\n+                n += getObjectTransformationCost(array[array.length - 1].getComponentType(), componentType) + 0.001f;\n             }\n             else {\n-                for (int j = destArgs.length - 1; j < srcArgs.length; ++j) {\n-                    final Class<?> srcClass = srcArgs[j];\n-                    totalCost += getObjectTransformationCost(srcClass, destClass) + 0.001f;\n+                for (int i = parameterTypes.length - 1; i < array.length; ++i) {\n+                    n += getObjectTransformationCost(array[i], componentType) + 0.001f;\n                 }\n             }\n         }\n-        return totalCost;\n+        return n;\n     }\n     \n-    private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass) {\n-        if (destClass.isPrimitive()) {\n-            return getPrimitivePromotionCost(srcClass, destClass);\n+    private static float getObjectTransformationCost(Class<?> superclass, final Class<?> clazz) {\n+        if (clazz.isPrimitive()) {\n+            return getPrimitivePromotionCost(superclass, clazz);\n         }\n-        float cost = 0.0f;\n-        while (srcClass != null && !destClass.equals(srcClass)) {\n-            if (destClass.isInterface() && ClassUtils.isAssignable((Class)srcClass, (Class)destClass)) {\n-                cost += 0.25f;\n+        float n = 0.0f;\n+        while (superclass != null && !clazz.equals(superclass)) {\n+            if (clazz.isInterface() && ClassUtils.isAssignable((Class)superclass, (Class)clazz)) {\n+                n += 0.25f;\n                 break;\n             }\n-            ++cost;\n-            srcClass = srcClass.getSuperclass();\n+            ++n;\n+            superclass = superclass.getSuperclass();\n         }\n-        if (srcClass == null) {\n-            cost += 1.5f;\n+        if (superclass == null) {\n+            n += 1.5f;\n         }\n-        return cost;\n+        return n;\n     }\n     \n-    private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass) {\n-        float cost = 0.0f;\n-        Class<?> cls = srcClass;\n-        if (!cls.isPrimitive()) {\n-            cost += 0.1f;\n-            cls = ClassUtils.wrapperToPrimitive((Class)cls);\n-        }\n-        for (int i = 0; cls != destClass && i < MemberUtils.ORDERED_PRIMITIVE_TYPES.length; ++i) {\n-            if (cls == MemberUtils.ORDERED_PRIMITIVE_TYPES[i]) {\n-                cost += 0.1f;\n-                if (i < MemberUtils.ORDERED_PRIMITIVE_TYPES.length - 1) {\n-                    cls = MemberUtils.ORDERED_PRIMITIVE_TYPES[i + 1];\n+    private static float getPrimitivePromotionCost(final Class<?> clazz, final Class<?> clazz2) {\n+        float n = 0.0f;\n+        Class<?> wrapperToPrimitive = clazz;\n+        if (!wrapperToPrimitive.isPrimitive()) {\n+            n += 0.1f;\n+            wrapperToPrimitive = ClassUtils.wrapperToPrimitive((Class)wrapperToPrimitive);\n+        }\n+        for (int n2 = 0; wrapperToPrimitive != clazz2 && n2 < MemberUtils.ORDERED_PRIMITIVE_TYPES.length; ++n2) {\n+            if (wrapperToPrimitive == MemberUtils.ORDERED_PRIMITIVE_TYPES[n2]) {\n+                n += 0.1f;\n+                if (n2 < MemberUtils.ORDERED_PRIMITIVE_TYPES.length - 1) {\n+                    wrapperToPrimitive = MemberUtils.ORDERED_PRIMITIVE_TYPES[n2 + 1];\n                 }\n             }\n         }\n-        return cost;\n+        return n;\n     }\n     \n-    static boolean isMatchingMethod(final Method method, final Class<?>[] parameterTypes) {\n-        return isMatchingExecutable(MemberUtils.Executable.access$100(method), parameterTypes);\n+    static boolean isMatchingMethod(final Method method, final Class<?>[] array) {\n+        return isMatchingExecutable(MemberUtils.Executable.access$100(method), array);\n     }\n     \n-    static boolean isMatchingConstructor(final Constructor<?> method, final Class<?>[] parameterTypes) {\n-        return isMatchingExecutable(MemberUtils.Executable.access$000((Constructor)method), parameterTypes);\n+    static boolean isMatchingConstructor(final Constructor<?> constructor, final Class<?>[] array) {\n+        return isMatchingExecutable(MemberUtils.Executable.access$000((Constructor)constructor), array);\n     }\n     \n-    private static boolean isMatchingExecutable(final MemberUtils.Executable method, final Class<?>[] parameterTypes) {\n-        final Class<?>[] methodParameterTypes = method.getParameterTypes();\n-        if (ClassUtils.isAssignable((Class[])parameterTypes, (Class[])methodParameterTypes, true)) {\n+    private static boolean isMatchingExecutable(final MemberUtils.Executable executable, final Class<?>[] array) {\n+        final Class[] parameterTypes = executable.getParameterTypes();\n+        if (ClassUtils.isAssignable((Class[])array, parameterTypes, true)) {\n             return true;\n         }\n-        if (method.isVarArgs()) {\n+        if (executable.isVarArgs()) {\n             int i;\n-            for (i = 0; i < methodParameterTypes.length - 1 && i < parameterTypes.length; ++i) {\n-                if (!ClassUtils.isAssignable((Class)parameterTypes[i], (Class)methodParameterTypes[i], true)) {\n+            for (i = 0; i < parameterTypes.length - 1 && i < array.length; ++i) {\n+                if (!ClassUtils.isAssignable((Class)array[i], parameterTypes[i], true)) {\n                     return false;\n                 }\n             }\n-            final Class<?> varArgParameterType = methodParameterTypes[methodParameterTypes.length - 1].getComponentType();\n-            while (i < parameterTypes.length) {\n-                if (!ClassUtils.isAssignable((Class)parameterTypes[i], (Class)varArgParameterType, true)) {\n+            final Class componentType = parameterTypes[parameterTypes.length - 1].getComponentType();\n+            while (i < array.length) {\n+                if (!ClassUtils.isAssignable((Class)array[i], (Class)componentType, true)) {\n                     return false;\n                 }\n                 ++i;\n             }\n             return true;\n         }\n         return false;\n"}]}
