{"diffoscope-json-version": 1, "source1": "first/BaseNCodec.class", "source2": "second/BaseNCodec.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -19,23 +19,22 @@\n     protected final byte PAD = 61;\n     protected final byte pad;\n     private final int unencodedBlockSize;\n     private final int encodedBlockSize;\n     protected final int lineLength;\n     private final int chunkSeparatorLength;\n     \n-    protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize, final int lineLength, final int chunkSeparatorLength) {\n-        this(unencodedBlockSize, encodedBlockSize, lineLength, chunkSeparatorLength, (byte)61);\n+    protected BaseNCodec(final int n, final int n2, final int n3, final int n4) {\n+        this(n, n2, n3, n4, (byte)61);\n     }\n     \n-    protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize, final int lineLength, final int chunkSeparatorLength, final byte pad) {\n+    protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize, final int n, final int chunkSeparatorLength, final byte pad) {\n         this.unencodedBlockSize = unencodedBlockSize;\n         this.encodedBlockSize = encodedBlockSize;\n-        final boolean useChunking = lineLength > 0 && chunkSeparatorLength > 0;\n-        this.lineLength = (useChunking ? (lineLength / encodedBlockSize * encodedBlockSize) : 0);\n+        this.lineLength = ((n > 0 && chunkSeparatorLength > 0) ? (n / encodedBlockSize * encodedBlockSize) : 0);\n         this.chunkSeparatorLength = chunkSeparatorLength;\n         this.pad = pad;\n     }\n     \n     boolean hasData(final BaseNCodec.Context context) {\n         return context.buffer != null;\n     }\n@@ -51,147 +50,147 @@\n     private byte[] resizeBuffer(final BaseNCodec.Context context) {\n         if (context.buffer == null) {\n             context.buffer = new byte[this.getDefaultBufferSize()];\n             context.pos = 0;\n             context.readPos = 0;\n         }\n         else {\n-            final byte[] b = new byte[context.buffer.length * 2];\n-            System.arraycopy(context.buffer, 0, b, 0, context.buffer.length);\n-            context.buffer = b;\n+            final byte[] buffer = new byte[context.buffer.length * 2];\n+            System.arraycopy(context.buffer, 0, buffer, 0, context.buffer.length);\n+            context.buffer = buffer;\n         }\n         return context.buffer;\n     }\n     \n-    protected byte[] ensureBufferSize(final int size, final BaseNCodec.Context context) {\n-        if (context.buffer == null || context.buffer.length < context.pos + size) {\n+    protected byte[] ensureBufferSize(final int n, final BaseNCodec.Context context) {\n+        if (context.buffer == null || context.buffer.length < context.pos + n) {\n             return this.resizeBuffer(context);\n         }\n         return context.buffer;\n     }\n     \n-    int readResults(final byte[] b, final int bPos, final int bAvail, final BaseNCodec.Context context) {\n+    int readResults(final byte[] array, final int n, final int b, final BaseNCodec.Context context) {\n         if (context.buffer != null) {\n-            final int len = Math.min(this.available(context), bAvail);\n-            System.arraycopy(context.buffer, context.readPos, b, bPos, len);\n-            context.readPos += len;\n+            final int min = Math.min(this.available(context), b);\n+            System.arraycopy(context.buffer, context.readPos, array, n, min);\n+            context.readPos += min;\n             if (context.readPos >= context.pos) {\n                 context.buffer = null;\n             }\n-            return len;\n+            return min;\n         }\n         return context.eof ? -1 : 0;\n     }\n     \n-    protected static boolean isWhiteSpace(final byte byteToCheck) {\n-        switch (byteToCheck) {\n+    protected static boolean isWhiteSpace(final byte b) {\n+        switch (b) {\n             case 9:\n             case 10:\n             case 13:\n             case 32: {\n                 return true;\n             }\n             default: {\n                 return false;\n             }\n         }\n     }\n     \n-    public Object encode(final Object obj) throws EncoderException {\n-        if (!(obj instanceof byte[])) {\n+    public Object encode(final Object o) throws EncoderException {\n+        if (!(o instanceof byte[])) {\n             throw new EncoderException(\"Parameter supplied to Base-N encode is not a byte[]\");\n         }\n-        return this.encode((byte[])obj);\n+        return this.encode((byte[])o);\n     }\n     \n-    public String encodeToString(final byte[] pArray) {\n-        return StringUtils.newStringUtf8(this.encode(pArray));\n+    public String encodeToString(final byte[] array) {\n+        return StringUtils.newStringUtf8(this.encode(array));\n     }\n     \n-    public String encodeAsString(final byte[] pArray) {\n-        return StringUtils.newStringUtf8(this.encode(pArray));\n+    public String encodeAsString(final byte[] array) {\n+        return StringUtils.newStringUtf8(this.encode(array));\n     }\n     \n-    public Object decode(final Object obj) throws DecoderException {\n-        if (obj instanceof byte[]) {\n-            return this.decode((byte[])obj);\n+    public Object decode(final Object o) throws DecoderException {\n+        if (o instanceof byte[]) {\n+            return this.decode((byte[])o);\n         }\n-        if (obj instanceof String) {\n-            return this.decode((String)obj);\n+        if (o instanceof String) {\n+            return this.decode((String)o);\n         }\n         throw new DecoderException(\"Parameter supplied to Base-N decode is not a byte[] or a String\");\n     }\n     \n-    public byte[] decode(final String pArray) {\n-        return this.decode(StringUtils.getBytesUtf8(pArray));\n+    public byte[] decode(final String s) {\n+        return this.decode(StringUtils.getBytesUtf8(s));\n     }\n     \n-    public byte[] decode(final byte[] pArray) {\n-        if (pArray == null || pArray.length == 0) {\n-            return pArray;\n+    public byte[] decode(final byte[] array) {\n+        if (array == null || array.length == 0) {\n+            return array;\n         }\n         final BaseNCodec.Context context = new BaseNCodec.Context();\n-        this.decode(pArray, 0, pArray.length, context);\n-        this.decode(pArray, 0, -1, context);\n-        final byte[] result = new byte[context.pos];\n-        this.readResults(result, 0, result.length, context);\n-        return result;\n+        this.decode(array, 0, array.length, context);\n+        this.decode(array, 0, -1, context);\n+        final byte[] array2 = new byte[context.pos];\n+        this.readResults(array2, 0, array2.length, context);\n+        return array2;\n     }\n     \n-    public byte[] encode(final byte[] pArray) {\n-        if (pArray == null || pArray.length == 0) {\n-            return pArray;\n+    public byte[] encode(final byte[] array) {\n+        if (array == null || array.length == 0) {\n+            return array;\n         }\n-        return this.encode(pArray, 0, pArray.length);\n+        return this.encode(array, 0, array.length);\n     }\n     \n-    public byte[] encode(final byte[] pArray, final int offset, final int length) {\n-        if (pArray == null || pArray.length == 0) {\n-            return pArray;\n+    public byte[] encode(final byte[] array, final int n, final int n2) {\n+        if (array == null || array.length == 0) {\n+            return array;\n         }\n         final BaseNCodec.Context context = new BaseNCodec.Context();\n-        this.encode(pArray, offset, length, context);\n-        this.encode(pArray, offset, -1, context);\n-        final byte[] buf = new byte[context.pos - context.readPos];\n-        this.readResults(buf, 0, buf.length, context);\n-        return buf;\n+        this.encode(array, n, n2, context);\n+        this.encode(array, n, -1, context);\n+        final byte[] array2 = new byte[context.pos - context.readPos];\n+        this.readResults(array2, 0, array2.length, context);\n+        return array2;\n     }\n     \n     abstract void encode(final byte[] p0, final int p1, final int p2, final BaseNCodec.Context p3);\n     \n     abstract void decode(final byte[] p0, final int p1, final int p2, final BaseNCodec.Context p3);\n     \n     protected abstract boolean isInAlphabet(final byte p0);\n     \n-    public boolean isInAlphabet(final byte[] arrayOctet, final boolean allowWSPad) {\n-        for (final byte octet : arrayOctet) {\n-            if (!this.isInAlphabet(octet) && (!allowWSPad || (octet != this.pad && !isWhiteSpace(octet)))) {\n+    public boolean isInAlphabet(final byte[] array, final boolean b) {\n+        for (final byte b2 : array) {\n+            if (!this.isInAlphabet(b2) && (!b || (b2 != this.pad && !isWhiteSpace(b2)))) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    public boolean isInAlphabet(final String basen) {\n-        return this.isInAlphabet(StringUtils.getBytesUtf8(basen), true);\n+    public boolean isInAlphabet(final String s) {\n+        return this.isInAlphabet(StringUtils.getBytesUtf8(s), true);\n     }\n     \n-    protected boolean containsAlphabetOrPad(final byte[] arrayOctet) {\n-        if (arrayOctet == null) {\n+    protected boolean containsAlphabetOrPad(final byte[] array) {\n+        if (array == null) {\n             return false;\n         }\n-        for (final byte element : arrayOctet) {\n-            if (this.pad == element || this.isInAlphabet(element)) {\n+        for (final byte b : array) {\n+            if (this.pad == b || this.isInAlphabet(b)) {\n                 return true;\n             }\n         }\n         return false;\n     }\n     \n-    public long getEncodedLength(final byte[] pArray) {\n-        long len = (pArray.length + this.unencodedBlockSize - 1) / this.unencodedBlockSize * (long)this.encodedBlockSize;\n+    public long getEncodedLength(final byte[] array) {\n+        long n = (array.length + this.unencodedBlockSize - 1) / this.unencodedBlockSize * (long)this.encodedBlockSize;\n         if (this.lineLength > 0) {\n-            len += (len + this.lineLength - 1L) / this.lineLength * this.chunkSeparatorLength;\n+            n += (n + this.lineLength - 1L) / this.lineLength * this.chunkSeparatorLength;\n         }\n-        return len;\n+        return n;\n     }\n }\n"}]}
