{"diffoscope-json-version": 1, "source1": "first/InstructionFactory.class", "source2": "second/InstructionFactory.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -11,149 +11,148 @@\n     private static final InstructionFactory.MethodObject[] append_mos;\n     \n     public InstructionFactory(final ClassGen cg, final ConstantPoolGen cp) {\n         this.cg = cg;\n         this.cp = cp;\n     }\n     \n-    public InstructionFactory(final ClassGen cg) {\n-        this(cg, cg.getConstantPool());\n+    public InstructionFactory(final ClassGen classGen) {\n+        this(classGen, classGen.getConstantPool());\n     }\n     \n-    public InstructionFactory(final ConstantPoolGen cp) {\n-        this(null, cp);\n+    public InstructionFactory(final ConstantPoolGen constantPoolGen) {\n+        this(null, constantPoolGen);\n     }\n     \n-    public InvokeInstruction createInvoke(final String class_name, final String name, final Type ret_type, final Type[] arg_types, final short kind) {\n-        int nargs = 0;\n-        final String signature = Type.getMethodSignature(ret_type, arg_types);\n-        for (final Type arg_type : arg_types) {\n-            nargs += arg_type.getSize();\n+    public InvokeInstruction createInvoke(final String s, final String s2, final Type type, final Type[] array, final short i) {\n+        int n = 0;\n+        final String methodSignature = Type.getMethodSignature(type, array);\n+        for (int length = array.length, j = 0; j < length; ++j) {\n+            n += array[j].getSize();\n         }\n-        int index;\n-        if (kind == 185) {\n-            index = this.cp.addInterfaceMethodref(class_name, name, signature);\n+        int n2;\n+        if (i == 185) {\n+            n2 = this.cp.addInterfaceMethodref(s, s2, methodSignature);\n         }\n         else {\n-            index = this.cp.addMethodref(class_name, name, signature);\n+            n2 = this.cp.addMethodref(s, s2, methodSignature);\n         }\n-        switch (kind) {\n+        switch (i) {\n             case 183: {\n-                return (InvokeInstruction)new INVOKESPECIAL(index);\n+                return (InvokeInstruction)new INVOKESPECIAL(n2);\n             }\n             case 182: {\n-                return (InvokeInstruction)new INVOKEVIRTUAL(index);\n+                return (InvokeInstruction)new INVOKEVIRTUAL(n2);\n             }\n             case 184: {\n-                return (InvokeInstruction)new INVOKESTATIC(index);\n+                return (InvokeInstruction)new INVOKESTATIC(n2);\n             }\n             case 185: {\n-                return (InvokeInstruction)new INVOKEINTERFACE(index, nargs + 1);\n+                return (InvokeInstruction)new INVOKEINTERFACE(n2, n + 1);\n             }\n             case 186: {\n-                return (InvokeInstruction)new INVOKEDYNAMIC(index);\n+                return (InvokeInstruction)new INVOKEDYNAMIC(n2);\n             }\n             default: {\n-                throw new RuntimeException(\"Oops: Unknown invoke kind: \" + kind);\n+                throw new RuntimeException(\"Oops: Unknown invoke kind: \" + i);\n             }\n         }\n     }\n     \n     public InstructionList createPrintln(final String s) {\n-        final InstructionList il = new InstructionList();\n-        final int out = this.cp.addFieldref(\"java.lang.System\", \"out\", \"Ljava/io/PrintStream;\");\n-        final int println = this.cp.addMethodref(\"java.io.PrintStream\", \"println\", \"(Ljava/lang/String;)V\");\n-        il.append((Instruction)new GETSTATIC(out));\n-        il.append((CompoundInstruction)new PUSH(this.cp, s));\n-        il.append((Instruction)new INVOKEVIRTUAL(println));\n-        return il;\n+        final InstructionList list = new InstructionList();\n+        final int addFieldref = this.cp.addFieldref(\"java.lang.System\", \"out\", \"Ljava/io/PrintStream;\");\n+        final int addMethodref = this.cp.addMethodref(\"java.io.PrintStream\", \"println\", \"(Ljava/lang/String;)V\");\n+        list.append((Instruction)new GETSTATIC(addFieldref));\n+        list.append((CompoundInstruction)new PUSH(this.cp, s));\n+        list.append((Instruction)new INVOKEVIRTUAL(addMethodref));\n+        return list;\n     }\n     \n-    public Instruction createConstant(final Object value) {\n+    public Instruction createConstant(final Object o) {\n         PUSH push;\n-        if (value instanceof Number) {\n-            push = new PUSH(this.cp, (Number)value);\n+        if (o instanceof Number) {\n+            push = new PUSH(this.cp, (Number)o);\n         }\n-        else if (value instanceof String) {\n-            push = new PUSH(this.cp, (String)value);\n+        else if (o instanceof String) {\n+            push = new PUSH(this.cp, (String)o);\n         }\n-        else if (value instanceof Boolean) {\n-            push = new PUSH(this.cp, (Boolean)value);\n+        else if (o instanceof Boolean) {\n+            push = new PUSH(this.cp, (Boolean)o);\n         }\n         else {\n-            if (!(value instanceof Character)) {\n-                throw new ClassGenException(\"Illegal type: \" + value.getClass());\n+            if (!(o instanceof Character)) {\n+                throw new ClassGenException(\"Illegal type: \" + o.getClass());\n             }\n-            push = new PUSH(this.cp, (Character)value);\n+            push = new PUSH(this.cp, (Character)o);\n         }\n         return push.getInstruction();\n     }\n     \n-    private InvokeInstruction createInvoke(final InstructionFactory.MethodObject m, final short kind) {\n-        return this.createInvoke(m.class_name, m.name, m.result_type, m.arg_types, kind);\n+    private InvokeInstruction createInvoke(final InstructionFactory.MethodObject methodObject, final short n) {\n+        return this.createInvoke(methodObject.class_name, methodObject.name, methodObject.result_type, methodObject.arg_types, n);\n     }\n     \n     private static boolean isString(final Type type) {\n         return type instanceof ObjectType && ((ObjectType)type).getClassName().equals(\"java.lang.String\");\n     }\n     \n-    public Instruction createAppend(final Type type) {\n-        final byte t = type.getType();\n-        if (isString(type)) {\n+    public Instruction createAppend(final Type obj) {\n+        final byte type = obj.getType();\n+        if (isString(obj)) {\n             return (Instruction)this.createInvoke(InstructionFactory.append_mos[0], (short)182);\n         }\n-        switch (t) {\n+        switch (type) {\n             case 4:\n             case 5:\n             case 6:\n             case 7:\n             case 8:\n             case 9:\n             case 10:\n             case 11: {\n-                return (Instruction)this.createInvoke(InstructionFactory.append_mos[t], (short)182);\n+                return (Instruction)this.createInvoke(InstructionFactory.append_mos[type], (short)182);\n             }\n             case 13:\n             case 14: {\n                 return (Instruction)this.createInvoke(InstructionFactory.append_mos[1], (short)182);\n             }\n             default: {\n-                throw new RuntimeException(\"Oops: No append for this type? \" + type);\n+                throw new RuntimeException(\"Oops: No append for this type? \" + obj);\n             }\n         }\n     }\n     \n-    public FieldInstruction createFieldAccess(final String class_name, final String name, final Type type, final short kind) {\n-        final String signature = type.getSignature();\n-        final int index = this.cp.addFieldref(class_name, name, signature);\n-        switch (kind) {\n+    public FieldInstruction createFieldAccess(final String s, final String s2, final Type type, final short i) {\n+        final int addFieldref = this.cp.addFieldref(s, s2, type.getSignature());\n+        switch (i) {\n             case 180: {\n-                return (FieldInstruction)new GETFIELD(index);\n+                return (FieldInstruction)new GETFIELD(addFieldref);\n             }\n             case 181: {\n-                return (FieldInstruction)new PUTFIELD(index);\n+                return (FieldInstruction)new PUTFIELD(addFieldref);\n             }\n             case 178: {\n-                return (FieldInstruction)new GETSTATIC(index);\n+                return (FieldInstruction)new GETSTATIC(addFieldref);\n             }\n             case 179: {\n-                return (FieldInstruction)new PUTSTATIC(index);\n+                return (FieldInstruction)new PUTSTATIC(addFieldref);\n             }\n             default: {\n-                throw new RuntimeException(\"Oops: Unknown getfield kind:\" + kind);\n+                throw new RuntimeException(\"Oops: Unknown getfield kind:\" + i);\n             }\n         }\n     }\n     \n     public static Instruction createThis() {\n         return (Instruction)new ALOAD(0);\n     }\n     \n-    public static ReturnInstruction createReturn(final Type type) {\n-        switch (type.getType()) {\n+    public static ReturnInstruction createReturn(final Type obj) {\n+        switch (obj.getType()) {\n             case 13:\n             case 14: {\n                 return InstructionConst.ARETURN;\n             }\n             case 4:\n             case 5:\n             case 8:\n@@ -170,21 +169,21 @@\n             case 11: {\n                 return InstructionConst.LRETURN;\n             }\n             case 12: {\n                 return InstructionConst.RETURN;\n             }\n             default: {\n-                throw new RuntimeException(\"Invalid type: \" + type);\n+                throw new RuntimeException(\"Invalid type: \" + obj);\n             }\n         }\n     }\n     \n-    private static ArithmeticInstruction createBinaryIntOp(final char first, final String op) {\n-        switch (first) {\n+    private static ArithmeticInstruction createBinaryIntOp(final char c, final String str) {\n+        switch (c) {\n             case '-': {\n                 return InstructionConst.ISUB;\n             }\n             case '+': {\n                 return InstructionConst.IADD;\n             }\n             case '%': {\n@@ -205,24 +204,24 @@\n             case '^': {\n                 return InstructionConst.IXOR;\n             }\n             case '<': {\n                 return InstructionConst.ISHL;\n             }\n             case '>': {\n-                return op.equals(\">>>\") ? InstructionConst.IUSHR : InstructionConst.ISHR;\n+                return str.equals(\">>>\") ? InstructionConst.IUSHR : InstructionConst.ISHR;\n             }\n             default: {\n-                throw new RuntimeException(\"Invalid operand \" + op);\n+                throw new RuntimeException(\"Invalid operand \" + str);\n             }\n         }\n     }\n     \n-    private static ArithmeticInstruction createBinaryLongOp(final char first, final String op) {\n-        switch (first) {\n+    private static ArithmeticInstruction createBinaryLongOp(final char c, final String str) {\n+        switch (c) {\n             case '-': {\n                 return InstructionConst.LSUB;\n             }\n             case '+': {\n                 return InstructionConst.LADD;\n             }\n             case '%': {\n@@ -243,24 +242,24 @@\n             case '^': {\n                 return InstructionConst.LXOR;\n             }\n             case '<': {\n                 return InstructionConst.LSHL;\n             }\n             case '>': {\n-                return op.equals(\">>>\") ? InstructionConst.LUSHR : InstructionConst.LSHR;\n+                return str.equals(\">>>\") ? InstructionConst.LUSHR : InstructionConst.LSHR;\n             }\n             default: {\n-                throw new RuntimeException(\"Invalid operand \" + op);\n+                throw new RuntimeException(\"Invalid operand \" + str);\n             }\n         }\n     }\n     \n-    private static ArithmeticInstruction createBinaryFloatOp(final char op) {\n-        switch (op) {\n+    private static ArithmeticInstruction createBinaryFloatOp(final char c) {\n+        switch (c) {\n             case '-': {\n                 return InstructionConst.FSUB;\n             }\n             case '+': {\n                 return InstructionConst.FADD;\n             }\n             case '*': {\n@@ -269,21 +268,21 @@\n             case '/': {\n                 return InstructionConst.FDIV;\n             }\n             case '%': {\n                 return InstructionConst.FREM;\n             }\n             default: {\n-                throw new RuntimeException(\"Invalid operand \" + op);\n+                throw new RuntimeException(\"Invalid operand \" + c);\n             }\n         }\n     }\n     \n-    private static ArithmeticInstruction createBinaryDoubleOp(final char op) {\n-        switch (op) {\n+    private static ArithmeticInstruction createBinaryDoubleOp(final char c) {\n+        switch (c) {\n             case '-': {\n                 return InstructionConst.DSUB;\n             }\n             case '+': {\n                 return InstructionConst.DADD;\n             }\n             case '*': {\n@@ -292,117 +291,117 @@\n             case '/': {\n                 return InstructionConst.DDIV;\n             }\n             case '%': {\n                 return InstructionConst.DREM;\n             }\n             default: {\n-                throw new RuntimeException(\"Invalid operand \" + op);\n+                throw new RuntimeException(\"Invalid operand \" + c);\n             }\n         }\n     }\n     \n-    public static ArithmeticInstruction createBinaryOperation(final String op, final Type type) {\n-        final char first = op.charAt(0);\n-        switch (type.getType()) {\n+    public static ArithmeticInstruction createBinaryOperation(final String s, final Type obj) {\n+        final char char1 = s.charAt(0);\n+        switch (obj.getType()) {\n             case 5:\n             case 8:\n             case 9:\n             case 10: {\n-                return createBinaryIntOp(first, op);\n+                return createBinaryIntOp(char1, s);\n             }\n             case 11: {\n-                return createBinaryLongOp(first, op);\n+                return createBinaryLongOp(char1, s);\n             }\n             case 6: {\n-                return createBinaryFloatOp(first);\n+                return createBinaryFloatOp(char1);\n             }\n             case 7: {\n-                return createBinaryDoubleOp(first);\n+                return createBinaryDoubleOp(char1);\n             }\n             default: {\n-                throw new RuntimeException(\"Invalid type \" + type);\n+                throw new RuntimeException(\"Invalid type \" + obj);\n             }\n         }\n     }\n     \n-    public static StackInstruction createPop(final int size) {\n-        return (size == 2) ? InstructionConst.POP2 : InstructionConst.POP;\n+    public static StackInstruction createPop(final int n) {\n+        return (n == 2) ? InstructionConst.POP2 : InstructionConst.POP;\n     }\n     \n-    public static StackInstruction createDup(final int size) {\n-        return (size == 2) ? InstructionConst.DUP2 : InstructionConst.DUP;\n+    public static StackInstruction createDup(final int n) {\n+        return (n == 2) ? InstructionConst.DUP2 : InstructionConst.DUP;\n     }\n     \n-    public static StackInstruction createDup_2(final int size) {\n-        return (size == 2) ? InstructionConst.DUP2_X2 : InstructionConst.DUP_X2;\n+    public static StackInstruction createDup_2(final int n) {\n+        return (n == 2) ? InstructionConst.DUP2_X2 : InstructionConst.DUP_X2;\n     }\n     \n-    public static StackInstruction createDup_1(final int size) {\n-        return (size == 2) ? InstructionConst.DUP2_X1 : InstructionConst.DUP_X1;\n+    public static StackInstruction createDup_1(final int n) {\n+        return (n == 2) ? InstructionConst.DUP2_X1 : InstructionConst.DUP_X1;\n     }\n     \n-    public static LocalVariableInstruction createStore(final Type type, final int index) {\n-        switch (type.getType()) {\n+    public static LocalVariableInstruction createStore(final Type obj, final int n) {\n+        switch (obj.getType()) {\n             case 4:\n             case 5:\n             case 8:\n             case 9:\n             case 10: {\n-                return (LocalVariableInstruction)new ISTORE(index);\n+                return (LocalVariableInstruction)new ISTORE(n);\n             }\n             case 6: {\n-                return (LocalVariableInstruction)new FSTORE(index);\n+                return (LocalVariableInstruction)new FSTORE(n);\n             }\n             case 7: {\n-                return (LocalVariableInstruction)new DSTORE(index);\n+                return (LocalVariableInstruction)new DSTORE(n);\n             }\n             case 11: {\n-                return (LocalVariableInstruction)new LSTORE(index);\n+                return (LocalVariableInstruction)new LSTORE(n);\n             }\n             case 13:\n             case 14: {\n-                return (LocalVariableInstruction)new ASTORE(index);\n+                return (LocalVariableInstruction)new ASTORE(n);\n             }\n             default: {\n-                throw new RuntimeException(\"Invalid type \" + type);\n+                throw new RuntimeException(\"Invalid type \" + obj);\n             }\n         }\n     }\n     \n-    public static LocalVariableInstruction createLoad(final Type type, final int index) {\n-        switch (type.getType()) {\n+    public static LocalVariableInstruction createLoad(final Type obj, final int n) {\n+        switch (obj.getType()) {\n             case 4:\n             case 5:\n             case 8:\n             case 9:\n             case 10: {\n-                return (LocalVariableInstruction)new ILOAD(index);\n+                return (LocalVariableInstruction)new ILOAD(n);\n             }\n             case 6: {\n-                return (LocalVariableInstruction)new FLOAD(index);\n+                return (LocalVariableInstruction)new FLOAD(n);\n             }\n             case 7: {\n-                return (LocalVariableInstruction)new DLOAD(index);\n+                return (LocalVariableInstruction)new DLOAD(n);\n             }\n             case 11: {\n-                return (LocalVariableInstruction)new LLOAD(index);\n+                return (LocalVariableInstruction)new LLOAD(n);\n             }\n             case 13:\n             case 14: {\n-                return (LocalVariableInstruction)new ALOAD(index);\n+                return (LocalVariableInstruction)new ALOAD(n);\n             }\n             default: {\n-                throw new RuntimeException(\"Invalid type \" + type);\n+                throw new RuntimeException(\"Invalid type \" + obj);\n             }\n         }\n     }\n     \n-    public static ArrayInstruction createArrayLoad(final Type type) {\n-        switch (type.getType()) {\n+    public static ArrayInstruction createArrayLoad(final Type obj) {\n+        switch (obj.getType()) {\n             case 4:\n             case 8: {\n                 return InstructionConst.BALOAD;\n             }\n             case 5: {\n                 return InstructionConst.CALOAD;\n             }\n@@ -422,21 +421,21 @@\n                 return InstructionConst.LALOAD;\n             }\n             case 13:\n             case 14: {\n                 return InstructionConst.AALOAD;\n             }\n             default: {\n-                throw new RuntimeException(\"Invalid type \" + type);\n+                throw new RuntimeException(\"Invalid type \" + obj);\n             }\n         }\n     }\n     \n-    public static ArrayInstruction createArrayStore(final Type type) {\n-        switch (type.getType()) {\n+    public static ArrayInstruction createArrayStore(final Type obj) {\n+        switch (obj.getType()) {\n             case 4:\n             case 8: {\n                 return InstructionConst.BASTORE;\n             }\n             case 5: {\n                 return InstructionConst.CASTORE;\n             }\n@@ -456,105 +455,105 @@\n                 return InstructionConst.LASTORE;\n             }\n             case 13:\n             case 14: {\n                 return InstructionConst.AASTORE;\n             }\n             default: {\n-                throw new RuntimeException(\"Invalid type \" + type);\n+                throw new RuntimeException(\"Invalid type \" + obj);\n             }\n         }\n     }\n     \n-    public Instruction createCast(final Type src_type, final Type dest_type) {\n-        if (src_type instanceof BasicType && dest_type instanceof BasicType) {\n-            final byte dest = dest_type.getType();\n-            byte src = src_type.getType();\n-            if (dest == 11 && (src == 5 || src == 8 || src == 9)) {\n-                src = 10;\n+    public Instruction createCast(final Type obj, final Type obj2) {\n+        if (obj instanceof BasicType && obj2 instanceof BasicType) {\n+            final byte type = obj2.getType();\n+            int type2 = obj.getType();\n+            if (type == 11 && (type2 == 5 || type2 == 8 || type2 == 9)) {\n+                type2 = 10;\n             }\n-            final String name = \"org.apache.bcel.generic.\" + InstructionFactory.short_names[src - 5] + \"2\" + InstructionFactory.short_names[dest - 5];\n-            Instruction i = null;\n+            final String string = \"org.apache.bcel.generic.\" + InstructionFactory.short_names[type2 - 5] + \"2\" + InstructionFactory.short_names[type - 5];\n+            Instruction instruction;\n             try {\n-                i = (Instruction)Class.forName(name).newInstance();\n+                instruction = (Instruction)Class.forName(string).newInstance();\n             }\n-            catch (final Exception e) {\n-                throw new RuntimeException(\"Could not find instruction: \" + name, e);\n+            catch (final Exception cause) {\n+                throw new RuntimeException(\"Could not find instruction: \" + string, cause);\n             }\n-            return i;\n+            return instruction;\n         }\n-        if (!(src_type instanceof ReferenceType) || !(dest_type instanceof ReferenceType)) {\n-            throw new RuntimeException(\"Can not cast \" + src_type + \" to \" + dest_type);\n+        if (!(obj instanceof ReferenceType) || !(obj2 instanceof ReferenceType)) {\n+            throw new RuntimeException(\"Can not cast \" + obj + \" to \" + obj2);\n         }\n-        if (dest_type instanceof ArrayType) {\n-            return (Instruction)new CHECKCAST(this.cp.addArrayClass((ArrayType)dest_type));\n+        if (obj2 instanceof ArrayType) {\n+            return (Instruction)new CHECKCAST(this.cp.addArrayClass((ArrayType)obj2));\n         }\n-        return (Instruction)new CHECKCAST(this.cp.addClass(((ObjectType)dest_type).getClassName()));\n+        return (Instruction)new CHECKCAST(this.cp.addClass(((ObjectType)obj2).getClassName()));\n     }\n     \n-    public GETFIELD createGetField(final String class_name, final String name, final Type t) {\n-        return new GETFIELD(this.cp.addFieldref(class_name, name, t.getSignature()));\n+    public GETFIELD createGetField(final String s, final String s2, final Type type) {\n+        return new GETFIELD(this.cp.addFieldref(s, s2, type.getSignature()));\n     }\n     \n-    public GETSTATIC createGetStatic(final String class_name, final String name, final Type t) {\n-        return new GETSTATIC(this.cp.addFieldref(class_name, name, t.getSignature()));\n+    public GETSTATIC createGetStatic(final String s, final String s2, final Type type) {\n+        return new GETSTATIC(this.cp.addFieldref(s, s2, type.getSignature()));\n     }\n     \n-    public PUTFIELD createPutField(final String class_name, final String name, final Type t) {\n-        return new PUTFIELD(this.cp.addFieldref(class_name, name, t.getSignature()));\n+    public PUTFIELD createPutField(final String s, final String s2, final Type type) {\n+        return new PUTFIELD(this.cp.addFieldref(s, s2, type.getSignature()));\n     }\n     \n-    public PUTSTATIC createPutStatic(final String class_name, final String name, final Type t) {\n-        return new PUTSTATIC(this.cp.addFieldref(class_name, name, t.getSignature()));\n+    public PUTSTATIC createPutStatic(final String s, final String s2, final Type type) {\n+        return new PUTSTATIC(this.cp.addFieldref(s, s2, type.getSignature()));\n     }\n     \n-    public CHECKCAST createCheckCast(final ReferenceType t) {\n-        if (t instanceof ArrayType) {\n-            return new CHECKCAST(this.cp.addArrayClass((ArrayType)t));\n+    public CHECKCAST createCheckCast(final ReferenceType referenceType) {\n+        if (referenceType instanceof ArrayType) {\n+            return new CHECKCAST(this.cp.addArrayClass((ArrayType)referenceType));\n         }\n-        return new CHECKCAST(this.cp.addClass((ObjectType)t));\n+        return new CHECKCAST(this.cp.addClass((ObjectType)referenceType));\n     }\n     \n-    public INSTANCEOF createInstanceOf(final ReferenceType t) {\n-        if (t instanceof ArrayType) {\n-            return new INSTANCEOF(this.cp.addArrayClass((ArrayType)t));\n+    public INSTANCEOF createInstanceOf(final ReferenceType referenceType) {\n+        if (referenceType instanceof ArrayType) {\n+            return new INSTANCEOF(this.cp.addArrayClass((ArrayType)referenceType));\n         }\n-        return new INSTANCEOF(this.cp.addClass((ObjectType)t));\n+        return new INSTANCEOF(this.cp.addClass((ObjectType)referenceType));\n     }\n     \n-    public NEW createNew(final ObjectType t) {\n-        return new NEW(this.cp.addClass(t));\n+    public NEW createNew(final ObjectType objectType) {\n+        return new NEW(this.cp.addClass(objectType));\n     }\n     \n     public NEW createNew(final String s) {\n         return this.createNew(ObjectType.getInstance(s));\n     }\n     \n-    public Instruction createNewArray(final Type t, final short dim) {\n-        if (dim != 1) {\n-            ArrayType at;\n-            if (t instanceof ArrayType) {\n-                at = (ArrayType)t;\n+    public Instruction createNewArray(final Type type, final short n) {\n+        if (n != 1) {\n+            ArrayType arrayType;\n+            if (type instanceof ArrayType) {\n+                arrayType = (ArrayType)type;\n             }\n             else {\n-                at = new ArrayType(t, (int)dim);\n+                arrayType = new ArrayType(type, (int)n);\n             }\n-            return (Instruction)new MULTIANEWARRAY(this.cp.addArrayClass(at), dim);\n+            return (Instruction)new MULTIANEWARRAY(this.cp.addArrayClass(arrayType), n);\n         }\n-        if (t instanceof ObjectType) {\n-            return (Instruction)new ANEWARRAY(this.cp.addClass((ObjectType)t));\n+        if (type instanceof ObjectType) {\n+            return (Instruction)new ANEWARRAY(this.cp.addClass((ObjectType)type));\n         }\n-        if (t instanceof ArrayType) {\n-            return (Instruction)new ANEWARRAY(this.cp.addArrayClass((ArrayType)t));\n+        if (type instanceof ArrayType) {\n+            return (Instruction)new ANEWARRAY(this.cp.addArrayClass((ArrayType)type));\n         }\n-        return (Instruction)new NEWARRAY(t.getType());\n+        return (Instruction)new NEWARRAY(type.getType());\n     }\n     \n-    public static Instruction createNull(final Type type) {\n-        switch (type.getType()) {\n+    public static Instruction createNull(final Type obj) {\n+        switch (obj.getType()) {\n             case 13:\n             case 14: {\n                 return InstructionConst.ACONST_NULL;\n             }\n             case 4:\n             case 5:\n             case 8:\n@@ -571,97 +570,97 @@\n             case 11: {\n                 return InstructionConst.LCONST_0;\n             }\n             case 12: {\n                 return InstructionConst.NOP;\n             }\n             default: {\n-                throw new RuntimeException(\"Invalid type: \" + type);\n+                throw new RuntimeException(\"Invalid type: \" + obj);\n             }\n         }\n     }\n     \n-    public static BranchInstruction createBranchInstruction(final short opcode, final InstructionHandle target) {\n-        switch (opcode) {\n+    public static BranchInstruction createBranchInstruction(final short i, final InstructionHandle instructionHandle) {\n+        switch (i) {\n             case 153: {\n-                return (BranchInstruction)new IFEQ(target);\n+                return (BranchInstruction)new IFEQ(instructionHandle);\n             }\n             case 154: {\n-                return (BranchInstruction)new IFNE(target);\n+                return (BranchInstruction)new IFNE(instructionHandle);\n             }\n             case 155: {\n-                return (BranchInstruction)new IFLT(target);\n+                return (BranchInstruction)new IFLT(instructionHandle);\n             }\n             case 156: {\n-                return (BranchInstruction)new IFGE(target);\n+                return (BranchInstruction)new IFGE(instructionHandle);\n             }\n             case 157: {\n-                return (BranchInstruction)new IFGT(target);\n+                return (BranchInstruction)new IFGT(instructionHandle);\n             }\n             case 158: {\n-                return (BranchInstruction)new IFLE(target);\n+                return (BranchInstruction)new IFLE(instructionHandle);\n             }\n             case 159: {\n-                return (BranchInstruction)new IF_ICMPEQ(target);\n+                return (BranchInstruction)new IF_ICMPEQ(instructionHandle);\n             }\n             case 160: {\n-                return (BranchInstruction)new IF_ICMPNE(target);\n+                return (BranchInstruction)new IF_ICMPNE(instructionHandle);\n             }\n             case 161: {\n-                return (BranchInstruction)new IF_ICMPLT(target);\n+                return (BranchInstruction)new IF_ICMPLT(instructionHandle);\n             }\n             case 162: {\n-                return (BranchInstruction)new IF_ICMPGE(target);\n+                return (BranchInstruction)new IF_ICMPGE(instructionHandle);\n             }\n             case 163: {\n-                return (BranchInstruction)new IF_ICMPGT(target);\n+                return (BranchInstruction)new IF_ICMPGT(instructionHandle);\n             }\n             case 164: {\n-                return (BranchInstruction)new IF_ICMPLE(target);\n+                return (BranchInstruction)new IF_ICMPLE(instructionHandle);\n             }\n             case 165: {\n-                return (BranchInstruction)new IF_ACMPEQ(target);\n+                return (BranchInstruction)new IF_ACMPEQ(instructionHandle);\n             }\n             case 166: {\n-                return (BranchInstruction)new IF_ACMPNE(target);\n+                return (BranchInstruction)new IF_ACMPNE(instructionHandle);\n             }\n             case 167: {\n-                return (BranchInstruction)new GOTO(target);\n+                return (BranchInstruction)new GOTO(instructionHandle);\n             }\n             case 168: {\n-                return (BranchInstruction)new JSR(target);\n+                return (BranchInstruction)new JSR(instructionHandle);\n             }\n             case 198: {\n-                return (BranchInstruction)new IFNULL(target);\n+                return (BranchInstruction)new IFNULL(instructionHandle);\n             }\n             case 199: {\n-                return (BranchInstruction)new IFNONNULL(target);\n+                return (BranchInstruction)new IFNONNULL(instructionHandle);\n             }\n             case 200: {\n-                return (BranchInstruction)new GOTO_W(target);\n+                return (BranchInstruction)new GOTO_W(instructionHandle);\n             }\n             case 201: {\n-                return (BranchInstruction)new JSR_W(target);\n+                return (BranchInstruction)new JSR_W(instructionHandle);\n             }\n             default: {\n-                throw new RuntimeException(\"Invalid opcode: \" + opcode);\n+                throw new RuntimeException(\"Invalid opcode: \" + i);\n             }\n         }\n     }\n     \n-    public void setClassGen(final ClassGen c) {\n-        this.cg = c;\n+    public void setClassGen(final ClassGen cg) {\n+        this.cg = cg;\n     }\n     \n     public ClassGen getClassGen() {\n         return this.cg;\n     }\n     \n-    public void setConstantPool(final ConstantPoolGen c) {\n-        this.cp = c;\n+    public void setConstantPool(final ConstantPoolGen cp) {\n+        this.cp = cp;\n     }\n     \n     public ConstantPoolGen getConstantPool() {\n         return this.cp;\n     }\n     \n     static {\n"}]}
