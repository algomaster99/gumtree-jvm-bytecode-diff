{"diffoscope-json-version": 1, "source1": "first/Fraction.class", "source2": "second/Fraction.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -29,148 +29,138 @@\n         this.hashCode = 0;\n         this.toString = null;\n         this.toProperString = null;\n         this.numerator = numerator;\n         this.denominator = denominator;\n     }\n     \n-    public static Fraction getFraction(int numerator, int denominator) {\n-        if (denominator == 0) {\n+    public static Fraction getFraction(int n, int n2) {\n+        if (n2 == 0) {\n             throw new ArithmeticException(\"The denominator must not be zero\");\n         }\n-        if (denominator < 0) {\n-            if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {\n+        if (n2 < 0) {\n+            if (n == Integer.MIN_VALUE || n2 == Integer.MIN_VALUE) {\n                 throw new ArithmeticException(\"overflow: can't negate\");\n             }\n-            numerator = -numerator;\n-            denominator = -denominator;\n+            n = -n;\n+            n2 = -n2;\n         }\n-        return new Fraction(numerator, denominator);\n+        return new Fraction(n, n2);\n     }\n     \n-    public static Fraction getFraction(final int whole, final int numerator, final int denominator) {\n-        if (denominator == 0) {\n+    public static Fraction getFraction(final int n, final int n2, final int n3) {\n+        if (n3 == 0) {\n             throw new ArithmeticException(\"The denominator must not be zero\");\n         }\n-        if (denominator < 0) {\n+        if (n3 < 0) {\n             throw new ArithmeticException(\"The denominator must not be negative\");\n         }\n-        if (numerator < 0) {\n+        if (n2 < 0) {\n             throw new ArithmeticException(\"The numerator must not be negative\");\n         }\n-        long numeratorValue;\n-        if (whole < 0) {\n-            numeratorValue = whole * (long)denominator - numerator;\n+        long n4;\n+        if (n < 0) {\n+            n4 = n * (long)n3 - n2;\n         }\n         else {\n-            numeratorValue = whole * (long)denominator + numerator;\n+            n4 = n * (long)n3 + n2;\n         }\n-        if (numeratorValue < -2147483648L || numeratorValue > 2147483647L) {\n+        if (n4 < -2147483648L || n4 > 2147483647L) {\n             throw new ArithmeticException(\"Numerator too large to represent as an Integer.\");\n         }\n-        return new Fraction((int)numeratorValue, denominator);\n+        return new Fraction((int)n4, n3);\n     }\n     \n-    public static Fraction getReducedFraction(int numerator, int denominator) {\n-        if (denominator == 0) {\n+    public static Fraction getReducedFraction(int n, int n2) {\n+        if (n2 == 0) {\n             throw new ArithmeticException(\"The denominator must not be zero\");\n         }\n-        if (numerator == 0) {\n+        if (n == 0) {\n             return Fraction.ZERO;\n         }\n-        if (denominator == Integer.MIN_VALUE && (numerator & 0x1) == 0x0) {\n-            numerator /= 2;\n-            denominator /= 2;\n+        if (n2 == Integer.MIN_VALUE && (n & 0x1) == 0x0) {\n+            n /= 2;\n+            n2 /= 2;\n         }\n-        if (denominator < 0) {\n-            if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {\n+        if (n2 < 0) {\n+            if (n == Integer.MIN_VALUE || n2 == Integer.MIN_VALUE) {\n                 throw new ArithmeticException(\"overflow: can't negate\");\n             }\n-            numerator = -numerator;\n-            denominator = -denominator;\n+            n = -n;\n+            n2 = -n2;\n         }\n-        final int gcd = greatestCommonDivisor(numerator, denominator);\n-        numerator /= gcd;\n-        denominator /= gcd;\n-        return new Fraction(numerator, denominator);\n+        final int greatestCommonDivisor = greatestCommonDivisor(n, n2);\n+        n /= greatestCommonDivisor;\n+        n2 /= greatestCommonDivisor;\n+        return new Fraction(n, n2);\n     }\n     \n-    public static Fraction getFraction(double value) {\n-        final int sign = (value < 0.0) ? -1 : 1;\n-        value = Math.abs(value);\n-        if (value > 2.147483647E9 || Double.isNaN(value)) {\n+    public static Fraction getFraction(double abs) {\n+        final int n = (abs < 0.0) ? -1 : 1;\n+        abs = Math.abs(abs);\n+        if (abs > 2.147483647E9 || Double.isNaN(abs)) {\n             throw new ArithmeticException(\"The value must not be greater than Integer.MAX_VALUE or NaN\");\n         }\n-        final int wholeNumber = (int)value;\n-        value -= wholeNumber;\n-        int numer0 = 0;\n-        int denom0 = 1;\n-        int numer2 = 1;\n-        int denom2 = 0;\n-        int numer3 = 0;\n-        int denom3 = 0;\n-        int a1 = (int)value;\n-        int a2 = 0;\n-        double x1 = 1.0;\n-        double x2 = 0.0;\n-        double y1 = value - a1;\n-        double y2 = 0.0;\n-        double delta2 = Double.MAX_VALUE;\n-        int i = 1;\n-        double delta3;\n+        final int n2 = (int)abs;\n+        abs -= n2;\n+        int n3 = 0;\n+        int n4 = 1;\n+        int n5 = 1;\n+        int n6 = 0;\n+        int n7 = (int)abs;\n+        double n8 = 1.0;\n+        double n9 = abs - n7;\n+        double abs2 = Double.MAX_VALUE;\n+        int n10 = 1;\n+        double n11;\n+        int n12;\n         do {\n-            delta3 = delta2;\n-            a2 = (int)(x1 / y1);\n-            x2 = y1;\n-            y2 = x1 - a2 * y1;\n-            numer3 = a1 * numer2 + numer0;\n-            denom3 = a1 * denom2 + denom0;\n-            final double fraction = numer3 / (double)denom3;\n-            delta2 = Math.abs(value - fraction);\n-            a1 = a2;\n-            x1 = x2;\n-            y1 = y2;\n-            numer0 = numer2;\n-            denom0 = denom2;\n-            numer2 = numer3;\n-            denom2 = denom3;\n-            ++i;\n-        } while (delta3 > delta2 && denom3 <= 10000 && denom3 > 0 && i < 25);\n-        if (i == 25) {\n+            n11 = abs2;\n+            final int n13 = (int)(n8 / n9);\n+            final double n14 = n9;\n+            final double n15 = n8 - n13 * n9;\n+            final int n16 = n7 * n5 + n3;\n+            n12 = n7 * n6 + n4;\n+            abs2 = Math.abs(abs - n16 / (double)n12);\n+            n7 = n13;\n+            n8 = n14;\n+            n9 = n15;\n+            n3 = n5;\n+            n4 = n6;\n+            n5 = n16;\n+            n6 = n12;\n+            ++n10;\n+        } while (n11 > abs2 && n12 <= 10000 && n12 > 0 && n10 < 25);\n+        if (n10 == 25) {\n             throw new ArithmeticException(\"Unable to convert double to fraction\");\n         }\n-        return getReducedFraction((numer0 + wholeNumber * denom0) * sign, denom0);\n+        return getReducedFraction((n3 + n2 * n4) * n, n4);\n     }\n     \n-    public static Fraction getFraction(String str) {\n-        Validate.notNull((Object)str, \"The string must not be null\", new Object[0]);\n-        int pos = str.indexOf(46);\n-        if (pos >= 0) {\n-            return getFraction(Double.parseDouble(str));\n-        }\n-        pos = str.indexOf(32);\n-        if (pos > 0) {\n-            final int whole = Integer.parseInt(str.substring(0, pos));\n-            str = str.substring(pos + 1);\n-            pos = str.indexOf(47);\n-            if (pos < 0) {\n+    public static Fraction getFraction(String substring) {\n+        Validate.notNull((Object)substring, \"The string must not be null\", new Object[0]);\n+        if (substring.indexOf(46) >= 0) {\n+            return getFraction(Double.parseDouble(substring));\n+        }\n+        final int index = substring.indexOf(32);\n+        if (index > 0) {\n+            final int int1 = Integer.parseInt(substring.substring(0, index));\n+            substring = substring.substring(index + 1);\n+            final int index2 = substring.indexOf(47);\n+            if (index2 < 0) {\n                 throw new NumberFormatException(\"The fraction could not be parsed as the format X Y/Z\");\n             }\n-            final int numer = Integer.parseInt(str.substring(0, pos));\n-            final int denom = Integer.parseInt(str.substring(pos + 1));\n-            return getFraction(whole, numer, denom);\n+            return getFraction(int1, Integer.parseInt(substring.substring(0, index2)), Integer.parseInt(substring.substring(index2 + 1)));\n         }\n         else {\n-            pos = str.indexOf(47);\n-            if (pos < 0) {\n-                return getFraction(Integer.parseInt(str), 1);\n-            }\n-            final int numer2 = Integer.parseInt(str.substring(0, pos));\n-            final int denom2 = Integer.parseInt(str.substring(pos + 1));\n-            return getFraction(numer2, denom2);\n+            final int index3 = substring.indexOf(47);\n+            if (index3 < 0) {\n+                return getFraction(Integer.parseInt(substring), 1);\n+            }\n+            return getFraction(Integer.parseInt(substring.substring(0, index3)), Integer.parseInt(substring.substring(index3 + 1)));\n         }\n     }\n     \n     public int getNumerator() {\n         return this.numerator;\n     }\n     \n@@ -206,19 +196,19 @@\n         return this.numerator / (double)this.denominator;\n     }\n     \n     public Fraction reduce() {\n         if (this.numerator == 0) {\n             return this.equals(Fraction.ZERO) ? this : Fraction.ZERO;\n         }\n-        final int gcd = greatestCommonDivisor(Math.abs(this.numerator), this.denominator);\n-        if (gcd == 1) {\n+        final int greatestCommonDivisor = greatestCommonDivisor(Math.abs(this.numerator), this.denominator);\n+        if (greatestCommonDivisor == 1) {\n             return this;\n         }\n-        return getFraction(this.numerator / gcd, this.denominator / gcd);\n+        return getFraction(this.numerator / greatestCommonDivisor, this.denominator / greatestCommonDivisor);\n     }\n     \n     public Fraction invert() {\n         if (this.numerator == 0) {\n             throw new ArithmeticException(\"Unable to invert zero.\");\n         }\n         if (this.numerator == Integer.MIN_VALUE) {\n@@ -240,196 +230,194 @@\n     public Fraction abs() {\n         if (this.numerator >= 0) {\n             return this;\n         }\n         return this.negate();\n     }\n     \n-    public Fraction pow(final int power) {\n-        if (power == 1) {\n+    public Fraction pow(final int n) {\n+        if (n == 1) {\n             return this;\n         }\n-        if (power == 0) {\n+        if (n == 0) {\n             return Fraction.ONE;\n         }\n-        if (power < 0) {\n-            if (power == Integer.MIN_VALUE) {\n-                return this.invert().pow(2).pow(-(power / 2));\n+        if (n < 0) {\n+            if (n == Integer.MIN_VALUE) {\n+                return this.invert().pow(2).pow(-(n / 2));\n             }\n-            return this.invert().pow(-power);\n+            return this.invert().pow(-n);\n         }\n         else {\n-            final Fraction f = this.multiplyBy(this);\n-            if (power % 2 == 0) {\n-                return f.pow(power / 2);\n+            final Fraction multiplyBy = this.multiplyBy(this);\n+            if (n % 2 == 0) {\n+                return multiplyBy.pow(n / 2);\n             }\n-            return f.pow(power / 2).multiplyBy(this);\n+            return multiplyBy.pow(n / 2).multiplyBy(this);\n         }\n     }\n     \n-    private static int greatestCommonDivisor(int u, int v) {\n-        if (u == 0 || v == 0) {\n-            if (u == Integer.MIN_VALUE || v == Integer.MIN_VALUE) {\n+    private static int greatestCommonDivisor(int n, int n2) {\n+        if (n == 0 || n2 == 0) {\n+            if (n == Integer.MIN_VALUE || n2 == Integer.MIN_VALUE) {\n                 throw new ArithmeticException(\"overflow: gcd is 2^31\");\n             }\n-            return Math.abs(u) + Math.abs(v);\n+            return Math.abs(n) + Math.abs(n2);\n         }\n         else {\n-            if (Math.abs(u) == 1 || Math.abs(v) == 1) {\n+            if (Math.abs(n) == 1 || Math.abs(n2) == 1) {\n                 return 1;\n             }\n-            if (u > 0) {\n-                u = -u;\n+            if (n > 0) {\n+                n = -n;\n             }\n-            if (v > 0) {\n-                v = -v;\n+            if (n2 > 0) {\n+                n2 = -n2;\n             }\n-            int k;\n-            for (k = 0; (u & 0x1) == 0x0 && (v & 0x1) == 0x0 && k < 31; u /= 2, v /= 2, ++k) {}\n-            if (k == 31) {\n+            int n3;\n+            for (n3 = 0; (n & 0x1) == 0x0 && (n2 & 0x1) == 0x0 && n3 < 31; n /= 2, n2 /= 2, ++n3) {}\n+            if (n3 == 31) {\n                 throw new ArithmeticException(\"overflow: gcd is 2^31\");\n             }\n-            int t = ((u & 0x1) == 0x1) ? v : (-(u / 2));\n+            int n4 = ((n & 0x1) == 0x1) ? n2 : (-(n / 2));\n             while (true) {\n-                if ((t & 0x1) == 0x0) {\n-                    t /= 2;\n+                if ((n4 & 0x1) == 0x0) {\n+                    n4 /= 2;\n                 }\n                 else {\n-                    if (t > 0) {\n-                        u = -t;\n+                    if (n4 > 0) {\n+                        n = -n4;\n                     }\n                     else {\n-                        v = t;\n+                        n2 = n4;\n                     }\n-                    t = (v - u) / 2;\n-                    if (t == 0) {\n+                    n4 = (n2 - n) / 2;\n+                    if (n4 == 0) {\n                         break;\n                     }\n                     continue;\n                 }\n             }\n-            return -u * (1 << k);\n+            return -n * (1 << n3);\n         }\n     }\n     \n-    private static int mulAndCheck(final int x, final int y) {\n-        final long m = x * (long)y;\n-        if (m < -2147483648L || m > 2147483647L) {\n+    private static int mulAndCheck(final int n, final int n2) {\n+        final long n3 = n * (long)n2;\n+        if (n3 < -2147483648L || n3 > 2147483647L) {\n             throw new ArithmeticException(\"overflow: mul\");\n         }\n-        return (int)m;\n+        return (int)n3;\n     }\n     \n-    private static int mulPosAndCheck(final int x, final int y) {\n-        final long m = x * (long)y;\n-        if (m > 2147483647L) {\n+    private static int mulPosAndCheck(final int n, final int n2) {\n+        final long n3 = n * (long)n2;\n+        if (n3 > 2147483647L) {\n             throw new ArithmeticException(\"overflow: mulPos\");\n         }\n-        return (int)m;\n+        return (int)n3;\n     }\n     \n-    private static int addAndCheck(final int x, final int y) {\n-        final long s = x + (long)y;\n-        if (s < -2147483648L || s > 2147483647L) {\n+    private static int addAndCheck(final int n, final int n2) {\n+        final long n3 = n + (long)n2;\n+        if (n3 < -2147483648L || n3 > 2147483647L) {\n             throw new ArithmeticException(\"overflow: add\");\n         }\n-        return (int)s;\n+        return (int)n3;\n     }\n     \n-    private static int subAndCheck(final int x, final int y) {\n-        final long s = x - (long)y;\n-        if (s < -2147483648L || s > 2147483647L) {\n+    private static int subAndCheck(final int n, final int n2) {\n+        final long n3 = n - (long)n2;\n+        if (n3 < -2147483648L || n3 > 2147483647L) {\n             throw new ArithmeticException(\"overflow: add\");\n         }\n-        return (int)s;\n+        return (int)n3;\n     }\n     \n     public Fraction add(final Fraction fraction) {\n         return this.addSub(fraction, true);\n     }\n     \n     public Fraction subtract(final Fraction fraction) {\n         return this.addSub(fraction, false);\n     }\n     \n-    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n+    private Fraction addSub(final Fraction fraction, final boolean b) {\n         Validate.notNull((Object)fraction, \"The fraction must not be null\", new Object[0]);\n         if (this.numerator == 0) {\n-            return isAdd ? fraction : fraction.negate();\n+            return b ? fraction : fraction.negate();\n         }\n         if (fraction.numerator == 0) {\n             return this;\n         }\n-        final int d1 = greatestCommonDivisor(this.denominator, fraction.denominator);\n-        if (d1 == 1) {\n-            final int uvp = mulAndCheck(this.numerator, fraction.denominator);\n-            final int upv = mulAndCheck(fraction.numerator, this.denominator);\n-            return new Fraction(isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv), mulPosAndCheck(this.denominator, fraction.denominator));\n-        }\n-        final BigInteger uvp2 = BigInteger.valueOf(this.numerator).multiply(BigInteger.valueOf((long)(fraction.denominator / d1)));\n-        final BigInteger upv2 = BigInteger.valueOf(fraction.numerator).multiply(BigInteger.valueOf((long)(this.denominator / d1)));\n-        final BigInteger t = isAdd ? uvp2.add(upv2) : uvp2.subtract(upv2);\n-        final int tmodd1 = t.mod(BigInteger.valueOf((long)d1)).intValue();\n-        final int d2 = (tmodd1 == 0) ? d1 : greatestCommonDivisor(tmodd1, d1);\n-        final BigInteger w = t.divide(BigInteger.valueOf((long)d2));\n-        if (w.bitLength() > 31) {\n+        final int greatestCommonDivisor = greatestCommonDivisor(this.denominator, fraction.denominator);\n+        if (greatestCommonDivisor == 1) {\n+            final int mulAndCheck = mulAndCheck(this.numerator, fraction.denominator);\n+            final int mulAndCheck2 = mulAndCheck(fraction.numerator, this.denominator);\n+            return new Fraction(b ? addAndCheck(mulAndCheck, mulAndCheck2) : subAndCheck(mulAndCheck, mulAndCheck2), mulPosAndCheck(this.denominator, fraction.denominator));\n+        }\n+        final BigInteger multiply = BigInteger.valueOf(this.numerator).multiply(BigInteger.valueOf((long)(fraction.denominator / greatestCommonDivisor)));\n+        final BigInteger multiply2 = BigInteger.valueOf(fraction.numerator).multiply(BigInteger.valueOf((long)(this.denominator / greatestCommonDivisor)));\n+        final BigInteger bigInteger = b ? multiply.add(multiply2) : multiply.subtract(multiply2);\n+        final int intValue = bigInteger.mod(BigInteger.valueOf((long)greatestCommonDivisor)).intValue();\n+        final int n = (intValue == 0) ? greatestCommonDivisor : greatestCommonDivisor(intValue, greatestCommonDivisor);\n+        final BigInteger divide = bigInteger.divide(BigInteger.valueOf((long)n));\n+        if (divide.bitLength() > 31) {\n             throw new ArithmeticException(\"overflow: numerator too large after multiply\");\n         }\n-        return new Fraction(w.intValue(), mulPosAndCheck(this.denominator / d1, fraction.denominator / d2));\n+        return new Fraction(divide.intValue(), mulPosAndCheck(this.denominator / greatestCommonDivisor, fraction.denominator / n));\n     }\n     \n     public Fraction multiplyBy(final Fraction fraction) {\n         Validate.notNull((Object)fraction, \"The fraction must not be null\", new Object[0]);\n         if (this.numerator == 0 || fraction.numerator == 0) {\n             return Fraction.ZERO;\n         }\n-        final int d1 = greatestCommonDivisor(this.numerator, fraction.denominator);\n-        final int d2 = greatestCommonDivisor(fraction.numerator, this.denominator);\n-        return getReducedFraction(mulAndCheck(this.numerator / d1, fraction.numerator / d2), mulPosAndCheck(this.denominator / d2, fraction.denominator / d1));\n+        final int greatestCommonDivisor = greatestCommonDivisor(this.numerator, fraction.denominator);\n+        final int greatestCommonDivisor2 = greatestCommonDivisor(fraction.numerator, this.denominator);\n+        return getReducedFraction(mulAndCheck(this.numerator / greatestCommonDivisor, fraction.numerator / greatestCommonDivisor2), mulPosAndCheck(this.denominator / greatestCommonDivisor2, fraction.denominator / greatestCommonDivisor));\n     }\n     \n     public Fraction divideBy(final Fraction fraction) {\n         Validate.notNull((Object)fraction, \"The fraction must not be null\", new Object[0]);\n         if (fraction.numerator == 0) {\n             throw new ArithmeticException(\"The fraction to divide by must not be zero\");\n         }\n         return this.multiplyBy(fraction.invert());\n     }\n     \n     @Override\n-    public boolean equals(final Object obj) {\n-        if (obj == this) {\n+    public boolean equals(final Object o) {\n+        if (o == this) {\n             return true;\n         }\n-        if (!(obj instanceof Fraction)) {\n+        if (!(o instanceof Fraction)) {\n             return false;\n         }\n-        final Fraction other = (Fraction)obj;\n-        return this.getNumerator() == other.getNumerator() && this.getDenominator() == other.getDenominator();\n+        final Fraction fraction = (Fraction)o;\n+        return this.getNumerator() == fraction.getNumerator() && this.getDenominator() == fraction.getDenominator();\n     }\n     \n     @Override\n     public int hashCode() {\n         if (this.hashCode == 0) {\n             this.hashCode = 37 * (629 + this.getNumerator()) + this.getDenominator();\n         }\n         return this.hashCode;\n     }\n     \n     @Override\n-    public int compareTo(final Fraction other) {\n-        if (this == other) {\n+    public int compareTo(final Fraction fraction) {\n+        if (this == fraction) {\n             return 0;\n         }\n-        if (this.numerator == other.numerator && this.denominator == other.denominator) {\n+        if (this.numerator == fraction.numerator && this.denominator == fraction.denominator) {\n             return 0;\n         }\n-        final long first = this.numerator * (long)other.denominator;\n-        final long second = other.numerator * (long)this.denominator;\n-        return Long.compare(first, second);\n+        return Long.compare((long)this.numerator * (long)fraction.denominator, (long)fraction.numerator * (long)this.denominator);\n     }\n     \n     @Override\n     public String toString() {\n         if (this.toString == null) {\n             this.toString = this.getNumerator() + \"/\" + this.getDenominator();\n         }\n"}]}
