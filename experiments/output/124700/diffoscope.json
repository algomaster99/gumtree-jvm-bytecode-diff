{"diffoscope-json-version": 1, "source1": "first/SiteUtil.class", "source2": "second/SiteUtil.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,14 +1,10 @@\n \n package com.puppycrawl.tools.checkstyle.site;\n \n-import java.util.HashMap;\n-import com.puppycrawl.tools.checkstyle.api.BeforeExecutionFileFilter;\n-import com.puppycrawl.tools.checkstyle.api.Filter;\n-import com.puppycrawl.tools.checkstyle.TreeWalkerFilter;\n import java.nio.file.attribute.BasicFileAttributes;\n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.InvocationTargetException;\n import java.util.BitSet;\n import java.util.function.ToIntFunction;\n import java.util.stream.IntStream;\n import java.util.function.IntFunction;\n@@ -16,38 +12,31 @@\n import java.lang.reflect.Array;\n import java.util.function.Function;\n import com.puppycrawl.tools.checkstyle.checks.naming.AccessModifierOption;\n import java.util.regex.Pattern;\n import java.net.URI;\n import com.puppycrawl.tools.checkstyle.PropertyCacheFile;\n import java.util.function.Supplier;\n-import java.util.Objects;\n import com.puppycrawl.tools.checkstyle.XdocsPropertyType;\n import java.util.Optional;\n import com.puppycrawl.tools.checkstyle.utils.JavadocUtil;\n import java.util.Arrays;\n-import com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\n-import com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\n-import com.puppycrawl.tools.checkstyle.api.AbstractCheck;\n import java.beans.PropertyDescriptor;\n import org.apache.commons.beanutils.PropertyUtils;\n import com.puppycrawl.tools.checkstyle.api.Configuration;\n import java.nio.charset.StandardCharsets;\n-import com.puppycrawl.tools.checkstyle.TreeWalker;\n import com.puppycrawl.tools.checkstyle.DefaultConfiguration;\n-import com.puppycrawl.tools.checkstyle.Checker;\n import com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n import java.util.LinkedHashMap;\n import java.util.stream.Stream;\n import java.io.IOException;\n import java.util.stream.Collector;\n import java.util.stream.Collectors;\n import java.nio.file.Files;\n import java.nio.file.FileVisitOption;\n-import java.nio.file.Paths;\n import java.nio.file.Path;\n import com.puppycrawl.tools.checkstyle.PackageNamesLoader;\n import com.puppycrawl.tools.checkstyle.PackageObjectFactory;\n import com.puppycrawl.tools.checkstyle.ModuleFactory;\n import com.puppycrawl.tools.checkstyle.api.CheckstyleException;\n import java.util.Locale;\n import com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck;\n@@ -55,14 +44,24 @@\n import com.puppycrawl.tools.checkstyle.checks.regexp.RegexpMultilineCheck;\n import java.util.Collection;\n import java.util.HashSet;\n import org.apache.maven.doxia.macro.MacroExecutionException;\n import java.util.Iterator;\n import java.lang.reflect.Field;\n import java.util.TreeSet;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\n+import com.puppycrawl.tools.checkstyle.api.BeforeExecutionFileFilter;\n+import com.puppycrawl.tools.checkstyle.api.Filter;\n+import com.puppycrawl.tools.checkstyle.Checker;\n+import com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\n+import com.puppycrawl.tools.checkstyle.TreeWalkerFilter;\n+import com.puppycrawl.tools.checkstyle.TreeWalker;\n+import com.puppycrawl.tools.checkstyle.api.AbstractCheck;\n import java.io.File;\n import java.util.List;\n import com.puppycrawl.tools.checkstyle.api.DetailNode;\n import java.util.Set;\n import java.util.Map;\n \n public final class SiteUtil\n@@ -88,14 +87,27 @@\n     private static final Set<String> UNDOCUMENTED_PROPERTIES;\n     private static final Set<String> PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD;\n     private static final Map<String, String> SINCE_VERSION_FOR_INHERITED_PROPERTY;\n     private static final Map<String, DetailNode> SUPER_CLASS_PROPERTIES_JAVADOCS;\n     private static final String MAIN_FOLDER_PATH;\n     private static final List<File> MODULE_SUPER_CLASS_FILES;\n     \n+    static {\n+        CLASS_TO_PARENT_MODULE = Map.ofEntries(Map.entry(AbstractCheck.class, TreeWalker.class.getSimpleName()), Map.entry(TreeWalkerFilter.class, TreeWalker.class.getSimpleName()), Map.entry(AbstractFileSetCheck.class, Checker.class.getSimpleName()), Map.entry(Filter.class, Checker.class.getSimpleName()), Map.entry(BeforeExecutionFileFilter.class, Checker.class.getSimpleName()));\n+        CHECK_PROPERTIES = getProperties(AbstractCheck.class);\n+        JAVADOC_CHECK_PROPERTIES = getProperties(AbstractJavadocCheck.class);\n+        FILESET_PROPERTIES = getProperties(AbstractFileSetCheck.class);\n+        UNDOCUMENTED_PROPERTIES = Set.of(\"SuppressWithNearbyCommentFilter.fileContents\", \"SuppressionCommentFilter.fileContents\");\n+        PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD = Set.of(\"SuppressWarningsHolderCheck.aliasList\", \"HeaderCheck.header\", \"RegexpHeaderCheck.header\", \"CustomImportOrderCheck.customImportOrderRules\");\n+        SINCE_VERSION_FOR_INHERITED_PROPERTY = Map.ofEntries(Map.entry(\"MissingDeprecatedCheck.violateExecutionOnNonTightHtml\", \"8.24\"), Map.entry(\"NonEmptyAtclauseDescriptionCheck.violateExecutionOnNonTightHtml\", \"8.3\"), Map.entry(\"NonEmptyAtclauseDescriptionCheck.javadocTokens\", \"7.3\"));\n+        SUPER_CLASS_PROPERTIES_JAVADOCS = new HashMap<String, DetailNode>();\n+        MAIN_FOLDER_PATH = Paths.get(\"src\", \"main\", \"java\", \"com\", \"puppycrawl\", \"tools\", \"checkstyle\").toString();\n+        MODULE_SUPER_CLASS_FILES = List.of(new File(Paths.get(SiteUtil.MAIN_FOLDER_PATH, \"checks\", \"naming\", \"AbstractAccessControlNameCheck.java\").toString()), new File(Paths.get(SiteUtil.MAIN_FOLDER_PATH, \"checks\", \"naming\", \"AbstractNameCheck.java\").toString()), new File(Paths.get(SiteUtil.MAIN_FOLDER_PATH, \"checks\", \"javadoc\", \"AbstractJavadocCheck.java\").toString()), new File(Paths.get(SiteUtil.MAIN_FOLDER_PATH, \"api\", \"AbstractFileSetCheck.java\").toString()), new File(Paths.get(SiteUtil.MAIN_FOLDER_PATH, \"checks\", \"header\", \"AbstractHeaderCheck.java\").toString()));\n+    }\n+    \n     private SiteUtil() {\n     }\n     \n     public static Set<String> getMessageKeys(final Class<?> module) throws MacroExecutionException {\n         final Set<Field> messageKeyFields = getCheckMessageKeys(module);\n         final Set<String> messageKeys = new TreeSet<String>();\n         for (final Field field : messageKeyFields) {\n@@ -103,17 +115,18 @@\n         }\n         return messageKeys;\n     }\n     \n     private static Set<Field> getCheckMessageKeys(final Class<?> module) throws MacroExecutionException {\n         try {\n             final Set<Field> checkstyleMessages = new HashSet<Field>();\n-            final Field[] declaredFields;\n-            final Field[] fields = declaredFields = module.getDeclaredFields();\n-            for (final Field field : declaredFields) {\n+            final Field[] fields = module.getDeclaredFields();\n+            Field[] array;\n+            for (int length = (array = fields).length, i = 0; i < length; ++i) {\n+                final Field field = array[i];\n                 if (field.getName().startsWith(\"MSG_\")) {\n                     checkstyleMessages.add(field);\n                 }\n             }\n             final Class<?> superModule = module.getSuperclass();\n             if (superModule != null) {\n                 checkstyleMessages.addAll(getCheckMessageKeys(superModule));\n@@ -160,27 +173,49 @@\n         }\n         catch (final CheckstyleException ex) {\n             throw new MacroExecutionException(\"Couldn't load checkstyle modules\", (Throwable)ex);\n         }\n     }\n     \n     public static String getNewlineAndIndentSpaces(final int amountOfSpaces) {\n-        return System.lineSeparator() + \" \".repeat(amountOfSpaces);\n+        return String.valueOf(System.lineSeparator()) + \" \".repeat(amountOfSpaces);\n     }\n     \n     public static Path getTemplatePath(final String moduleName) throws MacroExecutionException {\n         final String fileNamePattern = \".*[\\\\\\\\/]\" + moduleName.toLowerCase(Locale.ROOT) + \"\\\\..*\";\n-        return getXdocsTemplatesFilePaths().stream().filter(path -> path.toString().matches(fileNamePattern)).findFirst().orElse(null);\n+        return getXdocsTemplatesFilePaths().stream().filter(path -> path.toString().matches(regex)).findFirst().orElse(null);\n     }\n     \n     public static Set<Path> getXdocsTemplatesFilePaths() throws MacroExecutionException {\n         final Path directory = Paths.get(\"src/xdocs\", new String[0]);\n-        try (final Stream<Path> stream = Files.find(directory, Integer.MAX_VALUE, (path, attr) -> attr.isRegularFile() && path.toString().endsWith(\".xml.template\"), new FileVisitOption[0])) {\n-            final Set<? super Path> set = (Set<? super Path>)stream.collect((Collector<? super Path, ?, Set<? super Path>>)Collectors.toSet());\n-            return (Set<Path>)set;\n+        try {\n+            Throwable t = null;\n+            try {\n+                final Stream<Path> stream = Files.find(directory, Integer.MAX_VALUE, (path, attr) -> attr.isRegularFile() && path.toString().endsWith(\".xml.template\"), new FileVisitOption[0]);\n+                try {\n+                    return stream.collect((Collector<? super Path, ?, Set<Path>>)Collectors.toSet());\n+                }\n+                finally {\n+                    if (stream != null) {\n+                        stream.close();\n+                    }\n+                }\n+            }\n+            finally {\n+                if (t == null) {\n+                    final Throwable exception;\n+                    t = exception;\n+                }\n+                else {\n+                    final Throwable exception;\n+                    if (t != exception) {\n+                        t.addSuppressed(exception);\n+                    }\n+                }\n+            }\n         }\n         catch (final IOException ioException) {\n             throw new MacroExecutionException(\"Failed to find xdocs templates\", (Throwable)ioException);\n         }\n     }\n     \n     public static String getParentModule(final Class<?> moduleClass) throws MacroExecutionException {\n@@ -188,47 +223,48 @@\n         for (Class<?> parentClass = moduleClass.getSuperclass(); parentClass != null; parentClass = parentClass.getSuperclass()) {\n             parentModuleName = SiteUtil.CLASS_TO_PARENT_MODULE.get(parentClass);\n             if (parentModuleName != null) {\n                 break;\n             }\n         }\n         if (parentModuleName == null || parentModuleName.isEmpty()) {\n-            final Class<?>[] interfaces2;\n-            final Class<?>[] interfaces = interfaces2 = moduleClass.getInterfaces();\n-            for (final Class<?> interfaceClass : interfaces2) {\n+            final Class[] interfaces = moduleClass.getInterfaces();\n+            Class[] array;\n+            for (int length = (array = interfaces).length, i = 0; i < length; ++i) {\n+                final Class<?> interfaceClass = array[i];\n                 parentModuleName = SiteUtil.CLASS_TO_PARENT_MODULE.get(interfaceClass);\n                 if (parentModuleName != null) {\n                     break;\n                 }\n             }\n         }\n         if (parentModuleName == null || parentModuleName.isEmpty()) {\n             final String message = String.format(Locale.ROOT, \"Failed to find parent module for %s\", moduleClass.getSimpleName());\n             throw new MacroExecutionException(message);\n         }\n         return parentModuleName;\n     }\n     \n     public static Set<String> getPropertiesForDocumentation(final Class<?> clss, final Object instance) {\n-        final Set<String> properties = (Set<String>)getProperties(clss).stream().filter(prop -> !isGlobalProperty(clss, prop) && !isUndocumentedProperty(clss, prop)).collect((Collector<? super Object, ?, Set<String>>)Collectors.toSet());\n+        final Set<String> properties = (Set<String>)getProperties(clss).stream().filter(prop -> !isGlobalProperty(clazz, prop) && !isUndocumentedProperty(clazz, prop)).collect((Collector<? super Object, ?, Set<String>>)Collectors.toSet());\n         properties.addAll(getNonExplicitProperties(instance, clss));\n         return new TreeSet<String>(properties);\n     }\n     \n     public static Map<String, DetailNode> getPropertiesJavadocs(final Set<String> properties, final String moduleName, final File moduleFile) throws MacroExecutionException {\n         if (SiteUtil.SUPER_CLASS_PROPERTIES_JAVADOCS.isEmpty()) {\n             processSuperclasses();\n         }\n         processModule(moduleName, moduleFile);\n         final Map<String, DetailNode> unmodifiableJavadocs = ClassAndPropertiesSettersJavadocScraper.getJavadocsForModuleOrProperty();\n         final Map<String, DetailNode> javadocs = new LinkedHashMap<String, DetailNode>(unmodifiableJavadocs);\n         properties.forEach(property -> {\n             final DetailNode superClassPropertyJavadoc = (DetailNode)SiteUtil.SUPER_CLASS_PROPERTIES_JAVADOCS.get(property);\n             if (superClassPropertyJavadoc != null) {\n-                javadocs.putIfAbsent(property, superClassPropertyJavadoc);\n+                map.putIfAbsent(property, superClassPropertyJavadoc);\n             }\n             return;\n         });\n         assertAllPropertySetterJavadocsAreFound(properties, moduleName, javadocs);\n         return javadocs;\n     }\n     \n@@ -275,30 +311,31 @@\n             final String message2 = String.format(Locale.ROOT, \"Failed processing %s\", moduleName);\n             throw new MacroExecutionException(message2, (Throwable)checkstyleException);\n         }\n     }\n     \n     public static Set<String> getProperties(final Class<?> clss) {\n         final Set<String> result = new TreeSet<String>();\n-        final PropertyDescriptor[] propertyDescriptors2;\n-        final PropertyDescriptor[] propertyDescriptors = propertyDescriptors2 = PropertyUtils.getPropertyDescriptors((Class)clss);\n-        for (final PropertyDescriptor propertyDescriptor : propertyDescriptors2) {\n+        final PropertyDescriptor[] propertyDescriptors = PropertyUtils.getPropertyDescriptors((Class)clss);\n+        PropertyDescriptor[] array;\n+        for (int length = (array = propertyDescriptors).length, i = 0; i < length; ++i) {\n+            final PropertyDescriptor propertyDescriptor = array[i];\n             if (propertyDescriptor.getWriteMethod() != null) {\n                 result.add(propertyDescriptor.getName());\n             }\n         }\n         return result;\n     }\n     \n     private static boolean isGlobalProperty(final Class<?> clss, final String propertyName) {\n         return (AbstractCheck.class.isAssignableFrom(clss) && SiteUtil.CHECK_PROPERTIES.contains(propertyName)) || (AbstractJavadocCheck.class.isAssignableFrom(clss) && SiteUtil.JAVADOC_CHECK_PROPERTIES.contains(propertyName)) || (AbstractFileSetCheck.class.isAssignableFrom(clss) && SiteUtil.FILESET_PROPERTIES.contains(propertyName));\n     }\n     \n     private static boolean isUndocumentedProperty(final Class<?> clss, final String propertyName) {\n-        return SiteUtil.UNDOCUMENTED_PROPERTIES.contains(clss.getSimpleName() + \".\" + propertyName);\n+        return SiteUtil.UNDOCUMENTED_PROPERTIES.contains(String.valueOf(clss.getSimpleName()) + \".\" + propertyName);\n     }\n     \n     private static Set<String> getNonExplicitProperties(final Object instance, final Class<?> clss) {\n         final Set<String> result = new TreeSet<String>();\n         if (AbstractCheck.class.isAssignableFrom(clss)) {\n             final AbstractCheck check = (AbstractCheck)instance;\n             final int[] acceptableTokens = check.getAcceptableTokens();\n@@ -337,23 +374,23 @@\n         }\n         else if (\"javadocTokens\".equals(propertyName)) {\n             description = \"javadoc tokens to check\";\n         }\n         else {\n             final String descriptionString = SiteUtil.DescriptionExtractor.getDescriptionFromJavadoc(javadoc, moduleName).substring(\"Setter to \".length());\n             final String firstLetterCapitalized = descriptionString.substring(0, 1).toUpperCase(Locale.ROOT);\n-            description = firstLetterCapitalized + descriptionString.substring(1);\n+            description = String.valueOf(firstLetterCapitalized) + descriptionString.substring(1);\n         }\n         return description;\n     }\n     \n     public static String getSinceVersion(final String moduleName, final DetailNode moduleJavadoc, final String propertyName, final DetailNode propertyJavadoc) throws MacroExecutionException {\n         String sinceVersion;\n-        if (SiteUtil.SINCE_VERSION_FOR_INHERITED_PROPERTY.containsKey(moduleName + \".\" + propertyName)) {\n-            sinceVersion = SiteUtil.SINCE_VERSION_FOR_INHERITED_PROPERTY.get(moduleName + \".\" + propertyName);\n+        if (SiteUtil.SINCE_VERSION_FOR_INHERITED_PROPERTY.containsKey(String.valueOf(moduleName) + \".\" + propertyName)) {\n+            sinceVersion = SiteUtil.SINCE_VERSION_FOR_INHERITED_PROPERTY.get(String.valueOf(moduleName) + \".\" + propertyName);\n         }\n         else if (SiteUtil.SUPER_CLASS_PROPERTIES_JAVADOCS.containsKey(propertyName) || \"tokens\".equals(propertyName) || \"javadocTokens\".equals(propertyName)) {\n             sinceVersion = getSinceVersionFromJavadoc(moduleJavadoc);\n         }\n         else {\n             sinceVersion = getSinceVersionFromJavadoc(propertyJavadoc);\n         }\n@@ -370,32 +407,31 @@\n         final DetailNode text = JavadocUtil.findFirstToken(description, 10074);\n         return text.getText();\n     }\n     \n     private static DetailNode getSinceJavadocTag(final DetailNode javadoc) {\n         final DetailNode[] children = javadoc.getChildren();\n         DetailNode javadocTagWithSince = null;\n-        for (final DetailNode child : children) {\n+        DetailNode[] array;\n+        for (int length = (array = children).length, i = 0; i < length; ++i) {\n+            final DetailNode child = array[i];\n             if (child.getType() == 10071) {\n                 final DetailNode sinceNode = JavadocUtil.findFirstToken(child, 16);\n                 if (sinceNode != null) {\n                     javadocTagWithSince = child;\n                     break;\n                 }\n             }\n         }\n         return javadocTagWithSince;\n     }\n     \n     public static String getType(final Field field, final String propertyName, final String moduleName, final Object instance) throws MacroExecutionException {\n         final Class<?> fieldClass = getFieldClass(field, propertyName, moduleName, instance);\n-        final Optional<Object> map = Optional.ofNullable(field).map(nonNullField -> (XdocsPropertyType)nonNullField.getAnnotation(XdocsPropertyType.class)).map(propertyType -> propertyType.value().getDescription());\n-        final Class<?> obj = fieldClass;\n-        Objects.requireNonNull(obj);\n-        return map.orElseGet(obj::getSimpleName);\n+        return Optional.ofNullable(field).map(nonNullField -> (XdocsPropertyType)nonNullField.getAnnotation(XdocsPropertyType.class)).map(propertyType -> propertyType.value().getDescription()).orElseGet(fieldClass::getSimpleName);\n     }\n     \n     public static String getDefaultValue(final String propertyName, final Field field, final Object classInstance, final String moduleName) throws MacroExecutionException {\n         final Object value = getFieldValue(field, classInstance);\n         final Class<?> fieldClass = getFieldClass(field, propertyName, moduleName, classInstance);\n         String result = null;\n         if (\"charset\".equals(propertyName)) {\n@@ -420,20 +456,20 @@\n             }\n         }\n         else if (fieldClass == String[].class) {\n             result = getStringArrayPropertyValue(propertyName, value);\n         }\n         else if (fieldClass == URI.class || fieldClass == String.class) {\n             if (value != null) {\n-                result = \"\\\"\" + value.toString();\n+                result = String.valueOf('\\\"') + value.toString() + '\\\"';\n             }\n         }\n         else if (fieldClass == Pattern.class) {\n             if (value != null) {\n-                result = \"\\\"\" + value.toString().replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\").replace(\"\\r\", \"\\\\r\").replace((CharSequence)\"\\f\", (CharSequence)\"\\\\f\");\n+                result = String.valueOf('\\\"') + value.toString().replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\").replace(\"\\r\", \"\\\\r\").replace((CharSequence)\"\\f\", (CharSequence)\"\\\\f\") + '\\\"';\n             }\n         }\n         else if (fieldClass == Pattern[].class) {\n             result = getPatternArrayPropertyValue(value);\n         }\n         else if (fieldClass.isEnum()) {\n             if (value != null) {\n@@ -453,18 +489,15 @@\n         return result;\n     }\n     \n     private static String getPatternArrayPropertyValue(final Object fieldValue) {\n         Object value = fieldValue;\n         if (value instanceof Collection) {\n             final Collection<?> collection = (Collection)value;\n-            final Stream<?> stream = collection.stream();\n-            final Class<Pattern> obj = Pattern.class;\n-            Objects.requireNonNull(obj);\n-            value = stream.map((Function<?, ?>)obj::cast).toArray(Pattern[]::new);\n+            value = collection.stream().map((Function<?, ?>)Pattern.class::cast).toArray(Pattern[]::new);\n         }\n         String result = \"\";\n         if (value != null && Array.getLength(value) > 0) {\n             result = removeSquareBrackets(Arrays.stream((Pattern[])value).map((Function<? super Pattern, ?>)Pattern::pattern).collect((Collector<? super Object, ?, String>)Collectors.joining(\", \")));\n         }\n         if (result.isEmpty()) {\n             result = \"{}\";\n@@ -478,19 +511,37 @@\n     \n     private static String getStringArrayPropertyValue(final String propertyName, final Object value) {\n         String result;\n         if (value == null) {\n             result = \"\";\n         }\n         else {\n-            try (final Stream<?> valuesStream = getValuesStream(value)) {\n-                final Stream<?> stream = valuesStream;\n-                final Class<String> obj = String.class;\n-                Objects.requireNonNull(obj);\n-                result = stream.map((Function<?, ?>)obj::cast).sorted().collect((Collector<? super Object, ?, String>)Collectors.joining(\", \"));\n+            Throwable t = null;\n+            try {\n+                final Stream<?> valuesStream = getValuesStream(value);\n+                try {\n+                    result = valuesStream.map((Function<?, ?>)String.class::cast).sorted().collect((Collector<? super Object, ?, String>)Collectors.joining(\", \"));\n+                }\n+                finally {\n+                    if (valuesStream != null) {\n+                        valuesStream.close();\n+                    }\n+                }\n+            }\n+            finally {\n+                if (t == null) {\n+                    final Throwable exception;\n+                    t = exception;\n+                }\n+                else {\n+                    final Throwable exception;\n+                    if (t != exception) {\n+                        t.addSuppressed(exception);\n+                    }\n+                }\n             }\n         }\n         if (result.isEmpty()) {\n             if (\"fileExtensions\".equals(propertyName)) {\n                 result = \"all files\";\n             }\n             else {\n@@ -510,31 +561,49 @@\n             final Object[] array = (Object[])value;\n             valuesStream = Arrays.stream(array);\n         }\n         return valuesStream;\n     }\n     \n     private static String getIntArrayPropertyValue(final Object value) {\n-        try (final IntStream stream = getIntStream(value)) {\n-            String result = (String)stream.mapToObj((IntFunction<?>)TokenUtil::getTokenName).sorted().collect((Collector<? super Object, ?, String>)Collectors.joining(\", \"));\n-            if (result.isEmpty()) {\n-                result = \"{}\";\n+        Throwable t = null;\n+        try {\n+            final IntStream stream = getIntStream(value);\n+            try {\n+                String result = (String)stream.mapToObj((IntFunction<?>)TokenUtil::getTokenName).sorted().collect((Collector<? super Object, ?, String>)Collectors.joining(\", \"));\n+                if (result.isEmpty()) {\n+                    result = \"{}\";\n+                }\n+                return result;\n+            }\n+            finally {\n+                if (stream != null) {\n+                    stream.close();\n+                }\n+            }\n+        }\n+        finally {\n+            if (t == null) {\n+                final Throwable exception;\n+                t = exception;\n+            }\n+            else {\n+                final Throwable exception;\n+                if (t != exception) {\n+                    t.addSuppressed(exception);\n+                }\n             }\n-            return result;\n         }\n     }\n     \n     private static IntStream getIntStream(final Object value) {\n         IntStream stream;\n         if (value instanceof Collection) {\n             final Collection<?> collection = (Collection)value;\n-            final Stream<?> stream2 = collection.stream();\n-            final Class<Integer> type = Integer.TYPE;\n-            Objects.requireNonNull(type);\n-            stream = stream2.mapToInt(type::cast);\n+            stream = collection.stream().mapToInt(Integer.TYPE::cast);\n         }\n         else if (value instanceof BitSet) {\n             stream = ((BitSet)value).stream();\n         }\n         else {\n             stream = Arrays.stream((int[])value);\n         }\n@@ -543,15 +612,15 @@\n     \n     private static Class<?> getFieldClass(final Field field, final String propertyName, final String moduleName, final Object instance) throws MacroExecutionException {\n         Class<?> result = null;\n         if (field != null) {\n             result = field.getType();\n         }\n         if (result == null) {\n-            if (!SiteUtil.PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD.contains(moduleName + \".\" + propertyName)) {\n+            if (!SiteUtil.PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD.contains(String.valueOf(moduleName) + \".\" + propertyName)) {\n                 throw new MacroExecutionException(\"Could not find field \" + propertyName + \" in class \" + moduleName);\n             }\n             try {\n                 final PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(instance, propertyName);\n                 result = descriptor.getPropertyType();\n             }\n             catch (final IllegalAccessException | InvocationTargetException | NoSuchMethodException exc) {\n@@ -579,30 +648,29 @@\n             result = int[].class;\n         }\n         return result;\n     }\n     \n     public static List<Integer> getDifference(final int[] tokens, final int... subtractions) {\n         final Set<Integer> subtractionsSet = (Set<Integer>)Arrays.stream(subtractions).boxed().collect((Collector<? super Integer, ?, Set<Integer>>)Collectors.toSet());\n-        return Arrays.stream(tokens).boxed().filter(token -> !subtractionsSet.contains(token)).collect((Collector<? super Integer, ?, List<Integer>>)Collectors.toList());\n+        return Arrays.stream(tokens).boxed().filter(token -> !set.contains(token)).collect((Collector<? super Integer, ?, List<Integer>>)Collectors.toList());\n     }\n     \n     public static Field getField(final Class<?> fieldClass, final String propertyName) {\n         Field result = null;\n         Class<?> currentClass = fieldClass;\n         while (!Object.class.equals(currentClass)) {\n             try {\n                 result = currentClass.getDeclaredField(propertyName);\n                 result.trySetAccessible();\n+                break;\n             }\n             catch (final NoSuchFieldException ignored) {\n                 currentClass = currentClass.getSuperclass();\n-                continue;\n             }\n-            break;\n         }\n         return result;\n     }\n     \n     public static String getLinkToDocument(final String moduleName, final String document) throws MacroExecutionException {\n         final Path templatePath = getTemplatePath(moduleName.replace((CharSequence)\"Check\", (CharSequence)\"\"));\n         if (templatePath == null) {\n@@ -610,21 +678,8 @@\n         }\n         final Path templatePathParent = templatePath.getParent();\n         if (templatePathParent == null) {\n             throw new MacroExecutionException(\"Failed to get parent path for \" + templatePath);\n         }\n         return templatePathParent.relativize(Paths.get(\"src\", \"xdocs\", document)).toString().replace(\".xml\", \".html\").replace('\\\\', '/');\n     }\n-    \n-    static {\n-        CLASS_TO_PARENT_MODULE = Map.ofEntries(Map.entry(AbstractCheck.class, TreeWalker.class.getSimpleName()), Map.entry(TreeWalkerFilter.class, TreeWalker.class.getSimpleName()), Map.entry(AbstractFileSetCheck.class, Checker.class.getSimpleName()), Map.entry(Filter.class, Checker.class.getSimpleName()), Map.entry(BeforeExecutionFileFilter.class, Checker.class.getSimpleName()));\n-        CHECK_PROPERTIES = getProperties(AbstractCheck.class);\n-        JAVADOC_CHECK_PROPERTIES = getProperties(AbstractJavadocCheck.class);\n-        FILESET_PROPERTIES = getProperties(AbstractFileSetCheck.class);\n-        UNDOCUMENTED_PROPERTIES = Set.of(\"SuppressWithNearbyCommentFilter.fileContents\", \"SuppressionCommentFilter.fileContents\");\n-        PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD = Set.of(\"SuppressWarningsHolderCheck.aliasList\", \"HeaderCheck.header\", \"RegexpHeaderCheck.header\", \"CustomImportOrderCheck.customImportOrderRules\");\n-        SINCE_VERSION_FOR_INHERITED_PROPERTY = Map.ofEntries(Map.entry(\"MissingDeprecatedCheck.violateExecutionOnNonTightHtml\", \"8.24\"), Map.entry(\"NonEmptyAtclauseDescriptionCheck.violateExecutionOnNonTightHtml\", \"8.3\"), Map.entry(\"NonEmptyAtclauseDescriptionCheck.javadocTokens\", \"7.3\"));\n-        SUPER_CLASS_PROPERTIES_JAVADOCS = new HashMap<String, DetailNode>();\n-        MAIN_FOLDER_PATH = Paths.get(\"src\", \"main\", \"java\", \"com\", \"puppycrawl\", \"tools\", \"checkstyle\").toString();\n-        MODULE_SUPER_CLASS_FILES = List.of(new File(Paths.get(SiteUtil.MAIN_FOLDER_PATH, \"checks\", \"naming\", \"AbstractAccessControlNameCheck.java\").toString()), new File(Paths.get(SiteUtil.MAIN_FOLDER_PATH, \"checks\", \"naming\", \"AbstractNameCheck.java\").toString()), new File(Paths.get(SiteUtil.MAIN_FOLDER_PATH, \"checks\", \"javadoc\", \"AbstractJavadocCheck.java\").toString()), new File(Paths.get(SiteUtil.MAIN_FOLDER_PATH, \"api\", \"AbstractFileSetCheck.java\").toString()), new File(Paths.get(SiteUtil.MAIN_FOLDER_PATH, \"checks\", \"header\", \"AbstractHeaderCheck.java\").toString()));\n-    }\n }\n"}]}
