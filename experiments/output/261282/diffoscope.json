{"diffoscope-json-version": 1, "source1": "first/ClassUtils.class", "source2": "second/ClassUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -23,550 +23,540 @@\n     public static final String INNER_CLASS_SEPARATOR;\n     private static final Map<String, Class<?>> namePrimitiveMap;\n     private static final Map<Class<?>, Class<?>> primitiveWrapperMap;\n     private static final Map<Class<?>, Class<?>> wrapperPrimitiveMap;\n     private static final Map<String, String> abbreviationMap;\n     private static final Map<String, String> reverseAbbreviationMap;\n     \n-    public static String getShortClassName(final Object object, final String valueIfNull) {\n-        if (object == null) {\n-            return valueIfNull;\n+    public static String getShortClassName(final Object o, final String s) {\n+        if (o == null) {\n+            return s;\n         }\n-        return getShortClassName(object.getClass());\n+        return getShortClassName(o.getClass());\n     }\n     \n-    public static String getShortClassName(final Class<?> cls) {\n-        if (cls == null) {\n+    public static String getShortClassName(final Class<?> clazz) {\n+        if (clazz == null) {\n             return \"\";\n         }\n-        return getShortClassName(cls.getName());\n+        return getShortClassName(clazz.getName());\n     }\n     \n-    public static String getShortClassName(String className) {\n-        if (StringUtils.isEmpty((CharSequence)className)) {\n+    public static String getShortClassName(String s) {\n+        if (StringUtils.isEmpty((CharSequence)s)) {\n             return \"\";\n         }\n-        final StringBuilder arrayPrefix = new StringBuilder();\n-        if (className.startsWith(\"[\")) {\n-            while (className.charAt(0) == '[') {\n-                className = className.substring(1);\n-                arrayPrefix.append(\"[]\");\n+        final StringBuilder obj = new StringBuilder();\n+        if (s.startsWith(\"[\")) {\n+            while (s.charAt(0) == '[') {\n+                s = s.substring(1);\n+                obj.append(\"[]\");\n             }\n-            if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n-                className = className.substring(1, className.length() - 1);\n+            if (s.charAt(0) == 'L' && s.charAt(s.length() - 1) == ';') {\n+                s = s.substring(1, s.length() - 1);\n             }\n-            if (ClassUtils.reverseAbbreviationMap.containsKey(className)) {\n-                className = ClassUtils.reverseAbbreviationMap.get(className);\n+            if (ClassUtils.reverseAbbreviationMap.containsKey(s)) {\n+                s = ClassUtils.reverseAbbreviationMap.get(s);\n             }\n         }\n-        final int lastDotIdx = className.lastIndexOf(46);\n-        final int innerIdx = className.indexOf(36, (lastDotIdx == -1) ? 0 : (lastDotIdx + 1));\n-        String out = className.substring(lastDotIdx + 1);\n-        if (innerIdx != -1) {\n-            out = out.replace('$', '.');\n+        final int lastIndex = s.lastIndexOf(46);\n+        final int index = s.indexOf(36, (lastIndex == -1) ? 0 : (lastIndex + 1));\n+        String str = s.substring(lastIndex + 1);\n+        if (index != -1) {\n+            str = str.replace('$', '.');\n         }\n-        return out + (Object)arrayPrefix;\n+        return str + (Object)obj;\n     }\n     \n-    public static String getSimpleName(final Class<?> cls) {\n-        return getSimpleName(cls, \"\");\n+    public static String getSimpleName(final Class<?> clazz) {\n+        return getSimpleName(clazz, \"\");\n     }\n     \n-    public static String getSimpleName(final Class<?> cls, final String valueIfNull) {\n-        return (cls == null) ? valueIfNull : cls.getSimpleName();\n+    public static String getSimpleName(final Class<?> clazz, final String s) {\n+        return (clazz == null) ? s : clazz.getSimpleName();\n     }\n     \n-    public static String getSimpleName(final Object object) {\n-        return getSimpleName(object, \"\");\n+    public static String getSimpleName(final Object o) {\n+        return getSimpleName(o, \"\");\n     }\n     \n-    public static String getSimpleName(final Object object, final String valueIfNull) {\n-        return (object == null) ? valueIfNull : object.getClass().getSimpleName();\n+    public static String getSimpleName(final Object o, final String s) {\n+        return (o == null) ? s : o.getClass().getSimpleName();\n     }\n     \n-    public static String getName(final Class<?> cls) {\n-        return getName(cls, \"\");\n+    public static String getName(final Class<?> clazz) {\n+        return getName(clazz, \"\");\n     }\n     \n-    public static String getName(final Class<?> cls, final String valueIfNull) {\n-        return (cls == null) ? valueIfNull : cls.getName();\n+    public static String getName(final Class<?> clazz, final String s) {\n+        return (clazz == null) ? s : clazz.getName();\n     }\n     \n-    public static String getName(final Object object) {\n-        return getName(object, \"\");\n+    public static String getName(final Object o) {\n+        return getName(o, \"\");\n     }\n     \n-    public static String getName(final Object object, final String valueIfNull) {\n-        return (object == null) ? valueIfNull : object.getClass().getName();\n+    public static String getName(final Object o, final String s) {\n+        return (o == null) ? s : o.getClass().getName();\n     }\n     \n-    public static String getPackageName(final Object object, final String valueIfNull) {\n-        if (object == null) {\n-            return valueIfNull;\n+    public static String getPackageName(final Object o, final String s) {\n+        if (o == null) {\n+            return s;\n         }\n-        return getPackageName(object.getClass());\n+        return getPackageName(o.getClass());\n     }\n     \n-    public static String getPackageName(final Class<?> cls) {\n-        if (cls == null) {\n+    public static String getPackageName(final Class<?> clazz) {\n+        if (clazz == null) {\n             return \"\";\n         }\n-        return getPackageName(cls.getName());\n+        return getPackageName(clazz.getName());\n     }\n     \n-    public static String getPackageName(String className) {\n-        if (StringUtils.isEmpty((CharSequence)className)) {\n+    public static String getPackageName(String s) {\n+        if (StringUtils.isEmpty((CharSequence)s)) {\n             return \"\";\n         }\n-        while (className.charAt(0) == '[') {\n-            className = className.substring(1);\n+        while (s.charAt(0) == '[') {\n+            s = s.substring(1);\n         }\n-        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n-            className = className.substring(1);\n+        if (s.charAt(0) == 'L' && s.charAt(s.length() - 1) == ';') {\n+            s = s.substring(1);\n         }\n-        final int i = className.lastIndexOf(46);\n-        if (i == -1) {\n+        final int lastIndex = s.lastIndexOf(46);\n+        if (lastIndex == -1) {\n             return \"\";\n         }\n-        return className.substring(0, i);\n+        return s.substring(0, lastIndex);\n     }\n     \n-    public static String getAbbreviatedName(final Class<?> cls, final int lengthHint) {\n-        if (cls == null) {\n+    public static String getAbbreviatedName(final Class<?> clazz, final int n) {\n+        if (clazz == null) {\n             return \"\";\n         }\n-        return getAbbreviatedName(cls.getName(), lengthHint);\n+        return getAbbreviatedName(clazz.getName(), n);\n     }\n     \n-    public static String getAbbreviatedName(final String className, final int lengthHint) {\n-        if (lengthHint <= 0) {\n+    public static String getAbbreviatedName(final String s, final int n) {\n+        if (n <= 0) {\n             throw new IllegalArgumentException(\"len must be > 0\");\n         }\n-        if (className == null) {\n+        if (s == null) {\n             return \"\";\n         }\n-        if (className.length() <= lengthHint) {\n-            return className;\n+        if (s.length() <= n) {\n+            return s;\n         }\n-        final char[] abbreviated = className.toCharArray();\n-        int target = 0;\n-        for (int source = 0; source < abbreviated.length; abbreviated[target++] = abbreviated[source++]) {\n-            int runAheadTarget;\n-            for (runAheadTarget = target; source < abbreviated.length && abbreviated[source] != '.'; abbreviated[runAheadTarget++] = abbreviated[source++]) {}\n-            ++target;\n-            if (useFull(runAheadTarget, source, abbreviated.length, lengthHint) || target > runAheadTarget) {\n-                target = runAheadTarget;\n+        final char[] charArray = s.toCharArray();\n+        int count = 0;\n+        for (int i = 0; i < charArray.length; charArray[count++] = charArray[i++]) {\n+            int n2;\n+            for (n2 = count; i < charArray.length && charArray[i] != '.'; charArray[n2++] = charArray[i++]) {}\n+            ++count;\n+            if (useFull(n2, i, charArray.length, n) || count > n2) {\n+                count = n2;\n             }\n-            if (source < abbreviated.length) {}\n+            if (i < charArray.length) {}\n         }\n-        return new String(abbreviated, 0, target);\n+        return new String(charArray, 0, count);\n     }\n     \n-    private static boolean useFull(final int runAheadTarget, final int source, final int originalLength, final int desiredLength) {\n-        return source >= originalLength || runAheadTarget + originalLength - source <= desiredLength;\n+    private static boolean useFull(final int n, final int n2, final int n3, final int n4) {\n+        return n2 >= n3 || n + n3 - n2 <= n4;\n     }\n     \n-    public static List<Class<?>> getAllSuperclasses(final Class<?> cls) {\n-        if (cls == null) {\n+    public static List<Class<?>> getAllSuperclasses(final Class<?> clazz) {\n+        if (clazz == null) {\n             return null;\n         }\n-        final List<Class<?>> classes = new ArrayList<Class<?>>();\n-        for (Class<?> superclass = cls.getSuperclass(); superclass != null; superclass = superclass.getSuperclass()) {\n-            classes.add(superclass);\n+        final ArrayList list = new ArrayList();\n+        for (Class<?> clazz2 = clazz.getSuperclass(); clazz2 != null; clazz2 = clazz2.getSuperclass()) {\n+            list.add(clazz2);\n         }\n-        return classes;\n+        return list;\n     }\n     \n-    public static List<Class<?>> getAllInterfaces(final Class<?> cls) {\n-        if (cls == null) {\n+    public static List<Class<?>> getAllInterfaces(final Class<?> clazz) {\n+        if (clazz == null) {\n             return null;\n         }\n-        final LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<Class<?>>();\n-        getAllInterfaces(cls, interfacesFound);\n-        return new ArrayList<Class<?>>(interfacesFound);\n+        final LinkedHashSet c = new LinkedHashSet();\n+        getAllInterfaces(clazz, c);\n+        return new ArrayList<Class<?>>(c);\n     }\n     \n-    private static void getAllInterfaces(Class<?> cls, final HashSet<Class<?>> interfacesFound) {\n-        while (cls != null) {\n-            final Class<?>[] interfaces2;\n-            final Class<?>[] interfaces = interfaces2 = cls.getInterfaces();\n-            for (final Class<?> i : interfaces2) {\n-                if (interfacesFound.add(i)) {\n-                    getAllInterfaces(i, interfacesFound);\n+    private static void getAllInterfaces(Class<?> superclass, final HashSet<Class<?>> set) {\n+        while (superclass != null) {\n+            for (final Class e : superclass.getInterfaces()) {\n+                if (set.add(e)) {\n+                    getAllInterfaces(e, set);\n                 }\n             }\n-            cls = cls.getSuperclass();\n+            superclass = superclass.getSuperclass();\n         }\n     }\n     \n-    public static List<Class<?>> convertClassNamesToClasses(final List<String> classNames) {\n-        if (classNames == null) {\n+    public static List<Class<?>> convertClassNamesToClasses(final List<String> list) {\n+        if (list == null) {\n             return null;\n         }\n-        final List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size());\n-        for (final String className : classNames) {\n+        final ArrayList list2 = new ArrayList(list.size());\n+        for (final String className : list) {\n             try {\n-                classes.add(Class.forName(className));\n+                list2.add(Class.forName(className));\n             }\n             catch (final Exception ex) {\n-                classes.add(null);\n+                list2.add(null);\n             }\n         }\n-        return classes;\n+        return list2;\n     }\n     \n-    public static List<String> convertClassesToClassNames(final List<Class<?>> classes) {\n-        if (classes == null) {\n+    public static List<String> convertClassesToClassNames(final List<Class<?>> list) {\n+        if (list == null) {\n             return null;\n         }\n-        final List<String> classNames = new ArrayList<String>(classes.size());\n-        for (final Class<?> cls : classes) {\n-            if (cls == null) {\n-                classNames.add(null);\n+        final ArrayList list2 = new ArrayList(list.size());\n+        for (final Class clazz : list) {\n+            if (clazz == null) {\n+                list2.add(null);\n             }\n             else {\n-                classNames.add(cls.getName());\n+                list2.add(clazz.getName());\n             }\n         }\n-        return classNames;\n+        return list2;\n     }\n     \n-    public static boolean isAssignable(final Class<?>[] classArray, final Class<?>... toClassArray) {\n-        return isAssignable(classArray, toClassArray, true);\n+    public static boolean isAssignable(final Class<?>[] array, final Class<?>... array2) {\n+        return isAssignable(array, array2, true);\n     }\n     \n-    public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, final boolean autoboxing) {\n-        if (!ArrayUtils.isSameLength((Object[])classArray, (Object[])toClassArray)) {\n+    public static boolean isAssignable(Class<?>[] empty_CLASS_ARRAY, Class<?>[] empty_CLASS_ARRAY2, final boolean b) {\n+        if (!ArrayUtils.isSameLength((Object[])empty_CLASS_ARRAY, (Object[])empty_CLASS_ARRAY2)) {\n             return false;\n         }\n-        if (classArray == null) {\n-            classArray = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        if (empty_CLASS_ARRAY == null) {\n+            empty_CLASS_ARRAY = ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n-        if (toClassArray == null) {\n-            toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        if (empty_CLASS_ARRAY2 == null) {\n+            empty_CLASS_ARRAY2 = ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n-        for (int i = 0; i < classArray.length; ++i) {\n-            if (!isAssignable(classArray[i], toClassArray[i], autoboxing)) {\n+        for (int i = 0; i < empty_CLASS_ARRAY.length; ++i) {\n+            if (!isAssignable(empty_CLASS_ARRAY[i], empty_CLASS_ARRAY2[i], b)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    public static boolean isPrimitiveOrWrapper(final Class<?> type) {\n-        return type != null && (type.isPrimitive() || isPrimitiveWrapper(type));\n+    public static boolean isPrimitiveOrWrapper(final Class<?> clazz) {\n+        return clazz != null && (clazz.isPrimitive() || isPrimitiveWrapper(clazz));\n     }\n     \n-    public static boolean isPrimitiveWrapper(final Class<?> type) {\n-        return ClassUtils.wrapperPrimitiveMap.containsKey(type);\n+    public static boolean isPrimitiveWrapper(final Class<?> clazz) {\n+        return ClassUtils.wrapperPrimitiveMap.containsKey(clazz);\n     }\n     \n-    public static boolean isAssignable(final Class<?> cls, final Class<?> toClass) {\n-        return isAssignable(cls, toClass, true);\n+    public static boolean isAssignable(final Class<?> clazz, final Class<?> clazz2) {\n+        return isAssignable(clazz, clazz2, true);\n     }\n     \n-    public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) {\n-        if (toClass == null) {\n+    public static boolean isAssignable(Class<?> clazz, final Class<?> clazz2, final boolean b) {\n+        if (clazz2 == null) {\n             return false;\n         }\n-        if (cls == null) {\n-            return !toClass.isPrimitive();\n+        if (clazz == null) {\n+            return !clazz2.isPrimitive();\n         }\n-        if (autoboxing) {\n-            if (cls.isPrimitive() && !toClass.isPrimitive()) {\n-                cls = primitiveToWrapper(cls);\n-                if (cls == null) {\n+        if (b) {\n+            if (clazz.isPrimitive() && !clazz2.isPrimitive()) {\n+                clazz = primitiveToWrapper(clazz);\n+                if (clazz == null) {\n                     return false;\n                 }\n             }\n-            if (toClass.isPrimitive() && !cls.isPrimitive()) {\n-                cls = wrapperToPrimitive(cls);\n-                if (cls == null) {\n+            if (clazz2.isPrimitive() && !clazz.isPrimitive()) {\n+                clazz = wrapperToPrimitive(clazz);\n+                if (clazz == null) {\n                     return false;\n                 }\n             }\n         }\n-        if (cls.equals(toClass)) {\n+        if (clazz.equals(clazz2)) {\n             return true;\n         }\n-        if (!cls.isPrimitive()) {\n-            return toClass.isAssignableFrom(cls);\n+        if (!clazz.isPrimitive()) {\n+            return clazz2.isAssignableFrom(clazz);\n         }\n-        if (!toClass.isPrimitive()) {\n+        if (!clazz2.isPrimitive()) {\n             return false;\n         }\n-        if (Integer.TYPE.equals(cls)) {\n-            return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);\n+        if (Integer.TYPE.equals(clazz)) {\n+            return Long.TYPE.equals(clazz2) || Float.TYPE.equals(clazz2) || Double.TYPE.equals(clazz2);\n         }\n-        if (Long.TYPE.equals(cls)) {\n-            return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);\n+        if (Long.TYPE.equals(clazz)) {\n+            return Float.TYPE.equals(clazz2) || Double.TYPE.equals(clazz2);\n         }\n-        if (Boolean.TYPE.equals(cls)) {\n+        if (Boolean.TYPE.equals(clazz)) {\n             return false;\n         }\n-        if (Double.TYPE.equals(cls)) {\n+        if (Double.TYPE.equals(clazz)) {\n             return false;\n         }\n-        if (Float.TYPE.equals(cls)) {\n-            return Double.TYPE.equals(toClass);\n+        if (Float.TYPE.equals(clazz)) {\n+            return Double.TYPE.equals(clazz2);\n         }\n-        if (Character.TYPE.equals(cls)) {\n-            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);\n+        if (Character.TYPE.equals(clazz)) {\n+            return Integer.TYPE.equals(clazz2) || Long.TYPE.equals(clazz2) || Float.TYPE.equals(clazz2) || Double.TYPE.equals(clazz2);\n         }\n-        if (Short.TYPE.equals(cls)) {\n-            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);\n+        if (Short.TYPE.equals(clazz)) {\n+            return Integer.TYPE.equals(clazz2) || Long.TYPE.equals(clazz2) || Float.TYPE.equals(clazz2) || Double.TYPE.equals(clazz2);\n         }\n-        return Byte.TYPE.equals(cls) && (Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass));\n+        return Byte.TYPE.equals(clazz) && (Short.TYPE.equals(clazz2) || Integer.TYPE.equals(clazz2) || Long.TYPE.equals(clazz2) || Float.TYPE.equals(clazz2) || Double.TYPE.equals(clazz2));\n     }\n     \n-    public static Class<?> primitiveToWrapper(final Class<?> cls) {\n-        Class<?> convertedClass = cls;\n-        if (cls != null && cls.isPrimitive()) {\n-            convertedClass = ClassUtils.primitiveWrapperMap.get(cls);\n+    public static Class<?> primitiveToWrapper(final Class<?> clazz) {\n+        Class<?> clazz2 = clazz;\n+        if (clazz != null && clazz.isPrimitive()) {\n+            clazz2 = ClassUtils.primitiveWrapperMap.get(clazz);\n         }\n-        return convertedClass;\n+        return clazz2;\n     }\n     \n-    public static Class<?>[] primitivesToWrappers(final Class<?>... classes) {\n-        if (classes == null) {\n+    public static Class<?>[] primitivesToWrappers(final Class<?>... array) {\n+        if (array == null) {\n             return null;\n         }\n-        if (classes.length == 0) {\n-            return classes;\n+        if (array.length == 0) {\n+            return array;\n         }\n-        final Class<?>[] convertedClasses = new Class[classes.length];\n-        for (int i = 0; i < classes.length; ++i) {\n-            convertedClasses[i] = primitiveToWrapper(classes[i]);\n+        final Class[] array2 = new Class[array.length];\n+        for (int i = 0; i < array.length; ++i) {\n+            array2[i] = primitiveToWrapper(array[i]);\n         }\n-        return convertedClasses;\n+        return array2;\n     }\n     \n-    public static Class<?> wrapperToPrimitive(final Class<?> cls) {\n-        return ClassUtils.wrapperPrimitiveMap.get(cls);\n+    public static Class<?> wrapperToPrimitive(final Class<?> clazz) {\n+        return ClassUtils.wrapperPrimitiveMap.get(clazz);\n     }\n     \n-    public static Class<?>[] wrappersToPrimitives(final Class<?>... classes) {\n-        if (classes == null) {\n+    public static Class<?>[] wrappersToPrimitives(final Class<?>... array) {\n+        if (array == null) {\n             return null;\n         }\n-        if (classes.length == 0) {\n-            return classes;\n+        if (array.length == 0) {\n+            return array;\n         }\n-        final Class<?>[] convertedClasses = new Class[classes.length];\n-        for (int i = 0; i < classes.length; ++i) {\n-            convertedClasses[i] = wrapperToPrimitive(classes[i]);\n+        final Class[] array2 = new Class[array.length];\n+        for (int i = 0; i < array.length; ++i) {\n+            array2[i] = wrapperToPrimitive(array[i]);\n         }\n-        return convertedClasses;\n+        return array2;\n     }\n     \n-    public static boolean isInnerClass(final Class<?> cls) {\n-        return cls != null && cls.getEnclosingClass() != null;\n+    public static boolean isInnerClass(final Class<?> clazz) {\n+        return clazz != null && clazz.getEnclosingClass() != null;\n     }\n     \n-    public static Class<?> getClass(final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException {\n+    public static Class<?> getClass(final ClassLoader loader, final String s, final boolean initialize) throws ClassNotFoundException {\n         try {\n-            Class<?> clazz;\n-            if (ClassUtils.namePrimitiveMap.containsKey(className)) {\n-                clazz = ClassUtils.namePrimitiveMap.get(className);\n+            Class<?> forName;\n+            if (ClassUtils.namePrimitiveMap.containsKey(s)) {\n+                forName = ClassUtils.namePrimitiveMap.get(s);\n             }\n             else {\n-                clazz = Class.forName(toCanonicalName(className), initialize, classLoader);\n+                forName = Class.forName(toCanonicalName(s), initialize, loader);\n             }\n-            return clazz;\n+            return forName;\n         }\n         catch (final ClassNotFoundException ex) {\n-            final int lastDotIndex = className.lastIndexOf(46);\n-            if (lastDotIndex != -1) {\n+            final int lastIndex = s.lastIndexOf(46);\n+            if (lastIndex != -1) {\n                 try {\n-                    return getClass(classLoader, className.substring(0, lastDotIndex) + '$' + className.substring(lastDotIndex + 1), initialize);\n+                    return getClass(loader, s.substring(0, lastIndex) + '$' + s.substring(lastIndex + 1), initialize);\n                 }\n                 catch (final ClassNotFoundException ex2) {}\n             }\n             throw ex;\n         }\n     }\n     \n-    public static Class<?> getClass(final ClassLoader classLoader, final String className) throws ClassNotFoundException {\n-        return getClass(classLoader, className, true);\n+    public static Class<?> getClass(final ClassLoader classLoader, final String s) throws ClassNotFoundException {\n+        return getClass(classLoader, s, true);\n     }\n     \n-    public static Class<?> getClass(final String className) throws ClassNotFoundException {\n-        return getClass(className, true);\n+    public static Class<?> getClass(final String s) throws ClassNotFoundException {\n+        return getClass(s, true);\n     }\n     \n-    public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException {\n-        final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();\n-        final ClassLoader loader = (contextCL == null) ? ClassUtils.class.getClassLoader() : contextCL;\n-        return getClass(loader, className, initialize);\n+    public static Class<?> getClass(final String s, final boolean b) throws ClassNotFoundException {\n+        final ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n+        return getClass((contextClassLoader == null) ? ClassUtils.class.getClassLoader() : contextClassLoader, s, b);\n     }\n     \n-    public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) throws NoSuchMethodException {\n-        final Method declaredMethod = cls.getMethod(methodName, parameterTypes);\n-        if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) {\n-            return declaredMethod;\n+    public static Method getPublicMethod(final Class<?> clazz, final String str, final Class<?>... array) throws NoSuchMethodException {\n+        final Method method = clazz.getMethod(str, (Class[])array);\n+        if (Modifier.isPublic(method.getDeclaringClass().getModifiers())) {\n+            return method;\n         }\n-        final List<Class<?>> candidateClasses = new ArrayList<Class<?>>();\n-        candidateClasses.addAll(getAllInterfaces(cls));\n-        candidateClasses.addAll(getAllSuperclasses(cls));\n-        for (final Class<?> candidateClass : candidateClasses) {\n-            if (!Modifier.isPublic(candidateClass.getModifiers())) {\n+        final ArrayList list = new ArrayList();\n+        list.addAll(getAllInterfaces(clazz));\n+        list.addAll(getAllSuperclasses(clazz));\n+        for (final Class clazz2 : list) {\n+            if (!Modifier.isPublic(clazz2.getModifiers())) {\n                 continue;\n             }\n-            Method candidateMethod;\n+            Method method2;\n             try {\n-                candidateMethod = candidateClass.getMethod(methodName, parameterTypes);\n+                method2 = clazz2.getMethod(str, (Class[])array);\n             }\n             catch (final NoSuchMethodException ex) {\n                 continue;\n             }\n-            if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) {\n-                return candidateMethod;\n+            if (Modifier.isPublic(method2.getDeclaringClass().getModifiers())) {\n+                return method2;\n             }\n         }\n-        throw new NoSuchMethodException(\"Can't find a public method for \" + methodName + \" \" + ArrayUtils.toString((Object)parameterTypes));\n+        throw new NoSuchMethodException(\"Can't find a public method for \" + str + \" \" + ArrayUtils.toString((Object)array));\n     }\n     \n-    private static String toCanonicalName(String className) {\n-        className = StringUtils.deleteWhitespace(className);\n-        Validate.notNull((Object)className, \"className must not be null.\", new Object[0]);\n-        if (className.endsWith(\"[]\")) {\n-            final StringBuilder classNameBuffer = new StringBuilder();\n-            while (className.endsWith(\"[]\")) {\n-                className = className.substring(0, className.length() - 2);\n-                classNameBuffer.append(\"[\");\n+    private static String toCanonicalName(String str) {\n+        str = StringUtils.deleteWhitespace(str);\n+        Validate.notNull((Object)str, \"className must not be null.\", new Object[0]);\n+        if (str.endsWith(\"[]\")) {\n+            final StringBuilder sb = new StringBuilder();\n+            while (str.endsWith(\"[]\")) {\n+                str = str.substring(0, str.length() - 2);\n+                sb.append(\"[\");\n             }\n-            final String abbreviation = (String)ClassUtils.abbreviationMap.get(className);\n-            if (abbreviation != null) {\n-                classNameBuffer.append(abbreviation);\n+            final String str2 = (String)ClassUtils.abbreviationMap.get(str);\n+            if (str2 != null) {\n+                sb.append(str2);\n             }\n             else {\n-                classNameBuffer.append(\"L\").append(className).append(\";\");\n+                sb.append(\"L\").append(str).append(\";\");\n             }\n-            className = classNameBuffer.toString();\n+            str = sb.toString();\n         }\n-        return className;\n+        return str;\n     }\n     \n     public static Class<?>[] toClass(final Object... array) {\n         if (array == null) {\n             return null;\n         }\n         if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n-        final Class<?>[] classes = new Class[array.length];\n+        final Class[] array2 = new Class[array.length];\n         for (int i = 0; i < array.length; ++i) {\n-            classes[i] = ((array[i] == null) ? null : array[i].getClass());\n+            array2[i] = ((array[i] == null) ? null : array[i].getClass());\n         }\n-        return classes;\n+        return array2;\n     }\n     \n-    public static String getShortCanonicalName(final Object object, final String valueIfNull) {\n-        if (object == null) {\n-            return valueIfNull;\n+    public static String getShortCanonicalName(final Object o, final String s) {\n+        if (o == null) {\n+            return s;\n         }\n-        return getShortCanonicalName(object.getClass().getName());\n+        return getShortCanonicalName(o.getClass().getName());\n     }\n     \n-    public static String getCanonicalName(final Class<?> cls) {\n-        return getCanonicalName(cls, \"\");\n+    public static String getCanonicalName(final Class<?> clazz) {\n+        return getCanonicalName(clazz, \"\");\n     }\n     \n-    public static String getCanonicalName(final Class<?> cls, final String valueIfNull) {\n-        if (cls == null) {\n-            return valueIfNull;\n+    public static String getCanonicalName(final Class<?> clazz, final String s) {\n+        if (clazz == null) {\n+            return s;\n         }\n-        final String canonicalName = cls.getCanonicalName();\n-        return (canonicalName == null) ? valueIfNull : canonicalName;\n+        final String canonicalName = clazz.getCanonicalName();\n+        return (canonicalName == null) ? s : canonicalName;\n     }\n     \n-    public static String getCanonicalName(final Object object) {\n-        return getCanonicalName(object, \"\");\n+    public static String getCanonicalName(final Object o) {\n+        return getCanonicalName(o, \"\");\n     }\n     \n-    public static String getCanonicalName(final Object object, final String valueIfNull) {\n-        if (object == null) {\n-            return valueIfNull;\n+    public static String getCanonicalName(final Object o, final String s) {\n+        if (o == null) {\n+            return s;\n         }\n-        final String canonicalName = object.getClass().getCanonicalName();\n-        return (canonicalName == null) ? valueIfNull : canonicalName;\n+        final String canonicalName = o.getClass().getCanonicalName();\n+        return (canonicalName == null) ? s : canonicalName;\n     }\n     \n-    public static String getShortCanonicalName(final Class<?> cls) {\n-        if (cls == null) {\n+    public static String getShortCanonicalName(final Class<?> clazz) {\n+        if (clazz == null) {\n             return \"\";\n         }\n-        return getShortCanonicalName(cls.getName());\n+        return getShortCanonicalName(clazz.getName());\n     }\n     \n-    public static String getShortCanonicalName(final String canonicalName) {\n-        return getShortClassName(getCanonicalName(canonicalName));\n+    public static String getShortCanonicalName(final String s) {\n+        return getShortClassName(getCanonicalName(s));\n     }\n     \n-    public static String getPackageCanonicalName(final Object object, final String valueIfNull) {\n-        if (object == null) {\n-            return valueIfNull;\n+    public static String getPackageCanonicalName(final Object o, final String s) {\n+        if (o == null) {\n+            return s;\n         }\n-        return getPackageCanonicalName(object.getClass().getName());\n+        return getPackageCanonicalName(o.getClass().getName());\n     }\n     \n-    public static String getPackageCanonicalName(final Class<?> cls) {\n-        if (cls == null) {\n+    public static String getPackageCanonicalName(final Class<?> clazz) {\n+        if (clazz == null) {\n             return \"\";\n         }\n-        return getPackageCanonicalName(cls.getName());\n+        return getPackageCanonicalName(clazz.getName());\n     }\n     \n-    public static String getPackageCanonicalName(final String name) {\n-        return getPackageName(getCanonicalName(name));\n+    public static String getPackageCanonicalName(final String s) {\n+        return getPackageName(getCanonicalName(s));\n     }\n     \n-    private static String getCanonicalName(String className) {\n-        className = StringUtils.deleteWhitespace(className);\n-        if (className == null) {\n+    private static String getCanonicalName(String str) {\n+        str = StringUtils.deleteWhitespace(str);\n+        if (str == null) {\n             return null;\n         }\n-        int dim = 0;\n-        while (className.startsWith(\"[\")) {\n-            ++dim;\n-            className = className.substring(1);\n+        int n = 0;\n+        while (str.startsWith(\"[\")) {\n+            ++n;\n+            str = str.substring(1);\n         }\n-        if (dim < 1) {\n-            return className;\n+        if (n < 1) {\n+            return str;\n         }\n-        if (className.startsWith(\"L\")) {\n-            className = className.substring(1, className.endsWith(\";\") ? (className.length() - 1) : className.length());\n+        if (str.startsWith(\"L\")) {\n+            str = str.substring(1, str.endsWith(\";\") ? (str.length() - 1) : str.length());\n         }\n-        else if (!className.isEmpty()) {\n-            className = ClassUtils.reverseAbbreviationMap.get(className.substring(0, 1));\n+        else if (!str.isEmpty()) {\n+            str = ClassUtils.reverseAbbreviationMap.get(str.substring(0, 1));\n         }\n-        final StringBuilder canonicalClassNameBuffer = new StringBuilder(className);\n-        for (int i = 0; i < dim; ++i) {\n-            canonicalClassNameBuffer.append(\"[]\");\n+        final StringBuilder sb = new StringBuilder(str);\n+        for (int i = 0; i < n; ++i) {\n+            sb.append(\"[]\");\n         }\n-        return canonicalClassNameBuffer.toString();\n+        return sb.toString();\n     }\n     \n-    public static Iterable<Class<?>> hierarchy(final Class<?> type) {\n-        return hierarchy(type, ClassUtils.Interfaces.EXCLUDE);\n+    public static Iterable<Class<?>> hierarchy(final Class<?> clazz) {\n+        return hierarchy(clazz, ClassUtils.Interfaces.EXCLUDE);\n     }\n     \n-    public static Iterable<Class<?>> hierarchy(final Class<?> type, final ClassUtils.Interfaces interfacesBehavior) {\n-        final Iterable<Class<?>> classes = () -> {\n-            final MutableObject<Class<?>> next = (MutableObject<Class<?>>)new MutableObject((Object)type);\n-            return (Iterator<Class<?>>)new ClassUtils.ClassUtils$1((MutableObject)next);\n-        };\n-        if (interfacesBehavior != ClassUtils.Interfaces.INCLUDE) {\n-            return classes;\n+    public static Iterable<Class<?>> hierarchy(final Class<?> clazz, final ClassUtils.Interfaces interfaces) {\n+        final Iterable iterable = () -> new ClassUtils.ClassUtils$1(new MutableObject((Object)clazz2));\n+        if (interfaces != ClassUtils.Interfaces.INCLUDE) {\n+            return iterable;\n         }\n-        return () -> {\n-            final Set<Class<?>> seenInterfaces = new HashSet<Class<?>>();\n-            final Iterator<Class<?>> wrapped = classes.iterator();\n-            return (Iterator<Class<?>>)new ClassUtils.ClassUtils$2((Iterator)wrapped, (Set)seenInterfaces);\n-        };\n+        return () -> new ClassUtils.ClassUtils$2((Iterator)iterable2.iterator(), (Set)new HashSet());\n     }\n     \n     static {\n         PACKAGE_SEPARATOR = String.valueOf('.');\n         INNER_CLASS_SEPARATOR = String.valueOf('$');\n         (namePrimitiveMap = new HashMap<String, Class<?>>()).put(\"boolean\", Boolean.TYPE);\n         ClassUtils.namePrimitiveMap.put(\"byte\", Byte.TYPE);\n@@ -583,31 +573,31 @@\n         ClassUtils.primitiveWrapperMap.put(Short.TYPE, Short.class);\n         ClassUtils.primitiveWrapperMap.put(Integer.TYPE, Integer.class);\n         ClassUtils.primitiveWrapperMap.put(Long.TYPE, Long.class);\n         ClassUtils.primitiveWrapperMap.put(Double.TYPE, Double.class);\n         ClassUtils.primitiveWrapperMap.put(Float.TYPE, Float.class);\n         ClassUtils.primitiveWrapperMap.put(Void.TYPE, Void.TYPE);\n         wrapperPrimitiveMap = new HashMap<Class<?>, Class<?>>();\n-        for (final Map.Entry<Class<?>, Class<?>> entry : ClassUtils.primitiveWrapperMap.entrySet()) {\n-            final Class<?> primitiveClass = (Class<?>)entry.getKey();\n-            final Class<?> wrapperClass = (Class<?>)entry.getValue();\n-            if (!primitiveClass.equals(wrapperClass)) {\n-                ClassUtils.wrapperPrimitiveMap.put(wrapperClass, primitiveClass);\n+        for (final Map.Entry entry : ClassUtils.primitiveWrapperMap.entrySet()) {\n+            final Class clazz = (Class)entry.getKey();\n+            final Class obj = (Class)entry.getValue();\n+            if (!clazz.equals(obj)) {\n+                ClassUtils.wrapperPrimitiveMap.put(obj, clazz);\n             }\n         }\n-        final Map<String, String> m = new HashMap<String, String>();\n+        final HashMap m = new HashMap();\n         m.put(\"int\", \"I\");\n         m.put(\"boolean\", \"Z\");\n         m.put(\"float\", \"F\");\n         m.put(\"long\", \"J\");\n         m.put(\"short\", \"S\");\n         m.put(\"byte\", \"B\");\n         m.put(\"double\", \"D\");\n         m.put(\"char\", \"C\");\n-        final Map<String, String> r = new HashMap<String, String>();\n-        for (final Map.Entry<String, String> e : m.entrySet()) {\n-            r.put(e.getValue(), e.getKey());\n+        final HashMap i = new HashMap();\n+        for (final Map.Entry entry2 : m.entrySet()) {\n+            i.put(entry2.getValue(), entry2.getKey());\n         }\n-        abbreviationMap = Collections.unmodifiableMap((Map<? extends String, ? extends String>)m);\n-        reverseAbbreviationMap = Collections.unmodifiableMap((Map<? extends String, ? extends String>)r);\n+        abbreviationMap = Collections.unmodifiableMap((Map<?, ?>)m);\n+        reverseAbbreviationMap = Collections.unmodifiableMap((Map<?, ?>)i);\n     }\n }\n"}]}
