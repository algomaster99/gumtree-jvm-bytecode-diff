{"diffoscope-json-version": 1, "source1": "first/ZipArchiveEntry.class", "source2": "second/ZipArchiveEntry.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,16 +1,15 @@\n \n package org.apache.commons.compress.archivers.zip;\n \n+import java.util.Objects;\n import java.util.Date;\n import org.apache.commons.compress.utils.ByteUtils;\n import java.util.NoSuchElementException;\n-import java.util.stream.Stream;\n import java.util.function.Predicate;\n-import java.util.Objects;\n import java.util.Iterator;\n import java.util.Collection;\n import java.util.Arrays;\n import java.util.List;\n import java.util.ArrayList;\n import java.nio.file.attribute.FileTime;\n import java.io.IOException;\n@@ -48,14 +47,18 @@\n     private long dataOffset;\n     private boolean isStreamContiguous;\n     private ZipArchiveEntry.NameSource nameSource;\n     private ZipArchiveEntry.CommentSource commentSource;\n     private long diskNumberStart;\n     static final ZipArchiveEntry[] EMPTY_ZIP_ARCHIVE_ENTRY_ARRAY;\n     \n+    static {\n+        EMPTY_ZIP_ARCHIVE_ENTRY_ARRAY = new ZipArchiveEntry[0];\n+    }\n+    \n     public ZipArchiveEntry(final String name) {\n         super(name);\n         this.method = -1;\n         this.size = -1L;\n         this.platform = 0;\n         this.gpb = new GeneralPurposeBit();\n         this.localHeaderOffset = -1L;\n@@ -98,23 +101,23 @@\n     }\n     \n     protected ZipArchiveEntry() {\n         this(\"\");\n     }\n     \n     public ZipArchiveEntry(final File inputFile, final String entryName) {\n-        this((inputFile.isDirectory() && !entryName.endsWith(\"/\")) ? (entryName + \"/\") : entryName);\n+        this((inputFile.isDirectory() && !entryName.endsWith(\"/\")) ? (String.valueOf(entryName) + \"/\") : entryName);\n         if (inputFile.isFile()) {\n             this.setSize(inputFile.length());\n         }\n         this.setTime(inputFile.lastModified());\n     }\n     \n     public ZipArchiveEntry(final Path inputPath, final String entryName, final LinkOption... options) throws IOException {\n-        this((Files.isDirectory(inputPath, options) && !entryName.endsWith(\"/\")) ? (entryName + \"/\") : entryName);\n+        this((Files.isDirectory(inputPath, options) && !entryName.endsWith(\"/\")) ? (String.valueOf(entryName) + \"/\") : entryName);\n         if (Files.isRegularFile(inputPath, options)) {\n             this.setSize(Files.size(inputPath));\n         }\n         this.setTime(Files.getLastModifiedTime(inputPath, options));\n     }\n     \n     public void setTime(final FileTime fileTime) {\n@@ -280,22 +283,19 @@\n     \n     private ZipExtraField[] getAllExtraFields() {\n         final ZipExtraField[] allExtraFieldsNoCopy = this.getAllExtraFieldsNoCopy();\n         return (allExtraFieldsNoCopy == this.extraFields) ? this.copyOf(allExtraFieldsNoCopy, allExtraFieldsNoCopy.length) : allExtraFieldsNoCopy;\n     }\n     \n     private ZipExtraField findUnparseable(final List<ZipExtraField> fs) {\n-        final Stream<Object> stream = fs.stream();\n-        final Class<UnparseableExtraFieldData> obj = UnparseableExtraFieldData.class;\n-        Objects.requireNonNull(obj);\n-        return stream.filter((Predicate<? super ZipExtraField>)obj::isInstance).findFirst().orElse(null);\n+        return fs.stream().filter(UnparseableExtraFieldData.class::isInstance).findFirst().orElse(null);\n     }\n     \n     private ZipExtraField findMatching(final ZipShort headerId, final List<ZipExtraField> fs) {\n-        return fs.stream().filter(f -> headerId.equals((Object)f.getHeaderId())).findFirst().orElse(null);\n+        return fs.stream().filter(f -> zipShort.equals((Object)f.getHeaderId())).findFirst().orElse(null);\n     }\n     \n     public void addExtraField(final ZipExtraField ze) {\n         if (ze instanceof UnparseableExtraFieldData) {\n             this.unparseableExtra = (UnparseableExtraFieldData)ze;\n         }\n         else if (this.extraFields == null) {\n@@ -331,15 +331,17 @@\n     }\n     \n     public void removeExtraField(final ZipShort type) {\n         if (this.extraFields == null) {\n             throw new NoSuchElementException();\n         }\n         final List<ZipExtraField> newResult = new ArrayList<ZipExtraField>();\n-        for (final ZipExtraField extraField : this.extraFields) {\n+        ZipExtraField[] extraFields;\n+        for (int length = (extraFields = this.extraFields).length, i = 0; i < length; ++i) {\n+            final ZipExtraField extraField = extraFields[i];\n             if (!type.equals((Object)extraField.getHeaderId())) {\n                 newResult.add(extraField);\n             }\n         }\n         if (this.extraFields.length == newResult.size()) {\n             throw new NoSuchElementException();\n         }\n@@ -353,15 +355,17 @@\n         }\n         this.unparseableExtra = null;\n         this.setExtra();\n     }\n     \n     public ZipExtraField getExtraField(final ZipShort type) {\n         if (this.extraFields != null) {\n-            for (final ZipExtraField extraField : this.extraFields) {\n+            ZipExtraField[] extraFields;\n+            for (int length = (extraFields = this.extraFields).length, i = 0; i < length; ++i) {\n+                final ZipExtraField extraField = extraFields[i];\n                 if (type.equals((Object)extraField.getHeaderId())) {\n                     return extraField;\n                 }\n             }\n         }\n         return null;\n     }\n@@ -604,12 +608,8 @@\n     }\n     \n     private ZipExtraField[] copyOf(final ZipExtraField[] src, final int length) {\n         final ZipExtraField[] cpy = new ZipExtraField[length];\n         System.arraycopy(src, 0, cpy, 0, Math.min(src.length, length));\n         return cpy;\n     }\n-    \n-    static {\n-        EMPTY_ZIP_ARCHIVE_ENTRY_ARRAY = new ZipArchiveEntry[0];\n-    }\n }\n"}]}
