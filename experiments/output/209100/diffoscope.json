{"diffoscope-json-version": 1, "source1": "first/ProxyReader.class", "source2": "second/ProxyReader.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -5,134 +5,134 @@\n import org.apache.commons.io.IOUtils;\n import java.io.IOException;\n import java.io.Reader;\n import java.io.FilterReader;\n \n public abstract class ProxyReader extends FilterReader\n {\n-    public ProxyReader(final Reader proxy) {\n-        super(proxy);\n+    public ProxyReader(final Reader in) {\n+        super(in);\n     }\n     \n     @Override\n     public int read() throws IOException {\n         try {\n             this.beforeRead(1);\n-            final int c = this.in.read();\n-            this.afterRead((c != -1) ? 1 : -1);\n-            return c;\n+            final int read = this.in.read();\n+            this.afterRead((read != -1) ? 1 : -1);\n+            return read;\n         }\n-        catch (final IOException e) {\n-            this.handleIOException(e);\n+        catch (final IOException ex) {\n+            this.handleIOException(ex);\n             return -1;\n         }\n     }\n     \n     @Override\n-    public int read(final char[] chr) throws IOException {\n+    public int read(final char[] cbuf) throws IOException {\n         try {\n-            this.beforeRead(IOUtils.length(chr));\n-            final int n = this.in.read(chr);\n-            this.afterRead(n);\n-            return n;\n+            this.beforeRead(IOUtils.length(cbuf));\n+            final int read = this.in.read(cbuf);\n+            this.afterRead(read);\n+            return read;\n         }\n-        catch (final IOException e) {\n-            this.handleIOException(e);\n+        catch (final IOException ex) {\n+            this.handleIOException(ex);\n             return -1;\n         }\n     }\n     \n     @Override\n-    public int read(final char[] chr, final int st, final int len) throws IOException {\n+    public int read(final char[] array, final int n, final int n2) throws IOException {\n         try {\n-            this.beforeRead(len);\n-            final int n = this.in.read(chr, st, len);\n-            this.afterRead(n);\n-            return n;\n+            this.beforeRead(n2);\n+            final int read = this.in.read(array, n, n2);\n+            this.afterRead(read);\n+            return read;\n         }\n-        catch (final IOException e) {\n-            this.handleIOException(e);\n+        catch (final IOException ex) {\n+            this.handleIOException(ex);\n             return -1;\n         }\n     }\n     \n     @Override\n     public int read(final CharBuffer target) throws IOException {\n         try {\n             this.beforeRead(IOUtils.length((CharSequence)target));\n-            final int n = this.in.read(target);\n-            this.afterRead(n);\n-            return n;\n+            final int read = this.in.read(target);\n+            this.afterRead(read);\n+            return read;\n         }\n-        catch (final IOException e) {\n-            this.handleIOException(e);\n+        catch (final IOException ex) {\n+            this.handleIOException(ex);\n             return -1;\n         }\n     }\n     \n     @Override\n-    public long skip(final long ln) throws IOException {\n+    public long skip(final long n) throws IOException {\n         try {\n-            return this.in.skip(ln);\n+            return this.in.skip(n);\n         }\n-        catch (final IOException e) {\n-            this.handleIOException(e);\n+        catch (final IOException ex) {\n+            this.handleIOException(ex);\n             return 0L;\n         }\n     }\n     \n     @Override\n     public boolean ready() throws IOException {\n         try {\n             return this.in.ready();\n         }\n-        catch (final IOException e) {\n-            this.handleIOException(e);\n+        catch (final IOException ex) {\n+            this.handleIOException(ex);\n             return false;\n         }\n     }\n     \n     @Override\n     public void close() throws IOException {\n         try {\n             this.in.close();\n         }\n-        catch (final IOException e) {\n-            this.handleIOException(e);\n+        catch (final IOException ex) {\n+            this.handleIOException(ex);\n         }\n     }\n     \n     @Override\n-    public synchronized void mark(final int idx) throws IOException {\n+    public synchronized void mark(final int readAheadLimit) throws IOException {\n         try {\n-            this.in.mark(idx);\n+            this.in.mark(readAheadLimit);\n         }\n-        catch (final IOException e) {\n-            this.handleIOException(e);\n+        catch (final IOException ex) {\n+            this.handleIOException(ex);\n         }\n     }\n     \n     @Override\n     public synchronized void reset() throws IOException {\n         try {\n             this.in.reset();\n         }\n-        catch (final IOException e) {\n-            this.handleIOException(e);\n+        catch (final IOException ex) {\n+            this.handleIOException(ex);\n         }\n     }\n     \n     @Override\n     public boolean markSupported() {\n         return this.in.markSupported();\n     }\n     \n     protected void beforeRead(final int n) throws IOException {\n     }\n     \n     protected void afterRead(final int n) throws IOException {\n     }\n     \n-    protected void handleIOException(final IOException e) throws IOException {\n-        throw e;\n+    protected void handleIOException(final IOException ex) throws IOException {\n+        throw ex;\n     }\n }\n"}]}
