{"diffoscope-json-version": 1, "source1": "first/SevenZFile.class", "source2": "second/SevenZFile.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -54,14 +54,18 @@\n     private InputStream currentFolderInputStream;\n     private byte[] password;\n     private final SevenZFileOptions options;\n     private long compressedBytesReadFromCurrentEntry;\n     private long uncompressedBytesReadFromCurrentEntry;\n     private final ArrayList<InputStream> deferredBlockStreams;\n     \n+    static {\n+        sevenZSignature = new byte[] { 55, 122, -68, -81, 39, 28 };\n+    }\n+    \n     private static int assertFitsIntoNonNegativeInt(final String what, final long value) throws IOException {\n         if (value > 2147483647L || value < 0L) {\n             throw new IOException(String.format(\"Cannot handle % %,d\", what, Long.valueOf(value)));\n         }\n         return (int)value;\n     }\n     \n@@ -206,14 +210,17 @@\n             succeeded = true;\n         }\n         finally {\n             if (!succeeded && closeOnError) {\n                 this.channel.close();\n             }\n         }\n+        if (!succeeded && closeOnError) {\n+            this.channel.close();\n+        }\n     }\n     \n     public SevenZFile(final SeekableByteChannel channel, final String fileName, final char[] password) throws IOException {\n         this(channel, fileName, password, SevenZFileOptions.DEFAULT);\n     }\n     \n     public SevenZFile(final SeekableByteChannel channel, final String fileName, final char[] password, final SevenZFileOptions options) throws IOException {\n@@ -346,27 +353,53 @@\n             finally {\n                 this.channel = null;\n                 if (this.password != null) {\n                     Arrays.fill(this.password, (byte)0);\n                 }\n                 this.password = null;\n             }\n+            this.channel = null;\n+            if (this.password != null) {\n+                Arrays.fill(this.password, (byte)0);\n+            }\n+            this.password = null;\n         }\n     }\n     \n     private InputStream getCurrentStream() throws IOException {\n         if (this.archive.files[this.currentEntryIndex].getSize() == 0L) {\n             return new ByteArrayInputStream(ByteUtils.EMPTY_BYTE_ARRAY);\n         }\n         if (this.deferredBlockStreams.isEmpty()) {\n             throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n         }\n         while (this.deferredBlockStreams.size() > 1) {\n-            try (final InputStream stream = (InputStream)this.deferredBlockStreams.remove(0)) {\n-                IOUtils.skip(stream, Long.MAX_VALUE);\n+            Throwable t = null;\n+            try {\n+                final InputStream stream = (InputStream)this.deferredBlockStreams.remove(0);\n+                try {\n+                    IOUtils.skip(stream, Long.MAX_VALUE);\n+                }\n+                finally {\n+                    if (stream != null) {\n+                        stream.close();\n+                    }\n+                }\n+            }\n+            finally {\n+                if (t == null) {\n+                    final Throwable exception;\n+                    t = exception;\n+                }\n+                else {\n+                    final Throwable exception;\n+                    if (t != exception) {\n+                        t.addSuppressed(exception);\n+                    }\n+                }\n             }\n             this.compressedBytesReadFromCurrentEntry = 0L;\n         }\n         return this.deferredBlockStreams.get(0);\n     }\n     \n     public String getDefaultName() {\n@@ -374,15 +407,15 @@\n             return null;\n         }\n         final String lastSegment = new File(this.fileName).getName();\n         final int dotPos = lastSegment.lastIndexOf(\".\");\n         if (dotPos > 0) {\n             return lastSegment.substring(0, dotPos);\n         }\n-        return lastSegment + \"~\";\n+        return String.valueOf(lastSegment) + \"~\";\n     }\n     \n     public Iterable<SevenZArchiveEntry> getEntries() {\n         return new ArrayList<SevenZArchiveEntry>(Arrays.asList(this.archive.files));\n     }\n     \n     public InputStream getInputStream(final SevenZArchiveEntry entry) throws IOException {\n@@ -527,15 +560,15 @@\n             mask >>>= 1;\n         }\n         return bits;\n     }\n     \n     private ByteBuffer readEncodedHeader(final ByteBuffer header, final Archive archive, final byte[] password) throws IOException {\n         final int pos = header.position();\n-        final SevenZFile.ArchiveStatistics stats = new SevenZFile.ArchiveStatistics((SevenZFile.SevenZFile$1)null);\n+        final SevenZFile.ArchiveStatistics stats = new SevenZFile.ArchiveStatistics((SevenZFile.ArchiveStatistics)null);\n         this.sanityCheckStreamsInfo(header, stats);\n         stats.assertValidity(this.options.getMaxMemoryLimitInKb());\n         header.position();\n         this.readStreamsInfo(header, archive);\n         if (archive.folders == null || archive.folders.length == 0) {\n             throw new IOException(\"no folders, can't read encoded header\");\n         }\n@@ -853,26 +886,47 @@\n             }\n             nid = getUnsignedByte(header);\n         }\n     }\n     \n     private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\n         final StartHeader startHeader = new StartHeader();\n-        try (final DataInputStream dataInputStream = new DataInputStream((InputStream)new CRC32VerifyingInputStream((InputStream)new BoundedSeekableByteChannelInputStream(this.channel, 20L), 20L, startHeaderCrc))) {\n-            startHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\n-            if (startHeader.nextHeaderOffset < 0L || startHeader.nextHeaderOffset + 32L > this.channel.size()) {\n-                throw new IOException(\"nextHeaderOffset is out of bounds\");\n-            }\n-            startHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\n-            final long nextHeaderEnd = startHeader.nextHeaderOffset + startHeader.nextHeaderSize;\n-            if (nextHeaderEnd < startHeader.nextHeaderOffset || nextHeaderEnd + 32L > this.channel.size()) {\n-                throw new IOException(\"nextHeaderSize is out of bounds\");\n+        Throwable t = null;\n+        try {\n+            final DataInputStream dataInputStream = new DataInputStream((InputStream)new CRC32VerifyingInputStream((InputStream)new BoundedSeekableByteChannelInputStream(this.channel, 20L), 20L, startHeaderCrc));\n+            try {\n+                startHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\n+                if (startHeader.nextHeaderOffset < 0L || startHeader.nextHeaderOffset + 32L > this.channel.size()) {\n+                    throw new IOException(\"nextHeaderOffset is out of bounds\");\n+                }\n+                startHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\n+                final long nextHeaderEnd = startHeader.nextHeaderOffset + startHeader.nextHeaderSize;\n+                if (nextHeaderEnd < startHeader.nextHeaderOffset || nextHeaderEnd + 32L > this.channel.size()) {\n+                    throw new IOException(\"nextHeaderSize is out of bounds\");\n+                }\n+                startHeader.nextHeaderCrc = (0xFFFFFFFFL & (long)Integer.reverseBytes(dataInputStream.readInt()));\n+                return startHeader;\n+            }\n+            finally {\n+                if (dataInputStream != null) {\n+                    dataInputStream.close();\n+                }\n+            }\n+        }\n+        finally {\n+            if (t == null) {\n+                final Throwable exception;\n+                t = exception;\n+            }\n+            else {\n+                final Throwable exception;\n+                if (t != exception) {\n+                    t.addSuppressed(exception);\n+                }\n             }\n-            startHeader.nextHeaderCrc = (0xFFFFFFFFL & (long)Integer.reverseBytes(dataInputStream.readInt()));\n-            return startHeader;\n         }\n     }\n     \n     private void readStreamsInfo(final ByteBuffer header, final Archive archive) throws IOException {\n         int nid = getUnsignedByte(header);\n         if (nid == 6) {\n             this.readPackInfo(header, archive);\n@@ -888,35 +942,41 @@\n         if (nid == 8) {\n             this.readSubStreamsInfo(header, archive);\n             nid = getUnsignedByte(header);\n         }\n     }\n     \n     private void readSubStreamsInfo(final ByteBuffer header, final Archive archive) throws IOException {\n-        for (final Folder folder : archive.folders) {\n+        Folder[] folders;\n+        for (int length = (folders = archive.folders).length, l = 0; l < length; ++l) {\n+            final Folder folder = folders[l];\n             folder.numUnpackSubStreams = 1;\n         }\n         long unpackStreamsCount = (long)archive.folders.length;\n         int nid = getUnsignedByte(header);\n         if (nid == 13) {\n             unpackStreamsCount = 0L;\n-            for (final Folder folder2 : archive.folders) {\n+            Folder[] folders2;\n+            for (int length2 = (folders2 = archive.folders).length, n = 0; n < length2; ++n) {\n+                final Folder folder2 = folders2[n];\n                 final long numStreams = readUint64(header);\n                 folder2.numUnpackSubStreams = (int)numStreams;\n                 unpackStreamsCount += numStreams;\n             }\n             nid = getUnsignedByte(header);\n         }\n         final int totalUnpackStreams = (int)unpackStreamsCount;\n         final SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\n         subStreamsInfo.unpackSizes = new long[totalUnpackStreams];\n         subStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\n         subStreamsInfo.crcs = new long[totalUnpackStreams];\n         int nextUnpackStream = 0;\n-        for (final Folder folder3 : archive.folders) {\n+        Folder[] folders3;\n+        for (int length3 = (folders3 = archive.folders).length, n2 = 0; n2 < length3; ++n2) {\n+            final Folder folder3 = folders3[n2];\n             if (folder3.numUnpackSubStreams != 0) {\n                 long sum = 0L;\n                 if (nid == 9) {\n                     for (int i = 0; i < folder3.numUnpackSubStreams - 1; ++i) {\n                         final long size = readUint64(header);\n                         subStreamsInfo.unpackSizes[nextUnpackStream++] = size;\n                         sum += size;\n@@ -928,30 +988,34 @@\n                 subStreamsInfo.unpackSizes[nextUnpackStream++] = folder3.getUnpackSize() - sum;\n             }\n         }\n         if (nid == 9) {\n             nid = getUnsignedByte(header);\n         }\n         int numDigests = 0;\n-        for (final Folder folder4 : archive.folders) {\n+        Folder[] folders4;\n+        for (int length4 = (folders4 = archive.folders).length, n3 = 0; n3 < length4; ++n3) {\n+            final Folder folder4 = folders4[n3];\n             if (folder4.numUnpackSubStreams != 1 || !folder4.hasCrc) {\n                 numDigests += folder4.numUnpackSubStreams;\n             }\n         }\n         if (nid == 10) {\n             final BitSet hasMissingCrc = this.readAllOrBits(header, numDigests);\n             final long[] missingCrcs = new long[numDigests];\n             for (int j = 0; j < numDigests; ++j) {\n                 if (hasMissingCrc.get(j)) {\n                     missingCrcs[j] = (0xFFFFFFFFL & (long)getInt(header));\n                 }\n             }\n             int nextCrc = 0;\n             int nextMissingCrc = 0;\n-            for (final Folder folder5 : archive.folders) {\n+            Folder[] folders5;\n+            for (int length5 = (folders5 = archive.folders).length, n4 = 0; n4 < length5; ++n4) {\n+                final Folder folder5 = folders5[n4];\n                 if (folder5.numUnpackSubStreams == 1 && folder5.hasCrc) {\n                     subStreamsInfo.hasCrc.set(nextCrc, true);\n                     subStreamsInfo.crcs[nextCrc] = folder5.crc;\n                     ++nextCrc;\n                 }\n                 else {\n                     for (int k = 0; k < folder5.numUnpackSubStreams; ++k) {\n@@ -973,15 +1037,17 @@\n         final Folder[] folders = new Folder[numFoldersInt];\n         archive.folders = folders;\n         getUnsignedByte(header);\n         for (int i = 0; i < numFoldersInt; ++i) {\n             folders[i] = this.readFolder(header);\n         }\n         nid = getUnsignedByte(header);\n-        for (final Folder folder : folders) {\n+        Folder[] array;\n+        for (int length = (array = folders).length, l = 0; l < length; ++l) {\n+            final Folder folder = array[l];\n             assertFitsIntoNonNegativeInt(\"totalOutputStreams\", folder.totalOutputStreams);\n             folder.unpackSizes = new long[(int)folder.totalOutputStreams];\n             for (int j = 0; j < folder.totalOutputStreams; ++j) {\n                 folder.unpackSizes[j] = readUint64(header);\n             }\n         }\n         nid = getUnsignedByte(header);\n@@ -1009,15 +1075,15 @@\n         final Folder folder = this.archive.folders[folderIndex];\n         final int firstPackStreamIndex = this.archive.streamMap.folderFirstPackStreamIndex[folderIndex];\n         final long folderOffset = 32L + this.archive.packPos + this.archive.streamMap.packStreamOffsets[firstPackStreamIndex];\n         this.currentFolderInputStream = this.buildDecoderStack(folder, folderOffset, firstPackStreamIndex, file);\n     }\n     \n     private SevenZFile.ArchiveStatistics sanityCheckAndCollectStatistics(final ByteBuffer header) throws IOException {\n-        final SevenZFile.ArchiveStatistics stats = new SevenZFile.ArchiveStatistics((SevenZFile.SevenZFile$1)null);\n+        final SevenZFile.ArchiveStatistics stats = new SevenZFile.ArchiveStatistics((SevenZFile.ArchiveStatistics)null);\n         int nid = getUnsignedByte(header);\n         if (nid == 2) {\n             this.sanityCheckArchiveProperties(header);\n             nid = getUnsignedByte(header);\n         }\n         if (nid == 3) {\n             throw new IOException(\"Additional streams unsupported\");\n@@ -1042,26 +1108,26 @@\n             if (skipBytesFully(header, propertySize) < propertySize) {\n                 throw new IOException(\"invalid property size\");\n             }\n         }\n     }\n     \n     private void sanityCheckFilesInfo(final ByteBuffer header, final SevenZFile.ArchiveStatistics stats) throws IOException {\n-        SevenZFile.ArchiveStatistics.access$302(stats, assertFitsIntoNonNegativeInt(\"numFiles\", readUint64(header)));\n+        SevenZFile.ArchiveStatistics.access$1(stats, assertFitsIntoNonNegativeInt(\"numFiles\", readUint64(header)));\n         int emptyStreams = -1;\n         while (true) {\n             final int propertyType = getUnsignedByte(header);\n             if (propertyType == 0) {\n-                SevenZFile.ArchiveStatistics.access$402(stats, SevenZFile.ArchiveStatistics.access$300(stats) - Math.max(emptyStreams, 0));\n+                SevenZFile.ArchiveStatistics.access$3(stats, SevenZFile.ArchiveStatistics.access$2(stats) - Math.max(emptyStreams, 0));\n                 return;\n             }\n             final long size = readUint64(header);\n             switch (propertyType) {\n                 case 14: {\n-                    emptyStreams = this.readBits(header, SevenZFile.ArchiveStatistics.access$300(stats)).cardinality();\n+                    emptyStreams = this.readBits(header, SevenZFile.ArchiveStatistics.access$2(stats)).cardinality();\n                     continue;\n                 }\n                 case 15: {\n                     if (emptyStreams == -1) {\n                         throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n                     }\n                     this.readBits(header, emptyStreams);\n@@ -1086,54 +1152,54 @@\n                     int filesSeen = 0;\n                     for (int i = 0; i < namesLength; i += 2) {\n                         final char c = getChar(header);\n                         if (c == '\\0') {\n                             ++filesSeen;\n                         }\n                     }\n-                    if (filesSeen != SevenZFile.ArchiveStatistics.access$300(stats)) {\n-                        throw new IOException(\"Invalid number of file names (\" + filesSeen + \" instead of \" + SevenZFile.ArchiveStatistics.access$300(stats) + \")\");\n+                    if (filesSeen != SevenZFile.ArchiveStatistics.access$2(stats)) {\n+                        throw new IOException(\"Invalid number of file names (\" + filesSeen + \" instead of \" + SevenZFile.ArchiveStatistics.access$2(stats) + \")\");\n                     }\n                     continue;\n                 }\n                 case 18: {\n-                    final int timesDefined = this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$300(stats)).cardinality();\n+                    final int timesDefined = this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$2(stats)).cardinality();\n                     final int external2 = getUnsignedByte(header);\n                     if (external2 != 0) {\n                         throw new IOException(\"Not implemented\");\n                     }\n                     if (skipBytesFully(header, 8 * timesDefined) < 8 * timesDefined) {\n                         throw new IOException(\"invalid creation dates size\");\n                     }\n                     continue;\n                 }\n                 case 19: {\n-                    final int timesDefined = this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$300(stats)).cardinality();\n+                    final int timesDefined = this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$2(stats)).cardinality();\n                     final int external2 = getUnsignedByte(header);\n                     if (external2 != 0) {\n                         throw new IOException(\"Not implemented\");\n                     }\n                     if (skipBytesFully(header, 8 * timesDefined) < 8 * timesDefined) {\n                         throw new IOException(\"invalid access dates size\");\n                     }\n                     continue;\n                 }\n                 case 20: {\n-                    final int timesDefined = this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$300(stats)).cardinality();\n+                    final int timesDefined = this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$2(stats)).cardinality();\n                     final int external2 = getUnsignedByte(header);\n                     if (external2 != 0) {\n                         throw new IOException(\"Not implemented\");\n                     }\n                     if (skipBytesFully(header, 8 * timesDefined) < 8 * timesDefined) {\n                         throw new IOException(\"invalid modification dates size\");\n                     }\n                     continue;\n                 }\n                 case 21: {\n-                    final int attributesDefined = this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$300(stats)).cardinality();\n+                    final int attributesDefined = this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$2(stats)).cardinality();\n                     final int external2 = getUnsignedByte(header);\n                     if (external2 != 0) {\n                         throw new IOException(\"Not implemented\");\n                     }\n                     if (skipBytesFully(header, 4 * attributesDefined) < 4 * attributesDefined) {\n                         throw new IOException(\"invalid windows attributes size\");\n                     }\n@@ -1159,15 +1225,15 @@\n     }\n     \n     private int sanityCheckFolder(final ByteBuffer header, final SevenZFile.ArchiveStatistics stats) throws IOException {\n         final int numCoders = assertFitsIntoNonNegativeInt(\"numCoders\", readUint64(header));\n         if (numCoders == 0) {\n             throw new IOException(\"Folder without coders\");\n         }\n-        SevenZFile.ArchiveStatistics.access$514(stats, (long)numCoders);\n+        SevenZFile.ArchiveStatistics.access$5(stats, SevenZFile.ArchiveStatistics.access$4(stats) + (long)numCoders);\n         long totalOutStreams = 0L;\n         long totalInStreams = 0L;\n         for (int i = 0; i < numCoders; ++i) {\n             final int bits = getUnsignedByte(header);\n             final int idSize = bits & 0xF;\n             get(header, new byte[idSize]);\n             final boolean isSimple = (bits & 0x10) == 0x0;\n@@ -1189,16 +1255,16 @@\n                 if (skipBytesFully(header, propertiesSize) < propertiesSize) {\n                     throw new IOException(\"invalid propertiesSize in folder\");\n                 }\n             }\n         }\n         assertFitsIntoNonNegativeInt(\"totalInStreams\", totalInStreams);\n         assertFitsIntoNonNegativeInt(\"totalOutStreams\", totalOutStreams);\n-        SevenZFile.ArchiveStatistics.access$614(stats, totalOutStreams);\n-        SevenZFile.ArchiveStatistics.access$714(stats, totalInStreams);\n+        SevenZFile.ArchiveStatistics.access$7(stats, SevenZFile.ArchiveStatistics.access$6(stats) + totalOutStreams);\n+        SevenZFile.ArchiveStatistics.access$9(stats, SevenZFile.ArchiveStatistics.access$8(stats) + totalInStreams);\n         if (totalOutStreams == 0L) {\n             throw new IOException(\"Total output streams can't be 0\");\n         }\n         final int numBindPairs = assertFitsIntoNonNegativeInt(\"numBindPairs\", totalOutStreams - 1L);\n         if (totalInStreams < numBindPairs) {\n             throw new IOException(\"Total input streams can't be less than the number of bind pairs\");\n         }\n@@ -1233,30 +1299,30 @@\n     \n     private void sanityCheckPackInfo(final ByteBuffer header, final SevenZFile.ArchiveStatistics stats) throws IOException {\n         final long packPos = readUint64(header);\n         if (packPos < 0L || 32L + packPos > this.channel.size() || 32L + packPos < 0L) {\n             throw new IOException(\"packPos (\" + packPos + \") is out of range\");\n         }\n         final long numPackStreams = readUint64(header);\n-        SevenZFile.ArchiveStatistics.access$802(stats, assertFitsIntoNonNegativeInt(\"numPackStreams\", numPackStreams));\n+        SevenZFile.ArchiveStatistics.access$10(stats, assertFitsIntoNonNegativeInt(\"numPackStreams\", numPackStreams));\n         int nid = getUnsignedByte(header);\n         if (nid == 9) {\n             long totalPackSizes = 0L;\n-            for (int i = 0; i < SevenZFile.ArchiveStatistics.access$800(stats); ++i) {\n+            for (int i = 0; i < SevenZFile.ArchiveStatistics.access$11(stats); ++i) {\n                 final long packSize = readUint64(header);\n                 totalPackSizes += packSize;\n                 final long endOfPackStreams = 32L + packPos + totalPackSizes;\n                 if (packSize < 0L || endOfPackStreams > this.channel.size() || endOfPackStreams < packPos) {\n                     throw new IOException(\"packSize (\" + packSize + \") is out of range\");\n                 }\n             }\n             nid = getUnsignedByte(header);\n         }\n         if (nid == 10) {\n-            final int crcsDefined = this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$800(stats)).cardinality();\n+            final int crcsDefined = this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$11(stats)).cardinality();\n             if (skipBytesFully(header, 4 * crcsDefined) < 4 * crcsDefined) {\n                 throw new IOException(\"invalid number of CRCs in PackInfo\");\n             }\n             nid = getUnsignedByte(header);\n         }\n         if (nid != 0) {\n             throw new IOException(\"Badly terminated PackInfo (\" + nid + \")\");\n@@ -1282,24 +1348,24 @@\n         }\n     }\n     \n     private void sanityCheckSubStreamsInfo(final ByteBuffer header, final SevenZFile.ArchiveStatistics stats) throws IOException {\n         int nid = getUnsignedByte(header);\n         final List<Integer> numUnpackSubStreamsPerFolder = new LinkedList<Integer>();\n         if (nid == 13) {\n-            for (int i = 0; i < SevenZFile.ArchiveStatistics.access$900(stats); ++i) {\n+            for (int i = 0; i < SevenZFile.ArchiveStatistics.access$12(stats); ++i) {\n                 numUnpackSubStreamsPerFolder.add(Integer.valueOf(assertFitsIntoNonNegativeInt(\"numStreams\", readUint64(header))));\n             }\n-            SevenZFile.ArchiveStatistics.access$1002(stats, numUnpackSubStreamsPerFolder.stream().mapToLong(Integer::longValue).sum());\n+            SevenZFile.ArchiveStatistics.access$13(stats, numUnpackSubStreamsPerFolder.stream().mapToLong(Integer::longValue).sum());\n             nid = getUnsignedByte(header);\n         }\n         else {\n-            SevenZFile.ArchiveStatistics.access$1002(stats, (long)SevenZFile.ArchiveStatistics.access$900(stats));\n+            SevenZFile.ArchiveStatistics.access$13(stats, (long)SevenZFile.ArchiveStatistics.access$12(stats));\n         }\n-        assertFitsIntoNonNegativeInt(\"totalUnpackStreams\", SevenZFile.ArchiveStatistics.access$1000(stats));\n+        assertFitsIntoNonNegativeInt(\"totalUnpackStreams\", SevenZFile.ArchiveStatistics.access$14(stats));\n         if (nid == 9) {\n             final Iterator<Integer> iterator = numUnpackSubStreamsPerFolder.iterator();\n             while (iterator.hasNext()) {\n                 final int numUnpackSubStreams = (int)Integer.valueOf(iterator.next());\n                 if (numUnpackSubStreams == 0) {\n                     continue;\n                 }\n@@ -1310,22 +1376,22 @@\n                     }\n                 }\n             }\n             nid = getUnsignedByte(header);\n         }\n         int numDigests = 0;\n         if (numUnpackSubStreamsPerFolder.isEmpty()) {\n-            numDigests = ((SevenZFile.ArchiveStatistics.access$1100(stats) == null) ? SevenZFile.ArchiveStatistics.access$900(stats) : (SevenZFile.ArchiveStatistics.access$900(stats) - SevenZFile.ArchiveStatistics.access$1100(stats).cardinality()));\n+            numDigests = ((SevenZFile.ArchiveStatistics.access$15(stats) == null) ? SevenZFile.ArchiveStatistics.access$12(stats) : (SevenZFile.ArchiveStatistics.access$12(stats) - SevenZFile.ArchiveStatistics.access$15(stats).cardinality()));\n         }\n         else {\n             int folderIdx = 0;\n             final Iterator<Integer> iterator2 = numUnpackSubStreamsPerFolder.iterator();\n             while (iterator2.hasNext()) {\n                 final int numUnpackSubStreams2 = (int)Integer.valueOf(iterator2.next());\n-                if (numUnpackSubStreams2 != 1 || SevenZFile.ArchiveStatistics.access$1100(stats) == null || !SevenZFile.ArchiveStatistics.access$1100(stats).get(folderIdx++)) {\n+                if (numUnpackSubStreams2 != 1 || SevenZFile.ArchiveStatistics.access$15(stats) == null || !SevenZFile.ArchiveStatistics.access$15(stats).get(folderIdx++)) {\n                     numDigests += numUnpackSubStreams2;\n                 }\n             }\n         }\n         if (nid == 10) {\n             assertFitsIntoNonNegativeInt(\"numDigests\", numDigests);\n             final int missingCrcs = this.readAllOrBits(header, numDigests).cardinality();\n@@ -1341,26 +1407,26 @@\n     \n     private void sanityCheckUnpackInfo(final ByteBuffer header, final SevenZFile.ArchiveStatistics stats) throws IOException {\n         int nid = getUnsignedByte(header);\n         if (nid != 11) {\n             throw new IOException(\"Expected kFolder, got \" + nid);\n         }\n         final long numFolders = readUint64(header);\n-        SevenZFile.ArchiveStatistics.access$902(stats, assertFitsIntoNonNegativeInt(\"numFolders\", numFolders));\n+        SevenZFile.ArchiveStatistics.access$16(stats, assertFitsIntoNonNegativeInt(\"numFolders\", numFolders));\n         final int external = getUnsignedByte(header);\n         if (external != 0) {\n             throw new IOException(\"External unsupported\");\n         }\n         final List<Integer> numberOfOutputStreamsPerFolder = new LinkedList<Integer>();\n-        for (int i = 0; i < SevenZFile.ArchiveStatistics.access$900(stats); ++i) {\n+        for (int i = 0; i < SevenZFile.ArchiveStatistics.access$12(stats); ++i) {\n             numberOfOutputStreamsPerFolder.add(Integer.valueOf(this.sanityCheckFolder(header, stats)));\n         }\n-        final long totalNumberOfBindPairs = SevenZFile.ArchiveStatistics.access$600(stats) - SevenZFile.ArchiveStatistics.access$900(stats);\n-        final long packedStreamsRequiredByFolders = SevenZFile.ArchiveStatistics.access$700(stats) - totalNumberOfBindPairs;\n-        if (packedStreamsRequiredByFolders < SevenZFile.ArchiveStatistics.access$800(stats)) {\n+        final long totalNumberOfBindPairs = SevenZFile.ArchiveStatistics.access$6(stats) - SevenZFile.ArchiveStatistics.access$12(stats);\n+        final long packedStreamsRequiredByFolders = SevenZFile.ArchiveStatistics.access$8(stats) - totalNumberOfBindPairs;\n+        if (packedStreamsRequiredByFolders < SevenZFile.ArchiveStatistics.access$11(stats)) {\n             throw new IOException(\"archive doesn't contain enough packed streams\");\n         }\n         nid = getUnsignedByte(header);\n         if (nid != 12) {\n             throw new IOException(\"Expected kCodersUnpackSize, got \" + nid);\n         }\n         final Iterator<Integer> iterator = numberOfOutputStreamsPerFolder.iterator();\n@@ -1370,16 +1436,16 @@\n                 if (unpackSize < 0L) {\n                     throw new IllegalArgumentException(\"negative unpackSize\");\n                 }\n             }\n         }\n         nid = getUnsignedByte(header);\n         if (nid == 10) {\n-            SevenZFile.ArchiveStatistics.access$1102(stats, this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$900(stats)));\n-            final int crcsDefined = SevenZFile.ArchiveStatistics.access$1100(stats).cardinality();\n+            SevenZFile.ArchiveStatistics.access$17(stats, this.readAllOrBits(header, SevenZFile.ArchiveStatistics.access$12(stats)));\n+            final int crcsDefined = SevenZFile.ArchiveStatistics.access$15(stats).cardinality();\n             if (skipBytesFully(header, 4 * crcsDefined) < 4 * crcsDefined) {\n                 throw new IOException(\"invalid number of CRCs in UnpackInfo\");\n             }\n             nid = getUnsignedByte(header);\n         }\n         if (nid != 0) {\n             throw new IOException(\"Badly terminated UnpackInfo\");\n@@ -1452,12 +1518,8 @@\n                 }\n                 continue;\n             }\n             catch (final Exception ex) {}\n         }\n         throw new IOException(\"Start header corrupt and unable to guess end header\");\n     }\n-    \n-    static {\n-        sevenZSignature = new byte[] { 55, 122, -68, -81, 39, 28 };\n-    }\n }\n"}]}
