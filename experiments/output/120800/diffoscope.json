{"diffoscope-json-version": 1, "source1": "first/JavadocMetadataScraper.class", "source2": "second/JavadocMetadataScraper.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,12 +1,10 @@\n \n package com.puppycrawl.tools.checkstyle.meta;\n \n-import java.util.HashMap;\n-import java.util.Objects;\n import com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n import java.util.Collections;\n import java.util.stream.Collector;\n import java.util.stream.Collectors;\n import java.util.Arrays;\n import java.util.function.Function;\n import java.util.Deque;\n@@ -15,14 +13,15 @@\n import java.util.LinkedHashSet;\n import java.util.Optional;\n import java.util.regex.Matcher;\n import java.util.Locale;\n import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.TransformerException;\n import com.puppycrawl.tools.checkstyle.api.DetailAST;\n+import java.util.HashMap;\n import com.puppycrawl.tools.checkstyle.api.DetailNode;\n import java.util.Set;\n import java.util.regex.Pattern;\n import java.util.Map;\n import com.puppycrawl.tools.checkstyle.FileStatefulCheck;\n import com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\n \n@@ -51,14 +50,30 @@\n     private boolean toScan;\n     private DetailNode rootNode;\n     private int propertySectionStartIdx;\n     private int exampleSectionStartIdx;\n     private int parentSectionStartIdx;\n     private boolean writeXmlOutput;\n     \n+    static {\n+        MODULE_DETAILS_STORE = new HashMap<String, ModuleDetails>();\n+        PROPERTY_TAG = Pattern.compile(\"\\\\s*Property\\\\s*\");\n+        TYPE_TAG = Pattern.compile(\"^ Type is\\\\s.*\");\n+        VALIDATION_TYPE_TAG = Pattern.compile(\"\\\\s.*Validation type is\\\\s.*\");\n+        DEFAULT_VALUE_TAG = Pattern.compile(\"^ Default value is:*.*\");\n+        EXAMPLES_TAG = Pattern.compile(\"\\\\s*To configure the (default )?check.*\");\n+        PARENT_TAG = Pattern.compile(\"\\\\s*Parent is\\\\s*\");\n+        VIOLATION_MESSAGES_TAG = Pattern.compile(\"\\\\s*Violation Message Keys:\\\\s*\");\n+        TOKEN_TEXT_PATTERN = Pattern.compile(\"([A-Z_]{2,})+\");\n+        DESC_CLEAN = Pattern.compile(\"-\\\\s\");\n+        FILE_SEPARATOR_PATTERN = Pattern.compile(Pattern.quote(System.getProperty(\"file.separator\")));\n+        QUOTE_PATTERN = Pattern.compile(\"\\\"\");\n+        PROPERTIES_TO_NOT_WRITE = Set.of(\"null\", \"the charset property of the parent <a href=https://checkstyle.org/config.html#Checker>Checker</a> module\");\n+    }\n+    \n     public JavadocMetadataScraper() {\n         this.writeXmlOutput = true;\n     }\n     \n     public final void setWriteXmlOutput(final boolean writeXmlOutput) {\n         this.writeXmlOutput = writeXmlOutput;\n     }\n@@ -114,15 +129,15 @@\n                 this.log(rootAst.getLineNumber(), \"javadocmetadatascraper.description.missing\", new Object[] { fullQualifiedName.substring(fullQualifiedName.lastIndexOf(46) + 1) });\n             }\n             else if (this.writeXmlOutput) {\n                 try {\n                     XmlMetaWriter.write(this.moduleDetails);\n                 }\n                 catch (final TransformerException | ParserConfigurationException ex) {\n-                    throw new IllegalStateException(\"Failed to write metadata into XML file for module: \" + this.getModuleSimpleName(), (Throwable)ex);\n+                    throw new IllegalStateException(\"Failed to write metadata into XML file for module: \" + this.getModuleSimpleName(), ex);\n                 }\n             }\n             if (!this.writeXmlOutput) {\n                 JavadocMetadataScraper.MODULE_DETAILS_STORE.put(this.moduleDetails.getFullQualifiedName(), this.moduleDetails);\n             }\n         }\n     }\n@@ -156,28 +171,28 @@\n     private static ModulePropertyDetails createProperties(final DetailNode nodeLi) {\n         final ModulePropertyDetails modulePropertyDetails = new ModulePropertyDetails();\n         final Optional<DetailNode> propertyNameNode = getFirstChildOfType(nodeLi, 10072, 0);\n         if (propertyNameNode.isPresent()) {\n             final DetailNode propertyNameTag = (DetailNode)propertyNameNode.get();\n             final String propertyName = getTextFromTag(propertyNameTag);\n             final DetailNode propertyType = (DetailNode)getFirstChildOfMatchingText(nodeLi, JavadocMetadataScraper.TYPE_TAG).orElseThrow(() -> {\n-                new MetadataGenerationException(String.format(Locale.ROOT, \"Type for property '%s' is missing\", propertyName));\n+                new MetadataGenerationException(String.format(Locale.ROOT, \"Type for property '%s' is missing\", s));\n                 return;\n             });\n             final String propertyDesc = JavadocMetadataScraper.DESC_CLEAN.matcher(constructSubTreeText(nodeLi, propertyNameTag.getIndex() + 1, propertyType.getIndex() - 1)).replaceAll(Matcher.quoteReplacement(\"\"));\n             modulePropertyDetails.setDescription(propertyDesc.trim());\n             modulePropertyDetails.setName(propertyName);\n             modulePropertyDetails.setType(getTagTextFromProperty(nodeLi, propertyType));\n             final Optional<DetailNode> validationTypeNodeOpt = getFirstChildOfMatchingText(nodeLi, JavadocMetadataScraper.VALIDATION_TYPE_TAG);\n             if (validationTypeNodeOpt.isPresent()) {\n                 final DetailNode validationTypeNode = (DetailNode)validationTypeNodeOpt.get();\n                 modulePropertyDetails.setValidationType(getTagTextFromProperty(nodeLi, validationTypeNode));\n             }\n-            final String defaultValue = (String)getFirstChildOfMatchingText(nodeLi, JavadocMetadataScraper.DEFAULT_VALUE_TAG).map(defaultValueNode -> getPropertyDefaultText(nodeLi, defaultValueNode)).orElseThrow(() -> {\n-                new MetadataGenerationException(String.format(Locale.ROOT, \"Default value for property '%s' is missing\", propertyName));\n+            final String defaultValue = (String)getFirstChildOfMatchingText(nodeLi, JavadocMetadataScraper.DEFAULT_VALUE_TAG).map(defaultValueNode -> getPropertyDefaultText(nodeLi2, defaultValueNode)).orElseThrow(() -> {\n+                new MetadataGenerationException(String.format(Locale.ROOT, \"Default value for property '%s' is missing\", s2));\n                 return;\n             });\n             if (!JavadocMetadataScraper.PROPERTIES_TO_NOT_WRITE.contains(defaultValue)) {\n                 modulePropertyDetails.setDefaultValue(defaultValue);\n             }\n         }\n         return modulePropertyDetails;\n@@ -211,28 +226,28 @@\n             detailNode = stack.removeFirst();\n             if (visited.add(detailNode)) {\n                 final String childText = detailNode.getText();\n                 if (detailNode.getType() != 1 && !JavadocMetadataScraper.TOKEN_TEXT_PATTERN.matcher(childText).matches()) {\n                     result.insert(0, childText);\n                 }\n             }\n-            for (final DetailNode child : detailNode.getChildren()) {\n-                Label_0205: {\n-                    if (child.getParent().equals((Object)node)) {\n-                        if (child.getIndex() < childLeftLimit) {\n-                            break Label_0205;\n-                        }\n-                        if (child.getIndex() > childRightLimit) {\n-                            break Label_0205;\n-                        }\n+            DetailNode[] children;\n+            for (int length = (children = detailNode.getChildren()).length, i = 0; i < length; ++i) {\n+                final DetailNode child = children[i];\n+                if (child.getParent().equals(node)) {\n+                    if (child.getIndex() < childLeftLimit) {\n+                        continue;\n                     }\n-                    if (!visited.contains(child)) {\n-                        stack.addFirst(child);\n+                    if (child.getIndex() > childRightLimit) {\n+                        continue;\n                     }\n                 }\n+                if (!visited.contains(child)) {\n+                    stack.addFirst(child);\n+                }\n             }\n         }\n         return result.toString().trim();\n     }\n     \n     private String getDescriptionText() {\n         int descriptionEndIdx;\n@@ -267,23 +282,23 @@\n     }\n     \n     private static String getTextFromTag(final DetailNode nodeTag) {\n         return Optional.ofNullable(nodeTag).map((Function<? super DetailNode, ? extends String>)JavadocMetadataScraper::getText).orElse(\"\");\n     }\n     \n     private static Optional<DetailNode> getFirstChildOfType(final DetailNode node, final int tokenType, final int offset) {\n-        return Arrays.stream(node.getChildren()).filter(child -> child.getIndex() >= offset && child.getType() == tokenType).findFirst();\n+        return Arrays.stream(node.getChildren()).filter(child -> child.getIndex() >= n && child.getType() == n2).findFirst();\n     }\n     \n     private static String getText(final DetailNode parentNode) {\n         return Arrays.stream(parentNode.getChildren()).filter(child -> child.getType() == 10074).map(node -> JavadocMetadataScraper.QUOTE_PATTERN.matcher(node.getText().trim()).replaceAll(\"\")).collect((Collector<? super Object, ?, String>)Collectors.joining(\" \"));\n     }\n     \n     private static Optional<DetailNode> getFirstChildOfMatchingText(final DetailNode node, final Pattern pattern) {\n-        return Arrays.stream(node.getChildren()).filter(child -> pattern.matcher(child.getText()).matches()).findFirst();\n+        return Arrays.stream(node.getChildren()).filter(child -> pattern2.matcher(child.getText()).matches()).findFirst();\n     }\n     \n     private static DetailAST getParent(final DetailAST commentBlock) {\n         DetailAST result;\n         final DetailAST parentNode = result = commentBlock.getParent();\n         if (result.getType() == 159) {\n             result = parentNode.getParent().getParent();\n@@ -343,15 +358,15 @@\n     \n     public static void resetModuleDetailsStore() {\n         JavadocMetadataScraper.MODULE_DETAILS_STORE.clear();\n     }\n     \n     private boolean isTopLevelClassJavadoc() {\n         final DetailAST parent = getParent(this.getBlockCommentAst());\n-        final Optional<DetailAST> className = TokenUtil.findFirstTokenByPredicate(parent, child -> parent.getType() == 14 && child.getType() == 58);\n+        final Optional<DetailAST> className = TokenUtil.findFirstTokenByPredicate(parent, child -> detailAST.getType() == 14 && child.getType() == 58);\n         return className.isPresent() && this.getModuleSimpleName().equals(((DetailAST)className.get()).getText());\n     }\n     \n     private static boolean isExamplesText(final DetailNode ast) {\n         return isChildNodeTextMatches(ast, JavadocMetadataScraper.EXAMPLES_TAG);\n     }\n     \n@@ -364,28 +379,10 @@\n     }\n     \n     private static boolean isParentText(final DetailNode nodeParagraph) {\n         return isChildNodeTextMatches(nodeParagraph, JavadocMetadataScraper.PARENT_TAG);\n     }\n     \n     private static boolean isChildNodeTextMatches(final DetailNode ast, final Pattern pattern) {\n-        final Optional<Object> map = getFirstChildOfType(ast, 10074, 0).map((Function<? super DetailNode, ?>)DetailNode::getText);\n-        Objects.requireNonNull(pattern);\n-        return Boolean.valueOf(map.map((Function<? super Object, ?>)pattern::matcher).map((Function<? super Object, ?>)Matcher::matches).orElse(Boolean.FALSE));\n-    }\n-    \n-    static {\n-        MODULE_DETAILS_STORE = new HashMap<String, ModuleDetails>();\n-        PROPERTY_TAG = Pattern.compile(\"\\\\s*Property\\\\s*\");\n-        TYPE_TAG = Pattern.compile(\"^ Type is\\\\s.*\");\n-        VALIDATION_TYPE_TAG = Pattern.compile(\"\\\\s.*Validation type is\\\\s.*\");\n-        DEFAULT_VALUE_TAG = Pattern.compile(\"^ Default value is:*.*\");\n-        EXAMPLES_TAG = Pattern.compile(\"\\\\s*To configure the (default )?check.*\");\n-        PARENT_TAG = Pattern.compile(\"\\\\s*Parent is\\\\s*\");\n-        VIOLATION_MESSAGES_TAG = Pattern.compile(\"\\\\s*Violation Message Keys:\\\\s*\");\n-        TOKEN_TEXT_PATTERN = Pattern.compile(\"([A-Z_]{2,})+\");\n-        DESC_CLEAN = Pattern.compile(\"-\\\\s\");\n-        FILE_SEPARATOR_PATTERN = Pattern.compile(Pattern.quote(System.getProperty(\"file.separator\")));\n-        QUOTE_PATTERN = Pattern.compile(\"\\\"\");\n-        PROPERTIES_TO_NOT_WRITE = Set.of(\"null\", \"the charset property of the parent <a href=https://checkstyle.org/config.html#Checker>Checker</a> module\");\n+        return Boolean.valueOf(getFirstChildOfType(ast, 10074, 0).map((Function<? super DetailNode, ?>)DetailNode::getText).map((Function<? super Object, ?>)pattern::matcher).map((Function<? super Object, ? extends Boolean>)Matcher::matches).orElse(Boolean.FALSE));\n     }\n }\n"}]}
