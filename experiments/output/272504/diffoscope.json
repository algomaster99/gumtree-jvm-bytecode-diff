{"diffoscope-json-version": 1, "source1": "first/PropertyCacheFile.class", "source2": "second/PropertyCacheFile.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,12 +1,11 @@\n \n package com.puppycrawl.tools.checkstyle;\n \n import java.util.function.Predicate;\n-import java.net.URI;\n import com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n import java.util.Iterator;\n import com.puppycrawl.tools.checkstyle.api.CheckstyleException;\n import java.util.HashSet;\n import java.util.Set;\n import java.io.ObjectOutputStream;\n import java.security.NoSuchAlgorithmException;\n@@ -50,149 +49,140 @@\n         }\n         this.config = config;\n         this.fileName = fileName;\n     }\n     \n     public void load() throws IOException {\n         this.configHash = getHashCodeBasedOnObjectContent((Serializable)this.config);\n-        final Path path = Path.of(this.fileName, new String[0]);\n-        if (Files.exists(path, new LinkOption[0])) {\n-            try (final InputStream inStream = Files.newInputStream(path, new OpenOption[0])) {\n-                this.details.load(inStream);\n-                final String cachedConfigHash = this.details.getProperty(\"configuration*?\");\n-                if (!this.configHash.equals(cachedConfigHash)) {\n+        final Path of = Path.of(this.fileName, new String[0]);\n+        if (Files.exists(of, new LinkOption[0])) {\n+            try (final InputStream inputStream = Files.newInputStream(of, new OpenOption[0])) {\n+                this.details.load(inputStream);\n+                if (!this.configHash.equals(this.details.getProperty(\"configuration*?\"))) {\n                     this.reset();\n                 }\n             }\n         }\n         else {\n             this.reset();\n         }\n     }\n     \n     public void persist() throws IOException {\n-        final Path path = Paths.get(this.fileName, new String[0]);\n-        final Path directory = path.getParent();\n-        if (directory != null) {\n-            Files.createDirectories(directory, (FileAttribute<?>[])new FileAttribute[0]);\n+        final Path value = Paths.get(this.fileName, new String[0]);\n+        final Path parent = value.getParent();\n+        if (parent != null) {\n+            Files.createDirectories(parent, (FileAttribute<?>[])new FileAttribute[0]);\n         }\n-        try (final OutputStream out = Files.newOutputStream(path, new OpenOption[0])) {\n-            this.details.store(out, null);\n+        try (final OutputStream outputStream = Files.newOutputStream(value, new OpenOption[0])) {\n+            this.details.store(outputStream, null);\n         }\n     }\n     \n     public void reset() {\n         this.details.clear();\n         this.details.setProperty(\"configuration*?\", this.configHash);\n     }\n     \n-    public boolean isInCache(final String uncheckedFileName, final long timestamp) {\n-        final String lastChecked = this.details.getProperty(uncheckedFileName);\n-        return Objects.equals(lastChecked, Long.toString(timestamp));\n+    public boolean isInCache(final String key, final long i) {\n+        return Objects.equals(this.details.getProperty(key), Long.toString(i));\n     }\n     \n-    public void put(final String checkedFileName, final long timestamp) {\n-        this.details.setProperty(checkedFileName, Long.toString(timestamp));\n+    public void put(final String key, final long i) {\n+        this.details.setProperty(key, Long.toString(i));\n     }\n     \n-    public String get(final String name) {\n-        return this.details.getProperty(name);\n+    public String get(final String key) {\n+        return this.details.getProperty(key);\n     }\n     \n-    public void remove(final String checkedFileName) {\n-        this.details.remove(checkedFileName);\n+    public void remove(final String key) {\n+        this.details.remove(key);\n     }\n     \n-    private static String getHashCodeBasedOnObjectContent(final Serializable object) {\n+    private static String getHashCodeBasedOnObjectContent(final Serializable s) {\n         try {\n-            final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n-            serialize(object, outputStream);\n-            final MessageDigest digest = MessageDigest.getInstance(\"SHA-1\");\n-            digest.update(outputStream.toByteArray());\n-            return new BigInteger(1, digest.digest()).toString(16).toUpperCase(Locale.ROOT);\n+            final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+            serialize(s, byteArrayOutputStream);\n+            final MessageDigest instance = MessageDigest.getInstance(\"SHA-1\");\n+            instance.update(byteArrayOutputStream.toByteArray());\n+            return new BigInteger(1, instance.digest()).toString(16).toUpperCase(Locale.ROOT);\n         }\n-        catch (final IOException | NoSuchAlgorithmException ex) {\n-            throw new IllegalStateException(\"Unable to calculate hashcode.\", ex);\n+        catch (final IOException | NoSuchAlgorithmException cause) {\n+            throw new IllegalStateException(\"Unable to calculate hashcode.\", (Throwable)cause);\n         }\n     }\n     \n-    private static void serialize(final Serializable object, final OutputStream outputStream) throws IOException {\n-        try (final ObjectOutputStream oos = new ObjectOutputStream(outputStream)) {\n-            oos.writeObject(object);\n+    private static void serialize(final Serializable obj, final OutputStream out) throws IOException {\n+        try (final ObjectOutputStream objectOutputStream = new ObjectOutputStream(out)) {\n+            objectOutputStream.writeObject(obj);\n         }\n     }\n     \n-    public void putExternalResources(final Set<String> locations) {\n-        final Set<PropertyCacheFile.ExternalResource> resources = loadExternalResources(locations);\n-        if (this.areExternalResourcesChanged(resources)) {\n+    public void putExternalResources(final Set<String> set) {\n+        final Set<PropertyCacheFile.ExternalResource> loadExternalResources = loadExternalResources(set);\n+        if (this.areExternalResourcesChanged(loadExternalResources)) {\n             this.reset();\n-            this.fillCacheWithExternalResources(resources);\n+            this.fillCacheWithExternalResources(loadExternalResources);\n         }\n     }\n     \n-    private static Set<PropertyCacheFile.ExternalResource> loadExternalResources(final Set<String> resourceLocations) {\n-        final Set<PropertyCacheFile.ExternalResource> resources = new HashSet<PropertyCacheFile.ExternalResource>();\n-        for (String location : resourceLocations) {\n+    private static Set<PropertyCacheFile.ExternalResource> loadExternalResources(final Set<String> set) {\n+        final HashSet set2 = new HashSet();\n+        for (String s : set) {\n             try {\n-                final byte[] content = loadExternalResource(location);\n-                final String contentHashSum = getHashCodeBasedOnObjectContent(content);\n-                resources.add(new PropertyCacheFile.ExternalResource(\"module-resource*?:\" + location, contentHashSum));\n+                set2.add(new PropertyCacheFile.ExternalResource(\"module-resource*?:\" + s, getHashCodeBasedOnObjectContent(loadExternalResource(s))));\n             }\n             catch (final CheckstyleException | IOException ex) {\n-                final String contentHashSum = getHashCodeBasedOnObjectContent(ex);\n-                resources.add(new PropertyCacheFile.ExternalResource(\"module-resource*?:\" + location, contentHashSum));\n+                set2.add(new PropertyCacheFile.ExternalResource(\"module-resource*?:\" + s, getHashCodeBasedOnObjectContent((Serializable)ex)));\n             }\n         }\n-        return resources;\n+        return set2;\n     }\n     \n-    private static byte[] loadExternalResource(final String location) throws IOException, CheckstyleException {\n-        final URI uri = CommonUtil.getUriByFilename(location);\n-        try (final InputStream is = uri.toURL().openStream()) {\n-            return toByteArray(is);\n+    private static byte[] loadExternalResource(final String s) throws IOException, CheckstyleException {\n+        try (final InputStream openStream = CommonUtil.getUriByFilename(s).toURL().openStream()) {\n+            return toByteArray(openStream);\n         }\n     }\n     \n-    private static byte[] toByteArray(final InputStream stream) throws IOException {\n-        final ByteArrayOutputStream content = new ByteArrayOutputStream();\n+    private static byte[] toByteArray(final InputStream inputStream) throws IOException {\n+        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n         while (true) {\n-            final int size = stream.read(PropertyCacheFile.BUFFER);\n-            if (size == -1) {\n+            final int read = inputStream.read(PropertyCacheFile.BUFFER);\n+            if (read == -1) {\n                 break;\n             }\n-            content.write(PropertyCacheFile.BUFFER, 0, size);\n+            byteArrayOutputStream.write(PropertyCacheFile.BUFFER, 0, read);\n         }\n-        return content.toByteArray();\n+        return byteArrayOutputStream.toByteArray();\n     }\n     \n-    private boolean areExternalResourcesChanged(final Set<PropertyCacheFile.ExternalResource> resources) {\n-        return resources.stream().anyMatch((Predicate<? super Object>)this::isResourceChanged);\n+    private boolean areExternalResourcesChanged(final Set<PropertyCacheFile.ExternalResource> set) {\n+        return set.stream().anyMatch((Predicate<? super Object>)this::isResourceChanged);\n     }\n     \n-    private boolean isResourceChanged(final PropertyCacheFile.ExternalResource resource) {\n-        boolean changed = false;\n-        if (this.isResourceLocationInCache(resource.location)) {\n-            final String contentHashSum = resource.contentHashSum;\n-            final String cachedHashSum = this.details.getProperty(resource.location);\n-            if (!cachedHashSum.equals(contentHashSum)) {\n-                changed = true;\n+    private boolean isResourceChanged(final PropertyCacheFile.ExternalResource externalResource) {\n+        boolean b = false;\n+        if (this.isResourceLocationInCache(externalResource.location)) {\n+            if (!this.details.getProperty(externalResource.location).equals(externalResource.contentHashSum)) {\n+                b = true;\n             }\n         }\n         else {\n-            changed = true;\n+            b = true;\n         }\n-        return changed;\n+        return b;\n     }\n     \n-    private void fillCacheWithExternalResources(final Set<PropertyCacheFile.ExternalResource> externalResources) {\n-        externalResources.forEach(resource -> this.details.setProperty(resource.location, resource.contentHashSum));\n+    private void fillCacheWithExternalResources(final Set<PropertyCacheFile.ExternalResource> set) {\n+        set.forEach(externalResource -> this.details.setProperty(externalResource.location, externalResource.contentHashSum));\n     }\n     \n-    private boolean isResourceLocationInCache(final String location) {\n-        final String cachedHashSum = this.details.getProperty(location);\n-        return cachedHashSum != null;\n+    private boolean isResourceLocationInCache(final String key) {\n+        return this.details.getProperty(key) != null;\n     }\n     \n     static {\n         BUFFER = new byte[1024];\n     }\n }\n"}]}
