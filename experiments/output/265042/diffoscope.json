{"diffoscope-json-version": 1, "source1": "first/MethodGen.class", "source2": "second/MethodGen.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -56,382 +56,364 @@\n         return code.getCode();\n     }\n     \n     public static BCELComparator getComparator() {\n         return MethodGen.bcelComparator;\n     }\n     \n-    public static int getMaxStack(final ConstantPoolGen cp, final InstructionList il, final CodeExceptionGen[] et) {\n-        final MethodGen.BranchStack branchTargets = new MethodGen.BranchStack();\n-        for (final CodeExceptionGen element : et) {\n-            final InstructionHandle handler_pc = element.getHandlerPC();\n-            if (handler_pc != null) {\n-                branchTargets.push(handler_pc, 1);\n+    public static int getMaxStack(final ConstantPoolGen constantPoolGen, final InstructionList list, final CodeExceptionGen[] array) {\n+        final MethodGen.BranchStack branchStack = new MethodGen.BranchStack();\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            final InstructionHandle handlerPC = array[i].getHandlerPC();\n+            if (handlerPC != null) {\n+                branchStack.push(handlerPC, 1);\n             }\n         }\n         int stackDepth = 0;\n-        int maxStackDepth = 0;\n-        InstructionHandle ih = il.getStart();\n-        while (ih != null) {\n-            final Instruction instruction = ih.getInstruction();\n+        int n = 0;\n+        InstructionHandle instructionHandle = list.getStart();\n+        while (instructionHandle != null) {\n+            final Instruction instruction = instructionHandle.getInstruction();\n             final short opcode = instruction.getOpcode();\n-            final int delta = instruction.produceStack(cp) - instruction.consumeStack(cp);\n-            stackDepth += delta;\n-            if (stackDepth > maxStackDepth) {\n-                maxStackDepth = stackDepth;\n+            stackDepth += instruction.produceStack(constantPoolGen) - instruction.consumeStack(constantPoolGen);\n+            if (stackDepth > n) {\n+                n = stackDepth;\n             }\n             if (instruction instanceof BranchInstruction) {\n-                final BranchInstruction branch = (BranchInstruction)instruction;\n+                final BranchInstruction branchInstruction = (BranchInstruction)instruction;\n                 if (instruction instanceof Select) {\n-                    final Select select = (Select)branch;\n-                    final InstructionHandle[] targets2;\n-                    final InstructionHandle[] targets = targets2 = select.getTargets();\n-                    for (final InstructionHandle target : targets2) {\n-                        branchTargets.push(target, stackDepth);\n+                    final InstructionHandle[] targets = ((Select)branchInstruction).getTargets();\n+                    for (int length2 = targets.length, j = 0; j < length2; ++j) {\n+                        branchStack.push(targets[j], stackDepth);\n                     }\n-                    ih = null;\n+                    instructionHandle = null;\n                 }\n-                else if (!(branch instanceof IfInstruction)) {\n+                else if (!(branchInstruction instanceof IfInstruction)) {\n                     if (opcode == 168 || opcode == 201) {\n-                        branchTargets.push(ih.getNext(), stackDepth - 1);\n+                        branchStack.push(instructionHandle.getNext(), stackDepth - 1);\n                     }\n-                    ih = null;\n+                    instructionHandle = null;\n                 }\n-                branchTargets.push(branch.getTarget(), stackDepth);\n+                branchStack.push(branchInstruction.getTarget(), stackDepth);\n             }\n             else if (opcode == 191 || opcode == 169 || (opcode >= 172 && opcode <= 177)) {\n-                ih = null;\n+                instructionHandle = null;\n             }\n-            if (ih != null) {\n-                ih = ih.getNext();\n+            if (instructionHandle != null) {\n+                instructionHandle = instructionHandle.getNext();\n             }\n-            if (ih == null) {\n-                final MethodGen.BranchTarget bt = branchTargets.pop();\n-                if (bt == null) {\n+            if (instructionHandle == null) {\n+                final MethodGen.BranchTarget pop = branchStack.pop();\n+                if (pop == null) {\n                     continue;\n                 }\n-                ih = bt.target;\n-                stackDepth = bt.stackDepth;\n+                instructionHandle = pop.target;\n+                stackDepth = pop.stackDepth;\n             }\n         }\n-        return maxStackDepth;\n+        return n;\n     }\n     \n-    public static void setComparator(final BCELComparator comparator) {\n-        MethodGen.bcelComparator = comparator;\n+    public static void setComparator(final BCELComparator bcelComparator) {\n+        MethodGen.bcelComparator = bcelComparator;\n     }\n     \n-    public MethodGen(final int accessFlags, final Type returnType, final Type[] argTypes, String[] argNames, final String methodName, final String className, final InstructionList il, final ConstantPoolGen cp) {\n-        super(accessFlags);\n+    public MethodGen(final int n, final Type type, final Type[] argumentTypes, String[] array, final String name, final String className, final InstructionList instructionList, final ConstantPoolGen constantPool) {\n+        super(n);\n         this.variableList = new ArrayList<LocalVariableGen>();\n         this.lineNumberList = new ArrayList<LineNumberGen>();\n         this.exceptionList = new ArrayList<CodeExceptionGen>();\n         this.throwsList = new ArrayList<String>();\n         this.codeAttrsList = new ArrayList<Attribute>();\n-        this.setType(returnType);\n-        this.setArgumentTypes(argTypes);\n-        this.setArgumentNames(argNames);\n-        this.setName(methodName);\n+        this.setType(type);\n+        this.setArgumentTypes(argumentTypes);\n+        this.setArgumentNames(array);\n+        this.setName(name);\n         this.setClassName(className);\n-        this.setInstructionList(il);\n-        this.setConstantPool(cp);\n-        final boolean abstract_ = this.isAbstract() || this.isNative();\n+        this.setInstructionList(instructionList);\n+        this.setConstantPool(constantPool);\n+        final boolean b = this.isAbstract() || this.isNative();\n         InstructionHandle start = null;\n-        final InstructionHandle end = null;\n-        if (!abstract_) {\n-            start = il.getStart();\n+        final InstructionHandle instructionHandle = null;\n+        if (!b) {\n+            start = instructionList.getStart();\n             if (!this.isStatic() && className != null) {\n-                this.addLocalVariable(\"this\", (Type)ObjectType.getInstance(className), start, end);\n+                this.addLocalVariable(\"this\", (Type)ObjectType.getInstance(className), start, instructionHandle);\n             }\n         }\n-        if (argTypes != null) {\n-            final int size = argTypes.length;\n-            for (final Type argType : argTypes) {\n-                if (Type.VOID == argType) {\n+        if (argumentTypes != null) {\n+            final int length = argumentTypes.length;\n+            for (int length2 = argumentTypes.length, i = 0; i < length2; ++i) {\n+                if (Type.VOID == argumentTypes[i]) {\n                     throw new ClassGenException(\"'void' is an illegal argument type for a method\");\n                 }\n             }\n-            if (argNames != null) {\n-                if (size != argNames.length) {\n-                    throw new ClassGenException(\"Mismatch in argument array lengths: \" + size + \" vs. \" + argNames.length);\n+            if (array != null) {\n+                if (length != array.length) {\n+                    throw new ClassGenException(\"Mismatch in argument array lengths: \" + length + \" vs. \" + array.length);\n                 }\n             }\n             else {\n-                argNames = new String[size];\n-                for (int i = 0; i < size; ++i) {\n-                    argNames[i] = \"arg\" + i;\n-                }\n-                this.setArgumentNames(argNames);\n-            }\n-            if (!abstract_) {\n-                for (int i = 0; i < size; ++i) {\n-                    this.addLocalVariable(argNames[i], argTypes[i], start, end);\n+                array = new String[length];\n+                for (int j = 0; j < length; ++j) {\n+                    array[j] = \"arg\" + j;\n+                }\n+                this.setArgumentNames(array);\n+            }\n+            if (!b) {\n+                for (int k = 0; k < length; ++k) {\n+                    this.addLocalVariable(array[k], argumentTypes[k], start, instructionHandle);\n                 }\n             }\n         }\n     }\n     \n-    public MethodGen(final Method method, final String className, final ConstantPoolGen cp) {\n-        this(method.getAccessFlags(), Type.getReturnType(method.getSignature()), Type.getArgumentTypes(method.getSignature()), null, method.getName(), className, ((method.getAccessFlags() & 0x500) == 0x0) ? new InstructionList(getByteCodes(method)) : null, cp);\n-        final Attribute[] attributes2;\n-        final Attribute[] attributes = attributes2 = method.getAttributes();\n-        for (Attribute a : attributes2) {\n-            final Attribute attribute = a;\n-            if (a instanceof Code) {\n-                final Code c = (Code)a;\n-                this.setMaxStack(c.getMaxStack());\n-                this.setMaxLocals(c.getMaxLocals());\n-                final CodeException[] ces = c.getExceptionTable();\n-                if (ces != null) {\n-                    for (final CodeException ce : ces) {\n-                        final int type = ce.getCatchType();\n-                        ObjectType cType = null;\n-                        if (type > 0) {\n-                            final String cen = method.getConstantPool().getConstantString(type, (byte)7);\n-                            cType = ObjectType.getInstance(cen);\n+    public MethodGen(final Method method, final String s, final ConstantPoolGen constantPoolGen) {\n+        this(method.getAccessFlags(), Type.getReturnType(method.getSignature()), Type.getArgumentTypes(method.getSignature()), null, method.getName(), s, ((method.getAccessFlags() & 0x500) == 0x0) ? new InstructionList(getByteCodes(method)) : null, constantPoolGen);\n+        for (final Attribute attribute : method.getAttributes()) {\n+            if (attribute instanceof Code) {\n+                final Code code = (Code)attribute;\n+                this.setMaxStack(code.getMaxStack());\n+                this.setMaxLocals(code.getMaxLocals());\n+                final CodeException[] exceptionTable = code.getExceptionTable();\n+                if (exceptionTable != null) {\n+                    for (final CodeException ex : exceptionTable) {\n+                        final int catchType = ex.getCatchType();\n+                        ObjectType instance = null;\n+                        if (catchType > 0) {\n+                            instance = ObjectType.getInstance(method.getConstantPool().getConstantString(catchType, (byte)7));\n                         }\n-                        final int end_pc = ce.getEndPC();\n-                        final int length = getByteCodes(method).length;\n-                        InstructionHandle end;\n-                        if (length == end_pc) {\n-                            end = this.il.getEnd();\n+                        final int endPC = ex.getEndPC();\n+                        InstructionHandle instructionHandle;\n+                        if (getByteCodes(method).length == endPC) {\n+                            instructionHandle = this.il.getEnd();\n                         }\n                         else {\n-                            end = this.il.findHandle(end_pc);\n-                            end = end.getPrev();\n+                            instructionHandle = this.il.findHandle(endPC).getPrev();\n                         }\n-                        this.addExceptionHandler(this.il.findHandle(ce.getStartPC()), end, this.il.findHandle(ce.getHandlerPC()), cType);\n+                        this.addExceptionHandler(this.il.findHandle(ex.getStartPC()), instructionHandle, this.il.findHandle(ex.getHandlerPC()), instance);\n                     }\n                 }\n-                final Attribute[] attributes3;\n-                final Attribute[] c_attributes = attributes3 = c.getAttributes();\n-                for (int length4 = attributes3.length, k = 0; k < length4; ++k) {\n-                    final Attribute c_attribute = a = attributes3[k];\n-                    if (a instanceof LineNumberTable) {\n-                        ((LineNumberTable)a).forEach(l -> {\n-                            final InstructionHandle ih = this.il.findHandle(l.getStartPC());\n-                            if (ih != null) {\n-                                this.addLineNumber(ih, l.getLineNumber());\n+                for (final Attribute attribute2 : code.getAttributes()) {\n+                    if (attribute2 instanceof LineNumberTable) {\n+                        ((LineNumberTable)attribute2).forEach(lineNumber -> {\n+                            this.il.findHandle(lineNumber.getStartPC());\n+                            final InstructionHandle instructionHandle2;\n+                            if (instructionHandle2 != null) {\n+                                this.addLineNumber(instructionHandle2, lineNumber.getLineNumber());\n                             }\n                             return;\n                         });\n                     }\n-                    else if (a instanceof LocalVariableTable) {\n-                        this.updateLocalVariableTable((LocalVariableTable)a);\n+                    else if (attribute2 instanceof LocalVariableTable) {\n+                        this.updateLocalVariableTable((LocalVariableTable)attribute2);\n                     }\n-                    else if (a instanceof LocalVariableTypeTable) {\n-                        this.localVariableTypeTable = (LocalVariableTypeTable)a.copy(cp.getConstantPool());\n+                    else if (attribute2 instanceof LocalVariableTypeTable) {\n+                        this.localVariableTypeTable = (LocalVariableTypeTable)attribute2.copy(constantPoolGen.getConstantPool());\n                     }\n                     else {\n-                        this.addCodeAttribute(a);\n+                        this.addCodeAttribute(attribute2);\n                     }\n                 }\n             }\n-            else if (a instanceof ExceptionTable) {\n-                Collections.addAll(this.throwsList, ((ExceptionTable)a).getExceptionNames());\n+            else if (attribute instanceof ExceptionTable) {\n+                Collections.addAll(this.throwsList, ((ExceptionTable)attribute).getExceptionNames());\n             }\n-            else if (a instanceof Annotations) {\n-                final Annotations runtimeAnnotations = (Annotations)a;\n-                runtimeAnnotations.forEach(element -> this.addAnnotationEntry(new AnnotationEntryGen(element, cp, false)));\n+            else if (attribute instanceof Annotations) {\n+                ((Annotations)attribute).forEach(annotationEntry -> this.addAnnotationEntry(new AnnotationEntryGen(annotationEntry, constantPoolGen2, (boolean)(0 != 0))));\n             }\n             else {\n-                this.addAttribute(a);\n+                this.addAttribute(attribute);\n             }\n         }\n     }\n     \n-    public void addAnnotationsAsAttribute(final ConstantPoolGen cp) {\n-        this.addAll(AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries()));\n+    public void addAnnotationsAsAttribute(final ConstantPoolGen constantPoolGen) {\n+        this.addAll(AnnotationEntryGen.getAnnotationAttributes(constantPoolGen, super.getAnnotationEntries()));\n     }\n     \n-    public void addCodeAttribute(final Attribute a) {\n-        this.codeAttrsList.add(a);\n+    public void addCodeAttribute(final Attribute attribute) {\n+        this.codeAttrsList.add(attribute);\n     }\n     \n-    public void addException(final String className) {\n-        this.throwsList.add(className);\n+    public void addException(final String s) {\n+        this.throwsList.add(s);\n     }\n     \n-    public CodeExceptionGen addExceptionHandler(final InstructionHandle startPc, final InstructionHandle endPc, final InstructionHandle handlerPc, final ObjectType catchType) {\n-        if (startPc == null || endPc == null || handlerPc == null) {\n+    public CodeExceptionGen addExceptionHandler(final InstructionHandle instructionHandle, final InstructionHandle instructionHandle2, final InstructionHandle instructionHandle3, final ObjectType objectType) {\n+        if (instructionHandle == null || instructionHandle2 == null || instructionHandle3 == null) {\n             throw new ClassGenException(\"Exception handler target is null instruction\");\n         }\n-        final CodeExceptionGen c = new CodeExceptionGen(startPc, endPc, handlerPc, catchType);\n-        this.exceptionList.add(c);\n-        return c;\n+        final CodeExceptionGen codeExceptionGen = new CodeExceptionGen(instructionHandle, instructionHandle2, instructionHandle3, objectType);\n+        this.exceptionList.add(codeExceptionGen);\n+        return codeExceptionGen;\n     }\n     \n-    public LineNumberGen addLineNumber(final InstructionHandle ih, final int srcLine) {\n-        final LineNumberGen l = new LineNumberGen(ih, srcLine);\n-        this.lineNumberList.add(l);\n-        return l;\n+    public LineNumberGen addLineNumber(final InstructionHandle instructionHandle, final int n) {\n+        final LineNumberGen lineNumberGen = new LineNumberGen(instructionHandle, n);\n+        this.lineNumberList.add(lineNumberGen);\n+        return lineNumberGen;\n     }\n     \n-    public LocalVariableGen addLocalVariable(final String name, final Type type, final InstructionHandle start, final InstructionHandle end) {\n-        return this.addLocalVariable(name, type, this.maxLocals, start, end);\n+    public LocalVariableGen addLocalVariable(final String s, final Type type, final InstructionHandle instructionHandle, final InstructionHandle instructionHandle2) {\n+        return this.addLocalVariable(s, type, this.maxLocals, instructionHandle, instructionHandle2);\n     }\n     \n-    public LocalVariableGen addLocalVariable(final String name, final Type type, final int slot, final InstructionHandle start, final InstructionHandle end) {\n-        return this.addLocalVariable(name, type, slot, start, end, slot);\n+    public LocalVariableGen addLocalVariable(final String s, final Type type, final int n, final InstructionHandle instructionHandle, final InstructionHandle instructionHandle2) {\n+        return this.addLocalVariable(s, type, n, instructionHandle, instructionHandle2, n);\n     }\n     \n-    public LocalVariableGen addLocalVariable(final String name, final Type type, final int slot, final InstructionHandle start, final InstructionHandle end, final int orig_index) {\n-        final byte t = type.getType();\n-        if (t != 16) {\n-            final int add = type.getSize();\n-            if (slot + add > this.maxLocals) {\n-                this.maxLocals = slot + add;\n+    public LocalVariableGen addLocalVariable(final String s, final Type obj, final int n, final InstructionHandle instructionHandle, final InstructionHandle instructionHandle2, final int n2) {\n+        if (obj.getType() != 16) {\n+            final int size = obj.getSize();\n+            if (n + size > this.maxLocals) {\n+                this.maxLocals = n + size;\n             }\n-            final LocalVariableGen l = new LocalVariableGen(slot, name, type, start, end, orig_index);\n-            final int i;\n-            if ((i = this.variableList.indexOf(l)) >= 0) {\n-                this.variableList.set(i, l);\n+            final LocalVariableGen localVariableGen = new LocalVariableGen(n, s, obj, instructionHandle, instructionHandle2, n2);\n+            final int index;\n+            if ((index = this.variableList.indexOf(localVariableGen)) >= 0) {\n+                this.variableList.set(index, localVariableGen);\n             }\n             else {\n-                this.variableList.add(l);\n+                this.variableList.add(localVariableGen);\n             }\n-            return l;\n+            return localVariableGen;\n         }\n-        throw new IllegalArgumentException(\"Can not use \" + type + \" as type for local variable\");\n+        throw new IllegalArgumentException(\"Can not use \" + obj + \" as type for local variable\");\n     }\n     \n-    public void addObserver(final MethodObserver o) {\n+    public void addObserver(final MethodObserver methodObserver) {\n         if (this.observers == null) {\n             this.observers = new ArrayList<MethodObserver>();\n         }\n-        this.observers.add(o);\n+        this.observers.add(methodObserver);\n     }\n     \n-    public void addParameterAnnotation(final int parameterIndex, final AnnotationEntryGen annotation) {\n+    public void addParameterAnnotation(final int n, final AnnotationEntryGen annotationEntryGen) {\n         this.ensureExistingParameterAnnotationsUnpacked();\n         if (!this.hasParameterAnnotations) {\n-            final List<AnnotationEntryGen>[] parmList = new List[this.argTypes.length];\n-            this.paramAnnotations = parmList;\n+            this.paramAnnotations = new List[this.argTypes.length];\n             this.hasParameterAnnotations = true;\n         }\n-        final List<AnnotationEntryGen> existingAnnotations = this.paramAnnotations[parameterIndex];\n-        if (existingAnnotations != null) {\n-            existingAnnotations.add(annotation);\n+        final List<AnnotationEntryGen> list = this.paramAnnotations[n];\n+        if (list != null) {\n+            list.add(annotationEntryGen);\n         }\n         else {\n-            final List<AnnotationEntryGen> l = new ArrayList<AnnotationEntryGen>();\n-            l.add(annotation);\n-            this.paramAnnotations[parameterIndex] = l;\n+            final ArrayList list2 = new ArrayList();\n+            list2.add(annotationEntryGen);\n+            this.paramAnnotations[n] = list2;\n         }\n     }\n     \n-    public void addParameterAnnotationsAsAttribute(final ConstantPoolGen cp) {\n+    public void addParameterAnnotationsAsAttribute(final ConstantPoolGen constantPoolGen) {\n         if (!this.hasParameterAnnotations) {\n             return;\n         }\n-        final Attribute[] attrs = AnnotationEntryGen.getParameterAnnotationAttributes(cp, (List[])this.paramAnnotations);\n-        if (attrs != null) {\n-            this.addAll(attrs);\n+        final Attribute[] parameterAnnotationAttributes = AnnotationEntryGen.getParameterAnnotationAttributes(constantPoolGen, (List[])this.paramAnnotations);\n+        if (parameterAnnotationAttributes != null) {\n+            this.addAll(parameterAnnotationAttributes);\n         }\n     }\n     \n-    private Attribute[] addRuntimeAnnotationsAsAttribute(final ConstantPoolGen cp) {\n-        final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());\n-        this.addAll(attrs);\n-        return attrs;\n+    private Attribute[] addRuntimeAnnotationsAsAttribute(final ConstantPoolGen constantPoolGen) {\n+        final Attribute[] annotationAttributes = AnnotationEntryGen.getAnnotationAttributes(constantPoolGen, super.getAnnotationEntries());\n+        this.addAll(annotationAttributes);\n+        return annotationAttributes;\n     }\n     \n-    private Attribute[] addRuntimeParameterAnnotationsAsAttribute(final ConstantPoolGen cp) {\n+    private Attribute[] addRuntimeParameterAnnotationsAsAttribute(final ConstantPoolGen constantPoolGen) {\n         if (!this.hasParameterAnnotations) {\n             return Attribute.EMPTY_ARRAY;\n         }\n-        final Attribute[] attrs = AnnotationEntryGen.getParameterAnnotationAttributes(cp, (List[])this.paramAnnotations);\n-        this.addAll(attrs);\n-        return attrs;\n+        final Attribute[] parameterAnnotationAttributes = AnnotationEntryGen.getParameterAnnotationAttributes(constantPoolGen, (List[])this.paramAnnotations);\n+        this.addAll(parameterAnnotationAttributes);\n+        return parameterAnnotationAttributes;\n     }\n     \n-    private void adjustLocalVariableTypeTable(final LocalVariableTable lvt) {\n-        final LocalVariable[] lv = lvt.getLocalVariableTable();\n-        for (final LocalVariable element : this.localVariableTypeTable.getLocalVariableTypeTable()) {\n-            for (final LocalVariable l : lv) {\n-                if (element.getName().equals(l.getName()) && element.getIndex() == l.getOrigIndex()) {\n-                    element.setLength(l.getLength());\n-                    element.setStartPC(l.getStartPC());\n-                    element.setIndex(l.getIndex());\n+    private void adjustLocalVariableTypeTable(final LocalVariableTable localVariableTable) {\n+        final LocalVariable[] localVariableTable2 = localVariableTable.getLocalVariableTable();\n+        for (final LocalVariable localVariable : this.localVariableTypeTable.getLocalVariableTypeTable()) {\n+            for (final LocalVariable localVariable2 : localVariableTable2) {\n+                if (localVariable.getName().equals(localVariable2.getName()) && localVariable.getIndex() == localVariable2.getOrigIndex()) {\n+                    localVariable.setLength(localVariable2.getLength());\n+                    localVariable.setStartPC(localVariable2.getStartPC());\n+                    localVariable.setIndex(localVariable2.getIndex());\n                     break;\n                 }\n             }\n         }\n     }\n     \n-    public MethodGen copy(final String className, final ConstantPoolGen cp) {\n-        final Method m = ((MethodGen)this.clone()).getMethod();\n-        final MethodGen mg = new MethodGen(m, className, super.getConstantPool());\n-        if (super.getConstantPool() != cp) {\n-            mg.setConstantPool(cp);\n-            mg.getInstructionList().replaceConstantPool(super.getConstantPool(), cp);\n+    public MethodGen copy(final String s, final ConstantPoolGen constantPool) {\n+        final MethodGen methodGen = new MethodGen(((MethodGen)this.clone()).getMethod(), s, super.getConstantPool());\n+        if (super.getConstantPool() != constantPool) {\n+            methodGen.setConstantPool(constantPool);\n+            methodGen.getInstructionList().replaceConstantPool(super.getConstantPool(), constantPool);\n         }\n-        return mg;\n+        return methodGen;\n     }\n     \n     private void ensureExistingParameterAnnotationsUnpacked() {\n         if (this.haveUnpackedParameterAnnotations) {\n             return;\n         }\n-        final Attribute[] attrs = this.getAttributes();\n-        ParameterAnnotations paramAnnVisAttr = null;\n-        ParameterAnnotations paramAnnInvisAttr = null;\n-        for (final Attribute attribute : attrs) {\n+        final Attribute[] attributes = this.getAttributes();\n+        Object o = null;\n+        Object o2 = null;\n+        for (final Attribute attribute : attributes) {\n             if (attribute instanceof ParameterAnnotations) {\n                 if (!this.hasParameterAnnotations) {\n-                    final List<AnnotationEntryGen>[] parmList = new List[this.argTypes.length];\n-                    Arrays.setAll(this.paramAnnotations = parmList, i -> new ArrayList());\n+                    Arrays.setAll(this.paramAnnotations = new List[this.argTypes.length], p0 -> new ArrayList());\n                 }\n                 this.hasParameterAnnotations = true;\n-                final ParameterAnnotations rpa = (ParameterAnnotations)attribute;\n-                if (rpa instanceof RuntimeVisibleParameterAnnotations) {\n-                    paramAnnVisAttr = rpa;\n+                final ParameterAnnotations parameterAnnotations = (ParameterAnnotations)attribute;\n+                if (parameterAnnotations instanceof RuntimeVisibleParameterAnnotations) {\n+                    o = parameterAnnotations;\n                 }\n                 else {\n-                    paramAnnInvisAttr = rpa;\n+                    o2 = parameterAnnotations;\n                 }\n-                final ParameterAnnotationEntry[] parameterAnnotationEntries = rpa.getParameterAnnotationEntries();\n+                final ParameterAnnotationEntry[] parameterAnnotationEntries = parameterAnnotations.getParameterAnnotationEntries();\n                 for (int j = 0; j < parameterAnnotationEntries.length; ++j) {\n-                    final ParameterAnnotationEntry immutableArray = rpa.getParameterAnnotationEntries()[j];\n-                    final List<AnnotationEntryGen> mutable = this.makeMutableVersion(immutableArray.getAnnotationEntries());\n-                    this.paramAnnotations[j].addAll(mutable);\n+                    this.paramAnnotations[j].addAll(this.makeMutableVersion(parameterAnnotations.getParameterAnnotationEntries()[j].getAnnotationEntries()));\n                 }\n             }\n         }\n-        if (paramAnnVisAttr != null) {\n-            this.removeAttribute((Attribute)paramAnnVisAttr);\n+        if (o != null) {\n+            this.removeAttribute((Attribute)o);\n         }\n-        if (paramAnnInvisAttr != null) {\n-            this.removeAttribute((Attribute)paramAnnInvisAttr);\n+        if (o2 != null) {\n+            this.removeAttribute((Attribute)o2);\n         }\n         this.haveUnpackedParameterAnnotations = true;\n     }\n     \n-    public boolean equals(final Object obj) {\n-        return MethodGen.bcelComparator.equals((Object)this, obj);\n+    public boolean equals(final Object o) {\n+        return MethodGen.bcelComparator.equals((Object)this, o);\n     }\n     \n-    public List<AnnotationEntryGen> getAnnotationsOnParameter(final int i) {\n+    public List<AnnotationEntryGen> getAnnotationsOnParameter(final int n) {\n         this.ensureExistingParameterAnnotationsUnpacked();\n-        if (!this.hasParameterAnnotations || i > this.argTypes.length) {\n+        if (!this.hasParameterAnnotations || n > this.argTypes.length) {\n             return null;\n         }\n-        return this.paramAnnotations[i];\n+        return this.paramAnnotations[n];\n     }\n     \n-    public String getArgumentName(final int i) {\n-        return this.argNames[i];\n+    public String getArgumentName(final int n) {\n+        return this.argNames[n];\n     }\n     \n     public String[] getArgumentNames() {\n         return this.argNames.clone();\n     }\n     \n-    public Type getArgumentType(final int i) {\n-        return this.argTypes[i];\n+    public Type getArgumentType(final int n) {\n+        return this.argTypes[n];\n     }\n     \n     public Type[] getArgumentTypes() {\n         return this.argTypes.clone();\n     }\n     \n     public String getClassName() {\n@@ -439,74 +421,70 @@\n     }\n     \n     public Attribute[] getCodeAttributes() {\n         return this.codeAttrsList.toArray(Attribute.EMPTY_ARRAY);\n     }\n     \n     private CodeException[] getCodeExceptions() {\n-        final int size = this.exceptionList.size();\n-        final CodeException[] c_exc = new CodeException[size];\n-        Arrays.setAll(c_exc, i -> ((CodeExceptionGen)this.exceptionList.get(i)).getCodeException(super.getConstantPool()));\n-        return c_exc;\n+        final CodeException[] array = new CodeException[this.exceptionList.size()];\n+        Arrays.setAll(array, n2 -> ((CodeExceptionGen)this.exceptionList.get(n2)).getCodeException(super.getConstantPool()));\n+        return array;\n     }\n     \n     public CodeExceptionGen[] getExceptionHandlers() {\n         return this.exceptionList.toArray(CodeExceptionGen.EMPTY_ARRAY);\n     }\n     \n     public String[] getExceptions() {\n         return this.throwsList.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n     }\n     \n-    private ExceptionTable getExceptionTable(final ConstantPoolGen cp) {\n+    private ExceptionTable getExceptionTable(final ConstantPoolGen constantPoolGen) {\n         final int size = this.throwsList.size();\n-        final int[] ex = new int[size];\n-        Arrays.setAll(ex, i -> cp.addClass((String)this.throwsList.get(i)));\n-        return new ExceptionTable(cp.addUtf8(\"Exceptions\"), 2 + 2 * size, ex, cp.getConstantPool());\n+        final int[] array = new int[size];\n+        Arrays.setAll(array, n2 -> constantPoolGen2.addClass((String)this.throwsList.get(n2)));\n+        return new ExceptionTable(constantPoolGen.addUtf8(\"Exceptions\"), 2 + 2 * size, array, constantPoolGen.getConstantPool());\n     }\n     \n     public InstructionList getInstructionList() {\n         return this.il;\n     }\n     \n     public LineNumberGen[] getLineNumbers() {\n         return this.lineNumberList.toArray(LineNumberGen.EMPTY_ARRAY);\n     }\n     \n-    public LineNumberTable getLineNumberTable(final ConstantPoolGen cp) {\n-        final int size = this.lineNumberList.size();\n-        final LineNumber[] ln = new LineNumber[size];\n-        Arrays.setAll(ln, i -> ((LineNumberGen)this.lineNumberList.get(i)).getLineNumber());\n-        return new LineNumberTable(cp.addUtf8(\"LineNumberTable\"), 2 + ln.length * 4, ln, cp.getConstantPool());\n+    public LineNumberTable getLineNumberTable(final ConstantPoolGen constantPoolGen) {\n+        final LineNumber[] array = new LineNumber[this.lineNumberList.size()];\n+        Arrays.setAll(array, n2 -> ((LineNumberGen)this.lineNumberList.get(n2)).getLineNumber());\n+        return new LineNumberTable(constantPoolGen.addUtf8(\"LineNumberTable\"), 2 + array.length * 4, array, constantPoolGen.getConstantPool());\n     }\n     \n     public LocalVariableGen[] getLocalVariables() {\n         final int size = this.variableList.size();\n-        final LocalVariableGen[] lg = new LocalVariableGen[size];\n-        this.variableList.toArray(lg);\n+        final LocalVariableGen[] a = new LocalVariableGen[size];\n+        this.variableList.toArray(a);\n         for (int i = 0; i < size; ++i) {\n-            if (lg[i].getStart() == null && this.il != null) {\n-                lg[i].setStart(this.il.getStart());\n+            if (a[i].getStart() == null && this.il != null) {\n+                a[i].setStart(this.il.getStart());\n             }\n-            if (lg[i].getEnd() == null && this.il != null) {\n-                lg[i].setEnd(this.il.getEnd());\n+            if (a[i].getEnd() == null && this.il != null) {\n+                a[i].setEnd(this.il.getEnd());\n             }\n         }\n         if (size > 1) {\n-            Arrays.sort(lg, Comparator.comparingInt(LocalVariableGen::getIndex));\n+            Arrays.sort(a, Comparator.comparingInt(LocalVariableGen::getIndex));\n         }\n-        return lg;\n+        return a;\n     }\n     \n-    public LocalVariableTable getLocalVariableTable(final ConstantPoolGen cp) {\n-        final LocalVariableGen[] lg = this.getLocalVariables();\n-        final int size = lg.length;\n-        final LocalVariable[] lv = new LocalVariable[size];\n-        Arrays.setAll(lv, i -> lg[i].getLocalVariable(cp));\n-        return new LocalVariableTable(cp.addUtf8(\"LocalVariableTable\"), 2 + lv.length * 10, lv, cp.getConstantPool());\n+    public LocalVariableTable getLocalVariableTable(final ConstantPoolGen constantPoolGen) {\n+        final LocalVariable[] array = new LocalVariable[this.getLocalVariables().length];\n+        Arrays.setAll(array, n2 -> array2[n2].getLocalVariable(constantPoolGen2));\n+        return new LocalVariableTable(constantPoolGen.addUtf8(\"LocalVariableTable\"), 2 + array.length * 10, array, constantPoolGen.getConstantPool());\n     }\n     \n     public LocalVariableTypeTable getLocalVariableTypeTable() {\n         return this.localVariableTypeTable;\n     }\n     \n     public int getMaxLocals() {\n@@ -515,189 +493,189 @@\n     \n     public int getMaxStack() {\n         return this.maxStack;\n     }\n     \n     public Method getMethod() {\n         final String signature = this.getSignature();\n-        final ConstantPoolGen cp = super.getConstantPool();\n-        final int name_index = cp.addUtf8(super.getName());\n-        final int signature_index = cp.addUtf8(signature);\n-        final byte[] byteCode = (byte[])((this.il != null) ? this.il.getByteCode() : null);\n-        LineNumberTable lnt = null;\n-        LocalVariableTable lvt = null;\n+        final ConstantPoolGen constantPool = super.getConstantPool();\n+        final int addUtf8 = constantPool.addUtf8(super.getName());\n+        final int addUtf9 = constantPool.addUtf8(signature);\n+        final byte[] array = (byte[])((this.il != null) ? this.il.getByteCode() : null);\n+        Object lineNumberTable = null;\n+        Object localVariableTable = null;\n         if (!this.variableList.isEmpty() && !this.stripAttributes) {\n-            this.updateLocalVariableTable(this.getLocalVariableTable(cp));\n-            this.addCodeAttribute((Attribute)(lvt = this.getLocalVariableTable(cp)));\n+            this.updateLocalVariableTable(this.getLocalVariableTable(constantPool));\n+            this.addCodeAttribute((Attribute)(localVariableTable = this.getLocalVariableTable(constantPool)));\n         }\n         if (this.localVariableTypeTable != null) {\n-            if (lvt != null) {\n-                this.adjustLocalVariableTypeTable(lvt);\n+            if (localVariableTable != null) {\n+                this.adjustLocalVariableTypeTable((LocalVariableTable)localVariableTable);\n             }\n             this.addCodeAttribute((Attribute)this.localVariableTypeTable);\n         }\n         if (!this.lineNumberList.isEmpty() && !this.stripAttributes) {\n-            this.addCodeAttribute((Attribute)(lnt = this.getLineNumberTable(cp)));\n+            this.addCodeAttribute((Attribute)(lineNumberTable = this.getLineNumberTable(constantPool)));\n         }\n-        final Attribute[] codeAttrs = this.getCodeAttributes();\n-        int attrs_len = 0;\n-        for (final Attribute code_attr : codeAttrs) {\n-            attrs_len += code_attr.getLength() + 6;\n-        }\n-        final CodeException[] cExc = this.getCodeExceptions();\n-        final int exc_len = cExc.length * 8;\n-        Code code = null;\n-        if (byteCode != null && !this.isAbstract() && !this.isNative()) {\n-            final Attribute[] attributes2;\n-            final Attribute[] attributes = attributes2 = this.getAttributes();\n-            for (final Attribute a : attributes2) {\n-                if (a instanceof Code) {\n-                    this.removeAttribute(a);\n-                }\n-            }\n-            code = new Code(cp.addUtf8(\"Code\"), 8 + byteCode.length + 2 + exc_len + 2 + attrs_len, this.maxStack, this.maxLocals, byteCode, cExc, codeAttrs, cp.getConstantPool());\n-            this.addAttribute((Attribute)code);\n-        }\n-        final Attribute[] annotations = this.addRuntimeAnnotationsAsAttribute(cp);\n-        final Attribute[] parameterAnnotations = this.addRuntimeParameterAnnotationsAsAttribute(cp);\n-        ExceptionTable et = null;\n+        final Attribute[] codeAttributes = this.getCodeAttributes();\n+        int n = 0;\n+        final Attribute[] array2 = codeAttributes;\n+        for (int length = array2.length, i = 0; i < length; ++i) {\n+            n += array2[i].getLength() + 6;\n+        }\n+        final CodeException[] codeExceptions = this.getCodeExceptions();\n+        final int n2 = codeExceptions.length * 8;\n+        Object o = null;\n+        if (array != null && !this.isAbstract() && !this.isNative()) {\n+            for (final Attribute attribute : this.getAttributes()) {\n+                if (attribute instanceof Code) {\n+                    this.removeAttribute(attribute);\n+                }\n+            }\n+            o = new Code(constantPool.addUtf8(\"Code\"), 8 + array.length + 2 + n2 + 2 + n, this.maxStack, this.maxLocals, array, codeExceptions, codeAttributes, constantPool.getConstantPool());\n+            this.addAttribute((Attribute)o);\n+        }\n+        final Attribute[] addRuntimeAnnotationsAsAttribute = this.addRuntimeAnnotationsAsAttribute(constantPool);\n+        final Attribute[] addRuntimeParameterAnnotationsAsAttribute = this.addRuntimeParameterAnnotationsAsAttribute(constantPool);\n+        Object exceptionTable = null;\n         if (!this.throwsList.isEmpty()) {\n-            this.addAttribute((Attribute)(et = this.getExceptionTable(cp)));\n+            this.addAttribute((Attribute)(exceptionTable = this.getExceptionTable(constantPool)));\n         }\n-        final Method m = new Method(super.getAccessFlags(), name_index, signature_index, this.getAttributes(), cp.getConstantPool());\n-        if (lvt != null) {\n-            this.removeCodeAttribute((Attribute)lvt);\n+        final Method method = new Method(super.getAccessFlags(), addUtf8, addUtf9, this.getAttributes(), constantPool.getConstantPool());\n+        if (localVariableTable != null) {\n+            this.removeCodeAttribute((Attribute)localVariableTable);\n         }\n         if (this.localVariableTypeTable != null) {\n             this.removeCodeAttribute((Attribute)this.localVariableTypeTable);\n         }\n-        if (lnt != null) {\n-            this.removeCodeAttribute((Attribute)lnt);\n+        if (lineNumberTable != null) {\n+            this.removeCodeAttribute((Attribute)lineNumberTable);\n         }\n-        if (code != null) {\n-            this.removeAttribute((Attribute)code);\n+        if (o != null) {\n+            this.removeAttribute((Attribute)o);\n         }\n-        if (et != null) {\n-            this.removeAttribute((Attribute)et);\n+        if (exceptionTable != null) {\n+            this.removeAttribute((Attribute)exceptionTable);\n         }\n-        this.removeRuntimeAttributes(annotations);\n-        this.removeRuntimeAttributes(parameterAnnotations);\n-        return m;\n+        this.removeRuntimeAttributes(addRuntimeAnnotationsAsAttribute);\n+        this.removeRuntimeAttributes(addRuntimeParameterAnnotationsAsAttribute);\n+        return method;\n     }\n     \n     public Type getReturnType() {\n         return this.getType();\n     }\n     \n     public String getSignature() {\n         return Type.getMethodSignature(super.getType(), this.argTypes);\n     }\n     \n     public int hashCode() {\n         return MethodGen.bcelComparator.hashCode((Object)this);\n     }\n     \n-    private List<AnnotationEntryGen> makeMutableVersion(final AnnotationEntry[] mutableArray) {\n-        final List<AnnotationEntryGen> result = new ArrayList<AnnotationEntryGen>();\n-        for (final AnnotationEntry element : mutableArray) {\n-            result.add(new AnnotationEntryGen(element, this.getConstantPool(), false));\n+    private List<AnnotationEntryGen> makeMutableVersion(final AnnotationEntry[] array) {\n+        final ArrayList list = new ArrayList();\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            list.add(new AnnotationEntryGen(array[i], this.getConstantPool(), false));\n         }\n-        return result;\n+        return list;\n     }\n     \n-    public void removeCodeAttribute(final Attribute a) {\n-        this.codeAttrsList.remove(a);\n+    public void removeCodeAttribute(final Attribute attribute) {\n+        this.codeAttrsList.remove(attribute);\n     }\n     \n     public void removeCodeAttributes() {\n         this.localVariableTypeTable = null;\n         this.codeAttrsList.clear();\n     }\n     \n-    public void removeException(final String c) {\n-        this.throwsList.remove(c);\n+    public void removeException(final String s) {\n+        this.throwsList.remove(s);\n     }\n     \n-    public void removeExceptionHandler(final CodeExceptionGen c) {\n-        this.exceptionList.remove(c);\n+    public void removeExceptionHandler(final CodeExceptionGen codeExceptionGen) {\n+        this.exceptionList.remove(codeExceptionGen);\n     }\n     \n     public void removeExceptionHandlers() {\n         this.exceptionList.clear();\n     }\n     \n     public void removeExceptions() {\n         this.throwsList.clear();\n     }\n     \n-    public void removeLineNumber(final LineNumberGen l) {\n-        this.lineNumberList.remove(l);\n+    public void removeLineNumber(final LineNumberGen lineNumberGen) {\n+        this.lineNumberList.remove(lineNumberGen);\n     }\n     \n     public void removeLineNumbers() {\n         this.lineNumberList.clear();\n     }\n     \n-    public void removeLocalVariable(final LocalVariableGen l) {\n-        l.dispose();\n-        this.variableList.remove(l);\n+    public void removeLocalVariable(final LocalVariableGen localVariableGen) {\n+        localVariableGen.dispose();\n+        this.variableList.remove(localVariableGen);\n     }\n     \n     public void removeLocalVariables() {\n         this.variableList.forEach(LocalVariableGen::dispose);\n         this.variableList.clear();\n     }\n     \n     public void removeLocalVariableTypeTable() {\n         this.localVariableTypeTable = null;\n     }\n     \n     public void removeNOPs() {\n         if (this.il != null) {\n             InstructionHandle next;\n-            for (InstructionHandle ih = this.il.getStart(); ih != null; ih = next) {\n-                next = ih.getNext();\n-                if (next != null && ih.getInstruction() instanceof NOP) {\n+            for (InstructionHandle start = this.il.getStart(); start != null; start = next) {\n+                next = start.getNext();\n+                if (next != null && start.getInstruction() instanceof NOP) {\n                     try {\n-                        this.il.delete(ih);\n+                        this.il.delete(start);\n                     }\n-                    catch (final TargetLostException e) {\n-                        for (final InstructionHandle target : e.getTargets()) {\n-                            for (final InstructionTargeter targeter : target.getTargeters()) {\n-                                targeter.updateTarget(target, next);\n+                    catch (final TargetLostException ex) {\n+                        for (final InstructionHandle instructionHandle : ex.getTargets()) {\n+                            final InstructionTargeter[] targeters = instructionHandle.getTargeters();\n+                            for (int length2 = targeters.length, j = 0; j < length2; ++j) {\n+                                targeters[j].updateTarget(instructionHandle, next);\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n     }\n     \n-    public void removeObserver(final MethodObserver o) {\n+    public void removeObserver(final MethodObserver methodObserver) {\n         if (this.observers != null) {\n-            this.observers.remove(o);\n+            this.observers.remove(methodObserver);\n         }\n     }\n     \n-    public void removeRuntimeAttributes(final Attribute[] attrs) {\n-        for (final Attribute attr : attrs) {\n-            this.removeAttribute(attr);\n+    public void removeRuntimeAttributes(final Attribute[] array) {\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            this.removeAttribute(array[i]);\n         }\n     }\n     \n-    public void setArgumentName(final int i, final String name) {\n-        this.argNames[i] = name;\n+    public void setArgumentName(final int n, final String s) {\n+        this.argNames[n] = s;\n     }\n     \n     public void setArgumentNames(final String[] argNames) {\n         this.argNames = argNames;\n     }\n     \n-    public void setArgumentType(final int i, final Type type) {\n-        this.argTypes[i] = type;\n+    public void setArgumentType(final int n, final Type type) {\n+        this.argTypes[n] = type;\n     }\n     \n     public void setArgumentTypes(final Type[] argTypes) {\n         this.argTypes = argTypes;\n     }\n     \n     public void setClassName(final String className) {\n@@ -706,96 +684,96 @@\n     \n     public void setInstructionList(final InstructionList il) {\n         this.il = il;\n     }\n     \n     public void setMaxLocals() {\n         if (this.il != null) {\n-            int max = this.isStatic() ? 0 : 1;\n+            int maxLocals = this.isStatic() ? 0 : 1;\n             if (this.argTypes != null) {\n-                for (final Type argType : this.argTypes) {\n-                    max += argType.getSize();\n+                final Type[] argTypes = this.argTypes;\n+                for (int length = argTypes.length, i = 0; i < length; ++i) {\n+                    maxLocals += argTypes[i].getSize();\n                 }\n             }\n-            for (InstructionHandle ih = this.il.getStart(); ih != null; ih = ih.getNext()) {\n-                final Instruction ins = ih.getInstruction();\n-                if (ins instanceof LocalVariableInstruction || ins instanceof RET || ins instanceof IINC) {\n-                    final int index = ((IndexedInstruction)ins).getIndex() + ((TypedInstruction)ins).getType(super.getConstantPool()).getSize();\n-                    if (index > max) {\n-                        max = index;\n+            for (InstructionHandle instructionHandle = this.il.getStart(); instructionHandle != null; instructionHandle = instructionHandle.getNext()) {\n+                final Instruction instruction = instructionHandle.getInstruction();\n+                if (instruction instanceof LocalVariableInstruction || instruction instanceof RET || instruction instanceof IINC) {\n+                    final int n = ((IndexedInstruction)instruction).getIndex() + ((TypedInstruction)instruction).getType(super.getConstantPool()).getSize();\n+                    if (n > maxLocals) {\n+                        maxLocals = n;\n                     }\n                 }\n             }\n-            this.maxLocals = max;\n+            this.maxLocals = maxLocals;\n         }\n         else {\n             this.maxLocals = 0;\n         }\n     }\n     \n-    public void setMaxLocals(final int m) {\n-        this.maxLocals = m;\n+    public void setMaxLocals(final int maxLocals) {\n+        this.maxLocals = maxLocals;\n     }\n     \n     public void setMaxStack() {\n         if (this.il != null) {\n             this.maxStack = getMaxStack(super.getConstantPool(), this.il, this.getExceptionHandlers());\n         }\n         else {\n             this.maxStack = 0;\n         }\n     }\n     \n-    public void setMaxStack(final int m) {\n-        this.maxStack = m;\n+    public void setMaxStack(final int maxStack) {\n+        this.maxStack = maxStack;\n     }\n     \n-    public void setReturnType(final Type returnType) {\n-        this.setType(returnType);\n+    public void setReturnType(final Type type) {\n+        this.setType(type);\n     }\n     \n-    public void stripAttributes(final boolean flag) {\n-        this.stripAttributes = flag;\n+    public void stripAttributes(final boolean stripAttributes) {\n+        this.stripAttributes = stripAttributes;\n     }\n     \n     public final String toString() {\n-        final String access = Utility.accessToString(super.getAccessFlags());\n-        String signature = Type.getMethodSignature(super.getType(), this.argTypes);\n-        signature = Utility.methodSignatureToString(signature, super.getName(), access, true, this.getLocalVariableTable(super.getConstantPool()));\n-        final StringBuilder buf = new StringBuilder(signature);\n-        for (final Attribute a : this.getAttributes()) {\n-            if (!(a instanceof Code) && !(a instanceof ExceptionTable)) {\n-                buf.append(\" [\").append(a).append(\"]\");\n+        final StringBuilder sb = new StringBuilder(Utility.methodSignatureToString(Type.getMethodSignature(super.getType(), this.argTypes), super.getName(), Utility.accessToString(super.getAccessFlags()), true, this.getLocalVariableTable(super.getConstantPool())));\n+        for (final Attribute obj : this.getAttributes()) {\n+            if (!(obj instanceof Code) && !(obj instanceof ExceptionTable)) {\n+                sb.append(\" [\").append(obj).append(\"]\");\n             }\n         }\n         if (!this.throwsList.isEmpty()) {\n-            for (final String throwsDescriptor : this.throwsList) {\n-                buf.append(\"\\n\\t\\tthrows \").append(throwsDescriptor);\n+            final Iterator<String> iterator = this.throwsList.iterator();\n+            while (iterator.hasNext()) {\n+                sb.append(\"\\n\\t\\tthrows \").append(iterator.next());\n             }\n         }\n-        return buf.toString();\n+        return sb.toString();\n     }\n     \n     public void update() {\n         if (this.observers != null) {\n-            for (final MethodObserver observer : this.observers) {\n-                observer.notify(this);\n+            final Iterator<MethodObserver> iterator = this.observers.iterator();\n+            while (iterator.hasNext()) {\n+                ((MethodObserver)iterator.next()).notify(this);\n             }\n         }\n     }\n     \n-    private void updateLocalVariableTable(final LocalVariableTable a) {\n+    private void updateLocalVariableTable(final LocalVariableTable localVariableTable) {\n         this.removeLocalVariables();\n-        for (final LocalVariable l : a.getLocalVariableTable()) {\n-            InstructionHandle start = this.il.findHandle(l.getStartPC());\n-            final InstructionHandle end = this.il.findHandle(l.getStartPC() + l.getLength());\n-            if (null == start) {\n-                start = this.il.getStart();\n+        for (final LocalVariable localVariable : localVariableTable.getLocalVariableTable()) {\n+            InstructionHandle instructionHandle = this.il.findHandle(localVariable.getStartPC());\n+            final InstructionHandle handle = this.il.findHandle(localVariable.getStartPC() + localVariable.getLength());\n+            if (null == instructionHandle) {\n+                instructionHandle = this.il.getStart();\n             }\n-            this.addLocalVariable(l.getName(), Type.getType(l.getSignature()), l.getIndex(), start, end, l.getOrigIndex());\n+            this.addLocalVariable(localVariable.getName(), Type.getType(localVariable.getSignature()), localVariable.getIndex(), instructionHandle, handle, localVariable.getOrigIndex());\n         }\n     }\n     \n     static {\n         MethodGen.bcelComparator = (BCELComparator)new MethodGen.MethodGen$1();\n     }\n }\n"}]}
