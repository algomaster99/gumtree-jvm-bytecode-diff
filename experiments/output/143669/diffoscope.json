{"diffoscope-json-version": 1, "source1": "first/AbstractClassCouplingCheck.class", "source2": "second/AbstractClassCouplingCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,26 +1,24 @@\n \n package com.puppycrawl.tools.checkstyle.checks.metrics;\n \n-import java.util.Collections;\n import com.puppycrawl.tools.checkstyle.api.FullIdent;\n import com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n import com.puppycrawl.tools.checkstyle.api.DetailAST;\n import java.util.stream.Collector;\n import java.util.stream.Collectors;\n import java.util.function.Predicate;\n-import java.util.stream.Stream;\n import java.util.function.Consumer;\n-import java.util.Objects;\n import java.util.function.Function;\n import java.util.Arrays;\n import com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n import java.util.ArrayDeque;\n import java.util.HashMap;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.Deque;\n import java.util.Map;\n import java.util.List;\n import java.util.regex.Pattern;\n import java.util.Set;\n import com.puppycrawl.tools.checkstyle.FileStatefulCheck;\n import com.puppycrawl.tools.checkstyle.api.AbstractCheck;\n@@ -36,14 +34,20 @@\n     private final Map<String, String> importedClassPackages;\n     private final Deque<AbstractClassCouplingCheck.ClassContext> classesContexts;\n     private Set<String> excludedClasses;\n     private Set<String> excludedPackages;\n     private int max;\n     private String packageName;\n     \n+    static {\n+        DEFAULT_EXCLUDED_CLASSES = Set.of(new String[] { \"var\", \"boolean\", \"byte\", \"char\", \"double\", \"float\", \"int\", \"long\", \"short\", \"void\", \"Boolean\", \"Byte\", \"Character\", \"Double\", \"Float\", \"Integer\", \"Long\", \"Short\", \"Void\", \"Object\", \"Class\", \"String\", \"StringBuffer\", \"StringBuilder\", \"ArrayIndexOutOfBoundsException\", \"Exception\", \"RuntimeException\", \"IllegalArgumentException\", \"IllegalStateException\", \"IndexOutOfBoundsException\", \"NullPointerException\", \"Throwable\", \"SecurityException\", \"UnsupportedOperationException\", \"List\", \"ArrayList\", \"Deque\", \"Queue\", \"LinkedList\", \"Set\", \"HashSet\", \"SortedSet\", \"TreeSet\", \"Map\", \"HashMap\", \"SortedMap\", \"TreeMap\", \"Override\", \"Deprecated\", \"SafeVarargs\", \"SuppressWarnings\", \"FunctionalInterface\", \"Collection\", \"EnumSet\", \"LinkedHashMap\", \"LinkedHashSet\", \"Optional\", \"OptionalDouble\", \"OptionalInt\", \"OptionalLong\", \"DoubleStream\", \"IntStream\", \"LongStream\", \"Stream\" });\n+        DEFAULT_EXCLUDED_PACKAGES = Collections.emptySet();\n+        BRACKET_PATTERN = Pattern.compile(\"\\\\[[^]]*]\");\n+    }\n+    \n     protected AbstractClassCouplingCheck(final int defaultMax) {\n         this.excludeClassesRegexps = new ArrayList<Pattern>();\n         this.importedClassPackages = new HashMap<String, String>();\n         this.classesContexts = new ArrayDeque<AbstractClassCouplingCheck.ClassContext>();\n         this.excludedClasses = AbstractClassCouplingCheck.DEFAULT_EXCLUDED_CLASSES;\n         this.excludedPackages = AbstractClassCouplingCheck.DEFAULT_EXCLUDED_PACKAGES;\n         this.max = defaultMax;\n@@ -61,24 +65,21 @@\n     }\n     \n     public final void setExcludedClasses(final String... excludedClasses) {\n         this.excludedClasses = Set.of(excludedClasses);\n     }\n     \n     public void setExcludeClassesRegexps(final String... from) {\n-        final Stream<Object> map = Arrays.stream(from).map((Function<? super String, ?>)CommonUtil::createPattern);\n-        final List<Pattern> excludeClassesRegexps = this.excludeClassesRegexps;\n-        Objects.requireNonNull(excludeClassesRegexps);\n-        map.forEach(excludeClassesRegexps::add);\n+        Arrays.stream(from).map((Function<? super String, ?>)CommonUtil::createPattern).forEach(this.excludeClassesRegexps::add);\n     }\n     \n     public final void setExcludedPackages(final String... excludedPackages) {\n         final List<String> invalidIdentifiers = (List<String>)Arrays.stream(excludedPackages).filter(Predicate.not((Predicate<? super String>)CommonUtil::isName)).collect((Collector<? super String, ?, List<String>>)Collectors.toList());\n         if (!invalidIdentifiers.isEmpty()) {\n-            throw new IllegalArgumentException(\"the following values are not valid identifiers: \" + String.valueOf((Object)invalidIdentifiers));\n+            throw new IllegalArgumentException(\"the following values are not valid identifiers: \" + invalidIdentifiers);\n         }\n         this.excludedPackages = Set.of(excludedPackages);\n     }\n     \n     public final void beginTree(final DetailAST ast) {\n         this.importedClassPackages.clear();\n         this.classesContexts.clear();\n@@ -119,15 +120,15 @@\n                 break;\n             }\n             case 159: {\n                 this.visitAnnotationType(ast);\n                 break;\n             }\n             default: {\n-                throw new IllegalArgumentException(\"Unknown type: \" + String.valueOf((Object)ast));\n+                throw new IllegalArgumentException(\"Unknown type: \" + ast);\n             }\n         }\n     }\n     \n     public void leaveToken(final DetailAST ast) {\n         if (TokenUtil.isTypeDeclaration(ast.getType())) {\n             this.leaveClassDef();\n@@ -176,14 +177,8 @@\n     }\n     \n     private void visitAnnotationType(final DetailAST annotationAST) {\n         final DetailAST children = annotationAST.getFirstChild();\n         final DetailAST type = children.getNextSibling();\n         ((AbstractClassCouplingCheck.ClassContext)this.classesContexts.peek()).addReferencedClassName(type.getText());\n     }\n-    \n-    static {\n-        DEFAULT_EXCLUDED_CLASSES = Set.of(new String[] { \"var\", \"boolean\", \"byte\", \"char\", \"double\", \"float\", \"int\", \"long\", \"short\", \"void\", \"Boolean\", \"Byte\", \"Character\", \"Double\", \"Float\", \"Integer\", \"Long\", \"Short\", \"Void\", \"Object\", \"Class\", \"String\", \"StringBuffer\", \"StringBuilder\", \"ArrayIndexOutOfBoundsException\", \"Exception\", \"RuntimeException\", \"IllegalArgumentException\", \"IllegalStateException\", \"IndexOutOfBoundsException\", \"NullPointerException\", \"Throwable\", \"SecurityException\", \"UnsupportedOperationException\", \"List\", \"ArrayList\", \"Deque\", \"Queue\", \"LinkedList\", \"Set\", \"HashSet\", \"SortedSet\", \"TreeSet\", \"Map\", \"HashMap\", \"SortedMap\", \"TreeMap\", \"Override\", \"Deprecated\", \"SafeVarargs\", \"SuppressWarnings\", \"FunctionalInterface\", \"Collection\", \"EnumSet\", \"LinkedHashMap\", \"LinkedHashSet\", \"Optional\", \"OptionalDouble\", \"OptionalInt\", \"OptionalLong\", \"DoubleStream\", \"IntStream\", \"LongStream\", \"Stream\" });\n-        DEFAULT_EXCLUDED_PACKAGES = Collections.emptySet();\n-        BRACKET_PATTERN = Pattern.compile(\"\\\\[[^]]*]\");\n-    }\n }\n"}]}
