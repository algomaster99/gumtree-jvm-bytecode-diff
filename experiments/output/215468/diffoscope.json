{"diffoscope-json-version": 1, "source1": "first/ClassGen.class", "source2": "second/ClassGen.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,12 +1,11 @@\n \n package org.apache.bcel.generic;\n \n import java.util.Iterator;\n-import org.apache.bcel.classfile.ConstantPool;\n import org.apache.bcel.classfile.AnnotationEntry;\n import org.apache.bcel.classfile.RuntimeInvisibleAnnotations;\n import org.apache.bcel.classfile.RuntimeVisibleAnnotations;\n import org.apache.bcel.classfile.Annotations;\n import org.apache.bcel.classfile.JavaClass;\n import org.apache.bcel.classfile.SourceFile;\n import java.util.ArrayList;\n@@ -31,16 +30,16 @@\n     private final List<Method> methodList;\n     private final List<Attribute> attributeList;\n     private final List<String> interfaceList;\n     private final List<AnnotationEntryGen> annotationList;\n     private static BCELComparator bcelComparator;\n     private List<ClassObserver> observers;\n     \n-    public ClassGen(final String className, final String superClassName, final String fileName, final int accessFlags, final String[] interfaces, final ConstantPoolGen cp) {\n-        super(accessFlags);\n+    public ClassGen(final String className, final String superClassName, final String fileName, final int n, final String[] array, final ConstantPoolGen cp) {\n+        super(n);\n         this.classNameIndex = -1;\n         this.superclass_name_index = -1;\n         this.major = 45;\n         this.minor = 3;\n         this.fieldList = new ArrayList<Field>();\n         this.methodList = new ArrayList<Method>();\n         this.attributeList = new ArrayList<Attribute>();\n@@ -51,116 +50,113 @@\n         this.fileName = fileName;\n         this.cp = cp;\n         if (fileName != null) {\n             this.addAttribute((Attribute)new SourceFile(cp.addUtf8(\"SourceFile\"), 2, cp.addUtf8(fileName), cp.getConstantPool()));\n         }\n         this.classNameIndex = cp.addClass(className);\n         this.superclass_name_index = cp.addClass(superClassName);\n-        if (interfaces != null) {\n-            for (final String interface1 : interfaces) {\n-                this.addInterface(interface1);\n+        if (array != null) {\n+            for (int length = array.length, i = 0; i < length; ++i) {\n+                this.addInterface(array[i]);\n             }\n         }\n     }\n     \n-    public ClassGen(final String className, final String superClassName, final String fileName, final int accessFlags, final String[] interfaces) {\n-        this(className, superClassName, fileName, accessFlags, interfaces, new ConstantPoolGen());\n+    public ClassGen(final String s, final String s2, final String s3, final int n, final String[] array) {\n+        this(s, s2, s3, n, array, new ConstantPoolGen());\n     }\n     \n-    public ClassGen(final JavaClass clazz) {\n-        super(clazz.getAccessFlags());\n+    public ClassGen(final JavaClass javaClass) {\n+        super(javaClass.getAccessFlags());\n         this.classNameIndex = -1;\n         this.superclass_name_index = -1;\n         this.major = 45;\n         this.minor = 3;\n         this.fieldList = new ArrayList<Field>();\n         this.methodList = new ArrayList<Method>();\n         this.attributeList = new ArrayList<Attribute>();\n         this.interfaceList = new ArrayList<String>();\n         this.annotationList = new ArrayList<AnnotationEntryGen>();\n-        this.classNameIndex = clazz.getClassNameIndex();\n-        this.superclass_name_index = clazz.getSuperclassNameIndex();\n-        this.className = clazz.getClassName();\n-        this.superClassName = clazz.getSuperclassName();\n-        this.fileName = clazz.getSourceFileName();\n-        this.cp = new ConstantPoolGen(clazz.getConstantPool());\n-        this.major = clazz.getMajor();\n-        this.minor = clazz.getMinor();\n-        final Attribute[] attributes = clazz.getAttributes();\n-        final AnnotationEntryGen[] annotations = this.unpackAnnotations(attributes);\n-        final Method[] methods = clazz.getMethods();\n-        final Field[] fields = clazz.getFields();\n-        final String[] interfaceNames;\n-        final String[] interfaces = interfaceNames = clazz.getInterfaceNames();\n-        for (final String interface1 : interfaceNames) {\n-            this.addInterface(interface1);\n+        this.classNameIndex = javaClass.getClassNameIndex();\n+        this.superclass_name_index = javaClass.getSuperclassNameIndex();\n+        this.className = javaClass.getClassName();\n+        this.superClassName = javaClass.getSuperclassName();\n+        this.fileName = javaClass.getSourceFileName();\n+        this.cp = new ConstantPoolGen(javaClass.getConstantPool());\n+        this.major = javaClass.getMajor();\n+        this.minor = javaClass.getMinor();\n+        final Attribute[] attributes = javaClass.getAttributes();\n+        final AnnotationEntryGen[] unpackAnnotations = this.unpackAnnotations(attributes);\n+        final Method[] methods = javaClass.getMethods();\n+        final Field[] fields = javaClass.getFields();\n+        final String[] interfaceNames = javaClass.getInterfaceNames();\n+        for (int length = interfaceNames.length, i = 0; i < length; ++i) {\n+            this.addInterface(interfaceNames[i]);\n         }\n         for (final Attribute attribute : attributes) {\n             if (!(attribute instanceof Annotations)) {\n                 this.addAttribute(attribute);\n             }\n         }\n-        for (final AnnotationEntryGen annotation : annotations) {\n-            this.addAnnotationEntry(annotation);\n-        }\n-        for (final Method method : methods) {\n-            this.addMethod(method);\n-        }\n-        for (final Field field : fields) {\n-            this.addField(field);\n+        final AnnotationEntryGen[] array2 = unpackAnnotations;\n+        for (int length3 = array2.length, k = 0; k < length3; ++k) {\n+            this.addAnnotationEntry(array2[k]);\n+        }\n+        final Method[] array3 = methods;\n+        for (int length4 = array3.length, l = 0; l < length4; ++l) {\n+            this.addMethod(array3[l]);\n+        }\n+        final Field[] array4 = fields;\n+        for (int length5 = array4.length, n = 0; n < length5; ++n) {\n+            this.addField(array4[n]);\n         }\n     }\n     \n-    private AnnotationEntryGen[] unpackAnnotations(final Attribute[] attrs) {\n-        final List<AnnotationEntryGen> annotationGenObjs = new ArrayList<AnnotationEntryGen>();\n-        for (final Attribute attr : attrs) {\n-            if (attr instanceof RuntimeVisibleAnnotations) {\n-                final RuntimeVisibleAnnotations rva = (RuntimeVisibleAnnotations)attr;\n-                final AnnotationEntry[] annotationEntries;\n-                final AnnotationEntry[] annos = annotationEntries = rva.getAnnotationEntries();\n-                for (final AnnotationEntry a : annotationEntries) {\n-                    annotationGenObjs.add(new AnnotationEntryGen(a, this.getConstantPool(), false));\n+    private AnnotationEntryGen[] unpackAnnotations(final Attribute[] array) {\n+        final ArrayList list = new ArrayList();\n+        for (final Attribute attribute : array) {\n+            if (attribute instanceof RuntimeVisibleAnnotations) {\n+                final AnnotationEntry[] annotationEntries = ((RuntimeVisibleAnnotations)attribute).getAnnotationEntries();\n+                for (int length2 = annotationEntries.length, j = 0; j < length2; ++j) {\n+                    list.add(new AnnotationEntryGen(annotationEntries[j], this.getConstantPool(), false));\n                 }\n             }\n-            else if (attr instanceof RuntimeInvisibleAnnotations) {\n-                final RuntimeInvisibleAnnotations ria = (RuntimeInvisibleAnnotations)attr;\n-                final AnnotationEntry[] annotationEntries2;\n-                final AnnotationEntry[] annos = annotationEntries2 = ria.getAnnotationEntries();\n-                for (final AnnotationEntry a : annotationEntries2) {\n-                    annotationGenObjs.add(new AnnotationEntryGen(a, this.getConstantPool(), false));\n+            else if (attribute instanceof RuntimeInvisibleAnnotations) {\n+                final AnnotationEntry[] annotationEntries2 = ((RuntimeInvisibleAnnotations)attribute).getAnnotationEntries();\n+                for (int length3 = annotationEntries2.length, k = 0; k < length3; ++k) {\n+                    list.add(new AnnotationEntryGen(annotationEntries2[k], this.getConstantPool(), false));\n                 }\n             }\n         }\n-        return annotationGenObjs.toArray(new AnnotationEntryGen[annotationGenObjs.size()]);\n+        return (AnnotationEntryGen[])list.toArray(new AnnotationEntryGen[list.size()]);\n     }\n     \n     public JavaClass getJavaClass() {\n         final int[] interfaces = this.getInterfaces();\n         final Field[] fields = this.getFields();\n         final Method[] methods = this.getMethods();\n-        Attribute[] attributes = null;\n+        Attribute[] attributes;\n         if (this.annotationList.isEmpty()) {\n             attributes = this.getAttributes();\n         }\n         else {\n-            final Attribute[] annAttributes = AnnotationEntryGen.getAnnotationAttributes(this.cp, this.getAnnotationEntries());\n-            attributes = new Attribute[this.attributeList.size() + annAttributes.length];\n+            final Attribute[] annotationAttributes = AnnotationEntryGen.getAnnotationAttributes(this.cp, this.getAnnotationEntries());\n+            attributes = new Attribute[this.attributeList.size() + annotationAttributes.length];\n             this.attributeList.toArray(attributes);\n-            System.arraycopy(annAttributes, 0, attributes, this.attributeList.size(), annAttributes.length);\n+            System.arraycopy(annotationAttributes, 0, attributes, this.attributeList.size(), annotationAttributes.length);\n         }\n-        final ConstantPool _cp = this.cp.getFinalConstantPool();\n-        return new JavaClass(this.classNameIndex, this.superclass_name_index, this.fileName, this.major, this.minor, super.getAccessFlags(), _cp, interfaces, fields, methods, attributes);\n+        return new JavaClass(this.classNameIndex, this.superclass_name_index, this.fileName, this.major, this.minor, super.getAccessFlags(), this.cp.getFinalConstantPool(), interfaces, fields, methods, attributes);\n     }\n     \n-    public void addInterface(final String name) {\n-        this.interfaceList.add(name);\n+    public void addInterface(final String s) {\n+        this.interfaceList.add(s);\n     }\n     \n-    public void removeInterface(final String name) {\n-        this.interfaceList.remove(name);\n+    public void removeInterface(final String s) {\n+        this.interfaceList.remove(s);\n     }\n     \n     public int getMajor() {\n         return this.major;\n     }\n     \n     public void setMajor(final int major) {\n@@ -171,155 +167,154 @@\n         this.minor = minor;\n     }\n     \n     public int getMinor() {\n         return this.minor;\n     }\n     \n-    public void addAttribute(final Attribute a) {\n-        this.attributeList.add(a);\n+    public void addAttribute(final Attribute attribute) {\n+        this.attributeList.add(attribute);\n     }\n     \n-    public void addAnnotationEntry(final AnnotationEntryGen a) {\n-        this.annotationList.add(a);\n+    public void addAnnotationEntry(final AnnotationEntryGen annotationEntryGen) {\n+        this.annotationList.add(annotationEntryGen);\n     }\n     \n-    public void addMethod(final Method m) {\n-        this.methodList.add(m);\n+    public void addMethod(final Method method) {\n+        this.methodList.add(method);\n     }\n     \n-    public void addEmptyConstructor(final int access_flags) {\n-        final InstructionList il = new InstructionList();\n-        il.append((Instruction)InstructionConst.THIS);\n-        il.append((Instruction)new INVOKESPECIAL(this.cp.addMethodref(this.superClassName, \"<init>\", \"()V\")));\n-        il.append((Instruction)InstructionConst.RETURN);\n-        final MethodGen mg = new MethodGen(access_flags, (Type)Type.VOID, Type.NO_ARGS, (String[])null, \"<init>\", this.className, il, this.cp);\n-        mg.setMaxStack(1);\n-        this.addMethod(mg.getMethod());\n+    public void addEmptyConstructor(final int n) {\n+        final InstructionList list = new InstructionList();\n+        list.append((Instruction)InstructionConst.THIS);\n+        list.append((Instruction)new INVOKESPECIAL(this.cp.addMethodref(this.superClassName, \"<init>\", \"()V\")));\n+        list.append((Instruction)InstructionConst.RETURN);\n+        final MethodGen methodGen = new MethodGen(n, (Type)Type.VOID, Type.NO_ARGS, (String[])null, \"<init>\", this.className, list, this.cp);\n+        methodGen.setMaxStack(1);\n+        this.addMethod(methodGen.getMethod());\n     }\n     \n-    public void addField(final Field f) {\n-        this.fieldList.add(f);\n+    public void addField(final Field field) {\n+        this.fieldList.add(field);\n     }\n     \n-    public boolean containsField(final Field f) {\n-        return this.fieldList.contains(f);\n+    public boolean containsField(final Field field) {\n+        return this.fieldList.contains(field);\n     }\n     \n-    public Field containsField(final String name) {\n-        for (final Field f : this.fieldList) {\n-            if (f.getName().equals(name)) {\n-                return f;\n+    public Field containsField(final String anObject) {\n+        for (final Field field : this.fieldList) {\n+            if (field.getName().equals(anObject)) {\n+                return field;\n             }\n         }\n         return null;\n     }\n     \n-    public Method containsMethod(final String name, final String signature) {\n-        for (final Method m : this.methodList) {\n-            if (m.getName().equals(name) && m.getSignature().equals(signature)) {\n-                return m;\n+    public Method containsMethod(final String anObject, final String anObject2) {\n+        for (final Method method : this.methodList) {\n+            if (method.getName().equals(anObject) && method.getSignature().equals(anObject2)) {\n+                return method;\n             }\n         }\n         return null;\n     }\n     \n-    public void removeAttribute(final Attribute a) {\n-        this.attributeList.remove(a);\n+    public void removeAttribute(final Attribute attribute) {\n+        this.attributeList.remove(attribute);\n     }\n     \n-    public void removeMethod(final Method m) {\n-        this.methodList.remove(m);\n+    public void removeMethod(final Method method) {\n+        this.methodList.remove(method);\n     }\n     \n-    public void replaceMethod(final Method old, final Method new_) {\n-        if (new_ == null) {\n+    public void replaceMethod(final Method method, final Method method2) {\n+        if (method2 == null) {\n             throw new ClassGenException(\"Replacement method must not be null\");\n         }\n-        final int i = this.methodList.indexOf(old);\n-        if (i < 0) {\n-            this.methodList.add(new_);\n+        final int index = this.methodList.indexOf(method);\n+        if (index < 0) {\n+            this.methodList.add(method2);\n         }\n         else {\n-            this.methodList.set(i, new_);\n+            this.methodList.set(index, method2);\n         }\n     }\n     \n-    public void replaceField(final Field old, final Field new_) {\n-        if (new_ == null) {\n+    public void replaceField(final Field field, final Field field2) {\n+        if (field2 == null) {\n             throw new ClassGenException(\"Replacement method must not be null\");\n         }\n-        final int i = this.fieldList.indexOf(old);\n-        if (i < 0) {\n-            this.fieldList.add(new_);\n+        final int index = this.fieldList.indexOf(field);\n+        if (index < 0) {\n+            this.fieldList.add(field2);\n         }\n         else {\n-            this.fieldList.set(i, new_);\n+            this.fieldList.set(index, field2);\n         }\n     }\n     \n-    public void removeField(final Field f) {\n-        this.fieldList.remove(f);\n+    public void removeField(final Field field) {\n+        this.fieldList.remove(field);\n     }\n     \n     public String getClassName() {\n         return this.className;\n     }\n     \n     public String getSuperclassName() {\n         return this.superClassName;\n     }\n     \n     public String getFileName() {\n         return this.fileName;\n     }\n     \n-    public void setClassName(final String name) {\n-        this.className = name.replace('/', '.');\n-        this.classNameIndex = this.cp.addClass(name);\n+    public void setClassName(final String s) {\n+        this.className = s.replace('/', '.');\n+        this.classNameIndex = this.cp.addClass(s);\n     }\n     \n-    public void setSuperclassName(final String name) {\n-        this.superClassName = name.replace('/', '.');\n-        this.superclass_name_index = this.cp.addClass(name);\n+    public void setSuperclassName(final String s) {\n+        this.superClassName = s.replace('/', '.');\n+        this.superclass_name_index = this.cp.addClass(s);\n     }\n     \n     public Method[] getMethods() {\n         return this.methodList.toArray(new Method[this.methodList.size()]);\n     }\n     \n-    public void setMethods(final Method[] methods) {\n+    public void setMethods(final Method[] array) {\n         this.methodList.clear();\n-        for (final Method method : methods) {\n-            this.addMethod(method);\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            this.addMethod(array[i]);\n         }\n     }\n     \n-    public void setMethodAt(final Method method, final int pos) {\n-        this.methodList.set(pos, method);\n+    public void setMethodAt(final Method method, final int n) {\n+        this.methodList.set(n, method);\n     }\n     \n-    public Method getMethodAt(final int pos) {\n-        return this.methodList.get(pos);\n+    public Method getMethodAt(final int n) {\n+        return this.methodList.get(n);\n     }\n     \n     public String[] getInterfaceNames() {\n-        final int size = this.interfaceList.size();\n-        final String[] interfaces = new String[size];\n-        this.interfaceList.toArray(interfaces);\n-        return interfaces;\n+        final String[] array = new String[this.interfaceList.size()];\n+        this.interfaceList.toArray(array);\n+        return array;\n     }\n     \n     public int[] getInterfaces() {\n         final int size = this.interfaceList.size();\n-        final int[] interfaces = new int[size];\n+        final int[] array = new int[size];\n         for (int i = 0; i < size; ++i) {\n-            interfaces[i] = this.cp.addClass((String)this.interfaceList.get(i));\n+            array[i] = this.cp.addClass((String)this.interfaceList.get(i));\n         }\n-        return interfaces;\n+        return array;\n     }\n     \n     public Field[] getFields() {\n         return this.fieldList.toArray(new Field[this.fieldList.size()]);\n     }\n     \n     public Attribute[] getAttributes() {\n@@ -330,21 +325,21 @@\n         return this.annotationList.toArray(new AnnotationEntryGen[this.annotationList.size()]);\n     }\n     \n     public ConstantPoolGen getConstantPool() {\n         return this.cp;\n     }\n     \n-    public void setConstantPool(final ConstantPoolGen constant_pool) {\n-        this.cp = constant_pool;\n+    public void setConstantPool(final ConstantPoolGen cp) {\n+        this.cp = cp;\n     }\n     \n-    public void setClassNameIndex(final int class_name_index) {\n-        this.classNameIndex = class_name_index;\n-        this.className = this.cp.getConstantPool().getConstantString(class_name_index, (byte)7).replace('/', '.');\n+    public void setClassNameIndex(final int classNameIndex) {\n+        this.classNameIndex = classNameIndex;\n+        this.className = this.cp.getConstantPool().getConstantString(classNameIndex, (byte)7).replace('/', '.');\n     }\n     \n     public void setSuperclassNameIndex(final int superclass_name_index) {\n         this.superclass_name_index = superclass_name_index;\n         this.superClassName = this.cp.getConstantPool().getConstantString(superclass_name_index, (byte)7).replace('/', '.');\n     }\n     \n@@ -352,54 +347,55 @@\n         return this.superclass_name_index;\n     }\n     \n     public int getClassNameIndex() {\n         return this.classNameIndex;\n     }\n     \n-    public void addObserver(final ClassObserver o) {\n+    public void addObserver(final ClassObserver classObserver) {\n         if (this.observers == null) {\n             this.observers = new ArrayList<ClassObserver>();\n         }\n-        this.observers.add(o);\n+        this.observers.add(classObserver);\n     }\n     \n-    public void removeObserver(final ClassObserver o) {\n+    public void removeObserver(final ClassObserver classObserver) {\n         if (this.observers != null) {\n-            this.observers.remove(o);\n+            this.observers.remove(classObserver);\n         }\n     }\n     \n     public void update() {\n         if (this.observers != null) {\n-            for (final ClassObserver observer : this.observers) {\n-                observer.notify(this);\n+            final Iterator<ClassObserver> iterator = this.observers.iterator();\n+            while (iterator.hasNext()) {\n+                ((ClassObserver)iterator.next()).notify(this);\n             }\n         }\n     }\n     \n     public Object clone() {\n         try {\n             return super.clone();\n         }\n-        catch (final CloneNotSupportedException e) {\n+        catch (final CloneNotSupportedException ex) {\n             throw new Error(\"Clone Not Supported\");\n         }\n     }\n     \n     public static BCELComparator getComparator() {\n         return ClassGen.bcelComparator;\n     }\n     \n-    public static void setComparator(final BCELComparator comparator) {\n-        ClassGen.bcelComparator = comparator;\n+    public static void setComparator(final BCELComparator bcelComparator) {\n+        ClassGen.bcelComparator = bcelComparator;\n     }\n     \n-    public boolean equals(final Object obj) {\n-        return ClassGen.bcelComparator.equals((Object)this, obj);\n+    public boolean equals(final Object o) {\n+        return ClassGen.bcelComparator.equals((Object)this, o);\n     }\n     \n     public int hashCode() {\n         return ClassGen.bcelComparator.hashCode((Object)this);\n     }\n     \n     static {\n"}]}
