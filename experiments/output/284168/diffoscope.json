{"diffoscope-json-version": 1, "source1": "first/HashCodeBuilder.class", "source2": "second/HashCodeBuilder.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -22,169 +22,168 @@\n     private final int iConstant;\n     private int iTotal;\n     \n     static Set<IDKey> getRegistry() {\n         return HashCodeBuilder.REGISTRY.get();\n     }\n     \n-    static boolean isRegistered(final Object value) {\n+    static boolean isRegistered(final Object o) {\n         final Set<IDKey> registry = getRegistry();\n-        return registry != null && registry.contains(new IDKey(value));\n+        return registry != null && registry.contains(new IDKey(o));\n     }\n     \n-    private static void reflectionAppend(final Object object, final Class<?> clazz, final HashCodeBuilder builder, final boolean useTransients, final String[] excludeFields) {\n-        if (isRegistered(object)) {\n+    private static void reflectionAppend(final Object obj, final Class<?> clazz, final HashCodeBuilder hashCodeBuilder, final boolean b, final String[] array) {\n+        if (isRegistered(obj)) {\n             return;\n         }\n         try {\n-            register(object);\n-            final Field[] fields = (Field[])ArraySorter.sort((Object[])clazz.getDeclaredFields(), (Comparator)Comparator.comparing((Function<? super Object, ? extends Comparable>)Field::getName));\n-            AccessibleObject.setAccessible(fields, true);\n-            for (final Field field : fields) {\n-                if (!ArrayUtils.contains((Object[])excludeFields, (Object)field.getName()) && !field.getName().contains(\"$\") && (useTransients || !Modifier.isTransient(field.getModifiers())) && !Modifier.isStatic(field.getModifiers()) && !field.isAnnotationPresent((Class<? extends Annotation>)HashCodeExclude.class)) {\n+            register(obj);\n+            final Field[] array2 = (Field[])ArraySorter.sort((Object[])clazz.getDeclaredFields(), (Comparator)Comparator.comparing((Function<? super Object, ? extends Comparable>)Field::getName));\n+            AccessibleObject.setAccessible(array2, true);\n+            for (final Field field : array2) {\n+                if (!ArrayUtils.contains((Object[])array, (Object)field.getName()) && !field.getName().contains(\"$\") && (b || !Modifier.isTransient(field.getModifiers())) && !Modifier.isStatic(field.getModifiers()) && !field.isAnnotationPresent((Class<? extends Annotation>)HashCodeExclude.class)) {\n                     try {\n-                        final Object fieldValue = field.get(object);\n-                        builder.append(fieldValue);\n+                        hashCodeBuilder.append(field.get(obj));\n                     }\n-                    catch (final IllegalAccessException e) {\n+                    catch (final IllegalAccessException ex) {\n                         throw new InternalError(\"Unexpected IllegalAccessException\");\n                     }\n                 }\n             }\n         }\n         finally {\n-            unregister(object);\n+            unregister(obj);\n         }\n     }\n     \n-    public static int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final Object object) {\n-        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null, new String[0]);\n+    public static int reflectionHashCode(final int n, final int n2, final Object o) {\n+        return reflectionHashCode(n, n2, o, false, null, new String[0]);\n     }\n     \n-    public static int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final Object object, final boolean testTransients) {\n-        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null, new String[0]);\n+    public static int reflectionHashCode(final int n, final int n2, final Object o, final boolean b) {\n+        return reflectionHashCode(n, n2, o, b, null, new String[0]);\n     }\n     \n-    public static <T> int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final T object, final boolean testTransients, final Class<? super T> reflectUpToClass, final String... excludeFields) {\n-        Validate.notNull((Object)object, \"object\", new Object[0]);\n-        final HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\n-        Class<?> clazz = object.getClass();\n-        reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n-        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\n-            clazz = clazz.getSuperclass();\n-            reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n+    public static <T> int reflectionHashCode(final int n, final int n2, final T t, final boolean b, final Class<? super T> clazz, final String... array) {\n+        Validate.notNull((Object)t, \"object\", new Object[0]);\n+        final HashCodeBuilder hashCodeBuilder = new HashCodeBuilder(n, n2);\n+        Class<?> clazz2 = t.getClass();\n+        reflectionAppend(t, clazz2, hashCodeBuilder, b, array);\n+        while (clazz2.getSuperclass() != null && clazz2 != clazz) {\n+            clazz2 = clazz2.getSuperclass();\n+            reflectionAppend(t, clazz2, hashCodeBuilder, b, array);\n         }\n-        return builder.toHashCode();\n+        return hashCodeBuilder.toHashCode();\n     }\n     \n-    public static int reflectionHashCode(final Object object, final boolean testTransients) {\n-        return reflectionHashCode(17, 37, object, testTransients, null, new String[0]);\n+    public static int reflectionHashCode(final Object o, final boolean b) {\n+        return reflectionHashCode(17, 37, o, b, null, new String[0]);\n     }\n     \n-    public static int reflectionHashCode(final Object object, final Collection<String> excludeFields) {\n-        return reflectionHashCode(object, ReflectionToStringBuilder.toNoNullStringArray((Collection)excludeFields));\n+    public static int reflectionHashCode(final Object o, final Collection<String> collection) {\n+        return reflectionHashCode(o, ReflectionToStringBuilder.toNoNullStringArray((Collection)collection));\n     }\n     \n-    public static int reflectionHashCode(final Object object, final String... excludeFields) {\n-        return reflectionHashCode(17, 37, object, false, null, excludeFields);\n+    public static int reflectionHashCode(final Object o, final String... array) {\n+        return reflectionHashCode(17, 37, o, false, null, array);\n     }\n     \n-    private static void register(final Object value) {\n+    private static void register(final Object o) {\n         Set<IDKey> registry = getRegistry();\n         if (registry == null) {\n             registry = new HashSet<IDKey>();\n             HashCodeBuilder.REGISTRY.set(registry);\n         }\n-        registry.add(new IDKey(value));\n+        registry.add(new IDKey(o));\n     }\n     \n-    private static void unregister(final Object value) {\n+    private static void unregister(final Object o) {\n         final Set<IDKey> registry = getRegistry();\n         if (registry != null) {\n-            registry.remove(new IDKey(value));\n+            registry.remove(new IDKey(o));\n             if (registry.isEmpty()) {\n                 HashCodeBuilder.REGISTRY.remove();\n             }\n         }\n     }\n     \n     public HashCodeBuilder() {\n         this.iConstant = 37;\n         this.iTotal = 17;\n     }\n     \n-    public HashCodeBuilder(final int initialOddNumber, final int multiplierOddNumber) {\n-        Validate.isTrue(initialOddNumber % 2 != 0, \"HashCodeBuilder requires an odd initial value\", new Object[0]);\n-        Validate.isTrue(multiplierOddNumber % 2 != 0, \"HashCodeBuilder requires an odd multiplier\", new Object[0]);\n-        this.iConstant = multiplierOddNumber;\n-        this.iTotal = initialOddNumber;\n+    public HashCodeBuilder(final int iTotal, final int iConstant) {\n+        Validate.isTrue(iTotal % 2 != 0, \"HashCodeBuilder requires an odd initial value\", new Object[0]);\n+        Validate.isTrue(iConstant % 2 != 0, \"HashCodeBuilder requires an odd multiplier\", new Object[0]);\n+        this.iConstant = iConstant;\n+        this.iTotal = iTotal;\n     }\n     \n-    public HashCodeBuilder append(final boolean value) {\n-        this.iTotal = this.iTotal * this.iConstant + (value ? 0 : 1);\n+    public HashCodeBuilder append(final boolean b) {\n+        this.iTotal = this.iTotal * this.iConstant + (b ? 0 : 1);\n         return this;\n     }\n     \n     public HashCodeBuilder append(final boolean[] array) {\n         if (array == null) {\n             this.iTotal *= this.iConstant;\n         }\n         else {\n-            for (final boolean element : array) {\n-                this.append(element);\n+            for (int length = array.length, i = 0; i < length; ++i) {\n+                this.append(array[i]);\n             }\n         }\n         return this;\n     }\n     \n-    public HashCodeBuilder append(final byte value) {\n-        this.iTotal = this.iTotal * this.iConstant + value;\n+    public HashCodeBuilder append(final byte b) {\n+        this.iTotal = this.iTotal * this.iConstant + b;\n         return this;\n     }\n     \n     public HashCodeBuilder append(final byte[] array) {\n         if (array == null) {\n             this.iTotal *= this.iConstant;\n         }\n         else {\n-            for (final byte element : array) {\n-                this.append(element);\n+            for (int length = array.length, i = 0; i < length; ++i) {\n+                this.append(array[i]);\n             }\n         }\n         return this;\n     }\n     \n-    public HashCodeBuilder append(final char value) {\n-        this.iTotal = this.iTotal * this.iConstant + value;\n+    public HashCodeBuilder append(final char c) {\n+        this.iTotal = this.iTotal * this.iConstant + c;\n         return this;\n     }\n     \n     public HashCodeBuilder append(final char[] array) {\n         if (array == null) {\n             this.iTotal *= this.iConstant;\n         }\n         else {\n-            for (final char element : array) {\n-                this.append(element);\n+            for (int length = array.length, i = 0; i < length; ++i) {\n+                this.append(array[i]);\n             }\n         }\n         return this;\n     }\n     \n     public HashCodeBuilder append(final double value) {\n         return this.append(Double.doubleToLongBits(value));\n     }\n     \n     public HashCodeBuilder append(final double[] array) {\n         if (array == null) {\n             this.iTotal *= this.iConstant;\n         }\n         else {\n-            for (final double element : array) {\n-                this.append(element);\n+            for (int length = array.length, i = 0; i < length; ++i) {\n+                this.append(array[i]);\n             }\n         }\n         return this;\n     }\n     \n     public HashCodeBuilder append(final float value) {\n         this.iTotal = this.iTotal * this.iConstant + Float.floatToIntBits(value);\n@@ -192,129 +191,129 @@\n     }\n     \n     public HashCodeBuilder append(final float[] array) {\n         if (array == null) {\n             this.iTotal *= this.iConstant;\n         }\n         else {\n-            for (final float element : array) {\n-                this.append(element);\n+            for (int length = array.length, i = 0; i < length; ++i) {\n+                this.append(array[i]);\n             }\n         }\n         return this;\n     }\n     \n-    public HashCodeBuilder append(final int value) {\n-        this.iTotal = this.iTotal * this.iConstant + value;\n+    public HashCodeBuilder append(final int n) {\n+        this.iTotal = this.iTotal * this.iConstant + n;\n         return this;\n     }\n     \n     public HashCodeBuilder append(final int[] array) {\n         if (array == null) {\n             this.iTotal *= this.iConstant;\n         }\n         else {\n-            for (final int element : array) {\n-                this.append(element);\n+            for (int length = array.length, i = 0; i < length; ++i) {\n+                this.append(array[i]);\n             }\n         }\n         return this;\n     }\n     \n-    public HashCodeBuilder append(final long value) {\n-        this.iTotal = this.iTotal * this.iConstant + (int)(value ^ value >> 32);\n+    public HashCodeBuilder append(final long n) {\n+        this.iTotal = this.iTotal * this.iConstant + (int)(n ^ n >> 32);\n         return this;\n     }\n     \n     public HashCodeBuilder append(final long[] array) {\n         if (array == null) {\n             this.iTotal *= this.iConstant;\n         }\n         else {\n-            for (final long element : array) {\n-                this.append(element);\n+            for (int length = array.length, i = 0; i < length; ++i) {\n+                this.append(array[i]);\n             }\n         }\n         return this;\n     }\n     \n-    public HashCodeBuilder append(final Object object) {\n-        if (object == null) {\n+    public HashCodeBuilder append(final Object o) {\n+        if (o == null) {\n             this.iTotal *= this.iConstant;\n         }\n-        else if (object.getClass().isArray()) {\n-            this.appendArray(object);\n+        else if (o.getClass().isArray()) {\n+            this.appendArray(o);\n         }\n         else {\n-            this.iTotal = this.iTotal * this.iConstant + object.hashCode();\n+            this.iTotal = this.iTotal * this.iConstant + o.hashCode();\n         }\n         return this;\n     }\n     \n-    private void appendArray(final Object object) {\n-        if (object instanceof long[]) {\n-            this.append((long[])object);\n+    private void appendArray(final Object o) {\n+        if (o instanceof long[]) {\n+            this.append((long[])o);\n         }\n-        else if (object instanceof int[]) {\n-            this.append((int[])object);\n+        else if (o instanceof int[]) {\n+            this.append((int[])o);\n         }\n-        else if (object instanceof short[]) {\n-            this.append((short[])object);\n+        else if (o instanceof short[]) {\n+            this.append((short[])o);\n         }\n-        else if (object instanceof char[]) {\n-            this.append((char[])object);\n+        else if (o instanceof char[]) {\n+            this.append((char[])o);\n         }\n-        else if (object instanceof byte[]) {\n-            this.append((byte[])object);\n+        else if (o instanceof byte[]) {\n+            this.append((byte[])o);\n         }\n-        else if (object instanceof double[]) {\n-            this.append((double[])object);\n+        else if (o instanceof double[]) {\n+            this.append((double[])o);\n         }\n-        else if (object instanceof float[]) {\n-            this.append((float[])object);\n+        else if (o instanceof float[]) {\n+            this.append((float[])o);\n         }\n-        else if (object instanceof boolean[]) {\n-            this.append((boolean[])object);\n+        else if (o instanceof boolean[]) {\n+            this.append((boolean[])o);\n         }\n         else {\n-            this.append((Object[])object);\n+            this.append((Object[])o);\n         }\n     }\n     \n     public HashCodeBuilder append(final Object[] array) {\n         if (array == null) {\n             this.iTotal *= this.iConstant;\n         }\n         else {\n-            for (final Object element : array) {\n-                this.append(element);\n+            for (int length = array.length, i = 0; i < length; ++i) {\n+                this.append(array[i]);\n             }\n         }\n         return this;\n     }\n     \n-    public HashCodeBuilder append(final short value) {\n-        this.iTotal = this.iTotal * this.iConstant + value;\n+    public HashCodeBuilder append(final short n) {\n+        this.iTotal = this.iTotal * this.iConstant + n;\n         return this;\n     }\n     \n     public HashCodeBuilder append(final short[] array) {\n         if (array == null) {\n             this.iTotal *= this.iConstant;\n         }\n         else {\n-            for (final short element : array) {\n-                this.append(element);\n+            for (int length = array.length, i = 0; i < length; ++i) {\n+                this.append(array[i]);\n             }\n         }\n         return this;\n     }\n     \n-    public HashCodeBuilder appendSuper(final int superHashCode) {\n-        this.iTotal = this.iTotal * this.iConstant + superHashCode;\n+    public HashCodeBuilder appendSuper(final int n) {\n+        this.iTotal = this.iTotal * this.iConstant + n;\n         return this;\n     }\n     \n     public int toHashCode() {\n         return this.iTotal;\n     }\n     \n"}]}
