{"diffoscope-json-version": 1, "source1": "first/BlockLZ4CompressorInputStream.class", "source2": "second/BlockLZ4CompressorInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -11,107 +11,107 @@\n     static final int WINDOW_SIZE = 65536;\n     static final int SIZE_BITS = 4;\n     static final int BACK_REFERENCE_SIZE_MASK = 15;\n     static final int LITERAL_SIZE_MASK = 240;\n     private int nextBackReferenceSize;\n     private BlockLZ4CompressorInputStream.State state;\n     \n-    public BlockLZ4CompressorInputStream(final InputStream is) throws IOException {\n-        super(is, 65536);\n+    public BlockLZ4CompressorInputStream(final InputStream inputStream) throws IOException {\n+        super(inputStream, 65536);\n         this.state = BlockLZ4CompressorInputStream.State.NO_BLOCK;\n     }\n     \n-    public int read(final byte[] b, final int off, final int len) throws IOException {\n-        if (len == 0) {\n+    public int read(final byte[] array, final int n, final int n2) throws IOException {\n+        if (n2 == 0) {\n             return 0;\n         }\n         switch (BlockLZ4CompressorInputStream.BlockLZ4CompressorInputStream$1.$SwitchMap$org$apache$commons$compress$compressors$lz4$BlockLZ4CompressorInputStream$State[this.state.ordinal()]) {\n             case 1: {\n                 return -1;\n             }\n             case 2: {\n                 this.readSizes();\n             }\n             case 3: {\n-                final int litLen = this.readLiteral(b, off, len);\n+                final int literal = this.readLiteral(array, n, n2);\n                 if (!this.hasMoreDataInBlock()) {\n                     this.state = BlockLZ4CompressorInputStream.State.LOOKING_FOR_BACK_REFERENCE;\n                 }\n-                return (litLen > 0) ? litLen : this.read(b, off, len);\n+                return (literal > 0) ? literal : this.read(array, n, n2);\n             }\n             case 4: {\n                 if (!this.initializeBackReference()) {\n                     this.state = BlockLZ4CompressorInputStream.State.EOF;\n                     return -1;\n                 }\n             }\n             case 5: {\n-                final int backReferenceLen = this.readBackReference(b, off, len);\n+                final int backReference = this.readBackReference(array, n, n2);\n                 if (!this.hasMoreDataInBlock()) {\n                     this.state = BlockLZ4CompressorInputStream.State.NO_BLOCK;\n                 }\n-                return (backReferenceLen > 0) ? backReferenceLen : this.read(b, off, len);\n+                return (backReference > 0) ? backReference : this.read(array, n, n2);\n             }\n             default: {\n                 throw new IOException(\"Unknown stream state \" + this.state);\n             }\n         }\n     }\n     \n     private void readSizes() throws IOException {\n-        final int nextBlock = this.readOneByte();\n-        if (nextBlock == -1) {\n+        final int oneByte = this.readOneByte();\n+        if (oneByte == -1) {\n             throw new IOException(\"Premature end of stream while looking for next block\");\n         }\n-        this.nextBackReferenceSize = (nextBlock & 0xF);\n-        long literalSizePart = (long)((nextBlock & 0xF0) >> 4);\n-        if (literalSizePart == 15L) {\n-            literalSizePart += this.readSizeBytes();\n+        this.nextBackReferenceSize = (oneByte & 0xF);\n+        long n = (long)((oneByte & 0xF0) >> 4);\n+        if (n == 15L) {\n+            n += this.readSizeBytes();\n         }\n-        if (literalSizePart < 0L) {\n+        if (n < 0L) {\n             throw new IOException(\"Illegal block with a negative literal size found\");\n         }\n-        this.startLiteral(literalSizePart);\n+        this.startLiteral(n);\n         this.state = BlockLZ4CompressorInputStream.State.IN_LITERAL;\n     }\n     \n     private long readSizeBytes() throws IOException {\n-        long accum = 0L;\n-        int nextByte;\n+        long n = 0L;\n+        int i;\n         do {\n-            nextByte = this.readOneByte();\n-            if (nextByte == -1) {\n+            i = this.readOneByte();\n+            if (i == -1) {\n                 throw new IOException(\"Premature end of stream while parsing length\");\n             }\n-            accum += nextByte;\n-        } while (nextByte == 255);\n-        return accum;\n+            n += i;\n+        } while (i == 255);\n+        return n;\n     }\n     \n     private boolean initializeBackReference() throws IOException {\n-        int backReferenceOffset = 0;\n+        int n;\n         try {\n-            backReferenceOffset = (int)ByteUtils.fromLittleEndian(this.supplier, 2);\n+            n = (int)ByteUtils.fromLittleEndian(this.supplier, 2);\n         }\n         catch (final IOException ex) {\n             if (this.nextBackReferenceSize == 0) {\n                 return false;\n             }\n             throw ex;\n         }\n-        long backReferenceSize = (long)this.nextBackReferenceSize;\n+        long n2 = (long)this.nextBackReferenceSize;\n         if (this.nextBackReferenceSize == 15) {\n-            backReferenceSize += this.readSizeBytes();\n+            n2 += this.readSizeBytes();\n         }\n-        if (backReferenceSize < 0L) {\n+        if (n2 < 0L) {\n             throw new IOException(\"Illegal block with a negative match length found\");\n         }\n         try {\n-            this.startBackReference(backReferenceOffset, backReferenceSize + 4L);\n+            this.startBackReference(n, n2 + 4L);\n         }\n-        catch (final IllegalArgumentException ex2) {\n-            throw new IOException(\"Illegal block with bad offset found\", ex2);\n+        catch (final IllegalArgumentException cause) {\n+            throw new IOException(\"Illegal block with bad offset found\", cause);\n         }\n         this.state = BlockLZ4CompressorInputStream.State.IN_BACK_REFERENCE;\n         return true;\n     }\n }\n"}]}
