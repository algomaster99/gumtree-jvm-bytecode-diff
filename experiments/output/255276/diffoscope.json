{"diffoscope-json-version": 1, "source1": "first/BZip2CompressorOutputStream.class", "source2": "second/BZip2CompressorOutputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -24,186 +24,181 @@\n     private int combinedCRC;\n     private final int allowableBlockSize;\n     private BZip2CompressorOutputStream.Data data;\n     private BlockSort blockSorter;\n     private OutputStream out;\n     private volatile boolean closed;\n     \n-    private static void hbMakeCodeLengths(final byte[] len, final int[] freq, final BZip2CompressorOutputStream.Data dat, final int alphaSize, final int maxLen) {\n-        final int[] heap = dat.heap;\n-        final int[] weight = dat.weight;\n-        final int[] parent = dat.parent;\n-        int i = alphaSize;\n-        while (--i >= 0) {\n-            weight[i + 1] = ((freq[i] == 0) ? 1 : freq[i]) << 8;\n-        }\n-        boolean tooLong = true;\n-        while (tooLong) {\n-            tooLong = false;\n-            int nNodes = alphaSize;\n-            int nHeap = 0;\n+    private static void hbMakeCodeLengths(final byte[] array, final int[] array2, final BZip2CompressorOutputStream.Data data, final int n, final int n2) {\n+        final int[] heap = data.heap;\n+        final int[] weight = data.weight;\n+        final int[] parent = data.parent;\n+        int n3 = n;\n+        while (--n3 >= 0) {\n+            weight[n3 + 1] = ((array2[n3] == 0) ? 1 : array2[n3]) << 8;\n+        }\n+        int i = 1;\n+        while (i != 0) {\n+            i = 0;\n+            int n4 = n;\n+            int j = 0;\n             heap[0] = 0;\n             parent[weight[0] = 0] = -2;\n-            for (int j = 1; j <= alphaSize; ++j) {\n-                parent[j] = -1;\n-                ++nHeap;\n-                heap[nHeap] = j;\n-                int zz;\n-                int tmp;\n-                for (zz = nHeap, tmp = heap[zz]; weight[tmp] < weight[heap[zz >> 1]]; zz >>= 1) {\n-                    heap[zz] = heap[zz >> 1];\n-                }\n-                heap[zz] = tmp;\n-            }\n-            while (nHeap > 1) {\n-                final int n1 = heap[1];\n-                heap[1] = heap[nHeap];\n-                --nHeap;\n-                int yy = 0;\n-                int zz2 = 1;\n-                int tmp2 = heap[1];\n+            for (int k = 1; k <= n; ++k) {\n+                parent[k] = -1;\n+                ++j;\n+                heap[j] = k;\n+                int n5;\n+                int n6;\n+                for (n5 = j, n6 = heap[n5]; weight[n6] < weight[heap[n5 >> 1]]; n5 >>= 1) {\n+                    heap[n5] = heap[n5 >> 1];\n+                }\n+                heap[n5] = n6;\n+            }\n+            while (j > 1) {\n+                final int n7 = heap[1];\n+                heap[1] = heap[j];\n+                --j;\n+                int n8 = 1;\n+                final int n9 = heap[1];\n                 while (true) {\n-                    yy = zz2 << 1;\n-                    if (yy > nHeap) {\n+                    int n10 = n8 << 1;\n+                    if (n10 > j) {\n                         break;\n                     }\n-                    if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]]) {\n-                        ++yy;\n+                    if (n10 < j && weight[heap[n10 + 1]] < weight[heap[n10]]) {\n+                        ++n10;\n                     }\n-                    if (weight[tmp2] < weight[heap[yy]]) {\n+                    if (weight[n9] < weight[heap[n10]]) {\n                         break;\n                     }\n-                    heap[zz2] = heap[yy];\n-                    zz2 = yy;\n+                    heap[n8] = heap[n10];\n+                    n8 = n10;\n                 }\n-                heap[zz2] = tmp2;\n-                final int n2 = heap[1];\n-                heap[1] = heap[nHeap];\n-                --nHeap;\n-                yy = 0;\n-                zz2 = 1;\n-                tmp2 = heap[1];\n+                heap[n8] = n9;\n+                final int n11 = heap[1];\n+                heap[1] = heap[j];\n+                --j;\n+                int n12 = 1;\n+                final int n13 = heap[1];\n                 while (true) {\n-                    yy = zz2 << 1;\n-                    if (yy > nHeap) {\n+                    int n14 = n12 << 1;\n+                    if (n14 > j) {\n                         break;\n                     }\n-                    if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]]) {\n-                        ++yy;\n+                    if (n14 < j && weight[heap[n14 + 1]] < weight[heap[n14]]) {\n+                        ++n14;\n                     }\n-                    if (weight[tmp2] < weight[heap[yy]]) {\n+                    if (weight[n13] < weight[heap[n14]]) {\n                         break;\n                     }\n-                    heap[zz2] = heap[yy];\n-                    zz2 = yy;\n+                    heap[n12] = heap[n14];\n+                    n12 = n14;\n                 }\n-                heap[zz2] = tmp2;\n-                ++nNodes;\n-                parent[n1] = (parent[n2] = nNodes);\n-                final int weight_n1 = weight[n1];\n-                final int weight_n2 = weight[n2];\n-                weight[nNodes] = ((weight_n1 & 0xFFFFFF00) + (weight_n2 & 0xFFFFFF00) | 1 + (((weight_n1 & 0xFF) > (weight_n2 & 0xFF)) ? (weight_n1 & 0xFF) : (weight_n2 & 0xFF)));\n-                parent[nNodes] = -1;\n-                ++nHeap;\n-                heap[nHeap] = nNodes;\n-                tmp2 = 0;\n-                zz2 = nHeap;\n-                tmp2 = heap[zz2];\n-                for (int weight_tmp = weight[tmp2]; weight_tmp < weight[heap[zz2 >> 1]]; zz2 >>= 1) {\n-                    heap[zz2] = heap[zz2 >> 1];\n+                heap[n12] = n13;\n+                ++n4;\n+                parent[n7] = (parent[n11] = n4);\n+                final int n15 = weight[n7];\n+                final int n16 = weight[n11];\n+                weight[n4] = ((n15 & 0xFFFFFF00) + (n16 & 0xFFFFFF00) | 1 + (((n15 & 0xFF) > (n16 & 0xFF)) ? (n15 & 0xFF) : (n16 & 0xFF)));\n+                parent[n4] = -1;\n+                ++j;\n+                heap[j] = n4;\n+                int n17;\n+                int n18;\n+                for (n17 = j, n18 = heap[n17]; weight[n18] < weight[heap[n17 >> 1]]; n17 >>= 1) {\n+                    heap[n17] = heap[n17 >> 1];\n                 }\n-                heap[zz2] = tmp2;\n+                heap[n17] = n18;\n             }\n-            for (int j = 1; j <= alphaSize; ++j) {\n-                int k = 0;\n-                int parent_k;\n-                for (int l = j; (parent_k = parent[l]) >= 0; l = parent_k, ++k) {}\n-                len[j - 1] = (byte)k;\n-                if (k > maxLen) {\n-                    tooLong = true;\n+            for (int l = 1; l <= n; ++l) {\n+                int n19 = 0;\n+                int n21;\n+                for (int n20 = l; (n21 = parent[n20]) >= 0; n20 = n21, ++n19) {}\n+                array[l - 1] = (byte)n19;\n+                if (n19 > n2) {\n+                    i = 1;\n                 }\n             }\n-            if (tooLong) {\n-                for (int j = 1; j < alphaSize; ++j) {\n-                    int k = weight[j] >> 8;\n-                    k = 1 + (k >> 1);\n-                    weight[j] = k << 8;\n+            if (i != 0) {\n+                for (int n22 = 1; n22 < n; ++n22) {\n+                    weight[n22] = 1 + (weight[n22] >> 8 >> 1) << 8;\n                 }\n             }\n         }\n     }\n     \n-    public static int chooseBlockSize(final long inputLength) {\n-        return (inputLength > 0L) ? ((int)Math.min(inputLength / 132000L + 1L, 9L)) : 9;\n+    public static int chooseBlockSize(final long n) {\n+        return (n > 0L) ? ((int)Math.min(n / 132000L + 1L, 9L)) : 9;\n     }\n     \n-    public BZip2CompressorOutputStream(final OutputStream out) throws IOException {\n-        this(out, 9);\n+    public BZip2CompressorOutputStream(final OutputStream outputStream) throws IOException {\n+        this(outputStream, 9);\n     }\n     \n-    public BZip2CompressorOutputStream(final OutputStream out, final int blockSize) throws IOException {\n+    public BZip2CompressorOutputStream(final OutputStream out, final int blockSize100k) throws IOException {\n         this.crc = new CRC();\n         this.currentChar = -1;\n         this.runLength = 0;\n-        if (blockSize < 1) {\n-            throw new IllegalArgumentException(\"blockSize(\" + blockSize + \") < 1\");\n+        if (blockSize100k < 1) {\n+            throw new IllegalArgumentException(\"blockSize(\" + blockSize100k + \") < 1\");\n         }\n-        if (blockSize > 9) {\n-            throw new IllegalArgumentException(\"blockSize(\" + blockSize + \") > 9\");\n+        if (blockSize100k > 9) {\n+            throw new IllegalArgumentException(\"blockSize(\" + blockSize100k + \") > 9\");\n         }\n-        this.blockSize100k = blockSize;\n+        this.blockSize100k = blockSize100k;\n         this.out = out;\n         this.allowableBlockSize = this.blockSize100k * 100000 - 20;\n         this.init();\n     }\n     \n-    public void write(final int b) throws IOException {\n+    public void write(final int n) throws IOException {\n         if (!this.closed) {\n-            this.write0(b);\n+            this.write0(n);\n             return;\n         }\n         throw new IOException(\"Closed\");\n     }\n     \n     private void writeRun() throws IOException {\n-        final int lastShadow = this.last;\n-        if (lastShadow < this.allowableBlockSize) {\n-            final int currentCharShadow = this.currentChar;\n-            final BZip2CompressorOutputStream.Data dataShadow = this.data;\n-            dataShadow.inUse[currentCharShadow] = true;\n-            final byte ch = (byte)currentCharShadow;\n-            int runLengthShadow = this.runLength;\n-            this.crc.updateCRC(currentCharShadow, runLengthShadow);\n-            switch (runLengthShadow) {\n+        final int last = this.last;\n+        if (last < this.allowableBlockSize) {\n+            final int currentChar = this.currentChar;\n+            final BZip2CompressorOutputStream.Data data = this.data;\n+            data.inUse[currentChar] = true;\n+            final byte b = (byte)currentChar;\n+            int runLength = this.runLength;\n+            this.crc.updateCRC(currentChar, runLength);\n+            switch (runLength) {\n                 case 1: {\n-                    dataShadow.block[lastShadow + 2] = ch;\n-                    this.last = lastShadow + 1;\n+                    data.block[last + 2] = b;\n+                    this.last = last + 1;\n                     break;\n                 }\n                 case 2: {\n-                    dataShadow.block[lastShadow + 2] = ch;\n-                    dataShadow.block[lastShadow + 3] = ch;\n-                    this.last = lastShadow + 2;\n+                    data.block[last + 2] = b;\n+                    data.block[last + 3] = b;\n+                    this.last = last + 2;\n                     break;\n                 }\n                 case 3: {\n-                    final byte[] block = dataShadow.block;\n-                    block[lastShadow + 2] = ch;\n-                    block[lastShadow + 4] = (block[lastShadow + 3] = ch);\n-                    this.last = lastShadow + 3;\n+                    final byte[] block = data.block;\n+                    block[last + 2] = b;\n+                    block[last + 4] = (block[last + 3] = b);\n+                    this.last = last + 3;\n                     break;\n                 }\n                 default: {\n-                    runLengthShadow -= 4;\n-                    dataShadow.inUse[runLengthShadow] = true;\n-                    final byte[] block = dataShadow.block;\n-                    block[lastShadow + 3] = (block[lastShadow + 2] = ch);\n-                    block[lastShadow + 5] = (block[lastShadow + 4] = ch);\n-                    block[lastShadow + 6] = (byte)runLengthShadow;\n-                    this.last = lastShadow + 5;\n+                    runLength -= 4;\n+                    data.inUse[runLength] = true;\n+                    final byte[] block2 = data.block;\n+                    block2[last + 3] = (block2[last + 2] = b);\n+                    block2[last + 5] = (block2[last + 4] = b);\n+                    block2[last + 6] = (byte)runLength;\n+                    this.last = last + 5;\n                     break;\n                 }\n             }\n         }\n         else {\n             this.endBlock();\n             this.initBlock();\n@@ -235,28 +230,28 @@\n                 this.data = null;\n             }\n         }\n     }\n     \n     public void close() throws IOException {\n         if (!this.closed) {\n-            final OutputStream outShadow = this.out;\n+            final OutputStream out = this.out;\n             try {\n                 this.finish();\n             }\n             finally {\n-                outShadow.close();\n+                out.close();\n             }\n         }\n     }\n     \n     public void flush() throws IOException {\n-        final OutputStream outShadow = this.out;\n-        if (outShadow != null) {\n-            outShadow.flush();\n+        final OutputStream out = this.out;\n+        if (out != null) {\n+            out.flush();\n         }\n     }\n     \n     private void init() throws IOException {\n         this.bsPutUByte(66);\n         this.bsPutUByte(90);\n         this.data = new BZip2CompressorOutputStream.Data(this.blockSize100k);\n@@ -267,17 +262,17 @@\n         this.initBlock();\n     }\n     \n     private void initBlock() {\n         this.crc.initialiseCRC();\n         this.last = -1;\n         final boolean[] inUse = this.data.inUse;\n-        int i = 256;\n-        while (--i >= 0) {\n-            inUse[i] = false;\n+        int n = 256;\n+        while (--n >= 0) {\n+            inUse[n] = false;\n         }\n     }\n     \n     private void endBlock() throws IOException {\n         this.blockCRC = this.crc.getFinalCRC();\n         this.combinedCRC = (this.combinedCRC << 1 | this.combinedCRC >>> 31);\n         this.combinedCRC ^= this.blockCRC;\n@@ -307,546 +302,544 @@\n         this.bsFinishedWithStream();\n     }\n     \n     public final int getBlockSize() {\n         return this.blockSize100k;\n     }\n     \n-    public void write(final byte[] buf, int offs, final int len) throws IOException {\n-        if (offs < 0) {\n-            throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\");\n+    public void write(final byte[] array, int i, final int n) throws IOException {\n+        if (i < 0) {\n+            throw new IndexOutOfBoundsException(\"offs(\" + i + \") < 0.\");\n         }\n-        if (len < 0) {\n-            throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\");\n+        if (n < 0) {\n+            throw new IndexOutOfBoundsException(\"len(\" + n + \") < 0.\");\n         }\n-        if (offs + len > buf.length) {\n-            throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\" + len + \") > buf.length(\" + buf.length + \").\");\n+        if (i + n > array.length) {\n+            throw new IndexOutOfBoundsException(\"offs(\" + i + \") + len(\" + n + \") > buf.length(\" + array.length + \").\");\n         }\n         if (this.closed) {\n             throw new IOException(\"Stream closed\");\n         }\n-        final int hi = offs + len;\n-        while (offs < hi) {\n-            this.write0(buf[offs++]);\n+        while (i < i + n) {\n+            this.write0(array[i++]);\n         }\n     }\n     \n-    private void write0(int b) throws IOException {\n+    private void write0(int currentChar) throws IOException {\n         if (this.currentChar != -1) {\n-            b &= 0xFF;\n-            if (this.currentChar == b) {\n+            currentChar &= 0xFF;\n+            if (this.currentChar == currentChar) {\n                 if (++this.runLength > 254) {\n                     this.writeRun();\n                     this.currentChar = -1;\n                     this.runLength = 0;\n                 }\n             }\n             else {\n                 this.writeRun();\n                 this.runLength = 1;\n-                this.currentChar = b;\n+                this.currentChar = currentChar;\n             }\n         }\n         else {\n-            this.currentChar = (b & 0xFF);\n+            this.currentChar = (currentChar & 0xFF);\n             ++this.runLength;\n         }\n     }\n     \n-    private static void hbAssignCodes(final int[] code, final byte[] length, final int minLen, final int maxLen, final int alphaSize) {\n-        int vec = 0;\n-        for (int n = minLen; n <= maxLen; ++n) {\n-            for (int i = 0; i < alphaSize; ++i) {\n-                if ((length[i] & 0xFF) == n) {\n-                    code[i] = vec;\n-                    ++vec;\n+    private static void hbAssignCodes(final int[] array, final byte[] array2, final int n, final int n2, final int n3) {\n+        int n4 = 0;\n+        for (int i = n; i <= n2; ++i) {\n+            for (int j = 0; j < n3; ++j) {\n+                if ((array2[j] & 0xFF) == i) {\n+                    array[j] = n4;\n+                    ++n4;\n                 }\n             }\n-            vec <<= 1;\n+            n4 <<= 1;\n         }\n     }\n     \n     private void bsFinishedWithStream() throws IOException {\n         while (this.bsLive > 0) {\n-            final int ch = this.bsBuff >> 24;\n-            this.out.write(ch);\n+            this.out.write(this.bsBuff >> 24);\n             this.bsBuff <<= 8;\n             this.bsLive -= 8;\n         }\n     }\n     \n-    private void bsW(final int n, final int v) throws IOException {\n-        final OutputStream outShadow = this.out;\n-        int bsLiveShadow = this.bsLive;\n-        int bsBuffShadow = this.bsBuff;\n-        while (bsLiveShadow >= 8) {\n-            outShadow.write(bsBuffShadow >> 24);\n-            bsBuffShadow <<= 8;\n-            bsLiveShadow -= 8;\n-        }\n-        this.bsBuff = (bsBuffShadow | v << 32 - bsLiveShadow - n);\n-        this.bsLive = bsLiveShadow + n;\n-    }\n-    \n-    private void bsPutUByte(final int c) throws IOException {\n-        this.bsW(8, c);\n-    }\n-    \n-    private void bsPutInt(final int u) throws IOException {\n-        this.bsW(8, u >> 24 & 0xFF);\n-        this.bsW(8, u >> 16 & 0xFF);\n-        this.bsW(8, u >> 8 & 0xFF);\n-        this.bsW(8, u & 0xFF);\n+    private void bsW(final int n, final int n2) throws IOException {\n+        final OutputStream out = this.out;\n+        int i = this.bsLive;\n+        int bsBuff = this.bsBuff;\n+        while (i >= 8) {\n+            out.write(bsBuff >> 24);\n+            bsBuff <<= 8;\n+            i -= 8;\n+        }\n+        this.bsBuff = (bsBuff | n2 << 32 - i - n);\n+        this.bsLive = i + n;\n+    }\n+    \n+    private void bsPutUByte(final int n) throws IOException {\n+        this.bsW(8, n);\n+    }\n+    \n+    private void bsPutInt(final int n) throws IOException {\n+        this.bsW(8, n >> 24 & 0xFF);\n+        this.bsW(8, n >> 16 & 0xFF);\n+        this.bsW(8, n >> 8 & 0xFF);\n+        this.bsW(8, n & 0xFF);\n     }\n     \n     private void sendMTFValues() throws IOException {\n-        final byte[][] len = this.data.sendMTFValues_len;\n-        final int alphaSize = this.nInUse + 2;\n-        int t = 6;\n-        while (--t >= 0) {\n-            final byte[] len_t = len[t];\n-            int v = alphaSize;\n-            while (--v >= 0) {\n-                len_t[v] = 15;\n+        final byte[][] sendMTFValues_len = this.data.sendMTFValues_len;\n+        final int n = this.nInUse + 2;\n+        int n2 = 6;\n+        while (--n2 >= 0) {\n+            final byte[] array = sendMTFValues_len[n2];\n+            int n3 = n;\n+            while (--n3 >= 0) {\n+                array[n3] = 15;\n             }\n         }\n-        final int nGroups = (this.nMTF < 200) ? 2 : ((this.nMTF < 600) ? 3 : ((this.nMTF < 1200) ? 4 : ((this.nMTF < 2400) ? 5 : 6)));\n-        this.sendMTFValues0(nGroups, alphaSize);\n-        final int nSelectors = this.sendMTFValues1(nGroups, alphaSize);\n-        this.sendMTFValues2(nGroups, nSelectors);\n-        this.sendMTFValues3(nGroups, alphaSize);\n+        final int n4 = (this.nMTF < 200) ? 2 : ((this.nMTF < 600) ? 3 : ((this.nMTF < 1200) ? 4 : ((this.nMTF < 2400) ? 5 : 6)));\n+        this.sendMTFValues0(n4, n);\n+        final int sendMTFValues1 = this.sendMTFValues1(n4, n);\n+        this.sendMTFValues2(n4, sendMTFValues1);\n+        this.sendMTFValues3(n4, n);\n         this.sendMTFValues4();\n-        this.sendMTFValues5(nGroups, nSelectors);\n-        this.sendMTFValues6(nGroups, alphaSize);\n+        this.sendMTFValues5(n4, sendMTFValues1);\n+        this.sendMTFValues6(n4, n);\n         this.sendMTFValues7();\n     }\n     \n-    private void sendMTFValues0(final int nGroups, final int alphaSize) {\n-        final byte[][] len = this.data.sendMTFValues_len;\n+    private void sendMTFValues0(final int n, final int n2) {\n+        final byte[][] sendMTFValues_len = this.data.sendMTFValues_len;\n         final int[] mtfFreq = this.data.mtfFreq;\n-        int remF = this.nMTF;\n-        int gs = 0;\n-        for (int nPart = nGroups; nPart > 0; --nPart) {\n-            final int tFreq = remF / nPart;\n-            int ge = gs - 1;\n-            int aFreq = 0;\n-            for (int a = alphaSize - 1; aFreq < tFreq && ge < a; aFreq += mtfFreq[++ge]) {}\n-            if (ge > gs && nPart != nGroups && nPart != 1 && (nGroups - nPart & 0x1) != 0x0) {\n-                aFreq -= mtfFreq[ge--];\n-            }\n-            final byte[] len_np = len[nPart - 1];\n-            int v = alphaSize;\n-            while (--v >= 0) {\n-                if (v >= gs && v <= ge) {\n-                    len_np[v] = 0;\n+        int nmtf = this.nMTF;\n+        int n3 = 0;\n+        for (int i = n; i > 0; --i) {\n+            final int n4 = nmtf / i;\n+            int n5 = n3 - 1;\n+            int n6 = 0;\n+            for (int n7 = n2 - 1; n6 < n4 && n5 < n7; n6 += mtfFreq[++n5]) {}\n+            if (n5 > n3 && i != n && i != 1 && (n - i & 0x1) != 0x0) {\n+                n6 -= mtfFreq[n5--];\n+            }\n+            final byte[] array = sendMTFValues_len[i - 1];\n+            int n8 = n2;\n+            while (--n8 >= 0) {\n+                if (n8 >= n3 && n8 <= n5) {\n+                    array[n8] = 0;\n                 }\n                 else {\n-                    len_np[v] = 15;\n+                    array[n8] = 15;\n                 }\n             }\n-            gs = ge + 1;\n-            remF -= aFreq;\n+            n3 = n5 + 1;\n+            nmtf -= n6;\n         }\n     }\n     \n-    private int sendMTFValues1(final int nGroups, final int alphaSize) {\n-        final BZip2CompressorOutputStream.Data dataShadow = this.data;\n-        final int[][] rfreq = dataShadow.sendMTFValues_rfreq;\n-        final int[] fave = dataShadow.sendMTFValues_fave;\n-        final short[] cost = dataShadow.sendMTFValues_cost;\n-        final char[] sfmap = dataShadow.sfmap;\n-        final byte[] selector = dataShadow.selector;\n-        final byte[][] len = dataShadow.sendMTFValues_len;\n-        final byte[] len_0 = len[0];\n-        final byte[] len_2 = len[1];\n-        final byte[] len_3 = len[2];\n-        final byte[] len_4 = len[3];\n-        final byte[] len_5 = len[4];\n-        final byte[] len_6 = len[5];\n-        final int nMTFShadow = this.nMTF;\n-        int nSelectors = 0;\n-        for (int iter = 0; iter < 4; ++iter) {\n-            int t = nGroups;\n-            while (--t >= 0) {\n-                fave[t] = 0;\n-                final int[] rfreqt = rfreq[t];\n-                int i = alphaSize;\n-                while (--i >= 0) {\n-                    rfreqt[i] = 0;\n-                }\n-            }\n-            nSelectors = 0;\n-            int ge;\n-            for (int gs = 0; gs < this.nMTF; gs = ge + 1) {\n-                ge = Math.min(gs + 50 - 1, nMTFShadow - 1);\n-                if (nGroups == 6) {\n-                    short cost2 = 0;\n-                    short cost3 = 0;\n-                    short cost4 = 0;\n-                    short cost5 = 0;\n-                    short cost6 = 0;\n-                    short cost7 = 0;\n-                    for (int j = gs; j <= ge; ++j) {\n-                        final int icv = sfmap[j];\n-                        cost2 += (short)(len_0[icv] & 0xFF);\n-                        cost3 += (short)(len_2[icv] & 0xFF);\n-                        cost4 += (short)(len_3[icv] & 0xFF);\n-                        cost5 += (short)(len_4[icv] & 0xFF);\n-                        cost6 += (short)(len_5[icv] & 0xFF);\n-                        cost7 += (short)(len_6[icv] & 0xFF);\n-                    }\n-                    cost[0] = cost2;\n-                    cost[1] = cost3;\n-                    cost[2] = cost4;\n-                    cost[3] = cost5;\n-                    cost[4] = cost6;\n-                    cost[5] = cost7;\n+    private int sendMTFValues1(final int n, final int n2) {\n+        final BZip2CompressorOutputStream.Data data = this.data;\n+        final int[][] sendMTFValues_rfreq = data.sendMTFValues_rfreq;\n+        final int[] sendMTFValues_fave = data.sendMTFValues_fave;\n+        final short[] sendMTFValues_cost = data.sendMTFValues_cost;\n+        final char[] sfmap = data.sfmap;\n+        final byte[] selector = data.selector;\n+        final byte[][] sendMTFValues_len = data.sendMTFValues_len;\n+        final byte[] array = sendMTFValues_len[0];\n+        final byte[] array2 = sendMTFValues_len[1];\n+        final byte[] array3 = sendMTFValues_len[2];\n+        final byte[] array4 = sendMTFValues_len[3];\n+        final byte[] array5 = sendMTFValues_len[4];\n+        final byte[] array6 = sendMTFValues_len[5];\n+        final int nmtf = this.nMTF;\n+        int n3 = 0;\n+        for (int i = 0; i < 4; ++i) {\n+            int n4 = n;\n+            while (--n4 >= 0) {\n+                sendMTFValues_fave[n4] = 0;\n+                final int[] array7 = sendMTFValues_rfreq[n4];\n+                int n5 = n2;\n+                while (--n5 >= 0) {\n+                    array7[n5] = 0;\n+                }\n+            }\n+            n3 = 0;\n+            int min;\n+            for (int j = 0; j < this.nMTF; j = min + 1) {\n+                min = Math.min(j + 50 - 1, nmtf - 1);\n+                if (n == 6) {\n+                    short n6 = 0;\n+                    short n7 = 0;\n+                    short n8 = 0;\n+                    short n9 = 0;\n+                    short n10 = 0;\n+                    short n11 = 0;\n+                    for (int k = j; k <= min; ++k) {\n+                        final char c = sfmap[k];\n+                        n6 += (short)(array[c] & 0xFF);\n+                        n7 += (short)(array2[c] & 0xFF);\n+                        n8 += (short)(array3[c] & 0xFF);\n+                        n9 += (short)(array4[c] & 0xFF);\n+                        n10 += (short)(array5[c] & 0xFF);\n+                        n11 += (short)(array6[c] & 0xFF);\n+                    }\n+                    sendMTFValues_cost[0] = n6;\n+                    sendMTFValues_cost[1] = n7;\n+                    sendMTFValues_cost[2] = n8;\n+                    sendMTFValues_cost[3] = n9;\n+                    sendMTFValues_cost[4] = n10;\n+                    sendMTFValues_cost[5] = n11;\n                 }\n                 else {\n-                    int t2 = nGroups;\n-                    while (--t2 >= 0) {\n-                        cost[t2] = 0;\n-                    }\n-                    for (int i = gs; i <= ge; ++i) {\n-                        final int icv2 = sfmap[i];\n-                        int t3 = nGroups;\n-                        while (--t3 >= 0) {\n-                            final short[] array = cost;\n-                            final int n = t3;\n-                            array[n] += (short)(len[t3][icv2] & 0xFF);\n+                    int n12 = n;\n+                    while (--n12 >= 0) {\n+                        sendMTFValues_cost[n12] = 0;\n+                    }\n+                    for (int l = j; l <= min; ++l) {\n+                        final char c2 = sfmap[l];\n+                        int n13 = n;\n+                        while (--n13 >= 0) {\n+                            final short[] array8 = sendMTFValues_cost;\n+                            final int n14 = n13;\n+                            array8[n14] += (short)(sendMTFValues_len[n13][c2] & 0xFF);\n                         }\n                     }\n                 }\n-                int bt = -1;\n-                int t4 = nGroups;\n-                int bc = 999999999;\n-                while (--t4 >= 0) {\n-                    final int cost_t = cost[t4];\n-                    if (cost_t < bc) {\n-                        bc = cost_t;\n-                        bt = t4;\n-                    }\n-                }\n-                final int[] array2 = fave;\n-                final int n2 = bt;\n-                ++array2[n2];\n-                selector[nSelectors] = (byte)bt;\n-                ++nSelectors;\n-                final int[] rfreq_bt = rfreq[bt];\n-                for (int k = gs; k <= ge; ++k) {\n-                    final int[] array3 = rfreq_bt;\n-                    final char c = sfmap[k];\n-                    ++array3[c];\n-                }\n-            }\n-            for (t = 0; t < nGroups; ++t) {\n-                hbMakeCodeLengths(len[t], rfreq[t], this.data, alphaSize, 20);\n-            }\n-        }\n-        return nSelectors;\n-    }\n-    \n-    private void sendMTFValues2(final int nGroups, final int nSelectors) {\n-        final BZip2CompressorOutputStream.Data dataShadow = this.data;\n-        final byte[] pos = dataShadow.sendMTFValues2_pos;\n-        int i = nGroups;\n-        while (--i >= 0) {\n-            pos[i] = (byte)i;\n-        }\n-        for (i = 0; i < nSelectors; ++i) {\n-            byte ll_i;\n-            byte tmp;\n-            int j;\n-            byte tmp2;\n-            for (ll_i = dataShadow.selector[i], tmp = pos[0], j = 0; ll_i != tmp; tmp = pos[j], pos[j] = tmp2) {\n-                ++j;\n-                tmp2 = tmp;\n-            }\n-            pos[0] = tmp;\n-            dataShadow.selectorMtf[i] = (byte)j;\n-        }\n-    }\n-    \n-    private void sendMTFValues3(final int nGroups, final int alphaSize) {\n-        final int[][] code = this.data.sendMTFValues_code;\n-        final byte[][] len = this.data.sendMTFValues_len;\n-        for (int t = 0; t < nGroups; ++t) {\n-            int minLen = 32;\n-            int maxLen = 0;\n-            final byte[] len_t = len[t];\n-            int i = alphaSize;\n-            while (--i >= 0) {\n-                final int l = len_t[i] & 0xFF;\n-                if (l > maxLen) {\n-                    maxLen = l;\n+                int n15 = -1;\n+                int n16 = n;\n+                int n17 = 999999999;\n+                while (--n16 >= 0) {\n+                    final short n18 = sendMTFValues_cost[n16];\n+                    if (n18 < n17) {\n+                        n17 = n18;\n+                        n15 = n16;\n+                    }\n+                }\n+                final int[] array9 = sendMTFValues_fave;\n+                final int n19 = n15;\n+                ++array9[n19];\n+                selector[n3] = (byte)n15;\n+                ++n3;\n+                final int[] array10 = sendMTFValues_rfreq[n15];\n+                for (int n20 = j; n20 <= min; ++n20) {\n+                    final int[] array11 = array10;\n+                    final char c3 = sfmap[n20];\n+                    ++array11[c3];\n+                }\n+            }\n+            for (int n21 = 0; n21 < n; ++n21) {\n+                hbMakeCodeLengths(sendMTFValues_len[n21], sendMTFValues_rfreq[n21], this.data, n2, 20);\n+            }\n+        }\n+        return n3;\n+    }\n+    \n+    private void sendMTFValues2(final int n, final int n2) {\n+        final BZip2CompressorOutputStream.Data data = this.data;\n+        final byte[] sendMTFValues2_pos = data.sendMTFValues2_pos;\n+        int n3 = n;\n+        while (--n3 >= 0) {\n+            sendMTFValues2_pos[n3] = (byte)n3;\n+        }\n+        for (int i = 0; i < n2; ++i) {\n+            byte b;\n+            byte b2;\n+            int n4;\n+            byte b3;\n+            for (b = data.selector[i], b2 = sendMTFValues2_pos[0], n4 = 0; b != b2; b2 = sendMTFValues2_pos[n4], sendMTFValues2_pos[n4] = b3) {\n+                ++n4;\n+                b3 = b2;\n+            }\n+            sendMTFValues2_pos[0] = b2;\n+            data.selectorMtf[i] = (byte)n4;\n+        }\n+    }\n+    \n+    private void sendMTFValues3(final int n, final int n2) {\n+        final int[][] sendMTFValues_code = this.data.sendMTFValues_code;\n+        final byte[][] sendMTFValues_len = this.data.sendMTFValues_len;\n+        for (int i = 0; i < n; ++i) {\n+            int n3 = 32;\n+            int n4 = 0;\n+            final byte[] array = sendMTFValues_len[i];\n+            int n5 = n2;\n+            while (--n5 >= 0) {\n+                final int n6 = array[n5] & 0xFF;\n+                if (n6 > n4) {\n+                    n4 = n6;\n                 }\n-                if (l < minLen) {\n-                    minLen = l;\n+                if (n6 < n3) {\n+                    n3 = n6;\n                 }\n             }\n-            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n+            hbAssignCodes(sendMTFValues_code[i], sendMTFValues_len[i], n3, n4, n2);\n         }\n     }\n     \n     private void sendMTFValues4() throws IOException {\n         final boolean[] inUse = this.data.inUse;\n-        final boolean[] inUse2 = this.data.sentMTFValues4_inUse16;\n-        int i = 16;\n-        while (--i >= 0) {\n-            inUse2[i] = false;\n-            final int i2 = i * 16;\n-            int j = 16;\n-            while (--j >= 0) {\n-                if (inUse[i2 + j]) {\n-                    inUse2[i] = true;\n+        final boolean[] sentMTFValues4_inUse16 = this.data.sentMTFValues4_inUse16;\n+        int n = 16;\n+        while (--n >= 0) {\n+            sentMTFValues4_inUse16[n] = false;\n+            final int n2 = n * 16;\n+            int n3 = 16;\n+            while (--n3 >= 0) {\n+                if (inUse[n2 + n3]) {\n+                    sentMTFValues4_inUse16[n] = true;\n                 }\n             }\n         }\n-        for (i = 0; i < 16; ++i) {\n-            this.bsW(1, inUse2[i] ? 1 : 0);\n-        }\n-        final OutputStream outShadow = this.out;\n-        int bsLiveShadow = this.bsLive;\n-        int bsBuffShadow = this.bsBuff;\n+        for (int i = 0; i < 16; ++i) {\n+            this.bsW(1, sentMTFValues4_inUse16[i] ? 1 : 0);\n+        }\n+        final OutputStream out = this.out;\n+        int j = this.bsLive;\n+        int bsBuff = this.bsBuff;\n         for (int k = 0; k < 16; ++k) {\n-            if (inUse2[k]) {\n-                final int i3 = k * 16;\n+            if (sentMTFValues4_inUse16[k]) {\n+                final int n4 = k * 16;\n                 for (int l = 0; l < 16; ++l) {\n-                    while (bsLiveShadow >= 8) {\n-                        outShadow.write(bsBuffShadow >> 24);\n-                        bsBuffShadow <<= 8;\n-                        bsLiveShadow -= 8;\n+                    while (j >= 8) {\n+                        out.write(bsBuff >> 24);\n+                        bsBuff <<= 8;\n+                        j -= 8;\n                     }\n-                    if (inUse[i3 + l]) {\n-                        bsBuffShadow |= 1 << 32 - bsLiveShadow - 1;\n+                    if (inUse[n4 + l]) {\n+                        bsBuff |= 1 << 32 - j - 1;\n                     }\n-                    ++bsLiveShadow;\n+                    ++j;\n                 }\n             }\n         }\n-        this.bsBuff = bsBuffShadow;\n-        this.bsLive = bsLiveShadow;\n+        this.bsBuff = bsBuff;\n+        this.bsLive = j;\n     }\n     \n-    private void sendMTFValues5(final int nGroups, final int nSelectors) throws IOException {\n-        this.bsW(3, nGroups);\n-        this.bsW(15, nSelectors);\n-        final OutputStream outShadow = this.out;\n+    private void sendMTFValues5(final int n, final int n2) throws IOException {\n+        this.bsW(3, n);\n+        this.bsW(15, n2);\n+        final OutputStream out = this.out;\n         final byte[] selectorMtf = this.data.selectorMtf;\n-        int bsLiveShadow = this.bsLive;\n-        int bsBuffShadow = this.bsBuff;\n-        for (int i = 0; i < nSelectors; ++i) {\n-            for (int j = 0, hj = selectorMtf[i] & 0xFF; j < hj; ++j) {\n-                while (bsLiveShadow >= 8) {\n-                    outShadow.write(bsBuffShadow >> 24);\n-                    bsBuffShadow <<= 8;\n-                    bsLiveShadow -= 8;\n-                }\n-                bsBuffShadow |= 1 << 32 - bsLiveShadow - 1;\n-                ++bsLiveShadow;\n-            }\n-            while (bsLiveShadow >= 8) {\n-                outShadow.write(bsBuffShadow >> 24);\n-                bsBuffShadow <<= 8;\n-                bsLiveShadow -= 8;\n-            }\n-            ++bsLiveShadow;\n-        }\n-        this.bsBuff = bsBuffShadow;\n-        this.bsLive = bsLiveShadow;\n-    }\n-    \n-    private void sendMTFValues6(final int nGroups, final int alphaSize) throws IOException {\n-        final byte[][] len = this.data.sendMTFValues_len;\n-        final OutputStream outShadow = this.out;\n-        int bsLiveShadow = this.bsLive;\n-        int bsBuffShadow = this.bsBuff;\n-        for (final byte[] len_t : len) {\n-            int curr = len_t[0] & 0xFF;\n-            while (bsLiveShadow >= 8) {\n-                outShadow.write(bsBuffShadow >> 24);\n-                bsBuffShadow <<= 8;\n-                bsLiveShadow -= 8;\n-            }\n-            bsBuffShadow |= curr << 32 - bsLiveShadow - 5;\n-            bsLiveShadow += 5;\n-            for (int i = 0; i < alphaSize; ++i) {\n-                int lti;\n-                for (lti = (len_t[i] & 0xFF); curr < lti; ++curr) {\n-                    while (bsLiveShadow >= 8) {\n-                        outShadow.write(bsBuffShadow >> 24);\n-                        bsBuffShadow <<= 8;\n-                        bsLiveShadow -= 8;\n-                    }\n-                    bsBuffShadow |= 2 << 32 - bsLiveShadow - 2;\n-                    bsLiveShadow += 2;\n-                }\n-                while (curr > lti) {\n-                    while (bsLiveShadow >= 8) {\n-                        outShadow.write(bsBuffShadow >> 24);\n-                        bsBuffShadow <<= 8;\n-                        bsLiveShadow -= 8;\n-                    }\n-                    bsBuffShadow |= 3 << 32 - bsLiveShadow - 2;\n-                    bsLiveShadow += 2;\n-                    --curr;\n-                }\n-                while (bsLiveShadow >= 8) {\n-                    outShadow.write(bsBuffShadow >> 24);\n-                    bsBuffShadow <<= 8;\n-                    bsLiveShadow -= 8;\n+        int i = this.bsLive;\n+        int bsBuff = this.bsBuff;\n+        for (int j = 0; j < n2; ++j) {\n+            for (int k = 0; k < (selectorMtf[j] & 0xFF); ++k) {\n+                while (i >= 8) {\n+                    out.write(bsBuff >> 24);\n+                    bsBuff <<= 8;\n+                    i -= 8;\n+                }\n+                bsBuff |= 1 << 32 - i - 1;\n+                ++i;\n+            }\n+            while (i >= 8) {\n+                out.write(bsBuff >> 24);\n+                bsBuff <<= 8;\n+                i -= 8;\n+            }\n+            ++i;\n+        }\n+        this.bsBuff = bsBuff;\n+        this.bsLive = i;\n+    }\n+    \n+    private void sendMTFValues6(final int n, final int n2) throws IOException {\n+        final byte[][] sendMTFValues_len = this.data.sendMTFValues_len;\n+        final OutputStream out = this.out;\n+        int i = this.bsLive;\n+        int bsBuff = this.bsBuff;\n+        for (final byte[] array : sendMTFValues_len) {\n+            int k = array[0] & 0xFF;\n+            while (i >= 8) {\n+                out.write(bsBuff >> 24);\n+                bsBuff <<= 8;\n+                i -= 8;\n+            }\n+            bsBuff |= k << 32 - i - 5;\n+            i += 5;\n+            for (int l = 0; l < n2; ++l) {\n+                int n3;\n+                for (n3 = (array[l] & 0xFF); k < n3; ++k) {\n+                    while (i >= 8) {\n+                        out.write(bsBuff >> 24);\n+                        bsBuff <<= 8;\n+                        i -= 8;\n+                    }\n+                    bsBuff |= 2 << 32 - i - 2;\n+                    i += 2;\n+                }\n+                while (k > n3) {\n+                    while (i >= 8) {\n+                        out.write(bsBuff >> 24);\n+                        bsBuff <<= 8;\n+                        i -= 8;\n+                    }\n+                    bsBuff |= 3 << 32 - i - 2;\n+                    i += 2;\n+                    --k;\n+                }\n+                while (i >= 8) {\n+                    out.write(bsBuff >> 24);\n+                    bsBuff <<= 8;\n+                    i -= 8;\n                 }\n-                ++bsLiveShadow;\n+                ++i;\n             }\n         }\n-        this.bsBuff = bsBuffShadow;\n-        this.bsLive = bsLiveShadow;\n+        this.bsBuff = bsBuff;\n+        this.bsLive = i;\n     }\n     \n     private void sendMTFValues7() throws IOException {\n-        final BZip2CompressorOutputStream.Data dataShadow = this.data;\n-        final byte[][] len = dataShadow.sendMTFValues_len;\n-        final int[][] code = dataShadow.sendMTFValues_code;\n-        final OutputStream outShadow = this.out;\n-        final byte[] selector = dataShadow.selector;\n-        final char[] sfmap = dataShadow.sfmap;\n-        final int nMTFShadow = this.nMTF;\n-        int selCtr = 0;\n-        int bsLiveShadow = this.bsLive;\n-        int bsBuffShadow = this.bsBuff;\n-        int ge;\n-        for (int gs = 0; gs < nMTFShadow; gs = ge + 1, ++selCtr) {\n-            ge = Math.min(gs + 50 - 1, nMTFShadow - 1);\n-            final int selector_selCtr = selector[selCtr] & 0xFF;\n-            final int[] code_selCtr = code[selector_selCtr];\n-            final byte[] len_selCtr = len[selector_selCtr];\n-            while (gs <= ge) {\n-                final int sfmap_i = sfmap[gs];\n-                while (bsLiveShadow >= 8) {\n-                    outShadow.write(bsBuffShadow >> 24);\n-                    bsBuffShadow <<= 8;\n-                    bsLiveShadow -= 8;\n-                }\n-                final int n = len_selCtr[sfmap_i] & 0xFF;\n-                bsBuffShadow |= code_selCtr[sfmap_i] << 32 - bsLiveShadow - n;\n-                bsLiveShadow += n;\n-                ++gs;\n+        final BZip2CompressorOutputStream.Data data = this.data;\n+        final byte[][] sendMTFValues_len = data.sendMTFValues_len;\n+        final int[][] sendMTFValues_code = data.sendMTFValues_code;\n+        final OutputStream out = this.out;\n+        final byte[] selector = data.selector;\n+        final char[] sfmap = data.sfmap;\n+        final int nmtf = this.nMTF;\n+        int n = 0;\n+        int i = this.bsLive;\n+        int bsBuff = this.bsBuff;\n+        int min;\n+        for (int j = 0; j < nmtf; j = min + 1, ++n) {\n+            min = Math.min(j + 50 - 1, nmtf - 1);\n+            final int n2 = selector[n] & 0xFF;\n+            final int[] array = sendMTFValues_code[n2];\n+            final byte[] array2 = sendMTFValues_len[n2];\n+            while (j <= min) {\n+                final char c = sfmap[j];\n+                while (i >= 8) {\n+                    out.write(bsBuff >> 24);\n+                    bsBuff <<= 8;\n+                    i -= 8;\n+                }\n+                final int n3 = array2[c] & 0xFF;\n+                bsBuff |= array[c] << 32 - i - n3;\n+                i += n3;\n+                ++j;\n             }\n         }\n-        this.bsBuff = bsBuffShadow;\n-        this.bsLive = bsLiveShadow;\n+        this.bsBuff = bsBuff;\n+        this.bsLive = i;\n     }\n     \n     private void moveToFrontCodeAndSend() throws IOException {\n         this.bsW(24, this.data.origPtr);\n         this.generateMTFValues();\n         this.sendMTFValues();\n     }\n     \n     private void blockSort() {\n         this.blockSorter.blockSort(this.data, this.last);\n     }\n     \n     private void generateMTFValues() {\n-        final int lastShadow = this.last;\n-        final BZip2CompressorOutputStream.Data dataShadow = this.data;\n-        final boolean[] inUse = dataShadow.inUse;\n-        final byte[] block = dataShadow.block;\n-        final int[] fmap = dataShadow.fmap;\n-        final char[] sfmap = dataShadow.sfmap;\n-        final int[] mtfFreq = dataShadow.mtfFreq;\n-        final byte[] unseqToSeq = dataShadow.unseqToSeq;\n-        final byte[] yy = dataShadow.generateMTFValues_yy;\n-        int nInUseShadow = 0;\n+        final int last = this.last;\n+        final BZip2CompressorOutputStream.Data data = this.data;\n+        final boolean[] inUse = data.inUse;\n+        final byte[] block = data.block;\n+        final int[] fmap = data.fmap;\n+        final char[] sfmap = data.sfmap;\n+        final int[] mtfFreq = data.mtfFreq;\n+        final byte[] unseqToSeq = data.unseqToSeq;\n+        final byte[] generateMTFValues_yy = data.generateMTFValues_yy;\n+        int nInUse = 0;\n         for (int i = 0; i < 256; ++i) {\n             if (inUse[i]) {\n-                unseqToSeq[i] = (byte)nInUseShadow;\n-                ++nInUseShadow;\n+                unseqToSeq[i] = (byte)nInUse;\n+                ++nInUse;\n             }\n         }\n-        this.nInUse = nInUseShadow;\n+        this.nInUse = nInUse;\n         int j;\n-        int eob;\n-        for (eob = (j = nInUseShadow + 1); j >= 0; --j) {\n+        int n;\n+        for (n = (j = nInUse + 1); j >= 0; --j) {\n             mtfFreq[j] = 0;\n         }\n-        j = nInUseShadow;\n-        while (--j >= 0) {\n-            yy[j] = (byte)j;\n-        }\n-        int wr = 0;\n-        int zPend = 0;\n-        for (int k = 0; k <= lastShadow; ++k) {\n-            byte ll_i;\n-            byte tmp;\n-            int l;\n-            byte tmp2;\n-            for (ll_i = unseqToSeq[block[fmap[k]] & 0xFF], tmp = yy[0], l = 0; ll_i != tmp; tmp = yy[l], yy[l] = tmp2) {\n-                ++l;\n-                tmp2 = tmp;\n-            }\n-            yy[0] = tmp;\n-            if (l == 0) {\n-                ++zPend;\n+        int n2 = nInUse;\n+        while (--n2 >= 0) {\n+            generateMTFValues_yy[n2] = (byte)n2;\n+        }\n+        int n3 = 0;\n+        int n4 = 0;\n+        for (int k = 0; k <= last; ++k) {\n+            byte b;\n+            byte b2;\n+            int n5;\n+            byte b3;\n+            for (b = unseqToSeq[block[fmap[k]] & 0xFF], b2 = generateMTFValues_yy[0], n5 = 0; b != b2; b2 = generateMTFValues_yy[n5], generateMTFValues_yy[n5] = b3) {\n+                ++n5;\n+                b3 = b2;\n+            }\n+            generateMTFValues_yy[0] = b2;\n+            if (n5 == 0) {\n+                ++n4;\n             }\n             else {\n-                if (zPend > 0) {\n-                    --zPend;\n+                if (n4 > 0) {\n+                    --n4;\n                     while (true) {\n-                        if ((zPend & 0x1) == 0x0) {\n-                            sfmap[wr] = '\\0';\n-                            ++wr;\n+                        if ((n4 & 0x1) == 0x0) {\n+                            sfmap[n3] = '\\0';\n+                            ++n3;\n                             final int[] array = mtfFreq;\n-                            final int n = 0;\n-                            ++array[n];\n+                            final int n6 = 0;\n+                            ++array[n6];\n                         }\n                         else {\n-                            sfmap[wr] = '\\u0001';\n-                            ++wr;\n+                            sfmap[n3] = '\\u0001';\n+                            ++n3;\n                             final int[] array2 = mtfFreq;\n-                            final int n2 = 1;\n-                            ++array2[n2];\n+                            final int n7 = 1;\n+                            ++array2[n7];\n                         }\n-                        if (zPend < 2) {\n+                        if (n4 < 2) {\n                             break;\n                         }\n-                        zPend = zPend - 2 >> 1;\n+                        n4 = n4 - 2 >> 1;\n                     }\n-                    zPend = 0;\n+                    n4 = 0;\n                 }\n-                sfmap[wr] = (char)(l + 1);\n-                ++wr;\n+                sfmap[n3] = (char)(n5 + 1);\n+                ++n3;\n                 final int[] array3 = mtfFreq;\n-                final int n3 = l + 1;\n-                ++array3[n3];\n+                final int n8 = n5 + 1;\n+                ++array3[n8];\n             }\n         }\n-        if (zPend > 0) {\n-            --zPend;\n+        if (n4 > 0) {\n+            --n4;\n             while (true) {\n-                if ((zPend & 0x1) == 0x0) {\n-                    sfmap[wr] = '\\0';\n-                    ++wr;\n+                if ((n4 & 0x1) == 0x0) {\n+                    sfmap[n3] = '\\0';\n+                    ++n3;\n                     final int[] array4 = mtfFreq;\n-                    final int n4 = 0;\n-                    ++array4[n4];\n+                    final int n9 = 0;\n+                    ++array4[n9];\n                 }\n                 else {\n-                    sfmap[wr] = '\\u0001';\n-                    ++wr;\n+                    sfmap[n3] = '\\u0001';\n+                    ++n3;\n                     final int[] array5 = mtfFreq;\n-                    final int n5 = 1;\n-                    ++array5[n5];\n+                    final int n10 = 1;\n+                    ++array5[n10];\n                 }\n-                if (zPend < 2) {\n+                if (n4 < 2) {\n                     break;\n                 }\n-                zPend = zPend - 2 >> 1;\n+                n4 = n4 - 2 >> 1;\n             }\n         }\n-        sfmap[wr] = (char)eob;\n+        sfmap[n3] = (char)n;\n         final int[] array6 = mtfFreq;\n-        final int n6 = eob;\n-        ++array6[n6];\n-        this.nMTF = wr + 1;\n+        final int n11 = n;\n+        ++array6[n11];\n+        this.nMTF = n3 + 1;\n     }\n }\n"}]}
