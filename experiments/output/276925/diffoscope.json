{"diffoscope-json-version": 1, "source1": "first/XpathUtil.class", "source2": "second/XpathUtil.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,19 +1,18 @@\n \n package com.puppycrawl.tools.checkstyle.utils;\n \n import java.util.stream.Stream;\n-import net.sf.saxon.sxpath.XPathDynamicContext;\n import net.sf.saxon.sxpath.XPathExpression;\n import java.util.Objects;\n import net.sf.saxon.om.Item;\n import net.sf.saxon.sxpath.XPathEvaluator;\n import net.sf.saxon.Configuration;\n-import java.io.IOException;\n import net.sf.saxon.om.NodeInfo;\n+import java.io.IOException;\n import net.sf.saxon.trans.XPathException;\n import com.puppycrawl.tools.checkstyle.api.CheckstyleException;\n import java.util.Locale;\n import java.util.stream.Collector;\n import java.util.stream.Collectors;\n import java.util.function.Function;\n import com.puppycrawl.tools.checkstyle.AstTreeStringPrinter;\n@@ -34,61 +33,52 @@\n     private static final Pattern NEWLINE_TO_TAG;\n     private static final Pattern CARRIAGE_RETURN_TO_TAG;\n     private static final String DELIMITER;\n     \n     private XpathUtil() {\n     }\n     \n-    public static List<AbstractNode> createChildren(final AbstractNode root, final AbstractNode parent, final DetailAST firstChild) {\n-        DetailAST currentChild = firstChild;\n-        final int depth = parent.getDepth() + 1;\n-        final List<AbstractNode> result = new ArrayList<AbstractNode>();\n-        while (currentChild != null) {\n-            final int index = result.size();\n-            final ElementNode child = new ElementNode(root, parent, currentChild, depth, index);\n-            result.add((AbstractNode)child);\n-            currentChild = currentChild.getNextSibling();\n+    public static List<AbstractNode> createChildren(final AbstractNode abstractNode, final AbstractNode abstractNode2, final DetailAST detailAST) {\n+        DetailAST nextSibling = detailAST;\n+        final int n = abstractNode2.getDepth() + 1;\n+        final ArrayList list = new ArrayList();\n+        while (nextSibling != null) {\n+            list.add(new ElementNode(abstractNode, abstractNode2, nextSibling, n, list.size()));\n+            nextSibling = nextSibling.getNextSibling();\n         }\n-        return result;\n+        return list;\n     }\n     \n-    public static boolean supportsTextAttribute(final DetailAST ast) {\n-        return XpathUtil.TOKEN_TYPES_WITH_TEXT_ATTRIBUTE.get(ast.getType());\n+    public static boolean supportsTextAttribute(final DetailAST detailAST) {\n+        return XpathUtil.TOKEN_TYPES_WITH_TEXT_ATTRIBUTE.get(detailAST.getType());\n     }\n     \n-    public static String getTextAttributeValue(final DetailAST ast) {\n-        String text = ast.getText();\n-        if (ast.getType() == 139) {\n-            text = text.substring(1, text.length() - 1);\n+    public static String getTextAttributeValue(final DetailAST detailAST) {\n+        String input = detailAST.getText();\n+        if (detailAST.getType() == 139) {\n+            input = input.substring(1, input.length() - 1);\n         }\n-        text = XpathUtil.CARRIAGE_RETURN_TO_TAG.matcher(text).replaceAll(\"\\\\\\\\r\");\n-        return XpathUtil.NEWLINE_TO_TAG.matcher(text).replaceAll(\"\\\\\\\\n\");\n+        return XpathUtil.NEWLINE_TO_TAG.matcher(XpathUtil.CARRIAGE_RETURN_TO_TAG.matcher(input).replaceAll(\"\\\\\\\\r\")).replaceAll(\"\\\\\\\\n\");\n     }\n     \n-    public static String printXpathBranch(final String xpath, final File file) throws CheckstyleException, IOException {\n+    public static String printXpathBranch(final String s, final File file) throws CheckstyleException, IOException {\n         try {\n-            final RootNode rootNode = new RootNode(JavaParser.parseFile(file, JavaParser.Options.WITH_COMMENTS));\n-            final List<NodeInfo> matchingItems = getXpathItems(xpath, (AbstractNode)rootNode);\n-            return matchingItems.stream().map(item -> ((ElementNode)item).getUnderlyingNode()).map((Function<? super Object, ?>)AstTreeStringPrinter::printBranch).collect((Collector<? super Object, ?, String>)Collectors.joining(XpathUtil.DELIMITER));\n+            return getXpathItems(s, (AbstractNode)new RootNode(JavaParser.parseFile(file, JavaParser.Options.WITH_COMMENTS))).stream().map(nodeInfo -> ((ElementNode)nodeInfo).getUnderlyingNode()).map((Function<? super Object, ?>)AstTreeStringPrinter::printBranch).collect((Collector<? super Object, ?, String>)Collectors.joining(XpathUtil.DELIMITER));\n         }\n         catch (final XPathException ex) {\n-            final String errMsg = String.format(Locale.ROOT, \"Error during evaluation for xpath: %s, file: %s\", xpath, file.getCanonicalPath());\n-            throw new CheckstyleException(errMsg, (Throwable)ex);\n+            throw new CheckstyleException(String.format(Locale.ROOT, \"Error during evaluation for xpath: %s, file: %s\", s, file.getCanonicalPath()), (Throwable)ex);\n         }\n     }\n     \n-    public static List<NodeInfo> getXpathItems(final String xpath, final AbstractNode rootNode) throws XPathException {\n-        final XPathEvaluator xpathEvaluator = new XPathEvaluator(Configuration.newConfiguration());\n-        final XPathExpression xpathExpression = xpathEvaluator.createExpression(xpath);\n-        final XPathDynamicContext xpathDynamicContext = xpathExpression.createDynamicContext((Item)rootNode);\n-        final List<Item> items = xpathExpression.evaluate(xpathDynamicContext);\n-        final Stream<Object> stream = items.stream();\n+    public static List<NodeInfo> getXpathItems(final String s, final AbstractNode abstractNode) throws XPathException {\n+        final XPathExpression expression = new XPathEvaluator(Configuration.newConfiguration()).createExpression(s);\n+        final Stream stream = expression.evaluate(expression.createDynamicContext((Item)abstractNode)).stream();\n         final Class<NodeInfo> obj = NodeInfo.class;\n         Objects.requireNonNull(obj);\n-        return stream.map((Function<? super Object, ?>)obj::cast).collect((Collector<? super Object, ?, List<NodeInfo>>)Collectors.toUnmodifiableList());\n+        return (List<NodeInfo>)stream.map(obj::cast).collect(Collectors.toUnmodifiableList());\n     }\n     \n     static {\n         TOKEN_TYPES_WITH_TEXT_ATTRIBUTE = TokenUtil.asBitSet(new int[] { 58, 139, 138, 141, 137, 142, 140, 205, 183 });\n         NEWLINE_TO_TAG = Pattern.compile(\"\\n\");\n         CARRIAGE_RETURN_TO_TAG = Pattern.compile(\"\\r\");\n         DELIMITER = \"---------\" + System.lineSeparator();\n"}]}
