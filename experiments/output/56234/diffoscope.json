{"diffoscope-json-version": 1, "source1": "first/XMLPropertyListConfiguration.class", "source2": "second/XMLPropertyListConfiguration.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -58,34 +58,35 @@\n         try {\n             this.clearProperty(key);\n             this.addPropertyDirect(key, value);\n         }\n         finally {\n             this.setDetailEvents(true);\n         }\n+        this.setDetailEvents(true);\n     }\n     \n     protected void setPropertyInternal(final String key, final Object value) {\n         if (value instanceof byte[] || value instanceof List) {\n             this.setPropertyDirect(key, value);\n         }\n         else if (value instanceof Object[]) {\n-            this.setPropertyDirect(key, Arrays.asList((Object[])(Object[])value));\n+            this.setPropertyDirect(key, Arrays.asList((Object[])value));\n         }\n         else {\n             super.setPropertyInternal(key, value);\n         }\n     }\n     \n     protected void addPropertyInternal(final String key, final Object value) {\n         if (value instanceof byte[] || value instanceof List) {\n             this.addPropertyDirect(key, value);\n         }\n         else if (value instanceof Object[]) {\n-            this.addPropertyDirect(key, (Object)Arrays.asList((Object[])(Object[])value));\n+            this.addPropertyDirect(key, (Object)Arrays.asList((Object[])value));\n         }\n         else {\n             super.addPropertyInternal(key, value);\n         }\n     }\n     \n     public void initFileLocator(final FileLocator locator) {\n@@ -126,108 +127,110 @@\n         writer.println(\"</plist>\");\n         writer.flush();\n     }\n     \n     private void printNode(final PrintWriter out, final int indentLevel, final ImmutableNode node) {\n         final String padding = StringUtils.repeat(\" \", indentLevel * 4);\n         if (node.getNodeName() != null) {\n-            out.println(padding + \"<key>\" + StringEscapeUtils.escapeXml10(node.getNodeName()) + \"</key>\");\n+            out.println(String.valueOf(padding) + \"<key>\" + StringEscapeUtils.escapeXml10(node.getNodeName()) + \"</key>\");\n         }\n         final List<ImmutableNode> children = node.getChildren();\n         if (!children.isEmpty()) {\n-            out.println(padding + \"<dict>\");\n+            out.println(String.valueOf(padding) + \"<dict>\");\n             final Iterator<ImmutableNode> it = children.iterator();\n             while (it.hasNext()) {\n                 final ImmutableNode child = (ImmutableNode)it.next();\n                 this.printNode(out, indentLevel + 1, child);\n                 if (it.hasNext()) {\n                     out.println();\n                 }\n             }\n-            out.println(padding + \"</dict>\");\n+            out.println(String.valueOf(padding) + \"</dict>\");\n         }\n         else if (node.getValue() == null) {\n-            out.println(padding + \"<dict/>\");\n+            out.println(String.valueOf(padding) + \"<dict/>\");\n         }\n         else {\n             final Object value = node.getValue();\n             this.printValue(out, indentLevel, value);\n         }\n     }\n     \n     private void printValue(final PrintWriter out, final int indentLevel, final Object value) {\n         final String padding = StringUtils.repeat(\" \", indentLevel * 4);\n         if (value instanceof Date) {\n-            synchronized (XMLPropertyListConfiguration.PListNodeBuilder.access$000()) {\n-                out.println(padding + \"<date>\" + XMLPropertyListConfiguration.PListNodeBuilder.access$000().format((Date)value) + \"</date>\");\n+            synchronized (XMLPropertyListConfiguration.PListNodeBuilder.access$2()) {\n+                out.println(String.valueOf(padding) + \"<date>\" + XMLPropertyListConfiguration.PListNodeBuilder.access$2().format((Date)value) + \"</date>\");\n+                monitorexit(XMLPropertyListConfiguration.PListNodeBuilder.access$2());\n+                return;\n             }\n         }\n-        else if (value instanceof Calendar) {\n+        if (value instanceof Calendar) {\n             this.printValue(out, indentLevel, ((Calendar)value).getTime());\n         }\n         else if (value instanceof Number) {\n             if (value instanceof Double || value instanceof Float || value instanceof BigDecimal) {\n-                out.println(padding + \"<real>\" + value.toString() + \"</real>\");\n+                out.println(String.valueOf(padding) + \"<real>\" + value.toString() + \"</real>\");\n             }\n             else {\n-                out.println(padding + \"<integer>\" + value.toString() + \"</integer>\");\n+                out.println(String.valueOf(padding) + \"<integer>\" + value.toString() + \"</integer>\");\n             }\n         }\n         else if (value instanceof Boolean) {\n             if ((boolean)value) {\n-                out.println(padding + \"<true/>\");\n+                out.println(String.valueOf(padding) + \"<true/>\");\n             }\n             else {\n-                out.println(padding + \"<false/>\");\n+                out.println(String.valueOf(padding) + \"<false/>\");\n             }\n         }\n         else if (value instanceof List) {\n-            out.println(padding + \"<array>\");\n+            out.println(String.valueOf(padding) + \"<array>\");\n             for (final Object o : (List)value) {\n                 this.printValue(out, indentLevel + 1, o);\n             }\n-            out.println(padding + \"</array>\");\n+            out.println(String.valueOf(padding) + \"</array>\");\n         }\n         else if (value instanceof HierarchicalConfiguration) {\n             final HierarchicalConfiguration<ImmutableNode> config = (HierarchicalConfiguration<ImmutableNode>)value;\n             this.printNode(out, indentLevel, (ImmutableNode)config.getNodeModel().getNodeHandler().getRootNode());\n         }\n         else if (value instanceof ImmutableConfiguration) {\n-            out.println(padding + \"<dict>\");\n+            out.println(String.valueOf(padding) + \"<dict>\");\n             final ImmutableConfiguration config2 = (ImmutableConfiguration)value;\n             final Iterator<String> it = config2.getKeys();\n             while (it.hasNext()) {\n                 final String key = (String)it.next();\n                 final ImmutableNode node = new ImmutableNode.Builder().name(key).value(config2.getProperty(key)).create();\n                 this.printNode(out, indentLevel + 1, node);\n                 if (it.hasNext()) {\n                     out.println();\n                 }\n             }\n-            out.println(padding + \"</dict>\");\n+            out.println(String.valueOf(padding) + \"</dict>\");\n         }\n         else if (value instanceof Map) {\n             final Map<String, Object> map = transformMap((Map<?, ?>)value);\n             this.printValue(out, indentLevel, new MapConfiguration((Map)map));\n         }\n         else if (value instanceof byte[]) {\n             String base64;\n             try {\n-                base64 = new String(Base64.encodeBase64((byte[])(byte[])value), \"UTF-8\");\n+                base64 = new String(Base64.encodeBase64((byte[])value), \"UTF-8\");\n             }\n             catch (final UnsupportedEncodingException e) {\n                 throw new AssertionError((Object)e);\n             }\n-            out.println(padding + \"<data>\" + StringEscapeUtils.escapeXml10(base64) + \"</data>\");\n+            out.println(String.valueOf(padding) + \"<data>\" + StringEscapeUtils.escapeXml10(base64) + \"</data>\");\n         }\n         else if (value != null) {\n-            out.println(padding + \"<string>\" + StringEscapeUtils.escapeXml10(String.valueOf(value)) + \"</string>\");\n+            out.println(String.valueOf(padding) + \"<string>\" + StringEscapeUtils.escapeXml10(String.valueOf(value)) + \"</string>\");\n         }\n         else {\n-            out.println(padding + \"<string/>\");\n+            out.println(String.valueOf(padding) + \"<string/>\");\n         }\n     }\n     \n     private static Map<String, Object> transformMap(final Map<?, ?> src) {\n         final Map<String, Object> dest = new HashMap<String, Object>();\n         for (final Map.Entry<?, ?> e : src.entrySet()) {\n             if (e.getKey() instanceof String) {\n"}]}
