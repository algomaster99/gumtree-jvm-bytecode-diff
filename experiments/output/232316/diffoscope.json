{"diffoscope-json-version": 1, "source1": "first/NodeTracker.class", "source2": "second/NodeTracker.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -12,134 +12,132 @@\n {\n     private final Map<NodeSelector, NodeTracker.TrackedNodeData> trackedNodes;\n     \n     public NodeTracker() {\n         this(Collections.emptyMap());\n     }\n     \n-    private NodeTracker(final Map<NodeSelector, NodeTracker.TrackedNodeData> map) {\n-        this.trackedNodes = map;\n+    private NodeTracker(final Map<NodeSelector, NodeTracker.TrackedNodeData> trackedNodes) {\n+        this.trackedNodes = trackedNodes;\n     }\n     \n-    public NodeTracker trackNode(final ImmutableNode root, final NodeSelector selector, final NodeKeyResolver<ImmutableNode> resolver, final NodeHandler<ImmutableNode> handler) {\n-        final Map<NodeSelector, NodeTracker.TrackedNodeData> newState = new HashMap<NodeSelector, NodeTracker.TrackedNodeData>(this.trackedNodes);\n-        final NodeTracker.TrackedNodeData trackData = (NodeTracker.TrackedNodeData)newState.get(selector);\n-        newState.put(selector, trackDataForAddedObserver(root, selector, resolver, handler, trackData));\n-        return new NodeTracker(newState);\n-    }\n-    \n-    public NodeTracker trackNodes(final Collection<NodeSelector> selectors, final Collection<ImmutableNode> nodes) {\n-        final Map<NodeSelector, NodeTracker.TrackedNodeData> newState = new HashMap<NodeSelector, NodeTracker.TrackedNodeData>(this.trackedNodes);\n-        final Iterator<ImmutableNode> itNodes = nodes.iterator();\n-        for (final NodeSelector selector : selectors) {\n-            final ImmutableNode node = (ImmutableNode)itNodes.next();\n-            NodeTracker.TrackedNodeData trackData = (NodeTracker.TrackedNodeData)newState.get(selector);\n-            if (trackData == null) {\n-                trackData = new NodeTracker.TrackedNodeData(node);\n+    public NodeTracker trackNode(final ImmutableNode immutableNode, final NodeSelector nodeSelector, final NodeKeyResolver<ImmutableNode> nodeKeyResolver, final NodeHandler<ImmutableNode> nodeHandler) {\n+        final HashMap hashMap = new HashMap((Map<? extends K, ? extends V>)this.trackedNodes);\n+        hashMap.put(nodeSelector, trackDataForAddedObserver(immutableNode, nodeSelector, nodeKeyResolver, nodeHandler, (NodeTracker.TrackedNodeData)hashMap.get(nodeSelector)));\n+        return new NodeTracker(hashMap);\n+    }\n+    \n+    public NodeTracker trackNodes(final Collection<NodeSelector> collection, final Collection<ImmutableNode> collection2) {\n+        final HashMap hashMap = new HashMap((Map<? extends K, ? extends V>)this.trackedNodes);\n+        final Iterator<ImmutableNode> iterator = collection2.iterator();\n+        for (final NodeSelector nodeSelector : collection) {\n+            final ImmutableNode immutableNode = (ImmutableNode)iterator.next();\n+            final NodeTracker.TrackedNodeData trackedNodeData = (NodeTracker.TrackedNodeData)hashMap.get(nodeSelector);\n+            NodeTracker.TrackedNodeData observerAdded;\n+            if (trackedNodeData == null) {\n+                observerAdded = new NodeTracker.TrackedNodeData(immutableNode);\n             }\n             else {\n-                trackData = trackData.observerAdded();\n+                observerAdded = trackedNodeData.observerAdded();\n             }\n-            newState.put(selector, trackData);\n+            hashMap.put(nodeSelector, observerAdded);\n         }\n-        return new NodeTracker(newState);\n+        return new NodeTracker(hashMap);\n     }\n     \n-    public NodeTracker untrackNode(final NodeSelector selector) {\n-        final NodeTracker.TrackedNodeData trackData = this.getTrackedNodeData(selector);\n-        final Map<NodeSelector, NodeTracker.TrackedNodeData> newState = new HashMap<NodeSelector, NodeTracker.TrackedNodeData>(this.trackedNodes);\n-        final NodeTracker.TrackedNodeData newTrackData = trackData.observerRemoved();\n-        if (newTrackData == null) {\n-            newState.remove(selector);\n+    public NodeTracker untrackNode(final NodeSelector nodeSelector) {\n+        final NodeTracker.TrackedNodeData trackedNodeData = this.getTrackedNodeData(nodeSelector);\n+        final HashMap hashMap = new HashMap((Map<? extends K, ? extends V>)this.trackedNodes);\n+        final NodeTracker.TrackedNodeData observerRemoved = trackedNodeData.observerRemoved();\n+        if (observerRemoved == null) {\n+            hashMap.remove(nodeSelector);\n         }\n         else {\n-            newState.put(selector, newTrackData);\n+            hashMap.put(nodeSelector, observerRemoved);\n         }\n-        return new NodeTracker(newState);\n+        return new NodeTracker(hashMap);\n     }\n     \n-    public ImmutableNode getTrackedNode(final NodeSelector selector) {\n-        return this.getTrackedNodeData(selector).getNode();\n+    public ImmutableNode getTrackedNode(final NodeSelector nodeSelector) {\n+        return this.getTrackedNodeData(nodeSelector).getNode();\n     }\n     \n-    public boolean isTrackedNodeDetached(final NodeSelector selector) {\n-        return this.getTrackedNodeData(selector).isDetached();\n+    public boolean isTrackedNodeDetached(final NodeSelector nodeSelector) {\n+        return this.getTrackedNodeData(nodeSelector).isDetached();\n     }\n     \n-    public InMemoryNodeModel getDetachedNodeModel(final NodeSelector selector) {\n-        return this.getTrackedNodeData(selector).getDetachedModel();\n+    public InMemoryNodeModel getDetachedNodeModel(final NodeSelector nodeSelector) {\n+        return this.getTrackedNodeData(nodeSelector).getDetachedModel();\n     }\n     \n-    public NodeTracker update(final ImmutableNode root, final NodeSelector txTarget, final NodeKeyResolver<ImmutableNode> resolver, final NodeHandler<ImmutableNode> handler) {\n+    public NodeTracker update(final ImmutableNode immutableNode, final NodeSelector nodeSelector, final NodeKeyResolver<ImmutableNode> nodeKeyResolver, final NodeHandler<ImmutableNode> nodeHandler) {\n         if (this.trackedNodes.isEmpty()) {\n             return this;\n         }\n-        final Map<NodeSelector, NodeTracker.TrackedNodeData> newState = new HashMap<NodeSelector, NodeTracker.TrackedNodeData>();\n-        for (final Map.Entry<NodeSelector, NodeTracker.TrackedNodeData> e : this.trackedNodes.entrySet()) {\n-            newState.put(e.getKey(), determineUpdatedTrackedNodeData(root, txTarget, resolver, handler, e));\n+        final HashMap hashMap = new HashMap();\n+        for (final Map.Entry entry : this.trackedNodes.entrySet()) {\n+            hashMap.put(entry.getKey(), determineUpdatedTrackedNodeData(immutableNode, nodeSelector, nodeKeyResolver, nodeHandler, entry));\n         }\n-        return new NodeTracker(newState);\n+        return new NodeTracker(hashMap);\n     }\n     \n     public NodeTracker detachAllTrackedNodes() {\n         if (this.trackedNodes.isEmpty()) {\n             return this;\n         }\n-        final Map<NodeSelector, NodeTracker.TrackedNodeData> newState = new HashMap<NodeSelector, NodeTracker.TrackedNodeData>();\n-        for (final Map.Entry<NodeSelector, NodeTracker.TrackedNodeData> e : this.trackedNodes.entrySet()) {\n-            final NodeTracker.TrackedNodeData newData = ((NodeTracker.TrackedNodeData)e.getValue()).isDetached() ? ((NodeTracker.TrackedNodeData)e.getValue()) : ((NodeTracker.TrackedNodeData)e.getValue()).detach((ImmutableNode)null);\n-            newState.put(e.getKey(), newData);\n+        final HashMap hashMap = new HashMap();\n+        for (final Map.Entry entry : this.trackedNodes.entrySet()) {\n+            hashMap.put(entry.getKey(), ((NodeTracker.TrackedNodeData)entry.getValue()).isDetached() ? ((Object)entry.getValue()) : ((NodeTracker.TrackedNodeData)entry.getValue()).detach((ImmutableNode)null));\n         }\n-        return new NodeTracker(newState);\n+        return new NodeTracker(hashMap);\n     }\n     \n-    public NodeTracker replaceAndDetachTrackedNode(final NodeSelector selector, final ImmutableNode newNode) {\n-        final Map<NodeSelector, NodeTracker.TrackedNodeData> newState = new HashMap<NodeSelector, NodeTracker.TrackedNodeData>(this.trackedNodes);\n-        newState.put(selector, this.getTrackedNodeData(selector).detach(newNode));\n-        return new NodeTracker(newState);\n+    public NodeTracker replaceAndDetachTrackedNode(final NodeSelector nodeSelector, final ImmutableNode immutableNode) {\n+        final HashMap hashMap = new HashMap((Map<? extends K, ? extends V>)this.trackedNodes);\n+        hashMap.put(nodeSelector, this.getTrackedNodeData(nodeSelector).detach(immutableNode));\n+        return new NodeTracker(hashMap);\n     }\n     \n-    private NodeTracker.TrackedNodeData getTrackedNodeData(final NodeSelector selector) {\n-        final NodeTracker.TrackedNodeData trackData = (NodeTracker.TrackedNodeData)this.trackedNodes.get(selector);\n-        if (trackData == null) {\n-            throw new ConfigurationRuntimeException(\"No tracked node found: \" + selector);\n+    private NodeTracker.TrackedNodeData getTrackedNodeData(final NodeSelector obj) {\n+        final NodeTracker.TrackedNodeData trackedNodeData = (NodeTracker.TrackedNodeData)this.trackedNodes.get(obj);\n+        if (trackedNodeData == null) {\n+            throw new ConfigurationRuntimeException(\"No tracked node found: \" + obj);\n         }\n-        return trackData;\n+        return trackedNodeData;\n     }\n     \n-    private static NodeTracker.TrackedNodeData determineUpdatedTrackedNodeData(final ImmutableNode root, final NodeSelector txTarget, final NodeKeyResolver<ImmutableNode> resolver, final NodeHandler<ImmutableNode> handler, final Map.Entry<NodeSelector, NodeTracker.TrackedNodeData> e) {\n-        if (((NodeTracker.TrackedNodeData)e.getValue()).isDetached()) {\n-            return e.getValue();\n+    private static NodeTracker.TrackedNodeData determineUpdatedTrackedNodeData(final ImmutableNode immutableNode, final NodeSelector nodeSelector, final NodeKeyResolver<ImmutableNode> nodeKeyResolver, final NodeHandler<ImmutableNode> nodeHandler, final Map.Entry<NodeSelector, NodeTracker.TrackedNodeData> entry) {\n+        if (((NodeTracker.TrackedNodeData)entry.getValue()).isDetached()) {\n+            return entry.getValue();\n         }\n-        ImmutableNode newTarget;\n+        ImmutableNode select;\n         try {\n-            newTarget = ((NodeSelector)e.getKey()).select(root, (NodeKeyResolver)resolver, (NodeHandler)handler);\n+            select = ((NodeSelector)entry.getKey()).select(immutableNode, (NodeKeyResolver)nodeKeyResolver, (NodeHandler)nodeHandler);\n         }\n         catch (final Exception ex) {\n-            newTarget = null;\n+            select = null;\n         }\n-        if (newTarget == null) {\n-            return detachedTrackedNodeData(txTarget, e);\n+        if (select == null) {\n+            return detachedTrackedNodeData(nodeSelector, entry);\n         }\n-        return ((NodeTracker.TrackedNodeData)e.getValue()).updateNode(newTarget);\n+        return ((NodeTracker.TrackedNodeData)entry.getValue()).updateNode(select);\n     }\n     \n-    private static NodeTracker.TrackedNodeData detachedTrackedNodeData(final NodeSelector txTarget, final Map.Entry<NodeSelector, NodeTracker.TrackedNodeData> e) {\n-        final ImmutableNode newNode = ((NodeSelector)e.getKey()).equals((Object)txTarget) ? createEmptyTrackedNode(e.getValue()) : null;\n-        return ((NodeTracker.TrackedNodeData)e.getValue()).detach(newNode);\n+    private static NodeTracker.TrackedNodeData detachedTrackedNodeData(final NodeSelector nodeSelector, final Map.Entry<NodeSelector, NodeTracker.TrackedNodeData> entry) {\n+        return ((NodeTracker.TrackedNodeData)entry.getValue()).detach(((NodeSelector)entry.getKey()).equals((Object)nodeSelector) ? createEmptyTrackedNode(entry.getValue()) : null);\n     }\n     \n-    private static ImmutableNode createEmptyTrackedNode(final NodeTracker.TrackedNodeData data) {\n-        return new ImmutableNode.Builder().name(data.getNode().getNodeName()).create();\n+    private static ImmutableNode createEmptyTrackedNode(final NodeTracker.TrackedNodeData trackedNodeData) {\n+        return new ImmutableNode.Builder().name(trackedNodeData.getNode().getNodeName()).create();\n     }\n     \n-    private static NodeTracker.TrackedNodeData trackDataForAddedObserver(final ImmutableNode root, final NodeSelector selector, final NodeKeyResolver<ImmutableNode> resolver, final NodeHandler<ImmutableNode> handler, final NodeTracker.TrackedNodeData trackData) {\n-        if (trackData != null) {\n-            return trackData.observerAdded();\n+    private static NodeTracker.TrackedNodeData trackDataForAddedObserver(final ImmutableNode immutableNode, final NodeSelector obj, final NodeKeyResolver<ImmutableNode> nodeKeyResolver, final NodeHandler<ImmutableNode> nodeHandler, final NodeTracker.TrackedNodeData trackedNodeData) {\n+        if (trackedNodeData != null) {\n+            return trackedNodeData.observerAdded();\n         }\n-        final ImmutableNode target = selector.select(root, (NodeKeyResolver)resolver, (NodeHandler)handler);\n-        if (target == null) {\n-            throw new ConfigurationRuntimeException(\"Selector does not select unique node: \" + selector);\n+        final ImmutableNode select = obj.select(immutableNode, (NodeKeyResolver)nodeKeyResolver, (NodeHandler)nodeHandler);\n+        if (select == null) {\n+            throw new ConfigurationRuntimeException(\"Selector does not select unique node: \" + obj);\n         }\n-        return new NodeTracker.TrackedNodeData(target);\n+        return new NodeTracker.TrackedNodeData(select);\n     }\n }\n"}]}
