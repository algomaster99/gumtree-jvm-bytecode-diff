{"diffoscope-json-version": 1, "source1": "first/AbstractJavadocCheck.class", "source2": "second/AbstractJavadocCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -37,74 +37,72 @@\n     \n     public abstract int[] getDefaultJavadocTokens();\n     \n     public abstract void visitJavadocToken(final DetailNode p0);\n     \n     public int[] getAcceptableJavadocTokens() {\n         final int[] defaultJavadocTokens = this.getDefaultJavadocTokens();\n-        final int[] copy = new int[defaultJavadocTokens.length];\n-        System.arraycopy(defaultJavadocTokens, 0, copy, 0, defaultJavadocTokens.length);\n-        return copy;\n+        final int[] array = new int[defaultJavadocTokens.length];\n+        System.arraycopy(defaultJavadocTokens, 0, array, 0, defaultJavadocTokens.length);\n+        return array;\n     }\n     \n     public int[] getRequiredJavadocTokens() {\n         return CommonUtil.EMPTY_INT_ARRAY;\n     }\n     \n     public boolean acceptJavadocWithNonTightHtml() {\n         return true;\n     }\n     \n-    public final void setViolateExecutionOnNonTightHtml(final boolean shouldReportViolation) {\n-        this.violateExecutionOnNonTightHtml = shouldReportViolation;\n+    public final void setViolateExecutionOnNonTightHtml(final boolean violateExecutionOnNonTightHtml) {\n+        this.violateExecutionOnNonTightHtml = violateExecutionOnNonTightHtml;\n     }\n     \n-    public final void setJavadocTokens(final String... strRep) {\n-        for (final String str : strRep) {\n-            this.javadocTokens.add(Integer.valueOf(JavadocUtil.getTokenId(str)));\n+    public final void setJavadocTokens(final String... array) {\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            this.javadocTokens.add(Integer.valueOf(JavadocUtil.getTokenId(array[i])));\n         }\n     }\n     \n     public void init() {\n         this.validateDefaultJavadocTokens();\n         if (this.javadocTokens.isEmpty()) {\n             this.javadocTokens.addAll(Arrays.stream(this.getDefaultJavadocTokens()).boxed().collect((Collector<? super Integer, ?, Collection<? extends Integer>>)Collectors.toList()));\n         }\n         else {\n             final int[] acceptableJavadocTokens = this.getAcceptableJavadocTokens();\n             Arrays.sort(acceptableJavadocTokens);\n-            for (final Integer javadocTokenId : this.javadocTokens) {\n-                if (Arrays.binarySearch(acceptableJavadocTokens, javadocTokenId) < 0) {\n-                    final String message = String.format(Locale.ROOT, \"Javadoc Token \\\"%s\\\" was not found in Acceptable javadoc tokens list in check %s\", JavadocUtil.getTokenName((int)javadocTokenId), this.getClass().getName());\n-                    throw new IllegalStateException(message);\n+            for (final Integer n : this.javadocTokens) {\n+                if (Arrays.binarySearch(acceptableJavadocTokens, n) < 0) {\n+                    throw new IllegalStateException(String.format(Locale.ROOT, \"Javadoc Token \\\"%s\\\" was not found in Acceptable javadoc tokens list in check %s\", JavadocUtil.getTokenName((int)n), this.getClass().getName()));\n                 }\n             }\n         }\n     }\n     \n     private void validateDefaultJavadocTokens() {\n         if (this.getRequiredJavadocTokens().length != 0) {\n             final int[] defaultJavadocTokens = this.getDefaultJavadocTokens();\n             Arrays.sort(defaultJavadocTokens);\n-            for (final int javadocToken : this.getRequiredJavadocTokens()) {\n-                if (Arrays.binarySearch(defaultJavadocTokens, javadocToken) < 0) {\n-                    final String message = String.format(Locale.ROOT, \"Javadoc Token \\\"%s\\\" from required javadoc tokens was not found in default javadoc tokens list in check %s\", Integer.valueOf(javadocToken), this.getClass().getName());\n-                    throw new IllegalStateException(message);\n+            for (final int n : this.getRequiredJavadocTokens()) {\n+                if (Arrays.binarySearch(defaultJavadocTokens, n) < 0) {\n+                    throw new IllegalStateException(String.format(Locale.ROOT, \"Javadoc Token \\\"%s\\\" from required javadoc tokens was not found in default javadoc tokens list in check %s\", Integer.valueOf(n), this.getClass().getName()));\n                 }\n             }\n         }\n     }\n     \n-    public void beginJavadocTree(final DetailNode rootAst) {\n+    public void beginJavadocTree(final DetailNode detailNode) {\n     }\n     \n-    public void finishJavadocTree(final DetailNode rootAst) {\n+    public void finishJavadocTree(final DetailNode detailNode) {\n     }\n     \n-    public void leaveJavadocToken(final DetailNode ast) {\n+    public void leaveJavadocToken(final DetailNode detailNode) {\n     }\n     \n     public final int[] getDefaultTokens() {\n         return this.getRequiredTokens();\n     }\n     \n     public final int[] getAcceptableTokens() {\n@@ -115,77 +113,76 @@\n         return new int[] { 145 };\n     }\n     \n     public final boolean isCommentNodesRequired() {\n         return true;\n     }\n     \n-    public final void beginTree(final DetailAST rootAST) {\n+    public final void beginTree(final DetailAST detailAST) {\n         ((Map)AbstractJavadocCheck.TREE_CACHE.get()).clear();\n     }\n     \n-    public final void finishTree(final DetailAST rootAST) {\n+    public final void finishTree(final DetailAST detailAST) {\n     }\n     \n-    public final void visitToken(final DetailAST blockCommentNode) {\n-        if (JavadocUtil.isJavadocComment(blockCommentNode)) {\n-            ((AbstractJavadocCheck.FileContext)this.context.get()).blockCommentAst = blockCommentNode;\n-            final LineColumn treeCacheKey = new LineColumn(blockCommentNode.getLineNo(), blockCommentNode.getColumnNo());\n-            final JavadocDetailNodeParser.ParseStatus result = (JavadocDetailNodeParser.ParseStatus)((Map<LineColumn, JavadocDetailNodeParser.ParseStatus>)AbstractJavadocCheck.TREE_CACHE.get()).computeIfAbsent(treeCacheKey, key -> ((AbstractJavadocCheck.FileContext)this.context.get()).parser.parseJavadocAsDetailNode(blockCommentNode));\n-            if (result.getParseErrorMessage() == null) {\n-                if (this.acceptJavadocWithNonTightHtml() || !result.isNonTight()) {\n-                    this.processTree(result.getTree());\n+    public final void visitToken(final DetailAST blockCommentAst) {\n+        if (JavadocUtil.isJavadocComment(blockCommentAst)) {\n+            ((AbstractJavadocCheck.FileContext)this.context.get()).blockCommentAst = blockCommentAst;\n+            final JavadocDetailNodeParser.ParseStatus parseStatus = (JavadocDetailNodeParser.ParseStatus)((Map<LineColumn, JavadocDetailNodeParser.ParseStatus>)AbstractJavadocCheck.TREE_CACHE.get()).computeIfAbsent(new LineColumn(blockCommentAst.getLineNo(), blockCommentAst.getColumnNo()), p1 -> ((AbstractJavadocCheck.FileContext)this.context.get()).parser.parseJavadocAsDetailNode(detailAST));\n+            if (parseStatus.getParseErrorMessage() == null) {\n+                if (this.acceptJavadocWithNonTightHtml() || !parseStatus.isNonTight()) {\n+                    this.processTree(parseStatus.getTree());\n                 }\n-                if (this.violateExecutionOnNonTightHtml && result.isNonTight()) {\n-                    this.log(result.getFirstNonTightHtmlTag().getLine(), \"javadoc.unclosedHtml\", new Object[] { result.getFirstNonTightHtmlTag().getText() });\n+                if (this.violateExecutionOnNonTightHtml && parseStatus.isNonTight()) {\n+                    this.log(parseStatus.getFirstNonTightHtmlTag().getLine(), \"javadoc.unclosedHtml\", new Object[] { parseStatus.getFirstNonTightHtmlTag().getText() });\n                 }\n             }\n             else {\n-                final JavadocDetailNodeParser.ParseErrorMessage parseErrorMessage = result.getParseErrorMessage();\n+                final JavadocDetailNodeParser.ParseErrorMessage parseErrorMessage = parseStatus.getParseErrorMessage();\n                 this.log(parseErrorMessage.getLineNumber(), parseErrorMessage.getMessageKey(), parseErrorMessage.getMessageArguments());\n             }\n         }\n     }\n     \n     protected DetailAST getBlockCommentAst() {\n         return ((AbstractJavadocCheck.FileContext)this.context.get()).blockCommentAst;\n     }\n     \n-    private void processTree(final DetailNode root) {\n-        this.beginJavadocTree(root);\n-        this.walk(root);\n-        this.finishJavadocTree(root);\n-    }\n-    \n-    private void walk(final DetailNode root) {\n-        DetailNode toVisit;\n-        for (DetailNode curNode = root; curNode != null; curNode = toVisit) {\n-            boolean waitsForProcessing = this.shouldBeProcessed(curNode);\n-            if (waitsForProcessing) {\n-                this.visitJavadocToken(curNode);\n-            }\n-            toVisit = JavadocUtil.getFirstChild(curNode);\n-            while (curNode != null && toVisit == null) {\n-                if (waitsForProcessing) {\n-                    this.leaveJavadocToken(curNode);\n-                }\n-                toVisit = JavadocUtil.getNextSibling(curNode);\n-                if (toVisit == null) {\n-                    curNode = curNode.getParent();\n-                    if (curNode == null) {\n+    private void processTree(final DetailNode detailNode) {\n+        this.beginJavadocTree(detailNode);\n+        this.walk(detailNode);\n+        this.finishJavadocTree(detailNode);\n+    }\n+    \n+    private void walk(final DetailNode detailNode) {\n+        DetailNode detailNode2;\n+        for (DetailNode parent = detailNode; parent != null; parent = detailNode2) {\n+            boolean b = this.shouldBeProcessed(parent);\n+            if (b) {\n+                this.visitJavadocToken(parent);\n+            }\n+            detailNode2 = JavadocUtil.getFirstChild(parent);\n+            while (parent != null && detailNode2 == null) {\n+                if (b) {\n+                    this.leaveJavadocToken(parent);\n+                }\n+                detailNode2 = JavadocUtil.getNextSibling(parent);\n+                if (detailNode2 == null) {\n+                    parent = parent.getParent();\n+                    if (parent == null) {\n                         continue;\n                     }\n-                    waitsForProcessing = this.shouldBeProcessed(curNode);\n+                    b = this.shouldBeProcessed(parent);\n                 }\n             }\n         }\n     }\n     \n-    private boolean shouldBeProcessed(final DetailNode curNode) {\n-        return this.javadocTokens.contains(Integer.valueOf(curNode.getType()));\n+    private boolean shouldBeProcessed(final DetailNode detailNode) {\n+        return this.javadocTokens.contains(Integer.valueOf(detailNode.getType()));\n     }\n     \n     public void destroy() {\n         super.destroy();\n         this.context.remove();\n         AbstractJavadocCheck.TREE_CACHE.remove();\n     }\n"}]}
