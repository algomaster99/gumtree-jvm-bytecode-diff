{"diffoscope-json-version": 1, "source1": "first/WhitespaceAroundCheck.class", "source2": "second/WhitespaceAroundCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -31,150 +31,149 @@\n         return new int[] { 80, 29, 114, 106, 112, 108, 124, 104, 113, 107, 82, 127, 101, 175, 116, 120, 118, 181, 111, 72, 119, 96, 85, 92, 97, 91, 83, 88, 89, 67, 95, 84, 110, 117, 126, 99, 128, 102, 115, 125, 98, 109, 73, 122, 7, 105, 123, 103, 60, 100, 151, 174, 167, 172, 173, 171 };\n     }\n     \n     public int[] getRequiredTokens() {\n         return CommonUtil.EMPTY_INT_ARRAY;\n     }\n     \n-    public void setAllowEmptyMethods(final boolean allow) {\n-        this.allowEmptyMethods = allow;\n+    public void setAllowEmptyMethods(final boolean allowEmptyMethods) {\n+        this.allowEmptyMethods = allowEmptyMethods;\n     }\n     \n-    public void setAllowEmptyConstructors(final boolean allow) {\n-        this.allowEmptyConstructors = allow;\n+    public void setAllowEmptyConstructors(final boolean allowEmptyConstructors) {\n+        this.allowEmptyConstructors = allowEmptyConstructors;\n     }\n     \n-    public void setIgnoreEnhancedForColon(final boolean ignore) {\n-        this.ignoreEnhancedForColon = ignore;\n+    public void setIgnoreEnhancedForColon(final boolean ignoreEnhancedForColon) {\n+        this.ignoreEnhancedForColon = ignoreEnhancedForColon;\n     }\n     \n-    public void setAllowEmptyTypes(final boolean allow) {\n-        this.allowEmptyTypes = allow;\n+    public void setAllowEmptyTypes(final boolean allowEmptyTypes) {\n+        this.allowEmptyTypes = allowEmptyTypes;\n     }\n     \n-    public void setAllowEmptyLoops(final boolean allow) {\n-        this.allowEmptyLoops = allow;\n+    public void setAllowEmptyLoops(final boolean allowEmptyLoops) {\n+        this.allowEmptyLoops = allowEmptyLoops;\n     }\n     \n-    public void setAllowEmptyLambdas(final boolean allow) {\n-        this.allowEmptyLambdas = allow;\n+    public void setAllowEmptyLambdas(final boolean allowEmptyLambdas) {\n+        this.allowEmptyLambdas = allowEmptyLambdas;\n     }\n     \n-    public void setAllowEmptyCatches(final boolean allow) {\n-        this.allowEmptyCatches = allow;\n+    public void setAllowEmptyCatches(final boolean allowEmptyCatches) {\n+        this.allowEmptyCatches = allowEmptyCatches;\n     }\n     \n-    public void visitToken(final DetailAST ast) {\n-        final int currentType = ast.getType();\n-        if (!this.isNotRelevantSituation(ast, currentType)) {\n-            final int[] line = this.getLineCodePoints(ast.getLineNo() - 1);\n-            final int before = ast.getColumnNo() - 1;\n-            final int after = ast.getColumnNo() + ast.getText().length();\n-            if (before >= 0 && shouldCheckSeparationFromPreviousToken(ast) && !CommonUtil.isCodePointWhitespace(line, before)) {\n-                this.log(ast, \"ws.notPreceded\", new Object[] { ast.getText() });\n+    public void visitToken(final DetailAST detailAST) {\n+        if (!this.isNotRelevantSituation(detailAST, detailAST.getType())) {\n+            final int[] lineCodePoints = this.getLineCodePoints(detailAST.getLineNo() - 1);\n+            final int n = detailAST.getColumnNo() - 1;\n+            final int n2 = detailAST.getColumnNo() + detailAST.getText().length();\n+            if (n >= 0 && shouldCheckSeparationFromPreviousToken(detailAST) && !CommonUtil.isCodePointWhitespace(lineCodePoints, n)) {\n+                this.log(detailAST, \"ws.notPreceded\", new Object[] { detailAST.getText() });\n             }\n-            if (after < line.length) {\n-                final char nextChar = Character.toChars(line[after])[0];\n-                if (this.shouldCheckSeparationFromNextToken(ast, nextChar) && !Character.isWhitespace(nextChar)) {\n-                    this.log(ast, \"ws.notFollowed\", new Object[] { ast.getText() });\n+            if (n2 < lineCodePoints.length) {\n+                final char ch = Character.toChars(lineCodePoints[n2])[0];\n+                if (this.shouldCheckSeparationFromNextToken(detailAST, ch) && !Character.isWhitespace(ch)) {\n+                    this.log(detailAST, \"ws.notFollowed\", new Object[] { detailAST.getText() });\n                 }\n             }\n         }\n     }\n     \n-    private boolean isNotRelevantSituation(final DetailAST ast, final int currentType) {\n-        final int parentType = ast.getParent().getType();\n-        final boolean starImport = currentType == 60 && parentType == 59;\n-        final boolean insideCaseGroup = parentType == 33;\n-        final boolean starImportOrSlistInsideCaseGroup = starImport || insideCaseGroup;\n-        final boolean colonOfCaseOrDefaultOrForEach = isColonOfCaseOrDefault(parentType) || this.isColonOfForEach(parentType);\n-        final boolean emptyBlockOrType = this.isEmptyBlock(ast, parentType) || (this.allowEmptyTypes && isEmptyType(ast));\n-        return starImportOrSlistInsideCaseGroup || colonOfCaseOrDefaultOrForEach || emptyBlockOrType || isArrayInitialization(currentType, parentType);\n+    private boolean isNotRelevantSituation(final DetailAST detailAST, final int n) {\n+        final int type = detailAST.getParent().getType();\n+        final boolean b = n == 60 && type == 59;\n+        final boolean b2 = type == 33;\n+        final boolean b3 = b || b2;\n+        final boolean b4 = isColonOfCaseOrDefault(type) || this.isColonOfForEach(type);\n+        final boolean b5 = this.isEmptyBlock(detailAST, type) || (this.allowEmptyTypes && isEmptyType(detailAST));\n+        return b3 || b4 || b5 || isArrayInitialization(n, type);\n     }\n     \n-    private static boolean shouldCheckSeparationFromPreviousToken(final DetailAST ast) {\n-        return !isPartOfDoubleBraceInitializerForPreviousToken(ast);\n+    private static boolean shouldCheckSeparationFromPreviousToken(final DetailAST detailAST) {\n+        return !isPartOfDoubleBraceInitializerForPreviousToken(detailAST);\n     }\n     \n-    private boolean shouldCheckSeparationFromNextToken(final DetailAST ast, final char nextChar) {\n-        return !this.isEmptyCtorBlockCheckedFromSlist(ast) && (ast.getType() != 88 || ast.getFirstChild().getType() != 45) && ast.getType() != 29 && !isAnonymousInnerClassEnd(ast.getType(), nextChar) && !isPartOfDoubleBraceInitializerForNextToken(ast);\n+    private boolean shouldCheckSeparationFromNextToken(final DetailAST detailAST, final char c) {\n+        return !this.isEmptyCtorBlockCheckedFromSlist(detailAST) && (detailAST.getType() != 88 || detailAST.getFirstChild().getType() != 45) && detailAST.getType() != 29 && !isAnonymousInnerClassEnd(detailAST.getType(), c) && !isPartOfDoubleBraceInitializerForNextToken(detailAST);\n     }\n     \n-    private static boolean isAnonymousInnerClassEnd(final int currentType, final char nextChar) {\n-        return currentType == 73 && (nextChar == ')' || nextChar == ';' || nextChar == ',' || nextChar == '.');\n+    private static boolean isAnonymousInnerClassEnd(final int n, final char c) {\n+        return n == 73 && (c == ')' || c == ';' || c == ',' || c == '.');\n     }\n     \n-    private boolean isEmptyBlock(final DetailAST ast, final int parentType) {\n-        return this.isEmptyMethodBlock(ast, parentType) || this.isEmptyCtorBlockCheckedFromRcurly(ast) || this.isEmptyLoop(ast, parentType) || this.isEmptyLambda(ast, parentType) || this.isEmptyCatch(ast, parentType);\n+    private boolean isEmptyBlock(final DetailAST detailAST, final int n) {\n+        return this.isEmptyMethodBlock(detailAST, n) || this.isEmptyCtorBlockCheckedFromRcurly(detailAST) || this.isEmptyLoop(detailAST, n) || this.isEmptyLambda(detailAST, n) || this.isEmptyCatch(detailAST, n);\n     }\n     \n-    private static boolean isEmptyBlock(final DetailAST ast, final int parentType, final int match) {\n-        final int type = ast.getType();\n-        boolean result;\n+    private static boolean isEmptyBlock(final DetailAST detailAST, final int n, final int n2) {\n+        final int type = detailAST.getType();\n+        boolean b;\n         if (type == 73) {\n-            final DetailAST parent = ast.getParent();\n-            final DetailAST grandParent = ast.getParent().getParent();\n-            result = (parent.getFirstChild().getType() == 73 && grandParent.getType() == match);\n+            final DetailAST parent = detailAST.getParent();\n+            final DetailAST parent2 = detailAST.getParent().getParent();\n+            b = (parent.getFirstChild().getType() == 73 && parent2.getType() == n2);\n         }\n         else {\n-            result = (type == 7 && parentType == match && ast.getFirstChild().getType() == 73);\n+            b = (type == 7 && n == n2 && detailAST.getFirstChild().getType() == 73);\n         }\n-        return result;\n+        return b;\n     }\n     \n-    private static boolean isColonOfCaseOrDefault(final int parentType) {\n-        return parentType == 94 || parentType == 93;\n+    private static boolean isColonOfCaseOrDefault(final int n) {\n+        return n == 94 || n == 93;\n     }\n     \n-    private boolean isColonOfForEach(final int parentType) {\n-        return parentType == 156 && this.ignoreEnhancedForColon;\n+    private boolean isColonOfForEach(final int n) {\n+        return n == 156 && this.ignoreEnhancedForColon;\n     }\n     \n-    private static boolean isArrayInitialization(final int currentType, final int parentType) {\n-        return currentType == 73 && (parentType == 29 || parentType == 162);\n+    private static boolean isArrayInitialization(final int n, final int n2) {\n+        return n == 73 && (n2 == 29 || n2 == 162);\n     }\n     \n-    private boolean isEmptyMethodBlock(final DetailAST ast, final int parentType) {\n-        return this.allowEmptyMethods && isEmptyBlock(ast, parentType, 9);\n+    private boolean isEmptyMethodBlock(final DetailAST detailAST, final int n) {\n+        return this.allowEmptyMethods && isEmptyBlock(detailAST, n, 9);\n     }\n     \n-    private boolean isEmptyCtorBlockCheckedFromRcurly(final DetailAST ast) {\n-        final DetailAST parent = ast.getParent();\n-        final DetailAST grandParent = ast.getParent().getParent();\n-        return this.allowEmptyConstructors && parent.getFirstChild().getType() == 73 && (grandParent.getType() == 8 || grandParent.getType() == 203);\n+    private boolean isEmptyCtorBlockCheckedFromRcurly(final DetailAST detailAST) {\n+        final DetailAST parent = detailAST.getParent();\n+        final DetailAST parent2 = detailAST.getParent().getParent();\n+        return this.allowEmptyConstructors && parent.getFirstChild().getType() == 73 && (parent2.getType() == 8 || parent2.getType() == 203);\n     }\n     \n-    private boolean isEmptyCtorBlockCheckedFromSlist(final DetailAST ast) {\n-        return this.allowEmptyConstructors && (ast.getParent().getType() == 8 || ast.getParent().getType() == 203) && ast.getFirstChild().getType() == 73;\n+    private boolean isEmptyCtorBlockCheckedFromSlist(final DetailAST detailAST) {\n+        return this.allowEmptyConstructors && (detailAST.getParent().getType() == 8 || detailAST.getParent().getType() == 203) && detailAST.getFirstChild().getType() == 73;\n     }\n     \n-    private boolean isEmptyLoop(final DetailAST ast, final int parentType) {\n-        return this.allowEmptyLoops && (isEmptyBlock(ast, parentType, 91) || isEmptyBlock(ast, parentType, 84) || isEmptyBlock(ast, parentType, 85));\n+    private boolean isEmptyLoop(final DetailAST detailAST, final int n) {\n+        return this.allowEmptyLoops && (isEmptyBlock(detailAST, n, 91) || isEmptyBlock(detailAST, n, 84) || isEmptyBlock(detailAST, n, 85));\n     }\n     \n-    private boolean isEmptyLambda(final DetailAST ast, final int parentType) {\n-        return this.allowEmptyLambdas && isEmptyBlock(ast, parentType, 181);\n+    private boolean isEmptyLambda(final DetailAST detailAST, final int n) {\n+        return this.allowEmptyLambdas && isEmptyBlock(detailAST, n, 181);\n     }\n     \n-    private boolean isEmptyCatch(final DetailAST ast, final int parentType) {\n-        return this.allowEmptyCatches && isEmptyBlock(ast, parentType, 96);\n+    private boolean isEmptyCatch(final DetailAST detailAST, final int n) {\n+        return this.allowEmptyCatches && isEmptyBlock(detailAST, n, 96);\n     }\n     \n-    private static boolean isEmptyType(final DetailAST ast) {\n-        final int type = ast.getType();\n-        final DetailAST nextSibling = ast.getNextSibling();\n-        final DetailAST previousSibling = ast.getPreviousSibling();\n+    private static boolean isEmptyType(final DetailAST detailAST) {\n+        final int type = detailAST.getType();\n+        final DetailAST nextSibling = detailAST.getNextSibling();\n+        final DetailAST previousSibling = detailAST.getPreviousSibling();\n         return (type == 72 && nextSibling.getType() == 73) || (previousSibling != null && previousSibling.getType() == 72);\n     }\n     \n-    private static boolean isPartOfDoubleBraceInitializerForPreviousToken(final DetailAST ast) {\n-        final boolean initializerBeginsAfterClassBegins = ast.getParent().getType() == 11;\n-        final boolean classEndsAfterInitializerEnds = ast.getPreviousSibling() != null && ast.getPreviousSibling().getType() == 11;\n-        return initializerBeginsAfterClassBegins || classEndsAfterInitializerEnds;\n+    private static boolean isPartOfDoubleBraceInitializerForPreviousToken(final DetailAST detailAST) {\n+        final boolean b = detailAST.getParent().getType() == 11;\n+        final boolean b2 = detailAST.getPreviousSibling() != null && detailAST.getPreviousSibling().getType() == 11;\n+        return b || b2;\n     }\n     \n-    private static boolean isPartOfDoubleBraceInitializerForNextToken(final DetailAST ast) {\n-        final boolean classBeginBeforeInitializerBegin = ast.getType() == 72 && ast.getNextSibling().getType() == 11;\n-        final boolean initializerEndsBeforeClassEnds = ast.getParent().getParent().getType() == 11 && ast.getParent().getParent().getNextSibling().getType() == 73;\n-        return classBeginBeforeInitializerBegin || initializerEndsBeforeClassEnds;\n+    private static boolean isPartOfDoubleBraceInitializerForNextToken(final DetailAST detailAST) {\n+        final boolean b = detailAST.getType() == 72 && detailAST.getNextSibling().getType() == 11;\n+        final boolean b2 = detailAST.getParent().getParent().getType() == 11 && detailAST.getParent().getParent().getNextSibling().getType() == 73;\n+        return b || b2;\n     }\n }\n"}]}
