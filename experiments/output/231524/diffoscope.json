{"diffoscope-json-version": 1, "source1": "first/ZipFile.class", "source2": "second/ZipFile.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -84,141 +84,137 @@\n     private long centralDirectoryStartOffset;\n     private long firstLocalFileHeaderOffset;\n     \n     public static void closeQuietly(final ZipFile zipFile) {\n         IOUtils.closeQuietly((Closeable)zipFile);\n     }\n     \n-    public ZipFile(final File f) throws IOException {\n-        this(f, \"UTF8\");\n+    public ZipFile(final File file) throws IOException {\n+        this(file, \"UTF8\");\n     }\n     \n-    public ZipFile(final File f, final String encoding) throws IOException {\n-        this(f.toPath(), encoding, true);\n+    public ZipFile(final File file, final String s) throws IOException {\n+        this(file.toPath(), s, true);\n     }\n     \n-    public ZipFile(final File f, final String encoding, final boolean useUnicodeExtraFields) throws IOException {\n-        this(f.toPath(), encoding, useUnicodeExtraFields, false);\n+    public ZipFile(final File file, final String s, final boolean b) throws IOException {\n+        this(file.toPath(), s, b, false);\n     }\n     \n-    public ZipFile(final File f, final String encoding, final boolean useUnicodeExtraFields, final boolean ignoreLocalFileHeader) throws IOException {\n-        this(Files.newByteChannel(f.toPath(), (Set<? extends OpenOption>)EnumSet.of(StandardOpenOption.READ), (FileAttribute<?>[])new FileAttribute[0]), f.getAbsolutePath(), encoding, useUnicodeExtraFields, true, ignoreLocalFileHeader);\n+    public ZipFile(final File file, final String s, final boolean b, final boolean b2) throws IOException {\n+        this(Files.newByteChannel(file.toPath(), (Set<? extends OpenOption>)EnumSet.of(StandardOpenOption.READ), (FileAttribute<?>[])new FileAttribute[0]), file.getAbsolutePath(), s, b, true, b2);\n     }\n     \n     public ZipFile(final Path path) throws IOException {\n         this(path, \"UTF8\");\n     }\n     \n-    public ZipFile(final Path path, final String encoding) throws IOException {\n-        this(path, encoding, true);\n+    public ZipFile(final Path path, final String s) throws IOException {\n+        this(path, s, true);\n     }\n     \n-    public ZipFile(final Path path, final String encoding, final boolean useUnicodeExtraFields) throws IOException {\n-        this(path, encoding, useUnicodeExtraFields, false);\n+    public ZipFile(final Path path, final String s, final boolean b) throws IOException {\n+        this(path, s, b, false);\n     }\n     \n-    public ZipFile(final Path path, final String encoding, final boolean useUnicodeExtraFields, final boolean ignoreLocalFileHeader) throws IOException {\n-        this(Files.newByteChannel(path, (Set<? extends OpenOption>)EnumSet.of(StandardOpenOption.READ), (FileAttribute<?>[])new FileAttribute[0]), path.toAbsolutePath().toString(), encoding, useUnicodeExtraFields, true, ignoreLocalFileHeader);\n+    public ZipFile(final Path path, final String s, final boolean b, final boolean b2) throws IOException {\n+        this(Files.newByteChannel(path, (Set<? extends OpenOption>)EnumSet.of(StandardOpenOption.READ), (FileAttribute<?>[])new FileAttribute[0]), path.toAbsolutePath().toString(), s, b, true, b2);\n     }\n     \n-    public ZipFile(final SeekableByteChannel channel) throws IOException {\n-        this(channel, \"unknown archive\", \"UTF8\", true);\n+    public ZipFile(final SeekableByteChannel seekableByteChannel) throws IOException {\n+        this(seekableByteChannel, \"unknown archive\", \"UTF8\", true);\n     }\n     \n-    public ZipFile(final SeekableByteChannel channel, final String encoding) throws IOException {\n-        this(channel, \"unknown archive\", encoding, true);\n+    public ZipFile(final SeekableByteChannel seekableByteChannel, final String s) throws IOException {\n+        this(seekableByteChannel, \"unknown archive\", s, true);\n     }\n     \n-    public ZipFile(final SeekableByteChannel channel, final String archiveName, final String encoding, final boolean useUnicodeExtraFields) throws IOException {\n-        this(channel, archiveName, encoding, useUnicodeExtraFields, false, false);\n+    public ZipFile(final SeekableByteChannel seekableByteChannel, final String s, final String s2, final boolean b) throws IOException {\n+        this(seekableByteChannel, s, s2, b, false, false);\n     }\n     \n-    public ZipFile(final SeekableByteChannel channel, final String archiveName, final String encoding, final boolean useUnicodeExtraFields, final boolean ignoreLocalFileHeader) throws IOException {\n-        this(channel, archiveName, encoding, useUnicodeExtraFields, false, ignoreLocalFileHeader);\n+    public ZipFile(final SeekableByteChannel seekableByteChannel, final String s, final String s2, final boolean b, final boolean b2) throws IOException {\n+        this(seekableByteChannel, s, s2, b, false, b2);\n     }\n     \n-    private ZipFile(final SeekableByteChannel channel, final String archiveName, final String encoding, final boolean useUnicodeExtraFields, final boolean closeOnError, final boolean ignoreLocalFileHeader) throws IOException {\n+    private ZipFile(final SeekableByteChannel archive, final String s, final String encoding, final boolean useUnicodeExtraFields, final boolean b, final boolean b2) throws IOException {\n         this.entries = new LinkedList<ZipArchiveEntry>();\n         this.nameMap = new HashMap<String, LinkedList<ZipArchiveEntry>>(509);\n         this.closed = true;\n         this.dwordBuf = new byte[8];\n         this.wordBuf = new byte[4];\n         this.cfhBuf = new byte[42];\n         this.shortBuf = new byte[2];\n         this.dwordBbuf = ByteBuffer.wrap(this.dwordBuf);\n         this.wordBbuf = ByteBuffer.wrap(this.wordBuf);\n         this.cfhBbuf = ByteBuffer.wrap(this.cfhBuf);\n         this.shortBbuf = ByteBuffer.wrap(this.shortBuf);\n-        this.isSplitZipArchive = (channel instanceof ZipSplitReadOnlySeekableByteChannel);\n-        this.archiveName = archiveName;\n+        this.isSplitZipArchive = (archive instanceof ZipSplitReadOnlySeekableByteChannel);\n+        this.archiveName = s;\n         this.encoding = encoding;\n         this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n         this.useUnicodeExtraFields = useUnicodeExtraFields;\n-        this.archive = channel;\n-        boolean success = false;\n+        this.archive = archive;\n+        boolean b3 = false;\n         try {\n-            final Map<ZipArchiveEntry, ZipFile.NameAndComment> entriesWithoutUTF8Flag = this.populateFromCentralDirectory();\n-            if (!ignoreLocalFileHeader) {\n-                this.resolveLocalFileHeaderData(entriesWithoutUTF8Flag);\n+            final Map<ZipArchiveEntry, ZipFile.NameAndComment> populateFromCentralDirectory = this.populateFromCentralDirectory();\n+            if (!b2) {\n+                this.resolveLocalFileHeaderData(populateFromCentralDirectory);\n             }\n             this.fillNameMap();\n-            success = true;\n+            b3 = true;\n         }\n-        catch (final IOException e) {\n-            throw new IOException(\"Error on ZipFile \" + archiveName, e);\n+        catch (final IOException cause) {\n+            throw new IOException(\"Error on ZipFile \" + s, cause);\n         }\n         finally {\n-            this.closed = !success;\n-            if (!success && closeOnError) {\n+            this.closed = !b3;\n+            if (!b3 && b) {\n                 IOUtils.closeQuietly((Closeable)this.archive);\n             }\n         }\n     }\n     \n-    public ZipFile(final String name) throws IOException {\n-        this(new File(name).toPath(), \"UTF8\");\n+    public ZipFile(final String pathname) throws IOException {\n+        this(new File(pathname).toPath(), \"UTF8\");\n     }\n     \n-    public ZipFile(final String name, final String encoding) throws IOException {\n-        this(new File(name).toPath(), encoding, true);\n+    public ZipFile(final String pathname, final String s) throws IOException {\n+        this(new File(pathname).toPath(), s, true);\n     }\n     \n-    public boolean canReadEntryData(final ZipArchiveEntry ze) {\n-        return ZipUtil.canHandleEntryData(ze);\n+    public boolean canReadEntryData(final ZipArchiveEntry zipArchiveEntry) {\n+        return ZipUtil.canHandleEntryData(zipArchiveEntry);\n     }\n     \n     @Override\n     public void close() throws IOException {\n         this.closed = true;\n         this.archive.close();\n     }\n     \n-    public void copyRawEntries(final ZipArchiveOutputStream target, final ZipArchiveEntryPredicate predicate) throws IOException {\n-        final Enumeration<ZipArchiveEntry> src = this.getEntriesInPhysicalOrder();\n-        while (src.hasMoreElements()) {\n-            final ZipArchiveEntry entry = (ZipArchiveEntry)src.nextElement();\n-            if (predicate.test(entry)) {\n-                target.addRawArchiveEntry(entry, this.getRawInputStream(entry));\n+    public void copyRawEntries(final ZipArchiveOutputStream zipArchiveOutputStream, final ZipArchiveEntryPredicate zipArchiveEntryPredicate) throws IOException {\n+        final Enumeration<ZipArchiveEntry> entriesInPhysicalOrder = this.getEntriesInPhysicalOrder();\n+        while (entriesInPhysicalOrder.hasMoreElements()) {\n+            final ZipArchiveEntry zipArchiveEntry = (ZipArchiveEntry)entriesInPhysicalOrder.nextElement();\n+            if (zipArchiveEntryPredicate.test(zipArchiveEntry)) {\n+                zipArchiveOutputStream.addRawArchiveEntry(zipArchiveEntry, this.getRawInputStream(zipArchiveEntry));\n             }\n         }\n     }\n     \n-    private BoundedArchiveInputStream createBoundedInputStream(final long start, final long remaining) {\n-        if (start < 0L || remaining < 0L || start + remaining < start) {\n+    private BoundedArchiveInputStream createBoundedInputStream(final long n, final long n2) {\n+        if (n < 0L || n2 < 0L || n + n2 < n) {\n             throw new IllegalArgumentException(\"Corrupted archive, stream boundaries are out of range\");\n         }\n-        return (BoundedArchiveInputStream)((this.archive instanceof FileChannel) ? new ZipFile.BoundedFileChannelInputStream(this, start, remaining) : new BoundedSeekableByteChannelInputStream(start, remaining, this.archive));\n+        return (BoundedArchiveInputStream)((this.archive instanceof FileChannel) ? new ZipFile.BoundedFileChannelInputStream(this, n, n2) : new BoundedSeekableByteChannelInputStream(n, n2, this.archive));\n     }\n     \n     private void fillNameMap() {\n-        this.entries.forEach(ze -> {\n-            final String name = ze.getName();\n-            final LinkedList<ZipArchiveEntry> entriesOfThatName = (LinkedList<ZipArchiveEntry>)this.nameMap.computeIfAbsent(name, k -> new LinkedList());\n-            entriesOfThatName.addLast(ze);\n-        });\n+        this.entries.forEach(e -> ((LinkedList<ZipArchiveEntry>)this.nameMap.computeIfAbsent(e.getName(), p0 -> new LinkedList())).addLast(e));\n     }\n     \n     @Override\n     protected void finalize() throws Throwable {\n         try {\n             if (!this.closed) {\n                 this.close();\n@@ -229,160 +225,160 @@\n         }\n     }\n     \n     public InputStream getContentBeforeFirstLocalFileHeader() {\n         return (InputStream)((this.firstLocalFileHeaderOffset == 0L) ? null : this.createBoundedInputStream(0L, this.firstLocalFileHeaderOffset));\n     }\n     \n-    private long getDataOffset(final ZipArchiveEntry ze) throws IOException {\n-        final long s = ze.getDataOffset();\n-        if (s == -1L) {\n-            this.setDataOffset(ze);\n-            return ze.getDataOffset();\n+    private long getDataOffset(final ZipArchiveEntry dataOffset) throws IOException {\n+        final long dataOffset2 = dataOffset.getDataOffset();\n+        if (dataOffset2 == -1L) {\n+            this.setDataOffset(dataOffset);\n+            return dataOffset.getDataOffset();\n         }\n-        return s;\n+        return dataOffset2;\n     }\n     \n     public String getEncoding() {\n         return this.encoding;\n     }\n     \n     public Enumeration<ZipArchiveEntry> getEntries() {\n         return Collections.enumeration(this.entries);\n     }\n     \n-    public Iterable<ZipArchiveEntry> getEntries(final String name) {\n-        final List<ZipArchiveEntry> entriesOfThatName = (List)this.nameMap.get(name);\n-        return (entriesOfThatName != null) ? entriesOfThatName : Collections.emptyList();\n+    public Iterable<ZipArchiveEntry> getEntries(final String s) {\n+        final List list = (List)this.nameMap.get(s);\n+        return (Iterable<ZipArchiveEntry>)((list != null) ? list : Collections.emptyList());\n     }\n     \n     public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder() {\n-        final ZipArchiveEntry[] allEntries = (ZipArchiveEntry[])this.entries.toArray(ZipArchiveEntry.EMPTY_ARRAY);\n-        Arrays.sort(allEntries, ZipFile.offsetComparator);\n-        return Collections.enumeration(Arrays.asList(allEntries));\n+        final ZipArchiveEntry[] array = (ZipArchiveEntry[])this.entries.toArray(ZipArchiveEntry.EMPTY_ARRAY);\n+        Arrays.sort(array, ZipFile.offsetComparator);\n+        return Collections.enumeration(Arrays.asList(array));\n     }\n     \n-    public Iterable<ZipArchiveEntry> getEntriesInPhysicalOrder(final String name) {\n-        ZipArchiveEntry[] entriesOfThatName = ZipArchiveEntry.EMPTY_ARRAY;\n-        final LinkedList<ZipArchiveEntry> linkedList = (LinkedList<ZipArchiveEntry>)this.nameMap.get(name);\n-        if (linkedList != null) {\n-            entriesOfThatName = linkedList.toArray(entriesOfThatName);\n-            Arrays.sort(entriesOfThatName, ZipFile.offsetComparator);\n+    public Iterable<ZipArchiveEntry> getEntriesInPhysicalOrder(final String s) {\n+        ZipArchiveEntry[] empty_ARRAY = ZipArchiveEntry.EMPTY_ARRAY;\n+        final LinkedList list = (LinkedList)this.nameMap.get(s);\n+        if (list != null) {\n+            empty_ARRAY = (ZipArchiveEntry[])list.toArray(empty_ARRAY);\n+            Arrays.sort(empty_ARRAY, ZipFile.offsetComparator);\n         }\n-        return Arrays.asList(entriesOfThatName);\n+        return Arrays.asList(empty_ARRAY);\n     }\n     \n-    public ZipArchiveEntry getEntry(final String name) {\n-        final LinkedList<ZipArchiveEntry> entriesOfThatName = (LinkedList<ZipArchiveEntry>)this.nameMap.get(name);\n-        return (entriesOfThatName != null) ? ((ZipArchiveEntry)entriesOfThatName.getFirst()) : null;\n+    public ZipArchiveEntry getEntry(final String s) {\n+        final LinkedList list = (LinkedList)this.nameMap.get(s);\n+        return (list != null) ? ((ZipArchiveEntry)list.getFirst()) : null;\n     }\n     \n     public long getFirstLocalFileHeaderOffset() {\n         return this.firstLocalFileHeaderOffset;\n     }\n     \n-    public InputStream getInputStream(final ZipArchiveEntry zipEntry) throws IOException {\n-        if (!(zipEntry instanceof ZipFile.Entry)) {\n+    public InputStream getInputStream(final ZipArchiveEntry zipArchiveEntry) throws IOException {\n+        if (!(zipArchiveEntry instanceof ZipFile.Entry)) {\n             return null;\n         }\n-        ZipUtil.checkRequestedFeatures(zipEntry);\n-        final InputStream is = new BufferedInputStream(this.getRawInputStream(zipEntry));\n-        switch (ZipFile.ZipFile$2.$SwitchMap$org$apache$commons$compress$archivers$zip$ZipMethod[ZipMethod.getMethodByCode(zipEntry.getMethod()).ordinal()]) {\n+        ZipUtil.checkRequestedFeatures(zipArchiveEntry);\n+        final BufferedInputStream s1 = new BufferedInputStream(this.getRawInputStream(zipArchiveEntry));\n+        switch (ZipFile.ZipFile$2.$SwitchMap$org$apache$commons$compress$archivers$zip$ZipMethod[ZipMethod.getMethodByCode(zipArchiveEntry.getMethod()).ordinal()]) {\n             case 1: {\n-                return (InputStream)new ZipFile.StoredStatisticsStream(is);\n+                return (InputStream)new ZipFile.StoredStatisticsStream((InputStream)s1);\n             }\n             case 2: {\n-                return (InputStream)new UnshrinkingInputStream(is);\n+                return (InputStream)new UnshrinkingInputStream((InputStream)s1);\n             }\n             case 3: {\n                 try {\n-                    return (InputStream)new ExplodingInputStream(zipEntry.getGeneralPurposeBit().getSlidingDictionarySize(), zipEntry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(), is);\n+                    return (InputStream)new ExplodingInputStream(zipArchiveEntry.getGeneralPurposeBit().getSlidingDictionarySize(), zipArchiveEntry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(), (InputStream)s1);\n                 }\n-                catch (final IllegalArgumentException ex) {\n-                    throw new IOException(\"bad IMPLODE data\", ex);\n+                catch (final IllegalArgumentException cause) {\n+                    throw new IOException(\"bad IMPLODE data\", cause);\n                 }\n             }\n             case 4: {\n                 final Inflater inflater = new Inflater(true);\n-                return (InputStream)new ZipFile.ZipFile$1(this, (InputStream)new SequenceInputStream(is, new ByteArrayInputStream(ZipFile.ONE_ZERO_BYTE)), inflater, inflater);\n+                return (InputStream)new ZipFile.ZipFile$1(this, (InputStream)new SequenceInputStream(s1, new ByteArrayInputStream(ZipFile.ONE_ZERO_BYTE)), inflater, inflater);\n             }\n             case 5: {\n-                return (InputStream)new BZip2CompressorInputStream(is);\n+                return (InputStream)new BZip2CompressorInputStream((InputStream)s1);\n             }\n             case 6: {\n-                return (InputStream)new Deflate64CompressorInputStream(is);\n+                return (InputStream)new Deflate64CompressorInputStream((InputStream)s1);\n             }\n             default: {\n-                throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(zipEntry.getMethod()), zipEntry);\n+                throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(zipArchiveEntry.getMethod()), zipArchiveEntry);\n             }\n         }\n     }\n     \n-    public InputStream getRawInputStream(final ZipArchiveEntry ze) throws IOException {\n-        if (!(ze instanceof ZipFile.Entry)) {\n+    public InputStream getRawInputStream(final ZipArchiveEntry zipArchiveEntry) throws IOException {\n+        if (!(zipArchiveEntry instanceof ZipFile.Entry)) {\n             return null;\n         }\n-        final long start = this.getDataOffset(ze);\n-        if (start == -1L) {\n+        final long dataOffset = this.getDataOffset(zipArchiveEntry);\n+        if (dataOffset == -1L) {\n             return null;\n         }\n-        return (InputStream)this.createBoundedInputStream(start, ze.getCompressedSize());\n+        return (InputStream)this.createBoundedInputStream(dataOffset, zipArchiveEntry.getCompressedSize());\n     }\n     \n-    public String getUnixSymlink(final ZipArchiveEntry entry) throws IOException {\n-        if (entry != null && entry.isUnixSymlink()) {\n-            try (final InputStream in = this.getInputStream(entry)) {\n-                return this.zipEncoding.decode(IOUtils.toByteArray(in));\n+    public String getUnixSymlink(final ZipArchiveEntry zipArchiveEntry) throws IOException {\n+        if (zipArchiveEntry != null && zipArchiveEntry.isUnixSymlink()) {\n+            try (final InputStream inputStream = this.getInputStream(zipArchiveEntry)) {\n+                return this.zipEncoding.decode(IOUtils.toByteArray(inputStream));\n             }\n         }\n         return null;\n     }\n     \n     private Map<ZipArchiveEntry, ZipFile.NameAndComment> populateFromCentralDirectory() throws IOException {\n-        final HashMap<ZipArchiveEntry, ZipFile.NameAndComment> noUTF8Flag = new HashMap<ZipArchiveEntry, ZipFile.NameAndComment>();\n+        final HashMap hashMap = new HashMap();\n         this.positionAtCentralDirectory();\n         this.centralDirectoryStartOffset = this.archive.position();\n         this.wordBbuf.rewind();\n         IOUtils.readFully((ReadableByteChannel)this.archive, this.wordBbuf);\n-        long sig = ZipLong.getValue(this.wordBuf);\n-        if (sig != ZipFile.CFH_SIG && this.startsWithLocalFileHeader()) {\n+        long n = ZipLong.getValue(this.wordBuf);\n+        if (n != ZipFile.CFH_SIG && this.startsWithLocalFileHeader()) {\n             throw new IOException(\"Central directory is empty, can't expand corrupt archive.\");\n         }\n-        while (sig == ZipFile.CFH_SIG) {\n-            this.readCentralDirectoryEntry(noUTF8Flag);\n+        while (n == ZipFile.CFH_SIG) {\n+            this.readCentralDirectoryEntry(hashMap);\n             this.wordBbuf.rewind();\n             IOUtils.readFully((ReadableByteChannel)this.archive, this.wordBbuf);\n-            sig = ZipLong.getValue(this.wordBuf);\n+            n = ZipLong.getValue(this.wordBuf);\n         }\n-        return noUTF8Flag;\n+        return hashMap;\n     }\n     \n     private void positionAtCentralDirectory() throws IOException {\n         this.positionAtEndOfCentralDirectoryRecord();\n-        boolean found = false;\n-        final boolean searchedForZip64EOCD = this.archive.position() > 20L;\n-        if (searchedForZip64EOCD) {\n+        boolean equals = false;\n+        final boolean b = this.archive.position() > 20L;\n+        if (b) {\n             this.archive.position(this.archive.position() - 20L);\n             this.wordBbuf.rewind();\n             IOUtils.readFully((ReadableByteChannel)this.archive, this.wordBbuf);\n-            found = Arrays.equals(ZipArchiveOutputStream.ZIP64_EOCD_LOC_SIG, this.wordBuf);\n+            equals = Arrays.equals(ZipArchiveOutputStream.ZIP64_EOCD_LOC_SIG, this.wordBuf);\n         }\n-        if (!found) {\n-            if (searchedForZip64EOCD) {\n+        if (!equals) {\n+            if (b) {\n                 this.skipBytes(16);\n             }\n             this.positionAtCentralDirectory32();\n         }\n         else {\n             this.positionAtCentralDirectory64();\n         }\n     }\n     \n     private void positionAtCentralDirectory32() throws IOException {\n-        final long endOfCentralDirectoryRecordOffset = this.archive.position();\n+        final long position = this.archive.position();\n         if (this.isSplitZipArchive) {\n             this.skipBytes(6);\n             this.shortBbuf.rewind();\n             IOUtils.readFully((ReadableByteChannel)this.archive, this.shortBbuf);\n             this.centralDirectoryStartDiskNumber = ZipShort.getValue(this.shortBuf);\n             this.skipBytes(8);\n             this.wordBbuf.rewind();\n@@ -390,33 +386,32 @@\n             this.centralDirectoryStartRelativeOffset = ZipLong.getValue(this.wordBuf);\n             ((ZipSplitReadOnlySeekableByteChannel)this.archive).position(this.centralDirectoryStartDiskNumber, this.centralDirectoryStartRelativeOffset);\n         }\n         else {\n             this.skipBytes(12);\n             this.wordBbuf.rewind();\n             IOUtils.readFully((ReadableByteChannel)this.archive, this.wordBbuf);\n-            final long centralDirectoryLength = ZipLong.getValue(this.wordBuf);\n+            final long value = ZipLong.getValue(this.wordBuf);\n             this.wordBbuf.rewind();\n             IOUtils.readFully((ReadableByteChannel)this.archive, this.wordBbuf);\n             this.centralDirectoryStartDiskNumber = 0L;\n             this.centralDirectoryStartRelativeOffset = ZipLong.getValue(this.wordBuf);\n-            this.firstLocalFileHeaderOffset = Long.max(endOfCentralDirectoryRecordOffset - centralDirectoryLength - this.centralDirectoryStartRelativeOffset, 0L);\n+            this.firstLocalFileHeaderOffset = Long.max(position - value - this.centralDirectoryStartRelativeOffset, 0L);\n             this.archive.position(this.centralDirectoryStartRelativeOffset + this.firstLocalFileHeaderOffset);\n         }\n     }\n     \n     private void positionAtCentralDirectory64() throws IOException {\n         if (this.isSplitZipArchive) {\n             this.wordBbuf.rewind();\n             IOUtils.readFully((ReadableByteChannel)this.archive, this.wordBbuf);\n-            final long diskNumberOfEOCD = ZipLong.getValue(this.wordBuf);\n+            final long value = ZipLong.getValue(this.wordBuf);\n             this.dwordBbuf.rewind();\n             IOUtils.readFully((ReadableByteChannel)this.archive, this.dwordBbuf);\n-            final long relativeOffsetOfEOCD = ZipEightByteInteger.getLongValue(this.dwordBuf);\n-            ((ZipSplitReadOnlySeekableByteChannel)this.archive).position(diskNumberOfEOCD, relativeOffsetOfEOCD);\n+            ((ZipSplitReadOnlySeekableByteChannel)this.archive).position(value, ZipEightByteInteger.getLongValue(this.dwordBuf));\n         }\n         else {\n             this.skipBytes(4);\n             this.dwordBbuf.rewind();\n             IOUtils.readFully((ReadableByteChannel)this.archive, this.dwordBbuf);\n             this.archive.position(ZipEightByteInteger.getLongValue(this.dwordBuf));\n         }\n@@ -443,275 +438,263 @@\n             this.centralDirectoryStartDiskNumber = 0L;\n             this.centralDirectoryStartRelativeOffset = ZipEightByteInteger.getLongValue(this.dwordBuf);\n             this.archive.position(this.centralDirectoryStartRelativeOffset);\n         }\n     }\n     \n     private void positionAtEndOfCentralDirectoryRecord() throws IOException {\n-        final boolean found = this.tryToLocateSignature(22L, 65557L, ZipArchiveOutputStream.EOCD_SIG);\n-        if (!found) {\n+        if (!this.tryToLocateSignature(22L, 65557L, ZipArchiveOutputStream.EOCD_SIG)) {\n             throw new ZipException(\"Archive is not a ZIP archive\");\n         }\n     }\n     \n-    private void readCentralDirectoryEntry(final Map<ZipArchiveEntry, ZipFile.NameAndComment> noUTF8Flag) throws IOException {\n+    private void readCentralDirectoryEntry(final Map<ZipArchiveEntry, ZipFile.NameAndComment> map) throws IOException {\n         this.cfhBbuf.rewind();\n         IOUtils.readFully((ReadableByteChannel)this.archive, this.cfhBbuf);\n-        int off = 0;\n-        final ZipFile.Entry ze = new ZipFile.Entry();\n-        final int versionMadeBy = ZipShort.getValue(this.cfhBuf, off);\n-        off += 2;\n-        ze.setVersionMadeBy(versionMadeBy);\n-        ze.setPlatform(versionMadeBy >> 8 & 0xF);\n-        ze.setVersionRequired(ZipShort.getValue(this.cfhBuf, off));\n-        off += 2;\n-        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(this.cfhBuf, off);\n-        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n-        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : this.zipEncoding;\n-        if (hasUTF8Flag) {\n-            ze.setNameSource(ZipArchiveEntry.NameSource.NAME_WITH_EFS_FLAG);\n-        }\n-        ze.setGeneralPurposeBit(gpFlag);\n-        ze.setRawFlag(ZipShort.getValue(this.cfhBuf, off));\n-        off += 2;\n-        ze.setMethod(ZipShort.getValue(this.cfhBuf, off));\n-        off += 2;\n-        final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(this.cfhBuf, off));\n-        ze.setTime(time);\n-        off += 4;\n-        ze.setCrc(ZipLong.getValue(this.cfhBuf, off));\n-        off += 4;\n-        long size = ZipLong.getValue(this.cfhBuf, off);\n-        if (size < 0L) {\n+        int n = 0;\n+        final ZipFile.Entry sizesAndOffsetFromZip64Extra = new ZipFile.Entry();\n+        final int value = ZipShort.getValue(this.cfhBuf, n);\n+        n += 2;\n+        sizesAndOffsetFromZip64Extra.setVersionMadeBy(value);\n+        sizesAndOffsetFromZip64Extra.setPlatform(value >> 8 & 0xF);\n+        sizesAndOffsetFromZip64Extra.setVersionRequired(ZipShort.getValue(this.cfhBuf, n));\n+        n += 2;\n+        final GeneralPurposeBit parse = GeneralPurposeBit.parse(this.cfhBuf, n);\n+        final boolean usesUTF8ForNames = parse.usesUTF8ForNames();\n+        final ZipEncoding zipEncoding = usesUTF8ForNames ? ZipEncodingHelper.UTF8_ZIP_ENCODING : this.zipEncoding;\n+        if (usesUTF8ForNames) {\n+            sizesAndOffsetFromZip64Extra.setNameSource(ZipArchiveEntry.NameSource.NAME_WITH_EFS_FLAG);\n+        }\n+        sizesAndOffsetFromZip64Extra.setGeneralPurposeBit(parse);\n+        sizesAndOffsetFromZip64Extra.setRawFlag(ZipShort.getValue(this.cfhBuf, n));\n+        n += 2;\n+        sizesAndOffsetFromZip64Extra.setMethod(ZipShort.getValue(this.cfhBuf, n));\n+        n += 2;\n+        sizesAndOffsetFromZip64Extra.setTime(ZipUtil.dosToJavaTime(ZipLong.getValue(this.cfhBuf, n)));\n+        n += 4;\n+        sizesAndOffsetFromZip64Extra.setCrc(ZipLong.getValue(this.cfhBuf, n));\n+        n += 4;\n+        final long value2 = ZipLong.getValue(this.cfhBuf, n);\n+        if (value2 < 0L) {\n             throw new IOException(\"broken archive, entry with negative compressed size\");\n         }\n-        ze.setCompressedSize(size);\n-        off += 4;\n-        size = ZipLong.getValue(this.cfhBuf, off);\n-        if (size < 0L) {\n+        sizesAndOffsetFromZip64Extra.setCompressedSize(value2);\n+        n += 4;\n+        final long value3 = ZipLong.getValue(this.cfhBuf, n);\n+        if (value3 < 0L) {\n             throw new IOException(\"broken archive, entry with negative size\");\n         }\n-        ze.setSize(size);\n-        off += 4;\n-        final int fileNameLen = ZipShort.getValue(this.cfhBuf, off);\n-        off += 2;\n-        if (fileNameLen < 0) {\n+        sizesAndOffsetFromZip64Extra.setSize(value3);\n+        n += 4;\n+        final int value4 = ZipShort.getValue(this.cfhBuf, n);\n+        n += 2;\n+        if (value4 < 0) {\n             throw new IOException(\"broken archive, entry with negative fileNameLen\");\n         }\n-        final int extraLen = ZipShort.getValue(this.cfhBuf, off);\n-        off += 2;\n-        if (extraLen < 0) {\n+        final int value5 = ZipShort.getValue(this.cfhBuf, n);\n+        n += 2;\n+        if (value5 < 0) {\n             throw new IOException(\"broken archive, entry with negative extraLen\");\n         }\n-        final int commentLen = ZipShort.getValue(this.cfhBuf, off);\n-        off += 2;\n-        if (commentLen < 0) {\n+        final int value6 = ZipShort.getValue(this.cfhBuf, n);\n+        n += 2;\n+        if (value6 < 0) {\n             throw new IOException(\"broken archive, entry with negative commentLen\");\n         }\n-        ze.setDiskNumberStart((long)ZipShort.getValue(this.cfhBuf, off));\n-        off += 2;\n-        ze.setInternalAttributes(ZipShort.getValue(this.cfhBuf, off));\n-        off += 2;\n-        ze.setExternalAttributes(ZipLong.getValue(this.cfhBuf, off));\n-        off += 4;\n-        final byte[] fileName = IOUtils.readRange((ReadableByteChannel)this.archive, fileNameLen);\n-        if (fileName.length < fileNameLen) {\n+        sizesAndOffsetFromZip64Extra.setDiskNumberStart((long)ZipShort.getValue(this.cfhBuf, n));\n+        n += 2;\n+        sizesAndOffsetFromZip64Extra.setInternalAttributes(ZipShort.getValue(this.cfhBuf, n));\n+        n += 2;\n+        sizesAndOffsetFromZip64Extra.setExternalAttributes(ZipLong.getValue(this.cfhBuf, n));\n+        n += 4;\n+        final byte[] range = IOUtils.readRange((ReadableByteChannel)this.archive, value4);\n+        if (range.length < value4) {\n             throw new EOFException();\n         }\n-        ze.setName(entryEncoding.decode(fileName), fileName);\n-        ze.setLocalHeaderOffset(ZipLong.getValue(this.cfhBuf, off) + this.firstLocalFileHeaderOffset);\n-        this.entries.add((ZipArchiveEntry)ze);\n-        final byte[] cdExtraData = IOUtils.readRange((ReadableByteChannel)this.archive, extraLen);\n-        if (cdExtraData.length < extraLen) {\n+        sizesAndOffsetFromZip64Extra.setName(zipEncoding.decode(range), range);\n+        sizesAndOffsetFromZip64Extra.setLocalHeaderOffset(ZipLong.getValue(this.cfhBuf, n) + this.firstLocalFileHeaderOffset);\n+        this.entries.add((ZipArchiveEntry)sizesAndOffsetFromZip64Extra);\n+        final byte[] range2 = IOUtils.readRange((ReadableByteChannel)this.archive, value5);\n+        if (range2.length < value5) {\n             throw new EOFException();\n         }\n         try {\n-            ze.setCentralDirectoryExtra(cdExtraData);\n+            sizesAndOffsetFromZip64Extra.setCentralDirectoryExtra(range2);\n         }\n-        catch (final RuntimeException ex) {\n-            final ZipException z = new ZipException(\"Invalid extra data in entry \" + ze.getName());\n-            z.initCause(ex);\n-            throw z;\n-        }\n-        this.setSizesAndOffsetFromZip64Extra((ZipArchiveEntry)ze);\n-        this.sanityCheckLFHOffset((ZipArchiveEntry)ze);\n-        final byte[] comment = IOUtils.readRange((ReadableByteChannel)this.archive, commentLen);\n-        if (comment.length < commentLen) {\n+        catch (final RuntimeException cause) {\n+            final ZipException ex = new ZipException(\"Invalid extra data in entry \" + sizesAndOffsetFromZip64Extra.getName());\n+            ex.initCause(cause);\n+            throw ex;\n+        }\n+        this.setSizesAndOffsetFromZip64Extra((ZipArchiveEntry)sizesAndOffsetFromZip64Extra);\n+        this.sanityCheckLFHOffset((ZipArchiveEntry)sizesAndOffsetFromZip64Extra);\n+        final byte[] range3 = IOUtils.readRange((ReadableByteChannel)this.archive, value6);\n+        if (range3.length < value6) {\n             throw new EOFException();\n         }\n-        ze.setComment(entryEncoding.decode(comment));\n-        if (!hasUTF8Flag && this.useUnicodeExtraFields) {\n-            noUTF8Flag.put((ZipArchiveEntry)ze, new ZipFile.NameAndComment(fileName, comment, (ZipFile.ZipFile$1)null));\n-        }\n-        ze.setStreamContiguous(true);\n-    }\n-    \n-    private void resolveLocalFileHeaderData(final Map<ZipArchiveEntry, ZipFile.NameAndComment> entriesWithoutUTF8Flag) throws IOException {\n-        for (final ZipArchiveEntry zipArchiveEntry : this.entries) {\n-            final ZipFile.Entry ze = (ZipFile.Entry)zipArchiveEntry;\n-            final int[] lens = this.setDataOffset((ZipArchiveEntry)ze);\n-            final int fileNameLen = lens[0];\n-            final int extraFieldLen = lens[1];\n-            this.skipBytes(fileNameLen);\n-            final byte[] localExtraData = IOUtils.readRange((ReadableByteChannel)this.archive, extraFieldLen);\n-            if (localExtraData.length < extraFieldLen) {\n+        sizesAndOffsetFromZip64Extra.setComment(zipEncoding.decode(range3));\n+        if (!usesUTF8ForNames && this.useUnicodeExtraFields) {\n+            map.put((ZipArchiveEntry)sizesAndOffsetFromZip64Extra, new ZipFile.NameAndComment(range, range3, (ZipFile.ZipFile$1)null));\n+        }\n+        sizesAndOffsetFromZip64Extra.setStreamContiguous(true);\n+    }\n+    \n+    private void resolveLocalFileHeaderData(final Map<ZipArchiveEntry, ZipFile.NameAndComment> map) throws IOException {\n+        final Iterator<ZipArchiveEntry> iterator = this.entries.iterator();\n+        while (iterator.hasNext()) {\n+            final ZipFile.Entry dataOffset = (ZipFile.Entry)iterator.next();\n+            final int[] setDataOffset = this.setDataOffset((ZipArchiveEntry)dataOffset);\n+            final int n = setDataOffset[0];\n+            final int n2 = setDataOffset[1];\n+            this.skipBytes(n);\n+            final byte[] range = IOUtils.readRange((ReadableByteChannel)this.archive, n2);\n+            if (range.length < n2) {\n                 throw new EOFException();\n             }\n             try {\n-                ze.setExtra(localExtraData);\n+                dataOffset.setExtra(range);\n             }\n-            catch (final RuntimeException ex) {\n-                final ZipException z = new ZipException(\"Invalid extra data in entry \" + ze.getName());\n-                z.initCause(ex);\n-                throw z;\n+            catch (final RuntimeException cause) {\n+                final ZipException ex = new ZipException(\"Invalid extra data in entry \" + dataOffset.getName());\n+                ex.initCause(cause);\n+                throw ex;\n             }\n-            if (!entriesWithoutUTF8Flag.containsKey(ze)) {\n+            if (!map.containsKey(dataOffset)) {\n                 continue;\n             }\n-            final ZipFile.NameAndComment nc = (ZipFile.NameAndComment)entriesWithoutUTF8Flag.get(ze);\n-            ZipUtil.setNameAndCommentFromExtraFields((ZipArchiveEntry)ze, ZipFile.NameAndComment.access$200(nc), ZipFile.NameAndComment.access$300(nc));\n+            final ZipFile.NameAndComment nameAndComment = (ZipFile.NameAndComment)map.get(dataOffset);\n+            ZipUtil.setNameAndCommentFromExtraFields((ZipArchiveEntry)dataOffset, ZipFile.NameAndComment.access$200(nameAndComment), ZipFile.NameAndComment.access$300(nameAndComment));\n         }\n     }\n     \n-    private void sanityCheckLFHOffset(final ZipArchiveEntry ze) throws IOException {\n-        if (ze.getDiskNumberStart() < 0L) {\n+    private void sanityCheckLFHOffset(final ZipArchiveEntry zipArchiveEntry) throws IOException {\n+        if (zipArchiveEntry.getDiskNumberStart() < 0L) {\n             throw new IOException(\"broken archive, entry with negative disk number\");\n         }\n-        if (ze.getLocalHeaderOffset() < 0L) {\n+        if (zipArchiveEntry.getLocalHeaderOffset() < 0L) {\n             throw new IOException(\"broken archive, entry with negative local file header offset\");\n         }\n         if (this.isSplitZipArchive) {\n-            if (ze.getDiskNumberStart() > this.centralDirectoryStartDiskNumber) {\n-                throw new IOException(\"local file header for \" + ze.getName() + \" starts on a later disk than central directory\");\n+            if (zipArchiveEntry.getDiskNumberStart() > this.centralDirectoryStartDiskNumber) {\n+                throw new IOException(\"local file header for \" + zipArchiveEntry.getName() + \" starts on a later disk than central directory\");\n             }\n-            if (ze.getDiskNumberStart() == this.centralDirectoryStartDiskNumber && ze.getLocalHeaderOffset() > this.centralDirectoryStartRelativeOffset) {\n-                throw new IOException(\"local file header for \" + ze.getName() + \" starts after central directory\");\n+            if (zipArchiveEntry.getDiskNumberStart() == this.centralDirectoryStartDiskNumber && zipArchiveEntry.getLocalHeaderOffset() > this.centralDirectoryStartRelativeOffset) {\n+                throw new IOException(\"local file header for \" + zipArchiveEntry.getName() + \" starts after central directory\");\n             }\n         }\n-        else if (ze.getLocalHeaderOffset() > this.centralDirectoryStartOffset) {\n-            throw new IOException(\"local file header for \" + ze.getName() + \" starts after central directory\");\n+        else if (zipArchiveEntry.getLocalHeaderOffset() > this.centralDirectoryStartOffset) {\n+            throw new IOException(\"local file header for \" + zipArchiveEntry.getName() + \" starts after central directory\");\n         }\n     }\n     \n-    private int[] setDataOffset(final ZipArchiveEntry ze) throws IOException {\n-        long offset = ze.getLocalHeaderOffset();\n+    private int[] setDataOffset(final ZipArchiveEntry zipArchiveEntry) throws IOException {\n+        long localHeaderOffset = zipArchiveEntry.getLocalHeaderOffset();\n         if (this.isSplitZipArchive) {\n-            ((ZipSplitReadOnlySeekableByteChannel)this.archive).position(ze.getDiskNumberStart(), offset + 26L);\n-            offset = this.archive.position() - 26L;\n+            ((ZipSplitReadOnlySeekableByteChannel)this.archive).position(zipArchiveEntry.getDiskNumberStart(), localHeaderOffset + 26L);\n+            localHeaderOffset = this.archive.position() - 26L;\n         }\n         else {\n-            this.archive.position(offset + 26L);\n+            this.archive.position(localHeaderOffset + 26L);\n         }\n         this.wordBbuf.rewind();\n         IOUtils.readFully((ReadableByteChannel)this.archive, this.wordBbuf);\n         this.wordBbuf.flip();\n         this.wordBbuf.get(this.shortBuf);\n-        final int fileNameLen = ZipShort.getValue(this.shortBuf);\n+        final int value = ZipShort.getValue(this.shortBuf);\n         this.wordBbuf.get(this.shortBuf);\n-        final int extraFieldLen = ZipShort.getValue(this.shortBuf);\n-        ze.setDataOffset(offset + 26L + 2L + 2L + fileNameLen + (long)extraFieldLen);\n-        if (ze.getDataOffset() + ze.getCompressedSize() > this.centralDirectoryStartOffset) {\n-            throw new IOException(\"data for \" + ze.getName() + \" overlaps with central directory.\");\n+        final int value2 = ZipShort.getValue(this.shortBuf);\n+        zipArchiveEntry.setDataOffset(localHeaderOffset + 26L + 2L + 2L + value + (long)value2);\n+        if (zipArchiveEntry.getDataOffset() + zipArchiveEntry.getCompressedSize() > this.centralDirectoryStartOffset) {\n+            throw new IOException(\"data for \" + zipArchiveEntry.getName() + \" overlaps with central directory.\");\n         }\n-        return new int[] { fileNameLen, extraFieldLen };\n+        return new int[] { value, value2 };\n     }\n     \n-    private void setSizesAndOffsetFromZip64Extra(final ZipArchiveEntry ze) throws IOException {\n-        final ZipExtraField extra = ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n-        if (extra != null && !(extra instanceof Zip64ExtendedInformationExtraField)) {\n+    private void setSizesAndOffsetFromZip64Extra(final ZipArchiveEntry zipArchiveEntry) throws IOException {\n+        final ZipExtraField extraField = zipArchiveEntry.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n+        if (extraField != null && !(extraField instanceof Zip64ExtendedInformationExtraField)) {\n             throw new ZipException(\"archive contains unparseable zip64 extra field\");\n         }\n-        final Zip64ExtendedInformationExtraField z64 = (Zip64ExtendedInformationExtraField)extra;\n-        if (z64 != null) {\n-            final boolean hasUncompressedSize = ze.getSize() == 4294967295L;\n-            final boolean hasCompressedSize = ze.getCompressedSize() == 4294967295L;\n-            final boolean hasRelativeHeaderOffset = ze.getLocalHeaderOffset() == 4294967295L;\n-            final boolean hasDiskStart = ze.getDiskNumberStart() == 65535L;\n-            z64.reparseCentralDirectoryData(hasUncompressedSize, hasCompressedSize, hasRelativeHeaderOffset, hasDiskStart);\n-            if (hasUncompressedSize) {\n-                final long size = z64.getSize().getLongValue();\n-                if (size < 0L) {\n+        final Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField = (Zip64ExtendedInformationExtraField)extraField;\n+        if (zip64ExtendedInformationExtraField != null) {\n+            final boolean b = zipArchiveEntry.getSize() == 4294967295L;\n+            final boolean b2 = zipArchiveEntry.getCompressedSize() == 4294967295L;\n+            final boolean b3 = zipArchiveEntry.getLocalHeaderOffset() == 4294967295L;\n+            final boolean b4 = zipArchiveEntry.getDiskNumberStart() == 65535L;\n+            zip64ExtendedInformationExtraField.reparseCentralDirectoryData(b, b2, b3, b4);\n+            if (b) {\n+                final long longValue = zip64ExtendedInformationExtraField.getSize().getLongValue();\n+                if (longValue < 0L) {\n                     throw new IOException(\"broken archive, entry with negative size\");\n                 }\n-                ze.setSize(size);\n+                zipArchiveEntry.setSize(longValue);\n             }\n-            else if (hasCompressedSize) {\n-                z64.setSize(new ZipEightByteInteger(ze.getSize()));\n+            else if (b2) {\n+                zip64ExtendedInformationExtraField.setSize(new ZipEightByteInteger(zipArchiveEntry.getSize()));\n             }\n-            if (hasCompressedSize) {\n-                final long size = z64.getCompressedSize().getLongValue();\n-                if (size < 0L) {\n+            if (b2) {\n+                final long longValue2 = zip64ExtendedInformationExtraField.getCompressedSize().getLongValue();\n+                if (longValue2 < 0L) {\n                     throw new IOException(\"broken archive, entry with negative compressed size\");\n                 }\n-                ze.setCompressedSize(size);\n+                zipArchiveEntry.setCompressedSize(longValue2);\n             }\n-            else if (hasUncompressedSize) {\n-                z64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));\n+            else if (b) {\n+                zip64ExtendedInformationExtraField.setCompressedSize(new ZipEightByteInteger(zipArchiveEntry.getCompressedSize()));\n             }\n-            if (hasRelativeHeaderOffset) {\n-                ze.setLocalHeaderOffset(z64.getRelativeHeaderOffset().getLongValue());\n+            if (b3) {\n+                zipArchiveEntry.setLocalHeaderOffset(zip64ExtendedInformationExtraField.getRelativeHeaderOffset().getLongValue());\n             }\n-            if (hasDiskStart) {\n-                ze.setDiskNumberStart(z64.getDiskStartNumber().getValue());\n+            if (b4) {\n+                zipArchiveEntry.setDiskNumberStart(zip64ExtendedInformationExtraField.getDiskStartNumber().getValue());\n             }\n         }\n     }\n     \n-    private void skipBytes(final int count) throws IOException {\n-        final long currentPosition = this.archive.position();\n-        final long newPosition = currentPosition + count;\n-        if (newPosition > this.archive.size()) {\n+    private void skipBytes(final int n) throws IOException {\n+        final long n2 = this.archive.position() + n;\n+        if (n2 > this.archive.size()) {\n             throw new EOFException();\n         }\n-        this.archive.position(newPosition);\n+        this.archive.position(n2);\n     }\n     \n     private boolean startsWithLocalFileHeader() throws IOException {\n         this.archive.position(this.firstLocalFileHeaderOffset);\n         this.wordBbuf.rewind();\n         IOUtils.readFully((ReadableByteChannel)this.archive, this.wordBbuf);\n         return Arrays.equals(this.wordBuf, ZipArchiveOutputStream.LFH_SIG);\n     }\n     \n-    private boolean tryToLocateSignature(final long minDistanceFromEnd, final long maxDistanceFromEnd, final byte[] sig) throws IOException {\n-        boolean found = false;\n-        long off = this.archive.size() - minDistanceFromEnd;\n-        final long stopSearching = Math.max(0L, this.archive.size() - maxDistanceFromEnd);\n-        if (off >= 0L) {\n-            while (off >= stopSearching) {\n-                this.archive.position(off);\n+    private boolean tryToLocateSignature(final long n, final long n2, final byte[] array) throws IOException {\n+        boolean b = false;\n+        long n3 = this.archive.size() - n;\n+        final long max = Math.max(0L, this.archive.size() - n2);\n+        if (n3 >= 0L) {\n+            while (n3 >= max) {\n+                this.archive.position(n3);\n                 try {\n                     this.wordBbuf.rewind();\n                     IOUtils.readFully((ReadableByteChannel)this.archive, this.wordBbuf);\n                     this.wordBbuf.flip();\n                 }\n                 catch (final EOFException ex) {\n                     break;\n                 }\n-                int curr = this.wordBbuf.get();\n-                if (curr == sig[0]) {\n-                    curr = this.wordBbuf.get();\n-                    if (curr == sig[1]) {\n-                        curr = this.wordBbuf.get();\n-                        if (curr == sig[2]) {\n-                            curr = this.wordBbuf.get();\n-                            if (curr == sig[3]) {\n-                                found = true;\n-                                break;\n-                            }\n-                        }\n-                    }\n+                if (this.wordBbuf.get() == array[0] && this.wordBbuf.get() == array[1] && this.wordBbuf.get() == array[2] && this.wordBbuf.get() == array[3]) {\n+                    b = true;\n+                    break;\n                 }\n-                --off;\n+                --n3;\n             }\n         }\n-        if (found) {\n-            this.archive.position(off);\n+        if (b) {\n+            this.archive.position(n3);\n         }\n-        return found;\n+        return b;\n     }\n     \n     static {\n         ONE_ZERO_BYTE = new byte[1];\n         CFH_SIG = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n         offsetComparator = Comparator.comparingLong(ZipArchiveEntry::getDiskNumberStart).thenComparingLong(ZipArchiveEntry::getLocalHeaderOffset);\n     }\n"}]}
