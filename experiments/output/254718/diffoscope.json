{"diffoscope-json-version": 1, "source1": "first/MurmurHash3.class", "source2": "second/MurmurHash3.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -25,374 +25,288 @@\n     private static final int M = 5;\n     private static final int N1 = 1390208809;\n     private static final int N2 = 944331445;\n     \n     private MurmurHash3() {\n     }\n     \n-    public static int hash32(final long data1, final long data2) {\n-        return hash32(data1, data2, 104729);\n+    public static int hash32(final long n, final long n2) {\n+        return hash32(n, n2, 104729);\n     }\n     \n-    public static int hash32(final long data1, final long data2, final int seed) {\n-        int hash = seed;\n-        final long r0 = Long.reverseBytes(data1);\n-        final long r2 = Long.reverseBytes(data2);\n-        hash = mix32((int)r0, hash);\n-        hash = mix32((int)(r0 >>> 32), hash);\n-        hash = mix32((int)r2, hash);\n-        hash = mix32((int)(r2 >>> 32), hash);\n-        hash ^= 0x10;\n-        return fmix32(hash);\n+    public static int hash32(final long i, final long j, final int n) {\n+        final long reverseBytes = Long.reverseBytes(i);\n+        final long reverseBytes2 = Long.reverseBytes(j);\n+        return fmix32(mix32((int)(reverseBytes2 >>> 32), mix32((int)reverseBytes2, mix32((int)(reverseBytes >>> 32), mix32((int)reverseBytes, n)))) ^ 0x10);\n     }\n     \n-    public static int hash32(final long data) {\n-        return hash32(data, 104729);\n+    public static int hash32(final long n) {\n+        return hash32(n, 104729);\n     }\n     \n-    public static int hash32(final long data, final int seed) {\n-        int hash = seed;\n-        final long r0 = Long.reverseBytes(data);\n-        hash = mix32((int)r0, hash);\n-        hash = mix32((int)(r0 >>> 32), hash);\n-        hash ^= 0x8;\n-        return fmix32(hash);\n+    public static int hash32(final long i, final int n) {\n+        final long reverseBytes = Long.reverseBytes(i);\n+        return fmix32(mix32((int)(reverseBytes >>> 32), mix32((int)reverseBytes, n)) ^ 0x8);\n     }\n     \n     @Deprecated\n-    public static int hash32(final byte[] data) {\n-        return hash32(data, 0, data.length, 104729);\n+    public static int hash32(final byte[] array) {\n+        return hash32(array, 0, array.length, 104729);\n     }\n     \n     @Deprecated\n-    public static int hash32(final String data) {\n-        final byte[] bytes = StringUtils.getBytesUtf8(data);\n-        return hash32(bytes, 0, bytes.length, 104729);\n+    public static int hash32(final String s) {\n+        final byte[] bytesUtf8 = StringUtils.getBytesUtf8(s);\n+        return hash32(bytesUtf8, 0, bytesUtf8.length, 104729);\n     }\n     \n     @Deprecated\n-    public static int hash32(final byte[] data, final int length) {\n-        return hash32(data, length, 104729);\n+    public static int hash32(final byte[] array, final int n) {\n+        return hash32(array, n, 104729);\n     }\n     \n     @Deprecated\n-    public static int hash32(final byte[] data, final int length, final int seed) {\n-        return hash32(data, 0, length, seed);\n+    public static int hash32(final byte[] array, final int n, final int n2) {\n+        return hash32(array, 0, n, n2);\n     }\n     \n     @Deprecated\n-    public static int hash32(final byte[] data, final int offset, final int length, final int seed) {\n-        int hash = seed;\n-        final int nblocks = length >> 2;\n-        for (int i = 0; i < nblocks; ++i) {\n-            final int index = offset + (i << 2);\n-            final int k = getLittleEndianInt(data, index);\n-            hash = mix32(k, hash);\n+    public static int hash32(final byte[] array, final int n, final int n2, final int n3) {\n+        int mix32 = n3;\n+        final int n4 = n2 >> 2;\n+        for (int i = 0; i < n4; ++i) {\n+            mix32 = mix32(getLittleEndianInt(array, n + (i << 2)), mix32);\n         }\n-        final int index2 = offset + (nblocks << 2);\n-        int k2 = 0;\n-        switch (offset + length - index2) {\n+        final int n5 = n + (n4 << 2);\n+        int n6 = 0;\n+        switch (n + n2 - n5) {\n             case 3: {\n-                k2 ^= data[index2 + 2] << 16;\n+                n6 ^= array[n5 + 2] << 16;\n             }\n             case 2: {\n-                k2 ^= data[index2 + 1] << 8;\n+                n6 ^= array[n5 + 1] << 8;\n             }\n             case 1: {\n-                k2 ^= data[index2];\n-                k2 *= -862048943;\n-                k2 = Integer.rotateLeft(k2, 15);\n-                k2 *= 461845907;\n-                hash ^= k2;\n+                mix32 ^= Integer.rotateLeft((n6 ^ array[n5]) * -862048943, 15) * 461845907;\n                 break;\n             }\n         }\n-        hash ^= length;\n-        return fmix32(hash);\n+        return fmix32(mix32 ^ n2);\n     }\n     \n-    public static int hash32x86(final byte[] data) {\n-        return hash32x86(data, 0, data.length, 0);\n+    public static int hash32x86(final byte[] array) {\n+        return hash32x86(array, 0, array.length, 0);\n     }\n     \n-    public static int hash32x86(final byte[] data, final int offset, final int length, final int seed) {\n-        int hash = seed;\n-        final int nblocks = length >> 2;\n-        for (int i = 0; i < nblocks; ++i) {\n-            final int index = offset + (i << 2);\n-            final int k = getLittleEndianInt(data, index);\n-            hash = mix32(k, hash);\n+    public static int hash32x86(final byte[] array, final int n, final int n2, final int n3) {\n+        int mix32 = n3;\n+        final int n4 = n2 >> 2;\n+        for (int i = 0; i < n4; ++i) {\n+            mix32 = mix32(getLittleEndianInt(array, n + (i << 2)), mix32);\n         }\n-        final int index2 = offset + (nblocks << 2);\n-        int k2 = 0;\n-        switch (offset + length - index2) {\n+        final int n5 = n + (n4 << 2);\n+        int n6 = 0;\n+        switch (n + n2 - n5) {\n             case 3: {\n-                k2 ^= (data[index2 + 2] & 0xFF) << 16;\n+                n6 ^= (array[n5 + 2] & 0xFF) << 16;\n             }\n             case 2: {\n-                k2 ^= (data[index2 + 1] & 0xFF) << 8;\n+                n6 ^= (array[n5 + 1] & 0xFF) << 8;\n             }\n             case 1: {\n-                k2 ^= (data[index2] & 0xFF);\n-                k2 *= -862048943;\n-                k2 = Integer.rotateLeft(k2, 15);\n-                k2 *= 461845907;\n-                hash ^= k2;\n+                mix32 ^= Integer.rotateLeft((n6 ^ (array[n5] & 0xFF)) * -862048943, 15) * 461845907;\n                 break;\n             }\n         }\n-        hash ^= length;\n-        return fmix32(hash);\n+        return fmix32(mix32 ^ n2);\n     }\n     \n     @Deprecated\n-    public static long hash64(final long data) {\n-        long hash = 104729L;\n-        long k = Long.reverseBytes(data);\n-        final int length = 8;\n-        k *= -8663945395140668459L;\n-        k = Long.rotateLeft(k, 31);\n-        k *= 5545529020109919103L;\n-        hash ^= k;\n-        hash = Long.rotateLeft(hash, 27) * 5L + 1390208809L;\n-        hash ^= 0x8L;\n-        hash = fmix64(hash);\n-        return hash;\n+    public static long hash64(final long i) {\n+        return fmix64(Long.rotateLeft(0x19919L ^ Long.rotateLeft(Long.reverseBytes(i) * -8663945395140668459L, 31) * 5545529020109919103L, 27) * 5L + 1390208809L ^ 0x8L);\n     }\n     \n     @Deprecated\n-    public static long hash64(final int data) {\n-        long k1 = (long)Integer.reverseBytes(data) & 0xFFFFFFFFL;\n-        final int length = 4;\n-        long hash = 104729L;\n-        k1 *= -8663945395140668459L;\n-        k1 = Long.rotateLeft(k1, 31);\n-        k1 *= 5545529020109919103L;\n-        hash ^= k1;\n-        hash ^= 0x4L;\n-        hash = fmix64(hash);\n-        return hash;\n+    public static long hash64(final int i) {\n+        return fmix64(0x19919L ^ Long.rotateLeft(((long)Integer.reverseBytes(i) & 0xFFFFFFFFL) * -8663945395140668459L, 31) * 5545529020109919103L ^ 0x4L);\n     }\n     \n     @Deprecated\n-    public static long hash64(final short data) {\n-        long hash = 104729L;\n-        long k1 = 0L;\n-        k1 ^= ((long)data & 0xFFL) << 8;\n-        k1 ^= ((long)((data & 0xFF00) >> 8) & 0xFFL);\n-        k1 *= -8663945395140668459L;\n-        k1 = Long.rotateLeft(k1, 31);\n-        k1 *= 5545529020109919103L;\n-        hash ^= k1;\n-        hash ^= 0x2L;\n-        hash = fmix64(hash);\n-        return hash;\n+    public static long hash64(final short n) {\n+        return fmix64(0x19919L ^ Long.rotateLeft((0x0L ^ ((long)n & 0xFFL) << 8 ^ ((long)((n & 0xFF00) >> 8) & 0xFFL)) * -8663945395140668459L, 31) * 5545529020109919103L ^ 0x2L);\n     }\n     \n     @Deprecated\n-    public static long hash64(final byte[] data) {\n-        return hash64(data, 0, data.length, 104729);\n+    public static long hash64(final byte[] array) {\n+        return hash64(array, 0, array.length, 104729);\n     }\n     \n     @Deprecated\n-    public static long hash64(final byte[] data, final int offset, final int length) {\n-        return hash64(data, offset, length, 104729);\n+    public static long hash64(final byte[] array, final int n, final int n2) {\n+        return hash64(array, n, n2, 104729);\n     }\n     \n     @Deprecated\n-    public static long hash64(final byte[] data, final int offset, final int length, final int seed) {\n-        long hash = (long)seed;\n-        final int nblocks = length >> 3;\n-        for (int i = 0; i < nblocks; ++i) {\n-            final int index = offset + (i << 3);\n-            long k = getLittleEndianLong(data, index);\n-            k *= -8663945395140668459L;\n-            k = Long.rotateLeft(k, 31);\n-            k *= 5545529020109919103L;\n-            hash ^= k;\n-            hash = Long.rotateLeft(hash, 27) * 5L + 1390208809L;\n+    public static long hash64(final byte[] array, final int n, final int n2, final int n3) {\n+        long n4 = (long)n3;\n+        final int n5 = n2 >> 3;\n+        for (int i = 0; i < n5; ++i) {\n+            n4 = Long.rotateLeft(n4 ^ Long.rotateLeft(getLittleEndianLong(array, n + (i << 3)) * -8663945395140668459L, 31) * 5545529020109919103L, 27) * 5L + 1390208809L;\n         }\n-        long k2 = 0L;\n-        final int index2 = offset + (nblocks << 3);\n-        switch (offset + length - index2) {\n+        long n6 = 0L;\n+        final int n7 = n + (n5 << 3);\n+        switch (n + n2 - n7) {\n             case 7: {\n-                k2 ^= ((long)data[index2 + 6] & 0xFFL) << 48;\n+                n6 ^= ((long)array[n7 + 6] & 0xFFL) << 48;\n             }\n             case 6: {\n-                k2 ^= ((long)data[index2 + 5] & 0xFFL) << 40;\n+                n6 ^= ((long)array[n7 + 5] & 0xFFL) << 40;\n             }\n             case 5: {\n-                k2 ^= ((long)data[index2 + 4] & 0xFFL) << 32;\n+                n6 ^= ((long)array[n7 + 4] & 0xFFL) << 32;\n             }\n             case 4: {\n-                k2 ^= ((long)data[index2 + 3] & 0xFFL) << 24;\n+                n6 ^= ((long)array[n7 + 3] & 0xFFL) << 24;\n             }\n             case 3: {\n-                k2 ^= ((long)data[index2 + 2] & 0xFFL) << 16;\n+                n6 ^= ((long)array[n7 + 2] & 0xFFL) << 16;\n             }\n             case 2: {\n-                k2 ^= ((long)data[index2 + 1] & 0xFFL) << 8;\n+                n6 ^= ((long)array[n7 + 1] & 0xFFL) << 8;\n             }\n             case 1: {\n-                k2 ^= ((long)data[index2] & 0xFFL);\n-                k2 *= -8663945395140668459L;\n-                k2 = Long.rotateLeft(k2, 31);\n-                k2 *= 5545529020109919103L;\n-                hash ^= k2;\n+                n4 ^= Long.rotateLeft((n6 ^ ((long)array[n7] & 0xFFL)) * -8663945395140668459L, 31) * 5545529020109919103L;\n                 break;\n             }\n         }\n-        hash ^= length;\n-        hash = fmix64(hash);\n-        return hash;\n+        return fmix64(n4 ^ (long)n2);\n     }\n     \n-    public static long[] hash128(final byte[] data) {\n-        return hash128(data, 0, data.length, 104729);\n+    public static long[] hash128(final byte[] array) {\n+        return hash128(array, 0, array.length, 104729);\n     }\n     \n-    public static long[] hash128x64(final byte[] data) {\n-        return hash128x64(data, 0, data.length, 0);\n+    public static long[] hash128x64(final byte[] array) {\n+        return hash128x64(array, 0, array.length, 0);\n     }\n     \n     @Deprecated\n-    public static long[] hash128(final String data) {\n-        final byte[] bytes = StringUtils.getBytesUtf8(data);\n-        return hash128(bytes, 0, bytes.length, 104729);\n+    public static long[] hash128(final String s) {\n+        final byte[] bytesUtf8 = StringUtils.getBytesUtf8(s);\n+        return hash128(bytesUtf8, 0, bytesUtf8.length, 104729);\n     }\n     \n     @Deprecated\n-    public static long[] hash128(final byte[] data, final int offset, final int length, final int seed) {\n-        return hash128x64Internal(data, offset, length, seed);\n+    public static long[] hash128(final byte[] array, final int n, final int n2, final int n3) {\n+        return hash128x64Internal(array, n, n2, n3);\n     }\n     \n-    public static long[] hash128x64(final byte[] data, final int offset, final int length, final int seed) {\n-        return hash128x64Internal(data, offset, length, (long)seed & 0xFFFFFFFFL);\n+    public static long[] hash128x64(final byte[] array, final int n, final int n2, final int n3) {\n+        return hash128x64Internal(array, n, n2, (long)n3 & 0xFFFFFFFFL);\n     }\n     \n-    private static long[] hash128x64Internal(final byte[] data, final int offset, final int length, final long seed) {\n-        long h1 = seed;\n-        long h2 = seed;\n-        final int nblocks = length >> 4;\n-        for (int i = 0; i < nblocks; ++i) {\n-            final int index = offset + (i << 4);\n-            long k1 = getLittleEndianLong(data, index);\n-            long k2 = getLittleEndianLong(data, index + 8);\n-            k1 *= -8663945395140668459L;\n-            k1 = Long.rotateLeft(k1, 31);\n-            k1 *= 5545529020109919103L;\n-            h1 ^= k1;\n-            h1 = Long.rotateLeft(h1, 27);\n-            h1 += h2;\n-            h1 = h1 * 5L + 1390208809L;\n-            k2 *= 5545529020109919103L;\n-            k2 = Long.rotateLeft(k2, 33);\n-            k2 *= -8663945395140668459L;\n-            h2 ^= k2;\n-            h2 = Long.rotateLeft(h2, 31);\n-            h2 += h1;\n-            h2 = h2 * 5L + 944331445L;\n+    private static long[] hash128x64Internal(final byte[] array, final int n, final int n2, final long n3) {\n+        long n4 = n3;\n+        long n5 = n3;\n+        final int n6 = n2 >> 4;\n+        for (int i = 0; i < n6; ++i) {\n+            final int n7 = n + (i << 4);\n+            final long littleEndianLong = getLittleEndianLong(array, n7);\n+            final long littleEndianLong2 = getLittleEndianLong(array, n7 + 8);\n+            n4 = (Long.rotateLeft(n4 ^ Long.rotateLeft(littleEndianLong * -8663945395140668459L, 31) * 5545529020109919103L, 27) + n5) * 5L + 1390208809L;\n+            n5 = (Long.rotateLeft(n5 ^ Long.rotateLeft(littleEndianLong2 * 5545529020109919103L, 33) * -8663945395140668459L, 31) + n4) * 5L + 944331445L;\n         }\n-        long k3 = 0L;\n-        long k4 = 0L;\n-        final int index2 = offset + (nblocks << 4);\n-        switch (offset + length - index2) {\n+        long n8 = 0L;\n+        long n9 = 0L;\n+        final int n10 = n + (n6 << 4);\n+        switch (n + n2 - n10) {\n             case 15: {\n-                k4 ^= ((long)data[index2 + 14] & 0xFFL) << 48;\n+                n9 ^= ((long)array[n10 + 14] & 0xFFL) << 48;\n             }\n             case 14: {\n-                k4 ^= ((long)data[index2 + 13] & 0xFFL) << 40;\n+                n9 ^= ((long)array[n10 + 13] & 0xFFL) << 40;\n             }\n             case 13: {\n-                k4 ^= ((long)data[index2 + 12] & 0xFFL) << 32;\n+                n9 ^= ((long)array[n10 + 12] & 0xFFL) << 32;\n             }\n             case 12: {\n-                k4 ^= ((long)data[index2 + 11] & 0xFFL) << 24;\n+                n9 ^= ((long)array[n10 + 11] & 0xFFL) << 24;\n             }\n             case 11: {\n-                k4 ^= ((long)data[index2 + 10] & 0xFFL) << 16;\n+                n9 ^= ((long)array[n10 + 10] & 0xFFL) << 16;\n             }\n             case 10: {\n-                k4 ^= ((long)data[index2 + 9] & 0xFFL) << 8;\n+                n9 ^= ((long)array[n10 + 9] & 0xFFL) << 8;\n             }\n             case 9: {\n-                k4 ^= (data[index2 + 8] & 0xFF);\n-                k4 *= 5545529020109919103L;\n-                k4 = Long.rotateLeft(k4, 33);\n-                k4 *= -8663945395140668459L;\n-                h2 ^= k4;\n+                n5 ^= Long.rotateLeft((n9 ^ (long)(array[n10 + 8] & 0xFF)) * 5545529020109919103L, 33) * -8663945395140668459L;\n             }\n             case 8: {\n-                k3 ^= ((long)data[index2 + 7] & 0xFFL) << 56;\n+                n8 ^= ((long)array[n10 + 7] & 0xFFL) << 56;\n             }\n             case 7: {\n-                k3 ^= ((long)data[index2 + 6] & 0xFFL) << 48;\n+                n8 ^= ((long)array[n10 + 6] & 0xFFL) << 48;\n             }\n             case 6: {\n-                k3 ^= ((long)data[index2 + 5] & 0xFFL) << 40;\n+                n8 ^= ((long)array[n10 + 5] & 0xFFL) << 40;\n             }\n             case 5: {\n-                k3 ^= ((long)data[index2 + 4] & 0xFFL) << 32;\n+                n8 ^= ((long)array[n10 + 4] & 0xFFL) << 32;\n             }\n             case 4: {\n-                k3 ^= ((long)data[index2 + 3] & 0xFFL) << 24;\n+                n8 ^= ((long)array[n10 + 3] & 0xFFL) << 24;\n             }\n             case 3: {\n-                k3 ^= ((long)data[index2 + 2] & 0xFFL) << 16;\n+                n8 ^= ((long)array[n10 + 2] & 0xFFL) << 16;\n             }\n             case 2: {\n-                k3 ^= ((long)data[index2 + 1] & 0xFFL) << 8;\n+                n8 ^= ((long)array[n10 + 1] & 0xFFL) << 8;\n             }\n             case 1: {\n-                k3 ^= (data[index2] & 0xFF);\n-                k3 *= -8663945395140668459L;\n-                k3 = Long.rotateLeft(k3, 31);\n-                k3 *= 5545529020109919103L;\n-                h1 ^= k3;\n+                n4 ^= Long.rotateLeft((n8 ^ (long)(array[n10] & 0xFF)) * -8663945395140668459L, 31) * 5545529020109919103L;\n                 break;\n             }\n         }\n-        h1 ^= length;\n-        h2 ^= length;\n-        h1 += h2;\n-        h2 += h1;\n-        h1 = fmix64(h1);\n-        h2 = fmix64(h2);\n-        h1 += h2;\n-        h2 += h1;\n-        return new long[] { h1, h2 };\n-    }\n-    \n-    private static long getLittleEndianLong(final byte[] data, final int index) {\n-        return ((long)data[index] & 0xFFL) | ((long)data[index + 1] & 0xFFL) << 8 | ((long)data[index + 2] & 0xFFL) << 16 | ((long)data[index + 3] & 0xFFL) << 24 | ((long)data[index + 4] & 0xFFL) << 32 | ((long)data[index + 5] & 0xFFL) << 40 | ((long)data[index + 6] & 0xFFL) << 48 | ((long)data[index + 7] & 0xFFL) << 56;\n-    }\n-    \n-    private static int getLittleEndianInt(final byte[] data, final int index) {\n-        return (data[index] & 0xFF) | (data[index + 1] & 0xFF) << 8 | (data[index + 2] & 0xFF) << 16 | (data[index + 3] & 0xFF) << 24;\n-    }\n-    \n-    private static int mix32(int k, int hash) {\n-        k *= -862048943;\n-        k = Integer.rotateLeft(k, 15);\n-        k *= 461845907;\n-        hash ^= k;\n-        return Integer.rotateLeft(hash, 13) * 5 - 430675100;\n-    }\n-    \n-    private static int fmix32(int hash) {\n-        hash ^= hash >>> 16;\n-        hash *= -2048144789;\n-        hash ^= hash >>> 13;\n-        hash *= -1028477387;\n-        hash ^= hash >>> 16;\n-        return hash;\n-    }\n-    \n-    private static long fmix64(long hash) {\n-        hash ^= hash >>> 33;\n-        hash *= -49064778989728563L;\n-        hash ^= hash >>> 33;\n-        hash *= -4265267296055464877L;\n-        hash ^= hash >>> 33;\n-        return hash;\n+        final long n11 = n4 ^ (long)n2;\n+        final long n12 = n5 ^ (long)n2;\n+        final long n13 = n11 + n12;\n+        final long n14 = n12 + n13;\n+        final long fmix64 = fmix64(n13);\n+        final long fmix65 = fmix64(n14);\n+        final long n15 = fmix64 + fmix65;\n+        return new long[] { n15, fmix65 + n15 };\n+    }\n+    \n+    private static long getLittleEndianLong(final byte[] array, final int n) {\n+        return ((long)array[n] & 0xFFL) | ((long)array[n + 1] & 0xFFL) << 8 | ((long)array[n + 2] & 0xFFL) << 16 | ((long)array[n + 3] & 0xFFL) << 24 | ((long)array[n + 4] & 0xFFL) << 32 | ((long)array[n + 5] & 0xFFL) << 40 | ((long)array[n + 6] & 0xFFL) << 48 | ((long)array[n + 7] & 0xFFL) << 56;\n+    }\n+    \n+    private static int getLittleEndianInt(final byte[] array, final int n) {\n+        return (array[n] & 0xFF) | (array[n + 1] & 0xFF) << 8 | (array[n + 2] & 0xFF) << 16 | (array[n + 3] & 0xFF) << 24;\n+    }\n+    \n+    private static int mix32(int rotateLeft, int i) {\n+        rotateLeft *= -862048943;\n+        rotateLeft = Integer.rotateLeft(rotateLeft, 15);\n+        rotateLeft *= 461845907;\n+        i ^= rotateLeft;\n+        return Integer.rotateLeft(i, 13) * 5 - 430675100;\n+    }\n+    \n+    private static int fmix32(int n) {\n+        n ^= n >>> 16;\n+        n *= -2048144789;\n+        n ^= n >>> 13;\n+        n *= -1028477387;\n+        n ^= n >>> 16;\n+        return n;\n+    }\n+    \n+    private static long fmix64(long n) {\n+        n ^= n >>> 33;\n+        n *= -49064778989728563L;\n+        n ^= n >>> 33;\n+        n *= -4265267296055464877L;\n+        n ^= n >>> 33;\n+        return n;\n     }\n }\n"}]}
