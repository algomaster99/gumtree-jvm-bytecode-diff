{"diffoscope-json-version": 1, "source1": "first/SeekableInMemoryByteChannel.class", "source2": "second/SeekableInMemoryByteChannel.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -22,119 +22,118 @@\n         this.size = data.length;\n     }\n     \n     public SeekableInMemoryByteChannel() {\n         this(ByteUtils.EMPTY_BYTE_ARRAY);\n     }\n     \n-    public SeekableInMemoryByteChannel(final int size) {\n-        this(new byte[size]);\n+    public SeekableInMemoryByteChannel(final int n) {\n+        this(new byte[n]);\n     }\n     \n     @Override\n     public long position() {\n         return this.position;\n     }\n     \n     @Override\n-    public SeekableByteChannel position(final long newPosition) throws IOException {\n+    public SeekableByteChannel position(final long n) throws IOException {\n         this.ensureOpen();\n-        if (newPosition < 0L || newPosition > 2147483647L) {\n+        if (n < 0L || n > 2147483647L) {\n             throw new IOException(\"Position has to be in range 0.. 2147483647\");\n         }\n-        this.position = (int)newPosition;\n+        this.position = (int)n;\n         return this;\n     }\n     \n     @Override\n     public long size() {\n         return this.size;\n     }\n     \n     @Override\n-    public SeekableByteChannel truncate(final long newSize) {\n-        if (newSize < 0L || newSize > 2147483647L) {\n+    public SeekableByteChannel truncate(final long n) {\n+        if (n < 0L || n > 2147483647L) {\n             throw new IllegalArgumentException(\"Size has to be in range 0.. 2147483647\");\n         }\n-        if (this.size > newSize) {\n-            this.size = (int)newSize;\n+        if (this.size > n) {\n+            this.size = (int)n;\n         }\n-        if (this.position > newSize) {\n-            this.position = (int)newSize;\n+        if (this.position > n) {\n+            this.position = (int)n;\n         }\n         return this;\n     }\n     \n     @Override\n-    public int read(final ByteBuffer buf) throws IOException {\n+    public int read(final ByteBuffer byteBuffer) throws IOException {\n         this.ensureOpen();\n-        int wanted = buf.remaining();\n-        final int possible = this.size - this.position;\n-        if (possible <= 0) {\n+        int remaining = byteBuffer.remaining();\n+        final int n = this.size - this.position;\n+        if (n <= 0) {\n             return -1;\n         }\n-        if (wanted > possible) {\n-            wanted = possible;\n+        if (remaining > n) {\n+            remaining = n;\n         }\n-        buf.put(this.data, this.position, wanted);\n-        this.position += wanted;\n-        return wanted;\n+        byteBuffer.put(this.data, this.position, remaining);\n+        this.position += remaining;\n+        return remaining;\n     }\n     \n     @Override\n     public void close() {\n         this.closed.set(true);\n     }\n     \n     @Override\n     public boolean isOpen() {\n         return !this.closed.get();\n     }\n     \n     @Override\n-    public int write(final ByteBuffer b) throws IOException {\n+    public int write(final ByteBuffer byteBuffer) throws IOException {\n         this.ensureOpen();\n-        int wanted = b.remaining();\n-        final int possibleWithoutResize = this.size - this.position;\n-        if (wanted > possibleWithoutResize) {\n-            final int newSize = this.position + wanted;\n-            if (newSize < 0) {\n+        int remaining = byteBuffer.remaining();\n+        if (remaining > this.size - this.position) {\n+            final int n = this.position + remaining;\n+            if (n < 0) {\n                 this.resize(Integer.MAX_VALUE);\n-                wanted = Integer.MAX_VALUE - this.position;\n+                remaining = Integer.MAX_VALUE - this.position;\n             }\n             else {\n-                this.resize(newSize);\n+                this.resize(n);\n             }\n         }\n-        b.get(this.data, this.position, wanted);\n-        this.position += wanted;\n+        byteBuffer.get(this.data, this.position, remaining);\n+        this.position += remaining;\n         if (this.size < this.position) {\n             this.size = this.position;\n         }\n-        return wanted;\n+        return remaining;\n     }\n     \n     public byte[] array() {\n         return this.data;\n     }\n     \n-    private void resize(final int newLength) {\n-        int len = this.data.length;\n-        if (len <= 0) {\n-            len = 1;\n-        }\n-        if (newLength < 1073741823) {\n-            while (len < newLength) {\n-                len <<= 1;\n+    private void resize(final int n) {\n+        int i = this.data.length;\n+        if (i <= 0) {\n+            i = 1;\n+        }\n+        if (n < 1073741823) {\n+            while (i < n) {\n+                i <<= 1;\n             }\n         }\n         else {\n-            len = newLength;\n+            i = n;\n         }\n-        this.data = Arrays.copyOf(this.data, len);\n+        this.data = Arrays.copyOf(this.data, i);\n     }\n     \n     private void ensureOpen() throws ClosedChannelException {\n         if (!this.isOpen()) {\n             throw new ClosedChannelException();\n         }\n     }\n"}]}
