{"diffoscope-json-version": 1, "source1": "first/JavadocDetailNodeParser.class", "source2": "second/JavadocDetailNodeParser.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,13 +1,12 @@\n \n package com.puppycrawl.tools.checkstyle;\n \n import org.antlr.v4.runtime.CommonToken;\n import java.util.Iterator;\n-import java.util.Deque;\n import java.util.List;\n import org.antlr.v4.runtime.misc.Interval;\n import java.util.ArrayDeque;\n import org.antlr.v4.runtime.BufferedTokenStream;\n import org.antlr.v4.runtime.ParserRuleContext;\n import org.antlr.v4.runtime.tree.TerminalNode;\n import com.puppycrawl.tools.checkstyle.checks.javadoc.JavadocNodeImpl;\n@@ -17,275 +16,255 @@\n import org.antlr.v4.runtime.TokenSource;\n import org.antlr.v4.runtime.CommonTokenStream;\n import org.antlr.v4.runtime.CharStream;\n import com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocLexer;\n import org.antlr.v4.runtime.CharStreams;\n import org.antlr.v4.runtime.Token;\n import com.puppycrawl.tools.checkstyle.api.DetailNode;\n-import org.antlr.v4.runtime.tree.ParseTree;\n import org.antlr.v4.runtime.misc.ParseCancellationException;\n import com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocParser;\n import org.antlr.v4.runtime.RecognitionException;\n import org.antlr.v4.runtime.NoViableAltException;\n import org.antlr.v4.runtime.FailedPredicateException;\n+import org.antlr.v4.runtime.tree.ParseTree;\n import com.puppycrawl.tools.checkstyle.utils.JavadocUtil;\n import com.puppycrawl.tools.checkstyle.api.DetailAST;\n \n public class JavadocDetailNodeParser\n {\n     public static final String MSG_JAVADOC_MISSED_HTML_CLOSE = \"javadoc.missed.html.close\";\n     public static final String MSG_JAVADOC_WRONG_SINGLETON_TAG = \"javadoc.wrong.singleton.html.tag\";\n     public static final String MSG_JAVADOC_PARSE_RULE_ERROR = \"javadoc.parse.rule.error\";\n     public static final String MSG_UNCLOSED_HTML_TAG = \"javadoc.unclosedHtml\";\n     private static final String JAVADOC_START = \"/**\";\n     private int blockCommentLineNumber;\n     \n-    public JavadocDetailNodeParser.ParseStatus parseJavadocAsDetailNode(final DetailAST javadocCommentAst) {\n-        this.blockCommentLineNumber = javadocCommentAst.getLineNo();\n-        final String javadocComment = JavadocUtil.getJavadocCommentContent(javadocCommentAst);\n-        final JavadocDetailNodeParser.DescriptiveErrorListener errorListener = new JavadocDetailNodeParser.DescriptiveErrorListener();\n-        errorListener.setOffset(javadocCommentAst.getLineNo() - 1);\n-        final JavadocDetailNodeParser.ParseStatus result = new JavadocDetailNodeParser.ParseStatus();\n+    public JavadocDetailNodeParser.ParseStatus parseJavadocAsDetailNode(final DetailAST detailAST) {\n+        this.blockCommentLineNumber = detailAST.getLineNo();\n+        final String javadocCommentContent = JavadocUtil.getJavadocCommentContent(detailAST);\n+        final JavadocDetailNodeParser.DescriptiveErrorListener descriptiveErrorListener = new JavadocDetailNodeParser.DescriptiveErrorListener();\n+        descriptiveErrorListener.setOffset(detailAST.getLineNo() - 1);\n+        final JavadocDetailNodeParser.ParseStatus parseStatus = new JavadocDetailNodeParser.ParseStatus();\n         try {\n-            final JavadocParser javadocParser = createJavadocParser(javadocComment, errorListener);\n-            final ParseTree javadocParseTree = (ParseTree)javadocParser.javadoc();\n-            final DetailNode tree = this.convertParseTreeToDetailNode(javadocParseTree);\n-            this.adjustFirstLineToJavadocIndent(tree, javadocCommentAst.getColumnNo() + \"/**\".length());\n-            result.setTree(tree);\n-            result.firstNonTightHtmlTag = getFirstNonTightHtmlTag(javadocParser, errorListener.offset);\n+            final JavadocParser javadocParser = createJavadocParser(javadocCommentContent, descriptiveErrorListener);\n+            final DetailNode convertParseTreeToDetailNode = this.convertParseTreeToDetailNode((ParseTree)javadocParser.javadoc());\n+            this.adjustFirstLineToJavadocIndent(convertParseTreeToDetailNode, detailAST.getColumnNo() + \"/**\".length());\n+            parseStatus.setTree(convertParseTreeToDetailNode);\n+            parseStatus.firstNonTightHtmlTag = getFirstNonTightHtmlTag(javadocParser, descriptiveErrorListener.offset);\n         }\n         catch (final ParseCancellationException | IllegalArgumentException ex) {\n-            JavadocDetailNodeParser.ParseErrorMessage parseErrorMessage = null;\n-            if (ex.getCause() instanceof FailedPredicateException || ex.getCause() instanceof NoViableAltException) {\n-                final RecognitionException recognitionEx = (RecognitionException)ex.getCause();\n-                if (recognitionEx.getCtx() instanceof JavadocParser.HtmlTagContext) {\n-                    final Token htmlTagNameStart = getMissedHtmlTag(recognitionEx);\n-                    parseErrorMessage = new JavadocDetailNodeParser.ParseErrorMessage(errorListener.offset + htmlTagNameStart.getLine(), \"javadoc.missed.html.close\", new Object[] { Integer.valueOf(htmlTagNameStart.getCharPositionInLine()), htmlTagNameStart.getText() });\n+            JavadocDetailNodeParser.ParseErrorMessage errorMessage = null;\n+            if (((Throwable)ex).getCause() instanceof FailedPredicateException || ((Throwable)ex).getCause() instanceof NoViableAltException) {\n+                final RecognitionException ex2 = (RecognitionException)((Throwable)ex).getCause();\n+                if (ex2.getCtx() instanceof JavadocParser.HtmlTagContext) {\n+                    final Token missedHtmlTag = getMissedHtmlTag(ex2);\n+                    errorMessage = new JavadocDetailNodeParser.ParseErrorMessage(descriptiveErrorListener.offset + missedHtmlTag.getLine(), \"javadoc.missed.html.close\", new Object[] { Integer.valueOf(missedHtmlTag.getCharPositionInLine()), missedHtmlTag.getText() });\n                 }\n             }\n-            if (parseErrorMessage == null) {\n-                parseErrorMessage = errorListener.getErrorMessage();\n+            if (errorMessage == null) {\n+                errorMessage = descriptiveErrorListener.getErrorMessage();\n             }\n-            result.setParseErrorMessage(parseErrorMessage);\n+            parseStatus.setParseErrorMessage(errorMessage);\n         }\n-        return result;\n+        return parseStatus;\n     }\n     \n-    private static JavadocParser createJavadocParser(final String blockComment, final JavadocDetailNodeParser.DescriptiveErrorListener errorListener) {\n-        final JavadocLexer lexer = new JavadocLexer((CharStream)CharStreams.fromString(blockComment), true);\n-        final CommonTokenStream tokens = new CommonTokenStream((TokenSource)lexer);\n-        final JavadocParser parser = new JavadocParser((TokenStream)tokens);\n-        parser.removeErrorListeners();\n-        parser.addErrorListener((ANTLRErrorListener)errorListener);\n-        parser.setErrorHandler((ANTLRErrorStrategy)new CheckstyleParserErrorStrategy());\n-        return parser;\n-    }\n-    \n-    private DetailNode convertParseTreeToDetailNode(final ParseTree parseTreeNode) {\n-        JavadocNodeImpl currentJavadocParent;\n-        final JavadocNodeImpl rootJavadocNode = currentJavadocParent = this.createRootJavadocNode(parseTreeNode);\n-        ParseTree parseTreeParent = parseTreeNode;\n-        while (currentJavadocParent != null) {\n-            if (currentJavadocParent.getType() == 10074) {\n-                currentJavadocParent.setChildren((DetailNode[])JavadocNodeImpl.EMPTY_DETAIL_NODE_ARRAY);\n+    private static JavadocParser createJavadocParser(final String s, final JavadocDetailNodeParser.DescriptiveErrorListener descriptiveErrorListener) {\n+        final JavadocParser javadocParser = new JavadocParser((TokenStream)new CommonTokenStream((TokenSource)new JavadocLexer((CharStream)CharStreams.fromString(s), true)));\n+        javadocParser.removeErrorListeners();\n+        javadocParser.addErrorListener((ANTLRErrorListener)descriptiveErrorListener);\n+        javadocParser.setErrorHandler((ANTLRErrorStrategy)new CheckstyleParserErrorStrategy());\n+        return javadocParser;\n+    }\n+    \n+    private DetailNode convertParseTreeToDetailNode(final ParseTree parseTree) {\n+        JavadocNodeImpl rootJavadocNode;\n+        final JavadocNodeImpl javadocNodeImpl = rootJavadocNode = this.createRootJavadocNode(parseTree);\n+        ParseTree parseTree2 = parseTree;\n+        while (rootJavadocNode != null) {\n+            if (rootJavadocNode.getType() == 10074) {\n+                rootJavadocNode.setChildren((DetailNode[])JavadocNodeImpl.EMPTY_DETAIL_NODE_ARRAY);\n             }\n-            final JavadocNodeImpl[] children = (JavadocNodeImpl[])currentJavadocParent.getChildren();\n-            this.insertChildrenNodes(children, parseTreeParent);\n-            if (children.length > 0) {\n-                currentJavadocParent = children[0];\n-                parseTreeParent = parseTreeParent.getChild(0);\n+            final JavadocNodeImpl[] array = (JavadocNodeImpl[])rootJavadocNode.getChildren();\n+            this.insertChildrenNodes(array, parseTree2);\n+            if (array.length > 0) {\n+                rootJavadocNode = array[0];\n+                parseTree2 = parseTree2.getChild(0);\n             }\n             else {\n-                JavadocNodeImpl nextJavadocSibling = (JavadocNodeImpl)JavadocUtil.getNextSibling((DetailNode)currentJavadocParent);\n-                ParseTree nextParseTreeSibling = getNextSibling(parseTreeParent);\n-                while (nextJavadocSibling == null) {\n-                    currentJavadocParent = (JavadocNodeImpl)currentJavadocParent.getParent();\n-                    parseTreeParent = parseTreeParent.getParent();\n-                    if (currentJavadocParent == null) {\n+                JavadocNodeImpl javadocNodeImpl2 = (JavadocNodeImpl)JavadocUtil.getNextSibling((DetailNode)rootJavadocNode);\n+                ParseTree parseTree3 = getNextSibling(parseTree2);\n+                while (javadocNodeImpl2 == null) {\n+                    rootJavadocNode = (JavadocNodeImpl)rootJavadocNode.getParent();\n+                    parseTree2 = parseTree2.getParent();\n+                    if (rootJavadocNode == null) {\n                         break;\n                     }\n-                    nextJavadocSibling = (JavadocNodeImpl)JavadocUtil.getNextSibling((DetailNode)currentJavadocParent);\n-                    nextParseTreeSibling = getNextSibling(parseTreeParent);\n+                    javadocNodeImpl2 = (JavadocNodeImpl)JavadocUtil.getNextSibling((DetailNode)rootJavadocNode);\n+                    parseTree3 = getNextSibling(parseTree2);\n                 }\n-                currentJavadocParent = nextJavadocSibling;\n-                parseTreeParent = nextParseTreeSibling;\n+                rootJavadocNode = javadocNodeImpl2;\n+                parseTree2 = parseTree3;\n             }\n         }\n-        return (DetailNode)rootJavadocNode;\n+        return (DetailNode)javadocNodeImpl;\n     }\n     \n-    private void insertChildrenNodes(final JavadocNodeImpl[] nodes, final ParseTree parseTreeParent) {\n-        for (int i = 0; i < nodes.length; ++i) {\n-            final JavadocNodeImpl currentJavadocNode = nodes[i];\n-            final ParseTree currentParseTreeNodeChild = parseTreeParent.getChild(i);\n-            final JavadocNodeImpl[] subChildren = this.createChildrenNodes((DetailNode)currentJavadocNode, currentParseTreeNodeChild);\n-            currentJavadocNode.setChildren((DetailNode[])subChildren);\n+    private void insertChildrenNodes(final JavadocNodeImpl[] array, final ParseTree parseTree) {\n+        for (int i = 0; i < array.length; ++i) {\n+            final JavadocNodeImpl javadocNodeImpl = array[i];\n+            javadocNodeImpl.setChildren((DetailNode[])this.createChildrenNodes((DetailNode)javadocNodeImpl, parseTree.getChild(i)));\n         }\n     }\n     \n-    private JavadocNodeImpl[] createChildrenNodes(final DetailNode parentJavadocNode, final ParseTree parseTreeNode) {\n-        final JavadocNodeImpl[] children = new JavadocNodeImpl[parseTreeNode.getChildCount()];\n-        for (int j = 0; j < children.length; ++j) {\n-            final JavadocNodeImpl child = this.createJavadocNode(parseTreeNode.getChild(j), parentJavadocNode, j);\n-            children[j] = child;\n+    private JavadocNodeImpl[] createChildrenNodes(final DetailNode detailNode, final ParseTree parseTree) {\n+        final JavadocNodeImpl[] array = new JavadocNodeImpl[parseTree.getChildCount()];\n+        for (int i = 0; i < array.length; ++i) {\n+            array[i] = this.createJavadocNode(parseTree.getChild(i), detailNode, i);\n         }\n-        return children;\n+        return array;\n     }\n     \n-    private JavadocNodeImpl createRootJavadocNode(final ParseTree parseTreeNode) {\n-        final JavadocNodeImpl rootJavadocNode = this.createJavadocNode(parseTreeNode, null, -1);\n-        final int childCount = parseTreeNode.getChildCount();\n-        final DetailNode[] children = rootJavadocNode.getChildren();\n+    private JavadocNodeImpl createRootJavadocNode(final ParseTree parseTree) {\n+        final JavadocNodeImpl javadocNode = this.createJavadocNode(parseTree, null, -1);\n+        final int childCount = parseTree.getChildCount();\n+        final DetailNode[] children = javadocNode.getChildren();\n         for (int i = 0; i < childCount; ++i) {\n-            final JavadocNodeImpl child = this.createJavadocNode(parseTreeNode.getChild(i), (DetailNode)rootJavadocNode, i);\n-            children[i] = (DetailNode)child;\n+            children[i] = (DetailNode)this.createJavadocNode(parseTree.getChild(i), (DetailNode)javadocNode, i);\n         }\n-        rootJavadocNode.setChildren(children);\n-        return rootJavadocNode;\n+        javadocNode.setChildren(children);\n+        return javadocNode;\n     }\n     \n     private JavadocNodeImpl createJavadocNode(final ParseTree parseTree, final DetailNode parent, final int index) {\n-        final JavadocNodeImpl node = new JavadocNodeImpl();\n+        final JavadocNodeImpl javadocNodeImpl = new JavadocNodeImpl();\n         if (parseTree.getChildCount() == 0 || \"Text\".equals(getNodeClassNameWithoutContext(parseTree))) {\n-            node.setText(parseTree.getText());\n+            javadocNodeImpl.setText(parseTree.getText());\n         }\n         else {\n-            node.setText(getFormattedNodeClassNameWithoutContext(parseTree));\n+            javadocNodeImpl.setText(getFormattedNodeClassNameWithoutContext(parseTree));\n         }\n-        node.setColumnNumber(getColumn(parseTree));\n-        node.setLineNumber(getLine(parseTree) + this.blockCommentLineNumber);\n-        node.setIndex(index);\n-        node.setType(getTokenType(parseTree));\n-        node.setParent(parent);\n-        node.setChildren((DetailNode[])new JavadocNodeImpl[parseTree.getChildCount()]);\n-        return node;\n-    }\n-    \n-    private void adjustFirstLineToJavadocIndent(final DetailNode tree, final int javadocColumnNumber) {\n-        if (tree.getLineNumber() == this.blockCommentLineNumber) {\n-            ((JavadocNodeImpl)tree).setColumnNumber(tree.getColumnNumber() + javadocColumnNumber);\n-            final DetailNode[] children2;\n-            final DetailNode[] children = children2 = tree.getChildren();\n-            for (final DetailNode child : children2) {\n-                this.adjustFirstLineToJavadocIndent(child, javadocColumnNumber);\n+        javadocNodeImpl.setColumnNumber(getColumn(parseTree));\n+        javadocNodeImpl.setLineNumber(getLine(parseTree) + this.blockCommentLineNumber);\n+        javadocNodeImpl.setIndex(index);\n+        javadocNodeImpl.setType(getTokenType(parseTree));\n+        javadocNodeImpl.setParent(parent);\n+        javadocNodeImpl.setChildren((DetailNode[])new JavadocNodeImpl[parseTree.getChildCount()]);\n+        return javadocNodeImpl;\n+    }\n+    \n+    private void adjustFirstLineToJavadocIndent(final DetailNode detailNode, final int n) {\n+        if (detailNode.getLineNumber() == this.blockCommentLineNumber) {\n+            ((JavadocNodeImpl)detailNode).setColumnNumber(detailNode.getColumnNumber() + n);\n+            final DetailNode[] children = detailNode.getChildren();\n+            for (int length = children.length, i = 0; i < length; ++i) {\n+                this.adjustFirstLineToJavadocIndent(children[i], n);\n             }\n         }\n     }\n     \n-    private static int getLine(final ParseTree tree) {\n-        int line;\n-        if (tree instanceof TerminalNode) {\n-            line = ((TerminalNode)tree).getSymbol().getLine() - 1;\n+    private static int getLine(final ParseTree parseTree) {\n+        int n;\n+        if (parseTree instanceof TerminalNode) {\n+            n = ((TerminalNode)parseTree).getSymbol().getLine() - 1;\n         }\n         else {\n-            final ParserRuleContext rule = (ParserRuleContext)tree;\n-            line = rule.start.getLine() - 1;\n+            n = ((ParserRuleContext)parseTree).start.getLine() - 1;\n         }\n-        return line;\n+        return n;\n     }\n     \n-    private static int getColumn(final ParseTree tree) {\n-        int column;\n-        if (tree instanceof TerminalNode) {\n-            column = ((TerminalNode)tree).getSymbol().getCharPositionInLine();\n+    private static int getColumn(final ParseTree parseTree) {\n+        int n;\n+        if (parseTree instanceof TerminalNode) {\n+            n = ((TerminalNode)parseTree).getSymbol().getCharPositionInLine();\n         }\n         else {\n-            final ParserRuleContext rule = (ParserRuleContext)tree;\n-            column = rule.start.getCharPositionInLine();\n+            n = ((ParserRuleContext)parseTree).start.getCharPositionInLine();\n         }\n-        return column;\n+        return n;\n     }\n     \n-    private static ParseTree getNextSibling(final ParseTree node) {\n-        ParseTree nextSibling = null;\n-        if (node.getParent() != null) {\n-            final ParseTree parent = node.getParent();\n-            int index = 0;\n-            while (true) {\n-                final ParseTree currentNode = parent.getChild(index);\n-                if (currentNode.equals(node)) {\n-                    break;\n-                }\n-                ++index;\n-            }\n-            nextSibling = parent.getChild(index + 1);\n+    private static ParseTree getNextSibling(final ParseTree obj) {\n+        ParseTree child = null;\n+        if (obj.getParent() != null) {\n+            ParseTree parent;\n+            int n;\n+            for (parent = obj.getParent(), n = 0; !parent.getChild(n).equals(obj); ++n) {}\n+            child = parent.getChild(n + 1);\n         }\n-        return nextSibling;\n+        return child;\n     }\n     \n-    private static int getTokenType(final ParseTree node) {\n-        int tokenType;\n-        if (node.getChildCount() == 0) {\n-            tokenType = ((TerminalNode)node).getSymbol().getType();\n+    private static int getTokenType(final ParseTree parseTree) {\n+        int n;\n+        if (parseTree.getChildCount() == 0) {\n+            n = ((TerminalNode)parseTree).getSymbol().getType();\n         }\n         else {\n-            final String className = getNodeClassNameWithoutContext(node);\n-            tokenType = JavadocUtil.getTokenId(convertUpperCamelToUpperUnderscore(className));\n+            n = JavadocUtil.getTokenId(convertUpperCamelToUpperUnderscore(getNodeClassNameWithoutContext(parseTree)));\n         }\n-        return tokenType;\n+        return n;\n     }\n     \n-    private static String getFormattedNodeClassNameWithoutContext(final ParseTree node) {\n-        final String classNameWithoutContext = getNodeClassNameWithoutContext(node);\n-        return convertUpperCamelToUpperUnderscore(classNameWithoutContext);\n+    private static String getFormattedNodeClassNameWithoutContext(final ParseTree parseTree) {\n+        return convertUpperCamelToUpperUnderscore(getNodeClassNameWithoutContext(parseTree));\n     }\n     \n-    private static String getNodeClassNameWithoutContext(final ParseTree node) {\n-        final String className = node.getClass().getSimpleName();\n-        final int contextLength = 7;\n-        return className.substring(0, className.length() - 7);\n+    private static String getNodeClassNameWithoutContext(final ParseTree parseTree) {\n+        final String simpleName = parseTree.getClass().getSimpleName();\n+        return simpleName.substring(0, simpleName.length() - 7);\n     }\n     \n-    private static Token getMissedHtmlTag(final RecognitionException exception) {\n-        Token htmlTagNameStart = null;\n-        final Interval sourceInterval = exception.getCtx().getSourceInterval();\n-        final List<Token> tokenList = ((BufferedTokenStream)exception.getInputStream()).getTokens(sourceInterval.a, sourceInterval.b);\n-        final Deque<Token> stack = new ArrayDeque<Token>();\n-        int prevTokenType = -1;\n-        for (final Token token : tokenList) {\n-            final int tokenType = token.getType();\n-            if (tokenType == 100 && prevTokenType == 5) {\n-                stack.push(token);\n+    private static Token getMissedHtmlTag(final RecognitionException ex) {\n+        Token token = null;\n+        final Interval sourceInterval = ex.getCtx().getSourceInterval();\n+        final List tokens = ((BufferedTokenStream)ex.getInputStream()).getTokens(sourceInterval.a, sourceInterval.b);\n+        final ArrayDeque arrayDeque = new ArrayDeque();\n+        int n = -1;\n+        for (final Token token2 : tokens) {\n+            final int type = token2.getType();\n+            if (type == 100 && n == 5) {\n+                arrayDeque.push(token2);\n             }\n-            else if (tokenType == 100 && !stack.isEmpty()) {\n-                if (((Token)stack.peek()).getText().equals(token.getText())) {\n-                    stack.pop();\n+            else if (type == 100 && !arrayDeque.isEmpty()) {\n+                if (((Token)arrayDeque.peek()).getText().equals(token2.getText())) {\n+                    arrayDeque.pop();\n                 }\n                 else {\n-                    htmlTagNameStart = stack.pop();\n+                    token = (Token)arrayDeque.pop();\n                 }\n             }\n-            prevTokenType = tokenType;\n+            n = type;\n         }\n-        if (htmlTagNameStart == null) {\n-            htmlTagNameStart = stack.pop();\n+        if (token == null) {\n+            token = (Token)arrayDeque.pop();\n         }\n-        return htmlTagNameStart;\n+        return token;\n     }\n     \n-    private static Token getFirstNonTightHtmlTag(final JavadocParser javadocParser, final int javadocLineOffset) {\n+    private static Token getFirstNonTightHtmlTag(final JavadocParser javadocParser, final int n) {\n         final ParserRuleContext nonTightTagStartContext = javadocParser.nonTightTagStartContext;\n-        CommonToken offendingToken;\n+        CommonToken commonToken;\n         if (nonTightTagStartContext == null) {\n-            offendingToken = null;\n+            commonToken = null;\n         }\n         else {\n-            final Token token = ((TerminalNode)nonTightTagStartContext.getChild(1)).getSymbol();\n-            offendingToken = new CommonToken(token);\n-            offendingToken.setLine(offendingToken.getLine() + javadocLineOffset);\n-        }\n-        return (Token)offendingToken;\n+            commonToken = new CommonToken(((TerminalNode)nonTightTagStartContext.getChild(1)).getSymbol());\n+            commonToken.setLine(commonToken.getLine() + n);\n+        }\n+        return (Token)commonToken;\n     }\n     \n-    private static String convertUpperCamelToUpperUnderscore(final String text) {\n-        final StringBuilder result = new StringBuilder(20);\n-        boolean first = true;\n-        for (final char letter : text.toCharArray()) {\n-            if (!first && Character.isUpperCase(letter)) {\n-                result.append('_');\n+    private static String convertUpperCamelToUpperUnderscore(final String s) {\n+        final StringBuilder sb = new StringBuilder(20);\n+        int n = 1;\n+        for (final char c : s.toCharArray()) {\n+            if (n == 0 && Character.isUpperCase(c)) {\n+                sb.append('_');\n             }\n-            result.append(Character.toUpperCase(letter));\n-            first = false;\n+            sb.append(Character.toUpperCase(c));\n+            n = 0;\n         }\n-        return result.toString();\n+        return sb.toString();\n     }\n }\n"}]}
