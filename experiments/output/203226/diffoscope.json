{"diffoscope-json-version": 1, "source1": "first/SegmentConstantPool.class", "source2": "second/SegmentConstantPool.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -28,165 +28,159 @@\n     protected static final String REGEX_MATCH_INIT = \"^<init>.*\";\n     \n     public SegmentConstantPool(final CpBands bands) {\n         this.arrayCache = new SegmentConstantPoolArrayCache();\n         this.bands = bands;\n     }\n     \n-    public ClassFileEntry getValue(final int cp, final long value) throws Pack200Exception {\n-        final int index = (int)value;\n-        if (index == -1) {\n+    public ClassFileEntry getValue(final int i, final long n) throws Pack200Exception {\n+        final int n2 = (int)n;\n+        if (n2 == -1) {\n             return null;\n         }\n-        if (index < 0) {\n+        if (n2 < 0) {\n             throw new Pack200Exception(\"Cannot have a negative range\");\n         }\n-        if (cp == 1) {\n-            return (ClassFileEntry)this.bands.cpUTF8Value(index);\n+        if (i == 1) {\n+            return (ClassFileEntry)this.bands.cpUTF8Value(n2);\n         }\n-        if (cp == 2) {\n-            return (ClassFileEntry)this.bands.cpIntegerValue(index);\n+        if (i == 2) {\n+            return (ClassFileEntry)this.bands.cpIntegerValue(n2);\n         }\n-        if (cp == 3) {\n-            return (ClassFileEntry)this.bands.cpFloatValue(index);\n+        if (i == 3) {\n+            return (ClassFileEntry)this.bands.cpFloatValue(n2);\n         }\n-        if (cp == 4) {\n-            return (ClassFileEntry)this.bands.cpLongValue(index);\n+        if (i == 4) {\n+            return (ClassFileEntry)this.bands.cpLongValue(n2);\n         }\n-        if (cp == 5) {\n-            return (ClassFileEntry)this.bands.cpDoubleValue(index);\n+        if (i == 5) {\n+            return (ClassFileEntry)this.bands.cpDoubleValue(n2);\n         }\n-        if (cp == 6) {\n-            return (ClassFileEntry)this.bands.cpStringValue(index);\n+        if (i == 6) {\n+            return (ClassFileEntry)this.bands.cpStringValue(n2);\n         }\n-        if (cp == 7) {\n-            return (ClassFileEntry)this.bands.cpClassValue(index);\n+        if (i == 7) {\n+            return (ClassFileEntry)this.bands.cpClassValue(n2);\n         }\n-        if (cp == 8) {\n-            return (ClassFileEntry)this.bands.cpSignatureValue(index);\n+        if (i == 8) {\n+            return (ClassFileEntry)this.bands.cpSignatureValue(n2);\n         }\n-        if (cp == 9) {\n-            return (ClassFileEntry)this.bands.cpNameAndTypeValue(index);\n+        if (i == 9) {\n+            return (ClassFileEntry)this.bands.cpNameAndTypeValue(n2);\n         }\n-        throw new Error(\"Tried to get a value I don't know about: \" + cp);\n+        throw new Error(\"Tried to get a value I don't know about: \" + i);\n     }\n     \n-    public ConstantPoolEntry getClassSpecificPoolEntry(final int cp, final long desiredIndex, final String desiredClassName) throws Pack200Exception {\n-        final int index = (int)desiredIndex;\n-        int realIndex = -1;\n-        String[] array = null;\n-        if (cp == 10) {\n+    public ConstantPoolEntry getClassSpecificPoolEntry(final int i, final long n, final String s) throws Pack200Exception {\n+        final int n2 = (int)n;\n+        String[] array;\n+        if (i == 10) {\n             array = this.bands.getCpFieldClass();\n         }\n-        else if (cp == 11) {\n+        else if (i == 11) {\n             array = this.bands.getCpMethodClass();\n         }\n         else {\n-            if (cp != 12) {\n-                throw new Error(\"Don't know how to handle \" + cp);\n+            if (i != 12) {\n+                throw new Error(\"Don't know how to handle \" + i);\n             }\n             array = this.bands.getCpIMethodClass();\n         }\n-        realIndex = this.matchSpecificPoolEntryIndex(array, desiredClassName, index);\n-        return this.getConstantPoolEntry(cp, realIndex);\n+        return this.getConstantPoolEntry(i, this.matchSpecificPoolEntryIndex(array, s, n2));\n     }\n     \n-    public ConstantPoolEntry getClassPoolEntry(final String name) {\n-        final String[] classes = this.bands.getCpClass();\n-        final int index = this.matchSpecificPoolEntryIndex(classes, name, 0);\n-        if (index == -1) {\n+    public ConstantPoolEntry getClassPoolEntry(final String s) {\n+        final int matchSpecificPoolEntryIndex = this.matchSpecificPoolEntryIndex(this.bands.getCpClass(), s, 0);\n+        if (matchSpecificPoolEntryIndex == -1) {\n             return null;\n         }\n         try {\n-            return this.getConstantPoolEntry(7, index);\n+            return this.getConstantPoolEntry(7, matchSpecificPoolEntryIndex);\n         }\n         catch (final Pack200Exception ex) {\n             throw new Error(\"Error getting class pool entry\");\n         }\n     }\n     \n-    public ConstantPoolEntry getInitMethodPoolEntry(final int cp, final long value, final String desiredClassName) throws Pack200Exception {\n-        int realIndex = -1;\n-        final String desiredRegex = \"^<init>.*\";\n-        if (cp != 11) {\n+    public ConstantPoolEntry getInitMethodPoolEntry(final int n, final long n2, final String s) throws Pack200Exception {\n+        if (n != 11) {\n             throw new Error(\"Nothing but CP_METHOD can be an <init>\");\n         }\n-        realIndex = this.matchSpecificPoolEntryIndex(this.bands.getCpMethodClass(), this.bands.getCpMethodDescriptor(), desiredClassName, \"^<init>.*\", (int)value);\n-        return this.getConstantPoolEntry(cp, realIndex);\n+        return this.getConstantPoolEntry(n, this.matchSpecificPoolEntryIndex(this.bands.getCpMethodClass(), this.bands.getCpMethodDescriptor(), s, \"^<init>.*\", (int)n2));\n     }\n     \n-    protected int matchSpecificPoolEntryIndex(final String[] nameArray, final String compareString, final int desiredIndex) {\n-        return this.matchSpecificPoolEntryIndex(nameArray, nameArray, compareString, \".*\", desiredIndex);\n+    protected int matchSpecificPoolEntryIndex(final String[] array, final String s, final int n) {\n+        return this.matchSpecificPoolEntryIndex(array, array, s, \".*\", n);\n     }\n     \n-    protected int matchSpecificPoolEntryIndex(final String[] primaryArray, final String[] secondaryArray, final String primaryCompareString, final String secondaryCompareRegex, final int desiredIndex) {\n-        int instanceCount = -1;\n-        final List indexList = this.arrayCache.indexesForArrayKey(primaryArray, primaryCompareString);\n-        if (indexList.isEmpty()) {\n+    protected int matchSpecificPoolEntryIndex(final String[] array, final String[] array2, final String s, final String s2, final int n) {\n+        int n2 = -1;\n+        final List indexesForArrayKey = this.arrayCache.indexesForArrayKey(array, s);\n+        if (indexesForArrayKey.isEmpty()) {\n             return -1;\n         }\n-        for (int index = 0; index < indexList.size(); ++index) {\n-            final int arrayIndex = (int)Integer.valueOf(indexList.get(index));\n-            if (regexMatches(secondaryCompareRegex, secondaryArray[arrayIndex]) && ++instanceCount == desiredIndex) {\n-                return arrayIndex;\n+        for (int i = 0; i < indexesForArrayKey.size(); ++i) {\n+            final int intValue = (int)Integer.valueOf(indexesForArrayKey.get(i));\n+            if (regexMatches(s2, array2[intValue]) && ++n2 == n) {\n+                return intValue;\n             }\n         }\n         return -1;\n     }\n     \n-    protected static boolean regexMatches(final String regexString, final String compareString) {\n-        if (\".*\".equals(regexString)) {\n+    protected static boolean regexMatches(final String str, final String s) {\n+        if (\".*\".equals(str)) {\n             return true;\n         }\n-        if (\"^<init>.*\".equals(regexString)) {\n-            return compareString.length() >= \"<init>\".length() && \"<init>\".equals(compareString.substring(0, \"<init>\".length()));\n+        if (\"^<init>.*\".equals(str)) {\n+            return s.length() >= \"<init>\".length() && \"<init>\".equals(s.substring(0, \"<init>\".length()));\n         }\n-        throw new Error(\"regex trying to match a pattern I don't know: \" + regexString);\n+        throw new Error(\"regex trying to match a pattern I don't know: \" + str);\n     }\n     \n-    public ConstantPoolEntry getConstantPoolEntry(final int cp, final long value) throws Pack200Exception {\n-        final int index = (int)value;\n-        if (index == -1) {\n+    public ConstantPoolEntry getConstantPoolEntry(final int n, final long n2) throws Pack200Exception {\n+        final int n3 = (int)n2;\n+        if (n3 == -1) {\n             return null;\n         }\n-        if (index < 0) {\n+        if (n3 < 0) {\n             throw new Pack200Exception(\"Cannot have a negative range\");\n         }\n-        if (cp == 1) {\n-            return (ConstantPoolEntry)this.bands.cpUTF8Value(index);\n+        if (n == 1) {\n+            return (ConstantPoolEntry)this.bands.cpUTF8Value(n3);\n         }\n-        if (cp == 2) {\n-            return (ConstantPoolEntry)this.bands.cpIntegerValue(index);\n+        if (n == 2) {\n+            return (ConstantPoolEntry)this.bands.cpIntegerValue(n3);\n         }\n-        if (cp == 3) {\n-            return (ConstantPoolEntry)this.bands.cpFloatValue(index);\n+        if (n == 3) {\n+            return (ConstantPoolEntry)this.bands.cpFloatValue(n3);\n         }\n-        if (cp == 4) {\n-            return (ConstantPoolEntry)this.bands.cpLongValue(index);\n+        if (n == 4) {\n+            return (ConstantPoolEntry)this.bands.cpLongValue(n3);\n         }\n-        if (cp == 5) {\n-            return (ConstantPoolEntry)this.bands.cpDoubleValue(index);\n+        if (n == 5) {\n+            return (ConstantPoolEntry)this.bands.cpDoubleValue(n3);\n         }\n-        if (cp == 6) {\n-            return (ConstantPoolEntry)this.bands.cpStringValue(index);\n+        if (n == 6) {\n+            return (ConstantPoolEntry)this.bands.cpStringValue(n3);\n         }\n-        if (cp == 7) {\n-            return (ConstantPoolEntry)this.bands.cpClassValue(index);\n+        if (n == 7) {\n+            return (ConstantPoolEntry)this.bands.cpClassValue(n3);\n         }\n-        if (cp == 8) {\n+        if (n == 8) {\n             throw new Error(\"I don't know what to do with signatures yet\");\n         }\n-        if (cp == 9) {\n+        if (n == 9) {\n             throw new Error(\"I don't know what to do with descriptors yet\");\n         }\n-        if (cp == 10) {\n-            return (ConstantPoolEntry)this.bands.cpFieldValue(index);\n+        if (n == 10) {\n+            return (ConstantPoolEntry)this.bands.cpFieldValue(n3);\n         }\n-        if (cp == 11) {\n-            return (ConstantPoolEntry)this.bands.cpMethodValue(index);\n+        if (n == 11) {\n+            return (ConstantPoolEntry)this.bands.cpMethodValue(n3);\n         }\n-        if (cp == 12) {\n-            return (ConstantPoolEntry)this.bands.cpIMethodValue(index);\n+        if (n == 12) {\n+            return (ConstantPoolEntry)this.bands.cpIMethodValue(n3);\n         }\n         throw new Error(\"Get value incomplete\");\n     }\n }\n"}]}
