{"diffoscope-json-version": 1, "source1": "first/MethodUtils.class", "source2": "second/MethodUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,12 +1,11 @@\n \n package org.apache.commons.lang3.reflect;\n \n import java.lang.annotation.Annotation;\n-import java.lang.reflect.TypeVariable;\n import java.util.Map;\n import java.lang.reflect.Type;\n import java.util.Arrays;\n import java.util.LinkedHashSet;\n import java.util.Set;\n import java.util.Objects;\n import org.apache.commons.lang3.Validate;\n@@ -24,400 +23,381 @@\n import java.lang.reflect.Method;\n import java.util.Comparator;\n \n public class MethodUtils\n {\n     private static final Comparator<Method> METHOD_BY_SIGNATURE;\n     \n-    public static Object invokeMethod(final Object object, final String methodName) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n-        return invokeMethod(object, methodName, ArrayUtils.EMPTY_OBJECT_ARRAY, null);\n+    public static Object invokeMethod(final Object o, final String s) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        return invokeMethod(o, s, ArrayUtils.EMPTY_OBJECT_ARRAY, null);\n     }\n     \n-    public static Object invokeMethod(final Object object, final boolean forceAccess, final String methodName) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n-        return invokeMethod(object, forceAccess, methodName, ArrayUtils.EMPTY_OBJECT_ARRAY, null);\n+    public static Object invokeMethod(final Object o, final boolean b, final String s) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        return invokeMethod(o, b, s, ArrayUtils.EMPTY_OBJECT_ARRAY, null);\n     }\n     \n-    public static Object invokeMethod(final Object object, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n-        args = ArrayUtils.nullToEmpty(args);\n-        final Class<?>[] parameterTypes = ClassUtils.toClass(args);\n-        return invokeMethod(object, methodName, args, parameterTypes);\n+    public static Object invokeMethod(final Object o, final String s, Object... nullToEmpty) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        nullToEmpty = ArrayUtils.nullToEmpty(nullToEmpty);\n+        return invokeMethod(o, s, nullToEmpty, ClassUtils.toClass(nullToEmpty));\n     }\n     \n-    public static Object invokeMethod(final Object object, final boolean forceAccess, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n-        args = ArrayUtils.nullToEmpty(args);\n-        final Class<?>[] parameterTypes = ClassUtils.toClass(args);\n-        return invokeMethod(object, forceAccess, methodName, args, parameterTypes);\n+    public static Object invokeMethod(final Object o, final boolean b, final String s, Object... nullToEmpty) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        nullToEmpty = ArrayUtils.nullToEmpty(nullToEmpty);\n+        return invokeMethod(o, b, s, nullToEmpty, ClassUtils.toClass(nullToEmpty));\n     }\n     \n-    public static Object invokeMethod(final Object object, final boolean forceAccess, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n-        parameterTypes = ArrayUtils.nullToEmpty((Class[])parameterTypes);\n+    public static Object invokeMethod(final Object obj, final boolean b, final String str, Object[] args, final Class<?>[] array) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        final Class[] nullToEmpty = ArrayUtils.nullToEmpty((Class[])array);\n         args = ArrayUtils.nullToEmpty(args);\n-        Method method = null;\n-        String messagePrefix;\n-        if (forceAccess) {\n-            messagePrefix = \"No such method: \";\n-            method = getMatchingMethod(object.getClass(), methodName, parameterTypes);\n+        String str2;\n+        Method method;\n+        if (b) {\n+            str2 = \"No such method: \";\n+            method = getMatchingMethod(obj.getClass(), str, (Class<?>[])nullToEmpty);\n             if (method != null && !method.isAccessible()) {\n                 method.setAccessible(true);\n             }\n         }\n         else {\n-            messagePrefix = \"No such accessible method: \";\n-            method = getMatchingAccessibleMethod(object.getClass(), methodName, parameterTypes);\n+            str2 = \"No such accessible method: \";\n+            method = getMatchingAccessibleMethod(obj.getClass(), str, (Class<?>[])nullToEmpty);\n         }\n         if (method == null) {\n-            throw new NoSuchMethodException(messagePrefix + methodName + \"() on object: \" + object.getClass().getName());\n+            throw new NoSuchMethodException(str2 + str + \"() on object: \" + obj.getClass().getName());\n         }\n         args = toVarArgs(method, args);\n-        return method.invoke(object, args);\n+        return method.invoke(obj, args);\n     }\n     \n-    public static Object invokeMethod(final Object object, final String methodName, final Object[] args, final Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n-        return invokeMethod(object, false, methodName, args, parameterTypes);\n+    public static Object invokeMethod(final Object o, final String s, final Object[] array, final Class<?>[] array2) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        return invokeMethod(o, false, s, array, array2);\n     }\n     \n-    public static Object invokeExactMethod(final Object object, final String methodName) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n-        return invokeExactMethod(object, methodName, ArrayUtils.EMPTY_OBJECT_ARRAY, null);\n+    public static Object invokeExactMethod(final Object o, final String s) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        return invokeExactMethod(o, s, ArrayUtils.EMPTY_OBJECT_ARRAY, null);\n     }\n     \n-    public static Object invokeExactMethod(final Object object, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n-        args = ArrayUtils.nullToEmpty(args);\n-        final Class<?>[] parameterTypes = ClassUtils.toClass(args);\n-        return invokeExactMethod(object, methodName, args, parameterTypes);\n+    public static Object invokeExactMethod(final Object o, final String s, Object... nullToEmpty) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        nullToEmpty = ArrayUtils.nullToEmpty(nullToEmpty);\n+        return invokeExactMethod(o, s, nullToEmpty, ClassUtils.toClass(nullToEmpty));\n     }\n     \n-    public static Object invokeExactMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n-        args = ArrayUtils.nullToEmpty(args);\n-        parameterTypes = ArrayUtils.nullToEmpty((Class[])parameterTypes);\n-        final Method method = getAccessibleMethod(object.getClass(), methodName, parameterTypes);\n-        if (method == null) {\n-            throw new NoSuchMethodException(\"No such accessible method: \" + methodName + \"() on object: \" + object.getClass().getName());\n+    public static Object invokeExactMethod(final Object obj, final String str, Object[] nullToEmpty, final Class<?>[] array) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        nullToEmpty = ArrayUtils.nullToEmpty(nullToEmpty);\n+        final Method accessibleMethod = getAccessibleMethod(obj.getClass(), str, (Class<?>[])ArrayUtils.nullToEmpty((Class[])array));\n+        if (accessibleMethod == null) {\n+            throw new NoSuchMethodException(\"No such accessible method: \" + str + \"() on object: \" + obj.getClass().getName());\n         }\n-        return method.invoke(object, args);\n+        return accessibleMethod.invoke(obj, nullToEmpty);\n     }\n     \n-    public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n-        args = ArrayUtils.nullToEmpty(args);\n-        parameterTypes = ArrayUtils.nullToEmpty((Class[])parameterTypes);\n-        final Method method = getAccessibleMethod(cls, methodName, parameterTypes);\n-        if (method == null) {\n-            throw new NoSuchMethodException(\"No such accessible method: \" + methodName + \"() on class: \" + cls.getName());\n+    public static Object invokeExactStaticMethod(final Class<?> clazz, final String str, Object[] nullToEmpty, final Class<?>[] array) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        nullToEmpty = ArrayUtils.nullToEmpty(nullToEmpty);\n+        final Method accessibleMethod = getAccessibleMethod(clazz, str, (Class<?>[])ArrayUtils.nullToEmpty((Class[])array));\n+        if (accessibleMethod == null) {\n+            throw new NoSuchMethodException(\"No such accessible method: \" + str + \"() on class: \" + clazz.getName());\n         }\n-        return method.invoke(null, args);\n+        return accessibleMethod.invoke(null, nullToEmpty);\n     }\n     \n-    public static Object invokeStaticMethod(final Class<?> cls, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n-        args = ArrayUtils.nullToEmpty(args);\n-        final Class<?>[] parameterTypes = ClassUtils.toClass(args);\n-        return invokeStaticMethod(cls, methodName, args, parameterTypes);\n+    public static Object invokeStaticMethod(final Class<?> clazz, final String s, Object... nullToEmpty) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        nullToEmpty = ArrayUtils.nullToEmpty(nullToEmpty);\n+        return invokeStaticMethod(clazz, s, nullToEmpty, ClassUtils.toClass(nullToEmpty));\n     }\n     \n-    public static Object invokeStaticMethod(final Class<?> cls, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+    public static Object invokeStaticMethod(final Class<?> clazz, final String str, Object[] args, final Class<?>[] array) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n         args = ArrayUtils.nullToEmpty(args);\n-        parameterTypes = ArrayUtils.nullToEmpty((Class[])parameterTypes);\n-        final Method method = getMatchingAccessibleMethod(cls, methodName, parameterTypes);\n-        if (method == null) {\n-            throw new NoSuchMethodException(\"No such accessible method: \" + methodName + \"() on class: \" + cls.getName());\n+        final Method matchingAccessibleMethod = getMatchingAccessibleMethod(clazz, str, (Class<?>[])ArrayUtils.nullToEmpty((Class[])array));\n+        if (matchingAccessibleMethod == null) {\n+            throw new NoSuchMethodException(\"No such accessible method: \" + str + \"() on class: \" + clazz.getName());\n         }\n-        args = toVarArgs(method, args);\n-        return method.invoke(null, args);\n+        args = toVarArgs(matchingAccessibleMethod, args);\n+        return matchingAccessibleMethod.invoke(null, args);\n     }\n     \n-    private static Object[] toVarArgs(final Method method, Object[] args) {\n+    private static Object[] toVarArgs(final Method method, Object[] varArgs) {\n         if (method.isVarArgs()) {\n-            final Class<?>[] methodParameterTypes = method.getParameterTypes();\n-            args = getVarArgs(args, methodParameterTypes);\n+            varArgs = getVarArgs(varArgs, method.getParameterTypes());\n         }\n-        return args;\n+        return varArgs;\n     }\n     \n-    static Object[] getVarArgs(final Object[] args, final Class<?>[] methodParameterTypes) {\n-        if (args.length == methodParameterTypes.length && (args[args.length - 1] == null || args[args.length - 1].getClass().equals(methodParameterTypes[methodParameterTypes.length - 1]))) {\n-            return args;\n+    static Object[] getVarArgs(final Object[] array, final Class<?>[] array2) {\n+        if (array.length == array2.length && (array[array.length - 1] == null || array[array.length - 1].getClass().equals(array2[array2.length - 1]))) {\n+            return array;\n         }\n-        final Object[] newArgs = new Object[methodParameterTypes.length];\n-        System.arraycopy(args, 0, newArgs, 0, methodParameterTypes.length - 1);\n-        final Class<?> varArgComponentType = methodParameterTypes[methodParameterTypes.length - 1].getComponentType();\n-        final int varArgLength = args.length - methodParameterTypes.length + 1;\n-        Object varArgsArray = Array.newInstance(ClassUtils.primitiveToWrapper((Class)varArgComponentType), varArgLength);\n-        System.arraycopy(args, methodParameterTypes.length - 1, varArgsArray, 0, varArgLength);\n-        if (varArgComponentType.isPrimitive()) {\n-            varArgsArray = ArrayUtils.toPrimitive(varArgsArray);\n+        final Object[] array3 = new Object[array2.length];\n+        System.arraycopy(array, 0, array3, 0, array2.length - 1);\n+        final Class<?> componentType = array2[array2.length - 1].getComponentType();\n+        final int length = array.length - array2.length + 1;\n+        Object o = Array.newInstance(ClassUtils.primitiveToWrapper((Class)componentType), length);\n+        System.arraycopy(array, array2.length - 1, o, 0, length);\n+        if (componentType.isPrimitive()) {\n+            o = ArrayUtils.toPrimitive(o);\n         }\n-        newArgs[methodParameterTypes.length - 1] = varArgsArray;\n-        return newArgs;\n+        array3[array2.length - 1] = o;\n+        return array3;\n     }\n     \n-    public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n-        args = ArrayUtils.nullToEmpty(args);\n-        final Class<?>[] parameterTypes = ClassUtils.toClass(args);\n-        return invokeExactStaticMethod(cls, methodName, args, parameterTypes);\n+    public static Object invokeExactStaticMethod(final Class<?> clazz, final String s, Object... nullToEmpty) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        nullToEmpty = ArrayUtils.nullToEmpty(nullToEmpty);\n+        return invokeExactStaticMethod(clazz, s, nullToEmpty, ClassUtils.toClass(nullToEmpty));\n     }\n     \n-    public static Method getAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) {\n+    public static Method getAccessibleMethod(final Class<?> clazz, final String name, final Class<?>... parameterTypes) {\n         try {\n-            return getAccessibleMethod(cls.getMethod(methodName, parameterTypes));\n+            return getAccessibleMethod(clazz.getMethod(name, (Class[])parameterTypes));\n         }\n-        catch (final NoSuchMethodException e) {\n+        catch (final NoSuchMethodException ex) {\n             return null;\n         }\n     }\n     \n     public static Method getAccessibleMethod(Method method) {\n         if (!MemberUtils.isAccessible((Member)method)) {\n             return null;\n         }\n-        final Class<?> cls = method.getDeclaringClass();\n-        if (Modifier.isPublic(cls.getModifiers())) {\n+        final Class<?> declaringClass = method.getDeclaringClass();\n+        if (Modifier.isPublic(declaringClass.getModifiers())) {\n             return method;\n         }\n-        final String methodName = method.getName();\n+        final String name = method.getName();\n         final Class<?>[] parameterTypes = method.getParameterTypes();\n-        method = getAccessibleMethodFromInterfaceNest(cls, methodName, parameterTypes);\n+        method = getAccessibleMethodFromInterfaceNest(declaringClass, name, parameterTypes);\n         if (method == null) {\n-            method = getAccessibleMethodFromSuperclass(cls, methodName, parameterTypes);\n+            method = getAccessibleMethodFromSuperclass(declaringClass, name, parameterTypes);\n         }\n         return method;\n     }\n     \n-    private static Method getAccessibleMethodFromSuperclass(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) {\n-        for (Class<?> parentClass = cls.getSuperclass(); parentClass != null; parentClass = parentClass.getSuperclass()) {\n-            if (Modifier.isPublic(parentClass.getModifiers())) {\n+    private static Method getAccessibleMethodFromSuperclass(final Class<?> clazz, final String name, final Class<?>... parameterTypes) {\n+        for (Class<?> clazz2 = clazz.getSuperclass(); clazz2 != null; clazz2 = clazz2.getSuperclass()) {\n+            if (Modifier.isPublic(clazz2.getModifiers())) {\n                 try {\n-                    return parentClass.getMethod(methodName, parameterTypes);\n+                    return clazz2.getMethod(name, (Class[])parameterTypes);\n                 }\n-                catch (final NoSuchMethodException e) {\n+                catch (final NoSuchMethodException ex) {\n                     return null;\n                 }\n             }\n         }\n         return null;\n     }\n     \n-    private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls, final String methodName, final Class<?>... parameterTypes) {\n-        while (cls != null) {\n-            final Class<?>[] interfaces2;\n-            final Class<?>[] interfaces = interfaces2 = cls.getInterfaces();\n-            for (final Class<?> anInterface : interfaces2) {\n-                if (Modifier.isPublic(anInterface.getModifiers())) {\n+    private static Method getAccessibleMethodFromInterfaceNest(Class<?> superclass, final String name, final Class<?>... parameterTypes) {\n+        while (superclass != null) {\n+            for (final Class clazz : superclass.getInterfaces()) {\n+                if (Modifier.isPublic(clazz.getModifiers())) {\n                     try {\n-                        return anInterface.getDeclaredMethod(methodName, parameterTypes);\n+                        return clazz.getDeclaredMethod(name, (Class[])parameterTypes);\n                     }\n                     catch (final NoSuchMethodException ex) {\n-                        final Method method = getAccessibleMethodFromInterfaceNest(anInterface, methodName, parameterTypes);\n-                        if (method != null) {\n-                            return method;\n+                        final Method accessibleMethodFromInterfaceNest = getAccessibleMethodFromInterfaceNest(clazz, name, parameterTypes);\n+                        if (accessibleMethodFromInterfaceNest != null) {\n+                            return accessibleMethodFromInterfaceNest;\n                         }\n                     }\n                 }\n             }\n-            cls = cls.getSuperclass();\n+            superclass = superclass.getSuperclass();\n         }\n         return null;\n     }\n     \n-    public static Method getMatchingAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) {\n+    public static Method getMatchingAccessibleMethod(final Class<?> clazz, final String s, final Class<?>... parameterTypes) {\n         try {\n-            final Method method = cls.getMethod(methodName, parameterTypes);\n+            final Method method = clazz.getMethod(s, (Class[])parameterTypes);\n             MemberUtils.setAccessibleWorkaround((AccessibleObject)method);\n             return method;\n         }\n         catch (final NoSuchMethodException ex) {\n-            final Method[] methods = cls.getMethods();\n-            final List<Method> matchingMethods = new ArrayList<Method>();\n+            final Method[] methods = clazz.getMethods();\n+            final ArrayList list = new ArrayList();\n             for (final Method method2 : methods) {\n-                if (method2.getName().equals(methodName) && MemberUtils.isMatchingMethod(method2, (Class[])parameterTypes)) {\n-                    matchingMethods.add(method2);\n+                if (method2.getName().equals(s) && MemberUtils.isMatchingMethod(method2, (Class[])parameterTypes)) {\n+                    list.add(method2);\n                 }\n             }\n-            Collections.sort(matchingMethods, MethodUtils.METHOD_BY_SIGNATURE);\n-            Method bestMatch = null;\n-            for (final Method method3 : matchingMethods) {\n-                final Method accessibleMethod = getAccessibleMethod(method3);\n-                if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareMethodFit(accessibleMethod, bestMatch, (Class[])parameterTypes) < 0)) {\n-                    bestMatch = accessibleMethod;\n-                }\n-            }\n-            if (bestMatch != null) {\n-                MemberUtils.setAccessibleWorkaround((AccessibleObject)bestMatch);\n-            }\n-            if (bestMatch != null && bestMatch.isVarArgs() && bestMatch.getParameterTypes().length > 0 && parameterTypes.length > 0) {\n-                final Class<?>[] methodParameterTypes = bestMatch.getParameterTypes();\n-                final Class<?> methodParameterComponentType = methodParameterTypes[methodParameterTypes.length - 1].getComponentType();\n-                final String methodParameterComponentTypeName = ClassUtils.primitiveToWrapper((Class)methodParameterComponentType).getName();\n-                final Class<?> lastParameterType = parameterTypes[parameterTypes.length - 1];\n-                final String parameterTypeName = (lastParameterType == null) ? null : lastParameterType.getName();\n-                final String parameterTypeSuperClassName = (lastParameterType == null) ? null : lastParameterType.getSuperclass().getName();\n-                if (parameterTypeName != null && parameterTypeSuperClassName != null && !methodParameterComponentTypeName.equals(parameterTypeName) && !methodParameterComponentTypeName.equals(parameterTypeSuperClassName)) {\n+            Collections.sort((List<Object>)list, (Comparator<? super Object>)MethodUtils.METHOD_BY_SIGNATURE);\n+            Method accessibleWorkaround = null;\n+            final Iterator iterator = list.iterator();\n+            while (iterator.hasNext()) {\n+                final Method accessibleMethod = getAccessibleMethod((Method)iterator.next());\n+                if (accessibleMethod != null && (accessibleWorkaround == null || MemberUtils.compareMethodFit(accessibleMethod, accessibleWorkaround, (Class[])parameterTypes) < 0)) {\n+                    accessibleWorkaround = accessibleMethod;\n+                }\n+            }\n+            if (accessibleWorkaround != null) {\n+                MemberUtils.setAccessibleWorkaround((AccessibleObject)accessibleWorkaround);\n+            }\n+            if (accessibleWorkaround != null && accessibleWorkaround.isVarArgs() && accessibleWorkaround.getParameterTypes().length > 0 && parameterTypes.length > 0) {\n+                final Class<?>[] parameterTypes2 = accessibleWorkaround.getParameterTypes();\n+                final String name = ClassUtils.primitiveToWrapper((Class)parameterTypes2[parameterTypes2.length - 1].getComponentType()).getName();\n+                final Class<?> clazz2 = parameterTypes[parameterTypes.length - 1];\n+                final String anObject = (clazz2 == null) ? null : clazz2.getName();\n+                final String anObject2 = (clazz2 == null) ? null : clazz2.getSuperclass().getName();\n+                if (anObject != null && anObject2 != null && !name.equals(anObject) && !name.equals(anObject2)) {\n                     return null;\n                 }\n             }\n-            return bestMatch;\n+            return accessibleWorkaround;\n         }\n     }\n     \n-    public static Method getMatchingMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) {\n-        Validate.notNull((Object)cls, \"Null class not allowed.\", new Object[0]);\n-        Validate.notEmpty((CharSequence)methodName, \"Null or blank methodName not allowed.\", new Object[0]);\n-        Method[] methodArray = cls.getDeclaredMethods();\n-        final List<Class<?>> superclassList = ClassUtils.getAllSuperclasses((Class)cls);\n-        for (final Class<?> klass : superclassList) {\n-            methodArray = (Method[])ArrayUtils.addAll((Object[])methodArray, (Object[])klass.getDeclaredMethods());\n+    public static Method getMatchingMethod(final Class<?> clazz, final String s, final Class<?>... a) {\n+        Validate.notNull((Object)clazz, \"Null class not allowed.\", new Object[0]);\n+        Validate.notEmpty((CharSequence)s, \"Null or blank methodName not allowed.\", new Object[0]);\n+        Method[] declaredMethods = clazz.getDeclaredMethods();\n+        final Iterator iterator = ClassUtils.getAllSuperclasses((Class)clazz).iterator();\n+        while (iterator.hasNext()) {\n+            declaredMethods = (Method[])ArrayUtils.addAll((Object[])declaredMethods, (Object[])((Class)iterator.next()).getDeclaredMethods());\n         }\n-        Method inexactMatch = null;\n-        for (final Method method : methodArray) {\n-            if (methodName.equals(method.getName()) && Objects.deepEquals(parameterTypes, method.getParameterTypes())) {\n-                return method;\n-            }\n-            if (methodName.equals(method.getName()) && ClassUtils.isAssignable((Class[])parameterTypes, (Class[])method.getParameterTypes(), true)) {\n-                if (inexactMatch == null) {\n-                    inexactMatch = method;\n+        Method method = null;\n+        for (final Method method2 : declaredMethods) {\n+            if (s.equals(method2.getName()) && Objects.deepEquals(a, method2.getParameterTypes())) {\n+                return method2;\n+            }\n+            if (s.equals(method2.getName()) && ClassUtils.isAssignable((Class[])a, (Class[])method2.getParameterTypes(), true)) {\n+                if (method == null) {\n+                    method = method2;\n                 }\n-                else if (distance(parameterTypes, method.getParameterTypes()) < distance(parameterTypes, inexactMatch.getParameterTypes())) {\n-                    inexactMatch = method;\n+                else if (distance(a, method2.getParameterTypes()) < distance(a, method.getParameterTypes())) {\n+                    method = method2;\n                 }\n             }\n         }\n-        return inexactMatch;\n+        return method;\n     }\n     \n-    private static int distance(final Class<?>[] classArray, final Class<?>[] toClassArray) {\n-        int answer = 0;\n-        if (!ClassUtils.isAssignable((Class[])classArray, (Class[])toClassArray, true)) {\n+    private static int distance(final Class<?>[] array, final Class<?>[] array2) {\n+        int n = 0;\n+        if (!ClassUtils.isAssignable((Class[])array, (Class[])array2, true)) {\n             return -1;\n         }\n-        for (int offset = 0; offset < classArray.length; ++offset) {\n-            if (!classArray[offset].equals(toClassArray[offset])) {\n-                if (ClassUtils.isAssignable((Class)classArray[offset], (Class)toClassArray[offset], true) && !ClassUtils.isAssignable((Class)classArray[offset], (Class)toClassArray[offset], false)) {\n-                    ++answer;\n+        for (int i = 0; i < array.length; ++i) {\n+            if (!array[i].equals(array2[i])) {\n+                if (ClassUtils.isAssignable((Class)array[i], (Class)array2[i], true) && !ClassUtils.isAssignable((Class)array[i], (Class)array2[i], false)) {\n+                    ++n;\n                 }\n                 else {\n-                    answer += 2;\n+                    n += 2;\n                 }\n             }\n         }\n-        return answer;\n+        return n;\n     }\n     \n-    public static Set<Method> getOverrideHierarchy(final Method method, final ClassUtils.Interfaces interfacesBehavior) {\n+    public static Set<Method> getOverrideHierarchy(final Method method, final ClassUtils.Interfaces interfaces) {\n         Validate.notNull((Object)method);\n-        final Set<Method> result = new LinkedHashSet<Method>();\n-        result.add(method);\n+        final LinkedHashSet set = new LinkedHashSet();\n+        set.add(method);\n         final Class<?>[] parameterTypes = method.getParameterTypes();\n         final Class<?> declaringClass = method.getDeclaringClass();\n-        final Iterator<Class<?>> hierarchy = ClassUtils.hierarchy((Class)declaringClass, interfacesBehavior).iterator();\n-        hierarchy.next();\n+        final Iterator iterator = ClassUtils.hierarchy((Class)declaringClass, interfaces).iterator();\n+        iterator.next();\n     Label_0053:\n-        while (hierarchy.hasNext()) {\n-            final Class<?> c = (Class<?>)hierarchy.next();\n-            final Method m = getMatchingAccessibleMethod(c, method.getName(), parameterTypes);\n-            if (m == null) {\n+        while (iterator.hasNext()) {\n+            final Method matchingAccessibleMethod = getMatchingAccessibleMethod((Class<?>)iterator.next(), method.getName(), parameterTypes);\n+            if (matchingAccessibleMethod == null) {\n                 continue;\n             }\n-            if (Arrays.equals(m.getParameterTypes(), parameterTypes)) {\n-                result.add(m);\n+            if (Arrays.equals(matchingAccessibleMethod.getParameterTypes(), parameterTypes)) {\n+                set.add(matchingAccessibleMethod);\n             }\n             else {\n-                final Map<TypeVariable<?>, Type> typeArguments = TypeUtils.getTypeArguments((Type)declaringClass, (Class)m.getDeclaringClass());\n+                final Map typeArguments = TypeUtils.getTypeArguments((Type)declaringClass, (Class)matchingAccessibleMethod.getDeclaringClass());\n                 for (int i = 0; i < parameterTypes.length; ++i) {\n-                    final Type childType = TypeUtils.unrollVariables((Map)typeArguments, method.getGenericParameterTypes()[i]);\n-                    final Type parentType = TypeUtils.unrollVariables((Map)typeArguments, m.getGenericParameterTypes()[i]);\n-                    if (!TypeUtils.equals(childType, parentType)) {\n+                    if (!TypeUtils.equals(TypeUtils.unrollVariables(typeArguments, method.getGenericParameterTypes()[i]), TypeUtils.unrollVariables(typeArguments, matchingAccessibleMethod.getGenericParameterTypes()[i]))) {\n                         continue Label_0053;\n                     }\n                 }\n-                result.add(m);\n+                set.add(matchingAccessibleMethod);\n             }\n         }\n-        return result;\n+        return set;\n     }\n     \n-    public static Method[] getMethodsWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls) {\n-        return getMethodsWithAnnotation(cls, annotationCls, false, false);\n+    public static Method[] getMethodsWithAnnotation(final Class<?> clazz, final Class<? extends Annotation> clazz2) {\n+        return getMethodsWithAnnotation(clazz, clazz2, false, false);\n     }\n     \n-    public static List<Method> getMethodsListWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls) {\n-        return getMethodsListWithAnnotation(cls, annotationCls, false, false);\n+    public static List<Method> getMethodsListWithAnnotation(final Class<?> clazz, final Class<? extends Annotation> clazz2) {\n+        return getMethodsListWithAnnotation(clazz, clazz2, false, false);\n     }\n     \n-    public static Method[] getMethodsWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls, final boolean searchSupers, final boolean ignoreAccess) {\n-        final List<Method> annotatedMethodsList = getMethodsListWithAnnotation(cls, annotationCls, searchSupers, ignoreAccess);\n-        return annotatedMethodsList.toArray(ArrayUtils.EMPTY_METHOD_ARRAY);\n+    public static Method[] getMethodsWithAnnotation(final Class<?> clazz, final Class<? extends Annotation> clazz2, final boolean b, final boolean b2) {\n+        return getMethodsListWithAnnotation(clazz, clazz2, b, b2).toArray(ArrayUtils.EMPTY_METHOD_ARRAY);\n     }\n     \n-    public static List<Method> getMethodsListWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls, final boolean searchSupers, final boolean ignoreAccess) {\n-        Validate.notNull((Object)cls, \"The class must not be null\", new Object[0]);\n-        Validate.isTrue(annotationCls != null, \"The annotation class must not be null\", new Object[0]);\n-        final List<Class<?>> classes = searchSupers ? getAllSuperclassesAndInterfaces(cls) : new ArrayList<Class<?>>();\n-        classes.add(0, cls);\n-        final List<Method> annotatedMethods = new ArrayList<Method>();\n-        for (final Class<?> acls : classes) {\n-            final Method[] array;\n-            final Method[] methods = array = (ignoreAccess ? acls.getDeclaredMethods() : acls.getMethods());\n-            for (final Method method : array) {\n-                if (method.getAnnotation(annotationCls) != null) {\n-                    annotatedMethods.add(method);\n+    public static List<Method> getMethodsListWithAnnotation(final Class<?> clazz, final Class<? extends Annotation> annotationClass, final boolean b, final boolean b2) {\n+        Validate.notNull((Object)clazz, \"The class must not be null\", new Object[0]);\n+        Validate.isTrue(annotationClass != null, \"The annotation class must not be null\", new Object[0]);\n+        final List<Class<?>> list = b ? getAllSuperclassesAndInterfaces(clazz) : new ArrayList<Class<?>>();\n+        list.add(0, clazz);\n+        final ArrayList list2 = new ArrayList();\n+        for (final Class clazz2 : list) {\n+            for (final Method method : b2 ? clazz2.getDeclaredMethods() : clazz2.getMethods()) {\n+                if (method.getAnnotation(annotationClass) != null) {\n+                    list2.add(method);\n                 }\n             }\n         }\n-        return annotatedMethods;\n+        return list2;\n     }\n     \n-    public static <A extends Annotation> A getAnnotation(final Method method, final Class<A> annotationCls, final boolean searchSupers, final boolean ignoreAccess) {\n+    public static <A extends Annotation> A getAnnotation(final Method method, final Class<A> clazz, final boolean b, final boolean b2) {\n         Validate.notNull((Object)method, \"The method must not be null\", new Object[0]);\n-        Validate.isTrue(annotationCls != null, \"The annotation class must not be null\", new Object[0]);\n-        if (!ignoreAccess && !MemberUtils.isAccessible((Member)method)) {\n+        Validate.isTrue(clazz != null, \"The annotation class must not be null\", new Object[0]);\n+        if (!b2 && !MemberUtils.isAccessible((Member)method)) {\n             return null;\n         }\n-        A annotation = method.getAnnotation(annotationCls);\n-        if (annotation == null && searchSupers) {\n-            final Class<?> mcls = method.getDeclaringClass();\n-            final List<Class<?>> classes = getAllSuperclassesAndInterfaces(mcls);\n-            for (final Class<?> acls : classes) {\n-                final Method equivalentMethod = ignoreAccess ? getMatchingMethod(acls, method.getName(), method.getParameterTypes()) : getMatchingAccessibleMethod(acls, method.getName(), method.getParameterTypes());\n-                if (equivalentMethod != null) {\n-                    annotation = equivalentMethod.getAnnotation(annotationCls);\n+        Annotation annotation = method.getAnnotation(clazz);\n+        if (annotation == null && b) {\n+            for (final Class clazz2 : getAllSuperclassesAndInterfaces(method.getDeclaringClass())) {\n+                final Method method2 = b2 ? getMatchingMethod(clazz2, method.getName(), method.getParameterTypes()) : getMatchingAccessibleMethod(clazz2, method.getName(), method.getParameterTypes());\n+                if (method2 != null) {\n+                    annotation = method2.getAnnotation(clazz);\n                     if (annotation != null) {\n                         break;\n                     }\n                     continue;\n                 }\n             }\n         }\n-        return annotation;\n+        return (A)annotation;\n     }\n     \n-    private static List<Class<?>> getAllSuperclassesAndInterfaces(final Class<?> cls) {\n-        if (cls == null) {\n+    private static List<Class<?>> getAllSuperclassesAndInterfaces(final Class<?> clazz) {\n+        if (clazz == null) {\n             return null;\n         }\n-        final List<Class<?>> allSuperClassesAndInterfaces = new ArrayList<Class<?>>();\n-        final List<Class<?>> allSuperclasses = ClassUtils.getAllSuperclasses((Class)cls);\n-        int superClassIndex = 0;\n-        final List<Class<?>> allInterfaces = ClassUtils.getAllInterfaces((Class)cls);\n-        int interfaceIndex = 0;\n-        while (interfaceIndex < allInterfaces.size() || superClassIndex < allSuperclasses.size()) {\n-            Class<?> acls;\n-            if (interfaceIndex >= allInterfaces.size()) {\n-                acls = allSuperclasses.get(superClassIndex++);\n+        final ArrayList list = new ArrayList();\n+        final List allSuperclasses = ClassUtils.getAllSuperclasses((Class)clazz);\n+        int n = 0;\n+        final List allInterfaces = ClassUtils.getAllInterfaces((Class)clazz);\n+        int n2 = 0;\n+        while (n2 < allInterfaces.size() || n < allSuperclasses.size()) {\n+            Class clazz2;\n+            if (n2 >= allInterfaces.size()) {\n+                clazz2 = allSuperclasses.get(n++);\n             }\n-            else if (superClassIndex >= allSuperclasses.size()) {\n-                acls = allInterfaces.get(interfaceIndex++);\n+            else if (n >= allSuperclasses.size()) {\n+                clazz2 = allInterfaces.get(n2++);\n             }\n-            else if (interfaceIndex < superClassIndex) {\n-                acls = allInterfaces.get(interfaceIndex++);\n+            else if (n2 < n) {\n+                clazz2 = allInterfaces.get(n2++);\n             }\n-            else if (superClassIndex < interfaceIndex) {\n-                acls = allSuperclasses.get(superClassIndex++);\n+            else if (n < n2) {\n+                clazz2 = allSuperclasses.get(n++);\n             }\n             else {\n-                acls = allInterfaces.get(interfaceIndex++);\n+                clazz2 = allInterfaces.get(n2++);\n             }\n-            allSuperClassesAndInterfaces.add(acls);\n+            list.add(clazz2);\n         }\n-        return allSuperClassesAndInterfaces;\n+        return list;\n     }\n     \n     static {\n-        METHOD_BY_SIGNATURE = ((m1, m2) -> m1.toString().compareTo(m2.toString()));\n+        METHOD_BY_SIGNATURE = ((method, method2) -> method.toString().compareTo(method2.toString()));\n     }\n }\n"}]}
