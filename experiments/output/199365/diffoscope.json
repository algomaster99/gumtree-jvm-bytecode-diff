{"diffoscope-json-version": 1, "source1": "first/OperandStack.class", "source2": "second/OperandStack.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -14,43 +14,38 @@\n     private final int maxStack;\n     \n     public OperandStack(final int maxStack) {\n         this.stack = new ArrayList<Type>();\n         this.maxStack = maxStack;\n     }\n     \n-    public OperandStack(final int maxStack, final ObjectType obj) {\n+    public OperandStack(final int maxStack, final ObjectType objectType) {\n         this.stack = new ArrayList<Type>();\n         this.maxStack = maxStack;\n-        this.push((Type)obj);\n+        this.push((Type)objectType);\n     }\n     \n     public Object clone() {\n-        final OperandStack newstack = new OperandStack(this.maxStack);\n-        final ArrayList<Type> clone = (ArrayList)this.stack.clone();\n-        newstack.stack = clone;\n-        return newstack;\n+        final OperandStack operandStack = new OperandStack(this.maxStack);\n+        operandStack.stack = (ArrayList)this.stack.clone();\n+        return operandStack;\n     }\n     \n     public void clear() {\n         this.stack = new ArrayList<Type>();\n     }\n     \n     @Override\n     public int hashCode() {\n         return this.stack.hashCode();\n     }\n     \n     @Override\n     public boolean equals(final Object o) {\n-        if (!(o instanceof OperandStack)) {\n-            return false;\n-        }\n-        final OperandStack s = (OperandStack)o;\n-        return this.stack.equals(s.stack);\n+        return o instanceof OperandStack && this.stack.equals(((OperandStack)o).stack);\n     }\n     \n     public OperandStack getClone() {\n         return (OperandStack)this.clone();\n     }\n     \n     public boolean isEmpty() {\n@@ -61,25 +56,24 @@\n         return this.maxStack;\n     }\n     \n     public Type peek() {\n         return this.peek(0);\n     }\n     \n-    public Type peek(final int i) {\n-        return this.stack.get(this.size() - i - 1);\n+    public Type peek(final int n) {\n+        return this.stack.get(this.size() - n - 1);\n     }\n     \n     public Type pop() {\n-        final Type e = (Type)this.stack.remove(this.size() - 1);\n-        return e;\n+        return this.stack.remove(this.size() - 1);\n     }\n     \n-    public Type pop(final int i) {\n-        for (int j = 0; j < i; ++j) {\n+    public Type pop(final int n) {\n+        for (int i = 0; i < n; ++i) {\n             this.pop();\n         }\n         return null;\n     }\n     \n     public void push(final Type type) {\n         if (type == null) {\n@@ -95,19 +89,19 @@\n     }\n     \n     public int size() {\n         return this.stack.size();\n     }\n     \n     public int slotsUsed() {\n-        int slots = 0;\n+        int n = 0;\n         for (int i = 0; i < this.stack.size(); ++i) {\n-            slots += this.peek(i).getSize();\n+            n += this.peek(i).getSize();\n         }\n-        return slots;\n+        return n;\n     }\n     \n     @Override\n     public String toString() {\n         final StringBuilder sb = new StringBuilder();\n         sb.append(\"Slots used: \");\n         sb.append(this.slotsUsed());\n@@ -119,43 +113,43 @@\n             sb.append(\" (Size: \");\n             sb.append(String.valueOf(this.peek(i).getSize()));\n             sb.append(\")\\n\");\n         }\n         return sb.toString();\n     }\n     \n-    public void merge(final OperandStack s) {\n+    public void merge(final OperandStack operandStack) {\n         try {\n-            if (this.slotsUsed() != s.slotsUsed() || this.size() != s.size()) {\n-                throw new StructuralCodeConstraintException(\"Cannot merge stacks of different size:\\nOperandStack A:\\n\" + this + \"\\nOperandStack B:\\n\" + s);\n+            if (this.slotsUsed() != operandStack.slotsUsed() || this.size() != operandStack.size()) {\n+                throw new StructuralCodeConstraintException(\"Cannot merge stacks of different size:\\nOperandStack A:\\n\" + this + \"\\nOperandStack B:\\n\" + operandStack);\n             }\n             for (int i = 0; i < this.size(); ++i) {\n-                if (!(this.stack.get(i) instanceof UninitializedObjectType) && s.stack.get(i) instanceof UninitializedObjectType) {\n+                if (!(this.stack.get(i) instanceof UninitializedObjectType) && operandStack.stack.get(i) instanceof UninitializedObjectType) {\n                     throw new StructuralCodeConstraintException(\"Backwards branch with an uninitialized object on the stack detected.\");\n                 }\n-                if (!((Type)this.stack.get(i)).equals((Object)s.stack.get(i)) && this.stack.get(i) instanceof UninitializedObjectType && !(s.stack.get(i) instanceof UninitializedObjectType)) {\n+                if (!((Type)this.stack.get(i)).equals((Object)operandStack.stack.get(i)) && this.stack.get(i) instanceof UninitializedObjectType && !(operandStack.stack.get(i) instanceof UninitializedObjectType)) {\n                     throw new StructuralCodeConstraintException(\"Backwards branch with an uninitialized object on the stack detected.\");\n                 }\n-                if (this.stack.get(i) instanceof UninitializedObjectType && !(s.stack.get(i) instanceof UninitializedObjectType)) {\n+                if (this.stack.get(i) instanceof UninitializedObjectType && !(operandStack.stack.get(i) instanceof UninitializedObjectType)) {\n                     this.stack.set(i, (Type)((UninitializedObjectType)this.stack.get(i)).getInitialized());\n                 }\n-                if (!((Type)this.stack.get(i)).equals((Object)s.stack.get(i))) {\n-                    if (!(this.stack.get(i) instanceof ReferenceType) || !(s.stack.get(i) instanceof ReferenceType)) {\n-                        throw new StructuralCodeConstraintException(\"Cannot merge stacks of different types:\\nStack A:\\n\" + this + \"\\nStack B:\\n\" + s);\n+                if (!((Type)this.stack.get(i)).equals((Object)operandStack.stack.get(i))) {\n+                    if (!(this.stack.get(i) instanceof ReferenceType) || !(operandStack.stack.get(i) instanceof ReferenceType)) {\n+                        throw new StructuralCodeConstraintException(\"Cannot merge stacks of different types:\\nStack A:\\n\" + this + \"\\nStack B:\\n\" + operandStack);\n                     }\n-                    this.stack.set(i, (Type)((ReferenceType)this.stack.get(i)).getFirstCommonSuperclass((ReferenceType)(ReferenceType)s.stack.get(i)));\n+                    this.stack.set(i, (Type)((ReferenceType)this.stack.get(i)).getFirstCommonSuperclass((ReferenceType)(ReferenceType)operandStack.stack.get(i)));\n                 }\n             }\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj, (Throwable)obj);\n         }\n     }\n     \n-    public void initializeObject(final UninitializedObjectType u) {\n+    public void initializeObject(final UninitializedObjectType uninitializedObjectType) {\n         for (int i = 0; i < this.stack.size(); ++i) {\n-            if (this.stack.get(i) == u) {\n-                this.stack.set(i, (Type)u.getInitialized());\n+            if (this.stack.get(i) == uninitializedObjectType) {\n+                this.stack.set(i, (Type)uninitializedObjectType.getInitialized());\n             }\n         }\n     }\n }\n"}]}
