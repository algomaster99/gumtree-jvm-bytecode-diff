{"diffoscope-json-version": 1, "source1": "first/Base64.class", "source2": "second/Base64.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -26,232 +26,228 @@\n     private int pos;\n     private int readPos;\n     private int currentLinePos;\n     private int modulus;\n     private boolean eof;\n     private int x;\n     \n-    private static boolean containsBase64Byte(final byte[] arrayOctet) {\n-        for (final byte element : arrayOctet) {\n-            if (isBase64(element)) {\n+    private static boolean containsBase64Byte(final byte[] array) {\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            if (isBase64(array[i])) {\n                 return true;\n             }\n         }\n         return false;\n     }\n     \n-    public static byte[] decodeBase64(final byte[] base64Data) {\n-        return new Base64().decode(base64Data);\n+    public static byte[] decodeBase64(final byte[] array) {\n+        return new Base64().decode(array);\n     }\n     \n-    public static byte[] decodeBase64(final String base64String) {\n-        return new Base64().decode(base64String);\n+    public static byte[] decodeBase64(final String s) {\n+        return new Base64().decode(s);\n     }\n     \n-    public static BigInteger decodeInteger(final byte[] pArray) {\n-        return new BigInteger(1, decodeBase64(pArray));\n+    public static BigInteger decodeInteger(final byte[] array) {\n+        return new BigInteger(1, decodeBase64(array));\n     }\n     \n-    public static byte[] encodeBase64(final byte[] binaryData) {\n-        return encodeBase64(binaryData, false);\n+    public static byte[] encodeBase64(final byte[] array) {\n+        return encodeBase64(array, false);\n     }\n     \n-    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked) {\n-        return encodeBase64(binaryData, isChunked, false);\n+    public static byte[] encodeBase64(final byte[] array, final boolean b) {\n+        return encodeBase64(array, b, false);\n     }\n     \n-    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked, final boolean urlSafe) {\n-        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n+    public static byte[] encodeBase64(final byte[] array, final boolean b, final boolean b2) {\n+        return encodeBase64(array, b, b2, Integer.MAX_VALUE);\n     }\n     \n-    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked, final boolean urlSafe, final int maxResultSize) {\n-        if (binaryData == null || binaryData.length == 0) {\n-            return binaryData;\n+    public static byte[] encodeBase64(final byte[] array, final boolean b, final boolean b2, final int i) {\n+        if (array == null || array.length == 0) {\n+            return array;\n         }\n-        final long len = getEncodeLength(binaryData, isChunked ? 76 : 0, isChunked ? Base64.CHUNK_SEPARATOR : NetConstants.EMPTY_BTYE_ARRAY);\n-        if (len > maxResultSize) {\n-            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" + len + \") than the specified maxium size of \" + maxResultSize);\n+        final long encodeLength = getEncodeLength(array, b ? 76 : 0, b ? Base64.CHUNK_SEPARATOR : NetConstants.EMPTY_BTYE_ARRAY);\n+        if (encodeLength > i) {\n+            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" + encodeLength + \") than the specified maxium size of \" + i);\n         }\n-        final Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, Base64.CHUNK_SEPARATOR, urlSafe);\n-        return b64.encode(binaryData);\n+        return (b ? new Base64(b2) : new Base64(0, Base64.CHUNK_SEPARATOR, b2)).encode(array);\n     }\n     \n-    public static byte[] encodeBase64Chunked(final byte[] binaryData) {\n-        return encodeBase64(binaryData, true);\n+    public static byte[] encodeBase64Chunked(final byte[] array) {\n+        return encodeBase64(array, true);\n     }\n     \n-    public static String encodeBase64String(final byte[] binaryData) {\n-        return newStringUtf8(encodeBase64(binaryData, true));\n+    public static String encodeBase64String(final byte[] array) {\n+        return newStringUtf8(encodeBase64(array, true));\n     }\n     \n-    public static String encodeBase64String(final byte[] binaryData, final boolean useChunking) {\n-        return newStringUtf8(encodeBase64(binaryData, useChunking));\n+    public static String encodeBase64String(final byte[] array, final boolean b) {\n+        return newStringUtf8(encodeBase64(array, b));\n     }\n     \n-    public static String encodeBase64StringUnChunked(final byte[] binaryData) {\n-        return newStringUtf8(encodeBase64(binaryData, false));\n+    public static String encodeBase64StringUnChunked(final byte[] array) {\n+        return newStringUtf8(encodeBase64(array, false));\n     }\n     \n-    public static byte[] encodeBase64URLSafe(final byte[] binaryData) {\n-        return encodeBase64(binaryData, false, true);\n+    public static byte[] encodeBase64URLSafe(final byte[] array) {\n+        return encodeBase64(array, false, true);\n     }\n     \n-    public static String encodeBase64URLSafeString(final byte[] binaryData) {\n-        return newStringUtf8(encodeBase64(binaryData, false, true));\n+    public static String encodeBase64URLSafeString(final byte[] array) {\n+        return newStringUtf8(encodeBase64(array, false, true));\n     }\n     \n-    public static byte[] encodeInteger(final BigInteger bigInt) {\n-        return encodeBase64(toIntegerBytes(bigInt), false);\n+    public static byte[] encodeInteger(final BigInteger bigInteger) {\n+        return encodeBase64(toIntegerBytes(bigInteger), false);\n     }\n     \n-    private static long getEncodeLength(final byte[] pArray, int chunkSize, final byte[] chunkSeparator) {\n-        chunkSize = chunkSize / 4 * 4;\n-        long len = (long)(pArray.length * 4 / 3);\n-        final long mod = len % 4L;\n-        if (mod != 0L) {\n-            len += 4L - mod;\n+    private static long getEncodeLength(final byte[] array, int n, final byte[] array2) {\n+        n = n / 4 * 4;\n+        long n2 = (long)(array.length * 4 / 3);\n+        final long n3 = n2 % 4L;\n+        if (n3 != 0L) {\n+            n2 += 4L - n3;\n         }\n-        if (chunkSize > 0) {\n-            final boolean lenChunksPerfectly = len % chunkSize == 0L;\n-            len += len / chunkSize * chunkSeparator.length;\n-            if (!lenChunksPerfectly) {\n-                len += chunkSeparator.length;\n+        if (n > 0) {\n+            final boolean b = n2 % n == 0L;\n+            n2 += n2 / n * array2.length;\n+            if (!b) {\n+                n2 += array2.length;\n             }\n         }\n-        return len;\n+        return n2;\n     }\n     \n-    public static boolean isArrayByteBase64(final byte[] arrayOctet) {\n-        for (final byte element : arrayOctet) {\n-            if (!isBase64(element) && !isWhiteSpace(element)) {\n+    public static boolean isArrayByteBase64(final byte[] array) {\n+        for (final byte b : array) {\n+            if (!isBase64(b) && !isWhiteSpace(b)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    public static boolean isBase64(final byte octet) {\n-        return octet == 61 || (octet >= 0 && octet < Base64.DECODE_TABLE.length && Base64.DECODE_TABLE[octet] != -1);\n+    public static boolean isBase64(final byte b) {\n+        return b == 61 || (b >= 0 && b < Base64.DECODE_TABLE.length && Base64.DECODE_TABLE[b] != -1);\n     }\n     \n-    private static boolean isWhiteSpace(final byte byteToCheck) {\n-        switch (byteToCheck) {\n+    private static boolean isWhiteSpace(final byte b) {\n+        switch (b) {\n             case 9:\n             case 10:\n             case 13:\n             case 32: {\n                 return true;\n             }\n             default: {\n                 return false;\n             }\n         }\n     }\n     \n-    private static String newStringUtf8(final byte[] encode) {\n-        return new String(encode, StandardCharsets.UTF_8);\n+    private static String newStringUtf8(final byte[] bytes) {\n+        return new String(bytes, StandardCharsets.UTF_8);\n     }\n     \n-    static byte[] toIntegerBytes(final BigInteger bigInt) {\n-        Objects.requireNonNull(bigInt, \"bigInt\");\n-        int bitlen = bigInt.bitLength();\n-        bitlen = bitlen + 7 >> 3 << 3;\n-        final byte[] bigBytes = bigInt.toByteArray();\n-        if (bigInt.bitLength() % 8 != 0 && bigInt.bitLength() / 8 + 1 == bitlen / 8) {\n-            return bigBytes;\n-        }\n-        int startSrc = 0;\n-        int len = bigBytes.length;\n-        if (bigInt.bitLength() % 8 == 0) {\n-            startSrc = 1;\n-            --len;\n-        }\n-        final int startDst = bitlen / 8 - len;\n-        final byte[] resizedBytes = new byte[bitlen / 8];\n-        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n-        return resizedBytes;\n+    static byte[] toIntegerBytes(final BigInteger obj) {\n+        Objects.requireNonNull(obj, \"bigInt\");\n+        final int n = obj.bitLength() + 7 >> 3 << 3;\n+        final byte[] byteArray = obj.toByteArray();\n+        if (obj.bitLength() % 8 != 0 && obj.bitLength() / 8 + 1 == n / 8) {\n+            return byteArray;\n+        }\n+        int n2 = 0;\n+        int length = byteArray.length;\n+        if (obj.bitLength() % 8 == 0) {\n+            n2 = 1;\n+            --length;\n+        }\n+        final int n3 = n / 8 - length;\n+        final byte[] array = new byte[n / 8];\n+        System.arraycopy(byteArray, n2, array, n3, length);\n+        return array;\n     }\n     \n     public Base64() {\n         this(false);\n     }\n     \n-    public Base64(final boolean urlSafe) {\n-        this(76, Base64.CHUNK_SEPARATOR, urlSafe);\n+    public Base64(final boolean b) {\n+        this(76, Base64.CHUNK_SEPARATOR, b);\n     }\n     \n-    public Base64(final int lineLength) {\n-        this(lineLength, Base64.CHUNK_SEPARATOR);\n+    public Base64(final int n) {\n+        this(n, Base64.CHUNK_SEPARATOR);\n     }\n     \n-    public Base64(final int lineLength, final byte[] lineSeparator) {\n-        this(lineLength, lineSeparator, false);\n+    public Base64(final int n, final byte[] array) {\n+        this(n, array, false);\n     }\n     \n-    public Base64(int lineLength, byte[] lineSeparator, final boolean urlSafe) {\n-        if (lineSeparator == null) {\n-            lineLength = 0;\n-            lineSeparator = NetConstants.EMPTY_BTYE_ARRAY;\n+    public Base64(int n, byte[] empty_BTYE_ARRAY, final boolean b) {\n+        if (empty_BTYE_ARRAY == null) {\n+            n = 0;\n+            empty_BTYE_ARRAY = NetConstants.EMPTY_BTYE_ARRAY;\n         }\n-        this.lineLength = ((lineLength > 0) ? (lineLength / 4 * 4) : 0);\n-        System.arraycopy(lineSeparator, 0, this.lineSeparator = new byte[lineSeparator.length], 0, lineSeparator.length);\n-        if (lineLength > 0) {\n-            this.encodeSize = 4 + lineSeparator.length;\n+        this.lineLength = ((n > 0) ? (n / 4 * 4) : 0);\n+        System.arraycopy(empty_BTYE_ARRAY, 0, this.lineSeparator = new byte[empty_BTYE_ARRAY.length], 0, empty_BTYE_ARRAY.length);\n+        if (n > 0) {\n+            this.encodeSize = 4 + empty_BTYE_ARRAY.length;\n         }\n         else {\n             this.encodeSize = 4;\n         }\n         this.decodeSize = this.encodeSize - 1;\n-        if (containsBase64Byte(lineSeparator)) {\n-            final String sep = newStringUtf8(lineSeparator);\n-            throw new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n+        if (containsBase64Byte(empty_BTYE_ARRAY)) {\n+            throw new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + newStringUtf8(empty_BTYE_ARRAY) + \"]\");\n         }\n-        this.encodeTable = (urlSafe ? Base64.URL_SAFE_ENCODE_TABLE : Base64.STANDARD_ENCODE_TABLE);\n+        this.encodeTable = (b ? Base64.URL_SAFE_ENCODE_TABLE : Base64.STANDARD_ENCODE_TABLE);\n     }\n     \n     int avail() {\n         return (this.buffer != null) ? (this.pos - this.readPos) : 0;\n     }\n     \n-    public byte[] decode(final byte[] pArray) {\n+    public byte[] decode(final byte[] array) {\n         this.reset();\n-        if (pArray == null || pArray.length == 0) {\n-            return pArray;\n+        if (array == null || array.length == 0) {\n+            return array;\n         }\n-        final long len = (long)(pArray.length * 3 / 4);\n-        final byte[] buf = new byte[(int)len];\n-        this.setInitialBuffer(buf, 0, buf.length);\n-        this.decode(pArray, 0, pArray.length);\n-        this.decode(pArray, 0, -1);\n-        final byte[] result = new byte[this.pos];\n-        this.readResults(result, 0, result.length);\n-        return result;\n+        final byte[] array2 = new byte[(int)(long)(array.length * 3 / 4)];\n+        this.setInitialBuffer(array2, 0, array2.length);\n+        this.decode(array, 0, array.length);\n+        this.decode(array, 0, -1);\n+        final byte[] array3 = new byte[this.pos];\n+        this.readResults(array3, 0, array3.length);\n+        return array3;\n     }\n     \n-    void decode(final byte[] in, int inPos, final int inAvail) {\n+    void decode(final byte[] array, int n, final int n2) {\n         if (this.eof) {\n             return;\n         }\n-        if (inAvail < 0) {\n+        if (n2 < 0) {\n             this.eof = true;\n         }\n-        for (int i = 0; i < inAvail; ++i) {\n+        for (int i = 0; i < n2; ++i) {\n             if (this.buffer == null || this.buffer.length - this.pos < this.decodeSize) {\n                 this.resizeBuffer();\n             }\n-            final byte b = in[inPos++];\n+            final byte b = array[n++];\n             if (b == 61) {\n                 this.eof = true;\n                 break;\n             }\n             if (b >= 0 && b < Base64.DECODE_TABLE.length) {\n-                final int result = Base64.DECODE_TABLE[b];\n-                if (result >= 0) {\n+                final byte b2 = Base64.DECODE_TABLE[b];\n+                if (b2 >= 0) {\n                     this.modulus = ++this.modulus % 4;\n-                    this.x = (this.x << 6) + result;\n+                    this.x = (this.x << 6) + b2;\n                     if (this.modulus == 0) {\n                         this.buffer[this.pos++] = (byte)(this.x >> 16 & 0xFF);\n                         this.buffer[this.pos++] = (byte)(this.x >> 8 & 0xFF);\n                         this.buffer[this.pos++] = (byte)(this.x & 0xFF);\n                     }\n                 }\n             }\n@@ -269,44 +265,43 @@\n                     this.buffer[this.pos++] = (byte)(this.x >> 8 & 0xFF);\n                     break;\n                 }\n             }\n         }\n     }\n     \n-    public byte[] decode(final String pArray) {\n-        return this.decode(this.getBytesUtf8(pArray));\n+    public byte[] decode(final String s) {\n+        return this.decode(this.getBytesUtf8(s));\n     }\n     \n-    public byte[] encode(final byte[] pArray) {\n+    public byte[] encode(final byte[] array) {\n         this.reset();\n-        if (pArray == null || pArray.length == 0) {\n-            return pArray;\n+        if (array == null || array.length == 0) {\n+            return array;\n         }\n-        final long len = getEncodeLength(pArray, this.lineLength, this.lineSeparator);\n-        byte[] buf = new byte[(int)len];\n-        this.setInitialBuffer(buf, 0, buf.length);\n-        this.encode(pArray, 0, pArray.length);\n-        this.encode(pArray, 0, -1);\n-        if (this.buffer != buf) {\n-            this.readResults(buf, 0, buf.length);\n-        }\n-        if (this.isUrlSafe() && this.pos < buf.length) {\n-            final byte[] smallerBuf = new byte[this.pos];\n-            System.arraycopy(buf, 0, smallerBuf, 0, this.pos);\n-            buf = smallerBuf;\n+        byte[] array2 = new byte[(int)getEncodeLength(array, this.lineLength, this.lineSeparator)];\n+        this.setInitialBuffer(array2, 0, array2.length);\n+        this.encode(array, 0, array.length);\n+        this.encode(array, 0, -1);\n+        if (this.buffer != array2) {\n+            this.readResults(array2, 0, array2.length);\n         }\n-        return buf;\n+        if (this.isUrlSafe() && this.pos < array2.length) {\n+            final byte[] array3 = new byte[this.pos];\n+            System.arraycopy(array2, 0, array3, 0, this.pos);\n+            array2 = array3;\n+        }\n+        return array2;\n     }\n     \n-    void encode(final byte[] in, int inPos, final int inAvail) {\n+    void encode(final byte[] array, int n, final int n2) {\n         if (this.eof) {\n             return;\n         }\n-        if (inAvail < 0) {\n+        if (n2 < 0) {\n             this.eof = true;\n             if (this.buffer == null || this.buffer.length - this.pos < this.encodeSize) {\n                 this.resizeBuffer();\n             }\n             switch (this.modulus) {\n                 case 1: {\n                     this.buffer[this.pos++] = this.encodeTable[this.x >> 2 & 0x3F];\n@@ -331,24 +326,24 @@\n             }\n             if (this.lineLength > 0 && this.pos > 0) {\n                 System.arraycopy(this.lineSeparator, 0, this.buffer, this.pos, this.lineSeparator.length);\n                 this.pos += this.lineSeparator.length;\n             }\n         }\n         else {\n-            for (int i = 0; i < inAvail; ++i) {\n+            for (int i = 0; i < n2; ++i) {\n                 if (this.buffer == null || this.buffer.length - this.pos < this.encodeSize) {\n                     this.resizeBuffer();\n                 }\n                 this.modulus = ++this.modulus % 3;\n-                int b = in[inPos++];\n-                if (b < 0) {\n-                    b += 256;\n+                int n3 = array[n++];\n+                if (n3 < 0) {\n+                    n3 += 256;\n                 }\n-                this.x = (this.x << 8) + b;\n+                this.x = (this.x << 8) + n3;\n                 if (0 == this.modulus) {\n                     this.buffer[this.pos++] = this.encodeTable[this.x >> 18 & 0x3F];\n                     this.buffer[this.pos++] = this.encodeTable[this.x >> 12 & 0x3F];\n                     this.buffer[this.pos++] = this.encodeTable[this.x >> 6 & 0x3F];\n                     this.buffer[this.pos++] = this.encodeTable[this.x & 0x3F];\n                     this.currentLinePos += 4;\n                     if (this.lineLength > 0 && this.lineLength <= this.currentLinePos) {\n@@ -357,20 +352,20 @@\n                         this.currentLinePos = 0;\n                     }\n                 }\n             }\n         }\n     }\n     \n-    public String encodeToString(final byte[] pArray) {\n-        return newStringUtf8(this.encode(pArray));\n+    public String encodeToString(final byte[] array) {\n+        return newStringUtf8(this.encode(array));\n     }\n     \n-    private byte[] getBytesUtf8(final String pArray) {\n-        return pArray.getBytes(StandardCharsets.UTF_8);\n+    private byte[] getBytesUtf8(final String s) {\n+        return s.getBytes(StandardCharsets.UTF_8);\n     }\n     \n     int getLineLength() {\n         return this.lineLength;\n     }\n     \n     byte[] getLineSeparator() {\n@@ -381,28 +376,28 @@\n         return this.buffer != null;\n     }\n     \n     public boolean isUrlSafe() {\n         return this.encodeTable == Base64.URL_SAFE_ENCODE_TABLE;\n     }\n     \n-    int readResults(final byte[] b, final int bPos, final int bAvail) {\n+    int readResults(final byte[] array, final int n, final int b) {\n         if (this.buffer != null) {\n-            final int len = Math.min(this.avail(), bAvail);\n-            if (this.buffer != b) {\n-                System.arraycopy(this.buffer, this.readPos, b, bPos, len);\n-                this.readPos += len;\n+            final int min = Math.min(this.avail(), b);\n+            if (this.buffer != array) {\n+                System.arraycopy(this.buffer, this.readPos, array, n, min);\n+                this.readPos += min;\n                 if (this.readPos >= this.pos) {\n                     this.buffer = null;\n                 }\n             }\n             else {\n                 this.buffer = null;\n             }\n-            return len;\n+            return min;\n         }\n         return this.eof ? -1 : 0;\n     }\n     \n     private void reset() {\n         this.buffer = null;\n         this.pos = 0;\n@@ -415,25 +410,25 @@\n     private void resizeBuffer() {\n         if (this.buffer == null) {\n             this.buffer = new byte[8192];\n             this.pos = 0;\n             this.readPos = 0;\n         }\n         else {\n-            final byte[] b = new byte[this.buffer.length * 2];\n-            System.arraycopy(this.buffer, 0, b, 0, this.buffer.length);\n-            this.buffer = b;\n+            final byte[] buffer = new byte[this.buffer.length * 2];\n+            System.arraycopy(this.buffer, 0, buffer, 0, this.buffer.length);\n+            this.buffer = buffer;\n         }\n     }\n     \n-    void setInitialBuffer(final byte[] out, final int outPos, final int outAvail) {\n-        if (out != null && out.length == outAvail) {\n-            this.buffer = out;\n-            this.pos = outPos;\n-            this.readPos = outPos;\n+    void setInitialBuffer(final byte[] buffer, final int n, final int n2) {\n+        if (buffer != null && buffer.length == n2) {\n+            this.buffer = buffer;\n+            this.pos = n;\n+            this.readPos = n;\n         }\n     }\n     \n     static {\n         CHUNK_SEPARATOR = new byte[] { 13, 10 };\n         STANDARD_ENCODE_TABLE = new byte[] { 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47 };\n         URL_SAFE_ENCODE_TABLE = new byte[] { 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 45, 95 };\n"}]}
