{"diffoscope-json-version": 1, "source1": "first/AbstractLZ77CompressorInputStream.class", "source2": "second/AbstractLZ77CompressorInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -17,19 +17,19 @@\n     private final InputStream in;\n     private long bytesRemaining;\n     private int backReferenceOffset;\n     private int size;\n     private final byte[] oneByte;\n     protected final ByteUtils.ByteSupplier supplier;\n     \n-    public AbstractLZ77CompressorInputStream(final InputStream is, final int windowSize) throws IOException {\n+    public AbstractLZ77CompressorInputStream(final InputStream in, final int windowSize) throws IOException {\n         this.size = 0;\n         this.oneByte = new byte[1];\n         this.supplier = (ByteUtils.ByteSupplier)new AbstractLZ77CompressorInputStream.AbstractLZ77CompressorInputStream$1(this);\n-        this.in = is;\n+        this.in = in;\n         this.windowSize = windowSize;\n         this.buf = new byte[3 * windowSize];\n         final int n = 0;\n         this.readIndex = n;\n         this.writeIndex = n;\n         this.bytesRemaining = 0L;\n     }\n@@ -46,113 +46,112 @@\n         return this.writeIndex - this.readIndex;\n     }\n     \n     public int getSize() {\n         return this.size;\n     }\n     \n-    public void prefill(final byte[] data) {\n+    public void prefill(final byte[] array) {\n         if (this.writeIndex != 0) {\n             throw new IllegalStateException(\"the stream has already been read from, can't prefill anymore\");\n         }\n-        final int len = Math.min(this.windowSize, data.length);\n-        System.arraycopy(data, data.length - len, this.buf, 0, len);\n-        this.writeIndex += len;\n-        this.readIndex += len;\n+        final int min = Math.min(this.windowSize, array.length);\n+        System.arraycopy(array, array.length - min, this.buf, 0, min);\n+        this.writeIndex += min;\n+        this.readIndex += min;\n     }\n     \n-    protected final void startLiteral(final long length) {\n-        this.bytesRemaining = length;\n+    protected final void startLiteral(final long bytesRemaining) {\n+        this.bytesRemaining = bytesRemaining;\n     }\n     \n     protected final boolean hasMoreDataInBlock() {\n         return this.bytesRemaining > 0L;\n     }\n     \n-    protected final int readLiteral(final byte[] b, final int off, final int len) throws IOException {\n-        final int avail = this.available();\n-        if (len > avail) {\n-            this.tryToReadLiteral(len - avail);\n-        }\n-        return this.readFromBuffer(b, off, len);\n+    protected final int readLiteral(final byte[] array, final int n, final int n2) throws IOException {\n+        final int available = this.available();\n+        if (n2 > available) {\n+            this.tryToReadLiteral(n2 - available);\n+        }\n+        return this.readFromBuffer(array, n, n2);\n     }\n     \n-    private void tryToReadLiteral(final int bytesToRead) throws IOException {\n-        final int reallyTryToRead = Math.min((int)Math.min(bytesToRead, this.bytesRemaining), this.buf.length - this.writeIndex);\n-        final int bytesRead = (reallyTryToRead > 0) ? IOUtils.readFully(this.in, this.buf, this.writeIndex, reallyTryToRead) : 0;\n-        this.count(bytesRead);\n-        if (reallyTryToRead != bytesRead) {\n+    private void tryToReadLiteral(final int n) throws IOException {\n+        final int min = Math.min((int)Math.min(n, this.bytesRemaining), this.buf.length - this.writeIndex);\n+        final int n2 = (min > 0) ? IOUtils.readFully(this.in, this.buf, this.writeIndex, min) : 0;\n+        this.count(n2);\n+        if (min != n2) {\n             throw new IOException(\"Premature end of stream reading literal\");\n         }\n-        this.writeIndex += reallyTryToRead;\n-        this.bytesRemaining -= reallyTryToRead;\n+        this.writeIndex += min;\n+        this.bytesRemaining -= min;\n     }\n     \n-    private int readFromBuffer(final byte[] b, final int off, final int len) {\n-        final int readable = Math.min(len, this.available());\n-        if (readable > 0) {\n-            System.arraycopy(this.buf, this.readIndex, b, off, readable);\n-            this.readIndex += readable;\n+    private int readFromBuffer(final byte[] array, final int n, final int a) {\n+        final int min = Math.min(a, this.available());\n+        if (min > 0) {\n+            System.arraycopy(this.buf, this.readIndex, array, n, min);\n+            this.readIndex += min;\n             if (this.readIndex > 2 * this.windowSize) {\n                 this.slideBuffer();\n             }\n         }\n-        this.size += readable;\n-        return readable;\n+        this.size += min;\n+        return min;\n     }\n     \n     private void slideBuffer() {\n         System.arraycopy(this.buf, this.windowSize, this.buf, 0, this.windowSize * 2);\n         this.writeIndex -= this.windowSize;\n         this.readIndex -= this.windowSize;\n     }\n     \n-    protected final void startBackReference(final int offset, final long length) {\n-        this.backReferenceOffset = offset;\n-        this.bytesRemaining = length;\n+    protected final void startBackReference(final int backReferenceOffset, final long bytesRemaining) {\n+        this.backReferenceOffset = backReferenceOffset;\n+        this.bytesRemaining = bytesRemaining;\n     }\n     \n-    protected final int readBackReference(final byte[] b, final int off, final int len) {\n-        final int avail = this.available();\n-        if (len > avail) {\n-            this.tryToCopy(len - avail);\n+    protected final int readBackReference(final byte[] array, final int n, final int n2) {\n+        final int available = this.available();\n+        if (n2 > available) {\n+            this.tryToCopy(n2 - available);\n         }\n-        return this.readFromBuffer(b, off, len);\n+        return this.readFromBuffer(array, n, n2);\n     }\n     \n-    private void tryToCopy(final int bytesToCopy) {\n-        final int copy = Math.min((int)Math.min(bytesToCopy, this.bytesRemaining), this.buf.length - this.writeIndex);\n-        if (copy != 0) {\n+    private void tryToCopy(final int n) {\n+        final int min = Math.min((int)Math.min(n, this.bytesRemaining), this.buf.length - this.writeIndex);\n+        if (min != 0) {\n             if (this.backReferenceOffset == 1) {\n-                final byte last = this.buf[this.writeIndex - 1];\n-                Arrays.fill(this.buf, this.writeIndex, this.writeIndex + copy, last);\n-                this.writeIndex += copy;\n+                Arrays.fill(this.buf, this.writeIndex, this.writeIndex + min, this.buf[this.writeIndex - 1]);\n+                this.writeIndex += min;\n             }\n-            else if (copy < this.backReferenceOffset) {\n-                System.arraycopy(this.buf, this.writeIndex - this.backReferenceOffset, this.buf, this.writeIndex, copy);\n-                this.writeIndex += copy;\n+            else if (min < this.backReferenceOffset) {\n+                System.arraycopy(this.buf, this.writeIndex - this.backReferenceOffset, this.buf, this.writeIndex, min);\n+                this.writeIndex += min;\n             }\n             else {\n-                final int fullRots = copy / this.backReferenceOffset;\n-                for (int i = 0; i < fullRots; ++i) {\n+                final int n2 = min / this.backReferenceOffset;\n+                for (int i = 0; i < n2; ++i) {\n                     System.arraycopy(this.buf, this.writeIndex - this.backReferenceOffset, this.buf, this.writeIndex, this.backReferenceOffset);\n                     this.writeIndex += this.backReferenceOffset;\n                 }\n-                final int pad = copy - this.backReferenceOffset * fullRots;\n-                if (pad > 0) {\n-                    System.arraycopy(this.buf, this.writeIndex - this.backReferenceOffset, this.buf, this.writeIndex, pad);\n-                    this.writeIndex += pad;\n+                final int n3 = min - this.backReferenceOffset * n2;\n+                if (n3 > 0) {\n+                    System.arraycopy(this.buf, this.writeIndex - this.backReferenceOffset, this.buf, this.writeIndex, n3);\n+                    this.writeIndex += n3;\n                 }\n             }\n         }\n-        this.bytesRemaining -= copy;\n+        this.bytesRemaining -= min;\n     }\n     \n     protected final int readOneByte() throws IOException {\n-        final int b = this.in.read();\n-        if (b != -1) {\n+        final int read = this.in.read();\n+        if (read != -1) {\n             this.count(1);\n-            return b & 0xFF;\n+            return read & 0xFF;\n         }\n         return -1;\n     }\n }\n"}]}
