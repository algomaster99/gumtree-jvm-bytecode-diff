{"diffoscope-json-version": 1, "source1": "first/ImportControlLoader.class", "source2": "second/ImportControlLoader.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -45,133 +45,126 @@\n     private final Deque<AbstractImportControl> stack;\n     \n     private ImportControlLoader() throws ParserConfigurationException, SAXException {\n         super((Map)ImportControlLoader.DTD_RESOURCE_BY_ID);\n         this.stack = new ArrayDeque<AbstractImportControl>();\n     }\n     \n-    public void startElement(final String namespaceUri, final String localName, final String qName, final Attributes attributes) throws SAXException {\n-        if (\"import-control\".equals(qName)) {\n-            final String pkg = safeGet(attributes, \"pkg\");\n-            final MismatchStrategy strategyOnMismatch = getStrategyForImportControl(attributes);\n-            final boolean regex = containsRegexAttribute(attributes);\n-            this.stack.push((AbstractImportControl)new PkgImportControl(pkg, regex, strategyOnMismatch));\n-        }\n-        else if (\"subpackage\".equals(qName)) {\n-            final String name = safeGet(attributes, \"name\");\n-            final MismatchStrategy strategyOnMismatch = getStrategyForSubpackage(attributes);\n-            final boolean regex = containsRegexAttribute(attributes);\n-            final PkgImportControl parentImportControl = (PkgImportControl)this.stack.peek();\n-            final AbstractImportControl importControl = (AbstractImportControl)new PkgImportControl(parentImportControl, name, regex, strategyOnMismatch);\n-            parentImportControl.addChild(importControl);\n-            this.stack.push(importControl);\n-        }\n-        else if (\"file\".equals(qName)) {\n-            final String name = safeGet(attributes, \"name\");\n-            final boolean regex2 = containsRegexAttribute(attributes);\n-            final PkgImportControl parentImportControl2 = (PkgImportControl)this.stack.peek();\n-            final AbstractImportControl importControl2 = (AbstractImportControl)new FileImportControl(parentImportControl2, name, regex2);\n-            parentImportControl2.addChild(importControl2);\n-            this.stack.push(importControl2);\n+    public void startElement(final String s, final String s2, final String anObject, final Attributes attributes) throws SAXException {\n+        if (\"import-control\".equals(anObject)) {\n+            this.stack.push((AbstractImportControl)new PkgImportControl(safeGet(attributes, \"pkg\"), containsRegexAttribute(attributes), getStrategyForImportControl(attributes)));\n+        }\n+        else if (\"subpackage\".equals(anObject)) {\n+            final String safeGet = safeGet(attributes, \"name\");\n+            final MismatchStrategy strategyForSubpackage = getStrategyForSubpackage(attributes);\n+            final boolean containsRegexAttribute = containsRegexAttribute(attributes);\n+            final PkgImportControl pkgImportControl = (PkgImportControl)this.stack.peek();\n+            final PkgImportControl pkgImportControl2 = new PkgImportControl(pkgImportControl, safeGet, containsRegexAttribute, strategyForSubpackage);\n+            pkgImportControl.addChild((AbstractImportControl)pkgImportControl2);\n+            this.stack.push((AbstractImportControl)pkgImportControl2);\n+        }\n+        else if (\"file\".equals(anObject)) {\n+            final String safeGet2 = safeGet(attributes, \"name\");\n+            final boolean containsRegexAttribute2 = containsRegexAttribute(attributes);\n+            final PkgImportControl pkgImportControl3 = (PkgImportControl)this.stack.peek();\n+            final FileImportControl fileImportControl = new FileImportControl(pkgImportControl3, safeGet2, containsRegexAttribute2);\n+            pkgImportControl3.addChild((AbstractImportControl)fileImportControl);\n+            this.stack.push((AbstractImportControl)fileImportControl);\n         }\n         else {\n-            final AbstractImportRule rule = createImportRule(qName, attributes);\n-            ((AbstractImportControl)this.stack.peek()).addImportRule(rule);\n+            ((AbstractImportControl)this.stack.peek()).addImportRule(createImportRule(anObject, attributes));\n         }\n     }\n     \n-    private static AbstractImportRule createImportRule(final String qName, final Attributes attributes) throws SAXException {\n-        final boolean isAllow = \"allow\".equals(qName);\n-        final boolean isLocalOnly = attributes.getValue(\"local-only\") != null;\n-        final String pkg = attributes.getValue(\"pkg\");\n-        final boolean regex = containsRegexAttribute(attributes);\n-        AbstractImportRule rule;\n-        if (pkg == null) {\n-            final String clazz = safeGet(attributes, \"class\");\n-            rule = (AbstractImportRule)new ClassImportRule(isAllow, isLocalOnly, clazz, regex);\n+    private static AbstractImportRule createImportRule(final String anObject, final Attributes attributes) throws SAXException {\n+        final boolean equals = \"allow\".equals(anObject);\n+        final boolean b = attributes.getValue(\"local-only\") != null;\n+        final String value = attributes.getValue(\"pkg\");\n+        final boolean containsRegexAttribute = containsRegexAttribute(attributes);\n+        Object o;\n+        if (value == null) {\n+            o = new ClassImportRule(equals, b, safeGet(attributes, \"class\"), containsRegexAttribute);\n         }\n         else {\n-            final boolean exactMatch = attributes.getValue(\"exact-match\") != null;\n-            rule = (AbstractImportRule)new PkgImportRule(isAllow, isLocalOnly, pkg, exactMatch, regex);\n+            o = new PkgImportRule(equals, b, value, attributes.getValue(\"exact-match\") != null, containsRegexAttribute);\n         }\n-        return rule;\n+        return (AbstractImportRule)o;\n     }\n     \n     private static boolean containsRegexAttribute(final Attributes attributes) {\n         return attributes.getValue(\"regex\") != null;\n     }\n     \n-    public void endElement(final String namespaceUri, final String localName, final String qName) {\n-        if (\"subpackage\".equals(qName) || \"file\".equals(qName)) {\n+    public void endElement(final String s, final String s2, final String s3) {\n+        if (\"subpackage\".equals(s3) || \"file\".equals(s3)) {\n             this.stack.pop();\n         }\n     }\n     \n     public static PkgImportControl load(final URI uri) throws CheckstyleException {\n         return loadUri(uri);\n     }\n     \n-    private static PkgImportControl load(final InputSource source, final URI uri) throws CheckstyleException {\n+    private static PkgImportControl load(final InputSource inputSource, final URI uri) throws CheckstyleException {\n         try {\n-            final ImportControlLoader loader = new ImportControlLoader();\n-            loader.parseInputSource(source);\n-            return loader.getRoot();\n+            final ImportControlLoader importControlLoader = new ImportControlLoader();\n+            importControlLoader.parseInputSource(inputSource);\n+            return importControlLoader.getRoot();\n         }\n         catch (final ParserConfigurationException | SAXException ex) {\n-            throw new CheckstyleException(\"unable to parse \" + String.valueOf((Object)uri) + \" - \" + ex.getMessage(), (Throwable)ex);\n+            throw new CheckstyleException(\"unable to parse \" + String.valueOf((Object)uri) + \" - \" + ((Throwable)ex).getMessage(), (Throwable)ex);\n         }\n         catch (final IOException ex2) {\n             throw new CheckstyleException(\"unable to read \" + String.valueOf((Object)uri), (Throwable)ex2);\n         }\n     }\n     \n     private static PkgImportControl loadUri(final URI uri) throws CheckstyleException {\n-        try (final InputStream inputStream = uri.toURL().openStream()) {\n-            final InputSource source = new InputSource(inputStream);\n-            return load(source, uri);\n+        try (final InputStream openStream = uri.toURL().openStream()) {\n+            return load(new InputSource(openStream), uri);\n         }\n         catch (final MalformedURLException ex) {\n             throw new CheckstyleException(\"syntax error in url \" + String.valueOf((Object)uri), (Throwable)ex);\n         }\n         catch (final IOException ex2) {\n             throw new CheckstyleException(\"unable to find \" + String.valueOf((Object)uri), (Throwable)ex2);\n         }\n     }\n     \n     private PkgImportControl getRoot() {\n         return (PkgImportControl)this.stack.peek();\n     }\n     \n     private static MismatchStrategy getStrategyForImportControl(final Attributes attributes) {\n-        final String returnValue = attributes.getValue(\"strategyOnMismatch\");\n-        MismatchStrategy strategyOnMismatch = MismatchStrategy.DISALLOWED;\n-        if (\"allowed\".equals(returnValue)) {\n-            strategyOnMismatch = MismatchStrategy.ALLOWED;\n+        final String value = attributes.getValue(\"strategyOnMismatch\");\n+        MismatchStrategy mismatchStrategy = MismatchStrategy.DISALLOWED;\n+        if (\"allowed\".equals(value)) {\n+            mismatchStrategy = MismatchStrategy.ALLOWED;\n         }\n-        return strategyOnMismatch;\n+        return mismatchStrategy;\n     }\n     \n     private static MismatchStrategy getStrategyForSubpackage(final Attributes attributes) {\n-        final String returnValue = attributes.getValue(\"strategyOnMismatch\");\n-        MismatchStrategy strategyOnMismatch = MismatchStrategy.DELEGATE_TO_PARENT;\n-        if (\"allowed\".equals(returnValue)) {\n-            strategyOnMismatch = MismatchStrategy.ALLOWED;\n+        final String value = attributes.getValue(\"strategyOnMismatch\");\n+        MismatchStrategy mismatchStrategy = MismatchStrategy.DELEGATE_TO_PARENT;\n+        if (\"allowed\".equals(value)) {\n+            mismatchStrategy = MismatchStrategy.ALLOWED;\n         }\n-        else if (\"disallowed\".equals(returnValue)) {\n-            strategyOnMismatch = MismatchStrategy.DISALLOWED;\n+        else if (\"disallowed\".equals(value)) {\n+            mismatchStrategy = MismatchStrategy.DISALLOWED;\n         }\n-        return strategyOnMismatch;\n+        return mismatchStrategy;\n     }\n     \n-    private static String safeGet(final Attributes attributes, final String name) throws SAXException {\n-        final String returnValue = attributes.getValue(name);\n-        if (returnValue == null) {\n-            throw new SAXException(\"missing attribute \" + name);\n+    private static String safeGet(final Attributes attributes, final String s) throws SAXException {\n+        final String value = attributes.getValue(s);\n+        if (value == null) {\n+            throw new SAXException(\"missing attribute \" + s);\n         }\n-        return returnValue;\n+        return value;\n     }\n     \n     static {\n         (DTD_RESOURCE_BY_ID = new HashMap<String, String>()).put(\"-//Puppy Crawl//DTD Import Control 1.0//EN\", \"com/puppycrawl/tools/checkstyle/checks/imports/import_control_1_0.dtd\");\n         ImportControlLoader.DTD_RESOURCE_BY_ID.put(\"-//Puppy Crawl//DTD Import Control 1.1//EN\", \"com/puppycrawl/tools/checkstyle/checks/imports/import_control_1_1.dtd\");\n         ImportControlLoader.DTD_RESOURCE_BY_ID.put(\"-//Puppy Crawl//DTD Import Control 1.2//EN\", \"com/puppycrawl/tools/checkstyle/checks/imports/import_control_1_2.dtd\");\n         ImportControlLoader.DTD_RESOURCE_BY_ID.put(\"-//Puppy Crawl//DTD Import Control 1.3//EN\", \"com/puppycrawl/tools/checkstyle/checks/imports/import_control_1_3.dtd\");\n"}]}
