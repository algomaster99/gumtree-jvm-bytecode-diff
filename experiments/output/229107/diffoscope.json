{"diffoscope-json-version": 1, "source1": "first/CpioArchiveInputStream.class", "source2": "second/CpioArchiveInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -23,24 +23,24 @@\n     private final byte[] twoBytesBuf;\n     private final byte[] fourBytesBuf;\n     private final byte[] sixBytesBuf;\n     private final int blockSize;\n     private final ZipEncoding zipEncoding;\n     final String encoding;\n     \n-    public CpioArchiveInputStream(final InputStream in) {\n-        this(in, 512, \"US-ASCII\");\n+    public CpioArchiveInputStream(final InputStream inputStream) {\n+        this(inputStream, 512, \"US-ASCII\");\n     }\n     \n-    public CpioArchiveInputStream(final InputStream in, final String encoding) {\n-        this(in, 512, encoding);\n+    public CpioArchiveInputStream(final InputStream inputStream, final String s) {\n+        this(inputStream, 512, s);\n     }\n     \n-    public CpioArchiveInputStream(final InputStream in, final int blockSize) {\n-        this(in, blockSize, \"US-ASCII\");\n+    public CpioArchiveInputStream(final InputStream inputStream, final int n) {\n+        this(inputStream, n, \"US-ASCII\");\n     }\n     \n     public CpioArchiveInputStream(final InputStream in, final int blockSize, final String encoding) {\n         this.closed = false;\n         this.entryBytesRead = 0L;\n         this.entryEOF = false;\n         this.tmpbuf = new byte[4096];\n@@ -91,15 +91,15 @@\n         else if (CpioUtil.byteArray2long(this.twoBytesBuf, true) == 29127L) {\n             this.entry = this.readOldBinaryEntry(true);\n         }\n         else {\n             System.arraycopy(this.twoBytesBuf, 0, this.sixBytesBuf, 0, this.twoBytesBuf.length);\n             this.readFully(this.sixBytesBuf, this.twoBytesBuf.length, this.fourBytesBuf.length);\n             final String asciiString;\n-            final String magicString = asciiString = ArchiveUtils.toAsciiString(this.sixBytesBuf);\n+            final String str = asciiString = ArchiveUtils.toAsciiString(this.sixBytesBuf);\n             int n = -1;\n             switch (asciiString.hashCode()) {\n                 case 1426477263: {\n                     if (asciiString.equals(\"070701\")) {\n                         n = 0;\n                         break;\n                     }\n@@ -130,213 +130,213 @@\n                     break;\n                 }\n                 case 2: {\n                     this.entry = this.readOldAsciiEntry();\n                     break;\n                 }\n                 default: {\n-                    throw new IOException(\"Unknown magic [\" + magicString + \"]. Occured at byte: \" + this.getBytesRead());\n+                    throw new IOException(\"Unknown magic [\" + str + \"]. Occured at byte: \" + this.getBytesRead());\n                 }\n             }\n         }\n         this.entryBytesRead = 0L;\n         this.entryEOF = false;\n         this.crc = 0L;\n         if (this.entry.getName().equals(\"TRAILER!!!\")) {\n             this.entryEOF = true;\n             this.skipRemainderOfLastBlock();\n             return null;\n         }\n         return this.entry;\n     }\n     \n-    private void skip(final int bytes) throws IOException {\n-        if (bytes > 0) {\n-            this.readFully(this.fourBytesBuf, 0, bytes);\n+    private void skip(final int n) throws IOException {\n+        if (n > 0) {\n+            this.readFully(this.fourBytesBuf, 0, n);\n         }\n     }\n     \n-    public int read(final byte[] b, final int off, final int len) throws IOException {\n+    public int read(final byte[] array, final int n, final int n2) throws IOException {\n         this.ensureOpen();\n-        if (off < 0 || len < 0 || off > b.length - len) {\n+        if (n < 0 || n2 < 0 || n > array.length - n2) {\n             throw new IndexOutOfBoundsException();\n         }\n-        if (len == 0) {\n+        if (n2 == 0) {\n             return 0;\n         }\n         if (this.entry == null || this.entryEOF) {\n             return -1;\n         }\n         if (this.entryBytesRead == this.entry.getSize()) {\n             this.skip(this.entry.getDataPadCount());\n             this.entryEOF = true;\n             if (this.entry.getFormat() == 2 && this.crc != this.entry.getChksum()) {\n                 throw new IOException(\"CRC Error. Occured at byte: \" + this.getBytesRead());\n             }\n             return -1;\n         }\n         else {\n-            final int tmplength = (int)Math.min(len, this.entry.getSize() - this.entryBytesRead);\n-            if (tmplength < 0) {\n+            final int n3 = (int)Math.min(n2, this.entry.getSize() - this.entryBytesRead);\n+            if (n3 < 0) {\n                 return -1;\n             }\n-            final int tmpread = this.readFully(b, off, tmplength);\n+            final int fully = this.readFully(array, n, n3);\n             if (this.entry.getFormat() == 2) {\n-                for (int pos = 0; pos < tmpread; ++pos) {\n-                    this.crc += (b[pos] & 0xFF);\n+                for (int i = 0; i < fully; ++i) {\n+                    this.crc += (array[i] & 0xFF);\n                     this.crc &= 0xFFFFFFFFL;\n                 }\n             }\n-            this.entryBytesRead += tmpread;\n-            return tmpread;\n+            this.entryBytesRead += fully;\n+            return fully;\n         }\n     }\n     \n-    private final int readFully(final byte[] b, final int off, final int len) throws IOException {\n-        final int count = IOUtils.readFully(this.in, b, off, len);\n-        this.count(count);\n-        if (count < len) {\n+    private final int readFully(final byte[] array, final int n, final int n2) throws IOException {\n+        final int fully = IOUtils.readFully(this.in, array, n, n2);\n+        this.count(fully);\n+        if (fully < n2) {\n             throw new EOFException();\n         }\n-        return count;\n+        return fully;\n     }\n     \n-    private long readBinaryLong(final int length, final boolean swapHalfWord) throws IOException {\n-        final byte[] tmp = new byte[length];\n-        this.readFully(tmp, 0, tmp.length);\n-        return CpioUtil.byteArray2long(tmp, swapHalfWord);\n+    private long readBinaryLong(final int n, final boolean b) throws IOException {\n+        final byte[] array = new byte[n];\n+        this.readFully(array, 0, array.length);\n+        return CpioUtil.byteArray2long(array, b);\n     }\n     \n-    private long readAsciiLong(final int length, final int radix) throws IOException {\n-        final byte[] tmpBuffer = new byte[length];\n-        this.readFully(tmpBuffer, 0, tmpBuffer.length);\n-        return Long.parseLong(ArchiveUtils.toAsciiString(tmpBuffer), radix);\n+    private long readAsciiLong(final int n, final int radix) throws IOException {\n+        final byte[] array = new byte[n];\n+        this.readFully(array, 0, array.length);\n+        return Long.parseLong(ArchiveUtils.toAsciiString(array), radix);\n     }\n     \n-    private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException {\n-        CpioArchiveEntry ret;\n-        if (hasCrc) {\n-            ret = new CpioArchiveEntry((short)2);\n+    private CpioArchiveEntry readNewEntry(final boolean b) throws IOException {\n+        CpioArchiveEntry cpioArchiveEntry;\n+        if (b) {\n+            cpioArchiveEntry = new CpioArchiveEntry((short)2);\n         }\n         else {\n-            ret = new CpioArchiveEntry((short)1);\n+            cpioArchiveEntry = new CpioArchiveEntry((short)1);\n         }\n-        ret.setInode(this.readAsciiLong(8, 16));\n-        final long mode = this.readAsciiLong(8, 16);\n-        if (CpioUtil.fileType(mode) != 0L) {\n-            ret.setMode(mode);\n-        }\n-        ret.setUID(this.readAsciiLong(8, 16));\n-        ret.setGID(this.readAsciiLong(8, 16));\n-        ret.setNumberOfLinks(this.readAsciiLong(8, 16));\n-        ret.setTime(this.readAsciiLong(8, 16));\n-        ret.setSize(this.readAsciiLong(8, 16));\n-        ret.setDeviceMaj(this.readAsciiLong(8, 16));\n-        ret.setDeviceMin(this.readAsciiLong(8, 16));\n-        ret.setRemoteDeviceMaj(this.readAsciiLong(8, 16));\n-        ret.setRemoteDeviceMin(this.readAsciiLong(8, 16));\n-        final long namesize = this.readAsciiLong(8, 16);\n-        ret.setChksum(this.readAsciiLong(8, 16));\n-        final String name = this.readCString((int)namesize);\n-        ret.setName(name);\n-        if (CpioUtil.fileType(mode) == 0L && !name.equals(\"TRAILER!!!\")) {\n-            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \" + ArchiveUtils.sanitize(name) + \" Occured at byte: \" + this.getBytesRead());\n+        cpioArchiveEntry.setInode(this.readAsciiLong(8, 16));\n+        final long asciiLong = this.readAsciiLong(8, 16);\n+        if (CpioUtil.fileType(asciiLong) != 0L) {\n+            cpioArchiveEntry.setMode(asciiLong);\n+        }\n+        cpioArchiveEntry.setUID(this.readAsciiLong(8, 16));\n+        cpioArchiveEntry.setGID(this.readAsciiLong(8, 16));\n+        cpioArchiveEntry.setNumberOfLinks(this.readAsciiLong(8, 16));\n+        cpioArchiveEntry.setTime(this.readAsciiLong(8, 16));\n+        cpioArchiveEntry.setSize(this.readAsciiLong(8, 16));\n+        cpioArchiveEntry.setDeviceMaj(this.readAsciiLong(8, 16));\n+        cpioArchiveEntry.setDeviceMin(this.readAsciiLong(8, 16));\n+        cpioArchiveEntry.setRemoteDeviceMaj(this.readAsciiLong(8, 16));\n+        cpioArchiveEntry.setRemoteDeviceMin(this.readAsciiLong(8, 16));\n+        final long asciiLong2 = this.readAsciiLong(8, 16);\n+        cpioArchiveEntry.setChksum(this.readAsciiLong(8, 16));\n+        final String cString = this.readCString((int)asciiLong2);\n+        cpioArchiveEntry.setName(cString);\n+        if (CpioUtil.fileType(asciiLong) == 0L && !cString.equals(\"TRAILER!!!\")) {\n+            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \" + ArchiveUtils.sanitize(cString) + \" Occured at byte: \" + this.getBytesRead());\n         }\n-        this.skip(ret.getHeaderPadCount());\n-        return ret;\n+        this.skip(cpioArchiveEntry.getHeaderPadCount());\n+        return cpioArchiveEntry;\n     }\n     \n     private CpioArchiveEntry readOldAsciiEntry() throws IOException {\n-        final CpioArchiveEntry ret = new CpioArchiveEntry((short)4);\n-        ret.setDevice(this.readAsciiLong(6, 8));\n-        ret.setInode(this.readAsciiLong(6, 8));\n-        final long mode = this.readAsciiLong(6, 8);\n-        if (CpioUtil.fileType(mode) != 0L) {\n-            ret.setMode(mode);\n-        }\n-        ret.setUID(this.readAsciiLong(6, 8));\n-        ret.setGID(this.readAsciiLong(6, 8));\n-        ret.setNumberOfLinks(this.readAsciiLong(6, 8));\n-        ret.setRemoteDevice(this.readAsciiLong(6, 8));\n-        ret.setTime(this.readAsciiLong(11, 8));\n-        final long namesize = this.readAsciiLong(6, 8);\n-        ret.setSize(this.readAsciiLong(11, 8));\n-        final String name = this.readCString((int)namesize);\n-        ret.setName(name);\n-        if (CpioUtil.fileType(mode) == 0L && !name.equals(\"TRAILER!!!\")) {\n-            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \" + ArchiveUtils.sanitize(name) + \" Occured at byte: \" + this.getBytesRead());\n-        }\n-        return ret;\n-    }\n-    \n-    private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord) throws IOException {\n-        final CpioArchiveEntry ret = new CpioArchiveEntry((short)8);\n-        ret.setDevice(this.readBinaryLong(2, swapHalfWord));\n-        ret.setInode(this.readBinaryLong(2, swapHalfWord));\n-        final long mode = this.readBinaryLong(2, swapHalfWord);\n-        if (CpioUtil.fileType(mode) != 0L) {\n-            ret.setMode(mode);\n-        }\n-        ret.setUID(this.readBinaryLong(2, swapHalfWord));\n-        ret.setGID(this.readBinaryLong(2, swapHalfWord));\n-        ret.setNumberOfLinks(this.readBinaryLong(2, swapHalfWord));\n-        ret.setRemoteDevice(this.readBinaryLong(2, swapHalfWord));\n-        ret.setTime(this.readBinaryLong(4, swapHalfWord));\n-        final long namesize = this.readBinaryLong(2, swapHalfWord);\n-        ret.setSize(this.readBinaryLong(4, swapHalfWord));\n-        final String name = this.readCString((int)namesize);\n-        ret.setName(name);\n-        if (CpioUtil.fileType(mode) == 0L && !name.equals(\"TRAILER!!!\")) {\n-            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \" + ArchiveUtils.sanitize(name) + \"Occured at byte: \" + this.getBytesRead());\n-        }\n-        this.skip(ret.getHeaderPadCount());\n-        return ret;\n-    }\n-    \n-    private String readCString(final int length) throws IOException {\n-        final byte[] tmpBuffer = new byte[length - 1];\n-        this.readFully(tmpBuffer, 0, tmpBuffer.length);\n+        final CpioArchiveEntry cpioArchiveEntry = new CpioArchiveEntry((short)4);\n+        cpioArchiveEntry.setDevice(this.readAsciiLong(6, 8));\n+        cpioArchiveEntry.setInode(this.readAsciiLong(6, 8));\n+        final long asciiLong = this.readAsciiLong(6, 8);\n+        if (CpioUtil.fileType(asciiLong) != 0L) {\n+            cpioArchiveEntry.setMode(asciiLong);\n+        }\n+        cpioArchiveEntry.setUID(this.readAsciiLong(6, 8));\n+        cpioArchiveEntry.setGID(this.readAsciiLong(6, 8));\n+        cpioArchiveEntry.setNumberOfLinks(this.readAsciiLong(6, 8));\n+        cpioArchiveEntry.setRemoteDevice(this.readAsciiLong(6, 8));\n+        cpioArchiveEntry.setTime(this.readAsciiLong(11, 8));\n+        final long asciiLong2 = this.readAsciiLong(6, 8);\n+        cpioArchiveEntry.setSize(this.readAsciiLong(11, 8));\n+        final String cString = this.readCString((int)asciiLong2);\n+        cpioArchiveEntry.setName(cString);\n+        if (CpioUtil.fileType(asciiLong) == 0L && !cString.equals(\"TRAILER!!!\")) {\n+            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \" + ArchiveUtils.sanitize(cString) + \" Occured at byte: \" + this.getBytesRead());\n+        }\n+        return cpioArchiveEntry;\n+    }\n+    \n+    private CpioArchiveEntry readOldBinaryEntry(final boolean b) throws IOException {\n+        final CpioArchiveEntry cpioArchiveEntry = new CpioArchiveEntry((short)8);\n+        cpioArchiveEntry.setDevice(this.readBinaryLong(2, b));\n+        cpioArchiveEntry.setInode(this.readBinaryLong(2, b));\n+        final long binaryLong = this.readBinaryLong(2, b);\n+        if (CpioUtil.fileType(binaryLong) != 0L) {\n+            cpioArchiveEntry.setMode(binaryLong);\n+        }\n+        cpioArchiveEntry.setUID(this.readBinaryLong(2, b));\n+        cpioArchiveEntry.setGID(this.readBinaryLong(2, b));\n+        cpioArchiveEntry.setNumberOfLinks(this.readBinaryLong(2, b));\n+        cpioArchiveEntry.setRemoteDevice(this.readBinaryLong(2, b));\n+        cpioArchiveEntry.setTime(this.readBinaryLong(4, b));\n+        final long binaryLong2 = this.readBinaryLong(2, b);\n+        cpioArchiveEntry.setSize(this.readBinaryLong(4, b));\n+        final String cString = this.readCString((int)binaryLong2);\n+        cpioArchiveEntry.setName(cString);\n+        if (CpioUtil.fileType(binaryLong) == 0L && !cString.equals(\"TRAILER!!!\")) {\n+            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \" + ArchiveUtils.sanitize(cString) + \"Occured at byte: \" + this.getBytesRead());\n+        }\n+        this.skip(cpioArchiveEntry.getHeaderPadCount());\n+        return cpioArchiveEntry;\n+    }\n+    \n+    private String readCString(final int n) throws IOException {\n+        final byte[] array = new byte[n - 1];\n+        this.readFully(array, 0, array.length);\n         this.in.read();\n-        return this.zipEncoding.decode(tmpBuffer);\n+        return this.zipEncoding.decode(array);\n     }\n     \n-    public long skip(final long n) throws IOException {\n-        if (n < 0L) {\n+    public long skip(final long a) throws IOException {\n+        if (a < 0L) {\n             throw new IllegalArgumentException(\"negative skip length\");\n         }\n         this.ensureOpen();\n-        int max;\n-        int total;\n-        int len;\n-        for (max = (int)Math.min(n, 2147483647L), total = 0; total < max; total += len) {\n-            len = max - total;\n-            if (len > this.tmpbuf.length) {\n-                len = this.tmpbuf.length;\n+        int n;\n+        int i;\n+        int read;\n+        for (n = (int)Math.min(a, 2147483647L), i = 0; i < n; i += read) {\n+            int length = n - i;\n+            if (length > this.tmpbuf.length) {\n+                length = this.tmpbuf.length;\n             }\n-            len = this.read(this.tmpbuf, 0, len);\n-            if (len == -1) {\n+            read = this.read(this.tmpbuf, 0, length);\n+            if (read == -1) {\n                 this.entryEOF = true;\n                 break;\n             }\n         }\n-        return total;\n+        return i;\n     }\n     \n     public ArchiveEntry getNextEntry() throws IOException {\n         return (ArchiveEntry)this.getNextCPIOEntry();\n     }\n     \n     private void skipRemainderOfLastBlock() throws IOException {\n-        final long readFromLastBlock = this.getBytesRead() % this.blockSize;\n-        long skipped;\n-        for (long remainingBytes = (readFromLastBlock == 0L) ? 0L : (this.blockSize - readFromLastBlock); remainingBytes > 0L; remainingBytes -= skipped) {\n-            skipped = this.skip((long)this.blockSize - readFromLastBlock);\n-            if (skipped <= 0L) {\n+        final long n = this.getBytesRead() % this.blockSize;\n+        long skip;\n+        for (long n2 = (n == 0L) ? 0L : (this.blockSize - n); n2 > 0L; n2 -= skip) {\n+            skip = this.skip((long)this.blockSize - n);\n+            if (skip <= 0L) {\n                 break;\n             }\n         }\n     }\n     \n-    public static boolean matches(final byte[] signature, final int length) {\n-        return length >= 6 && ((signature[0] == 113 && (signature[1] & 0xFF) == 0xC7) || (signature[1] == 113 && (signature[0] & 0xFF) == 0xC7) || (signature[0] == 48 && signature[1] == 55 && signature[2] == 48 && signature[3] == 55 && signature[4] == 48 && (signature[5] == 49 || signature[5] == 50 || signature[5] == 55)));\n+    public static boolean matches(final byte[] array, final int n) {\n+        return n >= 6 && ((array[0] == 113 && (array[1] & 0xFF) == 0xC7) || (array[1] == 113 && (array[0] & 0xFF) == 0xC7) || (array[0] == 48 && array[1] == 55 && array[2] == 48 && array[3] == 55 && array[4] == 48 && (array[5] == 49 || array[5] == 50 || array[5] == 55)));\n     }\n }\n"}]}
