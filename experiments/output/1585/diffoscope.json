{"diffoscope-json-version": 1, "source1": "first/SevenZFile.class", "source2": "second/SevenZFile.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -155,20 +155,29 @@\n             return archive;\n         }\n         throw new IOException(\"Broken or unsupported archive: no Header\");\n     }\n     \n     private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\n         final StartHeader startHeader = new StartHeader();\n-        try (final DataInputStream dataInputStream = new DataInputStream((InputStream)new CRC32VerifyingInputStream((InputStream)new BoundedSeekableByteChannelInputStream(this.channel, 20L), 20L, startHeaderCrc))) {\n+        final DataInputStream dataInputStream = new DataInputStream((InputStream)new CRC32VerifyingInputStream((InputStream)new BoundedSeekableByteChannelInputStream(this.channel, 20L), 20L, startHeaderCrc));\n+        Throwable x0 = null;\n+        try {\n             startHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\n             startHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\n             startHeader.nextHeaderCrc = (0xFFFFFFFFL & (long)Integer.reverseBytes(dataInputStream.readInt()));\n             return startHeader;\n         }\n+        catch (final Throwable t) {\n+            x0 = t;\n+            throw t;\n+        }\n+        finally {\n+            $closeResource(x0, dataInputStream);\n+        }\n     }\n     \n     private void readHeader(final ByteBuffer header, final Archive archive) throws IOException {\n         int nid = getUnsignedByte(header);\n         if (nid == 2) {\n             this.readArchiveProperties(header);\n             nid = getUnsignedByte(header);\n@@ -210,17 +219,26 @@\n             }\n             inputStreamStack = Coders.addDecoder(this.fileName, inputStreamStack, folder.getUnpackSizeForCoder(coder), coder, password);\n         }\n         if (folder.hasCrc) {\n             inputStreamStack = (InputStream)new CRC32VerifyingInputStream(inputStreamStack, folder.getUnpackSize(), folder.crc);\n         }\n         final byte[] nextHeader = new byte[(int)folder.getUnpackSize()];\n-        try (final DataInputStream nextHeaderInputStream = new DataInputStream(inputStreamStack)) {\n+        final DataInputStream nextHeaderInputStream = new DataInputStream(inputStreamStack);\n+        Throwable x0 = null;\n+        try {\n             nextHeaderInputStream.readFully(nextHeader);\n         }\n+        catch (final Throwable t) {\n+            x0 = t;\n+            throw t;\n+        }\n+        finally {\n+            $closeResource(x0, nextHeaderInputStream);\n+        }\n         return ByteBuffer.wrap(nextHeader).order(ByteOrder.LITTLE_ENDIAN);\n     }\n     \n     private void readStreamsInfo(final ByteBuffer header, final Archive archive) throws IOException {\n         int nid = getUnsignedByte(header);\n         if (nid == 6) {\n             this.readPackInfo(header, archive);\n@@ -260,15 +278,15 @@\n                 if (archive.packCrcsDefined.get(i)) {\n                     archive.packCrcs[i] = (0xFFFFFFFFL & (long)header.getInt());\n                 }\n             }\n             nid = getUnsignedByte(header);\n         }\n         if (nid != 0) {\n-            throw new IOException(\"Badly terminated PackInfo (\" + nid + \")\");\n+            throw new IOException(\"Badly terminated PackInfo (\" + nid);\n         }\n     }\n     \n     private void readUnpackInfo(final ByteBuffer header, final Archive archive) throws IOException {\n         int nid = getUnsignedByte(header);\n         if (nid != 11) {\n             throw new IOException(\"Expected kFolder, got \" + nid);\n@@ -744,17 +762,28 @@\n         if (this.archive.files[this.currentEntryIndex].getSize() == 0L) {\n             return new ByteArrayInputStream(new byte[0]);\n         }\n         if (this.deferredBlockStreams.isEmpty()) {\n             throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n         }\n         while (this.deferredBlockStreams.size() > 1) {\n-            try (final InputStream stream = (InputStream)this.deferredBlockStreams.remove(0)) {\n+            final InputStream stream = (InputStream)this.deferredBlockStreams.remove(0);\n+            Throwable x0 = null;\n+            try {\n                 IOUtils.skip(stream, Long.MAX_VALUE);\n             }\n+            catch (final Throwable t) {\n+                x0 = t;\n+                throw t;\n+            }\n+            finally {\n+                if (stream != null) {\n+                    $closeResource(x0, stream);\n+                }\n+            }\n         }\n         return this.deferredBlockStreams.get(0);\n     }\n     \n     public int read(final byte[] b) throws IOException {\n         return this.read(b, 0, b.length);\n     }\n@@ -799,26 +828,40 @@\n             return 0L;\n         }\n         final int current = input.position();\n         final int maxSkip = input.remaining();\n         if (maxSkip < bytesToSkip) {\n             bytesToSkip = maxSkip;\n         }\n-        input.position();\n+        input.position(current + (int)bytesToSkip);\n         return bytesToSkip;\n     }\n     \n     private void readFully(final ByteBuffer buf) throws IOException {\n         buf.rewind();\n         IOUtils.readFully((ReadableByteChannel)this.channel, buf);\n         buf.flip();\n     }\n     \n     @Override\n     public String toString() {\n         return this.archive.toString();\n     }\n     \n+    private static /* synthetic */ void $closeResource(final Throwable x0, final AutoCloseable x1) {\n+        if (x0 != null) {\n+            try {\n+                x1.close();\n+            }\n+            catch (final Throwable exception) {\n+                x0.addSuppressed(exception);\n+            }\n+        }\n+        else {\n+            x1.close();\n+        }\n+    }\n+    \n     static {\n         sevenZSignature = new byte[] { 55, 122, -68, -81, 39, 28 };\n     }\n }\n"}]}
