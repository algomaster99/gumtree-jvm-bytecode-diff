{"diffoscope-json-version": 1, "source1": "first/ObjectUtils.class", "source2": "second/ObjectUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -8,370 +8,364 @@\n import java.util.TreeSet;\n import java.util.Comparator;\n import java.util.Map;\n import java.util.Collection;\n import org.apache.commons.lang3.text.StrBuilder;\n import java.io.IOException;\n import java.util.function.Supplier;\n-import java.lang.reflect.Method;\n import java.lang.reflect.InvocationTargetException;\n import org.apache.commons.lang3.exception.CloneFailedException;\n import java.lang.reflect.Array;\n \n public class ObjectUtils\n {\n     private static final char AT_SIGN = '@';\n     public static final ObjectUtils.Null NULL;\n     \n-    public static boolean allNull(final Object... values) {\n-        return !anyNotNull(values);\n+    public static boolean allNull(final Object... array) {\n+        return !anyNotNull(array);\n     }\n     \n-    public static boolean allNotNull(final Object... values) {\n-        if (values == null) {\n+    public static boolean allNotNull(final Object... array) {\n+        if (array == null) {\n             return false;\n         }\n-        for (final Object val : values) {\n-            if (val == null) {\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            if (array[i] == null) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    public static boolean anyNull(final Object... values) {\n-        return !allNotNull(values);\n+    public static boolean anyNull(final Object... array) {\n+        return !allNotNull(array);\n     }\n     \n-    public static boolean anyNotNull(final Object... values) {\n-        return firstNonNull(values) != null;\n+    public static boolean anyNotNull(final Object... array) {\n+        return firstNonNull(array) != null;\n     }\n     \n     public static <T> T clone(final T obj) {\n         if (obj instanceof Cloneable) {\n-            Object result;\n+            Object o;\n             if (obj.getClass().isArray()) {\n                 final Class<?> componentType = obj.getClass().getComponentType();\n                 if (componentType.isPrimitive()) {\n                     int length = Array.getLength(obj);\n-                    result = Array.newInstance(componentType, length);\n+                    o = Array.newInstance(componentType, length);\n                     while (length-- > 0) {\n-                        Array.set(result, length, Array.get((Object)obj, length));\n+                        Array.set(o, length, Array.get((Object)obj, length));\n                     }\n                 }\n                 else {\n-                    result = ((Object[])(Object)obj).clone();\n+                    o = ((Object[])(Object)obj).clone();\n                 }\n             }\n             else {\n                 try {\n-                    final Method clone = obj.getClass().getMethod(\"clone\", (Class<?>[])new Class[0]);\n-                    result = clone.invoke(obj, new Object[0]);\n+                    o = obj.getClass().getMethod(\"clone\", (Class<?>[])new Class[0]).invoke(obj, new Object[0]);\n                 }\n-                catch (final NoSuchMethodException e) {\n-                    throw new CloneFailedException(\"Cloneable type \" + obj.getClass().getName() + \" has no clone method\", (Throwable)e);\n+                catch (final NoSuchMethodException ex) {\n+                    throw new CloneFailedException(\"Cloneable type \" + obj.getClass().getName() + \" has no clone method\", (Throwable)ex);\n                 }\n-                catch (final IllegalAccessException e2) {\n-                    throw new CloneFailedException(\"Cannot clone Cloneable type \" + obj.getClass().getName(), (Throwable)e2);\n+                catch (final IllegalAccessException ex2) {\n+                    throw new CloneFailedException(\"Cannot clone Cloneable type \" + obj.getClass().getName(), (Throwable)ex2);\n                 }\n-                catch (final InvocationTargetException e3) {\n-                    throw new CloneFailedException(\"Exception cloning Cloneable type \" + obj.getClass().getName(), e3.getCause());\n+                catch (final InvocationTargetException ex3) {\n+                    throw new CloneFailedException(\"Exception cloning Cloneable type \" + obj.getClass().getName(), ex3.getCause());\n                 }\n             }\n-            final T checked = (T)result;\n-            return checked;\n+            return (T)o;\n         }\n         return null;\n     }\n     \n-    public static <T> T cloneIfPossible(final T obj) {\n-        final T clone = (T)clone((Object)obj);\n-        return (clone == null) ? obj : clone;\n+    public static <T> T cloneIfPossible(final T t) {\n+        final Object clone = clone((Object)t);\n+        return (T)((clone == null) ? t : clone);\n     }\n     \n-    public static <T extends Comparable<? super T>> int compare(final T c1, final T c2) {\n-        return compare(c1, c2, false);\n+    public static <T extends Comparable<? super T>> int compare(final T t, final T t2) {\n+        return compare(t, t2, false);\n     }\n     \n-    public static <T extends Comparable<? super T>> int compare(final T c1, final T c2, final boolean nullGreater) {\n-        if (c1 == c2) {\n+    public static <T extends Comparable<? super T>> int compare(final T t, final T t2, final boolean b) {\n+        if (t == t2) {\n             return 0;\n         }\n-        if (c1 == null) {\n-            return nullGreater ? 1 : -1;\n+        if (t == null) {\n+            return b ? 1 : -1;\n         }\n-        if (c2 == null) {\n-            return nullGreater ? -1 : 1;\n+        if (t2 == null) {\n+            return b ? -1 : 1;\n         }\n-        return c1.compareTo(c2);\n+        return t.compareTo(t2);\n     }\n     \n-    public static boolean CONST(final boolean v) {\n-        return v;\n+    public static boolean CONST(final boolean b) {\n+        return b;\n     }\n     \n-    public static byte CONST(final byte v) {\n-        return v;\n+    public static byte CONST(final byte b) {\n+        return b;\n     }\n     \n-    public static char CONST(final char v) {\n-        return v;\n+    public static char CONST(final char c) {\n+        return c;\n     }\n     \n-    public static double CONST(final double v) {\n-        return v;\n+    public static double CONST(final double n) {\n+        return n;\n     }\n     \n-    public static float CONST(final float v) {\n-        return v;\n+    public static float CONST(final float n) {\n+        return n;\n     }\n     \n-    public static int CONST(final int v) {\n-        return v;\n+    public static int CONST(final int n) {\n+        return n;\n     }\n     \n-    public static long CONST(final long v) {\n-        return v;\n+    public static long CONST(final long n) {\n+        return n;\n     }\n     \n-    public static short CONST(final short v) {\n-        return v;\n+    public static short CONST(final short n) {\n+        return n;\n     }\n     \n-    public static <T> T CONST(final T v) {\n-        return v;\n+    public static <T> T CONST(final T t) {\n+        return t;\n     }\n     \n-    public static byte CONST_BYTE(final int v) {\n-        if (v < -128 || v > 127) {\n-            throw new IllegalArgumentException(\"Supplied value must be a valid byte literal between -128 and 127: [\" + v + \"]\");\n+    public static byte CONST_BYTE(final int i) {\n+        if (i < -128 || i > 127) {\n+            throw new IllegalArgumentException(\"Supplied value must be a valid byte literal between -128 and 127: [\" + i + \"]\");\n         }\n-        return (byte)v;\n+        return (byte)i;\n     }\n     \n-    public static short CONST_SHORT(final int v) {\n-        if (v < -32768 || v > 32767) {\n-            throw new IllegalArgumentException(\"Supplied value must be a valid byte literal between -32768 and 32767: [\" + v + \"]\");\n+    public static short CONST_SHORT(final int i) {\n+        if (i < -32768 || i > 32767) {\n+            throw new IllegalArgumentException(\"Supplied value must be a valid byte literal between -32768 and 32767: [\" + i + \"]\");\n         }\n-        return (short)v;\n+        return (short)i;\n     }\n     \n-    public static <T> T defaultIfNull(final T object, final T defaultValue) {\n-        return (object != null) ? object : defaultValue;\n+    public static <T> T defaultIfNull(final T t, final T t2) {\n+        return (t != null) ? t : t2;\n     }\n     \n     @Deprecated\n-    public static boolean equals(final Object object1, final Object object2) {\n-        return object1 == object2 || (object1 != null && object2 != null && object1.equals(object2));\n+    public static boolean equals(final Object o, final Object obj) {\n+        return o == obj || (o != null && obj != null && o.equals(obj));\n     }\n     \n     @SafeVarargs\n-    public static <T> T firstNonNull(final T... values) {\n-        if (values != null) {\n-            for (final T val : values) {\n-                if (val != null) {\n-                    return val;\n+    public static <T> T firstNonNull(final T... array) {\n+        if (array != null) {\n+            for (final T t : array) {\n+                if (t != null) {\n+                    return t;\n                 }\n             }\n         }\n         return null;\n     }\n     \n     @SafeVarargs\n-    public static <T> T getFirstNonNull(final Supplier<T>... suppliers) {\n-        if (suppliers != null) {\n-            for (final Supplier<T> supplier : suppliers) {\n+    public static <T> T getFirstNonNull(final Supplier<T>... array) {\n+        if (array != null) {\n+            for (final Supplier<T> supplier : array) {\n                 if (supplier != null) {\n                     final T value = supplier.get();\n                     if (value != null) {\n                         return value;\n                     }\n                 }\n             }\n         }\n         return null;\n     }\n     \n-    public static <T> T getIfNull(final T object, final Supplier<T> defaultSupplier) {\n-        return (object != null) ? object : ((defaultSupplier == null) ? null : defaultSupplier.get());\n+    public static <T> T getIfNull(final T t, final Supplier<T> supplier) {\n+        return (t != null) ? t : ((supplier == null) ? null : supplier.get());\n     }\n     \n     @Deprecated\n-    public static int hashCode(final Object obj) {\n-        return (obj == null) ? 0 : obj.hashCode();\n+    public static int hashCode(final Object o) {\n+        return (o == null) ? 0 : o.hashCode();\n     }\n     \n     @Deprecated\n-    public static int hashCodeMulti(final Object... objects) {\n-        int hash = 1;\n-        if (objects != null) {\n-            for (final Object object : objects) {\n-                final int tmpHash = hashCode(object);\n-                hash = hash * 31 + tmpHash;\n+    public static int hashCodeMulti(final Object... array) {\n+        int n = 1;\n+        if (array != null) {\n+            for (int length = array.length, i = 0; i < length; ++i) {\n+                n = n * 31 + hashCode(array[i]);\n             }\n         }\n-        return hash;\n+        return n;\n     }\n     \n-    public static void identityToString(final Appendable appendable, final Object object) throws IOException {\n-        Validate.notNull(object, \"Cannot get the toString of a null object\", new Object[0]);\n-        appendable.append(object.getClass().getName()).append('@').append(Integer.toHexString(System.identityHashCode(object)));\n+    public static void identityToString(final Appendable appendable, final Object o) throws IOException {\n+        Validate.notNull(o, \"Cannot get the toString of a null object\", new Object[0]);\n+        appendable.append(o.getClass().getName()).append('@').append(Integer.toHexString(System.identityHashCode(o)));\n     }\n     \n-    public static String identityToString(final Object object) {\n-        if (object == null) {\n+    public static String identityToString(final Object o) {\n+        if (o == null) {\n             return null;\n         }\n-        final String name = object.getClass().getName();\n-        final String hexString = Integer.toHexString(System.identityHashCode(object));\n-        final StringBuilder builder = new StringBuilder(name.length() + 1 + hexString.length());\n-        builder.append(name).append('@').append(hexString);\n-        return builder.toString();\n+        final String name = o.getClass().getName();\n+        final String hexString = Integer.toHexString(System.identityHashCode(o));\n+        final StringBuilder sb = new StringBuilder(name.length() + 1 + hexString.length());\n+        sb.append(name).append('@').append(hexString);\n+        return sb.toString();\n     }\n     \n     @Deprecated\n-    public static void identityToString(final StrBuilder builder, final Object object) {\n-        Validate.notNull(object, \"Cannot get the toString of a null object\", new Object[0]);\n-        final String name = object.getClass().getName();\n-        final String hexString = Integer.toHexString(System.identityHashCode(object));\n-        builder.ensureCapacity(builder.length() + name.length() + 1 + hexString.length());\n-        builder.append(name).append('@').append(hexString);\n-    }\n-    \n-    public static void identityToString(final StringBuffer buffer, final Object object) {\n-        Validate.notNull(object, \"Cannot get the toString of a null object\", new Object[0]);\n-        final String name = object.getClass().getName();\n-        final String hexString = Integer.toHexString(System.identityHashCode(object));\n-        buffer.ensureCapacity(buffer.length() + name.length() + 1 + hexString.length());\n-        buffer.append(name).append('@').append(hexString);\n-    }\n-    \n-    public static void identityToString(final StringBuilder builder, final Object object) {\n-        Validate.notNull(object, \"Cannot get the toString of a null object\", new Object[0]);\n-        final String name = object.getClass().getName();\n-        final String hexString = Integer.toHexString(System.identityHashCode(object));\n-        builder.ensureCapacity();\n-        builder.append(name).append('@').append(hexString);\n+    public static void identityToString(final StrBuilder strBuilder, final Object o) {\n+        Validate.notNull(o, \"Cannot get the toString of a null object\", new Object[0]);\n+        final String name = o.getClass().getName();\n+        final String hexString = Integer.toHexString(System.identityHashCode(o));\n+        strBuilder.ensureCapacity(strBuilder.length() + name.length() + 1 + hexString.length());\n+        strBuilder.append(name).append('@').append(hexString);\n+    }\n+    \n+    public static void identityToString(final StringBuffer sb, final Object o) {\n+        Validate.notNull(o, \"Cannot get the toString of a null object\", new Object[0]);\n+        final String name = o.getClass().getName();\n+        final String hexString = Integer.toHexString(System.identityHashCode(o));\n+        sb.ensureCapacity(sb.length() + name.length() + 1 + hexString.length());\n+        sb.append(name).append('@').append(hexString);\n+    }\n+    \n+    public static void identityToString(final StringBuilder sb, final Object o) {\n+        Validate.notNull(o, \"Cannot get the toString of a null object\", new Object[0]);\n+        final String name = o.getClass().getName();\n+        final String hexString = Integer.toHexString(System.identityHashCode(o));\n+        sb.ensureCapacity();\n+        sb.append(name).append('@').append(hexString);\n     }\n     \n-    public static boolean isEmpty(final Object object) {\n-        if (object == null) {\n+    public static boolean isEmpty(final Object o) {\n+        if (o == null) {\n             return true;\n         }\n-        if (object instanceof CharSequence) {\n-            return ((CharSequence)object).length() == 0;\n+        if (o instanceof CharSequence) {\n+            return ((CharSequence)o).length() == 0;\n         }\n-        if (object.getClass().isArray()) {\n-            return Array.getLength(object) == 0;\n+        if (o.getClass().isArray()) {\n+            return Array.getLength(o) == 0;\n         }\n-        if (object instanceof Collection) {\n-            return ((Collection)object).isEmpty();\n+        if (o instanceof Collection) {\n+            return ((Collection)o).isEmpty();\n         }\n-        return object instanceof Map && ((Map)object).isEmpty();\n+        return o instanceof Map && ((Map)o).isEmpty();\n     }\n     \n-    public static boolean isNotEmpty(final Object object) {\n-        return !isEmpty(object);\n+    public static boolean isNotEmpty(final Object o) {\n+        return !isEmpty(o);\n     }\n     \n     @SafeVarargs\n-    public static <T extends Comparable<? super T>> T max(final T... values) {\n-        T result = null;\n-        if (values != null) {\n-            for (final T value : values) {\n-                if (compare(value, result, false) > 0) {\n-                    result = value;\n+    public static <T extends Comparable<? super T>> T max(final T... array) {\n+        Comparable<? super T> comparable = null;\n+        if (array != null) {\n+            for (final Comparable<? super T> comparable2 : array) {\n+                if (compare(comparable2, comparable, false) > 0) {\n+                    comparable = comparable2;\n                 }\n             }\n         }\n-        return result;\n+        return (T)comparable;\n     }\n     \n     @SafeVarargs\n-    public static <T> T median(final Comparator<T> comparator, final T... items) {\n-        Validate.notEmpty((Object[])items, \"null/empty items\", new Object[0]);\n-        Validate.noNullElements((Object[])items);\n+    public static <T> T median(final Comparator<T> comparator, final T... elements) {\n+        Validate.notEmpty((Object[])elements, \"null/empty items\", new Object[0]);\n+        Validate.noNullElements((Object[])elements);\n         Validate.notNull((Object)comparator, \"null comparator\", new Object[0]);\n-        final TreeSet<T> sort = new TreeSet<T>(comparator);\n-        Collections.addAll(sort, items);\n-        final T result = (T)sort.toArray()[(sort.size() - 1) / 2];\n-        return result;\n+        final TreeSet c = new TreeSet((Comparator<? super E>)comparator);\n+        Collections.addAll(c, elements);\n+        return (T)c.toArray()[(c.size() - 1) / 2];\n     }\n     \n     @SafeVarargs\n-    public static <T extends Comparable<? super T>> T median(final T... items) {\n-        Validate.notEmpty((Object[])items);\n-        Validate.noNullElements((Object[])items);\n-        final TreeSet<T> sort = new TreeSet<T>();\n-        Collections.addAll(sort, items);\n-        final T result = (T)sort.toArray()[(sort.size() - 1) / 2];\n-        return result;\n+    public static <T extends Comparable<? super T>> T median(final T... elements) {\n+        Validate.notEmpty((Object[])elements);\n+        Validate.noNullElements((Object[])elements);\n+        final TreeSet c = new TreeSet();\n+        Collections.addAll(c, elements);\n+        return (T)c.toArray()[(c.size() - 1) / 2];\n     }\n     \n     @SafeVarargs\n-    public static <T extends Comparable<? super T>> T min(final T... values) {\n-        T result = null;\n-        if (values != null) {\n-            for (final T value : values) {\n-                if (compare(value, result, true) < 0) {\n-                    result = value;\n+    public static <T extends Comparable<? super T>> T min(final T... array) {\n+        Comparable<? super T> comparable = null;\n+        if (array != null) {\n+            for (final Comparable<? super T> comparable2 : array) {\n+                if (compare(comparable2, comparable, true) < 0) {\n+                    comparable = comparable2;\n                 }\n             }\n         }\n-        return result;\n+        return (T)comparable;\n     }\n     \n     @SafeVarargs\n-    public static <T> T mode(final T... items) {\n-        if (ArrayUtils.isNotEmpty((Object[])items)) {\n-            final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(items.length);\n-            for (final T t : items) {\n-                final MutableInt count = (MutableInt)occurrences.get(t);\n-                if (count == null) {\n-                    occurrences.put(t, new MutableInt(1));\n+    public static <T> T mode(final T... array) {\n+        if (ArrayUtils.isNotEmpty((Object[])array)) {\n+            final HashMap hashMap = new HashMap(array.length);\n+            for (final T t : array) {\n+                final MutableInt mutableInt = (MutableInt)hashMap.get(t);\n+                if (mutableInt == null) {\n+                    hashMap.put(t, new MutableInt(1));\n                 }\n                 else {\n-                    count.increment();\n+                    mutableInt.increment();\n                 }\n             }\n-            T result = null;\n-            int max = 0;\n-            for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n-                final int cmp = ((MutableInt)e.getValue()).intValue();\n-                if (cmp == max) {\n-                    result = null;\n+            Object key = null;\n+            int n = 0;\n+            for (final Map.Entry entry : hashMap.entrySet()) {\n+                final int intValue = ((MutableInt)entry.getValue()).intValue();\n+                if (intValue == n) {\n+                    key = null;\n                 }\n                 else {\n-                    if (cmp <= max) {\n+                    if (intValue <= n) {\n                         continue;\n                     }\n-                    max = cmp;\n-                    result = e.getKey();\n+                    n = intValue;\n+                    key = entry.getKey();\n                 }\n             }\n-            return result;\n+            return (T)key;\n         }\n         return null;\n     }\n     \n-    public static boolean notEqual(final Object object1, final Object object2) {\n-        return !equals(object1, object2);\n+    public static boolean notEqual(final Object o, final Object o2) {\n+        return !equals(o, o2);\n     }\n     \n     @Deprecated\n-    public static String toString(final Object obj) {\n-        return (obj == null) ? \"\" : obj.toString();\n+    public static String toString(final Object o) {\n+        return (o == null) ? \"\" : o.toString();\n     }\n     \n     @Deprecated\n-    public static String toString(final Object obj, final String nullStr) {\n-        return (obj == null) ? nullStr : obj.toString();\n+    public static String toString(final Object o, final String s) {\n+        return (o == null) ? s : o.toString();\n     }\n     \n-    public static String toString(final Object obj, final Supplier<String> supplier) {\n-        return (obj == null) ? ((supplier == null) ? null : ((String)supplier.get())) : obj.toString();\n+    public static String toString(final Object o, final Supplier<String> supplier) {\n+        return (o == null) ? ((supplier == null) ? null : ((String)supplier.get())) : o.toString();\n     }\n     \n     static {\n         NULL = new ObjectUtils.Null();\n     }\n }\n"}]}
