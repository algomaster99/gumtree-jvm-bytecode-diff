{"diffoscope-json-version": 1, "source1": "first/DumpArchiveInputStream.class", "source2": "second/DumpArchiveInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -34,42 +34,41 @@\n     protected TapeInputStream raw;\n     private final Map<Integer, Dirent> names;\n     private final Map<Integer, DumpArchiveEntry> pending;\n     private Queue<DumpArchiveEntry> queue;\n     private final ZipEncoding zipEncoding;\n     final String encoding;\n     \n-    public DumpArchiveInputStream(final InputStream is) throws ArchiveException {\n-        this(is, null);\n+    public DumpArchiveInputStream(final InputStream inputStream) throws ArchiveException {\n+        this(inputStream, null);\n     }\n     \n-    public DumpArchiveInputStream(final InputStream is, final String encoding) throws ArchiveException {\n+    public DumpArchiveInputStream(final InputStream inputStream, final String encoding) throws ArchiveException {\n         this.readBuf = new byte[1024];\n         this.names = new HashMap<Integer, Dirent>();\n         this.pending = new HashMap<Integer, DumpArchiveEntry>();\n-        this.raw = new TapeInputStream(is);\n+        this.raw = new TapeInputStream(inputStream);\n         this.hasHitEOF = false;\n         this.encoding = encoding;\n         this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n         try {\n-            final byte[] headerBytes = this.raw.readRecord();\n-            if (!DumpArchiveUtil.verify(headerBytes)) {\n+            final byte[] record = this.raw.readRecord();\n+            if (!DumpArchiveUtil.verify(record)) {\n                 throw new UnrecognizedFormatException();\n             }\n-            this.summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n+            this.summary = new DumpArchiveSummary(record, this.zipEncoding);\n             this.raw.resetBlockSize(this.summary.getNTRec(), this.summary.isCompressed());\n             this.blockBuffer = new byte[4096];\n             this.readCLRI();\n             this.readBITS();\n         }\n         catch (final IOException ex) {\n             throw new ArchiveException(ex.getMessage(), (Exception)ex);\n         }\n-        final Dirent root = new Dirent(2, 2, 4, \".\");\n-        this.names.put(Integer.valueOf(2), root);\n+        this.names.put(Integer.valueOf(2), new Dirent(2, 2, 4, \".\"));\n         this.queue = new PriorityQueue<DumpArchiveEntry>(10, (Comparator<? super DumpArchiveEntry>)new DumpArchiveInputStream.DumpArchiveInputStream$1(this));\n     }\n     \n     @Deprecated\n     public int getCount() {\n         return (int)this.getBytesRead();\n     }\n@@ -79,240 +78,239 @@\n     }\n     \n     public DumpArchiveSummary getSummary() {\n         return this.summary;\n     }\n     \n     private void readCLRI() throws IOException {\n-        final byte[] buffer = this.raw.readRecord();\n-        if (!DumpArchiveUtil.verify(buffer)) {\n+        final byte[] record = this.raw.readRecord();\n+        if (!DumpArchiveUtil.verify(record)) {\n             throw new InvalidFormatException();\n         }\n-        this.active = DumpArchiveEntry.parse(buffer);\n+        this.active = DumpArchiveEntry.parse(record);\n         if (DumpArchiveConstants.SEGMENT_TYPE.CLRI != this.active.getHeaderType()) {\n             throw new InvalidFormatException();\n         }\n         if (this.raw.skip(1024L * (long)this.active.getHeaderCount()) == -1L) {\n             throw new EOFException();\n         }\n         this.readIdx = this.active.getHeaderCount();\n     }\n     \n     private void readBITS() throws IOException {\n-        final byte[] buffer = this.raw.readRecord();\n-        if (!DumpArchiveUtil.verify(buffer)) {\n+        final byte[] record = this.raw.readRecord();\n+        if (!DumpArchiveUtil.verify(record)) {\n             throw new InvalidFormatException();\n         }\n-        this.active = DumpArchiveEntry.parse(buffer);\n+        this.active = DumpArchiveEntry.parse(record);\n         if (DumpArchiveConstants.SEGMENT_TYPE.BITS != this.active.getHeaderType()) {\n             throw new InvalidFormatException();\n         }\n         if (this.raw.skip(1024L * (long)this.active.getHeaderCount()) == -1L) {\n             throw new EOFException();\n         }\n         this.readIdx = this.active.getHeaderCount();\n     }\n     \n     public DumpArchiveEntry getNextDumpEntry() throws IOException {\n         return this.getNextEntry();\n     }\n     \n     public DumpArchiveEntry getNextEntry() throws IOException {\n-        DumpArchiveEntry entry = null;\n+        DumpArchiveEntry active = null;\n         String path = null;\n         if (!this.queue.isEmpty()) {\n             return this.queue.remove();\n         }\n-        while (entry == null) {\n+        while (active == null) {\n             if (this.hasHitEOF) {\n                 return null;\n             }\n             while (this.readIdx < this.active.getHeaderCount()) {\n                 if (!this.active.isSparseRecord(this.readIdx++) && this.raw.skip(1024L) == -1L) {\n                     throw new EOFException();\n                 }\n             }\n             this.readIdx = 0;\n             this.filepos = this.raw.getBytesRead();\n-            byte[] headerBytes = this.raw.readRecord();\n-            if (!DumpArchiveUtil.verify(headerBytes)) {\n+            final byte[] record = this.raw.readRecord();\n+            if (!DumpArchiveUtil.verify(record)) {\n                 throw new InvalidFormatException();\n             }\n-            this.active = DumpArchiveEntry.parse(headerBytes);\n+            this.active = DumpArchiveEntry.parse(record);\n             while (DumpArchiveConstants.SEGMENT_TYPE.ADDR == this.active.getHeaderType()) {\n                 if (this.raw.skip(1024L * (long)(this.active.getHeaderCount() - this.active.getHeaderHoles())) == -1L) {\n                     throw new EOFException();\n                 }\n                 this.filepos = this.raw.getBytesRead();\n-                headerBytes = this.raw.readRecord();\n-                if (!DumpArchiveUtil.verify(headerBytes)) {\n+                final byte[] record2 = this.raw.readRecord();\n+                if (!DumpArchiveUtil.verify(record2)) {\n                     throw new InvalidFormatException();\n                 }\n-                this.active = DumpArchiveEntry.parse(headerBytes);\n+                this.active = DumpArchiveEntry.parse(record2);\n             }\n             if (DumpArchiveConstants.SEGMENT_TYPE.END == this.active.getHeaderType()) {\n                 this.hasHitEOF = true;\n                 return null;\n             }\n-            entry = this.active;\n-            if (entry.isDirectory()) {\n+            active = this.active;\n+            if (active.isDirectory()) {\n                 this.readDirectoryEntry(this.active);\n                 this.entryOffset = 0L;\n                 this.entrySize = 0L;\n                 this.readIdx = this.active.getHeaderCount();\n             }\n             else {\n                 this.entryOffset = 0L;\n                 this.entrySize = this.active.getEntrySize();\n                 this.readIdx = 0;\n             }\n             this.recordOffset = this.readBuf.length;\n-            path = this.getPath(entry);\n+            path = this.getPath(active);\n             if (path != null) {\n                 continue;\n             }\n-            entry = null;\n+            active = null;\n         }\n-        entry.setName(path);\n-        entry.setSimpleName(((Dirent)this.names.get(Integer.valueOf(entry.getIno()))).getName());\n-        entry.setOffset(this.filepos);\n-        return entry;\n+        active.setName(path);\n+        active.setSimpleName(((Dirent)this.names.get(Integer.valueOf(active.getIno()))).getName());\n+        active.setOffset(this.filepos);\n+        return active;\n     }\n     \n-    private void readDirectoryEntry(DumpArchiveEntry entry) throws IOException {\n-        long size = entry.getEntrySize();\n-        byte[] peekBytes;\n-        for (boolean first = true; first || DumpArchiveConstants.SEGMENT_TYPE.ADDR == entry.getHeaderType(); entry = DumpArchiveEntry.parse(peekBytes), first = false, size -= 1024L) {\n-            if (!first) {\n+    private void readDirectoryEntry(DumpArchiveEntry parse) throws IOException {\n+        long entrySize = parse.getEntrySize();\n+        byte[] peek;\n+        for (int n = 1; n != 0 || DumpArchiveConstants.SEGMENT_TYPE.ADDR == parse.getHeaderType(); parse = DumpArchiveEntry.parse(peek), n = 0, entrySize -= 1024L) {\n+            if (n == 0) {\n                 this.raw.readRecord();\n             }\n-            if (!this.names.containsKey(Integer.valueOf(entry.getIno())) && DumpArchiveConstants.SEGMENT_TYPE.INODE == entry.getHeaderType()) {\n-                this.pending.put(Integer.valueOf(entry.getIno()), entry);\n+            if (!this.names.containsKey(Integer.valueOf(parse.getIno())) && DumpArchiveConstants.SEGMENT_TYPE.INODE == parse.getHeaderType()) {\n+                this.pending.put(Integer.valueOf(parse.getIno()), parse);\n             }\n-            final int datalen = 1024 * entry.getHeaderCount();\n-            if (this.blockBuffer.length < datalen) {\n-                this.blockBuffer = new byte[datalen];\n+            final int n2 = 1024 * parse.getHeaderCount();\n+            if (this.blockBuffer.length < n2) {\n+                this.blockBuffer = new byte[n2];\n             }\n-            if (this.raw.read(this.blockBuffer, 0, datalen) != datalen) {\n+            if (this.raw.read(this.blockBuffer, 0, n2) != n2) {\n                 throw new EOFException();\n             }\n-            for (int reclen = 0, i = 0; i < datalen - 8 && i < size - 8L; i += reclen) {\n-                final int ino = DumpArchiveUtil.convert32(this.blockBuffer, i);\n-                reclen = DumpArchiveUtil.convert16(this.blockBuffer, i + 4);\n-                final byte type = this.blockBuffer[i + 6];\n-                final String name = DumpArchiveUtil.decode(this.zipEncoding, this.blockBuffer, i + 8, (int)this.blockBuffer[i + 7]);\n-                if (!\".\".equals(name)) {\n-                    if (!\"..\".equals(name)) {\n-                        final Dirent d = new Dirent(ino, entry.getIno(), (int)type, name);\n-                        this.names.put(Integer.valueOf(ino), d);\n-                        for (final Map.Entry<Integer, DumpArchiveEntry> e : this.pending.entrySet()) {\n-                            final String path = this.getPath(e.getValue());\n+            int convert33;\n+            for (int n3 = 0; n3 < n2 - 8 && n3 < entrySize - 8L; n3 += convert33) {\n+                final int convert32 = DumpArchiveUtil.convert32(this.blockBuffer, n3);\n+                convert33 = DumpArchiveUtil.convert16(this.blockBuffer, n3 + 4);\n+                final byte b = this.blockBuffer[n3 + 6];\n+                final String decode = DumpArchiveUtil.decode(this.zipEncoding, this.blockBuffer, n3 + 8, (int)this.blockBuffer[n3 + 7]);\n+                if (!\".\".equals(decode)) {\n+                    if (!\"..\".equals(decode)) {\n+                        this.names.put(Integer.valueOf(convert32), new Dirent(convert32, parse.getIno(), (int)b, decode));\n+                        for (final Map.Entry entry : this.pending.entrySet()) {\n+                            final String path = this.getPath((DumpArchiveEntry)entry.getValue());\n                             if (path != null) {\n-                                ((DumpArchiveEntry)e.getValue()).setName(path);\n-                                ((DumpArchiveEntry)e.getValue()).setSimpleName(((Dirent)this.names.get(e.getKey())).getName());\n-                                this.queue.add(e.getValue());\n+                                ((DumpArchiveEntry)entry.getValue()).setName(path);\n+                                ((DumpArchiveEntry)entry.getValue()).setSimpleName(((Dirent)this.names.get(entry.getKey())).getName());\n+                                this.queue.add((DumpArchiveEntry)entry.getValue());\n                             }\n                         }\n-                        for (final DumpArchiveEntry e2 : this.queue) {\n-                            this.pending.remove(Integer.valueOf(e2.getIno()));\n+                        final Iterator<Object> iterator2 = this.queue.iterator();\n+                        while (iterator2.hasNext()) {\n+                            this.pending.remove(Integer.valueOf(((DumpArchiveEntry)iterator2.next()).getIno()));\n                         }\n                     }\n                 }\n             }\n-            peekBytes = this.raw.peek();\n-            if (!DumpArchiveUtil.verify(peekBytes)) {\n+            peek = this.raw.peek();\n+            if (!DumpArchiveUtil.verify(peek)) {\n                 throw new InvalidFormatException();\n             }\n         }\n     }\n     \n-    private String getPath(final DumpArchiveEntry entry) {\n-        final Stack<String> elements = new Stack<String>();\n-        Dirent dirent = null;\n-        int i = entry.getIno();\n+    private String getPath(final DumpArchiveEntry dumpArchiveEntry) {\n+        final Stack stack = new Stack();\n+        int n = dumpArchiveEntry.getIno();\n         while (true) {\n-            while (this.names.containsKey(Integer.valueOf(i))) {\n-                dirent = this.names.get(Integer.valueOf(i));\n-                elements.push(dirent.getName());\n+            while (this.names.containsKey(Integer.valueOf(n))) {\n+                final Dirent dirent = (Dirent)this.names.get(Integer.valueOf(n));\n+                stack.push(dirent.getName());\n                 if (dirent.getIno() == dirent.getParentIno()) {\n-                    if (elements.isEmpty()) {\n-                        this.pending.put(Integer.valueOf(entry.getIno()), entry);\n+                    if (stack.isEmpty()) {\n+                        this.pending.put(Integer.valueOf(dumpArchiveEntry.getIno()), dumpArchiveEntry);\n                         return null;\n                     }\n-                    final StringBuilder sb = new StringBuilder(elements.pop());\n-                    while (!elements.isEmpty()) {\n+                    final StringBuilder sb = new StringBuilder(stack.pop());\n+                    while (!stack.isEmpty()) {\n                         sb.append('/');\n-                        sb.append(elements.pop());\n+                        sb.append(stack.pop());\n                     }\n                     return sb.toString();\n                 }\n                 else {\n-                    i = dirent.getParentIno();\n+                    n = dirent.getParentIno();\n                 }\n             }\n-            elements.clear();\n+            stack.clear();\n             continue;\n         }\n     }\n     \n-    public int read(final byte[] buf, int off, int len) throws IOException {\n-        int totalRead = 0;\n+    public int read(final byte[] array, int n, int i) throws IOException {\n+        int n2 = 0;\n         if (this.hasHitEOF || this.isClosed || this.entryOffset >= this.entrySize) {\n             return -1;\n         }\n         if (this.active == null) {\n             throw new IllegalStateException(\"No current dump entry\");\n         }\n-        if (len + this.entryOffset > this.entrySize) {\n-            len = (int)(this.entrySize - this.entryOffset);\n+        if (i + this.entryOffset > this.entrySize) {\n+            i = (int)(this.entrySize - this.entryOffset);\n         }\n-        while (len > 0) {\n-            final int sz = (len > this.readBuf.length - this.recordOffset) ? (this.readBuf.length - this.recordOffset) : len;\n-            if (this.recordOffset + sz <= this.readBuf.length) {\n-                System.arraycopy(this.readBuf, this.recordOffset, buf, off, sz);\n-                totalRead += sz;\n-                this.recordOffset += sz;\n-                len -= sz;\n-                off += sz;\n+        while (i > 0) {\n+            final int n3 = (i > this.readBuf.length - this.recordOffset) ? (this.readBuf.length - this.recordOffset) : i;\n+            if (this.recordOffset + n3 <= this.readBuf.length) {\n+                System.arraycopy(this.readBuf, this.recordOffset, array, n, n3);\n+                n2 += n3;\n+                this.recordOffset += n3;\n+                i -= n3;\n+                n += n3;\n             }\n-            if (len > 0) {\n+            if (i > 0) {\n                 if (this.readIdx >= 512) {\n-                    final byte[] headerBytes = this.raw.readRecord();\n-                    if (!DumpArchiveUtil.verify(headerBytes)) {\n+                    final byte[] record = this.raw.readRecord();\n+                    if (!DumpArchiveUtil.verify(record)) {\n                         throw new InvalidFormatException();\n                     }\n-                    this.active = DumpArchiveEntry.parse(headerBytes);\n+                    this.active = DumpArchiveEntry.parse(record);\n                     this.readIdx = 0;\n                 }\n                 if (!this.active.isSparseRecord(this.readIdx++)) {\n-                    final int r = this.raw.read(this.readBuf, 0, this.readBuf.length);\n-                    if (r != this.readBuf.length) {\n+                    if (this.raw.read(this.readBuf, 0, this.readBuf.length) != this.readBuf.length) {\n                         throw new EOFException();\n                     }\n                 }\n                 else {\n                     Arrays.fill(this.readBuf, (byte)0);\n                 }\n                 this.recordOffset = 0;\n             }\n         }\n-        this.entryOffset += totalRead;\n-        return totalRead;\n+        this.entryOffset += n2;\n+        return n2;\n     }\n     \n     public void close() throws IOException {\n         if (!this.isClosed) {\n             this.isClosed = true;\n             this.raw.close();\n         }\n     }\n     \n-    public static boolean matches(final byte[] buffer, final int length) {\n-        if (length < 32) {\n+    public static boolean matches(final byte[] array, final int n) {\n+        if (n < 32) {\n             return false;\n         }\n-        if (length >= 1024) {\n-            return DumpArchiveUtil.verify(buffer);\n+        if (n >= 1024) {\n+            return DumpArchiveUtil.verify(array);\n         }\n-        return 60012 == DumpArchiveUtil.convert32(buffer, 24);\n+        return 60012 == DumpArchiveUtil.convert32(array, 24);\n     }\n }\n"}]}
