{"diffoscope-json-version": 1, "source1": "first/ParallelScatterZipCreator.class", "source2": "second/ParallelScatterZipCreator.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -24,116 +24,116 @@\n     private final long startedAt;\n     private long compressionDoneAt;\n     private long scatterDoneAt;\n     private final int compressionLevel;\n     private final ThreadLocal<ScatterZipOutputStream> tlScatterStreams;\n     \n     private ScatterZipOutputStream createDeferred(final ScatterGatherBackingStoreSupplier scatterGatherBackingStoreSupplier) throws IOException {\n-        final ScatterGatherBackingStore bs = scatterGatherBackingStoreSupplier.get();\n-        final StreamCompressor sc = StreamCompressor.create(this.compressionLevel, bs);\n-        return new ScatterZipOutputStream(bs, sc);\n+        final ScatterGatherBackingStore value = scatterGatherBackingStoreSupplier.get();\n+        return new ScatterZipOutputStream(value, StreamCompressor.create(this.compressionLevel, value));\n     }\n     \n     public ParallelScatterZipCreator() {\n         this(Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()));\n     }\n     \n     public ParallelScatterZipCreator(final ExecutorService executorService) {\n         this(executorService, (ScatterGatherBackingStoreSupplier)new ParallelScatterZipCreator.DefaultBackingStoreSupplier((ParallelScatterZipCreator.ParallelScatterZipCreator$1)null));\n     }\n     \n-    public ParallelScatterZipCreator(final ExecutorService executorService, final ScatterGatherBackingStoreSupplier backingStoreSupplier) {\n-        this(executorService, backingStoreSupplier, -1);\n+    public ParallelScatterZipCreator(final ExecutorService executorService, final ScatterGatherBackingStoreSupplier scatterGatherBackingStoreSupplier) {\n+        this(executorService, scatterGatherBackingStoreSupplier, -1);\n     }\n     \n-    public ParallelScatterZipCreator(final ExecutorService executorService, final ScatterGatherBackingStoreSupplier backingStoreSupplier, final int compressionLevel) throws IllegalArgumentException {\n+    public ParallelScatterZipCreator(final ExecutorService es, final ScatterGatherBackingStoreSupplier backingStoreSupplier, final int compressionLevel) throws IllegalArgumentException {\n         this.streams = new ConcurrentLinkedDeque<ScatterZipOutputStream>();\n         this.futures = new ConcurrentLinkedDeque<Future<? extends ScatterZipOutputStream>>();\n         this.startedAt = System.currentTimeMillis();\n         this.tlScatterStreams = (ThreadLocal<ScatterZipOutputStream>)new ParallelScatterZipCreator.ParallelScatterZipCreator$1(this);\n         if ((compressionLevel < 0 || compressionLevel > 9) && compressionLevel != -1) {\n             throw new IllegalArgumentException(\"Compression level is expected between -1~9\");\n         }\n         this.backingStoreSupplier = backingStoreSupplier;\n-        this.es = executorService;\n+        this.es = es;\n         this.compressionLevel = compressionLevel;\n     }\n     \n-    public void addArchiveEntry(final ZipArchiveEntry zipArchiveEntry, final InputStreamSupplier source) {\n-        this.submitStreamAwareCallable(this.createCallable(zipArchiveEntry, source));\n+    public void addArchiveEntry(final ZipArchiveEntry zipArchiveEntry, final InputStreamSupplier inputStreamSupplier) {\n+        this.submitStreamAwareCallable(this.createCallable(zipArchiveEntry, inputStreamSupplier));\n     }\n     \n     public void addArchiveEntry(final ZipArchiveEntryRequestSupplier zipArchiveEntryRequestSupplier) {\n         this.submitStreamAwareCallable(this.createCallable(zipArchiveEntryRequestSupplier));\n     }\n     \n     public final void submit(final Callable<?> callable) {\n         this.submitStreamAwareCallable(() -> {\n-            callable.call();\n+            callable2.call();\n             return (ScatterZipOutputStream)this.tlScatterStreams.get();\n         });\n     }\n     \n     public final void submitStreamAwareCallable(final Callable<? extends ScatterZipOutputStream> callable) {\n         this.futures.add(this.es.submit(callable));\n     }\n     \n-    public final Callable<ScatterZipOutputStream> createCallable(final ZipArchiveEntry zipArchiveEntry, final InputStreamSupplier source) {\n-        final int method = zipArchiveEntry.getMethod();\n-        if (method == -1) {\n+    public final Callable<ScatterZipOutputStream> createCallable(final ZipArchiveEntry zipArchiveEntry, final InputStreamSupplier inputStreamSupplier) {\n+        if (zipArchiveEntry.getMethod() == -1) {\n             throw new IllegalArgumentException(\"Method must be set on zipArchiveEntry: \" + zipArchiveEntry);\n         }\n-        final ZipArchiveEntryRequest zipArchiveEntryRequest = ZipArchiveEntryRequest.createZipArchiveEntryRequest(zipArchiveEntry, source);\n         return () -> {\n-            final ScatterZipOutputStream scatterStream = (ScatterZipOutputStream)this.tlScatterStreams.get();\n-            scatterStream.addArchiveEntry(zipArchiveEntryRequest);\n-            return scatterStream;\n+            ZipArchiveEntryRequest.createZipArchiveEntryRequest(zipArchiveEntry, inputStreamSupplier2);\n+            final ScatterZipOutputStream scatterZipOutputStream = (ScatterZipOutputStream)this.tlScatterStreams.get();\n+            scatterZipOutputStream.addArchiveEntry(zipArchiveEntryRequest);\n+            return scatterZipOutputStream;\n         };\n     }\n     \n     public final Callable<ScatterZipOutputStream> createCallable(final ZipArchiveEntryRequestSupplier zipArchiveEntryRequestSupplier) {\n         return () -> {\n-            final ScatterZipOutputStream scatterStream = (ScatterZipOutputStream)this.tlScatterStreams.get();\n-            scatterStream.addArchiveEntry(zipArchiveEntryRequestSupplier.get());\n-            return scatterStream;\n+            final ScatterZipOutputStream scatterZipOutputStream = (ScatterZipOutputStream)this.tlScatterStreams.get();\n+            scatterZipOutputStream.addArchiveEntry(zipArchiveEntryRequestSupplier2.get());\n+            return scatterZipOutputStream;\n         };\n     }\n     \n-    public void writeTo(final ZipArchiveOutputStream targetStream) throws IOException, InterruptedException, ExecutionException {\n+    public void writeTo(final ZipArchiveOutputStream zipArchiveOutputStream) throws IOException, InterruptedException, ExecutionException {\n         try {\n             try {\n-                for (final Future<?> future : this.futures) {\n-                    future.get();\n+                final Iterator<Future<? extends ScatterZipOutputStream>> iterator = this.futures.iterator();\n+                while (iterator.hasNext()) {\n+                    ((Future)iterator.next()).get();\n                 }\n             }\n             finally {\n                 this.es.shutdown();\n             }\n             this.es.awaitTermination(60000L, TimeUnit.SECONDS);\n             this.compressionDoneAt = System.currentTimeMillis();\n-            for (final Future<? extends ScatterZipOutputStream> future2 : this.futures) {\n-                final ScatterZipOutputStream scatterStream = (ScatterZipOutputStream)future2.get();\n-                scatterStream.zipEntryWriter().writeNextZipEntry(targetStream);\n+            final Iterator<Future<? extends ScatterZipOutputStream>> iterator2 = this.futures.iterator();\n+            while (iterator2.hasNext()) {\n+                ((ScatterZipOutputStream)((Future<ScatterZipOutputStream>)iterator2.next()).get()).zipEntryWriter().writeNextZipEntry(zipArchiveOutputStream);\n             }\n-            for (final ScatterZipOutputStream scatterStream2 : this.streams) {\n-                scatterStream2.close();\n+            final Iterator<ScatterZipOutputStream> iterator3 = this.streams.iterator();\n+            while (iterator3.hasNext()) {\n+                ((ScatterZipOutputStream)iterator3.next()).close();\n             }\n             this.scatterDoneAt = System.currentTimeMillis();\n         }\n         finally {\n             this.closeAll();\n         }\n     }\n     \n     public ScatterStatistics getStatisticsMessage() {\n         return new ScatterStatistics(this.compressionDoneAt - this.startedAt, this.scatterDoneAt - this.compressionDoneAt);\n     }\n     \n     private void closeAll() {\n-        for (final ScatterZipOutputStream scatterStream : this.streams) {\n+        for (final ScatterZipOutputStream scatterZipOutputStream : this.streams) {\n             try {\n-                scatterStream.close();\n+                scatterZipOutputStream.close();\n             }\n             catch (final IOException ex) {}\n         }\n     }\n }\n"}]}
