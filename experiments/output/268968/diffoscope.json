{"diffoscope-json-version": 1, "source1": "first/NeedBracesCheck.class", "source2": "second/NeedBracesCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -32,198 +32,189 @@\n         return new int[] { 85, 92, 91, 83, 84, 93, 94, 181 };\n     }\n     \n     public int[] getRequiredTokens() {\n         return CommonUtil.EMPTY_INT_ARRAY;\n     }\n     \n-    public void visitToken(final DetailAST ast) {\n-        final boolean hasNoSlist = ast.findFirstToken(7) == null;\n-        if (hasNoSlist && !this.isSkipStatement(ast) && this.isBracesNeeded(ast)) {\n-            this.log(ast, \"needBraces\", new Object[] { ast.getText() });\n+    public void visitToken(final DetailAST detailAST) {\n+        if (detailAST.findFirstToken(7) == null && !this.isSkipStatement(detailAST) && this.isBracesNeeded(detailAST)) {\n+            this.log(detailAST, \"needBraces\", new Object[] { detailAST.getText() });\n         }\n     }\n     \n-    private boolean isBracesNeeded(final DetailAST ast) {\n-        boolean result = false;\n-        switch (ast.getType()) {\n+    private boolean isBracesNeeded(final DetailAST detailAST) {\n+        boolean b = false;\n+        switch (detailAST.getType()) {\n             case 84:\n             case 91: {\n-                result = !this.isEmptyLoopBodyAllowed(ast);\n+                b = !this.isEmptyLoopBodyAllowed(detailAST);\n                 break;\n             }\n             case 93:\n             case 94: {\n-                result = (hasUnbracedStatements(ast) && !isSwitchLabeledExpression(ast));\n+                b = (hasUnbracedStatements(detailAST) && !isSwitchLabeledExpression(detailAST));\n                 break;\n             }\n             case 92: {\n-                result = (ast.findFirstToken(83) == null);\n+                b = (detailAST.findFirstToken(83) == null);\n                 break;\n             }\n             case 181: {\n-                result = !isInSwitchRule(ast);\n+                b = !isInSwitchRule(detailAST);\n                 break;\n             }\n             default: {\n-                result = true;\n+                b = true;\n                 break;\n             }\n         }\n-        return result;\n+        return b;\n     }\n     \n-    private boolean isEmptyLoopBodyAllowed(final DetailAST ast) {\n-        return this.allowEmptyLoopBody && ast.findFirstToken(38) != null;\n+    private boolean isEmptyLoopBodyAllowed(final DetailAST detailAST) {\n+        return this.allowEmptyLoopBody && detailAST.findFirstToken(38) != null;\n     }\n     \n-    private static boolean hasUnbracedStatements(final DetailAST ast) {\n-        final DetailAST nextSibling = ast.getNextSibling();\n-        boolean result = false;\n-        if (isInSwitchRule(ast)) {\n-            final DetailAST parent = ast.getParent();\n-            result = (parent.getLastChild().getType() != 7);\n+    private static boolean hasUnbracedStatements(final DetailAST detailAST) {\n+        final DetailAST nextSibling = detailAST.getNextSibling();\n+        boolean b = false;\n+        if (isInSwitchRule(detailAST)) {\n+            b = (detailAST.getParent().getLastChild().getType() != 7);\n         }\n         else if (nextSibling != null && nextSibling.getType() == 7 && nextSibling.getFirstChild().getType() != 7) {\n-            result = true;\n+            b = true;\n         }\n-        return result;\n+        return b;\n     }\n     \n-    private boolean isSkipStatement(final DetailAST statement) {\n-        return this.allowSingleLineStatement && isSingleLineStatement(statement);\n+    private boolean isSkipStatement(final DetailAST detailAST) {\n+        return this.allowSingleLineStatement && isSingleLineStatement(detailAST);\n     }\n     \n-    private static boolean isSingleLineStatement(final DetailAST statement) {\n-        boolean result = false;\n-        switch (statement.getType()) {\n+    private static boolean isSingleLineStatement(final DetailAST detailAST) {\n+        boolean b = false;\n+        switch (detailAST.getType()) {\n             case 83: {\n-                result = isSingleLineIf(statement);\n+                b = isSingleLineIf(detailAST);\n                 break;\n             }\n             case 91: {\n-                result = isSingleLineFor(statement);\n+                b = isSingleLineFor(detailAST);\n                 break;\n             }\n             case 85: {\n-                result = isSingleLineDoWhile(statement);\n+                b = isSingleLineDoWhile(detailAST);\n                 break;\n             }\n             case 84: {\n-                result = isSingleLineWhile(statement);\n+                b = isSingleLineWhile(detailAST);\n                 break;\n             }\n             case 181: {\n-                result = (!isInSwitchRule(statement) && isSingleLineLambda(statement));\n+                b = (!isInSwitchRule(detailAST) && isSingleLineLambda(detailAST));\n                 break;\n             }\n             case 93:\n             case 94: {\n-                result = isSingleLineSwitchMember(statement);\n+                b = isSingleLineSwitchMember(detailAST);\n                 break;\n             }\n             default: {\n-                result = isSingleLineElse(statement);\n+                b = isSingleLineElse(detailAST);\n                 break;\n             }\n         }\n-        return result;\n+        return b;\n     }\n     \n-    private static boolean isSingleLineWhile(final DetailAST literalWhile) {\n-        boolean result = false;\n-        if (literalWhile.getParent().getType() == 7) {\n-            final DetailAST block = literalWhile.getLastChild().getPreviousSibling();\n-            result = TokenUtil.areOnSameLine(literalWhile, block);\n+    private static boolean isSingleLineWhile(final DetailAST detailAST) {\n+        boolean onSameLine = false;\n+        if (detailAST.getParent().getType() == 7) {\n+            onSameLine = TokenUtil.areOnSameLine(detailAST, detailAST.getLastChild().getPreviousSibling());\n         }\n-        return result;\n+        return onSameLine;\n     }\n     \n-    private static boolean isSingleLineDoWhile(final DetailAST literalDo) {\n-        boolean result = false;\n-        if (literalDo.getParent().getType() == 7) {\n-            final DetailAST block = literalDo.getFirstChild();\n-            result = TokenUtil.areOnSameLine(block, literalDo);\n+    private static boolean isSingleLineDoWhile(final DetailAST detailAST) {\n+        boolean onSameLine = false;\n+        if (detailAST.getParent().getType() == 7) {\n+            onSameLine = TokenUtil.areOnSameLine(detailAST.getFirstChild(), detailAST);\n         }\n-        return result;\n+        return onSameLine;\n     }\n     \n-    private static boolean isSingleLineFor(final DetailAST literalFor) {\n-        boolean result = false;\n-        if (literalFor.getLastChild().getType() == 38) {\n-            result = true;\n+    private static boolean isSingleLineFor(final DetailAST detailAST) {\n+        boolean onSameLine = false;\n+        if (detailAST.getLastChild().getType() == 38) {\n+            onSameLine = true;\n         }\n-        else if (literalFor.getParent().getType() == 7) {\n-            result = TokenUtil.areOnSameLine(literalFor, literalFor.getLastChild());\n+        else if (detailAST.getParent().getType() == 7) {\n+            onSameLine = TokenUtil.areOnSameLine(detailAST, detailAST.getLastChild());\n         }\n-        return result;\n+        return onSameLine;\n     }\n     \n-    private static boolean isSingleLineIf(final DetailAST literalIf) {\n-        boolean result = false;\n-        if (literalIf.getParent().getType() == 7) {\n-            final DetailAST literalIfLastChild = literalIf.getLastChild();\n-            DetailAST block;\n-            if (literalIfLastChild.getType() == 92) {\n-                block = literalIfLastChild.getPreviousSibling();\n+    private static boolean isSingleLineIf(final DetailAST detailAST) {\n+        boolean onSameLine = false;\n+        if (detailAST.getParent().getType() == 7) {\n+            final DetailAST lastChild = detailAST.getLastChild();\n+            DetailAST previousSibling;\n+            if (lastChild.getType() == 92) {\n+                previousSibling = lastChild.getPreviousSibling();\n             }\n             else {\n-                block = literalIfLastChild;\n+                previousSibling = lastChild;\n             }\n-            final DetailAST ifCondition = literalIf.findFirstToken(28);\n-            result = TokenUtil.areOnSameLine(ifCondition, block);\n+            onSameLine = TokenUtil.areOnSameLine(detailAST.findFirstToken(28), previousSibling);\n         }\n-        return result;\n+        return onSameLine;\n     }\n     \n-    private static boolean isSingleLineLambda(final DetailAST lambda) {\n-        final DetailAST lastLambdaToken = getLastLambdaToken(lambda);\n-        return TokenUtil.areOnSameLine(lambda, lastLambdaToken);\n+    private static boolean isSingleLineLambda(final DetailAST detailAST) {\n+        return TokenUtil.areOnSameLine(detailAST, getLastLambdaToken(detailAST));\n     }\n     \n-    private static DetailAST getLastLambdaToken(final DetailAST lambda) {\n-        DetailAST node = lambda;\n+    private static DetailAST getLastLambdaToken(final DetailAST detailAST) {\n+        DetailAST lastChild = detailAST;\n         do {\n-            node = node.getLastChild();\n-        } while (node.getLastChild() != null);\n-        return node;\n+            lastChild = lastChild.getLastChild();\n+        } while (lastChild.getLastChild() != null);\n+        return lastChild;\n     }\n     \n-    private static boolean isInSwitchRule(final DetailAST ast) {\n-        return ast.getParent().getType() == 208;\n+    private static boolean isInSwitchRule(final DetailAST detailAST) {\n+        return detailAST.getParent().getType() == 208;\n     }\n     \n-    private static boolean isSwitchLabeledExpression(final DetailAST ast) {\n-        final DetailAST parent = ast.getParent();\n-        return switchRuleHasSingleExpression(parent);\n+    private static boolean isSwitchLabeledExpression(final DetailAST detailAST) {\n+        return switchRuleHasSingleExpression(detailAST.getParent());\n     }\n     \n-    private static boolean switchRuleHasSingleExpression(final DetailAST switchRule) {\n-        final DetailAST possibleExpression = switchRule.findFirstToken(28);\n-        return possibleExpression != null && possibleExpression.getFirstChild().getFirstChild() == null;\n+    private static boolean switchRuleHasSingleExpression(final DetailAST detailAST) {\n+        final DetailAST firstToken = detailAST.findFirstToken(28);\n+        return firstToken != null && firstToken.getFirstChild().getFirstChild() == null;\n     }\n     \n-    private static boolean isSingleLineSwitchMember(final DetailAST statement) {\n-        boolean result;\n-        if (isInSwitchRule(statement)) {\n-            result = isSingleLineSwitchRule(statement);\n+    private static boolean isSingleLineSwitchMember(final DetailAST detailAST) {\n+        boolean b;\n+        if (isInSwitchRule(detailAST)) {\n+            b = isSingleLineSwitchRule(detailAST);\n         }\n         else {\n-            result = isSingleLineCaseGroup(statement);\n+            b = isSingleLineCaseGroup(detailAST);\n         }\n-        return result;\n+        return b;\n     }\n     \n-    private static boolean isSingleLineCaseGroup(final DetailAST ast) {\n-        return Boolean.valueOf(Optional.of(ast).map((Function<? super DetailAST, ?>)DetailAST::getNextSibling).map((Function<? super Object, ?>)DetailAST::getLastChild).map(lastToken -> Boolean.valueOf(TokenUtil.areOnSameLine(ast, lastToken))).orElse(Boolean.TRUE));\n+    private static boolean isSingleLineCaseGroup(final DetailAST value) {\n+        return Boolean.valueOf(Optional.of(value).map((Function<? super DetailAST, ?>)DetailAST::getNextSibling).map((Function<? super Object, ?>)DetailAST::getLastChild).map(detailAST2 -> Boolean.valueOf(TokenUtil.areOnSameLine(detailAST, detailAST2))).orElse(Boolean.TRUE));\n     }\n     \n-    private static boolean isSingleLineSwitchRule(final DetailAST ast) {\n-        final DetailAST lastSibling = ast.getParent().getLastChild();\n-        return TokenUtil.areOnSameLine(ast, lastSibling);\n+    private static boolean isSingleLineSwitchRule(final DetailAST detailAST) {\n+        return TokenUtil.areOnSameLine(detailAST, detailAST.getParent().getLastChild());\n     }\n     \n-    private static boolean isSingleLineElse(final DetailAST literalElse) {\n-        final DetailAST block = literalElse.getFirstChild();\n-        return TokenUtil.areOnSameLine(literalElse, block);\n+    private static boolean isSingleLineElse(final DetailAST detailAST) {\n+        return TokenUtil.areOnSameLine(detailAST, detailAST.getFirstChild());\n     }\n }\n"}]}
