{"diffoscope-json-version": 1, "source1": "first/RequireThisCheck.class", "source2": "second/RequireThisCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,20 +1,20 @@\n \n package com.puppycrawl.tools.checkstyle.checks.coding;\n \n import java.util.HashSet;\n-import com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n import java.util.Iterator;\n import java.util.Set;\n import com.puppycrawl.tools.checkstyle.utils.CheckUtil;\n import com.puppycrawl.tools.checkstyle.utils.ScopeUtil;\n import java.util.Queue;\n import java.util.LinkedList;\n import java.util.HashMap;\n import java.util.ArrayDeque;\n+import com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n import com.puppycrawl.tools.checkstyle.api.DetailAST;\n import java.util.Map;\n import java.util.Deque;\n import java.util.BitSet;\n import com.puppycrawl.tools.checkstyle.FileStatefulCheck;\n import com.puppycrawl.tools.checkstyle.api.AbstractCheck;\n \n@@ -28,14 +28,20 @@\n     private static final BitSet COMPOUND_ASSIGN_TOKENS;\n     private final Deque<RequireThisCheck.AbstractFrame> current;\n     private Map<DetailAST, RequireThisCheck.AbstractFrame> frames;\n     private boolean checkFields;\n     private boolean checkMethods;\n     private boolean validateOnlyOverlapping;\n     \n+    static {\n+        DECLARATION_TOKENS = TokenUtil.asBitSet(new int[] { 10, 8, 9, 14, 154, 157, 15, 21, 164, 199, 202, 178 });\n+        ASSIGN_TOKENS = TokenUtil.asBitSet(new int[] { 80, 98, 100, 101, 102, 103, 104, 105, 106, 107 });\n+        COMPOUND_ASSIGN_TOKENS = TokenUtil.asBitSet(new int[] { 98, 100, 101, 102, 103, 104, 105, 106, 107 });\n+    }\n+    \n     public RequireThisCheck() {\n         this.current = new ArrayDeque<RequireThisCheck.AbstractFrame>();\n         this.checkFields = true;\n         this.checkMethods = true;\n         this.validateOnlyOverlapping = true;\n     }\n     \n@@ -136,19 +142,20 @@\n         switch (parentType) {\n             case 159:\n             case 160:\n             case 161: {\n                 break;\n             }\n             case 27: {\n-                if (this.checkMethods) {\n-                    final RequireThisCheck.AbstractFrame frame = this.getMethodWithoutThis(ast);\n-                    if (frame != null) {\n-                        this.logViolation(\"require.this.method\", ast, frame);\n-                    }\n+                if (!this.checkMethods) {\n+                    break;\n+                }\n+                final RequireThisCheck.AbstractFrame frame = this.getMethodWithoutThis(ast);\n+                if (frame != null) {\n+                    this.logViolation(\"require.this.method\", ast, frame);\n                     break;\n                 }\n                 break;\n             }\n             default: {\n                 if (!this.checkFields) {\n                     break;\n@@ -165,15 +172,15 @@\n     }\n     \n     private void logViolation(final String msgKey, final DetailAST ast, final RequireThisCheck.AbstractFrame frame) {\n         if (frame.getFrameName().equals(this.getNearestClassFrameName())) {\n             this.log(ast, msgKey, new Object[] { ast.getText(), \"\" });\n         }\n         else if (!(frame instanceof RequireThisCheck.AnonymousClassFrame)) {\n-            this.log(ast, msgKey, new Object[] { ast.getText(), frame.getFrameName() });\n+            this.log(ast, msgKey, new Object[] { ast.getText(), String.valueOf(frame.getFrameName()) + '.' });\n         }\n     }\n     \n     private RequireThisCheck.AbstractFrame getFieldWithoutThis(final DetailAST ast, final int parentType) {\n         final boolean importOrPackage = ScopeUtil.getSurroundingScope(ast) == null;\n         final boolean typeName = parentType == 13 || parentType == 136;\n         RequireThisCheck.AbstractFrame frame = null;\n@@ -414,15 +421,15 @@\n     \n     private static boolean isReturnedVariable(final RequireThisCheck.AbstractFrame currentFrame, final DetailAST ident) {\n         final DetailAST blockFrameNameIdent = currentFrame.getFrameNameIdent();\n         final DetailAST definitionToken = blockFrameNameIdent.getParent();\n         final DetailAST blockStartToken = definitionToken.findFirstToken(7);\n         final DetailAST blockEndToken = getBlockEndToken(blockFrameNameIdent, blockStartToken);\n         final Set<DetailAST> returnsInsideBlock = getAllTokensOfType(definitionToken, 88, blockEndToken.getLineNo());\n-        return returnsInsideBlock.stream().anyMatch(returnToken -> isAstInside(returnToken, ident));\n+        return returnsInsideBlock.stream().anyMatch(returnToken -> isAstInside(returnToken, ast));\n     }\n     \n     private static boolean isAstInside(final DetailAST tree, final DetailAST ast) {\n         boolean result = false;\n         if (isAstSimilar(tree, ast)) {\n             result = true;\n         }\n@@ -616,24 +623,18 @@\n             final DetailAST lambdaParameters = parent.findFirstToken(20);\n             if (lambdaParameters == null) {\n                 isLambdaParameter = parent.getFirstChild().getText().equals(ast.getText());\n             }\n             else {\n                 isLambdaParameter = TokenUtil.findFirstTokenByPredicate(lambdaParameters, paramDef -> {\n                     final DetailAST param = paramDef.findFirstToken(58);\n-                    return param != null && param.getText().equals(ast.getText());\n+                    return param != null && param.getText().equals(detailAST.getText());\n                 }).isPresent();\n             }\n         }\n         return isLambdaParameter;\n     }\n     \n     private static boolean isAstSimilar(final DetailAST left, final DetailAST right) {\n         return left.getType() == right.getType() && left.getText().equals(right.getText());\n     }\n-    \n-    static {\n-        DECLARATION_TOKENS = TokenUtil.asBitSet(new int[] { 10, 8, 9, 14, 154, 157, 15, 21, 164, 199, 202, 178 });\n-        ASSIGN_TOKENS = TokenUtil.asBitSet(new int[] { 80, 98, 100, 101, 102, 103, 104, 105, 106, 107 });\n-        COMPOUND_ASSIGN_TOKENS = TokenUtil.asBitSet(new int[] { 98, 100, 101, 102, 103, 104, 105, 106, 107 });\n-    }\n }\n"}]}
