{"diffoscope-json-version": 1, "source1": "first/PerformanceTest.class", "source2": "second/PerformanceTest.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,12 +1,11 @@\n \n package org.apache.commons.csv.perf;\n \n import org.junit.jupiter.api.Test;\n-import java.util.Objects;\n import java.util.Iterator;\n import org.apache.commons.csv.CSVParser;\n import org.apache.commons.csv.CSVRecord;\n import org.apache.commons.csv.CSVFormat;\n import java.io.Reader;\n import java.io.FileReader;\n import java.io.BufferedReader;\n@@ -22,40 +21,106 @@\n \n public class PerformanceTest\n {\n     private static final String TEST_RESRC = \"org/apache/commons/csv/perf/worldcitiespop.txt.gz\";\n     private static final File BIG_FILE;\n     private final int max = 10;\n     \n+    static {\n+        BIG_FILE = new File(System.getProperty(\"java.io.tmpdir\"), \"worldcitiespop.txt\");\n+    }\n+    \n     @BeforeAll\n     public static void setUpClass() throws FileNotFoundException, IOException {\n         if (PerformanceTest.BIG_FILE.exists()) {\n             System.out.println(String.format(\"Found test fixture %s: %,d bytes.\", PerformanceTest.BIG_FILE, Long.valueOf(PerformanceTest.BIG_FILE.length())));\n             return;\n         }\n         System.out.println(\"Decompressing test fixture to: \" + PerformanceTest.BIG_FILE + \"...\");\n-        try (final InputStream input = new GZIPInputStream(PerformanceTest.class.getClassLoader().getResourceAsStream(\"org/apache/commons/csv/perf/worldcitiespop.txt.gz\"));\n-             final OutputStream output = new FileOutputStream(PerformanceTest.BIG_FILE)) {\n-            IOUtils.copy(input, output);\n-            System.out.println(String.format(\"Decompressed test fixture %s: %,d bytes.\", PerformanceTest.BIG_FILE, Long.valueOf(PerformanceTest.BIG_FILE.length())));\n+        Throwable t = null;\n+        try {\n+            final InputStream input = new GZIPInputStream(PerformanceTest.class.getClassLoader().getResourceAsStream(\"org/apache/commons/csv/perf/worldcitiespop.txt.gz\"));\n+            try {\n+                final OutputStream output = new FileOutputStream(PerformanceTest.BIG_FILE);\n+                try {\n+                    IOUtils.copy(input, output);\n+                    System.out.println(String.format(\"Decompressed test fixture %s: %,d bytes.\", PerformanceTest.BIG_FILE, Long.valueOf(PerformanceTest.BIG_FILE.length())));\n+                }\n+                finally {\n+                    if (output != null) {\n+                        output.close();\n+                    }\n+                }\n+                if (input != null) {\n+                    input.close();\n+                }\n+            }\n+            finally {\n+                if (t == null) {\n+                    final Throwable exception;\n+                    t = exception;\n+                }\n+                else {\n+                    final Throwable exception;\n+                    if (t != exception) {\n+                        t.addSuppressed(exception);\n+                    }\n+                }\n+                if (input != null) {\n+                    input.close();\n+                }\n+            }\n+        }\n+        finally {\n+            if (t == null) {\n+                final Throwable exception2;\n+                t = exception2;\n+            }\n+            else {\n+                final Throwable exception2;\n+                if (t != exception2) {\n+                    t.addSuppressed(exception2);\n+                }\n+            }\n         }\n     }\n     \n     private BufferedReader createBufferedReader() throws IOException {\n         return new BufferedReader(new FileReader(PerformanceTest.BIG_FILE));\n     }\n     \n     private long parse(final Reader reader, final boolean traverseColumns) throws IOException {\n         final CSVFormat format = CSVFormat.DEFAULT.builder().setIgnoreSurroundingSpaces(false).build();\n         long recordCount = 0L;\n-        try (final CSVParser parser = format.parse(reader)) {\n-            for (final CSVRecord record : parser) {\n-                ++recordCount;\n-                if (traverseColumns) {\n-                    for (String s : record) {}\n+        Throwable t = null;\n+        try {\n+            final CSVParser parser = format.parse(reader);\n+            try {\n+                for (final CSVRecord record : parser) {\n+                    ++recordCount;\n+                    if (traverseColumns) {\n+                        for (String s : record) {}\n+                    }\n+                }\n+            }\n+            finally {\n+                if (parser != null) {\n+                    parser.close();\n+                }\n+            }\n+        }\n+        finally {\n+            if (t == null) {\n+                final Throwable exception;\n+                t = exception;\n+            }\n+            else {\n+                final Throwable exception;\n+                if (t != exception) {\n+                    t.addSuppressed(exception);\n                 }\n             }\n         }\n         return recordCount;\n     }\n     \n     private void println(final String s) {\n@@ -68,71 +133,188 @@\n             ++count;\n         }\n         return count;\n     }\n     \n     public long testParseBigFile(final boolean traverseColumns) throws Exception {\n         final long startMillis = System.currentTimeMillis();\n-        try (final BufferedReader reader = this.createBufferedReader()) {\n-            final long count = this.parse(reader, traverseColumns);\n-            final long totalMillis = System.currentTimeMillis() - startMillis;\n-            this.println(String.format(\"File parsed in %,d milliseconds with Commons CSV: %,d lines.\", Long.valueOf(totalMillis), Long.valueOf(count)));\n-            return totalMillis;\n+        Throwable t = null;\n+        try {\n+            final BufferedReader reader = this.createBufferedReader();\n+            try {\n+                final long count = this.parse(reader, traverseColumns);\n+                final long totalMillis = System.currentTimeMillis() - startMillis;\n+                this.println(String.format(\"File parsed in %,d milliseconds with Commons CSV: %,d lines.\", Long.valueOf(totalMillis), Long.valueOf(count)));\n+                return totalMillis;\n+            }\n+            finally {\n+                if (reader != null) {\n+                    reader.close();\n+                }\n+            }\n+        }\n+        finally {\n+            if (t == null) {\n+                final Throwable exception;\n+                t = exception;\n+            }\n+            else {\n+                final Throwable exception;\n+                if (t != exception) {\n+                    t.addSuppressed(exception);\n+                }\n+            }\n         }\n     }\n     \n     @Test\n     public void testParseBigFileRepeat() throws Exception {\n         long bestTime = Long.MAX_VALUE;\n-        int i = 0;\n-        while (true) {\n-            final int n = i;\n-            Objects.requireNonNull(this);\n-            if (n >= 10) {\n-                break;\n-            }\n+        for (int i = 0; i < 10; ++i) {\n             bestTime = Math.min(this.testParseBigFile(false), bestTime);\n-            ++i;\n         }\n-        final String format = \"Best time out of %,d is %,d milliseconds.\";\n-        final Object[] args = new Object[2];\n-        final int n2 = 0;\n-        Objects.requireNonNull(this);\n-        args[n2] = Integer.valueOf(10);\n-        args[1] = Long.valueOf(bestTime);\n-        this.println(String.format(format, args));\n+        this.println(String.format(\"Best time out of %,d is %,d milliseconds.\", Integer.valueOf(10), Long.valueOf(bestTime)));\n     }\n     \n     @Test\n     public void testReadBigFile() throws Exception {\n-        long bestTime = Long.MAX_VALUE;\n-        int i = 0;\n-        while (true) {\n-            final int n = i;\n-            Objects.requireNonNull(this);\n-            if (n >= 10) {\n-                break;\n-            }\n-            long startMillis;\n-            long count;\n-            try (final BufferedReader in = this.createBufferedReader()) {\n-                startMillis = System.currentTimeMillis();\n-                count = this.readAll(in);\n-            }\n-            final long totalMillis = System.currentTimeMillis() - startMillis;\n-            bestTime = Math.min(totalMillis, bestTime);\n-            this.println(String.format(\"File read in %,d milliseconds: %,d lines.\", Long.valueOf(totalMillis), Long.valueOf(count)));\n-            ++i;\n-        }\n-        final String format = \"Best time out of %,d is %,d milliseconds.\";\n-        final Object[] args = new Object[2];\n-        final int n2 = 0;\n-        Objects.requireNonNull(this);\n-        args[n2] = Integer.valueOf(10);\n-        args[1] = Long.valueOf(bestTime);\n-        this.println(String.format(format, args));\n-    }\n-    \n-    static {\n-        BIG_FILE = new File(System.getProperty(\"java.io.tmpdir\"), \"worldcitiespop.txt\");\n+        // \n+        // This method could not be decompiled.\n+        // \n+        // Original Bytecode:\n+        // \n+        //     3: lstore_1        /* bestTime */\n+        //     4: iconst_0       \n+        //     5: istore          i\n+        //     7: goto            140\n+        //    10: aconst_null    \n+        //    11: astore          8\n+        //    13: aconst_null    \n+        //    14: astore          9\n+        //    16: aload_0         /* this */\n+        //    17: invokespecial   org/apache/commons/csv/perf/PerformanceTest.createBufferedReader:()Ljava/io/BufferedReader;\n+        //    20: astore          in\n+        //    22: invokestatic    java/lang/System.currentTimeMillis:()J\n+        //    25: lstore          startMillis\n+        //    27: aload_0         /* this */\n+        //    28: aload           in\n+        //    30: invokespecial   org/apache/commons/csv/perf/PerformanceTest.readAll:(Ljava/io/BufferedReader;)J\n+        //    33: lstore_3        /* count */\n+        //    34: aload           in\n+        //    36: ifnull          93\n+        //    39: aload           in\n+        //    41: invokevirtual   java/io/BufferedReader.close:()V\n+        //    44: goto            93\n+        //    47: astore          8\n+        //    49: aload           in\n+        //    51: ifnull          59\n+        //    54: aload           in\n+        //    56: invokevirtual   java/io/BufferedReader.close:()V\n+        //    59: aload           8\n+        //    61: athrow         \n+        //    62: astore          9\n+        //    64: aload           8\n+        //    66: ifnonnull       76\n+        //    69: aload           9\n+        //    71: astore          8\n+        //    73: goto            90\n+        //    76: aload           8\n+        //    78: aload           9\n+        //    80: if_acmpeq       90\n+        //    83: aload           8\n+        //    85: aload           9\n+        //    87: invokevirtual   java/lang/Throwable.addSuppressed:(Ljava/lang/Throwable;)V\n+        //    90: aload           8\n+        //    92: athrow         \n+        //    93: invokestatic    java/lang/System.currentTimeMillis:()J\n+        //    96: lload           startMillis\n+        //    98: lsub           \n+        //    99: lstore          totalMillis\n+        //   101: lload           totalMillis\n+        //   103: lload_1         /* bestTime */\n+        //   104: invokestatic    java/lang/Math.min:(JJ)J\n+        //   107: lstore_1        /* bestTime */\n+        //   108: aload_0         /* this */\n+        //   109: ldc_w           \"File read in %,d milliseconds: %,d lines.\"\n+        //   112: iconst_2       \n+        //   113: anewarray       Ljava/lang/Object;\n+        //   116: dup            \n+        //   117: iconst_0       \n+        //   118: lload           totalMillis\n+        //   120: invokestatic    java/lang/Long.valueOf:(J)Ljava/lang/Long;\n+        //   123: aastore        \n+        //   124: dup            \n+        //   125: iconst_1       \n+        //   126: lload_3         /* count */\n+        //   127: invokestatic    java/lang/Long.valueOf:(J)Ljava/lang/Long;\n+        //   130: aastore        \n+        //   131: invokestatic    java/lang/String.format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;\n+        //   134: invokespecial   org/apache/commons/csv/perf/PerformanceTest.println:(Ljava/lang/String;)V\n+        //   137: iinc            i, 1\n+        //   140: iload           i\n+        //   142: bipush          10\n+        //   144: if_icmplt       10\n+        //   147: aload_0         /* this */\n+        //   148: ldc_w           \"Best time out of %,d is %,d milliseconds.\"\n+        //   151: iconst_2       \n+        //   152: anewarray       Ljava/lang/Object;\n+        //   155: dup            \n+        //   156: iconst_0       \n+        //   157: bipush          10\n+        //   159: invokestatic    java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n+        //   162: aastore        \n+        //   163: dup            \n+        //   164: iconst_1       \n+        //   165: lload_1         /* bestTime */\n+        //   166: invokestatic    java/lang/Long.valueOf:(J)Ljava/lang/Long;\n+        //   169: aastore        \n+        //   170: invokestatic    java/lang/String.format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;\n+        //   173: invokespecial   org/apache/commons/csv/perf/PerformanceTest.println:(Ljava/lang/String;)V\n+        //   176: return         \n+        //    Exceptions:\n+        //  throws java.lang.Exception\n+        //    StackMapTable: 00 08 FF 00 0A 00 05 07 00 01 04 00 00 01 00 00 FF 00 24 00 0A 07 00 01 04 00 00 01 00 00 07 00 8E 07 00 8E 07 00 9A 00 01 07 00 8E FA 00 0B 42 07 00 8E 0D 0D FF 00 02 00 05 07 00 01 04 04 01 04 00 00 FF 00 2E 00 05 07 00 01 04 00 00 01 00 00\n+        //    Exceptions:\n+        //  Try           Handler\n+        //  Start  End    Start  End    Type\n+        //  -----  -----  -----  -----  ----\n+        //  22     34     47     62     Any\n+        //  16     62     62     93     Any\n+        // \n+        // The error that occurred was:\n+        // \n+        // java.lang.IndexOutOfBoundsException: Index 1 out of bounds for length 1\n+        //     at java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:100)\n+        //     at java.base/jdk.internal.util.Preconditions.outOfBoundsCheckIndex(Preconditions.java:106)\n+        //     at java.base/jdk.internal.util.Preconditions.checkIndex(Preconditions.java:302)\n+        //     at java.base/java.util.Objects.checkIndex(Objects.java:385)\n+        //     at java.base/java.util.ArrayList.get(ArrayList.java:427)\n+        //     at com.strobel.assembler.Collection.get(Collection.java:43)\n+        //     at java.base/java.util.Collections$UnmodifiableList.get(Collections.java:1501)\n+        //     at com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.adjustArgumentsForMethodCallCore(AstMethodBodyBuilder.java:1300)\n+        //     at com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.adjustArgumentsForMethodCall(AstMethodBodyBuilder.java:1273)\n+        //     at com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.transformCall(AstMethodBodyBuilder.java:1184)\n+        //     at com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.transformByteCode(AstMethodBodyBuilder.java:713)\n+        //     at com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.transformExpression(AstMethodBodyBuilder.java:534)\n+        //     at com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.transformByteCode(AstMethodBodyBuilder.java:548)\n+        //     at com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.transformExpression(AstMethodBodyBuilder.java:534)\n+        //     at com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.transformNode(AstMethodBodyBuilder.java:377)\n+        //     at com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.transformBlock(AstMethodBodyBuilder.java:318)\n+        //     at com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.transformNode(AstMethodBodyBuilder.java:410)\n+        //     at com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.transformBlock(AstMethodBodyBuilder.java:318)\n+        //     at com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.createMethodBody(AstMethodBodyBuilder.java:213)\n+        //     at com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.createMethodBody(AstMethodBodyBuilder.java:93)\n+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createMethodBody(AstBuilder.java:868)\n+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createMethod(AstBuilder.java:761)\n+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.addTypeMembers(AstBuilder.java:638)\n+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createTypeCore(AstBuilder.java:605)\n+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createTypeNoCache(AstBuilder.java:195)\n+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createType(AstBuilder.java:162)\n+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.addType(AstBuilder.java:137)\n+        //     at com.strobel.decompiler.languages.java.JavaLanguage.buildAst(JavaLanguage.java:71)\n+        //     at com.strobel.decompiler.languages.java.JavaLanguage.decompileType(JavaLanguage.java:59)\n+        //     at com.strobel.decompiler.DecompilerDriver.decompileType(DecompilerDriver.java:333)\n+        //     at com.strobel.decompiler.DecompilerDriver.main(DecompilerDriver.java:147)\n+        // \n+        throw new IllegalStateException(\"An error occurred while decompiling this method.\");\n     }\n }\n"}]}
