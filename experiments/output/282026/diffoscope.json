{"diffoscope-json-version": 1, "source1": "first/IOStreams.class", "source2": "second/IOStreams.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -8,42 +8,44 @@\n import org.apache.commons.io.IOExceptionList;\n import java.util.stream.Stream;\n \n final class IOStreams\n {\n     static final Object NONE;\n     \n-    static <T> void forAll(final Stream<T> stream, final IOConsumer<T> action) throws IOExceptionList {\n-        forAll(stream, action, (i, e) -> e);\n+    static <T> void forAll(final Stream<T> stream, final IOConsumer<T> ioConsumer) throws IOExceptionList {\n+        forAll(stream, ioConsumer, (p0, ex) -> ex);\n     }\n     \n-    static <T> void forAll(final Stream<T> stream, final IOConsumer<T> action, final BiFunction<Integer, IOException, IOException> exSupplier) throws IOExceptionList {\n-        IOStream.adapt((Stream)stream).forAll((IOConsumer)action, (BiFunction)IOIndexedException::new);\n+    static <T> void forAll(final Stream<T> stream, final IOConsumer<T> ioConsumer, final BiFunction<Integer, IOException, IOException> biFunction) throws IOExceptionList {\n+        IOStream.adapt((Stream)stream).forAll((IOConsumer)ioConsumer, (BiFunction)IOIndexedException::new);\n     }\n     \n-    static <T> void forEach(final Stream<T> stream, final IOConsumer<T> action) throws IOException {\n-        final IOConsumer<T> actualAction = toIOConsumer(action);\n-        of(stream).forEach(e -> Erase.accept(actualAction, e));\n+    static <T> void forEach(final Stream<T> stream, final IOConsumer<T> ioConsumer) throws IOException {\n+        of(stream).forEach(o -> {\n+            toIOConsumer((org.apache.commons.io.function.IOConsumer<Object>)ioConsumer3);\n+            Erase.accept(ioConsumer2, o);\n+        });\n     }\n     \n-    static <T> Stream<T> of(final Iterable<T> values) {\n-        return (values == null) ? Stream.empty() : StreamSupport.stream(values.spliterator(), false);\n+    static <T> Stream<T> of(final Iterable<T> iterable) {\n+        return (iterable == null) ? Stream.empty() : StreamSupport.stream(iterable.spliterator(), false);\n     }\n     \n     static <T> Stream<T> of(final Stream<T> stream) {\n         return (stream == null) ? Stream.empty() : stream;\n     }\n     \n     @SafeVarargs\n     static <T> Stream<T> of(final T... values) {\n         return (values == null) ? Stream.empty() : Stream.of(values);\n     }\n     \n-    static <T> IOConsumer<T> toIOConsumer(final IOConsumer<T> action) {\n-        return (IOConsumer<T>)((action != null) ? action : IOConsumer.noop());\n+    static <T> IOConsumer<T> toIOConsumer(final IOConsumer<T> ioConsumer) {\n+        return (IOConsumer<T>)((ioConsumer != null) ? ioConsumer : IOConsumer.noop());\n     }\n     \n     private IOStreams() {\n     }\n     \n     static {\n         NONE = new Object();\n"}]}
