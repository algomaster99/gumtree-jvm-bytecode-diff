{"diffoscope-json-version": 1, "source1": "first/FinalClassCheck.class", "source2": "second/FinalClassCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,13 +1,14 @@\n \n package com.puppycrawl.tools.checkstyle.checks.design;\n \n import java.util.function.Function;\n import java.util.Comparator;\n import java.util.function.ToIntFunction;\n+import java.util.function.Consumer;\n import java.util.Optional;\n import com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n import java.util.function.BiConsumer;\n import com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n import com.puppycrawl.tools.checkstyle.utils.ScopeUtil;\n import com.puppycrawl.tools.checkstyle.utils.CheckUtil;\n import java.util.HashMap;\n@@ -130,29 +131,29 @@\n         }\n         return shouldBeFinal;\n     }\n     \n     private void registerExtendedClass(final String qualifiedClassName, final FinalClassCheck.ClassDesc currentClass) {\n         final String superClassName = getSuperClassName(currentClass.getTypeDeclarationAst());\n         if (superClassName != null) {\n-            final ToIntFunction<FinalClassCheck.ClassDesc> nestedClassCountProvider = classDesc -> CheckUtil.typeDeclarationNameMatchingCount(qualifiedClassName, classDesc.getQualifiedName());\n-            this.getNearestClassWithSameName(superClassName, nestedClassCountProvider).or(() -> Optional.ofNullable(this.innerClasses.get(superClassName))).ifPresent(rec$ -> ((FinalClassCheck.ClassDesc)rec$).registerNestedSubclass());\n+            final ToIntFunction<FinalClassCheck.ClassDesc> nestedClassCountProvider = classDesc -> CheckUtil.typeDeclarationNameMatchingCount(s, classDesc.getQualifiedName());\n+            this.getNearestClassWithSameName(superClassName, nestedClassCountProvider).or(() -> Optional.ofNullable(this.innerClasses.get(s2))).ifPresent(FinalClassCheck.ClassDesc::access$0);\n         }\n     }\n     \n     private void registerAnonymousInnerClassToSuperClass(final DetailAST literalNewAst, final String outerTypeDeclName) {\n         final String superClassName = CheckUtil.getShortNameOfAnonInnerClass(literalNewAst);\n-        final ToIntFunction<FinalClassCheck.ClassDesc> anonClassCountProvider = classDesc -> getAnonSuperTypeMatchingCount(outerTypeDeclName, classDesc.getQualifiedName());\n-        this.getNearestClassWithSameName(superClassName, anonClassCountProvider).or(() -> Optional.ofNullable(this.innerClasses.get(superClassName))).ifPresent(rec$ -> ((FinalClassCheck.ClassDesc)rec$).registerSuperClassOfAnonymousInnerClass());\n+        final ToIntFunction<FinalClassCheck.ClassDesc> anonClassCountProvider = classDesc -> getAnonSuperTypeMatchingCount(patternTypeDeclaration, classDesc.getQualifiedName());\n+        this.getNearestClassWithSameName(superClassName, anonClassCountProvider).or(() -> Optional.ofNullable(this.innerClasses.get(s))).ifPresent(FinalClassCheck.ClassDesc::access$1);\n     }\n     \n     private Optional<FinalClassCheck.ClassDesc> getNearestClassWithSameName(final String className, final ToIntFunction<FinalClassCheck.ClassDesc> countProvider) {\n         final String dotAndClassName = \".\".concat(className);\n         final Comparator<FinalClassCheck.ClassDesc> longestMatch = Comparator.comparingInt((ToIntFunction<? super FinalClassCheck.ClassDesc>)countProvider);\n-        return this.innerClasses.entrySet().stream().filter(entry -> ((String)entry.getKey()).endsWith(dotAndClassName)).map((Function<? super Object, ? extends FinalClassCheck.ClassDesc>)Map.Entry::getValue).min(longestMatch.reversed().thenComparingInt(FinalClassCheck.TypeDeclarationDescription::getDepth));\n+        return this.innerClasses.entrySet().stream().filter(entry -> ((String)entry.getKey()).endsWith(suffix)).map((Function<? super Object, ? extends FinalClassCheck.ClassDesc>)Map.Entry::getValue).min(longestMatch.reversed().thenComparingInt(FinalClassCheck.TypeDeclarationDescription::getDepth));\n     }\n     \n     private String extractQualifiedTypeName(final DetailAST typeDeclarationAst) {\n         final String className = typeDeclarationAst.findFirstToken(58).getText();\n         String outerTypeDeclarationQualifiedName = null;\n         if (!this.typeDeclarations.isEmpty()) {\n             outerTypeDeclarationQualifiedName = ((FinalClassCheck.TypeDeclarationDescription)this.typeDeclarations.peek()).getQualifiedName();\n"}]}
