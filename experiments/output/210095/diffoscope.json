{"diffoscope-json-version": 1, "source1": "first/BackgroundInitializer.class", "source2": "second/BackgroundInitializer.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -13,16 +13,16 @@\n     private ExecutorService executor;\n     private Future<T> future;\n     \n     protected BackgroundInitializer() {\n         this(null);\n     }\n     \n-    protected BackgroundInitializer(final ExecutorService exec) {\n-        this.setExternalExecutor(exec);\n+    protected BackgroundInitializer(final ExecutorService externalExecutor) {\n+        this.setExternalExecutor(externalExecutor);\n     }\n     \n     public final synchronized ExecutorService getExternalExecutor() {\n         return this.externalExecutor;\n     }\n     \n     public synchronized boolean isStarted() {\n@@ -35,38 +35,38 @@\n         }\n         this.externalExecutor = externalExecutor;\n     }\n     \n     public synchronized boolean start() {\n         if (!this.isStarted()) {\n             this.executor = this.getExternalExecutor();\n-            ExecutorService tempExec;\n+            ExecutorService executorService;\n             if (this.executor == null) {\n-                tempExec = (this.executor = this.createExecutor());\n+                executorService = (this.executor = this.createExecutor());\n             }\n             else {\n-                tempExec = null;\n+                executorService = null;\n             }\n-            this.future = this.executor.submit(this.createTask(tempExec));\n+            this.future = this.executor.submit(this.createTask(executorService));\n             return true;\n         }\n         return false;\n     }\n     \n     public T get() throws ConcurrentException {\n         try {\n             return this.getFuture().get();\n         }\n-        catch (final ExecutionException execex) {\n-            ConcurrentUtils.handleCause(execex);\n+        catch (final ExecutionException ex) {\n+            ConcurrentUtils.handleCause(ex);\n             return null;\n         }\n-        catch (final InterruptedException iex) {\n+        catch (final InterruptedException ex2) {\n             Thread.currentThread().interrupt();\n-            throw new ConcurrentException((Throwable)iex);\n+            throw new ConcurrentException((Throwable)ex2);\n         }\n     }\n     \n     public synchronized Future<T> getFuture() {\n         if (this.future == null) {\n             throw new IllegalStateException(\"start() must be called first!\");\n         }\n@@ -79,15 +79,15 @@\n     \n     protected int getTaskCount() {\n         return 1;\n     }\n     \n     protected abstract T initialize() throws Exception;\n     \n-    private Callable<T> createTask(final ExecutorService execDestroy) {\n-        return (Callable<T>)new BackgroundInitializer.InitializationTask(this, execDestroy);\n+    private Callable<T> createTask(final ExecutorService executorService) {\n+        return (Callable<T>)new BackgroundInitializer.InitializationTask(this, executorService);\n     }\n     \n     private ExecutorService createExecutor() {\n         return Executors.newFixedThreadPool(this.getTaskCount());\n     }\n }\n"}]}
