{"diffoscope-json-version": 1, "source1": "first/TypeUtils.class", "source2": "second/TypeUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -22,14 +22,18 @@\n import java.lang.reflect.Type;\n import java.lang.reflect.WildcardType;\n \n public class TypeUtils\n {\n     public static final WildcardType WILDCARD_ALL;\n     \n+    static {\n+        WILDCARD_ALL = wildcardType().withUpperBounds(new Type[] { Object.class }).build();\n+    }\n+    \n     public static boolean isAssignable(final Type type, final Type toType) {\n         return isAssignable(type, toType, null);\n     }\n     \n     private static boolean isAssignable(final Type type, final Type toType, final Map<TypeVariable<?>, Type> typeVarAssigns) {\n         if (toType == null || toType instanceof Class) {\n             return isAssignable(type, (Class<?>)toType);\n@@ -62,15 +66,17 @@\n         if (type instanceof Class) {\n             return ClassUtils.isAssignable((Class)type, (Class)toClass);\n         }\n         if (type instanceof ParameterizedType) {\n             return isAssignable(getRawType((ParameterizedType)type), toClass);\n         }\n         if (type instanceof TypeVariable) {\n-            for (final Type bound : ((TypeVariable)type).getBounds()) {\n+            Type[] bounds;\n+            for (int length = (bounds = ((TypeVariable)type).getBounds()).length, i = 0; i < length; ++i) {\n+                final Type bound = bounds[i];\n                 if (isAssignable(bound, toClass)) {\n                     return true;\n                 }\n             }\n             return false;\n         }\n         if (type instanceof GenericArrayType) {\n@@ -141,23 +147,27 @@\n             final Class<?> cls = (Class)type;\n             return cls.isArray() && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns);\n         }\n         if (type instanceof GenericArrayType) {\n             return isAssignable(((GenericArrayType)type).getGenericComponentType(), toComponentType, typeVarAssigns);\n         }\n         if (type instanceof WildcardType) {\n-            for (final Type bound : getImplicitUpperBounds((WildcardType)type)) {\n+            Type[] implicitUpperBounds;\n+            for (int length = (implicitUpperBounds = getImplicitUpperBounds((WildcardType)type)).length, i = 0; i < length; ++i) {\n+                final Type bound = implicitUpperBounds[i];\n                 if (isAssignable(bound, toGenericArrayType)) {\n                     return true;\n                 }\n             }\n             return false;\n         }\n         if (type instanceof TypeVariable) {\n-            for (final Type bound : getImplicitBounds((TypeVariable<?>)type)) {\n+            Type[] implicitBounds;\n+            for (int length2 = (implicitBounds = getImplicitBounds((TypeVariable<?>)type)).length, j = 0; j < length2; ++j) {\n+                final Type bound = implicitBounds[j];\n                 if (isAssignable(bound, toGenericArrayType)) {\n                     return true;\n                 }\n             }\n             return false;\n         }\n         if (type instanceof ParameterizedType) {\n@@ -178,38 +188,50 @@\n         }\n         final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType);\n         final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType);\n         if (type instanceof WildcardType) {\n             final WildcardType wildcardType = (WildcardType)type;\n             final Type[] upperBounds = getImplicitUpperBounds(wildcardType);\n             final Type[] lowerBounds = getImplicitLowerBounds(wildcardType);\n-            for (Type toBound : toUpperBounds) {\n+            Type[] array;\n+            for (int length = (array = toUpperBounds).length, i = 0; i < length; ++i) {\n+                Type toBound = array[i];\n                 toBound = substituteTypeVariables(toBound, typeVarAssigns);\n-                for (final Type bound : upperBounds) {\n+                Type[] array2;\n+                for (int length2 = (array2 = upperBounds).length, j = 0; j < length2; ++j) {\n+                    final Type bound = array2[j];\n                     if (!isAssignable(bound, toBound, typeVarAssigns)) {\n                         return false;\n                     }\n                 }\n             }\n-            for (Type toBound : toLowerBounds) {\n+            Type[] array3;\n+            for (int length3 = (array3 = toLowerBounds).length, k = 0; k < length3; ++k) {\n+                Type toBound = array3[k];\n                 toBound = substituteTypeVariables(toBound, typeVarAssigns);\n-                for (final Type bound : lowerBounds) {\n+                Type[] array4;\n+                for (int length4 = (array4 = lowerBounds).length, l = 0; l < length4; ++l) {\n+                    final Type bound = array4[l];\n                     if (!isAssignable(toBound, bound, typeVarAssigns)) {\n                         return false;\n                     }\n                 }\n             }\n             return true;\n         }\n-        for (final Type toBound2 : toUpperBounds) {\n+        Type[] array5;\n+        for (int length5 = (array5 = toUpperBounds).length, n = 0; n < length5; ++n) {\n+            final Type toBound2 = array5[n];\n             if (!isAssignable(type, substituteTypeVariables(toBound2, typeVarAssigns), typeVarAssigns)) {\n                 return false;\n             }\n         }\n-        for (final Type toBound2 : toLowerBounds) {\n+        Type[] array6;\n+        for (int length6 = (array6 = toLowerBounds).length, n2 = 0; n2 < length6; ++n2) {\n+            final Type toBound2 = array6[n2];\n             if (!isAssignable(substituteTypeVariables(toBound2, typeVarAssigns), type, typeVarAssigns)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n@@ -220,17 +242,18 @@\n         if (toTypeVariable == null) {\n             return false;\n         }\n         if (toTypeVariable.equals(type)) {\n             return true;\n         }\n         if (type instanceof TypeVariable) {\n-            final Type[] implicitBounds;\n-            final Type[] bounds = implicitBounds = getImplicitBounds((TypeVariable<?>)type);\n-            for (final Type bound : implicitBounds) {\n+            final Type[] bounds = getImplicitBounds((TypeVariable<?>)type);\n+            Type[] array;\n+            for (int length = (array = bounds).length, i = 0; i < length; ++i) {\n+                final Type bound = array[i];\n                 if (isAssignable(bound, toTypeVariable, typeVarAssigns)) {\n                     return true;\n                 }\n             }\n         }\n         if (type instanceof Class || type instanceof ParameterizedType || type instanceof GenericArrayType || type instanceof WildcardType) {\n             return false;\n@@ -264,23 +287,27 @@\n         if (type instanceof ParameterizedType) {\n             return getTypeArguments((ParameterizedType)type, toClass, subtypeVarAssigns);\n         }\n         if (type instanceof GenericArrayType) {\n             return getTypeArguments(((GenericArrayType)type).getGenericComponentType(), toClass.isArray() ? toClass.getComponentType() : toClass, subtypeVarAssigns);\n         }\n         if (type instanceof WildcardType) {\n-            for (final Type bound : getImplicitUpperBounds((WildcardType)type)) {\n+            Type[] implicitUpperBounds;\n+            for (int length = (implicitUpperBounds = getImplicitUpperBounds((WildcardType)type)).length, i = 0; i < length; ++i) {\n+                final Type bound = implicitUpperBounds[i];\n                 if (isAssignable(bound, toClass)) {\n                     return getTypeArguments(bound, toClass, subtypeVarAssigns);\n                 }\n             }\n             return null;\n         }\n         if (type instanceof TypeVariable) {\n-            for (final Type bound : getImplicitBounds((TypeVariable<?>)type)) {\n+            Type[] implicitBounds;\n+            for (int length2 = (implicitBounds = getImplicitBounds((TypeVariable<?>)type)).length, j = 0; j < length2; ++j) {\n+                final Type bound = implicitBounds[j];\n                 if (isAssignable(bound, toClass)) {\n                     return getTypeArguments(bound, toClass, subtypeVarAssigns);\n                 }\n             }\n             return null;\n         }\n         throw new IllegalStateException(\"found an unhandled type: \" + type);\n@@ -297,15 +324,15 @@\n             final ParameterizedType parameterizedOwnerType = (ParameterizedType)ownerType;\n             typeVarAssigns = getTypeArguments(parameterizedOwnerType, getRawType(parameterizedOwnerType), subtypeVarAssigns);\n         }\n         else {\n             typeVarAssigns = ((subtypeVarAssigns == null) ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns));\n         }\n         final Type[] typeArgs = parameterizedType.getActualTypeArguments();\n-        final TypeVariable<?>[] typeParams = cls.getTypeParameters();\n+        final TypeVariable[] typeParams = cls.getTypeParameters();\n         for (int i = 0; i < typeParams.length; ++i) {\n             final Type typeArg = typeArgs[i];\n             typeVarAssigns.put(typeParams[i], typeVarAssigns.containsKey(typeArg) ? ((Type)typeVarAssigns.get(typeArg)) : typeArg);\n         }\n         if (toClass.equals(cls)) {\n             return typeVarAssigns;\n         }\n@@ -352,30 +379,32 @@\n     \n     private static <T> void mapTypeVariablesToArguments(final Class<T> cls, final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) {\n         final Type ownerType = parameterizedType.getOwnerType();\n         if (ownerType instanceof ParameterizedType) {\n             mapTypeVariablesToArguments((Class<Object>)cls, (ParameterizedType)ownerType, typeVarAssigns);\n         }\n         final Type[] typeArgs = parameterizedType.getActualTypeArguments();\n-        final TypeVariable<?>[] typeVars = getRawType(parameterizedType).getTypeParameters();\n+        final TypeVariable[] typeVars = getRawType(parameterizedType).getTypeParameters();\n         final List<TypeVariable<Class<T>>> typeVarList = Arrays.asList(cls.getTypeParameters());\n         for (int i = 0; i < typeArgs.length; ++i) {\n             final TypeVariable<?> typeVar = typeVars[i];\n             final Type typeArg = typeArgs[i];\n             if (typeVarList.contains(typeArg) && typeVarAssigns.containsKey(typeVar)) {\n-                typeVarAssigns.put((TypeVariable)typeArg, typeVarAssigns.get((Object)typeVar));\n+                typeVarAssigns.put(typeArg, (Type)typeVarAssigns.get(typeVar));\n             }\n         }\n     }\n     \n     private static Type getClosestParentType(final Class<?> cls, final Class<?> superClass) {\n         if (superClass.isInterface()) {\n             final Type[] interfaceTypes = cls.getGenericInterfaces();\n             Type genericInterface = null;\n-            for (final Type midType : interfaceTypes) {\n+            Type[] array;\n+            for (int length = (array = interfaceTypes).length, i = 0; i < length; ++i) {\n+                final Type midType = array[i];\n                 Class<?> midClass = null;\n                 if (midType instanceof ParameterizedType) {\n                     midClass = getRawType((ParameterizedType)midType);\n                 }\n                 else {\n                     if (!(midType instanceof Class)) {\n                         throw new IllegalStateException(\"Unexpected generic interface type found: \" + midType);\n@@ -429,23 +458,25 @@\n         final Type[] bounds = wildcardType.getUpperBounds();\n         return (bounds.length == 0) ? new Type[] { Object.class } : normalizeUpperBounds(bounds);\n     }\n     \n     public static Type[] getImplicitLowerBounds(final WildcardType wildcardType) {\n         Validate.notNull((Object)wildcardType, \"wildcardType is null\", new Object[0]);\n         final Type[] bounds = wildcardType.getLowerBounds();\n-        return (bounds.length == 0) ? new Type[] { null } : bounds;\n+        return (bounds.length == 0) ? new Type[1] : bounds;\n     }\n     \n     public static boolean typesSatisfyVariables(final Map<TypeVariable<?>, Type> typeVarAssigns) {\n         Validate.notNull((Object)typeVarAssigns, \"typeVarAssigns is null\", new Object[0]);\n         for (final Map.Entry<TypeVariable<?>, Type> entry : typeVarAssigns.entrySet()) {\n             final TypeVariable<?> typeVar = (TypeVariable<?>)entry.getKey();\n             final Type type = (Type)entry.getValue();\n-            for (final Type bound : getImplicitBounds(typeVar)) {\n+            Type[] implicitBounds;\n+            for (int length = (implicitBounds = getImplicitBounds(typeVar)).length, i = 0; i < length; ++i) {\n+                final Type bound = implicitBounds[i];\n                 if (!isAssignable(type, substituteTypeVariables(bound, typeVarAssigns), typeVarAssigns)) {\n                     return false;\n                 }\n             }\n         }\n         return true;\n     }\n@@ -563,15 +594,17 @@\n         if (type instanceof TypeVariable) {\n             return true;\n         }\n         if (type instanceof Class) {\n             return ((Class)type).getTypeParameters().length > 0;\n         }\n         if (type instanceof ParameterizedType) {\n-            for (final Type arg : ((ParameterizedType)type).getActualTypeArguments()) {\n+            Type[] actualTypeArguments;\n+            for (int length = (actualTypeArguments = ((ParameterizedType)type).getActualTypeArguments()).length, i = 0; i < length; ++i) {\n+                final Type arg = actualTypeArguments[i];\n                 if (containsTypeVariables(arg)) {\n                     return true;\n                 }\n             }\n             return false;\n         }\n         if (type instanceof WildcardType) {\n@@ -603,15 +636,15 @@\n         }\n         else {\n             Validate.isTrue(isAssignable(owner, raw.getEnclosingClass()), \"%s is invalid owner type for parameterized %s\", new Object[] { owner, raw });\n             useOwner = owner;\n         }\n         Validate.noNullElements((Object[])typeArguments, \"null type argument at index %s\", new Object[0]);\n         Validate.isTrue(raw.getTypeParameters().length == typeArguments.length, \"invalid number of type parameters specified: expected %d, got %d\", new Object[] { Integer.valueOf(raw.getTypeParameters().length), Integer.valueOf(typeArguments.length) });\n-        return (ParameterizedType)new TypeUtils.ParameterizedTypeImpl((Class)raw, useOwner, typeArguments, (TypeUtils.TypeUtils$1)null);\n+        return (ParameterizedType)new TypeUtils.ParameterizedTypeImpl((Class)raw, useOwner, typeArguments, (TypeUtils.ParameterizedTypeImpl)null);\n     }\n     \n     public static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings) {\n         Validate.notNull((Object)raw, \"raw class is null\", new Object[0]);\n         Validate.notNull((Object)typeArgMappings, \"typeArgMappings is null\", new Object[0]);\n         return parameterizeWithOwner(owner, raw, extractTypeArgumentsFrom(typeArgMappings, (TypeVariable<?>[])raw.getTypeParameters()));\n     }\n@@ -623,19 +656,19 @@\n             Validate.isTrue(mappings.containsKey((Object)var), \"missing argument mapping for %s\", new Object[] { toString((Type)var) });\n             result[index++] = mappings.get(var);\n         }\n         return result;\n     }\n     \n     public static TypeUtils.WildcardTypeBuilder wildcardType() {\n-        return new TypeUtils.WildcardTypeBuilder((TypeUtils.TypeUtils$1)null);\n+        return new TypeUtils.WildcardTypeBuilder((TypeUtils.WildcardTypeBuilder)null);\n     }\n     \n     public static GenericArrayType genericArrayType(final Type componentType) {\n-        return (GenericArrayType)new TypeUtils.GenericArrayTypeImpl((Type)Validate.notNull((Object)componentType, \"componentType is null\", new Object[0]), (TypeUtils.TypeUtils$1)null);\n+        return (GenericArrayType)new TypeUtils.GenericArrayTypeImpl((Type)Validate.notNull((Object)componentType, \"componentType is null\", new Object[0]), (TypeUtils.GenericArrayTypeImpl)null);\n     }\n     \n     public static boolean equals(final Type t1, final Type t2) {\n         if (Objects.equals(t1, t2)) {\n             return true;\n         }\n         if (t1 instanceof ParameterizedType) {\n@@ -727,15 +760,15 @@\n     \n     public static <T> Typed<T> wrap(final Class<T> type) {\n         return wrap((Type)type);\n     }\n     \n     private static String classToString(final Class<?> c) {\n         if (c.isArray()) {\n-            return toString((Type)c.getComponentType()) + \"[]\";\n+            return String.valueOf(toString((Type)c.getComponentType())) + \"[]\";\n         }\n         final StringBuilder buf = new StringBuilder();\n         if (c.getEnclosingClass() != null) {\n             buf.append(classToString(c.getEnclosingClass())).append('.').append(c.getSimpleName());\n         }\n         else {\n             buf.append(c.getName());\n@@ -836,12 +869,8 @@\n         }\n         return buf;\n     }\n     \n     private static <T> String toString(final T object) {\n         return (object instanceof Type) ? toString((Type)object) : object.toString();\n     }\n-    \n-    static {\n-        WILDCARD_ALL = wildcardType().withUpperBounds(new Type[] { Object.class }).build();\n-    }\n }\n"}]}
