{"diffoscope-json-version": 1, "source1": "first/BinaryTree.class", "source2": "second/BinaryTree.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -9,102 +9,102 @@\n \n class BinaryTree\n {\n     private static final int UNDEFINED = -1;\n     private static final int NODE = -2;\n     private final int[] tree;\n     \n-    public BinaryTree(final int i) {\n-        if (i < 0 || i > 30) {\n-            throw new IllegalArgumentException(\"depth must be bigger than 0 and not bigger than 30 but is \" + i);\n+    public BinaryTree(final int n) {\n+        if (n < 0 || n > 30) {\n+            throw new IllegalArgumentException(\"depth must be bigger than 0 and not bigger than 30 but is \" + n);\n         }\n-        Arrays.fill(this.tree = new int[(int)((1L << i + 1) - 1L)], -1);\n+        Arrays.fill(this.tree = new int[(int)((1L << n + 1) - 1L)], -1);\n     }\n     \n-    public void addLeaf(final int i, final int n, final int n2, final int n3) {\n-        if (n2 == 0) {\n-            if (this.tree[i] != -1) {\n-                throw new IllegalArgumentException(\"Tree value at index \" + i + \" has already been assigned (\" + this.tree[i] + \")\");\n+    public void addLeaf(final int n, final int n2, final int n3, final int n4) {\n+        if (n3 == 0) {\n+            if (this.tree[n] != -1) {\n+                throw new IllegalArgumentException(\"Tree value at index \" + n + \" has already been assigned (\" + this.tree[n]);\n             }\n-            this.tree[i] = n3;\n+            this.tree[n] = n4;\n         }\n         else {\n-            this.tree[i] = -2;\n-            this.addLeaf(2 * i + 1 + (n & 0x1), n >>> 1, n2 - 1, n3);\n+            this.tree[n] = -2;\n+            this.addLeaf(2 * n + 1 + (n2 & 0x1), n2 >>> 1, n3 - 1, n4);\n         }\n     }\n     \n     public int read(final BitStream bitStream) throws IOException {\n-        int i = 0;\n+        int n = 0;\n         while (true) {\n             final int nextBit = bitStream.nextBit();\n             if (nextBit == -1) {\n                 return -1;\n             }\n-            final int n = 2 * i + 1 + nextBit;\n-            final int n2 = this.tree[n];\n-            if (n2 == -2) {\n-                i = n;\n+            final int n2 = 2 * n + 1 + nextBit;\n+            final int n3 = this.tree[n2];\n+            if (n3 == -2) {\n+                n = n2;\n             }\n             else {\n-                if (n2 != -1) {\n-                    return n2;\n+                if (n3 != -1) {\n+                    return n3;\n                 }\n-                throw new IOException(\"The child \" + nextBit + \" of node at index \" + i + \" is not defined\");\n+                throw new IOException(\"The child \" + nextBit + \" of node at index \" + n + \" is not defined\");\n             }\n         }\n     }\n     \n-    static BinaryTree decode(final InputStream inputStream, final int i) throws IOException {\n-        if (i < 0) {\n-            throw new IllegalArgumentException(\"totalNumberOfValues must be bigger than 0, is \" + i);\n+    static BinaryTree decode(final InputStream inputStream, final int n) throws IOException {\n+        if (n < 0) {\n+            throw new IllegalArgumentException(\"totalNumberOfValues must be bigger than 0, is \" + n);\n         }\n-        final int n = inputStream.read() + 1;\n-        if (n == 0) {\n+        final int n2 = inputStream.read() + 1;\n+        if (n2 == 0) {\n             throw new IOException(\"Cannot read the size of the encoded tree, unexpected end of stream\");\n         }\n-        final byte[] range = IOUtils.readRange(inputStream, n);\n-        if (range.length != n) {\n+        final byte[] range = IOUtils.readRange(inputStream, n2);\n+        if (range.length != n2) {\n             throw new EOFException();\n         }\n         int max = 0;\n-        final int[] array = new int[i];\n-        int n2 = 0;\n+        final int[] array = new int[n];\n+        int n3 = 0;\n         for (final byte b : range) {\n-            final int n3 = ((b & 0xF0) >> 4) + 1;\n-            if (n2 + n3 > i) {\n+            final int n4 = ((b & 0xF0) >> 4) + 1;\n+            if (n3 + n4 > n) {\n                 throw new IOException(\"Number of values exceeds given total number of values\");\n             }\n             final int b2 = (b & 0xF) + 1;\n-            for (int k = 0; k < n3; ++k) {\n-                array[n2++] = b2;\n+            for (int j = 0; j < n4; ++j) {\n+                array[n3++] = b2;\n             }\n             max = Math.max(max, b2);\n         }\n         final int length2 = array.length;\n         final int[] array3 = new int[length2];\n-        for (int l = 0; l < array3.length; ++l) {\n-            array3[l] = l;\n+        for (int k = 0; k < array3.length; ++k) {\n+            array3[k] = k;\n         }\n-        int n4 = 0;\n+        int n5 = 0;\n         final int[] array4 = new int[length2];\n-        for (int n5 = 0; n5 < length2; ++n5) {\n+        for (int l = 0; l < length2; ++l) {\n             for (int n6 = 0; n6 < length2; ++n6) {\n-                if (array[n6] == n5) {\n-                    array4[n4] = n5;\n-                    array3[n4] = n6;\n-                    ++n4;\n+                if (array[n6] == l) {\n+                    array4[n5] = l;\n+                    array3[n5] = n6;\n+                    ++n5;\n                 }\n             }\n         }\n         int n7 = 0;\n         int n8 = 0;\n         int n9 = 0;\n-        final int[] array5 = new int[i];\n-        for (int n10 = i - 1; n10 >= 0; --n10) {\n+        final int[] array5 = new int[n];\n+        for (int n10 = n - 1; n10 >= 0; --n10) {\n             n7 += n8;\n             if (array4[n10] != n9) {\n                 n9 = array4[n10];\n                 n8 = 1 << 16 - n9;\n             }\n             array5[array3[n10]] = n7;\n         }\n"}]}
