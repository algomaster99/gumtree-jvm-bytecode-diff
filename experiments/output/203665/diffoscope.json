{"diffoscope-json-version": 1, "source1": "first/TarUtils.class", "source2": "second/TarUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -23,472 +23,461 @@\n     private static final int BYTE_MASK = 255;\n     static final ZipEncoding DEFAULT_ENCODING;\n     static final ZipEncoding FALLBACK_ENCODING;\n     \n     private TarUtils() {\n     }\n     \n-    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n-        long result = 0L;\n-        int end = offset + length;\n-        int start = offset;\n-        if (length < 2) {\n-            throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n+    public static long parseOctal(final byte[] array, final int n, final int i) {\n+        long n2 = 0L;\n+        int n3 = n + i;\n+        int j = n;\n+        if (i < 2) {\n+            throw new IllegalArgumentException(\"Length \" + i + \" must be at least 2\");\n         }\n-        if (buffer[start] == 0) {\n+        if (array[j] == 0) {\n             return 0L;\n         }\n-        while (start < end && buffer[start] == 32) {\n-            ++start;\n+        while (j < n3 && array[j] == 32) {\n+            ++j;\n         }\n-        for (byte trailer = buffer[end - 1]; start < end && (trailer == 0 || trailer == 32); --end, trailer = buffer[end - 1]) {}\n-        while (start < end) {\n-            final byte currentByte = buffer[start];\n-            if (currentByte < 48 || currentByte > 55) {\n-                throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));\n+        for (byte b = array[n3 - 1]; j < n3 && (b == 0 || b == 32); --n3, b = array[n3 - 1]) {}\n+        while (j < n3) {\n+            final byte b2 = array[j];\n+            if (b2 < 48 || b2 > 55) {\n+                throw new IllegalArgumentException(exceptionMessage(array, n, i, j, b2));\n             }\n-            result = (result << 3) + (currentByte - 48);\n-            ++start;\n+            n2 = (n2 << 3) + (b2 - 48);\n+            ++j;\n         }\n-        return result;\n+        return n2;\n     }\n     \n-    public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length) {\n-        if ((buffer[offset] & 0x80) == 0x0) {\n-            return parseOctal(buffer, offset, length);\n+    public static long parseOctalOrBinary(final byte[] array, final int n, final int n2) {\n+        if ((array[n] & 0x80) == 0x0) {\n+            return parseOctal(array, n, n2);\n         }\n-        final boolean negative = buffer[offset] == -1;\n-        if (length < 9) {\n-            return parseBinaryLong(buffer, offset, length, negative);\n+        final boolean b = array[n] == -1;\n+        if (n2 < 9) {\n+            return parseBinaryLong(array, n, n2, b);\n         }\n-        return parseBinaryBigInteger(buffer, offset, length, negative);\n+        return parseBinaryBigInteger(array, n, n2, b);\n     }\n     \n-    private static long parseBinaryLong(final byte[] buffer, final int offset, final int length, final boolean negative) {\n-        if (length >= 9) {\n-            throw new IllegalArgumentException(\"At offset \" + offset + \", \" + length + \" byte binary number exceeds maximum signed long value\");\n+    private static long parseBinaryLong(final byte[] array, final int i, final int j, final boolean b) {\n+        if (j >= 9) {\n+            throw new IllegalArgumentException(\"At offset \" + i + \", \" + j + \" byte binary number exceeds maximum signed long value\");\n         }\n-        long val = 0L;\n-        for (int i = 1; i < length; ++i) {\n-            val = (val << 8) + (buffer[offset + i] & 0xFF);\n+        long n = 0L;\n+        for (int k = 1; k < j; ++k) {\n+            n = (n << 8) + (array[i + k] & 0xFF);\n         }\n-        if (negative) {\n-            --val;\n-            val ^= (long)Math.pow(2.0, (double)(length - 1) * 8.0) - 1L;\n+        if (b) {\n+            n = (n - 1L ^ (long)Math.pow(2.0, (double)(j - 1) * 8.0) - 1L);\n         }\n-        return negative ? (-val) : val;\n+        return b ? (-n) : n;\n     }\n     \n-    private static long parseBinaryBigInteger(final byte[] buffer, final int offset, final int length, final boolean negative) {\n-        final byte[] remainder = new byte[length - 1];\n-        System.arraycopy(buffer, offset + 1, remainder, 0, length - 1);\n-        BigInteger val = new BigInteger(remainder);\n-        if (negative) {\n-            val = val.add(BigInteger.valueOf(-1L)).not();\n+    private static long parseBinaryBigInteger(final byte[] array, final int i, final int j, final boolean b) {\n+        final byte[] val = new byte[j - 1];\n+        System.arraycopy(array, i + 1, val, 0, j - 1);\n+        BigInteger not = new BigInteger(val);\n+        if (b) {\n+            not = not.add(BigInteger.valueOf(-1L)).not();\n         }\n-        if (val.bitLength() > 63) {\n-            throw new IllegalArgumentException(\"At offset \" + offset + \", \" + length + \" byte binary number exceeds maximum signed long value\");\n+        if (not.bitLength() > 63) {\n+            throw new IllegalArgumentException(\"At offset \" + i + \", \" + j + \" byte binary number exceeds maximum signed long value\");\n         }\n-        return negative ? (-val.longValue()) : val.longValue();\n+        return b ? (-not.longValue()) : not.longValue();\n     }\n     \n-    public static boolean parseBoolean(final byte[] buffer, final int offset) {\n-        return buffer[offset] == 1;\n+    public static boolean parseBoolean(final byte[] array, final int n) {\n+        return array[n] == 1;\n     }\n     \n-    private static String exceptionMessage(final byte[] buffer, final int offset, final int length, final int current, final byte currentByte) {\n-        String string = new String(buffer, offset, length, Charset.defaultCharset());\n-        string = string.replace(\"\\u0000\", \"{NUL}\");\n-        return \"Invalid byte \" + currentByte + \" at offset \" + (current - offset) + \" in '\" + string + \"' len=\" + length;\n+    private static String exceptionMessage(final byte[] bytes, final int offset, final int n, final int n2, final byte i) {\n+        return \"Invalid byte \" + i + \" at offset \" + (n2 - offset) + \" in '\" + new String(bytes, offset, n, Charset.defaultCharset()).replace((CharSequence)\"\\u0000\", (CharSequence)\"{NUL}\") + \"' len=\" + n;\n     }\n     \n-    public static String parseName(final byte[] buffer, final int offset, final int length) {\n+    public static String parseName(final byte[] array, final int n, final int n2) {\n         try {\n-            return parseName(buffer, offset, length, TarUtils.DEFAULT_ENCODING);\n+            return parseName(array, n, n2, TarUtils.DEFAULT_ENCODING);\n         }\n         catch (final IOException ex) {\n             try {\n-                return parseName(buffer, offset, length, TarUtils.FALLBACK_ENCODING);\n+                return parseName(array, n, n2, TarUtils.FALLBACK_ENCODING);\n             }\n-            catch (final IOException ex2) {\n-                throw new UncheckedIOException(ex2);\n+            catch (final IOException cause) {\n+                throw new UncheckedIOException(cause);\n             }\n         }\n     }\n     \n-    public static String parseName(final byte[] buffer, final int offset, final int length, final ZipEncoding encoding) throws IOException {\n-        int len = 0;\n-        for (int i = offset; len < length && buffer[i] != 0; ++len, ++i) {}\n-        if (len > 0) {\n-            final byte[] b = new byte[len];\n-            System.arraycopy(buffer, offset, b, 0, len);\n-            return encoding.decode(b);\n+    public static String parseName(final byte[] array, final int n, final int n2, final ZipEncoding zipEncoding) throws IOException {\n+        int n3 = 0;\n+        for (int n4 = n; n3 < n2 && array[n4] != 0; ++n3, ++n4) {}\n+        if (n3 > 0) {\n+            final byte[] array2 = new byte[n3];\n+            System.arraycopy(array, n, array2, 0, n3);\n+            return zipEncoding.decode(array2);\n         }\n         return \"\";\n     }\n     \n-    public static TarArchiveStructSparse parseSparse(final byte[] buffer, final int offset) {\n-        final long sparseOffset = parseOctalOrBinary(buffer, offset, 12);\n-        final long sparseNumbytes = parseOctalOrBinary(buffer, offset + 12, 12);\n-        return new TarArchiveStructSparse(sparseOffset, sparseNumbytes);\n+    public static TarArchiveStructSparse parseSparse(final byte[] array, final int n) {\n+        return new TarArchiveStructSparse(parseOctalOrBinary(array, n, 12), parseOctalOrBinary(array, n + 12, 12));\n     }\n     \n-    static List<TarArchiveStructSparse> readSparseStructs(final byte[] buffer, final int offset, final int entries) throws IOException {\n-        final List<TarArchiveStructSparse> sparseHeaders = new ArrayList<TarArchiveStructSparse>();\n-        for (int i = 0; i < entries; ++i) {\n+    static List<TarArchiveStructSparse> readSparseStructs(final byte[] array, final int n, final int n2) throws IOException {\n+        final ArrayList list = new ArrayList();\n+        for (int i = 0; i < n2; ++i) {\n             try {\n-                final TarArchiveStructSparse sparseHeader = parseSparse(buffer, offset + i * 24);\n-                if (sparseHeader.getOffset() < 0L) {\n+                final TarArchiveStructSparse sparse = parseSparse(array, n + i * 24);\n+                if (sparse.getOffset() < 0L) {\n                     throw new IOException(\"Corrupted TAR archive, sparse entry with negative offset\");\n                 }\n-                if (sparseHeader.getNumbytes() < 0L) {\n+                if (sparse.getNumbytes() < 0L) {\n                     throw new IOException(\"Corrupted TAR archive, sparse entry with negative numbytes\");\n                 }\n-                sparseHeaders.add(sparseHeader);\n+                list.add(sparse);\n             }\n-            catch (final IllegalArgumentException ex) {\n-                throw new IOException(\"Corrupted TAR archive, sparse entry is invalid\", ex);\n+            catch (final IllegalArgumentException cause) {\n+                throw new IOException(\"Corrupted TAR archive, sparse entry is invalid\", cause);\n             }\n         }\n-        return Collections.unmodifiableList((List<? extends TarArchiveStructSparse>)sparseHeaders);\n+        return (List<TarArchiveStructSparse>)Collections.unmodifiableList((List<?>)list);\n     }\n     \n-    public static int formatNameBytes(final String name, final byte[] buf, final int offset, final int length) {\n+    public static int formatNameBytes(final String s, final byte[] array, final int n, final int n2) {\n         try {\n-            return formatNameBytes(name, buf, offset, length, TarUtils.DEFAULT_ENCODING);\n+            return formatNameBytes(s, array, n, n2, TarUtils.DEFAULT_ENCODING);\n         }\n         catch (final IOException ex) {\n             try {\n-                return formatNameBytes(name, buf, offset, length, TarUtils.FALLBACK_ENCODING);\n+                return formatNameBytes(s, array, n, n2, TarUtils.FALLBACK_ENCODING);\n             }\n-            catch (final IOException ex2) {\n-                throw new UncheckedIOException(ex2);\n+            catch (final IOException cause) {\n+                throw new UncheckedIOException(cause);\n             }\n         }\n     }\n     \n-    public static int formatNameBytes(final String name, final byte[] buf, final int offset, final int length, final ZipEncoding encoding) throws IOException {\n-        int len;\n-        ByteBuffer b;\n-        for (len = name.length(), b = encoding.encode(name); b.limit() > length && len > 0; b = encoding.encode(name.substring(0, --len))) {}\n-        final int limit = b.limit() - b.position();\n-        System.arraycopy(b.array(), b.arrayOffset(), buf, offset, limit);\n-        for (int i = limit; i < length; ++i) {\n-            buf[offset + i] = 0;\n+    public static int formatNameBytes(final String s, final byte[] array, final int n, final int n2, final ZipEncoding zipEncoding) throws IOException {\n+        int length;\n+        ByteBuffer byteBuffer;\n+        for (length = s.length(), byteBuffer = zipEncoding.encode(s); byteBuffer.limit() > n2 && length > 0; byteBuffer = zipEncoding.encode(s.substring(0, --length))) {}\n+        final int n3 = byteBuffer.limit() - byteBuffer.position();\n+        System.arraycopy(byteBuffer.array(), byteBuffer.arrayOffset(), array, n, n3);\n+        for (int i = n3; i < n2; ++i) {\n+            array[n + i] = 0;\n         }\n-        return offset + length;\n+        return n + n2;\n     }\n     \n-    public static void formatUnsignedOctalString(final long value, final byte[] buffer, final int offset, final int length) {\n-        int remaining = length;\n-        --remaining;\n-        if (value == 0L) {\n-            buffer[offset + remaining--] = 48;\n+    public static void formatUnsignedOctalString(final long n, final byte[] array, final int n2, final int i) {\n+        int j = i;\n+        --j;\n+        if (n == 0L) {\n+            array[n2 + j--] = 48;\n         }\n         else {\n-            long val;\n-            for (val = value; remaining >= 0 && val != 0L; val >>>= 3, --remaining) {\n-                buffer[offset + remaining] = (byte)(48 + (byte)(val & 0x7L));\n+            long n3;\n+            for (n3 = n; j >= 0 && n3 != 0L; n3 >>>= 3, --j) {\n+                array[n2 + j] = (byte)(48 + (byte)(n3 & 0x7L));\n             }\n-            if (val != 0L) {\n-                throw new IllegalArgumentException(value + \"=\" + Long.toOctalString(value) + \" will not fit in octal number buffer of length \" + length);\n+            if (n3 != 0L) {\n+                throw new IllegalArgumentException(n + \"=\" + Long.toOctalString(n) + \" will not fit in octal number buffer of length \" + i);\n             }\n         }\n-        while (remaining >= 0) {\n-            buffer[offset + remaining] = 48;\n-            --remaining;\n+        while (j >= 0) {\n+            array[n2 + j] = 48;\n+            --j;\n         }\n     }\n     \n-    public static int formatOctalBytes(final long value, final byte[] buf, final int offset, final int length) {\n-        int idx = length - 2;\n-        formatUnsignedOctalString(value, buf, offset, idx);\n-        buf[offset + idx++] = 32;\n-        buf[offset + idx] = 0;\n-        return offset + length;\n+    public static int formatOctalBytes(final long n, final byte[] array, final int n2, final int n3) {\n+        int n4 = n3 - 2;\n+        formatUnsignedOctalString(n, array, n2, n4);\n+        array[n2 + n4++] = 32;\n+        array[n2 + n4] = 0;\n+        return n2 + n3;\n     }\n     \n-    public static int formatLongOctalBytes(final long value, final byte[] buf, final int offset, final int length) {\n-        final int idx = length - 1;\n-        formatUnsignedOctalString(value, buf, offset, idx);\n-        buf[offset + idx] = 32;\n-        return offset + length;\n+    public static int formatLongOctalBytes(final long n, final byte[] array, final int n2, final int n3) {\n+        final int n4 = n3 - 1;\n+        formatUnsignedOctalString(n, array, n2, n4);\n+        array[n2 + n4] = 32;\n+        return n2 + n3;\n     }\n     \n-    public static int formatLongOctalOrBinaryBytes(final long value, final byte[] buf, final int offset, final int length) {\n-        final long maxAsOctalChar = (length == 8) ? 2097151L : 8589934591L;\n-        final boolean negative = value < 0L;\n-        if (!negative && value <= maxAsOctalChar) {\n-            return formatLongOctalBytes(value, buf, offset, length);\n+    public static int formatLongOctalOrBinaryBytes(final long n, final byte[] array, final int n2, final int n3) {\n+        final long n4 = (n3 == 8) ? 2097151L : 8589934591L;\n+        final boolean b = n < 0L;\n+        if (!b && n <= n4) {\n+            return formatLongOctalBytes(n, array, n2, n3);\n         }\n-        if (length < 9) {\n-            formatLongBinary(value, buf, offset, length, negative);\n+        if (n3 < 9) {\n+            formatLongBinary(n, array, n2, n3, b);\n         }\n         else {\n-            formatBigIntegerBinary(value, buf, offset, length, negative);\n+            formatBigIntegerBinary(n, array, n2, n3, b);\n         }\n-        buf[offset] = (byte)(negative ? 255 : 128);\n-        return offset + length;\n+        array[n2] = (byte)(b ? 255 : 128);\n+        return n2 + n3;\n     }\n     \n-    private static void formatLongBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) {\n-        final int bits = (length - 1) * 8;\n-        final long max = 1L << bits;\n-        long val = Math.abs(value);\n-        if (val < 0L || val >= max) {\n-            throw new IllegalArgumentException(\"Value \" + value + \" is too large for \" + length + \" byte field.\");\n+    private static void formatLongBinary(final long n, final byte[] array, final int n2, final int i, final boolean b) {\n+        final int n3 = (i - 1) * 8;\n+        final long n4 = 1L << n3;\n+        long abs = Math.abs(n);\n+        if (abs < 0L || abs >= n4) {\n+            throw new IllegalArgumentException(\"Value \" + n + \" is too large for \" + i + \" byte field.\");\n         }\n-        if (negative) {\n-            val ^= max - 1L;\n-            ++val;\n-            val |= 255L << bits;\n+        if (b) {\n+            abs = ((abs ^ n4 - 1L) + 1L | 255L << n3);\n         }\n-        for (int i = offset + length - 1; i >= offset; --i) {\n-            buf[i] = (byte)val;\n-            val >>= 8;\n+        for (int j = n2 + i - 1; j >= n2; --j) {\n+            array[j] = (byte)abs;\n+            abs >>= 8;\n         }\n     }\n     \n-    private static void formatBigIntegerBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) {\n-        final BigInteger val = BigInteger.valueOf(value);\n-        final byte[] b = val.toByteArray();\n-        final int len = b.length;\n-        if (len > length - 1) {\n-            throw new IllegalArgumentException(\"Value \" + value + \" is too large for \" + length + \" byte field.\");\n+    private static void formatBigIntegerBinary(final long n, final byte[] array, final int n2, final int i, final boolean b) {\n+        final byte[] byteArray = BigInteger.valueOf(n).toByteArray();\n+        final int length = byteArray.length;\n+        if (length > i - 1) {\n+            throw new IllegalArgumentException(\"Value \" + n + \" is too large for \" + i + \" byte field.\");\n         }\n-        final int off = offset + length - len;\n-        System.arraycopy(b, 0, buf, off, len);\n-        final byte fill = (byte)(negative ? 255 : 0);\n-        for (int i = offset + 1; i < off; ++i) {\n-            buf[i] = fill;\n+        final int n3 = n2 + i - length;\n+        System.arraycopy(byteArray, 0, array, n3, length);\n+        final byte b2 = (byte)(b ? 255 : 0);\n+        for (int j = n2 + 1; j < n3; ++j) {\n+            array[j] = b2;\n         }\n     }\n     \n-    public static int formatCheckSumOctalBytes(final long value, final byte[] buf, final int offset, final int length) {\n-        int idx = length - 2;\n-        formatUnsignedOctalString(value, buf, offset, idx);\n-        buf[offset + idx++] = 0;\n-        buf[offset + idx] = 32;\n-        return offset + length;\n+    public static int formatCheckSumOctalBytes(final long n, final byte[] array, final int n2, final int n3) {\n+        int n4 = n3 - 2;\n+        formatUnsignedOctalString(n, array, n2, n4);\n+        array[n2 + n4++] = 0;\n+        array[n2 + n4] = 32;\n+        return n2 + n3;\n     }\n     \n-    public static long computeCheckSum(final byte[] buf) {\n-        long sum = 0L;\n-        for (final byte element : buf) {\n-            sum += (0xFF & element);\n+    public static long computeCheckSum(final byte[] array) {\n+        long n = 0L;\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            n += (0xFF & array[i]);\n         }\n-        return sum;\n+        return n;\n     }\n     \n-    public static boolean verifyCheckSum(final byte[] header) {\n-        final long storedSum = parseOctal(header, 148, 8);\n-        long unsignedSum = 0L;\n-        long signedSum = 0L;\n-        for (int i = 0; i < header.length; ++i) {\n-            byte b = header[i];\n+    public static boolean verifyCheckSum(final byte[] array) {\n+        final long octal = parseOctal(array, 148, 8);\n+        long n = 0L;\n+        long n2 = 0L;\n+        for (int i = 0; i < array.length; ++i) {\n+            int n3 = array[i];\n             if (148 <= i && i < 156) {\n-                b = 32;\n+                n3 = 32;\n             }\n-            unsignedSum += (0xFF & b);\n-            signedSum += b;\n+            n += (0xFF & n3);\n+            n2 += n3;\n         }\n-        return storedSum == unsignedSum || storedSum == signedSum;\n+        return octal == n || octal == n2;\n     }\n     \n     @Deprecated\n-    protected static Map<String, String> parsePaxHeaders(final InputStream inputStream, final List<TarArchiveStructSparse> sparseHeaders, final Map<String, String> globalPaxHeaders) throws IOException {\n-        return parsePaxHeaders(inputStream, sparseHeaders, globalPaxHeaders, -1L);\n+    protected static Map<String, String> parsePaxHeaders(final InputStream inputStream, final List<TarArchiveStructSparse> list, final Map<String, String> map) throws IOException {\n+        return parsePaxHeaders(inputStream, list, map, -1L);\n     }\n     \n-    protected static Map<String, String> parsePaxHeaders(final InputStream inputStream, final List<TarArchiveStructSparse> sparseHeaders, final Map<String, String> globalPaxHeaders, final long headerSize) throws IOException {\n-        final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n-        Long offset = null;\n-        int totalRead = 0;\n+    protected static Map<String, String> parsePaxHeaders(final InputStream inputStream, final List<TarArchiveStructSparse> list, final Map<String, String> m, final long n) throws IOException {\n+        final HashMap hashMap = new HashMap((Map<? extends K, ? extends V>)m);\n+        Long value = null;\n+        int n2 = 0;\n         while (true) {\n-            int len = 0;\n-            int read = 0;\n-            int ch;\n-            while ((ch = inputStream.read()) != -1) {\n-                ++read;\n-                ++totalRead;\n-                if (ch == 10) {\n+            int n3 = 0;\n+            int n4 = 0;\n+            int n5;\n+            while ((n5 = inputStream.read()) != -1) {\n+                ++n4;\n+                ++n2;\n+                if (n5 == 10) {\n                     break;\n                 }\n-                if (ch == 32) {\n-                    final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n-                    while ((ch = inputStream.read()) != -1) {\n-                        ++read;\n-                        if (++totalRead < 0) {\n+                if (n5 == 32) {\n+                    final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+                    while ((n5 = inputStream.read()) != -1) {\n+                        ++n4;\n+                        if (++n2 < 0) {\n                             break;\n                         }\n-                        if (headerSize >= 0L && totalRead >= headerSize) {\n+                        if (n >= 0L && n2 >= n) {\n                             break;\n                         }\n-                        if (ch == 61) {\n-                            final String keyword = coll.toString(\"UTF-8\");\n-                            final int restLen = len - read;\n-                            if (restLen <= 1) {\n-                                headers.remove(keyword);\n+                        if (n5 == 61) {\n+                            final String string = byteArrayOutputStream.toString(\"UTF-8\");\n+                            final int n6 = n3 - n4;\n+                            if (n6 <= 1) {\n+                                hashMap.remove(string);\n                                 break;\n                             }\n-                            if (headerSize >= 0L && restLen > headerSize - totalRead) {\n-                                throw new IOException(\"Paxheader value size \" + restLen + \" exceeds size of header record\");\n+                            if (n >= 0L && n6 > n - n2) {\n+                                throw new IOException(\"Paxheader value size \" + n6 + \" exceeds size of header record\");\n                             }\n-                            final byte[] rest = IOUtils.readRange(inputStream, restLen);\n-                            final int got = rest.length;\n-                            if (got != restLen) {\n-                                throw new IOException(\"Failed to read Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n+                            final byte[] range = IOUtils.readRange(inputStream, n6);\n+                            final int length = range.length;\n+                            if (length != n6) {\n+                                throw new IOException(\"Failed to read Paxheader. Expected \" + n6 + \" bytes, read \" + length);\n                             }\n-                            totalRead += restLen;\n-                            if (rest[restLen - 1] != 10) {\n+                            n2 += n6;\n+                            if (range[n6 - 1] != 10) {\n                                 throw new IOException(\"Failed to read Paxheader.Value should end with a newline\");\n                             }\n-                            final String value = new String(rest, 0, restLen - 1, StandardCharsets.UTF_8);\n-                            headers.put(keyword, value);\n-                            if (keyword.equals(\"GNU.sparse.offset\")) {\n-                                if (offset != null) {\n-                                    sparseHeaders.add(new TarArchiveStructSparse((long)offset, 0L));\n+                            final String s = new String(range, 0, n6 - 1, StandardCharsets.UTF_8);\n+                            hashMap.put(string, s);\n+                            if (string.equals(\"GNU.sparse.offset\")) {\n+                                if (value != null) {\n+                                    list.add(new TarArchiveStructSparse((long)value, 0L));\n                                 }\n                                 try {\n-                                    offset = Long.valueOf(value);\n+                                    value = Long.valueOf(s);\n                                 }\n                                 catch (final NumberFormatException ex) {\n                                     throw new IOException(\"Failed to read Paxheader.GNU.sparse.offset contains a non-numeric value\");\n                                 }\n-                                if (offset < 0L) {\n+                                if (value < 0L) {\n                                     throw new IOException(\"Failed to read Paxheader.GNU.sparse.offset contains negative value\");\n                                 }\n                             }\n-                            if (keyword.equals(\"GNU.sparse.numbytes\")) {\n-                                if (offset == null) {\n+                            if (string.equals(\"GNU.sparse.numbytes\")) {\n+                                if (value == null) {\n                                     throw new IOException(\"Failed to read Paxheader.GNU.sparse.offset is expected before GNU.sparse.numbytes shows up.\");\n                                 }\n-                                long numbytes;\n+                                long long1;\n                                 try {\n-                                    numbytes = Long.parseLong(value);\n+                                    long1 = Long.parseLong(s);\n                                 }\n                                 catch (final NumberFormatException ex2) {\n                                     throw new IOException(\"Failed to read Paxheader.GNU.sparse.numbytes contains a non-numeric value.\");\n                                 }\n-                                if (numbytes < 0L) {\n+                                if (long1 < 0L) {\n                                     throw new IOException(\"Failed to read Paxheader.GNU.sparse.numbytes contains negative value\");\n                                 }\n-                                sparseHeaders.add(new TarArchiveStructSparse((long)offset, numbytes));\n-                                offset = null;\n+                                list.add(new TarArchiveStructSparse((long)value, long1));\n+                                value = null;\n                             }\n                             break;\n                         }\n                         else {\n-                            coll.write(ch);\n+                            byteArrayOutputStream.write(n5);\n                         }\n                     }\n                     break;\n                 }\n-                if (ch < 48 || ch > 57) {\n+                if (n5 < 48 || n5 > 57) {\n                     throw new IOException(\"Failed to read Paxheader. Encountered a non-number while reading length\");\n                 }\n-                len *= 10;\n-                len += ch - 48;\n+                n3 = n3 * 10 + (n5 - 48);\n             }\n-            if (ch == -1) {\n-                if (offset != null) {\n-                    sparseHeaders.add(new TarArchiveStructSparse((long)offset, 0L));\n+            if (n5 == -1) {\n+                if (value != null) {\n+                    list.add(new TarArchiveStructSparse((long)value, 0L));\n                 }\n-                return headers;\n+                return hashMap;\n             }\n         }\n     }\n     \n     @Deprecated\n-    protected static List<TarArchiveStructSparse> parsePAX01SparseHeaders(final String sparseMap) {\n+    protected static List<TarArchiveStructSparse> parsePAX01SparseHeaders(final String s) {\n         try {\n-            return parseFromPAX01SparseHeaders(sparseMap);\n+            return parseFromPAX01SparseHeaders(s);\n         }\n-        catch (final IOException ex) {\n-            throw new UncheckedIOException(ex.getMessage(), ex);\n+        catch (final IOException cause) {\n+            throw new UncheckedIOException(cause.getMessage(), cause);\n         }\n     }\n     \n-    protected static List<TarArchiveStructSparse> parseFromPAX01SparseHeaders(final String sparseMap) throws IOException {\n-        final List<TarArchiveStructSparse> sparseHeaders = new ArrayList<TarArchiveStructSparse>();\n-        final String[] sparseHeaderStrings = sparseMap.split(\",\");\n-        if (sparseHeaderStrings.length % 2 == 1) {\n+    protected static List<TarArchiveStructSparse> parseFromPAX01SparseHeaders(final String s) throws IOException {\n+        final ArrayList list = new ArrayList();\n+        final String[] split = s.split(\",\");\n+        if (split.length % 2 == 1) {\n             throw new IOException(\"Corrupted TAR archive. Bad format in GNU.sparse.map PAX Header\");\n         }\n-        for (int i = 0; i < sparseHeaderStrings.length; i += 2) {\n-            long sparseOffset;\n+        for (int i = 0; i < split.length; i += 2) {\n+            long long1;\n             try {\n-                sparseOffset = Long.parseLong(sparseHeaderStrings[i]);\n+                long1 = Long.parseLong(split[i]);\n             }\n             catch (final NumberFormatException ex) {\n                 throw new IOException(\"Corrupted TAR archive. Sparse struct offset contains a non-numeric value\");\n             }\n-            if (sparseOffset < 0L) {\n+            if (long1 < 0L) {\n                 throw new IOException(\"Corrupted TAR archive. Sparse struct offset contains negative value\");\n             }\n-            long sparseNumbytes;\n+            long long2;\n             try {\n-                sparseNumbytes = Long.parseLong(sparseHeaderStrings[i + 1]);\n+                long2 = Long.parseLong(split[i + 1]);\n             }\n             catch (final NumberFormatException ex2) {\n                 throw new IOException(\"Corrupted TAR archive. Sparse struct numbytes contains a non-numeric value\");\n             }\n-            if (sparseNumbytes < 0L) {\n+            if (long2 < 0L) {\n                 throw new IOException(\"Corrupted TAR archive. Sparse struct numbytes contains negative value\");\n             }\n-            sparseHeaders.add(new TarArchiveStructSparse(sparseOffset, sparseNumbytes));\n+            list.add(new TarArchiveStructSparse(long1, long2));\n         }\n-        return Collections.unmodifiableList((List<? extends TarArchiveStructSparse>)sparseHeaders);\n+        return (List<TarArchiveStructSparse>)Collections.unmodifiableList((List<?>)list);\n     }\n     \n-    protected static List<TarArchiveStructSparse> parsePAX1XSparseHeaders(final InputStream inputStream, final int recordSize) throws IOException {\n-        final List<TarArchiveStructSparse> sparseHeaders = new ArrayList<TarArchiveStructSparse>();\n-        long bytesRead = 0L;\n-        long[] readResult = readLineOfNumberForPax1X(inputStream);\n-        long sparseHeadersCount = readResult[0];\n-        if (sparseHeadersCount < 0L) {\n+    protected static List<TarArchiveStructSparse> parsePAX1XSparseHeaders(final InputStream inputStream, final int n) throws IOException {\n+        final ArrayList list = new ArrayList();\n+        final long n2 = 0L;\n+        final long[] lineOfNumberForPax1X = readLineOfNumberForPax1X(inputStream);\n+        long n3 = lineOfNumberForPax1X[0];\n+        if (n3 < 0L) {\n             throw new IOException(\"Corrupted TAR archive. Negative value in sparse headers block\");\n         }\n-        bytesRead += readResult[1];\n-        while (sparseHeadersCount-- > 0L) {\n-            readResult = readLineOfNumberForPax1X(inputStream);\n-            final long sparseOffset = readResult[0];\n-            if (sparseOffset < 0L) {\n+        long n4 = n2 + lineOfNumberForPax1X[1];\n+        while (n3-- > 0L) {\n+            final long[] lineOfNumberForPax1X2 = readLineOfNumberForPax1X(inputStream);\n+            final long n5 = lineOfNumberForPax1X2[0];\n+            if (n5 < 0L) {\n                 throw new IOException(\"Corrupted TAR archive. Sparse header block offset contains negative value\");\n             }\n-            bytesRead += readResult[1];\n-            readResult = readLineOfNumberForPax1X(inputStream);\n-            final long sparseNumbytes = readResult[0];\n-            if (sparseNumbytes < 0L) {\n+            final long n6 = n4 + lineOfNumberForPax1X2[1];\n+            final long[] lineOfNumberForPax1X3 = readLineOfNumberForPax1X(inputStream);\n+            final long n7 = lineOfNumberForPax1X3[0];\n+            if (n7 < 0L) {\n                 throw new IOException(\"Corrupted TAR archive. Sparse header block numbytes contains negative value\");\n             }\n-            bytesRead += readResult[1];\n-            sparseHeaders.add(new TarArchiveStructSparse(sparseOffset, sparseNumbytes));\n+            n4 = n6 + lineOfNumberForPax1X3[1];\n+            list.add(new TarArchiveStructSparse(n5, n7));\n         }\n-        final long bytesToSkip = recordSize - bytesRead % recordSize;\n-        IOUtils.skip(inputStream, bytesToSkip);\n-        return sparseHeaders;\n+        IOUtils.skip(inputStream, (long)n - n4 % n);\n+        return list;\n     }\n     \n     private static long[] readLineOfNumberForPax1X(final InputStream inputStream) throws IOException {\n-        long result = 0L;\n-        long bytesRead = 0L;\n-        int number;\n-        while ((number = inputStream.read()) != 10) {\n-            ++bytesRead;\n-            if (number == -1) {\n+        long n = 0L;\n+        long n2 = 0L;\n+        int read;\n+        while ((read = inputStream.read()) != 10) {\n+            ++n2;\n+            if (read == -1) {\n                 throw new IOException(\"Unexpected EOF when reading parse information of 1.X PAX format\");\n             }\n-            if (number < 48 || number > 57) {\n+            if (read < 48 || read > 57) {\n                 throw new IOException(\"Corrupted TAR archive. Non-numeric value in sparse headers block\");\n             }\n-            result = result * 10L + (number - 48);\n+            n = n * 10L + (read - 48);\n         }\n-        ++bytesRead;\n-        return new long[] { result, bytesRead };\n+        return new long[] { n, n2 + 1L };\n     }\n     \n     static {\n         DEFAULT_ENCODING = ZipEncodingHelper.getZipEncoding((String)null);\n         FALLBACK_ENCODING = (ZipEncoding)new TarUtils.TarUtils$1();\n     }\n }\n"}]}
