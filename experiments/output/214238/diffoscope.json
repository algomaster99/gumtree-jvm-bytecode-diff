{"diffoscope-json-version": 1, "source1": "first/JSONObject.class", "source2": "second/JSONObject.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -30,390 +30,387 @@\n     private final Map<String, Object> map;\n     public static final Object NULL;\n     \n     public JSONObject() {\n         this.map = new HashMap<String, Object>();\n     }\n     \n-    public JSONObject(final JSONObject jo, final String... names) {\n-        this(names.length);\n-        for (int i = 0; i < names.length; ++i) {\n+    public JSONObject(final JSONObject jsonObject, final String... array) {\n+        this(array.length);\n+        for (int i = 0; i < array.length; ++i) {\n             try {\n-                this.putOnce(names[i], jo.opt(names[i]));\n+                this.putOnce(array[i], jsonObject.opt(array[i]));\n             }\n             catch (final Exception ex) {}\n         }\n     }\n     \n-    public JSONObject(final JSONTokener x) throws JSONException {\n+    public JSONObject(final JSONTokener jsonTokener) throws JSONException {\n         this();\n-        if (x.nextClean() != '{') {\n-            throw x.syntaxError(\"A JSONObject text must begin with '{'\");\n+        if (jsonTokener.nextClean() != '{') {\n+            throw jsonTokener.syntaxError(\"A JSONObject text must begin with '{'\");\n         }\n         while (true) {\n-            char c = x.nextClean();\n-            switch (c) {\n+            switch (jsonTokener.nextClean()) {\n                 case '\\0': {\n-                    throw x.syntaxError(\"A JSONObject text must end with '}'\");\n+                    throw jsonTokener.syntaxError(\"A JSONObject text must end with '}'\");\n                 }\n                 case '}': {\n                     return;\n                 }\n                 default: {\n-                    x.back();\n-                    final String key = x.nextValue().toString();\n-                    c = x.nextClean();\n-                    if (c != ':') {\n-                        throw x.syntaxError(\"Expected a ':' after a key\");\n+                    jsonTokener.back();\n+                    final String string = jsonTokener.nextValue().toString();\n+                    if (jsonTokener.nextClean() != ':') {\n+                        throw jsonTokener.syntaxError(\"Expected a ':' after a key\");\n                     }\n-                    if (key != null) {\n-                        if (this.opt(key) != null) {\n-                            throw x.syntaxError(\"Duplicate key \\\"\" + key + \"\\\"\");\n+                    if (string != null) {\n+                        if (this.opt(string) != null) {\n+                            throw jsonTokener.syntaxError(\"Duplicate key \\\"\" + string + \"\\\"\");\n                         }\n-                        final Object value = x.nextValue();\n-                        if (value != null) {\n-                            this.put(key, value);\n+                        final Object nextValue = jsonTokener.nextValue();\n+                        if (nextValue != null) {\n+                            this.put(string, nextValue);\n                         }\n                     }\n-                    switch (x.nextClean()) {\n+                    switch (jsonTokener.nextClean()) {\n                         case ',':\n                         case ';': {\n-                            if (x.nextClean() == '}') {\n+                            if (jsonTokener.nextClean() == '}') {\n                                 return;\n                             }\n-                            x.back();\n+                            jsonTokener.back();\n                             continue;\n                         }\n                         case '}': {\n                             return;\n                         }\n                         default: {\n-                            throw x.syntaxError(\"Expected a ',' or '}'\");\n+                            throw jsonTokener.syntaxError(\"Expected a ',' or '}'\");\n                         }\n                     }\n                     break;\n                 }\n             }\n         }\n     }\n     \n-    public JSONObject(final Map<?, ?> m) {\n-        if (m == null) {\n+    public JSONObject(final Map<?, ?> map) {\n+        if (map == null) {\n             this.map = new HashMap<String, Object>();\n         }\n         else {\n-            this.map = new HashMap<String, Object>(m.size());\n-            for (final Map.Entry<?, ?> e : m.entrySet()) {\n-                if (e.getKey() == null) {\n+            this.map = new HashMap<String, Object>(map.size());\n+            for (final Map.Entry entry : map.entrySet()) {\n+                if (entry.getKey() == null) {\n                     throw new NullPointerException(\"Null key.\");\n                 }\n-                final Object value = e.getValue();\n+                final Object value = entry.getValue();\n                 if (value == null) {\n                     continue;\n                 }\n-                this.map.put(String.valueOf((Object)e.getKey()), wrap(value));\n+                this.map.put(String.valueOf(entry.getKey()), wrap(value));\n             }\n         }\n     }\n     \n-    public JSONObject(final Object bean) {\n+    public JSONObject(final Object o) {\n         this();\n-        this.populateMap(bean);\n+        this.populateMap(o);\n     }\n     \n-    private JSONObject(final Object bean, final Set<Object> objectsRecord) {\n+    private JSONObject(final Object o, final Set<Object> set) {\n         this();\n-        this.populateMap(bean, objectsRecord);\n+        this.populateMap(o, set);\n     }\n     \n-    public JSONObject(final Object object, final String... names) {\n-        this(names.length);\n-        final Class<?> c = object.getClass();\n-        for (int i = 0; i < names.length; ++i) {\n-            final String name = names[i];\n+    public JSONObject(final Object obj, final String... array) {\n+        this(array.length);\n+        final Class<?> class1 = obj.getClass();\n+        for (int i = 0; i < array.length; ++i) {\n+            final String name = array[i];\n             try {\n-                this.putOpt(name, c.getField(name).get(object));\n+                this.putOpt(name, class1.getField(name).get(obj));\n             }\n             catch (final Exception ex) {}\n         }\n     }\n     \n-    public JSONObject(final String source) throws JSONException {\n-        this(new JSONTokener(source));\n+    public JSONObject(final String s) throws JSONException {\n+        this(new JSONTokener(s));\n     }\n     \n     public JSONObject(final String baseName, final Locale locale) throws JSONException {\n         this();\n         final ResourceBundle bundle = ResourceBundle.getBundle(baseName, locale, Thread.currentThread().getContextClassLoader());\n         final Enumeration<String> keys = bundle.getKeys();\n         while (keys.hasMoreElements()) {\n-            final Object key = keys.nextElement();\n-            if (key != null) {\n-                final String[] path = ((String)key).split(\"\\\\.\");\n-                final int last = path.length - 1;\n-                JSONObject target = this;\n-                for (final String segment : path) {\n-                    JSONObject nextTarget = target.optJSONObject(segment);\n-                    if (nextTarget == null) {\n-                        nextTarget = new JSONObject();\n-                        target.put(segment, nextTarget);\n+            final String nextElement = keys.nextElement();\n+            if (nextElement != null) {\n+                final String[] split = ((String)nextElement).split(\"\\\\.\");\n+                final int n = split.length - 1;\n+                JSONObject jsonObject = this;\n+                for (final String s : split) {\n+                    JSONObject optJSONObject = jsonObject.optJSONObject(s);\n+                    if (optJSONObject == null) {\n+                        optJSONObject = new JSONObject();\n+                        jsonObject.put(s, optJSONObject);\n                     }\n-                    target = nextTarget;\n+                    jsonObject = optJSONObject;\n                 }\n-                target.put(path[last], bundle.getString((String)key));\n+                jsonObject.put(split[n], bundle.getString(nextElement));\n             }\n         }\n     }\n     \n     protected JSONObject(final int initialCapacity) {\n         this.map = new HashMap<String, Object>(initialCapacity);\n     }\n     \n-    public JSONObject accumulate(final String key, final Object value) throws JSONException {\n-        testValidity(value);\n-        final Object object = this.opt(key);\n-        if (object == null) {\n-            this.put(key, (value instanceof JSONArray) ? new JSONArray().put(value) : value);\n+    public JSONObject accumulate(final String s, final Object o) throws JSONException {\n+        testValidity(o);\n+        final Object opt = this.opt(s);\n+        if (opt == null) {\n+            this.put(s, (o instanceof JSONArray) ? new JSONArray().put(o) : o);\n         }\n-        else if (object instanceof JSONArray) {\n-            ((JSONArray)object).put(value);\n+        else if (opt instanceof JSONArray) {\n+            ((JSONArray)opt).put(o);\n         }\n         else {\n-            this.put(key, new JSONArray().put(object).put(value));\n+            this.put(s, new JSONArray().put(opt).put(o));\n         }\n         return this;\n     }\n     \n-    public JSONObject append(final String key, final Object value) throws JSONException {\n-        testValidity(value);\n-        final Object object = this.opt(key);\n-        if (object == null) {\n-            this.put(key, new JSONArray().put(value));\n+    public JSONObject append(final String s, final Object o) throws JSONException {\n+        testValidity(o);\n+        final Object opt = this.opt(s);\n+        if (opt == null) {\n+            this.put(s, new JSONArray().put(o));\n         }\n         else {\n-            if (!(object instanceof JSONArray)) {\n-                throw wrongValueFormatException(key, \"JSONArray\", null, null);\n+            if (!(opt instanceof JSONArray)) {\n+                throw wrongValueFormatException(s, \"JSONArray\", null, null);\n             }\n-            this.put(key, ((JSONArray)object).put(value));\n+            this.put(s, ((JSONArray)opt).put(o));\n         }\n         return this;\n     }\n     \n     public static String doubleToString(final double d) {\n         if (Double.isInfinite(d) || Double.isNaN(d)) {\n             return \"null\";\n         }\n-        String string = Double.toString(d);\n-        if (string.indexOf(46) > 0 && string.indexOf(101) < 0 && string.indexOf(69) < 0) {\n-            while (string.endsWith(\"0\")) {\n-                string = string.substring(0, string.length() - 1);\n+        String s = Double.toString(d);\n+        if (s.indexOf(46) > 0 && s.indexOf(101) < 0 && s.indexOf(69) < 0) {\n+            while (s.endsWith(\"0\")) {\n+                s = s.substring(0, s.length() - 1);\n             }\n-            if (string.endsWith(\".\")) {\n-                string = string.substring(0, string.length() - 1);\n+            if (s.endsWith(\".\")) {\n+                s = s.substring(0, s.length() - 1);\n             }\n         }\n-        return string;\n+        return s;\n     }\n     \n-    public Object get(final String key) throws JSONException {\n-        if (key == null) {\n+    public Object get(final String s) throws JSONException {\n+        if (s == null) {\n             throw new JSONException(\"Null key.\");\n         }\n-        final Object object = this.opt(key);\n-        if (object == null) {\n-            throw new JSONException(\"JSONObject[\" + quote(key) + \"] not found.\");\n+        final Object opt = this.opt(s);\n+        if (opt == null) {\n+            throw new JSONException(\"JSONObject[\" + quote(s) + \"] not found.\");\n         }\n-        return object;\n+        return opt;\n     }\n     \n-    public <E extends Enum<E>> E getEnum(final Class<E> clazz, final String key) throws JSONException {\n-        final E val = (E)this.optEnum((Class<Enum>)clazz, key);\n-        if (val == null) {\n-            throw wrongValueFormatException(key, \"enum of type \" + quote(clazz.getSimpleName()), null);\n+    public <E extends Enum<E>> E getEnum(final Class<E> clazz, final String s) throws JSONException {\n+        final Enum optEnum = this.optEnum((Class<Enum>)clazz, s);\n+        if (optEnum == null) {\n+            throw wrongValueFormatException(s, \"enum of type \" + quote(clazz.getSimpleName()), null);\n         }\n-        return val;\n+        return (E)optEnum;\n     }\n     \n-    public boolean getBoolean(final String key) throws JSONException {\n-        final Object object = this.get(key);\n-        if (object.equals(Boolean.FALSE) || (object instanceof String && ((String)object).equalsIgnoreCase(\"false\"))) {\n+    public boolean getBoolean(final String s) throws JSONException {\n+        final Object value = this.get(s);\n+        if (value.equals(Boolean.FALSE) || (value instanceof String && ((String)value).equalsIgnoreCase(\"false\"))) {\n             return false;\n         }\n-        if (object.equals(Boolean.TRUE) || (object instanceof String && ((String)object).equalsIgnoreCase(\"true\"))) {\n+        if (value.equals(Boolean.TRUE) || (value instanceof String && ((String)value).equalsIgnoreCase(\"true\"))) {\n             return true;\n         }\n-        throw wrongValueFormatException(key, \"Boolean\", null);\n+        throw wrongValueFormatException(s, \"Boolean\", null);\n     }\n     \n-    public BigInteger getBigInteger(final String key) throws JSONException {\n-        final Object object = this.get(key);\n-        final BigInteger ret = objectToBigInteger(object, null);\n-        if (ret != null) {\n-            return ret;\n+    public BigInteger getBigInteger(final String s) throws JSONException {\n+        final Object value = this.get(s);\n+        final BigInteger objectToBigInteger = objectToBigInteger(value, null);\n+        if (objectToBigInteger != null) {\n+            return objectToBigInteger;\n         }\n-        throw wrongValueFormatException(key, \"BigInteger\", object, null);\n+        throw wrongValueFormatException(s, \"BigInteger\", value, null);\n     }\n     \n-    public BigDecimal getBigDecimal(final String key) throws JSONException {\n-        final Object object = this.get(key);\n-        final BigDecimal ret = objectToBigDecimal(object, null);\n-        if (ret != null) {\n-            return ret;\n+    public BigDecimal getBigDecimal(final String s) throws JSONException {\n+        final Object value = this.get(s);\n+        final BigDecimal objectToBigDecimal = objectToBigDecimal(value, null);\n+        if (objectToBigDecimal != null) {\n+            return objectToBigDecimal;\n         }\n-        throw wrongValueFormatException(key, \"BigDecimal\", object, null);\n+        throw wrongValueFormatException(s, \"BigDecimal\", value, null);\n     }\n     \n-    public double getDouble(final String key) throws JSONException {\n-        final Object object = this.get(key);\n-        if (object instanceof Number) {\n-            return ((Number)object).doubleValue();\n+    public double getDouble(final String s) throws JSONException {\n+        final Object value = this.get(s);\n+        if (value instanceof Number) {\n+            return ((Number)value).doubleValue();\n         }\n         try {\n-            return Double.parseDouble(object.toString());\n+            return Double.parseDouble(value.toString());\n         }\n-        catch (final Exception e) {\n-            throw wrongValueFormatException(key, \"double\", e);\n+        catch (final Exception ex) {\n+            throw wrongValueFormatException(s, \"double\", ex);\n         }\n     }\n     \n-    public float getFloat(final String key) throws JSONException {\n-        final Object object = this.get(key);\n-        if (object instanceof Number) {\n-            return ((Number)object).floatValue();\n+    public float getFloat(final String s) throws JSONException {\n+        final Object value = this.get(s);\n+        if (value instanceof Number) {\n+            return ((Number)value).floatValue();\n         }\n         try {\n-            return Float.parseFloat(object.toString());\n+            return Float.parseFloat(value.toString());\n         }\n-        catch (final Exception e) {\n-            throw wrongValueFormatException(key, \"float\", e);\n+        catch (final Exception ex) {\n+            throw wrongValueFormatException(s, \"float\", ex);\n         }\n     }\n     \n-    public Number getNumber(final String key) throws JSONException {\n-        final Object object = this.get(key);\n+    public Number getNumber(final String s) throws JSONException {\n+        final Object value = this.get(s);\n         try {\n-            if (object instanceof Number) {\n-                return (Number)object;\n+            if (value instanceof Number) {\n+                return (Number)value;\n             }\n-            return stringToNumber(object.toString());\n+            return stringToNumber(value.toString());\n         }\n-        catch (final Exception e) {\n-            throw wrongValueFormatException(key, \"number\", e);\n+        catch (final Exception ex) {\n+            throw wrongValueFormatException(s, \"number\", ex);\n         }\n     }\n     \n-    public int getInt(final String key) throws JSONException {\n-        final Object object = this.get(key);\n-        if (object instanceof Number) {\n-            return ((Number)object).intValue();\n+    public int getInt(final String s) throws JSONException {\n+        final Object value = this.get(s);\n+        if (value instanceof Number) {\n+            return ((Number)value).intValue();\n         }\n         try {\n-            return Integer.parseInt(object.toString());\n+            return Integer.parseInt(value.toString());\n         }\n-        catch (final Exception e) {\n-            throw wrongValueFormatException(key, \"int\", e);\n+        catch (final Exception ex) {\n+            throw wrongValueFormatException(s, \"int\", ex);\n         }\n     }\n     \n-    public JSONArray getJSONArray(final String key) throws JSONException {\n-        final Object object = this.get(key);\n-        if (object instanceof JSONArray) {\n-            return (JSONArray)object;\n+    public JSONArray getJSONArray(final String s) throws JSONException {\n+        final Object value = this.get(s);\n+        if (value instanceof JSONArray) {\n+            return (JSONArray)value;\n         }\n-        throw wrongValueFormatException(key, \"JSONArray\", null);\n+        throw wrongValueFormatException(s, \"JSONArray\", null);\n     }\n     \n-    public JSONObject getJSONObject(final String key) throws JSONException {\n-        final Object object = this.get(key);\n-        if (object instanceof JSONObject) {\n-            return (JSONObject)object;\n+    public JSONObject getJSONObject(final String s) throws JSONException {\n+        final Object value = this.get(s);\n+        if (value instanceof JSONObject) {\n+            return (JSONObject)value;\n         }\n-        throw wrongValueFormatException(key, \"JSONObject\", null);\n+        throw wrongValueFormatException(s, \"JSONObject\", null);\n     }\n     \n-    public long getLong(final String key) throws JSONException {\n-        final Object object = this.get(key);\n-        if (object instanceof Number) {\n-            return ((Number)object).longValue();\n+    public long getLong(final String s) throws JSONException {\n+        final Object value = this.get(s);\n+        if (value instanceof Number) {\n+            return ((Number)value).longValue();\n         }\n         try {\n-            return Long.parseLong(object.toString());\n+            return Long.parseLong(value.toString());\n         }\n-        catch (final Exception e) {\n-            throw wrongValueFormatException(key, \"long\", e);\n+        catch (final Exception ex) {\n+            throw wrongValueFormatException(s, \"long\", ex);\n         }\n     }\n     \n-    public static String[] getNames(final JSONObject jo) {\n-        if (jo.isEmpty()) {\n+    public static String[] getNames(final JSONObject jsonObject) {\n+        if (jsonObject.isEmpty()) {\n             return null;\n         }\n-        return jo.keySet().toArray(new String[jo.length()]);\n+        return jsonObject.keySet().toArray(new String[jsonObject.length()]);\n     }\n     \n-    public static String[] getNames(final Object object) {\n-        if (object == null) {\n+    public static String[] getNames(final Object o) {\n+        if (o == null) {\n             return null;\n         }\n-        final Class<?> klass = object.getClass();\n-        final Field[] fields = klass.getFields();\n+        final Field[] fields = o.getClass().getFields();\n         final int length = fields.length;\n         if (length == 0) {\n             return null;\n         }\n-        final String[] names = new String[length];\n+        final String[] array = new String[length];\n         for (int i = 0; i < length; ++i) {\n-            names[i] = fields[i].getName();\n+            array[i] = fields[i].getName();\n         }\n-        return names;\n+        return array;\n     }\n     \n-    public String getString(final String key) throws JSONException {\n-        final Object object = this.get(key);\n-        if (object instanceof String) {\n-            return (String)object;\n+    public String getString(final String s) throws JSONException {\n+        final Object value = this.get(s);\n+        if (value instanceof String) {\n+            return (String)value;\n         }\n-        throw wrongValueFormatException(key, \"string\", null);\n+        throw wrongValueFormatException(s, \"string\", null);\n     }\n     \n-    public boolean has(final String key) {\n-        return this.map.containsKey(key);\n+    public boolean has(final String s) {\n+        return this.map.containsKey(s);\n     }\n     \n-    public JSONObject increment(final String key) throws JSONException {\n-        final Object value = this.opt(key);\n-        if (value == null) {\n-            this.put(key, 1);\n+    public JSONObject increment(final String s) throws JSONException {\n+        final Object opt = this.opt(s);\n+        if (opt == null) {\n+            this.put(s, 1);\n         }\n-        else if (value instanceof Integer) {\n-            this.put(key, (int)value + 1);\n+        else if (opt instanceof Integer) {\n+            this.put(s, (int)opt + 1);\n         }\n-        else if (value instanceof Long) {\n-            this.put(key, (long)value + 1L);\n+        else if (opt instanceof Long) {\n+            this.put(s, (long)opt + 1L);\n         }\n-        else if (value instanceof BigInteger) {\n-            this.put(key, ((BigInteger)value).add(BigInteger.ONE));\n+        else if (opt instanceof BigInteger) {\n+            this.put(s, ((BigInteger)opt).add(BigInteger.ONE));\n         }\n-        else if (value instanceof Float) {\n-            this.put(key, (float)value + 1.0f);\n+        else if (opt instanceof Float) {\n+            this.put(s, (float)opt + 1.0f);\n         }\n-        else if (value instanceof Double) {\n-            this.put(key, (double)value + 1.0);\n+        else if (opt instanceof Double) {\n+            this.put(s, (double)opt + 1.0);\n         }\n         else {\n-            if (!(value instanceof BigDecimal)) {\n-                throw new JSONException(\"Unable to increment [\" + quote(key) + \"].\");\n+            if (!(opt instanceof BigDecimal)) {\n+                throw new JSONException(\"Unable to increment [\" + quote(s) + \"].\");\n             }\n-            this.put(key, ((BigDecimal)value).add(BigDecimal.ONE));\n+            this.put(s, ((BigDecimal)opt).add(BigDecimal.ONE));\n         }\n         return this;\n     }\n     \n-    public boolean isNull(final String key) {\n-        return JSONObject.NULL.equals(this.opt(key));\n+    public boolean isNull(final String s) {\n+        return JSONObject.NULL.equals(this.opt(s));\n     }\n     \n     public Iterator<String> keys() {\n         return this.keySet().iterator();\n     }\n     \n     public Set<String> keySet() {\n@@ -439,929 +436,914 @@\n     public JSONArray names() {\n         if (this.map.isEmpty()) {\n             return null;\n         }\n         return new JSONArray((Collection)this.map.keySet());\n     }\n     \n-    public static String numberToString(final Number number) throws JSONException {\n-        if (number == null) {\n+    public static String numberToString(final Number n) throws JSONException {\n+        if (n == null) {\n             throw new JSONException(\"Null pointer\");\n         }\n-        testValidity(number);\n-        String string = number.toString();\n-        if (string.indexOf(46) > 0 && string.indexOf(101) < 0 && string.indexOf(69) < 0) {\n-            while (string.endsWith(\"0\")) {\n-                string = string.substring(0, string.length() - 1);\n+        testValidity(n);\n+        String s = n.toString();\n+        if (s.indexOf(46) > 0 && s.indexOf(101) < 0 && s.indexOf(69) < 0) {\n+            while (s.endsWith(\"0\")) {\n+                s = s.substring(0, s.length() - 1);\n             }\n-            if (string.endsWith(\".\")) {\n-                string = string.substring(0, string.length() - 1);\n+            if (s.endsWith(\".\")) {\n+                s = s.substring(0, s.length() - 1);\n             }\n         }\n-        return string;\n+        return s;\n     }\n     \n-    public Object opt(final String key) {\n-        return (key == null) ? null : this.map.get(key);\n+    public Object opt(final String s) {\n+        return (s == null) ? null : this.map.get(s);\n     }\n     \n-    public <E extends Enum<E>> E optEnum(final Class<E> clazz, final String key) {\n-        return this.optEnum(clazz, key, (E)null);\n+    public <E extends Enum<E>> E optEnum(final Class<E> clazz, final String s) {\n+        return this.optEnum(clazz, s, (E)null);\n     }\n     \n-    public <E extends Enum<E>> E optEnum(final Class<E> clazz, final String key, final E defaultValue) {\n+    public <E extends Enum<E>> E optEnum(final Class<E> enumClass, final String s, final E e) {\n         try {\n-            final Object val = this.opt(key);\n-            if (JSONObject.NULL.equals(val)) {\n-                return defaultValue;\n+            final Object opt = this.opt(s);\n+            if (JSONObject.NULL.equals(opt)) {\n+                return e;\n             }\n-            if (clazz.isAssignableFrom(val.getClass())) {\n-                final E myE = (E)val;\n-                return myE;\n+            if (enumClass.isAssignableFrom(((Enum<E>)opt).getClass())) {\n+                return (E)opt;\n             }\n-            return Enum.valueOf(clazz, val.toString());\n+            return Enum.valueOf(enumClass, opt.toString());\n         }\n-        catch (final IllegalArgumentException e) {\n-            return defaultValue;\n+        catch (final IllegalArgumentException ex) {\n+            return e;\n         }\n-        catch (final NullPointerException e2) {\n-            return defaultValue;\n+        catch (final NullPointerException ex2) {\n+            return e;\n         }\n     }\n     \n-    public boolean optBoolean(final String key) {\n-        return this.optBoolean(key, false);\n+    public boolean optBoolean(final String s) {\n+        return this.optBoolean(s, false);\n     }\n     \n-    public boolean optBoolean(final String key, final boolean defaultValue) {\n-        final Object val = this.opt(key);\n-        if (JSONObject.NULL.equals(val)) {\n-            return defaultValue;\n+    public boolean optBoolean(final String s, final boolean b) {\n+        final Object opt = this.opt(s);\n+        if (JSONObject.NULL.equals(opt)) {\n+            return b;\n         }\n-        if (val instanceof Boolean) {\n-            return (boolean)val;\n+        if (opt instanceof Boolean) {\n+            return (boolean)opt;\n         }\n         try {\n-            return this.getBoolean(key);\n+            return this.getBoolean(s);\n         }\n-        catch (final Exception e) {\n-            return defaultValue;\n+        catch (final Exception ex) {\n+            return b;\n         }\n     }\n     \n-    public BigDecimal optBigDecimal(final String key, final BigDecimal defaultValue) {\n-        final Object val = this.opt(key);\n-        return objectToBigDecimal(val, defaultValue);\n+    public BigDecimal optBigDecimal(final String s, final BigDecimal bigDecimal) {\n+        return objectToBigDecimal(this.opt(s), bigDecimal);\n     }\n     \n-    static BigDecimal objectToBigDecimal(final Object val, final BigDecimal defaultValue) {\n-        return objectToBigDecimal(val, defaultValue, true);\n+    static BigDecimal objectToBigDecimal(final Object o, final BigDecimal bigDecimal) {\n+        return objectToBigDecimal(o, bigDecimal, true);\n     }\n     \n-    static BigDecimal objectToBigDecimal(final Object val, final BigDecimal defaultValue, final boolean exact) {\n-        if (JSONObject.NULL.equals(val)) {\n-            return defaultValue;\n+    static BigDecimal objectToBigDecimal(final Object obj, final BigDecimal bigDecimal, final boolean b) {\n+        if (JSONObject.NULL.equals(obj)) {\n+            return bigDecimal;\n         }\n-        if (val instanceof BigDecimal) {\n-            return (BigDecimal)val;\n+        if (obj instanceof BigDecimal) {\n+            return (BigDecimal)obj;\n         }\n-        if (val instanceof BigInteger) {\n-            return new BigDecimal((BigInteger)val);\n+        if (obj instanceof BigInteger) {\n+            return new BigDecimal((BigInteger)obj);\n         }\n-        if (val instanceof Double || val instanceof Float) {\n-            if (!numberIsFinite((Number)val)) {\n-                return defaultValue;\n+        if (obj instanceof Double || obj instanceof Float) {\n+            if (!numberIsFinite((Number)obj)) {\n+                return bigDecimal;\n             }\n-            if (exact) {\n-                return new BigDecimal(((Number)val).doubleValue());\n+            if (b) {\n+                return new BigDecimal(((Number)obj).doubleValue());\n             }\n-            return new BigDecimal(val.toString());\n+            return new BigDecimal(obj.toString());\n         }\n         else {\n-            if (val instanceof Long || val instanceof Integer || val instanceof Short || val instanceof Byte) {\n-                return new BigDecimal(((Number)val).longValue());\n+            if (obj instanceof Long || obj instanceof Integer || obj instanceof Short || obj instanceof Byte) {\n+                return new BigDecimal(((Number)obj).longValue());\n             }\n             try {\n-                return new BigDecimal(val.toString());\n+                return new BigDecimal(obj.toString());\n             }\n-            catch (final Exception e) {\n-                return defaultValue;\n+            catch (final Exception ex) {\n+                return bigDecimal;\n             }\n         }\n     }\n     \n-    public BigInteger optBigInteger(final String key, final BigInteger defaultValue) {\n-        final Object val = this.opt(key);\n-        return objectToBigInteger(val, defaultValue);\n+    public BigInteger optBigInteger(final String s, final BigInteger bigInteger) {\n+        return objectToBigInteger(this.opt(s), bigInteger);\n     }\n     \n-    static BigInteger objectToBigInteger(final Object val, final BigInteger defaultValue) {\n-        if (JSONObject.NULL.equals(val)) {\n-            return defaultValue;\n+    static BigInteger objectToBigInteger(final Object obj, final BigInteger bigInteger) {\n+        if (JSONObject.NULL.equals(obj)) {\n+            return bigInteger;\n         }\n-        if (val instanceof BigInteger) {\n-            return (BigInteger)val;\n+        if (obj instanceof BigInteger) {\n+            return (BigInteger)obj;\n         }\n-        if (val instanceof BigDecimal) {\n-            return ((BigDecimal)val).toBigInteger();\n+        if (obj instanceof BigDecimal) {\n+            return ((BigDecimal)obj).toBigInteger();\n         }\n-        if (val instanceof Double || val instanceof Float) {\n-            if (!numberIsFinite((Number)val)) {\n-                return defaultValue;\n+        if (obj instanceof Double || obj instanceof Float) {\n+            if (!numberIsFinite((Number)obj)) {\n+                return bigInteger;\n             }\n-            return new BigDecimal(((Number)val).doubleValue()).toBigInteger();\n+            return new BigDecimal(((Number)obj).doubleValue()).toBigInteger();\n         }\n         else {\n-            if (val instanceof Long || val instanceof Integer || val instanceof Short || val instanceof Byte) {\n-                return BigInteger.valueOf(((Number)val).longValue());\n+            if (obj instanceof Long || obj instanceof Integer || obj instanceof Short || obj instanceof Byte) {\n+                return BigInteger.valueOf(((Number)obj).longValue());\n             }\n             try {\n-                final String valStr = val.toString();\n-                if (isDecimalNotation(valStr)) {\n-                    return new BigDecimal(valStr).toBigInteger();\n+                final String string = obj.toString();\n+                if (isDecimalNotation(string)) {\n+                    return new BigDecimal(string).toBigInteger();\n                 }\n-                return new BigInteger(valStr);\n+                return new BigInteger(string);\n             }\n-            catch (final Exception e) {\n-                return defaultValue;\n+            catch (final Exception ex) {\n+                return bigInteger;\n             }\n         }\n     }\n     \n-    public double optDouble(final String key) {\n-        return this.optDouble(key, Double.NaN);\n+    public double optDouble(final String s) {\n+        return this.optDouble(s, Double.NaN);\n     }\n     \n-    public double optDouble(final String key, final double defaultValue) {\n-        final Number val = this.optNumber(key);\n-        if (val == null) {\n-            return defaultValue;\n+    public double optDouble(final String s, final double n) {\n+        final Number optNumber = this.optNumber(s);\n+        if (optNumber == null) {\n+            return n;\n         }\n-        final double doubleValue = val.doubleValue();\n-        return doubleValue;\n+        return optNumber.doubleValue();\n     }\n     \n-    public float optFloat(final String key) {\n-        return this.optFloat(key, Float.NaN);\n+    public float optFloat(final String s) {\n+        return this.optFloat(s, Float.NaN);\n     }\n     \n-    public float optFloat(final String key, final float defaultValue) {\n-        final Number val = this.optNumber(key);\n-        if (val == null) {\n-            return defaultValue;\n+    public float optFloat(final String s, final float n) {\n+        final Number optNumber = this.optNumber(s);\n+        if (optNumber == null) {\n+            return n;\n         }\n-        final float floatValue = val.floatValue();\n-        return floatValue;\n+        return optNumber.floatValue();\n     }\n     \n-    public int optInt(final String key) {\n-        return this.optInt(key, 0);\n+    public int optInt(final String s) {\n+        return this.optInt(s, 0);\n     }\n     \n-    public int optInt(final String key, final int defaultValue) {\n-        final Number val = this.optNumber(key, null);\n-        if (val == null) {\n-            return defaultValue;\n+    public int optInt(final String s, final int n) {\n+        final Number optNumber = this.optNumber(s, null);\n+        if (optNumber == null) {\n+            return n;\n         }\n-        return val.intValue();\n+        return optNumber.intValue();\n     }\n     \n-    public JSONArray optJSONArray(final String key) {\n-        final Object o = this.opt(key);\n-        return (o instanceof JSONArray) ? ((JSONArray)o) : null;\n+    public JSONArray optJSONArray(final String s) {\n+        final Object opt = this.opt(s);\n+        return (opt instanceof JSONArray) ? ((JSONArray)opt) : null;\n     }\n     \n-    public JSONObject optJSONObject(final String key) {\n-        return this.optJSONObject(key, null);\n+    public JSONObject optJSONObject(final String s) {\n+        return this.optJSONObject(s, null);\n     }\n     \n-    public JSONObject optJSONObject(final String key, final JSONObject defaultValue) {\n-        final Object object = this.opt(key);\n-        return (object instanceof JSONObject) ? ((JSONObject)object) : defaultValue;\n+    public JSONObject optJSONObject(final String s, final JSONObject jsonObject) {\n+        final Object opt = this.opt(s);\n+        return (opt instanceof JSONObject) ? ((JSONObject)opt) : jsonObject;\n     }\n     \n-    public long optLong(final String key) {\n-        return this.optLong(key, 0L);\n+    public long optLong(final String s) {\n+        return this.optLong(s, 0L);\n     }\n     \n-    public long optLong(final String key, final long defaultValue) {\n-        final Number val = this.optNumber(key, null);\n-        if (val == null) {\n-            return defaultValue;\n+    public long optLong(final String s, final long n) {\n+        final Number optNumber = this.optNumber(s, null);\n+        if (optNumber == null) {\n+            return n;\n         }\n-        return val.longValue();\n+        return optNumber.longValue();\n     }\n     \n-    public Number optNumber(final String key) {\n-        return this.optNumber(key, null);\n+    public Number optNumber(final String s) {\n+        return this.optNumber(s, null);\n     }\n     \n-    public Number optNumber(final String key, final Number defaultValue) {\n-        final Object val = this.opt(key);\n-        if (JSONObject.NULL.equals(val)) {\n-            return defaultValue;\n+    public Number optNumber(final String s, final Number n) {\n+        final Object opt = this.opt(s);\n+        if (JSONObject.NULL.equals(opt)) {\n+            return n;\n         }\n-        if (val instanceof Number) {\n-            return (Number)val;\n+        if (opt instanceof Number) {\n+            return (Number)opt;\n         }\n         try {\n-            return stringToNumber(val.toString());\n+            return stringToNumber(opt.toString());\n         }\n-        catch (final Exception e) {\n-            return defaultValue;\n+        catch (final Exception ex) {\n+            return n;\n         }\n     }\n     \n-    public String optString(final String key) {\n-        return this.optString(key, \"\");\n+    public String optString(final String s) {\n+        return this.optString(s, \"\");\n     }\n     \n-    public String optString(final String key, final String defaultValue) {\n-        final Object object = this.opt(key);\n-        return JSONObject.NULL.equals(object) ? defaultValue : object.toString();\n+    public String optString(final String s, final String s2) {\n+        final Object opt = this.opt(s);\n+        return JSONObject.NULL.equals(opt) ? s2 : opt.toString();\n     }\n     \n-    private void populateMap(final Object bean) {\n-        this.populateMap(bean, Collections.newSetFromMap((Map<Object, Boolean>)new IdentityHashMap<Object, Boolean>()));\n+    private void populateMap(final Object o) {\n+        this.populateMap(o, Collections.newSetFromMap((Map<Object, Boolean>)new IdentityHashMap<Object, Boolean>()));\n     }\n     \n-    private void populateMap(final Object bean, final Set<Object> objectsRecord) {\n-        final Class<?> klass = bean.getClass();\n-        final boolean includeSuperClass = klass.getClassLoader() != null;\n-        final Method[] array;\n-        final Method[] methods = array = (includeSuperClass ? klass.getMethods() : klass.getDeclaredMethods());\n-        for (final Method method : array) {\n+    private void populateMap(final Object obj, final Set<Object> set) {\n+        final Class<?> class1 = obj.getClass();\n+        for (final Method method : (class1.getClassLoader() != null) ? class1.getMethods() : class1.getDeclaredMethods()) {\n             final int modifiers = method.getModifiers();\n             if (Modifier.isPublic(modifiers) && !Modifier.isStatic(modifiers) && method.getParameterTypes().length == 0 && !method.isBridge() && method.getReturnType() != Void.TYPE && isValidMethodName(method.getName())) {\n-                final String key = getKeyNameFromMethod(method);\n-                if (key != null && !key.isEmpty()) {\n+                final String keyNameFromMethod = getKeyNameFromMethod(method);\n+                if (keyNameFromMethod != null && !keyNameFromMethod.isEmpty()) {\n                     try {\n-                        final Object result = method.invoke(bean, new Object[0]);\n-                        if (result != null) {\n-                            if (objectsRecord.contains(result)) {\n-                                throw recursivelyDefinedObjectException(key);\n+                        final Object invoke = method.invoke(obj, new Object[0]);\n+                        if (invoke != null) {\n+                            if (set.contains(invoke)) {\n+                                throw recursivelyDefinedObjectException(keyNameFromMethod);\n                             }\n-                            objectsRecord.add(result);\n-                            this.map.put(key, wrap(result, objectsRecord));\n-                            objectsRecord.remove(result);\n-                            if (result instanceof Closeable) {\n+                            set.add(invoke);\n+                            this.map.put(keyNameFromMethod, wrap(invoke, set));\n+                            set.remove(invoke);\n+                            if (invoke instanceof Closeable) {\n                                 try {\n-                                    ((Closeable)result).close();\n+                                    ((Closeable)invoke).close();\n                                 }\n                                 catch (final IOException ex) {}\n                             }\n                         }\n                     }\n                     catch (final IllegalAccessException ex2) {}\n                     catch (final IllegalArgumentException ex3) {}\n                     catch (final InvocationTargetException ex4) {}\n                 }\n             }\n         }\n     }\n     \n-    private static boolean isValidMethodName(final String name) {\n-        return !\"getClass\".equals(name) && !\"getDeclaringClass\".equals(name);\n+    private static boolean isValidMethodName(final String s) {\n+        return !\"getClass\".equals(s) && !\"getDeclaringClass\".equals(s);\n     }\n     \n     private static String getKeyNameFromMethod(final Method method) {\n-        final int ignoreDepth = getAnnotationDepth(method, (Class<? extends Annotation>)JSONPropertyIgnore.class);\n-        if (ignoreDepth > 0) {\n-            final int forcedNameDepth = getAnnotationDepth(method, (Class<? extends Annotation>)JSONPropertyName.class);\n-            if (forcedNameDepth < 0 || ignoreDepth <= forcedNameDepth) {\n+        final int annotationDepth = getAnnotationDepth(method, (Class<? extends Annotation>)JSONPropertyIgnore.class);\n+        if (annotationDepth > 0) {\n+            final int annotationDepth2 = getAnnotationDepth(method, (Class<? extends Annotation>)JSONPropertyName.class);\n+            if (annotationDepth2 < 0 || annotationDepth <= annotationDepth2) {\n                 return null;\n             }\n         }\n-        final JSONPropertyName annotation = (JSONPropertyName)getAnnotation(method, JSONPropertyName.class);\n-        if (annotation != null && annotation.value() != null && !annotation.value().isEmpty()) {\n-            return annotation.value();\n+        final JSONPropertyName jsonPropertyName = (JSONPropertyName)getAnnotation(method, JSONPropertyName.class);\n+        if (jsonPropertyName != null && jsonPropertyName.value() != null && !jsonPropertyName.value().isEmpty()) {\n+            return jsonPropertyName.value();\n         }\n         final String name = method.getName();\n-        String key;\n+        String s;\n         if (name.startsWith(\"get\") && name.length() > 3) {\n-            key = name.substring(3);\n+            s = name.substring(3);\n         }\n         else {\n             if (!name.startsWith(\"is\") || name.length() <= 2) {\n                 return null;\n             }\n-            key = name.substring(2);\n+            s = name.substring(2);\n         }\n-        if (key.length() == 0 || Character.isLowerCase(key.charAt(0))) {\n+        if (s.length() == 0 || Character.isLowerCase(s.charAt(0))) {\n             return null;\n         }\n-        if (key.length() == 1) {\n-            key = key.toLowerCase(Locale.ROOT);\n+        if (s.length() == 1) {\n+            s = s.toLowerCase(Locale.ROOT);\n         }\n-        else if (!Character.isUpperCase(key.charAt(1))) {\n-            key = key.substring(0, 1).toLowerCase(Locale.ROOT) + key.substring(1);\n+        else if (!Character.isUpperCase(s.charAt(1))) {\n+            s = s.substring(0, 1).toLowerCase(Locale.ROOT) + s.substring(1);\n         }\n-        return key;\n+        return s;\n     }\n     \n-    private static <A extends Annotation> A getAnnotation(final Method m, final Class<A> annotationClass) {\n-        if (m == null || annotationClass == null) {\n+    private static <A extends Annotation> A getAnnotation(final Method method, final Class<A> clazz) {\n+        if (method == null || clazz == null) {\n             return null;\n         }\n-        if (m.isAnnotationPresent(annotationClass)) {\n-            return m.getAnnotation(annotationClass);\n+        if (method.isAnnotationPresent(clazz)) {\n+            return method.getAnnotation(clazz);\n         }\n-        final Class<?> c = m.getDeclaringClass();\n-        if (c.getSuperclass() == null) {\n+        final Class<?> declaringClass = method.getDeclaringClass();\n+        if (declaringClass.getSuperclass() == null) {\n             return null;\n         }\n-        for (final Class<?> i : c.getInterfaces()) {\n+        for (final Class clazz2 : declaringClass.getInterfaces()) {\n             try {\n-                final Method im = i.getMethod(m.getName(), m.getParameterTypes());\n-                return (A)getAnnotation(im, (Class<Annotation>)annotationClass);\n+                return (A)getAnnotation(clazz2.getMethod(method.getName(), (Class[])method.getParameterTypes()), (Class<Annotation>)clazz);\n             }\n             catch (final SecurityException ex) {}\n             catch (final NoSuchMethodException ex2) {}\n         }\n         try {\n-            return (A)getAnnotation(c.getSuperclass().getMethod(m.getName(), m.getParameterTypes()), (Class<Annotation>)annotationClass);\n+            return (A)getAnnotation(declaringClass.getSuperclass().getMethod(method.getName(), (Class[])method.getParameterTypes()), (Class<Annotation>)clazz);\n         }\n         catch (final SecurityException ex3) {\n             return null;\n         }\n         catch (final NoSuchMethodException ex4) {\n             return null;\n         }\n     }\n     \n-    private static int getAnnotationDepth(final Method m, final Class<? extends Annotation> annotationClass) {\n-        if (m == null || annotationClass == null) {\n+    private static int getAnnotationDepth(final Method method, final Class<? extends Annotation> annotationClass) {\n+        if (method == null || annotationClass == null) {\n             return -1;\n         }\n-        if (m.isAnnotationPresent(annotationClass)) {\n+        if (method.isAnnotationPresent(annotationClass)) {\n             return 1;\n         }\n-        final Class<?> c = m.getDeclaringClass();\n-        if (c.getSuperclass() == null) {\n+        final Class<?> declaringClass = method.getDeclaringClass();\n+        if (declaringClass.getSuperclass() == null) {\n             return -1;\n         }\n-        for (final Class<?> i : c.getInterfaces()) {\n+        for (final Class clazz : declaringClass.getInterfaces()) {\n             try {\n-                final Method im = i.getMethod(m.getName(), m.getParameterTypes());\n-                final int d = getAnnotationDepth(im, annotationClass);\n-                if (d > 0) {\n-                    return d + 1;\n+                final int annotationDepth = getAnnotationDepth(clazz.getMethod(method.getName(), (Class[])method.getParameterTypes()), annotationClass);\n+                if (annotationDepth > 0) {\n+                    return annotationDepth + 1;\n                 }\n             }\n             catch (final SecurityException ex) {}\n             catch (final NoSuchMethodException ex2) {}\n         }\n         try {\n-            final int d2 = getAnnotationDepth(c.getSuperclass().getMethod(m.getName(), m.getParameterTypes()), annotationClass);\n-            if (d2 > 0) {\n-                return d2 + 1;\n+            final int annotationDepth2 = getAnnotationDepth(declaringClass.getSuperclass().getMethod(method.getName(), (Class[])method.getParameterTypes()), annotationClass);\n+            if (annotationDepth2 > 0) {\n+                return annotationDepth2 + 1;\n             }\n             return -1;\n         }\n         catch (final SecurityException ex3) {\n             return -1;\n         }\n         catch (final NoSuchMethodException ex4) {\n             return -1;\n         }\n     }\n     \n-    public JSONObject put(final String key, final boolean value) throws JSONException {\n-        return this.put(key, value ? Boolean.TRUE : Boolean.FALSE);\n+    public JSONObject put(final String s, final boolean b) throws JSONException {\n+        return this.put(s, b ? Boolean.TRUE : Boolean.FALSE);\n     }\n     \n-    public JSONObject put(final String key, final Collection<?> value) throws JSONException {\n-        return this.put(key, new JSONArray((Collection)value));\n+    public JSONObject put(final String s, final Collection<?> collection) throws JSONException {\n+        return this.put(s, new JSONArray((Collection)collection));\n     }\n     \n-    public JSONObject put(final String key, final double value) throws JSONException {\n-        return this.put(key, Double.valueOf(value));\n+    public JSONObject put(final String s, final double d) throws JSONException {\n+        return this.put(s, Double.valueOf(d));\n     }\n     \n-    public JSONObject put(final String key, final float value) throws JSONException {\n-        return this.put(key, Float.valueOf(value));\n+    public JSONObject put(final String s, final float f) throws JSONException {\n+        return this.put(s, Float.valueOf(f));\n     }\n     \n-    public JSONObject put(final String key, final int value) throws JSONException {\n-        return this.put(key, Integer.valueOf(value));\n+    public JSONObject put(final String s, final int i) throws JSONException {\n+        return this.put(s, Integer.valueOf(i));\n     }\n     \n-    public JSONObject put(final String key, final long value) throws JSONException {\n-        return this.put(key, Long.valueOf(value));\n+    public JSONObject put(final String s, final long l) throws JSONException {\n+        return this.put(s, Long.valueOf(l));\n     }\n     \n-    public JSONObject put(final String key, final Map<?, ?> value) throws JSONException {\n-        return this.put(key, new JSONObject(value));\n+    public JSONObject put(final String s, final Map<?, ?> map) throws JSONException {\n+        return this.put(s, new JSONObject(map));\n     }\n     \n-    public JSONObject put(final String key, final Object value) throws JSONException {\n-        if (key == null) {\n+    public JSONObject put(final String s, final Object o) throws JSONException {\n+        if (s == null) {\n             throw new NullPointerException(\"Null key.\");\n         }\n-        if (value != null) {\n-            testValidity(value);\n-            this.map.put(key, value);\n+        if (o != null) {\n+            testValidity(o);\n+            this.map.put(s, o);\n         }\n         else {\n-            this.remove(key);\n+            this.remove(s);\n         }\n         return this;\n     }\n     \n-    public JSONObject putOnce(final String key, final Object value) throws JSONException {\n-        if (key == null || value == null) {\n+    public JSONObject putOnce(final String str, final Object o) throws JSONException {\n+        if (str == null || o == null) {\n             return this;\n         }\n-        if (this.opt(key) != null) {\n-            throw new JSONException(\"Duplicate key \\\"\" + key + \"\\\"\");\n+        if (this.opt(str) != null) {\n+            throw new JSONException(\"Duplicate key \\\"\" + str + \"\\\"\");\n         }\n-        return this.put(key, value);\n+        return this.put(str, o);\n     }\n     \n-    public JSONObject putOpt(final String key, final Object value) throws JSONException {\n-        if (key != null && value != null) {\n-            return this.put(key, value);\n+    public JSONObject putOpt(final String s, final Object o) throws JSONException {\n+        if (s != null && o != null) {\n+            return this.put(s, o);\n         }\n         return this;\n     }\n     \n-    public Object query(final String jsonPointer) {\n-        return this.query(new JSONPointer(jsonPointer));\n+    public Object query(final String s) {\n+        return this.query(new JSONPointer(s));\n     }\n     \n     public Object query(final JSONPointer jsonPointer) {\n         return jsonPointer.queryFrom((Object)this);\n     }\n     \n-    public Object optQuery(final String jsonPointer) {\n-        return this.optQuery(new JSONPointer(jsonPointer));\n+    public Object optQuery(final String s) {\n+        return this.optQuery(new JSONPointer(s));\n     }\n     \n     public Object optQuery(final JSONPointer jsonPointer) {\n         try {\n             return jsonPointer.queryFrom((Object)this);\n         }\n-        catch (final JSONPointerException e) {\n+        catch (final JSONPointerException ex) {\n             return null;\n         }\n     }\n     \n-    public static String quote(final String string) {\n-        final StringWriter sw = new StringWriter();\n-        synchronized (sw.getBuffer()) {\n+    public static String quote(final String s) {\n+        final StringWriter stringWriter = new StringWriter();\n+        synchronized (stringWriter.getBuffer()) {\n             try {\n-                return quote(string, sw).toString();\n+                return quote(s, stringWriter).toString();\n             }\n-            catch (final IOException ignored) {\n+            catch (final IOException ex) {\n                 return \"\";\n             }\n         }\n     }\n     \n-    public static Writer quote(final String string, final Writer w) throws IOException {\n-        if (string == null || string.isEmpty()) {\n-            w.write(\"\\\"\\\"\");\n-            return w;\n-        }\n-        char c = '\\0';\n-        final int len = string.length();\n-        w.write(34);\n-        for (int i = 0; i < len; ++i) {\n-            final char b = c;\n-            c = string.charAt(i);\n-            switch (c) {\n-                case '\\\"':\n-                case '\\\\': {\n-                    w.write(92);\n-                    w.write(c);\n+    public static Writer quote(final String s, final Writer writer) throws IOException {\n+        if (s == null || s.isEmpty()) {\n+            writer.write(\"\\\"\\\"\");\n+            return writer;\n+        }\n+        int char1 = 0;\n+        final int length = s.length();\n+        writer.write(34);\n+        for (int i = 0; i < length; ++i) {\n+            final int n = char1;\n+            char1 = s.charAt(i);\n+            switch (char1) {\n+                case 34:\n+                case 92: {\n+                    writer.write(92);\n+                    writer.write(char1);\n                     break;\n                 }\n-                case '/': {\n-                    if (b == '<') {\n-                        w.write(92);\n+                case 47: {\n+                    if (n == 60) {\n+                        writer.write(92);\n                     }\n-                    w.write(c);\n+                    writer.write(char1);\n                     break;\n                 }\n-                case '\\b': {\n-                    w.write(\"\\\\b\");\n+                case 8: {\n+                    writer.write(\"\\\\b\");\n                     break;\n                 }\n-                case '\\t': {\n-                    w.write(\"\\\\t\");\n+                case 9: {\n+                    writer.write(\"\\\\t\");\n                     break;\n                 }\n-                case '\\n': {\n-                    w.write(\"\\\\n\");\n+                case 10: {\n+                    writer.write(\"\\\\n\");\n                     break;\n                 }\n-                case '\\f': {\n-                    w.write(\"\\\\f\");\n+                case 12: {\n+                    writer.write(\"\\\\f\");\n                     break;\n                 }\n-                case '\\r': {\n-                    w.write(\"\\\\r\");\n+                case 13: {\n+                    writer.write(\"\\\\r\");\n                     break;\n                 }\n                 default: {\n-                    if (c < ' ' || (c >= '\\u0080' && c < '\u00a0') || (c >= '\\u2000' && c < '\\u2100')) {\n-                        w.write(\"\\\\u\");\n-                        final String hhhh = Integer.toHexString(c);\n-                        w.write(\"0000\", 0, 4 - hhhh.length());\n-                        w.write(hhhh);\n+                    if (char1 < 32 || (char1 >= 128 && char1 < 160) || (char1 >= 8192 && char1 < 8448)) {\n+                        writer.write(\"\\\\u\");\n+                        final String hexString = Integer.toHexString(char1);\n+                        writer.write(\"0000\", 0, 4 - hexString.length());\n+                        writer.write(hexString);\n                         break;\n                     }\n-                    w.write(c);\n+                    writer.write(char1);\n                     break;\n                 }\n             }\n         }\n-        w.write(34);\n-        return w;\n+        writer.write(34);\n+        return writer;\n     }\n     \n-    public Object remove(final String key) {\n-        return this.map.remove(key);\n+    public Object remove(final String s) {\n+        return this.map.remove(s);\n     }\n     \n-    public boolean similar(final Object other) {\n+    public boolean similar(final Object o) {\n         try {\n-            if (!(other instanceof JSONObject)) {\n+            if (!(o instanceof JSONObject)) {\n                 return false;\n             }\n-            if (!this.keySet().equals(((JSONObject)other).keySet())) {\n+            if (!this.keySet().equals(((JSONObject)o).keySet())) {\n                 return false;\n             }\n-            for (final Map.Entry<String, ?> entry : this.entrySet()) {\n-                final String name = (String)entry.getKey();\n-                final Object valueThis = entry.getValue();\n-                final Object valueOther = ((JSONObject)other).get(name);\n-                if (valueThis == valueOther) {\n+            for (final Map.Entry entry : this.entrySet()) {\n+                final String s = (String)entry.getKey();\n+                final Object value = entry.getValue();\n+                final Object value2 = ((JSONObject)o).get(s);\n+                if (value == value2) {\n                     continue;\n                 }\n-                if (valueThis == null) {\n+                if (value == null) {\n                     return false;\n                 }\n-                if (valueThis instanceof JSONObject) {\n-                    if (!((JSONObject)valueThis).similar(valueOther)) {\n+                if (value instanceof JSONObject) {\n+                    if (!((JSONObject)value).similar(value2)) {\n                         return false;\n                     }\n                     continue;\n                 }\n-                else if (valueThis instanceof JSONArray) {\n-                    if (!((JSONArray)valueThis).similar(valueOther)) {\n+                else if (value instanceof JSONArray) {\n+                    if (!((JSONArray)value).similar(value2)) {\n                         return false;\n                     }\n                     continue;\n                 }\n-                else if (valueThis instanceof Number && valueOther instanceof Number) {\n-                    if (!isNumberSimilar((Number)valueThis, (Number)valueOther)) {\n+                else if (value instanceof Number && value2 instanceof Number) {\n+                    if (!isNumberSimilar((Number)value, (Number)value2)) {\n                         return false;\n                     }\n                     continue;\n                 }\n                 else {\n-                    if (!valueThis.equals(valueOther)) {\n+                    if (!value.equals(value2)) {\n                         return false;\n                     }\n                     continue;\n                 }\n             }\n             return true;\n         }\n-        catch (final Throwable exception) {\n+        catch (final Throwable t) {\n             return false;\n         }\n     }\n     \n-    static boolean isNumberSimilar(final Number l, final Number r) {\n-        if (!numberIsFinite(l) || !numberIsFinite(r)) {\n+    static boolean isNumberSimilar(final Number n, final Number n2) {\n+        if (!numberIsFinite(n) || !numberIsFinite(n2)) {\n             return false;\n         }\n-        if (l.getClass().equals(r.getClass()) && l instanceof Comparable) {\n-            final int compareTo = ((Comparable)l).compareTo(r);\n-            return compareTo == 0;\n-        }\n-        final BigDecimal lBigDecimal = objectToBigDecimal(l, null, false);\n-        final BigDecimal rBigDecimal = objectToBigDecimal(r, null, false);\n-        return lBigDecimal != null && rBigDecimal != null && lBigDecimal.compareTo(rBigDecimal) == 0;\n+        if (n.getClass().equals(n2.getClass()) && n instanceof Comparable) {\n+            return ((Comparable)n).compareTo(n2) == 0;\n+        }\n+        final BigDecimal objectToBigDecimal = objectToBigDecimal(n, null, false);\n+        final BigDecimal objectToBigDecimal2 = objectToBigDecimal(n2, null, false);\n+        return objectToBigDecimal != null && objectToBigDecimal2 != null && objectToBigDecimal.compareTo(objectToBigDecimal2) == 0;\n     }\n     \n     private static boolean numberIsFinite(final Number n) {\n         return (!(n instanceof Double) || (!((Double)n).isInfinite() && !((Double)n).isNaN())) && (!(n instanceof Float) || (!((Float)n).isInfinite() && !((Float)n).isNaN()));\n     }\n     \n-    protected static boolean isDecimalNotation(final String val) {\n-        return val.indexOf(46) > -1 || val.indexOf(101) > -1 || val.indexOf(69) > -1 || \"-0\".equals(val);\n+    protected static boolean isDecimalNotation(final String anObject) {\n+        return anObject.indexOf(46) > -1 || anObject.indexOf(101) > -1 || anObject.indexOf(69) > -1 || \"-0\".equals(anObject);\n     }\n     \n-    protected static Number stringToNumber(final String val) throws NumberFormatException {\n-        final char initial = val.charAt(0);\n-        if ((initial < '0' || initial > '9') && initial != '-') {\n-            throw new NumberFormatException(\"val [\" + val + \"] is not a valid number.\");\n+    protected static Number stringToNumber(final String s) throws NumberFormatException {\n+        final char char1 = s.charAt(0);\n+        if ((char1 < '0' || char1 > '9') && char1 != '-') {\n+            throw new NumberFormatException(\"val [\" + s + \"] is not a valid number.\");\n         }\n-        if (isDecimalNotation(val)) {\n+        if (isDecimalNotation(s)) {\n             try {\n-                final BigDecimal bd = new BigDecimal(val);\n-                if (initial == '-' && BigDecimal.ZERO.compareTo(bd) == 0) {\n+                final BigDecimal val = new BigDecimal(s);\n+                if (char1 == '-' && BigDecimal.ZERO.compareTo(val) == 0) {\n                     return Double.valueOf(-0.0);\n                 }\n-                return bd;\n+                return val;\n             }\n-            catch (final NumberFormatException retryAsDouble) {\n+            catch (final NumberFormatException ex) {\n                 try {\n-                    final Double d = Double.valueOf(val);\n-                    if (d.isNaN() || d.isInfinite()) {\n-                        throw new NumberFormatException(\"val [\" + val + \"] is not a valid number.\");\n+                    final Double value = Double.valueOf(s);\n+                    if (value.isNaN() || value.isInfinite()) {\n+                        throw new NumberFormatException(\"val [\" + s + \"] is not a valid number.\");\n                     }\n-                    return d;\n+                    return value;\n                 }\n-                catch (final NumberFormatException ignore) {\n-                    throw new NumberFormatException(\"val [\" + val + \"] is not a valid number.\");\n+                catch (final NumberFormatException ex2) {\n+                    throw new NumberFormatException(\"val [\" + s + \"] is not a valid number.\");\n                 }\n             }\n         }\n-        if (initial == '0' && val.length() > 1) {\n-            final char at1 = val.charAt(1);\n-            if (at1 >= '0' && at1 <= '9') {\n-                throw new NumberFormatException(\"val [\" + val + \"] is not a valid number.\");\n+        if (char1 == '0' && s.length() > 1) {\n+            final char char2 = s.charAt(1);\n+            if (char2 >= '0' && char2 <= '9') {\n+                throw new NumberFormatException(\"val [\" + s + \"] is not a valid number.\");\n             }\n         }\n-        else if (initial == '-' && val.length() > 2) {\n-            final char at1 = val.charAt(1);\n-            final char at2 = val.charAt(2);\n-            if (at1 == '0' && at2 >= '0' && at2 <= '9') {\n-                throw new NumberFormatException(\"val [\" + val + \"] is not a valid number.\");\n+        else if (char1 == '-' && s.length() > 2) {\n+            final char char3 = s.charAt(1);\n+            final char char4 = s.charAt(2);\n+            if (char3 == '0' && char4 >= '0' && char4 <= '9') {\n+                throw new NumberFormatException(\"val [\" + s + \"] is not a valid number.\");\n             }\n         }\n-        final BigInteger bi = new BigInteger(val);\n-        if (bi.bitLength() <= 31) {\n-            return Integer.valueOf(bi.intValue());\n+        final BigInteger bigInteger = new BigInteger(s);\n+        if (bigInteger.bitLength() <= 31) {\n+            return Integer.valueOf(bigInteger.intValue());\n         }\n-        if (bi.bitLength() <= 63) {\n-            return Long.valueOf(bi.longValue());\n+        if (bigInteger.bitLength() <= 63) {\n+            return Long.valueOf(bigInteger.longValue());\n         }\n-        return bi;\n+        return bigInteger;\n     }\n     \n-    public static Object stringToValue(final String string) {\n-        if (\"\".equals(string)) {\n-            return string;\n+    public static Object stringToValue(final String s) {\n+        if (\"\".equals(s)) {\n+            return s;\n         }\n-        if (\"true\".equalsIgnoreCase(string)) {\n+        if (\"true\".equalsIgnoreCase(s)) {\n             return Boolean.TRUE;\n         }\n-        if (\"false\".equalsIgnoreCase(string)) {\n+        if (\"false\".equalsIgnoreCase(s)) {\n             return Boolean.FALSE;\n         }\n-        if (\"null\".equalsIgnoreCase(string)) {\n+        if (\"null\".equalsIgnoreCase(s)) {\n             return JSONObject.NULL;\n         }\n-        final char initial = string.charAt(0);\n-        if (initial < '0' || initial > '9') {\n-            if (initial != '-') {\n-                return string;\n+        final char char1 = s.charAt(0);\n+        if (char1 < '0' || char1 > '9') {\n+            if (char1 != '-') {\n+                return s;\n             }\n         }\n         try {\n-            return stringToNumber(string);\n+            return stringToNumber(s);\n         }\n         catch (final Exception ex) {}\n-        return string;\n+        return s;\n     }\n     \n     public static void testValidity(final Object o) throws JSONException {\n         if (o instanceof Number && !numberIsFinite((Number)o)) {\n             throw new JSONException(\"JSON does not allow non-finite numbers.\");\n         }\n     }\n     \n-    public JSONArray toJSONArray(final JSONArray names) throws JSONException {\n-        if (names == null || names.isEmpty()) {\n+    public JSONArray toJSONArray(final JSONArray jsonArray) throws JSONException {\n+        if (jsonArray == null || jsonArray.isEmpty()) {\n             return null;\n         }\n-        final JSONArray ja = new JSONArray();\n-        for (int i = 0; i < names.length(); ++i) {\n-            ja.put(this.opt(names.getString(i)));\n+        final JSONArray jsonArray2 = new JSONArray();\n+        for (int i = 0; i < jsonArray.length(); ++i) {\n+            jsonArray2.put(this.opt(jsonArray.getString(i)));\n         }\n-        return ja;\n+        return jsonArray2;\n     }\n     \n     @Override\n     public String toString() {\n         try {\n             return this.toString(0);\n         }\n-        catch (final Exception e) {\n+        catch (final Exception ex) {\n             return null;\n         }\n     }\n     \n-    public String toString(final int indentFactor) throws JSONException {\n-        final StringWriter w = new StringWriter();\n-        synchronized (w.getBuffer()) {\n-            return this.write(w, indentFactor, 0).toString();\n+    public String toString(final int n) throws JSONException {\n+        final StringWriter stringWriter = new StringWriter();\n+        synchronized (stringWriter.getBuffer()) {\n+            return this.write(stringWriter, n, 0).toString();\n         }\n     }\n     \n-    public static String valueToString(final Object value) throws JSONException {\n-        return JSONWriter.valueToString(value);\n+    public static String valueToString(final Object o) throws JSONException {\n+        return JSONWriter.valueToString(o);\n     }\n     \n-    public static Object wrap(final Object object) {\n-        return wrap(object, null);\n+    public static Object wrap(final Object o) {\n+        return wrap(o, null);\n     }\n     \n-    private static Object wrap(final Object object, final Set<Object> objectsRecord) {\n+    private static Object wrap(final Object o, final Set<Object> set) {\n         try {\n-            if (JSONObject.NULL.equals(object)) {\n+            if (JSONObject.NULL.equals(o)) {\n                 return JSONObject.NULL;\n             }\n-            if (object instanceof JSONObject || object instanceof JSONArray || JSONObject.NULL.equals(object) || object instanceof JSONString || object instanceof Byte || object instanceof Character || object instanceof Short || object instanceof Integer || object instanceof Long || object instanceof Boolean || object instanceof Float || object instanceof Double || object instanceof String || object instanceof BigInteger || object instanceof BigDecimal || object instanceof Enum) {\n-                return object;\n+            if (o instanceof JSONObject || o instanceof JSONArray || JSONObject.NULL.equals(o) || o instanceof JSONString || o instanceof Byte || o instanceof Character || o instanceof Short || o instanceof Integer || o instanceof Long || o instanceof Boolean || o instanceof Float || o instanceof Double || o instanceof String || o instanceof BigInteger || o instanceof BigDecimal || o instanceof Enum) {\n+                return o;\n             }\n-            if (object instanceof Collection) {\n-                final Collection<?> coll = (Collection)object;\n-                return new JSONArray((Collection)coll);\n+            if (o instanceof Collection) {\n+                return new JSONArray((Collection)o);\n             }\n-            if (object.getClass().isArray()) {\n-                return new JSONArray(object);\n+            if (o.getClass().isArray()) {\n+                return new JSONArray(o);\n             }\n-            if (object instanceof Map) {\n-                final Map<?, ?> map = (Map)object;\n-                return new JSONObject(map);\n+            if (o instanceof Map) {\n+                return new JSONObject((Map<?, ?>)o);\n             }\n-            final Package objectPackage = object.getClass().getPackage();\n-            final String objectPackageName = (objectPackage != null) ? objectPackage.getName() : \"\";\n-            if (objectPackageName.startsWith(\"java.\") || objectPackageName.startsWith(\"javax.\") || object.getClass().getClassLoader() == null) {\n-                return object.toString();\n+            final Package package1 = o.getClass().getPackage();\n+            final String s = (package1 != null) ? package1.getName() : \"\";\n+            if (s.startsWith(\"java.\") || s.startsWith(\"javax.\") || o.getClass().getClassLoader() == null) {\n+                return o.toString();\n             }\n-            if (objectsRecord != null) {\n-                return new JSONObject(object, objectsRecord);\n+            if (set != null) {\n+                return new JSONObject(o, set);\n             }\n-            return new JSONObject(object);\n+            return new JSONObject(o);\n         }\n-        catch (final JSONException exception) {\n-            throw exception;\n+        catch (final JSONException ex) {\n+            throw ex;\n         }\n-        catch (final Exception exception2) {\n+        catch (final Exception ex2) {\n             return null;\n         }\n     }\n     \n     public Writer write(final Writer writer) throws JSONException {\n         return this.write(writer, 0, 0);\n     }\n     \n-    static final Writer writeValue(final Writer writer, final Object value, final int indentFactor, final int indent) throws JSONException, IOException {\n-        if (value == null || value.equals(null)) {\n+    static final Writer writeValue(final Writer writer, final Object o, final int n, final int n2) throws JSONException, IOException {\n+        if (o == null || o.equals(null)) {\n             writer.write(\"null\");\n         }\n-        else if (value instanceof JSONString) {\n-            Object o;\n+        else if (o instanceof JSONString) {\n+            String jsonString;\n             try {\n-                o = ((JSONString)value).toJSONString();\n+                jsonString = ((JSONString)o).toJSONString();\n             }\n-            catch (final Exception e) {\n-                throw new JSONException((Throwable)e);\n+            catch (final Exception ex) {\n+                throw new JSONException((Throwable)ex);\n             }\n-            writer.write((o != null) ? o.toString() : quote(value.toString()));\n+            writer.write((jsonString != null) ? jsonString.toString() : quote(o.toString()));\n         }\n-        else if (value instanceof Number) {\n-            final String numberAsString = numberToString((Number)value);\n-            if (JSONObject.NUMBER_PATTERN.matcher(numberAsString).matches()) {\n-                writer.write(numberAsString);\n+        else if (o instanceof Number) {\n+            final String numberToString = numberToString((Number)o);\n+            if (JSONObject.NUMBER_PATTERN.matcher(numberToString).matches()) {\n+                writer.write(numberToString);\n             }\n             else {\n-                quote(numberAsString, writer);\n+                quote(numberToString, writer);\n             }\n         }\n-        else if (value instanceof Boolean) {\n-            writer.write(value.toString());\n+        else if (o instanceof Boolean) {\n+            writer.write(o.toString());\n         }\n-        else if (value instanceof Enum) {\n-            writer.write(quote(((Enum)value).name()));\n+        else if (o instanceof Enum) {\n+            writer.write(quote(((Enum)o).name()));\n         }\n-        else if (value instanceof JSONObject) {\n-            ((JSONObject)value).write(writer, indentFactor, indent);\n+        else if (o instanceof JSONObject) {\n+            ((JSONObject)o).write(writer, n, n2);\n         }\n-        else if (value instanceof JSONArray) {\n-            ((JSONArray)value).write(writer, indentFactor, indent);\n+        else if (o instanceof JSONArray) {\n+            ((JSONArray)o).write(writer, n, n2);\n         }\n-        else if (value instanceof Map) {\n-            final Map<?, ?> map = (Map)value;\n-            new JSONObject(map).write(writer, indentFactor, indent);\n+        else if (o instanceof Map) {\n+            new JSONObject((Map<?, ?>)o).write(writer, n, n2);\n         }\n-        else if (value instanceof Collection) {\n-            final Collection<?> coll = (Collection)value;\n-            new JSONArray((Collection)coll).write(writer, indentFactor, indent);\n+        else if (o instanceof Collection) {\n+            new JSONArray((Collection)o).write(writer, n, n2);\n         }\n-        else if (value.getClass().isArray()) {\n-            new JSONArray(value).write(writer, indentFactor, indent);\n+        else if (o.getClass().isArray()) {\n+            new JSONArray(o).write(writer, n, n2);\n         }\n         else {\n-            quote(value.toString(), writer);\n+            quote(o.toString(), writer);\n         }\n         return writer;\n     }\n     \n-    static final void indent(final Writer writer, final int indent) throws IOException {\n-        for (int i = 0; i < indent; ++i) {\n+    static final void indent(final Writer writer, final int n) throws IOException {\n+        for (int i = 0; i < n; ++i) {\n             writer.write(32);\n         }\n     }\n     \n-    public Writer write(final Writer writer, final int indentFactor, final int indent) throws JSONException {\n+    public Writer write(final Writer writer, final int n, final int n2) throws JSONException {\n         try {\n-            boolean needsComma = false;\n+            int n3 = 0;\n             final int length = this.length();\n             writer.write(123);\n             if (length == 1) {\n-                final Map.Entry<String, ?> entry = (Map.Entry<String, Object>)this.entrySet().iterator().next();\n-                final String key = (String)entry.getKey();\n-                writer.write(quote(key));\n+                final Map.Entry entry = (Map.Entry)this.entrySet().iterator().next();\n+                final String str = (String)entry.getKey();\n+                writer.write(quote(str));\n                 writer.write(58);\n-                if (indentFactor > 0) {\n+                if (n > 0) {\n                     writer.write(32);\n                 }\n                 try {\n-                    writeValue(writer, entry.getValue(), indentFactor, indent);\n+                    writeValue(writer, entry.getValue(), n, n2);\n                 }\n-                catch (final Exception e) {\n-                    throw new JSONException(\"Unable to write JSONObject value for key: \" + key, (Throwable)e);\n+                catch (final Exception ex) {\n+                    throw new JSONException(\"Unable to write JSONObject value for key: \" + str, (Throwable)ex);\n                 }\n             }\n             else if (length != 0) {\n-                final int newIndent = indent + indentFactor;\n-                for (final Map.Entry<String, ?> entry2 : this.entrySet()) {\n-                    if (needsComma) {\n+                final int n4 = n2 + n;\n+                for (final Map.Entry entry2 : this.entrySet()) {\n+                    if (n3 != 0) {\n                         writer.write(44);\n                     }\n-                    if (indentFactor > 0) {\n+                    if (n > 0) {\n                         writer.write(10);\n                     }\n-                    indent(writer, newIndent);\n-                    final String key2 = (String)entry2.getKey();\n-                    writer.write(quote(key2));\n+                    indent(writer, n4);\n+                    final String str2 = (String)entry2.getKey();\n+                    writer.write(quote(str2));\n                     writer.write(58);\n-                    if (indentFactor > 0) {\n+                    if (n > 0) {\n                         writer.write(32);\n                     }\n                     try {\n-                        writeValue(writer, entry2.getValue(), indentFactor, newIndent);\n+                        writeValue(writer, entry2.getValue(), n, n4);\n                     }\n-                    catch (final Exception e2) {\n-                        throw new JSONException(\"Unable to write JSONObject value for key: \" + key2, (Throwable)e2);\n+                    catch (final Exception ex2) {\n+                        throw new JSONException(\"Unable to write JSONObject value for key: \" + str2, (Throwable)ex2);\n                     }\n-                    needsComma = true;\n+                    n3 = 1;\n                 }\n-                if (indentFactor > 0) {\n+                if (n > 0) {\n                     writer.write(10);\n                 }\n-                indent(writer, indent);\n+                indent(writer, n2);\n             }\n             writer.write(125);\n             return writer;\n         }\n-        catch (final IOException exception) {\n-            throw new JSONException((Throwable)exception);\n+        catch (final IOException ex3) {\n+            throw new JSONException((Throwable)ex3);\n         }\n     }\n     \n     public Map<String, Object> toMap() {\n-        final Map<String, Object> results = new HashMap<String, Object>();\n-        for (final Map.Entry<String, Object> entry : this.entrySet()) {\n-            Object value;\n+        final HashMap hashMap = new HashMap();\n+        for (final Map.Entry entry : this.entrySet()) {\n+            Object o;\n             if (entry.getValue() == null || JSONObject.NULL.equals(entry.getValue())) {\n-                value = null;\n+                o = null;\n             }\n             else if (entry.getValue() instanceof JSONObject) {\n-                value = ((JSONObject)entry.getValue()).toMap();\n+                o = ((JSONObject)entry.getValue()).toMap();\n             }\n             else if (entry.getValue() instanceof JSONArray) {\n-                value = ((JSONArray)entry.getValue()).toList();\n+                o = ((JSONArray)entry.getValue()).toList();\n             }\n             else {\n-                value = entry.getValue();\n+                o = entry.getValue();\n             }\n-            results.put(entry.getKey(), value);\n+            hashMap.put(entry.getKey(), o);\n         }\n-        return results;\n+        return hashMap;\n     }\n     \n-    private static JSONException wrongValueFormatException(final String key, final String valueType, final Throwable cause) {\n-        return new JSONException(\"JSONObject[\" + quote(key) + \"] is not a \" + valueType + \".\", cause);\n+    private static JSONException wrongValueFormatException(final String s, final String str, final Throwable t) {\n+        return new JSONException(\"JSONObject[\" + quote(s) + \"] is not a \" + str + \".\", t);\n     }\n     \n-    private static JSONException wrongValueFormatException(final String key, final String valueType, final Object value, final Throwable cause) {\n-        return new JSONException(\"JSONObject[\" + quote(key) + \"] is not a \" + valueType + \" (\" + value + \").\", cause);\n+    private static JSONException wrongValueFormatException(final String s, final String str, final Object obj, final Throwable t) {\n+        return new JSONException(\"JSONObject[\" + quote(s) + \"] is not a \" + str + \" (\" + obj + \").\", t);\n     }\n     \n-    private static JSONException recursivelyDefinedObjectException(final String key) {\n-        return new JSONException(\"JavaBean object contains recursively defined member variable of key \" + quote(key));\n+    private static JSONException recursivelyDefinedObjectException(final String s) {\n+        return new JSONException(\"JavaBean object contains recursively defined member variable of key \" + quote(s));\n     }\n     \n     static {\n         NUMBER_PATTERN = Pattern.compile(\"-?(?:0|[1-9]\\\\d*)(?:\\\\.\\\\d+)?(?:[eE][+-]?\\\\d+)?\");\n         NULL = new JSONObject.Null((JSONObject.JSONObject$1)null);\n     }\n }\n"}]}
