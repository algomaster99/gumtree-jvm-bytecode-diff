{"diffoscope-json-version": 1, "source1": "first/CpioArchiveOutputStream.class", "source2": "second/CpioArchiveOutputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -26,49 +26,49 @@\n     private long written;\n     private final OutputStream out;\n     private final int blockSize;\n     private long nextArtificalDeviceAndInode;\n     private final ZipEncoding zipEncoding;\n     final String encoding;\n     \n-    public CpioArchiveOutputStream(final OutputStream out) {\n-        this(out, (short)1);\n+    public CpioArchiveOutputStream(final OutputStream outputStream) {\n+        this(outputStream, (short)1);\n     }\n     \n-    public CpioArchiveOutputStream(final OutputStream out, final short format) {\n-        this(out, format, 512, \"US-ASCII\");\n+    public CpioArchiveOutputStream(final OutputStream outputStream, final short n) {\n+        this(outputStream, n, 512, \"US-ASCII\");\n     }\n     \n-    public CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize) {\n-        this(out, format, blockSize, \"US-ASCII\");\n+    public CpioArchiveOutputStream(final OutputStream outputStream, final short n, final int n2) {\n+        this(outputStream, n, n2, \"US-ASCII\");\n     }\n     \n-    public CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding) {\n+    public CpioArchiveOutputStream(final OutputStream out, final short n, final int blockSize, final String encoding) {\n         this.names = new HashMap<String, CpioArchiveEntry>();\n         this.nextArtificalDeviceAndInode = 1L;\n         this.out = out;\n-        switch (format) {\n+        switch (n) {\n             case 1:\n             case 2:\n             case 4:\n             case 8: {\n-                this.entryFormat = format;\n+                this.entryFormat = n;\n                 this.blockSize = blockSize;\n                 this.encoding = encoding;\n                 this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n                 return;\n             }\n             default: {\n-                throw new IllegalArgumentException(\"Unknown format: \" + format);\n+                throw new IllegalArgumentException(\"Unknown format: \" + n);\n             }\n         }\n     }\n     \n-    public CpioArchiveOutputStream(final OutputStream out, final String encoding) {\n-        this(out, (short)1, 512, encoding);\n+    public CpioArchiveOutputStream(final OutputStream outputStream, final String s) {\n+        this(outputStream, (short)1, 512, s);\n     }\n     \n     public void close() throws IOException {\n         try {\n             if (!this.finished) {\n                 this.finish();\n             }\n@@ -97,32 +97,31 @@\n             throw new IOException(\"CRC Error\");\n         }\n         this.entry = null;\n         this.crc = 0L;\n         this.written = 0L;\n     }\n     \n-    public ArchiveEntry createArchiveEntry(final File inputFile, final String entryName) throws IOException {\n+    public ArchiveEntry createArchiveEntry(final File file, final String s) throws IOException {\n         if (this.finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n-        return (ArchiveEntry)new CpioArchiveEntry(inputFile, entryName);\n+        return (ArchiveEntry)new CpioArchiveEntry(file, s);\n     }\n     \n-    public ArchiveEntry createArchiveEntry(final Path inputPath, final String entryName, final LinkOption... options) throws IOException {\n+    public ArchiveEntry createArchiveEntry(final Path path, final String s, final LinkOption... array) throws IOException {\n         if (this.finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n-        return (ArchiveEntry)new CpioArchiveEntry(inputPath, entryName, options);\n+        return (ArchiveEntry)new CpioArchiveEntry(path, s, array);\n     }\n     \n-    private byte[] encode(final String str) throws IOException {\n-        final ByteBuffer buf = this.zipEncoding.encode(str);\n-        final int len = buf.limit() - buf.position();\n-        return Arrays.copyOfRange(buf.array(), buf.arrayOffset(), buf.arrayOffset() + len);\n+    private byte[] encode(final String s) throws IOException {\n+        final ByteBuffer encode = this.zipEncoding.encode(s);\n+        return Arrays.copyOfRange(encode.array(), encode.arrayOffset(), encode.arrayOffset() + (encode.limit() - encode.position()));\n     }\n     \n     private void ensureOpen() throws IOException {\n         if (this.closed) {\n             throw new IOException(\"Stream closed\");\n         }\n     }\n@@ -135,50 +134,49 @@\n         if (this.entry != null) {\n             throw new IOException(\"This archive contains unclosed entries.\");\n         }\n         (this.entry = new CpioArchiveEntry(this.entryFormat)).setName(\"TRAILER!!!\");\n         this.entry.setNumberOfLinks(1L);\n         this.writeHeader(this.entry);\n         this.closeArchiveEntry();\n-        final int lengthOfLastBlock = (int)(this.getBytesWritten() % this.blockSize);\n-        if (lengthOfLastBlock != 0) {\n-            this.pad(this.blockSize - lengthOfLastBlock);\n+        final int n = (int)(this.getBytesWritten() % this.blockSize);\n+        if (n != 0) {\n+            this.pad(this.blockSize - n);\n         }\n         this.finished = true;\n     }\n     \n-    private void pad(final int count) throws IOException {\n-        if (count > 0) {\n-            final byte[] buff = new byte[count];\n-            this.out.write(buff);\n-            this.count(count);\n+    private void pad(final int n) throws IOException {\n+        if (n > 0) {\n+            this.out.write(new byte[n]);\n+            this.count(n);\n         }\n     }\n     \n-    public void putArchiveEntry(final ArchiveEntry entry) throws IOException {\n+    public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\n         if (this.finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n-        final CpioArchiveEntry e = (CpioArchiveEntry)entry;\n+        final CpioArchiveEntry cpioArchiveEntry = (CpioArchiveEntry)archiveEntry;\n         this.ensureOpen();\n         if (this.entry != null) {\n             this.closeArchiveEntry();\n         }\n-        if (e.getTime() == -1L) {\n-            e.setTime(System.currentTimeMillis() / 1000L);\n+        if (cpioArchiveEntry.getTime() == -1L) {\n+            cpioArchiveEntry.setTime(System.currentTimeMillis() / 1000L);\n         }\n-        final short format = e.getFormat();\n+        final short format = cpioArchiveEntry.getFormat();\n         if (format != this.entryFormat) {\n             throw new IOException(\"Header format: \" + format + \" does not match existing format: \" + this.entryFormat);\n         }\n-        if (this.names.put(e.getName(), e) != null) {\n-            throw new IOException(\"Duplicate entry: \" + e.getName());\n+        if (this.names.put(cpioArchiveEntry.getName(), cpioArchiveEntry) != null) {\n+            throw new IOException(\"Duplicate entry: \" + cpioArchiveEntry.getName());\n         }\n-        this.writeHeader(e);\n-        this.entry = e;\n+        this.writeHeader(cpioArchiveEntry);\n+        this.entry = cpioArchiveEntry;\n         this.written = 0L;\n     }\n     \n     public void write(final byte[] b, final int off, final int len) throws IOException {\n         this.ensureOpen();\n         if (off < 0 || len < 0 || off > b.length - len) {\n             throw new IndexOutOfBoundsException();\n@@ -191,171 +189,170 @@\n         }\n         if (this.written + len > this.entry.getSize()) {\n             throw new IOException(\"Attempt to write past end of STORED entry\");\n         }\n         this.out.write(b, off, len);\n         this.written += len;\n         if (this.entry.getFormat() == 2) {\n-            for (int pos = 0; pos < len; ++pos) {\n-                this.crc += (b[pos] & 0xFF);\n+            for (int i = 0; i < len; ++i) {\n+                this.crc += (b[i] & 0xFF);\n                 this.crc &= 0xFFFFFFFFL;\n             }\n         }\n         this.count(len);\n     }\n     \n-    private void writeAsciiLong(final long number, final int length, final int radix) throws IOException {\n-        final StringBuilder tmp = new StringBuilder();\n-        if (radix == 16) {\n-            tmp.append(Long.toHexString(number));\n+    private void writeAsciiLong(final long lng, final int n, final int n2) throws IOException {\n+        final StringBuilder sb = new StringBuilder();\n+        if (n2 == 16) {\n+            sb.append(Long.toHexString(lng));\n         }\n-        else if (radix == 8) {\n-            tmp.append(Long.toOctalString(number));\n+        else if (n2 == 8) {\n+            sb.append(Long.toOctalString(lng));\n         }\n         else {\n-            tmp.append(number);\n+            sb.append(lng);\n         }\n-        String tmpStr;\n-        if (tmp.length() <= length) {\n-            for (int insertLength = length - tmp.length(), pos = 0; pos < insertLength; ++pos) {\n-                tmp.insert(0, \"0\");\n+        String s;\n+        if (sb.length() <= n) {\n+            for (int n3 = n - sb.length(), i = 0; i < n3; ++i) {\n+                sb.insert(0, \"0\");\n             }\n-            tmpStr = tmp.toString();\n+            s = sb.toString();\n         }\n         else {\n-            tmpStr = tmp.substring();\n+            s = sb.substring();\n         }\n-        final byte[] b = ArchiveUtils.toAsciiBytes(tmpStr);\n-        this.out.write(b);\n-        this.count(b.length);\n+        final byte[] asciiBytes = ArchiveUtils.toAsciiBytes(s);\n+        this.out.write(asciiBytes);\n+        this.count(asciiBytes.length);\n     }\n     \n-    private void writeBinaryLong(final long number, final int length, final boolean swapHalfWord) throws IOException {\n-        final byte[] tmp = CpioUtil.long2byteArray(number, length, swapHalfWord);\n-        this.out.write(tmp);\n-        this.count(tmp.length);\n+    private void writeBinaryLong(final long n, final int n2, final boolean b) throws IOException {\n+        final byte[] long2byteArray = CpioUtil.long2byteArray(n, n2, b);\n+        this.out.write(long2byteArray);\n+        this.count(long2byteArray.length);\n     }\n     \n-    private void writeCString(final byte[] str) throws IOException {\n-        this.out.write(str);\n+    private void writeCString(final byte[] b) throws IOException {\n+        this.out.write(b);\n         this.out.write(0);\n-        this.count(str.length + 1);\n+        this.count(b.length + 1);\n     }\n     \n-    private void writeHeader(final CpioArchiveEntry e) throws IOException {\n-        switch (e.getFormat()) {\n+    private void writeHeader(final CpioArchiveEntry cpioArchiveEntry) throws IOException {\n+        switch (cpioArchiveEntry.getFormat()) {\n             case 1: {\n                 this.out.write(ArchiveUtils.toAsciiBytes(\"070701\"));\n                 this.count(6);\n-                this.writeNewEntry(e);\n+                this.writeNewEntry(cpioArchiveEntry);\n                 break;\n             }\n             case 2: {\n                 this.out.write(ArchiveUtils.toAsciiBytes(\"070702\"));\n                 this.count(6);\n-                this.writeNewEntry(e);\n+                this.writeNewEntry(cpioArchiveEntry);\n                 break;\n             }\n             case 4: {\n                 this.out.write(ArchiveUtils.toAsciiBytes(\"070707\"));\n                 this.count(6);\n-                this.writeOldAsciiEntry(e);\n+                this.writeOldAsciiEntry(cpioArchiveEntry);\n                 break;\n             }\n             case 8: {\n-                final boolean swapHalfWord = true;\n                 this.writeBinaryLong(29127L, 2, true);\n-                this.writeOldBinaryEntry(e, true);\n+                this.writeOldBinaryEntry(cpioArchiveEntry, true);\n                 break;\n             }\n             default: {\n-                throw new IOException(\"Unknown format \" + e.getFormat());\n+                throw new IOException(\"Unknown format \" + cpioArchiveEntry.getFormat());\n             }\n         }\n     }\n     \n-    private void writeNewEntry(final CpioArchiveEntry entry) throws IOException {\n-        long inode = entry.getInode();\n-        long devMin = entry.getDeviceMin();\n-        if (\"TRAILER!!!\".equals(entry.getName())) {\n-            devMin = (inode = 0L);\n+    private void writeNewEntry(final CpioArchiveEntry cpioArchiveEntry) throws IOException {\n+        long inode = cpioArchiveEntry.getInode();\n+        long deviceMin = cpioArchiveEntry.getDeviceMin();\n+        if (\"TRAILER!!!\".equals(cpioArchiveEntry.getName())) {\n+            deviceMin = (inode = 0L);\n         }\n-        else if (inode == 0L && devMin == 0L) {\n+        else if (inode == 0L && deviceMin == 0L) {\n             inode = (this.nextArtificalDeviceAndInode & -1L);\n-            devMin = (this.nextArtificalDeviceAndInode++ >> 32 & -1L);\n+            deviceMin = (this.nextArtificalDeviceAndInode++ >> 32 & -1L);\n         }\n         else {\n-            this.nextArtificalDeviceAndInode = Math.max(this.nextArtificalDeviceAndInode, inode + 4294967296L * devMin) + 1L;\n+            this.nextArtificalDeviceAndInode = Math.max(this.nextArtificalDeviceAndInode, inode + 4294967296L * deviceMin) + 1L;\n         }\n         this.writeAsciiLong(inode, 8, 16);\n-        this.writeAsciiLong(entry.getMode(), 8, 16);\n-        this.writeAsciiLong(entry.getUID(), 8, 16);\n-        this.writeAsciiLong(entry.getGID(), 8, 16);\n-        this.writeAsciiLong(entry.getNumberOfLinks(), 8, 16);\n-        this.writeAsciiLong(entry.getTime(), 8, 16);\n-        this.writeAsciiLong(entry.getSize(), 8, 16);\n-        this.writeAsciiLong(entry.getDeviceMaj(), 8, 16);\n-        this.writeAsciiLong(devMin, 8, 16);\n-        this.writeAsciiLong(entry.getRemoteDeviceMaj(), 8, 16);\n-        this.writeAsciiLong(entry.getRemoteDeviceMin(), 8, 16);\n-        final byte[] name = this.encode(entry.getName());\n-        this.writeAsciiLong((long)name.length + 1L, 8, 16);\n-        this.writeAsciiLong(entry.getChksum(), 8, 16);\n-        this.writeCString(name);\n-        this.pad(entry.getHeaderPadCount((long)name.length));\n-    }\n-    \n-    private void writeOldAsciiEntry(final CpioArchiveEntry entry) throws IOException {\n-        long inode = entry.getInode();\n-        long device = entry.getDevice();\n-        if (\"TRAILER!!!\".equals(entry.getName())) {\n+        this.writeAsciiLong(cpioArchiveEntry.getMode(), 8, 16);\n+        this.writeAsciiLong(cpioArchiveEntry.getUID(), 8, 16);\n+        this.writeAsciiLong(cpioArchiveEntry.getGID(), 8, 16);\n+        this.writeAsciiLong(cpioArchiveEntry.getNumberOfLinks(), 8, 16);\n+        this.writeAsciiLong(cpioArchiveEntry.getTime(), 8, 16);\n+        this.writeAsciiLong(cpioArchiveEntry.getSize(), 8, 16);\n+        this.writeAsciiLong(cpioArchiveEntry.getDeviceMaj(), 8, 16);\n+        this.writeAsciiLong(deviceMin, 8, 16);\n+        this.writeAsciiLong(cpioArchiveEntry.getRemoteDeviceMaj(), 8, 16);\n+        this.writeAsciiLong(cpioArchiveEntry.getRemoteDeviceMin(), 8, 16);\n+        final byte[] encode = this.encode(cpioArchiveEntry.getName());\n+        this.writeAsciiLong((long)encode.length + 1L, 8, 16);\n+        this.writeAsciiLong(cpioArchiveEntry.getChksum(), 8, 16);\n+        this.writeCString(encode);\n+        this.pad(cpioArchiveEntry.getHeaderPadCount((long)encode.length));\n+    }\n+    \n+    private void writeOldAsciiEntry(final CpioArchiveEntry cpioArchiveEntry) throws IOException {\n+        long inode = cpioArchiveEntry.getInode();\n+        long device = cpioArchiveEntry.getDevice();\n+        if (\"TRAILER!!!\".equals(cpioArchiveEntry.getName())) {\n             device = (inode = 0L);\n         }\n         else if (inode == 0L && device == 0L) {\n             inode = (this.nextArtificalDeviceAndInode & 0x3FFFFL);\n             device = (this.nextArtificalDeviceAndInode++ >> 18 & 0x3FFFFL);\n         }\n         else {\n             this.nextArtificalDeviceAndInode = Math.max(this.nextArtificalDeviceAndInode, inode + 262144L * device) + 1L;\n         }\n         this.writeAsciiLong(device, 6, 8);\n         this.writeAsciiLong(inode, 6, 8);\n-        this.writeAsciiLong(entry.getMode(), 6, 8);\n-        this.writeAsciiLong(entry.getUID(), 6, 8);\n-        this.writeAsciiLong(entry.getGID(), 6, 8);\n-        this.writeAsciiLong(entry.getNumberOfLinks(), 6, 8);\n-        this.writeAsciiLong(entry.getRemoteDevice(), 6, 8);\n-        this.writeAsciiLong(entry.getTime(), 11, 8);\n-        final byte[] name = this.encode(entry.getName());\n-        this.writeAsciiLong((long)name.length + 1L, 6, 8);\n-        this.writeAsciiLong(entry.getSize(), 11, 8);\n-        this.writeCString(name);\n-    }\n-    \n-    private void writeOldBinaryEntry(final CpioArchiveEntry entry, final boolean swapHalfWord) throws IOException {\n-        long inode = entry.getInode();\n-        long device = entry.getDevice();\n-        if (\"TRAILER!!!\".equals(entry.getName())) {\n+        this.writeAsciiLong(cpioArchiveEntry.getMode(), 6, 8);\n+        this.writeAsciiLong(cpioArchiveEntry.getUID(), 6, 8);\n+        this.writeAsciiLong(cpioArchiveEntry.getGID(), 6, 8);\n+        this.writeAsciiLong(cpioArchiveEntry.getNumberOfLinks(), 6, 8);\n+        this.writeAsciiLong(cpioArchiveEntry.getRemoteDevice(), 6, 8);\n+        this.writeAsciiLong(cpioArchiveEntry.getTime(), 11, 8);\n+        final byte[] encode = this.encode(cpioArchiveEntry.getName());\n+        this.writeAsciiLong((long)encode.length + 1L, 6, 8);\n+        this.writeAsciiLong(cpioArchiveEntry.getSize(), 11, 8);\n+        this.writeCString(encode);\n+    }\n+    \n+    private void writeOldBinaryEntry(final CpioArchiveEntry cpioArchiveEntry, final boolean b) throws IOException {\n+        long inode = cpioArchiveEntry.getInode();\n+        long device = cpioArchiveEntry.getDevice();\n+        if (\"TRAILER!!!\".equals(cpioArchiveEntry.getName())) {\n             device = (inode = 0L);\n         }\n         else if (inode == 0L && device == 0L) {\n             inode = (this.nextArtificalDeviceAndInode & 0xFFFFL);\n             device = (this.nextArtificalDeviceAndInode++ >> 16 & 0xFFFFL);\n         }\n         else {\n             this.nextArtificalDeviceAndInode = Math.max(this.nextArtificalDeviceAndInode, inode + 65536L * device) + 1L;\n         }\n-        this.writeBinaryLong(device, 2, swapHalfWord);\n-        this.writeBinaryLong(inode, 2, swapHalfWord);\n-        this.writeBinaryLong(entry.getMode(), 2, swapHalfWord);\n-        this.writeBinaryLong(entry.getUID(), 2, swapHalfWord);\n-        this.writeBinaryLong(entry.getGID(), 2, swapHalfWord);\n-        this.writeBinaryLong(entry.getNumberOfLinks(), 2, swapHalfWord);\n-        this.writeBinaryLong(entry.getRemoteDevice(), 2, swapHalfWord);\n-        this.writeBinaryLong(entry.getTime(), 4, swapHalfWord);\n-        final byte[] name = this.encode(entry.getName());\n-        this.writeBinaryLong((long)name.length + 1L, 2, swapHalfWord);\n-        this.writeBinaryLong(entry.getSize(), 4, swapHalfWord);\n-        this.writeCString(name);\n-        this.pad(entry.getHeaderPadCount((long)name.length));\n+        this.writeBinaryLong(device, 2, b);\n+        this.writeBinaryLong(inode, 2, b);\n+        this.writeBinaryLong(cpioArchiveEntry.getMode(), 2, b);\n+        this.writeBinaryLong(cpioArchiveEntry.getUID(), 2, b);\n+        this.writeBinaryLong(cpioArchiveEntry.getGID(), 2, b);\n+        this.writeBinaryLong(cpioArchiveEntry.getNumberOfLinks(), 2, b);\n+        this.writeBinaryLong(cpioArchiveEntry.getRemoteDevice(), 2, b);\n+        this.writeBinaryLong(cpioArchiveEntry.getTime(), 4, b);\n+        final byte[] encode = this.encode(cpioArchiveEntry.getName());\n+        this.writeBinaryLong((long)encode.length + 1L, 2, b);\n+        this.writeBinaryLong(cpioArchiveEntry.getSize(), 4, b);\n+        this.writeCString(encode);\n+        this.pad(cpioArchiveEntry.getHeaderPadCount((long)encode.length));\n     }\n }\n"}]}
