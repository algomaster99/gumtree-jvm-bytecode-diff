{"diffoscope-json-version": 1, "source1": "first/UniquePropertiesCheck.class", "source2": "second/UniquePropertiesCheck.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -18,22 +18,49 @@\n @StatelessCheck\n public class UniquePropertiesCheck extends AbstractFileSetCheck\n {\n     public static final String MSG_KEY = \"properties.duplicate.property\";\n     public static final String MSG_IO_EXCEPTION_KEY = \"unable.open.cause\";\n     private static final Pattern SPACE_PATTERN;\n     \n+    static {\n+        SPACE_PATTERN = Pattern.compile(\" \");\n+    }\n+    \n     public UniquePropertiesCheck() {\n         this.setFileExtensions(new String[] { \"properties\" });\n     }\n     \n     protected void processFiltered(final File file, final FileText fileText) {\n         final UniquePropertiesCheck.UniqueProperties properties = new UniquePropertiesCheck.UniqueProperties();\n-        try (final InputStream inputStream = Files.newInputStream(file.toPath(), new OpenOption[0])) {\n-            properties.load(inputStream);\n+        try {\n+            Throwable t = null;\n+            try {\n+                final InputStream inputStream = Files.newInputStream(file.toPath(), new OpenOption[0]);\n+                try {\n+                    properties.load(inputStream);\n+                }\n+                finally {\n+                    if (inputStream != null) {\n+                        inputStream.close();\n+                    }\n+                }\n+            }\n+            finally {\n+                if (t == null) {\n+                    final Throwable exception;\n+                    t = exception;\n+                }\n+                else {\n+                    final Throwable exception;\n+                    if (t != exception) {\n+                        t.addSuppressed(exception);\n+                    }\n+                }\n+            }\n         }\n         catch (final IOException ex) {\n             this.log(1, \"unable.open.cause\", new Object[] { file.getPath(), ex.getLocalizedMessage() });\n         }\n         for (final Map.Entry<String, AtomicInteger> duplication : properties.getDuplicatedKeys().entrySet()) {\n             final String keyName = (String)duplication.getKey();\n             final int lineNumber = getLineNumber(fileText, keyName);\n@@ -59,12 +86,8 @@\n         return lineNumber;\n     }\n     \n     private static Pattern getKeyPattern(final String keyName) {\n         final String keyPatternString = \"^\" + UniquePropertiesCheck.SPACE_PATTERN.matcher(keyName).replaceAll(Matcher.quoteReplacement(\"\\\\\\\\ \")) + \"[\\\\s:=].*$\";\n         return Pattern.compile(keyPatternString);\n     }\n-    \n-    static {\n-        SPACE_PATTERN = Pattern.compile(\" \");\n-    }\n }\n"}]}
