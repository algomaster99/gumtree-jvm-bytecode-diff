{"diffoscope-json-version": 1, "source1": "first/SWITCH.class", "source2": "second/SWITCH.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -14,83 +14,83 @@\n             }\n         }\n         return true;\n     }\n     \n     private static void sort(final int l, final int r, final int[] match, final InstructionHandle[] targets) {\n         int i = l;\n-        int j = r;\n-        final int m = match[l + r >>> 1];\n+        int r2 = r;\n+        final int j = match[l + r >>> 1];\n         while (true) {\n-            if (match[i] < m) {\n+            if (match[i] < j) {\n                 ++i;\n             }\n             else {\n-                while (m < match[j]) {\n-                    --j;\n+                while (j < match[r2]) {\n+                    --r2;\n                 }\n-                if (i <= j) {\n-                    final int h = match[i];\n-                    match[i] = match[j];\n-                    match[j] = h;\n-                    final InstructionHandle h2 = targets[i];\n-                    targets[i] = targets[j];\n-                    targets[j] = h2;\n+                if (i <= r2) {\n+                    final int n = match[i];\n+                    match[i] = match[r2];\n+                    match[r2] = n;\n+                    final InstructionHandle instructionHandle = targets[i];\n+                    targets[i] = targets[r2];\n+                    targets[r2] = instructionHandle;\n                     ++i;\n-                    --j;\n+                    --r2;\n                 }\n-                if (i > j) {\n+                if (i > r2) {\n                     break;\n                 }\n                 continue;\n             }\n         }\n-        if (l < j) {\n-            sort(l, j, match, targets);\n+        if (l < r2) {\n+            sort(l, r2, match, targets);\n         }\n         if (i < r) {\n             sort(i, r, match, targets);\n         }\n     }\n     \n     public SWITCH(final int[] match, final InstructionHandle[] targets, final InstructionHandle target) {\n         this(match, targets, target, 1);\n     }\n     \n     public SWITCH(final int[] match, final InstructionHandle[] targets, final InstructionHandle target, final int maxGap) {\n-        final int[] matchClone = (int[])match.clone();\n-        final InstructionHandle[] targetsClone = (InstructionHandle[])targets.clone();\n-        final int matchLength = match.length;\n-        if (matchLength < 2) {\n+        final int[] array = (int[])match.clone();\n+        final InstructionHandle[] targets2 = (InstructionHandle[])targets.clone();\n+        final int length = match.length;\n+        if (length < 2) {\n             this.instruction = (Select)new TABLESWITCH(match, targets, target);\n         }\n         else {\n-            sort(0, matchLength - 1, matchClone, targetsClone);\n-            if (matchIsOrdered(matchClone, matchLength, maxGap)) {\n-                final int maxSize = matchLength + matchLength * maxGap;\n-                final int[] mVec = new int[maxSize];\n-                final InstructionHandle[] tVec = new InstructionHandle[maxSize];\n-                int count = 1;\n-                mVec[0] = match[0];\n-                tVec[0] = targets[0];\n-                for (int i = 1; i < matchLength; ++i) {\n-                    final int prev = match[i - 1];\n-                    for (int gap = match[i] - prev, j = 1; j < gap; ++j) {\n-                        mVec[count] = prev + j;\n-                        tVec[count] = target;\n-                        ++count;\n+            sort(0, length - 1, array, targets2);\n+            if (matchIsOrdered(array, length, maxGap)) {\n+                final int n = length + length * maxGap;\n+                final int[] original = new int[n];\n+                final InstructionHandle[] original2 = new InstructionHandle[n];\n+                int n2 = 1;\n+                original[0] = match[0];\n+                original2[0] = targets[0];\n+                for (int i = 1; i < length; ++i) {\n+                    final int n3 = match[i - 1];\n+                    for (int n4 = match[i] - n3, j = 1; j < n4; ++j) {\n+                        original[n2] = n3 + j;\n+                        original2[n2] = target;\n+                        ++n2;\n                     }\n-                    mVec[count] = match[i];\n-                    tVec[count] = targets[i];\n-                    ++count;\n+                    original[n2] = match[i];\n+                    original2[n2] = targets[i];\n+                    ++n2;\n                 }\n-                this.instruction = (Select)new TABLESWITCH(Arrays.copyOf(mVec, count), (InstructionHandle[])Arrays.copyOf(tVec, count), target);\n+                this.instruction = (Select)new TABLESWITCH(Arrays.copyOf(original, n2), (InstructionHandle[])Arrays.copyOf(original2, n2), target);\n             }\n             else {\n-                this.instruction = (Select)new LOOKUPSWITCH(matchClone, targetsClone, target);\n+                this.instruction = (Select)new LOOKUPSWITCH(array, targets2, target);\n             }\n         }\n     }\n     \n     public Instruction getInstruction() {\n         return (Instruction)this.instruction;\n     }\n"}]}
