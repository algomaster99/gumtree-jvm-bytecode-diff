{"diffoscope-json-version": 1, "source1": "first/ClassPath.class", "source2": "second/ClassPath.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -31,181 +31,175 @@\n     private static final FilenameFilter MODULES_FILTER;\n     public static final ClassPath SYSTEM_CLASS_PATH;\n     private final String classPathString;\n     private final ClassPath parent;\n     private final List<ClassPath.AbstractPathEntry> paths;\n     \n     private static void addJdkModules(final String javaHome, final List<String> list) {\n-        String modulesPath = System.getProperty(\"java.modules.path\");\n-        if (modulesPath == null || modulesPath.trim().isEmpty()) {\n-            modulesPath = javaHome + File.separator + \"jmods\";\n-        }\n-        final File modulesDir = new File(modulesPath);\n-        if (modulesDir.exists()) {\n-            final String[] modules = modulesDir.list(ClassPath.MODULES_FILTER);\n-            if (modules != null) {\n-                for (final String module : modules) {\n-                    list.add(modulesDir.getPath() + File.separatorChar + module);\n+        String pathname = System.getProperty(\"java.modules.path\");\n+        if (pathname == null || pathname.trim().isEmpty()) {\n+            pathname = javaHome + File.separator + \"jmods\";\n+        }\n+        final File file = new File(pathname);\n+        if (file.exists()) {\n+            final String[] list2 = file.list(ClassPath.MODULES_FILTER);\n+            if (list2 != null) {\n+                final String[] array = list2;\n+                for (int length = array.length, i = 0; i < length; ++i) {\n+                    list.add(file.getPath() + File.separatorChar + array[i]);\n                 }\n             }\n         }\n     }\n     \n     public static String getClassPath() {\n-        final String classPathProp = System.getProperty(\"java.class.path\");\n-        final String bootClassPathProp = System.getProperty(\"sun.boot.class.path\");\n-        final String extDirs = System.getProperty(\"java.ext.dirs\");\n-        final String javaHome = System.getProperty(\"java.home\");\n-        final List<String> list = new ArrayList<String>();\n-        final Path modulesPath = Paths.get(javaHome, new String[0]).resolve(\"lib/modules\");\n-        if (Files.exists(modulesPath, new LinkOption[0]) && Files.isRegularFile(modulesPath, new LinkOption[0])) {\n-            list.add(modulesPath.toAbsolutePath().toString());\n-        }\n-        addJdkModules(javaHome, list);\n-        getPathComponents(classPathProp, list);\n-        getPathComponents(bootClassPathProp, list);\n-        final List<String> dirs = new ArrayList<String>();\n-        getPathComponents(extDirs, dirs);\n-        for (final String d : dirs) {\n-            final File extDir = new File(d);\n-            final String[] extensions = extDir.list(ClassPath.ARCHIVE_FILTER);\n-            if (extensions != null) {\n-                for (final String extension : extensions) {\n-                    list.add(extDir.getPath() + File.separatorChar + extension);\n+        final String property = System.getProperty(\"java.class.path\");\n+        final String property2 = System.getProperty(\"sun.boot.class.path\");\n+        final String property3 = System.getProperty(\"java.ext.dirs\");\n+        final String property4 = System.getProperty(\"java.home\");\n+        final ArrayList list = new ArrayList();\n+        final Path resolve = Paths.get(property4, new String[0]).resolve(\"lib/modules\");\n+        if (Files.exists(resolve, new LinkOption[0]) && Files.isRegularFile(resolve, new LinkOption[0])) {\n+            list.add(resolve.toAbsolutePath().toString());\n+        }\n+        addJdkModules(property4, list);\n+        getPathComponents(property, list);\n+        getPathComponents(property2, list);\n+        final ArrayList list2 = new ArrayList();\n+        getPathComponents(property3, list2);\n+        final Iterator iterator = list2.iterator();\n+        while (iterator.hasNext()) {\n+            final File file = new File((String)iterator.next());\n+            final String[] list3 = file.list(ClassPath.ARCHIVE_FILTER);\n+            if (list3 != null) {\n+                final String[] array = list3;\n+                for (int length = array.length, i = 0; i < length; ++i) {\n+                    list.add(file.getPath() + File.separatorChar + array[i]);\n                 }\n             }\n         }\n-        return list.stream().collect((Collector<? super Object, ?, String>)Collectors.joining(File.pathSeparator));\n+        return (String)list.stream().collect(Collectors.joining(File.pathSeparator));\n     }\n     \n     private static void getPathComponents(final String path, final List<String> list) {\n         if (path != null) {\n-            final StringTokenizer tokenizer = new StringTokenizer(path, File.pathSeparator);\n-            while (tokenizer.hasMoreTokens()) {\n-                final String name = tokenizer.nextToken();\n-                final File file = new File(name);\n-                if (file.exists()) {\n-                    list.add(name);\n+            final StringTokenizer stringTokenizer = new StringTokenizer(path, File.pathSeparator);\n+            while (stringTokenizer.hasMoreTokens()) {\n+                final String nextToken = stringTokenizer.nextToken();\n+                if (new File(nextToken).exists()) {\n+                    list.add(nextToken);\n                 }\n             }\n         }\n     }\n     \n     @Deprecated\n     public ClassPath() {\n         this(getClassPath());\n     }\n     \n     public ClassPath(final ClassPath parent, final String classPathString) {\n         this.parent = parent;\n         this.classPathString = Objects.requireNonNull(classPathString, \"classPathString\");\n         this.paths = new ArrayList<ClassPath.AbstractPathEntry>();\n-        final StringTokenizer tokenizer = new StringTokenizer(classPathString, File.pathSeparator);\n-        while (tokenizer.hasMoreTokens()) {\n-            final String path = tokenizer.nextToken();\n-            if (!path.isEmpty()) {\n-                final File file = new File(path);\n+        final StringTokenizer stringTokenizer = new StringTokenizer(classPathString, File.pathSeparator);\n+        while (stringTokenizer.hasMoreTokens()) {\n+            final String nextToken = stringTokenizer.nextToken();\n+            if (!nextToken.isEmpty()) {\n+                final File obj = new File(nextToken);\n                 try {\n-                    if (!file.exists()) {\n+                    if (!obj.exists()) {\n                         continue;\n                     }\n-                    if (file.isDirectory()) {\n-                        this.paths.add((ClassPath.AbstractPathEntry)new ClassPath.Dir(path));\n+                    if (obj.isDirectory()) {\n+                        this.paths.add((ClassPath.AbstractPathEntry)new ClassPath.Dir(nextToken));\n                     }\n-                    else if (path.endsWith(\".jmod\")) {\n-                        this.paths.add((ClassPath.AbstractPathEntry)new ClassPath.Module(new ZipFile(file)));\n+                    else if (nextToken.endsWith(\".jmod\")) {\n+                        this.paths.add((ClassPath.AbstractPathEntry)new ClassPath.Module(new ZipFile(obj)));\n                     }\n-                    else if (path.endsWith(ModularRuntimeImage.MODULES_PATH)) {\n+                    else if (nextToken.endsWith(ModularRuntimeImage.MODULES_PATH)) {\n                         this.paths.add((ClassPath.AbstractPathEntry)new ClassPath.JrtModules(ModularRuntimeImage.MODULES_PATH));\n                     }\n                     else {\n-                        this.paths.add((ClassPath.AbstractPathEntry)new ClassPath.Jar(new ZipFile(file)));\n+                        this.paths.add((ClassPath.AbstractPathEntry)new ClassPath.Jar(new ZipFile(obj)));\n                     }\n                 }\n-                catch (final IOException e) {\n-                    if (!path.endsWith(\".zip\") && !path.endsWith(\".jar\")) {\n+                catch (final IOException obj2) {\n+                    if (!nextToken.endsWith(\".zip\") && !nextToken.endsWith(\".jar\")) {\n                         continue;\n                     }\n-                    System.err.println(\"CLASSPATH component \" + file + \": \" + e);\n+                    System.err.println(\"CLASSPATH component \" + obj + \": \" + obj2);\n                 }\n             }\n         }\n     }\n     \n     public ClassPath(final String classPath) {\n         this(null, classPath);\n     }\n     \n     @Override\n     public void close() throws IOException {\n-        for (final ClassPath.AbstractPathEntry path : this.paths) {\n-            path.close();\n+        final Iterator<ClassPath.AbstractPathEntry> iterator = this.paths.iterator();\n+        while (iterator.hasNext()) {\n+            ((ClassPath.AbstractPathEntry)iterator.next()).close();\n         }\n     }\n     \n     @Override\n     public boolean equals(final Object obj) {\n-        if (this == obj) {\n-            return true;\n-        }\n-        if (obj == null) {\n-            return false;\n-        }\n-        if (this.getClass() != obj.getClass()) {\n-            return false;\n-        }\n-        final ClassPath other = (ClassPath)obj;\n-        return Objects.equals(this.classPathString, other.classPathString);\n+        return this == obj || (obj != null && this.getClass() == obj.getClass() && Objects.equals(this.classPathString, ((ClassPath)obj).classPathString));\n     }\n     \n     public byte[] getBytes(final String name) throws IOException {\n         return this.getBytes(name, \".class\");\n     }\n     \n     public byte[] getBytes(final String name, final String suffix) throws IOException {\n-        DataInputStream dis = null;\n+        DataInputStream dataInputStream = null;\n         try (final InputStream inputStream = this.getInputStream(name, suffix)) {\n             if (inputStream == null) {\n                 throw new IOException(\"Couldn't find: \" + name + suffix);\n             }\n-            dis = new DataInputStream(inputStream);\n-            final byte[] bytes = new byte[inputStream.available()];\n-            dis.readFully(bytes);\n-            return bytes;\n+            dataInputStream = new DataInputStream(inputStream);\n+            final byte[] b = new byte[inputStream.available()];\n+            dataInputStream.readFully(b);\n+            return b;\n         }\n         finally {\n-            if (dis != null) {\n-                dis.close();\n+            if (dataInputStream != null) {\n+                dataInputStream.close();\n             }\n         }\n     }\n     \n     public ClassPath.ClassFile getClassFile(final String name) throws IOException {\n         return this.getClassFile(name, \".class\");\n     }\n     \n     public ClassPath.ClassFile getClassFile(final String name, final String suffix) throws IOException {\n-        ClassPath.ClassFile cf = null;\n+        ClassPath.ClassFile classFile = null;\n         if (this.parent != null) {\n-            cf = this.parent.getClassFileInternal(name, suffix);\n+            classFile = this.parent.getClassFileInternal(name, suffix);\n         }\n-        if (cf == null) {\n-            cf = this.getClassFileInternal(name, suffix);\n+        if (classFile == null) {\n+            classFile = this.getClassFileInternal(name, suffix);\n         }\n-        if (cf != null) {\n-            return cf;\n+        if (classFile != null) {\n+            return classFile;\n         }\n         throw new IOException(\"Couldn't find: \" + name + suffix);\n     }\n     \n     private ClassPath.ClassFile getClassFileInternal(final String name, final String suffix) {\n-        for (final ClassPath.AbstractPathEntry path : this.paths) {\n-            final ClassPath.ClassFile cf = path.getClassFile(name, suffix);\n-            if (cf != null) {\n-                return cf;\n+        final Iterator<ClassPath.AbstractPathEntry> iterator = this.paths.iterator();\n+        while (iterator.hasNext()) {\n+            final ClassPath.ClassFile classFile = ((ClassPath.AbstractPathEntry)iterator.next()).getClassFile(name, suffix);\n+            if (classFile != null) {\n+                return classFile;\n             }\n         }\n         return null;\n     }\n     \n     public InputStream getInputStream(final String name) throws IOException {\n         return this.getInputStream(Utility.packageToPath(name), \".class\");\n@@ -220,56 +214,59 @@\n             }\n         }\n         catch (final Exception ex) {}\n         return this.getClassFile(name, suffix).getInputStream();\n     }\n     \n     public String getPath(String name) throws IOException {\n-        final int index = name.lastIndexOf(46);\n-        String suffix = \"\";\n-        if (index > 0) {\n-            suffix = name.substring(index);\n-            name = name.substring(0, index);\n+        final int lastIndex = name.lastIndexOf(46);\n+        String substring = \"\";\n+        if (lastIndex > 0) {\n+            substring = name.substring(lastIndex);\n+            name = name.substring(0, lastIndex);\n         }\n-        return this.getPath(name, suffix);\n+        return this.getPath(name, substring);\n     }\n     \n     public String getPath(final String name, final String suffix) throws IOException {\n         return this.getClassFile(name, suffix).getPath();\n     }\n     \n     public URL getResource(final String name) {\n-        for (final ClassPath.AbstractPathEntry path : this.paths) {\n-            final URL url;\n-            if ((url = path.getResource(name)) != null) {\n-                return url;\n+        final Iterator<ClassPath.AbstractPathEntry> iterator = this.paths.iterator();\n+        while (iterator.hasNext()) {\n+            final URL resource;\n+            if ((resource = ((ClassPath.AbstractPathEntry)iterator.next()).getResource(name)) != null) {\n+                return resource;\n             }\n         }\n         return null;\n     }\n     \n     public InputStream getResourceAsStream(final String name) {\n-        for (final ClassPath.AbstractPathEntry path : this.paths) {\n-            final InputStream is;\n-            if ((is = path.getResourceAsStream(name)) != null) {\n-                return is;\n+        final Iterator<ClassPath.AbstractPathEntry> iterator = this.paths.iterator();\n+        while (iterator.hasNext()) {\n+            final InputStream resourceAsStream;\n+            if ((resourceAsStream = ((ClassPath.AbstractPathEntry)iterator.next()).getResourceAsStream(name)) != null) {\n+                return resourceAsStream;\n             }\n         }\n         return null;\n     }\n     \n     public Enumeration<URL> getResources(final String name) {\n-        final Vector<URL> results = new Vector<URL>();\n-        for (final ClassPath.AbstractPathEntry path : this.paths) {\n-            final URL url;\n-            if ((url = path.getResource(name)) != null) {\n-                results.add(url);\n+        final Vector vector = new Vector();\n+        final Iterator<ClassPath.AbstractPathEntry> iterator = this.paths.iterator();\n+        while (iterator.hasNext()) {\n+            final URL resource;\n+            if ((resource = ((ClassPath.AbstractPathEntry)iterator.next()).getResource(name)) != null) {\n+                vector.add(resource);\n             }\n         }\n-        return results.elements();\n+        return vector.elements();\n     }\n     \n     @Override\n     public int hashCode() {\n         return this.classPathString.hashCode();\n     }\n     \n"}]}
