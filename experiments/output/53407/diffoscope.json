{"diffoscope-json-version": 1, "source1": "first/TarArchiveEntry.class", "source2": "second/TarArchiveEntry.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -69,14 +69,18 @@\n     private boolean paxGNU1XSparse;\n     private boolean starSparse;\n     private final Path file;\n     private final LinkOption[] linkOptions;\n     private final Map<String, String> extraPaxHeaders;\n     private long dataOffset;\n     \n+    static {\n+        EMPTY_TAR_ARCHIVE_ENTRY_ARRAY = new TarArchiveEntry[0];\n+    }\n+    \n     private static FileTime fileTimeFromOptionalSeconds(final long seconds) {\n         if (seconds <= 0L) {\n             return null;\n         }\n         return FileTime.from(seconds, TimeUnit.SECONDS);\n     }\n     \n@@ -163,24 +167,24 @@\n         this.dataOffset = -1L;\n         final String normalizedName = normalizeFileName(fileName, false);\n         this.file = file.toPath();\n         this.linkOptions = IOUtils.EMPTY_LINK_OPTIONS;\n         try {\n             this.readFileMode(this.file, normalizedName, new LinkOption[0]);\n         }\n-        catch (final IOException e) {\n+        catch (final IOException ex) {\n             if (!file.isDirectory()) {\n                 this.size = file.length();\n             }\n         }\n         this.userName = \"\";\n         try {\n             this.readOsSpecificProperties(this.file, new LinkOption[0]);\n         }\n-        catch (final IOException e) {\n+        catch (final IOException ex2) {\n             this.mTime = FileTime.fromMillis(file.lastModified());\n         }\n         this.preserveAbsolutePath = false;\n     }\n     \n     public TarArchiveEntry(final Map<String, String> globalPaxHeaders, final byte[] headerBuf, final ZipEncoding encoding, final boolean lenient) throws IOException {\n         this(false);\n@@ -340,20 +344,43 @@\n     }\n     \n     public TarArchiveEntry[] getDirectoryEntries() {\n         if (this.file == null || !this.isDirectory()) {\n             return TarArchiveEntry.EMPTY_TAR_ARCHIVE_ENTRY_ARRAY;\n         }\n         final List<TarArchiveEntry> entries = new ArrayList<TarArchiveEntry>();\n-        try (final DirectoryStream<Path> dirStream = Files.newDirectoryStream(this.file)) {\n-            for (final Path p : dirStream) {\n-                entries.add(new TarArchiveEntry(p));\n+        try {\n+            Throwable t = null;\n+            try {\n+                final DirectoryStream<Path> dirStream = Files.newDirectoryStream(this.file);\n+                try {\n+                    for (final Path p : dirStream) {\n+                        entries.add(new TarArchiveEntry(p));\n+                    }\n+                }\n+                finally {\n+                    if (dirStream != null) {\n+                        dirStream.close();\n+                    }\n+                }\n+            }\n+            finally {\n+                if (t == null) {\n+                    final Throwable exception;\n+                    t = exception;\n+                }\n+                else {\n+                    final Throwable exception;\n+                    if (t != exception) {\n+                        t.addSuppressed(exception);\n+                    }\n+                }\n             }\n         }\n-        catch (final IOException e) {\n+        catch (final IOException ex) {\n             return TarArchiveEntry.EMPTY_TAR_ARCHIVE_ENTRY_ARRAY;\n         }\n         return entries.toArray(TarArchiveEntry.EMPTY_TAR_ARCHIVE_ENTRY_ARRAY);\n     }\n     \n     public String getExtraPaxHeader(final String name) {\n         return this.extraPaxHeaders.get(name);\n@@ -618,15 +645,15 @@\n         return TarUtils.parseOctalOrBinary(header, offset, length);\n     }\n     \n     public void parseTarHeader(final byte[] header) {\n         try {\n             this.parseTarHeader(header, TarUtils.DEFAULT_ENCODING);\n         }\n-        catch (final IOException ex) {\n+        catch (final IOException ex3) {\n             try {\n                 this.parseTarHeader(header, TarUtils.DEFAULT_ENCODING, true, false);\n             }\n             catch (final IOException ex2) {\n                 throw new UncheckedIOException(ex2);\n             }\n         }\n@@ -706,251 +733,180 @@\n                 offset += 12;\n                 break;\n             }\n             case 4: {\n                 final String xstarPrefix = oldStyle ? TarUtils.parseName(header, offset, 131) : TarUtils.parseName(header, offset, 131, encoding);\n                 offset += 131;\n                 if (!xstarPrefix.isEmpty()) {\n-                    this.name = xstarPrefix + \"/\" + this.name;\n+                    this.name = String.valueOf(xstarPrefix) + \"/\" + this.name;\n                 }\n                 this.aTime = fileTimeFromOptionalSeconds(this.parseOctalOrBinary(header, offset, 12, lenient));\n                 offset += 12;\n                 this.cTime = fileTimeFromOptionalSeconds(this.parseOctalOrBinary(header, offset, 12, lenient));\n                 offset += 12;\n                 break;\n             }\n             default: {\n                 final String prefix = oldStyle ? TarUtils.parseName(header, offset, 155) : TarUtils.parseName(header, offset, 155, encoding);\n                 offset += 155;\n                 if (this.isDirectory() && !this.name.endsWith(\"/\")) {\n-                    this.name += \"/\";\n+                    this.name = String.valueOf(this.name) + \"/\";\n                 }\n                 if (!prefix.isEmpty()) {\n-                    this.name = prefix + \"/\" + this.name;\n+                    this.name = String.valueOf(prefix) + \"/\" + this.name;\n                     break;\n                 }\n                 break;\n             }\n         }\n     }\n     \n     private void processPaxHeader(final String key, final String val) throws IOException {\n         this.processPaxHeader(key, val, this.extraPaxHeaders);\n     }\n     \n     private void processPaxHeader(final String key, final String val, final Map<String, String> headers) throws IOException {\n-        int n = -1;\n         switch (key.hashCode()) {\n-            case 3433509: {\n-                if (key.equals(\"path\")) {\n-                    n = 0;\n+            case -1916861932: {\n+                if (!key.equals(\"SCHILY.devmajor\")) {\n                     break;\n                 }\n-                break;\n-            }\n-            case 1195018015: {\n-                if (key.equals(\"linkpath\")) {\n-                    n = 1;\n-                    break;\n+                final int devMajor = Integer.parseInt(val);\n+                if (devMajor < 0) {\n+                    throw new IOException(\"Corrupted TAR archive. Dev-Major is negative\");\n                 }\n-                break;\n+                this.setDevMajor(devMajor);\n+                return;\n             }\n-            case 102338: {\n-                if (key.equals(\"gid\")) {\n-                    n = 2;\n+            case -1916619760: {\n+                if (!key.equals(\"SCHILY.devminor\")) {\n                     break;\n                 }\n-                break;\n-            }\n-            case 98496370: {\n-                if (key.equals(\"gname\")) {\n-                    n = 3;\n-                    break;\n+                final int devMinor = Integer.parseInt(val);\n+                if (devMinor < 0) {\n+                    throw new IOException(\"Corrupted TAR archive. Dev-Minor is negative\");\n                 }\n-                break;\n+                this.setDevMinor(devMinor);\n+                return;\n             }\n-            case 115792: {\n-                if (key.equals(\"uid\")) {\n-                    n = 4;\n+            case -277496563: {\n+                if (!key.equals(\"GNU.sparse.realsize\")) {\n                     break;\n                 }\n-                break;\n+                this.fillGNUSparse1xData(headers);\n+                return;\n             }\n-            case 111425664: {\n-                if (key.equals(\"uname\")) {\n-                    n = 5;\n+            case -160380561: {\n+                if (!key.equals(\"GNU.sparse.size\")) {\n                     break;\n                 }\n-                break;\n+                this.fillGNUSparse0xData(headers);\n+                return;\n             }\n-            case 3530753: {\n-                if (key.equals(\"size\")) {\n-                    n = 6;\n+            case 102338: {\n+                if (!key.equals(\"gid\")) {\n                     break;\n                 }\n-                break;\n+                this.setGroupId(Long.parseLong(val));\n+                return;\n             }\n-            case 104223930: {\n-                if (key.equals(\"mtime\")) {\n-                    n = 7;\n+            case 115792: {\n+                if (!key.equals(\"uid\")) {\n                     break;\n                 }\n-                break;\n+                this.setUserId(Long.parseLong(val));\n+                return;\n             }\n-            case 93141678: {\n-                if (key.equals(\"atime\")) {\n-                    n = 8;\n+            case 3433509: {\n+                if (!key.equals(\"path\")) {\n                     break;\n                 }\n-                break;\n+                this.setName(val);\n+                return;\n             }\n-            case 94988720: {\n-                if (key.equals(\"ctime\")) {\n-                    n = 9;\n+            case 3530753: {\n+                if (!key.equals(\"size\")) {\n                     break;\n                 }\n-                break;\n-            }\n-            case 304222685: {\n-                if (key.equals(\"LIBARCHIVE.creationtime\")) {\n-                    n = 10;\n-                    break;\n+                final long size = Long.parseLong(val);\n+                if (size < 0L) {\n+                    throw new IOException(\"Corrupted TAR archive. Entry size is negative\");\n                 }\n-                break;\n+                this.setSize(size);\n+                return;\n             }\n-            case -1916619760: {\n-                if (key.equals(\"SCHILY.devminor\")) {\n-                    n = 11;\n+            case 93141678: {\n+                if (!key.equals(\"atime\")) {\n                     break;\n                 }\n-                break;\n+                this.setLastAccessTime(FileTime.from(parseInstantFromDecimalSeconds(val)));\n+                return;\n             }\n-            case -1916861932: {\n-                if (key.equals(\"SCHILY.devmajor\")) {\n-                    n = 12;\n+            case 94988720: {\n+                if (!key.equals(\"ctime\")) {\n                     break;\n                 }\n-                break;\n+                this.setStatusChangeTime(FileTime.from(parseInstantFromDecimalSeconds(val)));\n+                return;\n             }\n-            case -160380561: {\n-                if (key.equals(\"GNU.sparse.size\")) {\n-                    n = 13;\n+            case 98496370: {\n+                if (!key.equals(\"gname\")) {\n                     break;\n                 }\n-                break;\n+                this.setGroupName(val);\n+                return;\n             }\n-            case -277496563: {\n-                if (key.equals(\"GNU.sparse.realsize\")) {\n-                    n = 14;\n+            case 104223930: {\n+                if (!key.equals(\"mtime\")) {\n                     break;\n                 }\n-                break;\n+                this.setLastModifiedTime(FileTime.from(parseInstantFromDecimalSeconds(val)));\n+                return;\n             }\n-            case 530706950: {\n-                if (key.equals(\"SCHILY.filetype\")) {\n-                    n = 15;\n+            case 111425664: {\n+                if (!key.equals(\"uname\")) {\n                     break;\n                 }\n-                break;\n-            }\n-        }\n-        switch (n) {\n-            case 0: {\n-                this.setName(val);\n-                break;\n-            }\n-            case 1: {\n-                this.setLinkName(val);\n-                break;\n-            }\n-            case 2: {\n-                this.setGroupId(Long.parseLong(val));\n-                break;\n-            }\n-            case 3: {\n-                this.setGroupName(val);\n-                break;\n-            }\n-            case 4: {\n-                this.setUserId(Long.parseLong(val));\n-                break;\n-            }\n-            case 5: {\n                 this.setUserName(val);\n-                break;\n+                return;\n             }\n-            case 6: {\n-                final long size = Long.parseLong(val);\n-                if (size < 0L) {\n-                    throw new IOException(\"Corrupted TAR archive. Entry size is negative\");\n+            case 304222685: {\n+                if (!key.equals(\"LIBARCHIVE.creationtime\")) {\n+                    break;\n                 }\n-                this.setSize(size);\n-                break;\n-            }\n-            case 7: {\n-                this.setLastModifiedTime(FileTime.from(parseInstantFromDecimalSeconds(val)));\n-                break;\n-            }\n-            case 8: {\n-                this.setLastAccessTime(FileTime.from(parseInstantFromDecimalSeconds(val)));\n-                break;\n-            }\n-            case 9: {\n-                this.setStatusChangeTime(FileTime.from(parseInstantFromDecimalSeconds(val)));\n-                break;\n-            }\n-            case 10: {\n                 this.setCreationTime(FileTime.from(parseInstantFromDecimalSeconds(val)));\n-                break;\n-            }\n-            case 11: {\n-                final int devMinor = Integer.parseInt(val);\n-                if (devMinor < 0) {\n-                    throw new IOException(\"Corrupted TAR archive. Dev-Minor is negative\");\n-                }\n-                this.setDevMinor(devMinor);\n-                break;\n+                return;\n             }\n-            case 12: {\n-                final int devMajor = Integer.parseInt(val);\n-                if (devMajor < 0) {\n-                    throw new IOException(\"Corrupted TAR archive. Dev-Major is negative\");\n+            case 530706950: {\n+                if (!key.equals(\"SCHILY.filetype\")) {\n+                    break;\n                 }\n-                this.setDevMajor(devMajor);\n-                break;\n-            }\n-            case 13: {\n-                this.fillGNUSparse0xData(headers);\n-                break;\n-            }\n-            case 14: {\n-                this.fillGNUSparse1xData(headers);\n-                break;\n-            }\n-            case 15: {\n                 if (\"sparse\".equals(val)) {\n                     this.fillStarSparseData(headers);\n-                    break;\n                 }\n-                break;\n+                return;\n             }\n-            default: {\n-                this.extraPaxHeaders.put(key, val);\n-                break;\n+            case 1195018015: {\n+                if (!key.equals(\"linkpath\")) {\n+                    break;\n+                }\n+                this.setLinkName(val);\n+                return;\n             }\n         }\n+        this.extraPaxHeaders.put(key, val);\n     }\n     \n     private void readFileMode(final Path file, final String normalizedName, final LinkOption... options) throws IOException {\n         if (Files.isDirectory(file, options)) {\n             this.mode = 16877;\n             this.linkFlag = 53;\n             final int nameLength = normalizedName.length();\n             if (nameLength == 0 || normalizedName.charAt(nameLength - 1) != '/') {\n-                this.name = normalizedName + \"/\";\n+                this.name = String.valueOf(normalizedName) + \"/\";\n             }\n             else {\n                 this.name = normalizedName;\n             }\n         }\n         else {\n             this.mode = 33188;\n@@ -1106,15 +1062,15 @@\n         }\n     }\n     \n     public void writeEntryHeader(final byte[] outbuf) {\n         try {\n             this.writeEntryHeader(outbuf, TarUtils.DEFAULT_ENCODING, false);\n         }\n-        catch (final IOException ex) {\n+        catch (final IOException ex3) {\n             try {\n                 this.writeEntryHeader(outbuf, TarUtils.FALLBACK_ENCODING, false);\n             }\n             catch (final IOException ex2) {\n                 throw new UncheckedIOException(ex2);\n             }\n         }\n@@ -1162,12 +1118,8 @@\n             offset = this.writeEntryHeaderField(time.to(TimeUnit.SECONDS), outbuf, offset, fieldLength, true);\n         }\n         else {\n             offset = this.fill(0, offset, outbuf, fieldLength);\n         }\n         return offset;\n     }\n-    \n-    static {\n-        EMPTY_TAR_ARCHIVE_ENTRY_ARRAY = new TarArchiveEntry[0];\n-    }\n }\n"}]}
