{"diffoscope-json-version": 1, "source1": "first/TarFile.class", "source2": "second/TarFile.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -107,15 +107,15 @@\n         }\n         if (this.currEntry != null) {\n             this.repositionForwardTo(this.currEntry.getDataOffset() + this.currEntry.getSize());\n             this.throwExceptionIfPositionIsNotInArchive();\n             this.skipRecordPadding();\n         }\n         final ByteBuffer headerBuf = this.getRecord();\n-        if (null == headerBuf) {\n+        if (headerBuf == null) {\n             return this.currEntry = null;\n         }\n         try {\n             final long position = this.archive.position();\n             this.currEntry = new TarArchiveEntry((Map)this.globalPaxHeaders, headerBuf.array(), this.zipEncoding, this.lenient, position);\n         }\n         catch (final IllegalArgumentException e) {\n@@ -132,15 +132,15 @@\n             final byte[] longNameData = this.getLongNameData();\n             if (longNameData == null) {\n                 return null;\n             }\n             final String name = this.zipEncoding.decode(longNameData);\n             this.currEntry.setName(name);\n             if (this.currEntry.isDirectory() && !name.endsWith(\"/\")) {\n-                this.currEntry.setName(name + \"/\");\n+                this.currEntry.setName(String.valueOf(name) + \"/\");\n             }\n         }\n         if (this.currEntry.isGlobalPaxHeader()) {\n             this.readGlobalPaxHeaders();\n         }\n         try {\n             if (this.currEntry.isPaxHeader()) {\n@@ -205,52 +205,136 @@\n     private void applyPaxHeadersToCurrentEntry(final Map<String, String> headers, final List<TarArchiveStructSparse> sparseHeaders) throws IOException {\n         this.currEntry.updateEntryFromPaxHeaders((Map)headers);\n         this.currEntry.setSparseHeaders((List)sparseHeaders);\n     }\n     \n     private void paxHeaders() throws IOException {\n         List<TarArchiveStructSparse> sparseHeaders = new ArrayList<TarArchiveStructSparse>();\n+        Throwable t = null;\n         Map<String, String> headers;\n-        try (final InputStream input = this.getInputStream(this.currEntry)) {\n-            headers = TarUtils.parsePaxHeaders(input, (List)sparseHeaders, (Map)this.globalPaxHeaders, this.currEntry.getSize());\n+        try {\n+            final InputStream input = this.getInputStream(this.currEntry);\n+            try {\n+                headers = TarUtils.parsePaxHeaders(input, (List)sparseHeaders, (Map)this.globalPaxHeaders, this.currEntry.getSize());\n+            }\n+            finally {\n+                if (input != null) {\n+                    input.close();\n+                }\n+            }\n+        }\n+        finally {\n+            if (t == null) {\n+                final Throwable exception;\n+                t = exception;\n+            }\n+            else {\n+                final Throwable exception;\n+                if (t != exception) {\n+                    t.addSuppressed(exception);\n+                }\n+            }\n         }\n         if (headers.containsKey(\"GNU.sparse.map\")) {\n             sparseHeaders = new ArrayList<TarArchiveStructSparse>(TarUtils.parseFromPAX01SparseHeaders((String)headers.get(\"GNU.sparse.map\")));\n         }\n         this.getNextTarEntry();\n         if (this.currEntry == null) {\n             throw new IOException(\"premature end of tar archive. Didn't find any entry after PAX header.\");\n         }\n         this.applyPaxHeadersToCurrentEntry(headers, sparseHeaders);\n         if (this.currEntry.isPaxGNU1XSparse()) {\n-            try (final InputStream input = this.getInputStream(this.currEntry)) {\n-                sparseHeaders = TarUtils.parsePAX1XSparseHeaders(input, this.recordSize);\n+            Throwable t2 = null;\n+            try {\n+                final InputStream input = this.getInputStream(this.currEntry);\n+                try {\n+                    sparseHeaders = TarUtils.parsePAX1XSparseHeaders(input, this.recordSize);\n+                }\n+                finally {\n+                    if (input != null) {\n+                        input.close();\n+                    }\n+                }\n+            }\n+            finally {\n+                if (t2 == null) {\n+                    final Throwable exception2;\n+                    t2 = exception2;\n+                }\n+                else {\n+                    final Throwable exception2;\n+                    if (t2 != exception2) {\n+                        t2.addSuppressed(exception2);\n+                    }\n+                }\n             }\n             this.currEntry.setSparseHeaders((List)sparseHeaders);\n             this.currEntry.setDataOffset(this.currEntry.getDataOffset() + (long)this.recordSize);\n         }\n         this.buildSparseInputStreams();\n     }\n     \n     private void readGlobalPaxHeaders() throws IOException {\n-        try (final InputStream input = this.getInputStream(this.currEntry)) {\n-            this.globalPaxHeaders = TarUtils.parsePaxHeaders(input, (List)this.globalSparseHeaders, (Map)this.globalPaxHeaders, this.currEntry.getSize());\n+        Throwable t = null;\n+        try {\n+            final InputStream input = this.getInputStream(this.currEntry);\n+            try {\n+                this.globalPaxHeaders = TarUtils.parsePaxHeaders(input, (List)this.globalSparseHeaders, (Map)this.globalPaxHeaders, this.currEntry.getSize());\n+            }\n+            finally {\n+                if (input != null) {\n+                    input.close();\n+                }\n+            }\n+        }\n+        finally {\n+            if (t == null) {\n+                final Throwable exception;\n+                t = exception;\n+            }\n+            else {\n+                final Throwable exception;\n+                if (t != exception) {\n+                    t.addSuppressed(exception);\n+                }\n+            }\n         }\n         this.getNextTarEntry();\n         if (this.currEntry == null) {\n             throw new IOException(\"Error detected parsing the pax header\");\n         }\n     }\n     \n     private byte[] getLongNameData() throws IOException {\n         final ByteArrayOutputStream longName = new ByteArrayOutputStream();\n-        try (final InputStream in = this.getInputStream(this.currEntry)) {\n-            int length;\n-            while ((length = in.read(this.smallBuf)) >= 0) {\n-                longName.write(this.smallBuf, 0, length);\n+        Throwable t = null;\n+        try {\n+            final InputStream in = this.getInputStream(this.currEntry);\n+            try {\n+                int length;\n+                while ((length = in.read(this.smallBuf)) >= 0) {\n+                    longName.write(this.smallBuf, 0, length);\n+                }\n+            }\n+            finally {\n+                if (in != null) {\n+                    in.close();\n+                }\n+            }\n+        }\n+        finally {\n+            if (t == null) {\n+                final Throwable exception;\n+                t = exception;\n+            }\n+            else {\n+                final Throwable exception;\n+                if (t != exception) {\n+                    t.addSuppressed(exception);\n+                }\n             }\n         }\n         this.getNextTarEntry();\n         if (this.currEntry == null) {\n             return null;\n         }\n         int length;\n@@ -308,14 +392,17 @@\n             shouldReset = !this.isEOFRecord(this.readRecord());\n         }\n         finally {\n             if (shouldReset) {\n                 this.archive.position(this.archive.position() - (long)this.recordSize);\n             }\n         }\n+        if (shouldReset) {\n+            this.archive.position(this.archive.position() - (long)this.recordSize);\n+        }\n     }\n     \n     private void consumeRemainderOfLastBlock() throws IOException {\n         final long bytesReadOfLastBlock = this.archive.position() % this.blockSize;\n         if (bytesReadOfLastBlock > 0L) {\n             this.repositionForwardBy((long)this.blockSize - bytesReadOfLastBlock);\n         }\n"}]}
