{"diffoscope-json-version": 1, "source1": "first/Pass2Verifier.class", "source2": "second/Pass2Verifier.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,22 +1,20 @@\n \n package org.apache.bcel.verifier.statics;\n \n import org.apache.bcel.classfile.Method;\n-import java.util.Map;\n import java.util.HashMap;\n import org.apache.bcel.classfile.Visitor;\n import org.apache.bcel.classfile.DescendingVisitor;\n-import java.util.Set;\n+import org.apache.bcel.classfile.JavaClass;\n import org.apache.bcel.verifier.VerifierFactory;\n import org.apache.bcel.generic.Type;\n import java.util.HashSet;\n import org.apache.bcel.verifier.exc.ClassConstraintException;\n import org.apache.bcel.verifier.VerificationResult;\n-import org.apache.bcel.classfile.JavaClass;\n import org.apache.bcel.verifier.exc.AssertionViolatedException;\n import org.apache.bcel.Repository;\n import java.util.Objects;\n import org.apache.bcel.classfile.Node;\n import org.apache.bcel.verifier.Verifier;\n import org.apache.bcel.Constants;\n import org.apache.bcel.verifier.PassVerifier;\n@@ -75,119 +73,112 @@\n     \n     public Pass2Verifier(final Verifier verifier) {\n         this.verifier = verifier;\n     }\n     \n     private void constantPoolEntriesSatisfyStaticConstraints() {\n         try {\n-            final JavaClass jc = Repository.lookupClass(this.verifier.getClassName());\n-            new Pass2Verifier.CPESSC_Visitor(this, jc, (Pass2Verifier.Pass2Verifier$1)null);\n+            new Pass2Verifier.CPESSC_Visitor(this, Repository.lookupClass(this.verifier.getClassName()), (Pass2Verifier.Pass2Verifier$1)null);\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj, (Throwable)obj);\n         }\n     }\n     \n     public VerificationResult do_verify() {\n         try {\n-            final VerificationResult vr1 = this.verifier.doPass1();\n-            if (vr1.equals((Object)VerificationResult.VR_OK)) {\n+            if (this.verifier.doPass1().equals((Object)VerificationResult.VR_OK)) {\n                 this.localVariablesInfos = new LocalVariablesInfo[Repository.lookupClass(this.verifier.getClassName()).getMethods().length];\n-                VerificationResult vr2 = VerificationResult.VR_OK;\n+                VerificationResult vr_OK = VerificationResult.VR_OK;\n                 try {\n                     this.constantPoolEntriesSatisfyStaticConstraints();\n                     this.fieldAndMethodRefsAreValid();\n                     this.everyClassHasAnAccessibleSuperclass();\n                     this.finalMethodsAreNotOverridden();\n                 }\n-                catch (final ClassConstraintException cce) {\n-                    vr2 = new VerificationResult(2, cce.getMessage());\n+                catch (final ClassConstraintException ex) {\n+                    vr_OK = new VerificationResult(2, ex.getMessage());\n                 }\n-                return vr2;\n+                return vr_OK;\n             }\n             return VerificationResult.VR_NOTYET;\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj, (Throwable)obj);\n         }\n     }\n     \n     private void everyClassHasAnAccessibleSuperclass() {\n         try {\n-            final Set<String> hs = new HashSet<String>();\n-            JavaClass jc = Repository.lookupClass(this.verifier.getClassName());\n-            int supidx = -1;\n-            while (supidx != 0) {\n-                supidx = jc.getSuperclassNameIndex();\n-                if (supidx == 0) {\n-                    if (jc != Repository.lookupClass(Type.OBJECT.getClassName())) {\n-                        throw new ClassConstraintException(\"Superclass of '\" + jc.getClassName() + \"' missing but not \" + Type.OBJECT.getClassName() + \" itself!\");\n+            final HashSet set = new HashSet();\n+            JavaClass javaClass = Repository.lookupClass(this.verifier.getClassName());\n+            int i = -1;\n+            while (i != 0) {\n+                i = javaClass.getSuperclassNameIndex();\n+                if (i == 0) {\n+                    if (javaClass != Repository.lookupClass(Type.OBJECT.getClassName())) {\n+                        throw new ClassConstraintException(\"Superclass of '\" + javaClass.getClassName() + \"' missing but not \" + Type.OBJECT.getClassName() + \" itself!\");\n                     }\n                     continue;\n                 }\n                 else {\n-                    final String supername = jc.getSuperclassName();\n-                    if (!hs.add(supername)) {\n+                    final String superclassName = javaClass.getSuperclassName();\n+                    if (!set.add(superclassName)) {\n                         throw new ClassConstraintException(\"Circular superclass hierarchy detected.\");\n                     }\n-                    final Verifier v = VerifierFactory.getVerifier(supername);\n-                    final VerificationResult vr = v.doPass1();\n-                    if (vr != VerificationResult.VR_OK) {\n-                        throw new ClassConstraintException(\"Could not load in ancestor class '\" + supername + \"'.\");\n-                    }\n-                    jc = Repository.lookupClass(supername);\n-                    if (jc.isFinal()) {\n-                        throw new ClassConstraintException(\"Ancestor class '\" + supername + \"' has the FINAL access modifier and must therefore not be subclassed.\");\n+                    if (VerifierFactory.getVerifier(superclassName).doPass1() != VerificationResult.VR_OK) {\n+                        throw new ClassConstraintException(\"Could not load in ancestor class '\" + superclassName + \"'.\");\n+                    }\n+                    javaClass = Repository.lookupClass(superclassName);\n+                    if (javaClass.isFinal()) {\n+                        throw new ClassConstraintException(\"Ancestor class '\" + superclassName + \"' has the FINAL access modifier and must therefore not be subclassed.\");\n                     }\n                     continue;\n                 }\n             }\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj, (Throwable)obj);\n         }\n     }\n     \n     private void fieldAndMethodRefsAreValid() {\n         try {\n-            final JavaClass jc = Repository.lookupClass(this.verifier.getClassName());\n-            final DescendingVisitor v = new DescendingVisitor(jc, (Visitor)new Pass2Verifier.FAMRAV_Visitor(this, jc, (Pass2Verifier.Pass2Verifier$1)null));\n-            v.visit();\n+            final JavaClass lookupClass = Repository.lookupClass(this.verifier.getClassName());\n+            new DescendingVisitor(lookupClass, (Visitor)new Pass2Verifier.FAMRAV_Visitor(this, lookupClass, (Pass2Verifier.Pass2Verifier$1)null)).visit();\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj, (Throwable)obj);\n         }\n     }\n     \n     private void finalMethodsAreNotOverridden() {\n         try {\n-            final Map<String, String> map = new HashMap<String, String>();\n-            JavaClass jc = Repository.lookupClass(this.verifier.getClassName());\n-            int supidx = -1;\n-            while (supidx != 0) {\n-                supidx = jc.getSuperclassNameIndex();\n-                final Method[] methods2;\n-                final Method[] methods = methods2 = jc.getMethods();\n-                for (final Method method : methods2) {\n-                    final String nameAndSig = method.getName() + method.getSignature();\n-                    if (map.containsKey(nameAndSig) && method.isFinal()) {\n+            final HashMap hashMap = new HashMap();\n+            JavaClass javaClass = Repository.lookupClass(this.verifier.getClassName());\n+            int i = -1;\n+            while (i != 0) {\n+                i = javaClass.getSuperclassNameIndex();\n+                for (final Method method : javaClass.getMethods()) {\n+                    final String string = method.getName() + method.getSignature();\n+                    if (hashMap.containsKey(string) && method.isFinal()) {\n                         if (!method.isPrivate()) {\n-                            throw new ClassConstraintException(\"Method '\" + nameAndSig + \"' in class '\" + map.get(nameAndSig) + \"' overrides the final (not-overridable) definition in class '\" + jc.getClassName() + \"'.\");\n+                            throw new ClassConstraintException(\"Method '\" + string + \"' in class '\" + (String)hashMap.get(string) + \"' overrides the final (not-overridable) definition in class '\" + javaClass.getClassName() + \"'.\");\n                         }\n-                        this.addMessage(\"Method '\" + nameAndSig + \"' in class '\" + map.get(nameAndSig) + \"' overrides the final (not-overridable) definition in class '\" + jc.getClassName() + \"'. This is okay, as the original definition was private; however this constraint leverage was introduced by JLS 8.4.6 (not vmspec2) and the behavior of the Sun verifiers.\");\n+                        this.addMessage(\"Method '\" + string + \"' in class '\" + (String)hashMap.get(string) + \"' overrides the final (not-overridable) definition in class '\" + javaClass.getClassName() + \"'. This is okay, as the original definition was private; however this constraint leverage was introduced by JLS 8.4.6 (not vmspec2) and the behavior of the Sun verifiers.\");\n                     }\n                     else if (!method.isStatic()) {\n-                        map.put(nameAndSig, jc.getClassName());\n+                        hashMap.put(string, javaClass.getClassName());\n                     }\n                 }\n-                jc = Repository.lookupClass(jc.getSuperclassName());\n+                javaClass = Repository.lookupClass(javaClass.getSuperclassName());\n             }\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj, (Throwable)obj);\n         }\n     }\n     \n     public LocalVariablesInfo getLocalVariablesInfo(final int methodNr) {\n         if (this.verify() != VerificationResult.VR_OK) {\n             return null;\n         }\n"}]}
