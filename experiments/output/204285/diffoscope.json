{"diffoscope-json-version": 1, "source1": "first/CpioUtil.class", "source2": "second/CpioUtil.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,51 +1,48 @@\n \n package org.apache.commons.compress.archivers.cpio;\n \n import java.util.Arrays;\n \n class CpioUtil\n {\n-    static long byteArray2long(final byte[] number, final boolean swapHalfWord) {\n-        if (number.length % 2 != 0) {\n+    static long byteArray2long(final byte[] original, final boolean b) {\n+        if (original.length % 2 != 0) {\n             throw new UnsupportedOperationException();\n         }\n-        int pos = 0;\n-        final byte[] tmpNumber = Arrays.copyOf(number, number.length);\n-        if (!swapHalfWord) {\n-            byte tmp;\n-            for (tmp = 0, pos = 0; pos < tmpNumber.length; tmpNumber[pos++] = tmpNumber[pos], tmpNumber[pos] = tmp, ++pos) {\n-                tmp = tmpNumber[pos];\n+        final byte[] copy = Arrays.copyOf(original, original.length);\n+        if (!b) {\n+            byte b2;\n+            for (int i = 0; i < copy.length; copy[i++] = copy[i], copy[i] = b2, ++i) {\n+                b2 = copy[i];\n             }\n         }\n-        long ret = (long)(tmpNumber[0] & 0xFF);\n-        for (pos = 1; pos < tmpNumber.length; ++pos) {\n-            ret <<= 8;\n-            ret |= (tmpNumber[pos] & 0xFF);\n+        long n = (long)(copy[0] & 0xFF);\n+        for (int j = 1; j < copy.length; ++j) {\n+            n = (n << 8 | (long)(copy[j] & 0xFF));\n         }\n-        return ret;\n+        return n;\n     }\n     \n-    static long fileType(final long mode) {\n-        return mode & 0xF000L;\n+    static long fileType(final long n) {\n+        return n & 0xF000L;\n     }\n     \n-    static byte[] long2byteArray(final long number, final int length, final boolean swapHalfWord) {\n-        final byte[] ret = new byte[length];\n-        int pos = 0;\n-        if (length % 2 != 0 || length < 2) {\n+    static byte[] long2byteArray(final long n, final int n2, final boolean b) {\n+        final byte[] array = new byte[n2];\n+        if (n2 % 2 != 0 || n2 < 2) {\n             throw new UnsupportedOperationException();\n         }\n-        long tmp_number = number;\n-        for (pos = length - 1; pos >= 0; --pos) {\n-            ret[pos] = (byte)(tmp_number & 0xFFL);\n-            tmp_number >>= 8;\n-        }\n-        if (!swapHalfWord) {\n-            byte tmp;\n-            for (tmp = 0, pos = 0; pos < length; ret[pos++] = ret[pos], ret[pos] = tmp, ++pos) {\n-                tmp = ret[pos];\n+        long n3 = n;\n+        for (int i = n2 - 1; i >= 0; --i) {\n+            array[i] = (byte)(n3 & 0xFFL);\n+            n3 >>= 8;\n+        }\n+        if (!b) {\n+            byte b2;\n+            for (int j = 0; j < n2; array[j++] = array[j], array[j] = b2, ++j) {\n+                b2 = array[j];\n             }\n         }\n-        return ret;\n+        return array;\n     }\n }\n"}]}
