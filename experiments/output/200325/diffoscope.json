{"diffoscope-json-version": 1, "source1": "first/Pass3bVerifier.class", "source2": "second/Pass3bVerifier.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -33,188 +33,179 @@\n     private final int methodNo;\n     \n     public Pass3bVerifier(final Verifier myOwner, final int methodNo) {\n         this.myOwner = myOwner;\n         this.methodNo = methodNo;\n     }\n     \n-    private void circulationPump(final MethodGen m, final ControlFlowGraph cfg, final InstructionContext start, final Frame vanillaFrame, final InstConstraintVisitor icv, final ExecutionVisitor ev) {\n+    private void circulationPump(final MethodGen methodGen, final ControlFlowGraph controlFlowGraph, final InstructionContext instructionContext, final Frame frame, final InstConstraintVisitor instConstraintVisitor, final ExecutionVisitor executionVisitor) {\n         final Random random = new Random();\n-        final Pass3bVerifier.InstructionContextQueue icq = new Pass3bVerifier.InstructionContextQueue((Pass3bVerifier.Pass3bVerifier$1)null);\n-        start.execute(vanillaFrame, new ArrayList(), icv, ev);\n-        icq.add(start, new ArrayList());\n-        while (!icq.isEmpty()) {\n-            final InstructionContext u = icq.getIC(0);\n-            final ArrayList<InstructionContext> ec = icq.getEC(0);\n-            icq.remove(0);\n-            final ArrayList<InstructionContext> oldchain = (ArrayList)ec.clone();\n-            final ArrayList<InstructionContext> newchain = (ArrayList)ec.clone();\n-            newchain.add(u);\n-            if (u.getInstruction().getInstruction() instanceof RET) {\n-                final RET ret = (RET)u.getInstruction().getInstruction();\n-                final ReturnaddressType t = (ReturnaddressType)u.getOutFrame((ArrayList)oldchain).getLocals().get(ret.getIndex());\n-                final InstructionContext theSuccessor = cfg.contextOf(t.getTarget());\n-                InstructionContext lastJSR = null;\n-                int skipJsr = 0;\n-                for (int ss = oldchain.size() - 1; ss >= 0; --ss) {\n-                    if (skipJsr < 0) {\n+        final Pass3bVerifier.InstructionContextQueue instructionContextQueue = new Pass3bVerifier.InstructionContextQueue((Pass3bVerifier.Pass3bVerifier$1)null);\n+        instructionContext.execute(frame, new ArrayList(), instConstraintVisitor, executionVisitor);\n+        instructionContextQueue.add(instructionContext, new ArrayList());\n+        while (!instructionContextQueue.isEmpty()) {\n+            final InstructionContext ic = instructionContextQueue.getIC(0);\n+            final ArrayList ec = instructionContextQueue.getEC(0);\n+            instructionContextQueue.remove(0);\n+            final ArrayList obj = (ArrayList)ec.clone();\n+            final ArrayList list = (ArrayList)ec.clone();\n+            list.add(ic);\n+            if (ic.getInstruction().getInstruction() instanceof RET) {\n+                final InstructionContext context = controlFlowGraph.contextOf(((ReturnaddressType)ic.getOutFrame(obj).getLocals().get(((RET)ic.getInstruction().getInstruction()).getIndex())).getTarget());\n+                InstructionContext instructionContext2 = null;\n+                int n = 0;\n+                for (int i = obj.size() - 1; i >= 0; --i) {\n+                    if (n < 0) {\n                         throw new AssertionViolatedException(\"More RET than JSR in execution chain?!\");\n                     }\n-                    if (((InstructionContext)oldchain.get(ss)).getInstruction().getInstruction() instanceof JsrInstruction) {\n-                        if (skipJsr == 0) {\n-                            lastJSR = oldchain.get(ss);\n+                    if (((InstructionContext)obj.get(i)).getInstruction().getInstruction() instanceof JsrInstruction) {\n+                        if (n == 0) {\n+                            instructionContext2 = (InstructionContext)obj.get(i);\n                             break;\n                         }\n-                        --skipJsr;\n+                        --n;\n                     }\n-                    if (((InstructionContext)oldchain.get(ss)).getInstruction().getInstruction() instanceof RET) {\n-                        ++skipJsr;\n+                    if (((InstructionContext)obj.get(i)).getInstruction().getInstruction() instanceof RET) {\n+                        ++n;\n                     }\n                 }\n-                if (lastJSR == null) {\n-                    throw new AssertionViolatedException(\"RET without a JSR before in ExecutionChain?! EC: '\" + oldchain + \"'.\");\n+                if (instructionContext2 == null) {\n+                    throw new AssertionViolatedException(\"RET without a JSR before in ExecutionChain?! EC: '\" + obj + \"'.\");\n                 }\n-                final JsrInstruction jsr = (JsrInstruction)lastJSR.getInstruction().getInstruction();\n-                if (theSuccessor != cfg.contextOf(jsr.physicalSuccessor())) {\n-                    throw new AssertionViolatedException(\"RET '\" + u.getInstruction() + \"' info inconsistent: jump back to '\" + theSuccessor + \"' or '\" + cfg.contextOf(jsr.physicalSuccessor()) + \"'?\");\n+                final JsrInstruction jsrInstruction = (JsrInstruction)instructionContext2.getInstruction().getInstruction();\n+                if (context != controlFlowGraph.contextOf(jsrInstruction.physicalSuccessor())) {\n+                    throw new AssertionViolatedException(\"RET '\" + ic.getInstruction() + \"' info inconsistent: jump back to '\" + context + \"' or '\" + controlFlowGraph.contextOf(jsrInstruction.physicalSuccessor()) + \"'?\");\n                 }\n-                if (theSuccessor.execute(u.getOutFrame((ArrayList)oldchain), (ArrayList)newchain, icv, ev)) {\n-                    final ArrayList<InstructionContext> newchainClone = (ArrayList)newchain.clone();\n-                    icq.add(theSuccessor, (ArrayList)newchainClone);\n+                if (context.execute(ic.getOutFrame(obj), list, instConstraintVisitor, executionVisitor)) {\n+                    instructionContextQueue.add(context, (ArrayList)list.clone());\n                 }\n             }\n             else {\n-                final InstructionContext[] successors;\n-                final InstructionContext[] succs = successors = u.getSuccessors();\n-                for (final InstructionContext v : successors) {\n-                    if (v.execute(u.getOutFrame((ArrayList)oldchain), (ArrayList)newchain, icv, ev)) {\n-                        final ArrayList<InstructionContext> newchainClone2 = (ArrayList)newchain.clone();\n-                        icq.add(v, (ArrayList)newchainClone2);\n+                for (final InstructionContext instructionContext3 : ic.getSuccessors()) {\n+                    if (instructionContext3.execute(ic.getOutFrame(obj), list, instConstraintVisitor, executionVisitor)) {\n+                        instructionContextQueue.add(instructionContext3, (ArrayList)list.clone());\n                     }\n                 }\n             }\n-            final ExceptionHandler[] exceptionHandlers;\n-            final ExceptionHandler[] excHds = exceptionHandlers = u.getExceptionHandlers();\n-            for (final ExceptionHandler excHd : exceptionHandlers) {\n-                final InstructionContext v2 = cfg.contextOf(excHd.getHandlerStart());\n-                if (v2.execute(new Frame(u.getOutFrame((ArrayList)oldchain).getLocals(), new OperandStack(u.getOutFrame((ArrayList)oldchain).getStack().maxStack(), (excHd.getExceptionType() == null) ? Type.THROWABLE : excHd.getExceptionType())), new ArrayList(), icv, ev)) {\n-                    icq.add(v2, new ArrayList());\n+            for (final ExceptionHandler exceptionHandler : ic.getExceptionHandlers()) {\n+                final InstructionContext context2 = controlFlowGraph.contextOf(exceptionHandler.getHandlerStart());\n+                if (context2.execute(new Frame(ic.getOutFrame(obj).getLocals(), new OperandStack(ic.getOutFrame(obj).getStack().maxStack(), (exceptionHandler.getExceptionType() == null) ? Type.THROWABLE : exceptionHandler.getExceptionType())), new ArrayList(), instConstraintVisitor, executionVisitor)) {\n+                    instructionContextQueue.add(context2, new ArrayList());\n                 }\n             }\n         }\n-        InstructionHandle ih = start.getInstruction();\n+        InstructionHandle instructionHandle = instructionContext.getInstruction();\n         do {\n-            if (ih.getInstruction() instanceof ReturnInstruction && !cfg.isDead(ih)) {\n-                final InstructionContext ic = cfg.contextOf(ih);\n-                final Frame f = ic.getOutFrame(new ArrayList());\n-                final LocalVariables lvs = f.getLocals();\n-                for (int i = 0; i < lvs.maxLocals(); ++i) {\n-                    if (lvs.get(i) instanceof UninitializedObjectType) {\n-                        this.addMessage(\"Warning: ReturnInstruction '\" + ic + \"' may leave method with an uninitialized object in the local variables array '\" + lvs + \"'.\");\n-                    }\n-                }\n-                final OperandStack os = f.getStack();\n-                for (int j = 0; j < os.size(); ++j) {\n-                    if (os.peek(j) instanceof UninitializedObjectType) {\n-                        this.addMessage(\"Warning: ReturnInstruction '\" + ic + \"' may leave method with an uninitialized object on the operand stack '\" + os + \"'.\");\n-                    }\n-                }\n-                Type returnedType = null;\n-                final OperandStack inStack = ic.getInFrame().getStack();\n-                if (inStack.size() >= 1) {\n-                    returnedType = inStack.peek();\n+            if (instructionHandle.getInstruction() instanceof ReturnInstruction && !controlFlowGraph.isDead(instructionHandle)) {\n+                final InstructionContext context3 = controlFlowGraph.contextOf(instructionHandle);\n+                final Frame outFrame = context3.getOutFrame(new ArrayList());\n+                final LocalVariables locals = outFrame.getLocals();\n+                for (int l = 0; l < locals.maxLocals(); ++l) {\n+                    if (locals.get(l) instanceof UninitializedObjectType) {\n+                        this.addMessage(\"Warning: ReturnInstruction '\" + context3 + \"' may leave method with an uninitialized object in the local variables array '\" + locals + \"'.\");\n+                    }\n+                }\n+                final OperandStack stack = outFrame.getStack();\n+                for (int n2 = 0; n2 < stack.size(); ++n2) {\n+                    if (stack.peek(n2) instanceof UninitializedObjectType) {\n+                        this.addMessage(\"Warning: ReturnInstruction '\" + context3 + \"' may leave method with an uninitialized object on the operand stack '\" + stack + \"'.\");\n+                    }\n+                }\n+                final OperandStack stack2 = context3.getInFrame().getStack();\n+                Object o;\n+                if (stack2.size() >= 1) {\n+                    o = stack2.peek();\n                 }\n                 else {\n-                    returnedType = (Type)Type.VOID;\n+                    o = Type.VOID;\n                 }\n-                if (returnedType == null) {\n+                if (o == null) {\n                     continue;\n                 }\n-                if (returnedType instanceof ReferenceType) {\n+                if (o instanceof ReferenceType) {\n                     try {\n-                        if (((ReferenceType)returnedType).isCastableTo(m.getReturnType())) {\n+                        if (((ReferenceType)o).isCastableTo(methodGen.getReturnType())) {\n                             continue;\n                         }\n-                        this.invalidReturnTypeError(returnedType, m);\n+                        this.invalidReturnTypeError((Type)o, methodGen);\n                         continue;\n                     }\n-                    catch (final ClassNotFoundException e) {\n-                        throw new IllegalArgumentException(e);\n+                    catch (final ClassNotFoundException cause) {\n+                        throw new IllegalArgumentException(cause);\n                     }\n                 }\n-                if (returnedType.equals((Object)m.getReturnType().normalizeForStackOrLocal())) {\n+                if (((Type)o).equals((Object)methodGen.getReturnType().normalizeForStackOrLocal())) {\n                     continue;\n                 }\n-                this.invalidReturnTypeError(returnedType, m);\n+                this.invalidReturnTypeError((Type)o, methodGen);\n             }\n-        } while ((ih = ih.getNext()) != null);\n+        } while ((instructionHandle = instructionHandle.getNext()) != null);\n     }\n     \n     public VerificationResult do_verify() {\n         if (!this.myOwner.doPass3a(this.methodNo).equals((Object)VerificationResult.VR_OK)) {\n             return VerificationResult.VR_NOTYET;\n         }\n-        JavaClass jc;\n+        JavaClass lookupClass;\n         try {\n-            jc = Repository.lookupClass(this.myOwner.getClassName());\n+            lookupClass = Repository.lookupClass(this.myOwner.getClassName());\n         }\n-        catch (final ClassNotFoundException e) {\n-            throw new AssertionViolatedException(\"Missing class: \" + e, (Throwable)e);\n+        catch (final ClassNotFoundException obj) {\n+            throw new AssertionViolatedException(\"Missing class: \" + obj, (Throwable)obj);\n         }\n-        final ConstantPoolGen constantPoolGen = new ConstantPoolGen(jc.getConstantPool());\n-        final InstConstraintVisitor icv = new InstConstraintVisitor();\n-        icv.setConstantPoolGen(constantPoolGen);\n-        final ExecutionVisitor ev = new ExecutionVisitor();\n-        ev.setConstantPoolGen(constantPoolGen);\n-        final Method[] methods = jc.getMethods();\n+        final ConstantPoolGen constantPoolGen = new ConstantPoolGen(lookupClass.getConstantPool());\n+        final InstConstraintVisitor instConstraintVisitor = new InstConstraintVisitor();\n+        instConstraintVisitor.setConstantPoolGen(constantPoolGen);\n+        final ExecutionVisitor executionVisitor = new ExecutionVisitor();\n+        executionVisitor.setConstantPoolGen(constantPoolGen);\n+        final Method[] methods = lookupClass.getMethods();\n         try {\n-            final MethodGen mg = new MethodGen(methods[this.methodNo], this.myOwner.getClassName(), constantPoolGen);\n-            icv.setMethodGen(mg);\n-            if (!mg.isAbstract() && !mg.isNative()) {\n-                final ControlFlowGraph cfg = new ControlFlowGraph(mg);\n-                final Frame f = new Frame(mg.getMaxLocals(), mg.getMaxStack());\n-                if (!mg.isStatic()) {\n-                    if (mg.getName().equals(\"<init>\")) {\n-                        Frame.setThis(new UninitializedObjectType(ObjectType.getInstance(jc.getClassName())));\n-                        f.getLocals().set(0, (Type)Frame.getThis());\n+            final MethodGen methodGen = new MethodGen(methods[this.methodNo], this.myOwner.getClassName(), constantPoolGen);\n+            instConstraintVisitor.setMethodGen(methodGen);\n+            if (!methodGen.isAbstract() && !methodGen.isNative()) {\n+                final ControlFlowGraph controlFlowGraph = new ControlFlowGraph(methodGen);\n+                final Frame frame = new Frame(methodGen.getMaxLocals(), methodGen.getMaxStack());\n+                if (!methodGen.isStatic()) {\n+                    if (methodGen.getName().equals(\"<init>\")) {\n+                        Frame.setThis(new UninitializedObjectType(ObjectType.getInstance(lookupClass.getClassName())));\n+                        frame.getLocals().set(0, (Type)Frame.getThis());\n                     }\n                     else {\n                         Frame.setThis((UninitializedObjectType)null);\n-                        f.getLocals().set(0, (Type)ObjectType.getInstance(jc.getClassName()));\n+                        frame.getLocals().set(0, (Type)ObjectType.getInstance(lookupClass.getClassName()));\n                     }\n                 }\n-                final Type[] argtypes = mg.getArgumentTypes();\n-                int twoslotoffset = 0;\n-                for (int j = 0; j < argtypes.length; ++j) {\n-                    if (argtypes[j] == Type.SHORT || argtypes[j] == Type.BYTE || argtypes[j] == Type.CHAR || argtypes[j] == Type.BOOLEAN) {\n-                        argtypes[j] = (Type)Type.INT;\n+                final Type[] argumentTypes = methodGen.getArgumentTypes();\n+                int n = 0;\n+                for (int i = 0; i < argumentTypes.length; ++i) {\n+                    if (argumentTypes[i] == Type.SHORT || argumentTypes[i] == Type.BYTE || argumentTypes[i] == Type.CHAR || argumentTypes[i] == Type.BOOLEAN) {\n+                        argumentTypes[i] = (Type)Type.INT;\n                     }\n-                    f.getLocals().set(twoslotoffset + j + (mg.isStatic() ? 0 : 1), argtypes[j]);\n-                    if (argtypes[j].getSize() == 2) {\n-                        ++twoslotoffset;\n-                        f.getLocals().set(twoslotoffset + j + (mg.isStatic() ? 0 : 1), Type.UNKNOWN);\n+                    frame.getLocals().set(n + i + (methodGen.isStatic() ? 0 : 1), argumentTypes[i]);\n+                    if (argumentTypes[i].getSize() == 2) {\n+                        ++n;\n+                        frame.getLocals().set(n + i + (methodGen.isStatic() ? 0 : 1), Type.UNKNOWN);\n                     }\n                 }\n-                this.circulationPump(mg, cfg, cfg.contextOf(mg.getInstructionList().getStart()), f, icv, ev);\n+                this.circulationPump(methodGen, controlFlowGraph, controlFlowGraph.contextOf(methodGen.getInstructionList().getStart()), frame, instConstraintVisitor, executionVisitor);\n             }\n         }\n-        catch (final VerifierConstraintViolatedException ce) {\n-            ce.extendMessage(\"Constraint violated in method '\" + methods[this.methodNo] + \"':\\n\", \"\");\n-            return new VerificationResult(2, ce.getMessage());\n-        }\n-        catch (final RuntimeException re) {\n-            final StringWriter sw = new StringWriter();\n-            final PrintWriter pw = new PrintWriter(sw);\n-            re.printStackTrace(pw);\n-            throw new AssertionViolatedException(\"Some RuntimeException occurred while verify()ing class '\" + jc.getClassName() + \"', method '\" + methods[this.methodNo] + \"'. Original RuntimeException's stack trace:\\n---\\n\" + sw + \"---\\n\", (Throwable)re);\n+        catch (final VerifierConstraintViolatedException ex) {\n+            ex.extendMessage(\"Constraint violated in method '\" + methods[this.methodNo] + \"':\\n\", \"\");\n+            return new VerificationResult(2, ex.getMessage());\n+        }\n+        catch (final RuntimeException ex2) {\n+            final StringWriter stringWriter = new StringWriter();\n+            ex2.printStackTrace(new PrintWriter((Writer)stringWriter));\n+            throw new AssertionViolatedException(\"Some RuntimeException occurred while verify()ing class '\" + lookupClass.getClassName() + \"', method '\" + methods[this.methodNo] + \"'. Original RuntimeException's stack trace:\\n---\\n\" + stringWriter + \"---\\n\", (Throwable)ex2);\n         }\n         return VerificationResult.VR_OK;\n     }\n     \n     public int getMethodNo() {\n         return this.methodNo;\n     }\n     \n-    public void invalidReturnTypeError(final Type returnedType, final MethodGen m) {\n-        throw new StructuralCodeConstraintException(\"Returned type \" + returnedType + \" does not match Method's return type \" + m.getReturnType());\n+    public void invalidReturnTypeError(final Type obj, final MethodGen methodGen) {\n+        throw new StructuralCodeConstraintException(\"Returned type \" + obj + \" does not match Method's return type \" + methodGen.getReturnType());\n     }\n }\n"}]}
