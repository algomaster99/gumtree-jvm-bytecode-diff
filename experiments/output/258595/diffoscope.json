{"diffoscope-json-version": 1, "source1": "first/PerformanceTest.class", "source2": "second/PerformanceTest.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -29,110 +29,110 @@\n     @BeforeAll\n     public static void setUpClass() throws FileNotFoundException, IOException {\n         if (PerformanceTest.BIG_FILE.exists()) {\n             System.out.println(String.format(\"Found test fixture %s: %,d bytes.\", PerformanceTest.BIG_FILE, Long.valueOf(PerformanceTest.BIG_FILE.length())));\n             return;\n         }\n         System.out.println(\"Decompressing test fixture to: \" + PerformanceTest.BIG_FILE + \"...\");\n-        try (final InputStream input = new GZIPInputStream(PerformanceTest.class.getClassLoader().getResourceAsStream(\"org/apache/commons/csv/perf/worldcitiespop.txt.gz\"));\n-             final OutputStream output = new FileOutputStream(PerformanceTest.BIG_FILE)) {\n-            IOUtils.copy(input, output);\n+        try (final GZIPInputStream gzipInputStream = new GZIPInputStream(PerformanceTest.class.getClassLoader().getResourceAsStream(\"org/apache/commons/csv/perf/worldcitiespop.txt.gz\"));\n+             final FileOutputStream fileOutputStream = new FileOutputStream(PerformanceTest.BIG_FILE)) {\n+            IOUtils.copy((InputStream)gzipInputStream, (OutputStream)fileOutputStream);\n             System.out.println(String.format(\"Decompressed test fixture %s: %,d bytes.\", PerformanceTest.BIG_FILE, Long.valueOf(PerformanceTest.BIG_FILE.length())));\n         }\n     }\n     \n     private BufferedReader createBufferedReader() throws IOException {\n         return new BufferedReader(new FileReader(PerformanceTest.BIG_FILE));\n     }\n     \n-    private long parse(final Reader reader, final boolean traverseColumns) throws IOException {\n-        final CSVFormat format = CSVFormat.DEFAULT.builder().setIgnoreSurroundingSpaces(false).build();\n-        long recordCount = 0L;\n-        try (final CSVParser parser = format.parse(reader)) {\n-            for (final CSVRecord record : parser) {\n-                ++recordCount;\n-                if (traverseColumns) {\n-                    for (String s : record) {}\n+    private long parse(final Reader reader, final boolean b) throws IOException {\n+        final CSVFormat build = CSVFormat.DEFAULT.builder().setIgnoreSurroundingSpaces(false).build();\n+        long n = 0L;\n+        try (final CSVParser parse = build.parse(reader)) {\n+            for (final CSVRecord csvRecord : parse) {\n+                ++n;\n+                if (b) {\n+                    for (String s : csvRecord) {}\n                 }\n             }\n         }\n-        return recordCount;\n+        return n;\n     }\n     \n-    private void println(final String s) {\n-        System.out.println(s);\n+    private void println(final String x) {\n+        System.out.println(x);\n     }\n     \n-    private long readAll(final BufferedReader in) throws IOException {\n-        long count = 0L;\n-        while (in.readLine() != null) {\n-            ++count;\n+    private long readAll(final BufferedReader bufferedReader) throws IOException {\n+        long n = 0L;\n+        while (bufferedReader.readLine() != null) {\n+            ++n;\n         }\n-        return count;\n+        return n;\n     }\n     \n-    public long testParseBigFile(final boolean traverseColumns) throws Exception {\n-        final long startMillis = System.currentTimeMillis();\n-        try (final BufferedReader reader = this.createBufferedReader()) {\n-            final long count = this.parse(reader, traverseColumns);\n-            final long totalMillis = System.currentTimeMillis() - startMillis;\n-            this.println(String.format(\"File parsed in %,d milliseconds with Commons CSV: %,d lines.\", Long.valueOf(totalMillis), Long.valueOf(count)));\n-            return totalMillis;\n+    public long testParseBigFile(final boolean b) throws Exception {\n+        final long currentTimeMillis = System.currentTimeMillis();\n+        try (final BufferedReader bufferedReader = this.createBufferedReader()) {\n+            final long parse = this.parse(bufferedReader, b);\n+            final long l = System.currentTimeMillis() - currentTimeMillis;\n+            this.println(String.format(\"File parsed in %,d milliseconds with Commons CSV: %,d lines.\", Long.valueOf(l), Long.valueOf(parse)));\n+            return l;\n         }\n     }\n     \n     @Test\n     public void testParseBigFileRepeat() throws Exception {\n-        long bestTime = Long.MAX_VALUE;\n-        int i = 0;\n+        long min = Long.MAX_VALUE;\n+        int n = 0;\n         while (true) {\n-            final int n = i;\n+            final int n2 = n;\n             Objects.requireNonNull(this);\n-            if (n >= 10) {\n+            if (n2 >= 10) {\n                 break;\n             }\n-            bestTime = Math.min(this.testParseBigFile(false), bestTime);\n-            ++i;\n+            min = Math.min(this.testParseBigFile(false), min);\n+            ++n;\n         }\n         final String format = \"Best time out of %,d is %,d milliseconds.\";\n         final Object[] args = new Object[2];\n-        final int n2 = 0;\n+        final int n3 = 0;\n         Objects.requireNonNull(this);\n-        args[n2] = Integer.valueOf(10);\n-        args[1] = Long.valueOf(bestTime);\n+        args[n3] = Integer.valueOf(10);\n+        args[1] = Long.valueOf(min);\n         this.println(String.format(format, args));\n     }\n     \n     @Test\n     public void testReadBigFile() throws Exception {\n-        long bestTime = Long.MAX_VALUE;\n-        int i = 0;\n+        long min = Long.MAX_VALUE;\n+        int n = 0;\n         while (true) {\n-            final int n = i;\n+            final int n2 = n;\n             Objects.requireNonNull(this);\n-            if (n >= 10) {\n+            if (n2 >= 10) {\n                 break;\n             }\n-            long startMillis;\n-            long count;\n-            try (final BufferedReader in = this.createBufferedReader()) {\n-                startMillis = System.currentTimeMillis();\n-                count = this.readAll(in);\n+            long currentTimeMillis;\n+            long all;\n+            try (final BufferedReader bufferedReader = this.createBufferedReader()) {\n+                currentTimeMillis = System.currentTimeMillis();\n+                all = this.readAll(bufferedReader);\n             }\n-            final long totalMillis = System.currentTimeMillis() - startMillis;\n-            bestTime = Math.min(totalMillis, bestTime);\n-            this.println(String.format(\"File read in %,d milliseconds: %,d lines.\", Long.valueOf(totalMillis), Long.valueOf(count)));\n-            ++i;\n+            final long n3 = System.currentTimeMillis() - currentTimeMillis;\n+            min = Math.min(n3, min);\n+            this.println(String.format(\"File read in %,d milliseconds: %,d lines.\", Long.valueOf(n3), Long.valueOf(all)));\n+            ++n;\n         }\n         final String format = \"Best time out of %,d is %,d milliseconds.\";\n         final Object[] args = new Object[2];\n-        final int n2 = 0;\n+        final int n4 = 0;\n         Objects.requireNonNull(this);\n-        args[n2] = Integer.valueOf(10);\n-        args[1] = Long.valueOf(bestTime);\n+        args[n4] = Integer.valueOf(10);\n+        args[1] = Long.valueOf(min);\n         this.println(String.format(format, args));\n     }\n     \n     static {\n         BIG_FILE = new File(System.getProperty(\"java.io.tmpdir\"), \"worldcitiespop.txt\");\n     }\n }\n"}]}
