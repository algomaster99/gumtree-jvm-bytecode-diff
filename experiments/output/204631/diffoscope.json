{"diffoscope-json-version": 1, "source1": "first/CodeAttribute.class", "source2": "second/CodeAttribute.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -20,112 +20,116 @@\n     public int maxLocals;\n     public int maxStack;\n     \n     public static void setAttributeName(final CPUTF8 attributeName) {\n         CodeAttribute.attributeName = attributeName;\n     }\n     \n-    public CodeAttribute(final int maxStack, final int maxLocals, final byte[] codePacked, final Segment segment, final OperandManager operandManager, final List<ExceptionTableEntry> exceptionTable) {\n+    public CodeAttribute(final int maxStack, final int maxLocals, final byte[] array, final Segment segment, final OperandManager operandManager, final List<ExceptionTableEntry> exceptionTable) {\n         super(CodeAttribute.attributeName);\n         this.attributes = new ArrayList<Attribute>();\n         this.byteCodeOffsets = new ArrayList<Integer>();\n         this.byteCodes = new ArrayList<ByteCode>();\n         this.maxLocals = maxLocals;\n         this.maxStack = maxStack;\n         this.codeLength = 0;\n         this.exceptionTable = exceptionTable;\n         this.byteCodeOffsets.add(Integer.valueOf(0));\n         int byteCodeIndex = 0;\n-        for (int i = 0; i < codePacked.length; ++i) {\n-            final ByteCode byteCode = ByteCode.getByteCode(codePacked[i] & 0xFF);\n+        for (int i = 0; i < array.length; ++i) {\n+            final ByteCode byteCode = ByteCode.getByteCode(array[i] & 0xFF);\n             byteCode.setByteCodeIndex(byteCodeIndex);\n             ++byteCodeIndex;\n             byteCode.extractOperands(operandManager, segment, this.codeLength);\n             this.byteCodes.add(byteCode);\n             this.codeLength += byteCode.getLength();\n-            final int lastBytecodePosition = (int)Integer.valueOf(this.byteCodeOffsets.get(this.byteCodeOffsets.size() - 1));\n+            final int intValue = (int)Integer.valueOf(this.byteCodeOffsets.get(this.byteCodeOffsets.size() - 1));\n             if (byteCode.hasMultipleByteCodes()) {\n-                this.byteCodeOffsets.add(Integer.valueOf(lastBytecodePosition + 1));\n+                this.byteCodeOffsets.add(Integer.valueOf(intValue + 1));\n                 ++byteCodeIndex;\n             }\n-            if (i < codePacked.length - 1) {\n-                this.byteCodeOffsets.add(Integer.valueOf(lastBytecodePosition + byteCode.getLength()));\n+            if (i < array.length - 1) {\n+                this.byteCodeOffsets.add(Integer.valueOf(intValue + byteCode.getLength()));\n             }\n             if (byteCode.getOpcode() == 196) {\n                 ++i;\n             }\n         }\n         final Iterator<ByteCode> iterator = this.byteCodes.iterator();\n         while (iterator.hasNext()) {\n-            final ByteCode byteCode = (ByteCode)iterator.next();\n-            byteCode.applyByteCodeTargetFixup(this);\n+            ((ByteCode)iterator.next()).applyByteCodeTargetFixup(this);\n         }\n     }\n     \n     public void addAttribute(final Attribute attribute) {\n         this.attributes.add(attribute);\n         if (attribute instanceof LocalVariableTableAttribute) {\n             ((LocalVariableTableAttribute)attribute).setCodeLength(this.codeLength);\n         }\n         if (attribute instanceof LocalVariableTypeTableAttribute) {\n             ((LocalVariableTypeTableAttribute)attribute).setCodeLength(this.codeLength);\n         }\n     }\n     \n     protected int getLength() {\n-        int attributesSize = 0;\n-        for (final Attribute attribute : this.attributes) {\n-            attributesSize += attribute.getLengthIncludingHeader();\n+        int n = 0;\n+        final Iterator<Attribute> iterator = this.attributes.iterator();\n+        while (iterator.hasNext()) {\n+            n += ((Attribute)iterator.next()).getLengthIncludingHeader();\n         }\n-        return 8 + this.codeLength + 2 + this.exceptionTable.size() * 8 + 2 + attributesSize;\n+        return 8 + this.codeLength + 2 + this.exceptionTable.size() * 8 + 2 + n;\n     }\n     \n     protected ClassFileEntry[] getNestedClassFileEntries() {\n-        final List<ClassFileEntry> nestedEntries = new ArrayList<ClassFileEntry>(this.attributes.size() + this.byteCodes.size() + 10);\n-        nestedEntries.add((ClassFileEntry)this.getAttributeName());\n-        nestedEntries.addAll((Collection<? extends ClassFileEntry>)this.byteCodes);\n-        nestedEntries.addAll((Collection<? extends ClassFileEntry>)this.attributes);\n-        for (final ExceptionTableEntry entry : this.exceptionTable) {\n-            final CPClass catchType = entry.getCatchType();\n+        final ArrayList list = new ArrayList(this.attributes.size() + this.byteCodes.size() + 10);\n+        list.add(this.getAttributeName());\n+        list.addAll(this.byteCodes);\n+        list.addAll(this.attributes);\n+        final Iterator<ExceptionTableEntry> iterator = this.exceptionTable.iterator();\n+        while (iterator.hasNext()) {\n+            final CPClass catchType = ((ExceptionTableEntry)iterator.next()).getCatchType();\n             if (catchType != null) {\n-                nestedEntries.add((ClassFileEntry)catchType);\n+                list.add(catchType);\n             }\n         }\n-        return nestedEntries.toArray(ClassFileEntry.NONE);\n+        return (ClassFileEntry[])list.toArray(ClassFileEntry.NONE);\n     }\n     \n     protected int[] getStartPCs() {\n         return null;\n     }\n     \n-    public void renumber(final List<Integer> byteCodeOffsets) {\n-        this.exceptionTable.forEach(entry -> entry.renumber(byteCodeOffsets));\n+    public void renumber(final List<Integer> list) {\n+        this.exceptionTable.forEach(exceptionTableEntry -> exceptionTableEntry.renumber(list2));\n     }\n     \n-    protected void resolve(final ClassConstantPool pool) {\n-        super.resolve(pool);\n-        this.attributes.forEach(attribute -> attribute.resolve(pool));\n-        this.byteCodes.forEach(byteCode -> byteCode.resolve(pool));\n-        this.exceptionTable.forEach(byteCode -> byteCode.resolve(pool));\n+    protected void resolve(final ClassConstantPool classConstantPool) {\n+        super.resolve(classConstantPool);\n+        this.attributes.forEach(attribute -> attribute.resolve(classConstantPool2));\n+        this.byteCodes.forEach(byteCode -> byteCode.resolve(classConstantPool3));\n+        this.exceptionTable.forEach(exceptionTableEntry -> exceptionTableEntry.resolve(classConstantPool4));\n     }\n     \n     public String toString() {\n         return \"Code: \" + this.getLength() + \" bytes\";\n     }\n     \n-    protected void writeBody(final DataOutputStream dos) throws IOException {\n-        dos.writeShort(this.maxStack);\n-        dos.writeShort(this.maxLocals);\n-        dos.writeInt(this.codeLength);\n-        for (final ByteCode byteCode : this.byteCodes) {\n-            byteCode.write(dos);\n-        }\n-        dos.writeShort(this.exceptionTable.size());\n-        for (final ExceptionTableEntry entry : this.exceptionTable) {\n-            entry.write(dos);\n-        }\n-        dos.writeShort(this.attributes.size());\n-        for (final Attribute attribute : this.attributes) {\n-            attribute.write(dos);\n+    protected void writeBody(final DataOutputStream dataOutputStream) throws IOException {\n+        dataOutputStream.writeShort(this.maxStack);\n+        dataOutputStream.writeShort(this.maxLocals);\n+        dataOutputStream.writeInt(this.codeLength);\n+        final Iterator<ByteCode> iterator = this.byteCodes.iterator();\n+        while (iterator.hasNext()) {\n+            ((ByteCode)iterator.next()).write(dataOutputStream);\n+        }\n+        dataOutputStream.writeShort(this.exceptionTable.size());\n+        final Iterator<ExceptionTableEntry> iterator2 = this.exceptionTable.iterator();\n+        while (iterator2.hasNext()) {\n+            ((ExceptionTableEntry)iterator2.next()).write(dataOutputStream);\n+        }\n+        dataOutputStream.writeShort(this.attributes.size());\n+        final Iterator<Attribute> iterator3 = this.attributes.iterator();\n+        while (iterator3.hasNext()) {\n+            ((Attribute)iterator3.next()).write(dataOutputStream);\n         }\n     }\n }\n"}]}
