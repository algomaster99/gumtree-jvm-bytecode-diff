{"diffoscope-json-version": 1, "source1": "first/BoundedArchiveInputStream.class", "source2": "second/BoundedArchiveInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -7,56 +7,54 @@\n \n public abstract class BoundedArchiveInputStream extends InputStream\n {\n     private final long end;\n     private ByteBuffer singleByteBuffer;\n     private long loc;\n     \n-    public BoundedArchiveInputStream(final long start, final long remaining) {\n-        this.end = start + remaining;\n-        if (this.end < start) {\n-            throw new IllegalArgumentException(\"Invalid length of stream at offset=\" + start + \", length=\" + remaining);\n+    public BoundedArchiveInputStream(final long n, final long lng) {\n+        this.end = n + lng;\n+        if (this.end < n) {\n+            throw new IllegalArgumentException(\"Invalid length of stream at offset=\" + n + \", length=\" + lng);\n         }\n-        this.loc = start;\n+        this.loc = n;\n     }\n     \n     @Override\n     public synchronized int read() throws IOException {\n         if (this.loc >= this.end) {\n             return -1;\n         }\n         if (this.singleByteBuffer == null) {\n             this.singleByteBuffer = ByteBuffer.allocate(1);\n         }\n         else {\n             this.singleByteBuffer.rewind();\n         }\n-        final int read = this.read(this.loc, this.singleByteBuffer);\n-        if (read < 1) {\n+        if (this.read(this.loc, this.singleByteBuffer) < 1) {\n             return -1;\n         }\n         ++this.loc;\n         return this.singleByteBuffer.get() & 0xFF;\n     }\n     \n     @Override\n-    public synchronized int read(final byte[] b, final int off, final int len) throws IOException {\n+    public synchronized int read(final byte[] array, final int offset, final int n) throws IOException {\n         if (this.loc >= this.end) {\n             return -1;\n         }\n-        final long maxLen = Math.min(len, this.end - this.loc);\n-        if (maxLen <= 0L) {\n+        final long min = Math.min(n, this.end - this.loc);\n+        if (min <= 0L) {\n             return 0;\n         }\n-        if (off < 0 || off > b.length || maxLen > b.length - off) {\n+        if (offset < 0 || offset > array.length || min > array.length - offset) {\n             throw new IndexOutOfBoundsException(\"offset or len are out of bounds\");\n         }\n-        final ByteBuffer buf = ByteBuffer.wrap(b, off, (int)maxLen);\n-        final int ret = this.read(this.loc, buf);\n-        if (ret > 0) {\n-            this.loc += ret;\n+        final int read = this.read(this.loc, ByteBuffer.wrap(array, offset, (int)min));\n+        if (read > 0) {\n+            this.loc += read;\n         }\n-        return ret;\n+        return read;\n     }\n     \n     protected abstract int read(final long p0, final ByteBuffer p1) throws IOException;\n }\n"}]}
