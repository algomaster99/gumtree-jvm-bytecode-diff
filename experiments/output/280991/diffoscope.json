{"diffoscope-json-version": 1, "source1": "first/DirectoryWalker.class", "source2": "second/DirectoryWalker.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -21,103 +21,102 @@\n     }\n     \n     protected DirectoryWalker(final FileFilter filter, final int depthLimit) {\n         this.filter = filter;\n         this.depthLimit = depthLimit;\n     }\n     \n-    protected DirectoryWalker(IOFileFilter directoryFilter, IOFileFilter fileFilter, final int depthLimit) {\n-        if (directoryFilter == null && fileFilter == null) {\n+    protected DirectoryWalker(IOFileFilter directoryOnly, IOFileFilter fileOnly, final int depthLimit) {\n+        if (directoryOnly == null && fileOnly == null) {\n             this.filter = null;\n         }\n         else {\n-            directoryFilter = ((directoryFilter != null) ? directoryFilter : TrueFileFilter.TRUE);\n-            fileFilter = ((fileFilter != null) ? fileFilter : TrueFileFilter.TRUE);\n-            directoryFilter = FileFilterUtils.makeDirectoryOnly(directoryFilter);\n-            fileFilter = FileFilterUtils.makeFileOnly(fileFilter);\n-            this.filter = (FileFilter)directoryFilter.or(fileFilter);\n+            directoryOnly = ((directoryOnly != null) ? directoryOnly : TrueFileFilter.TRUE);\n+            fileOnly = ((fileOnly != null) ? fileOnly : TrueFileFilter.TRUE);\n+            directoryOnly = FileFilterUtils.makeDirectoryOnly(directoryOnly);\n+            fileOnly = FileFilterUtils.makeFileOnly(fileOnly);\n+            this.filter = (FileFilter)directoryOnly.or(fileOnly);\n         }\n         this.depthLimit = depthLimit;\n     }\n     \n-    protected final void walk(final File startDirectory, final Collection<T> results) throws IOException {\n-        Objects.requireNonNull(startDirectory, \"startDirectory\");\n+    protected final void walk(final File obj, final Collection<T> collection) throws IOException {\n+        Objects.requireNonNull(obj, \"startDirectory\");\n         try {\n-            this.handleStart(startDirectory, results);\n-            this.walk(startDirectory, 0, results);\n-            this.handleEnd(results);\n-        }\n-        catch (final DirectoryWalker.CancelException cancel) {\n-            this.handleCancelled(startDirectory, results, cancel);\n+            this.handleStart(obj, collection);\n+            this.walk(obj, 0, collection);\n+            this.handleEnd(collection);\n+        }\n+        catch (final DirectoryWalker.CancelException ex) {\n+            this.handleCancelled(obj, collection, ex);\n         }\n     }\n     \n-    private void walk(final File directory, final int depth, final Collection<T> results) throws IOException {\n-        this.checkIfCancelled(directory, depth, results);\n-        if (this.handleDirectory(directory, depth, results)) {\n-            this.handleDirectoryStart(directory, depth, results);\n-            final int childDepth = depth + 1;\n-            if (this.depthLimit < 0 || childDepth <= this.depthLimit) {\n-                this.checkIfCancelled(directory, depth, results);\n-                File[] childFiles = (this.filter == null) ? directory.listFiles() : directory.listFiles(this.filter);\n-                childFiles = this.filterDirectoryContents(directory, depth, childFiles);\n-                if (childFiles == null) {\n-                    this.handleRestricted(directory, childDepth, results);\n+    private void walk(final File file, final int n, final Collection<T> collection) throws IOException {\n+        this.checkIfCancelled(file, n, collection);\n+        if (this.handleDirectory(file, n, collection)) {\n+            this.handleDirectoryStart(file, n, collection);\n+            final int n2 = n + 1;\n+            if (this.depthLimit < 0 || n2 <= this.depthLimit) {\n+                this.checkIfCancelled(file, n, collection);\n+                final File[] filterDirectoryContents = this.filterDirectoryContents(file, n, (this.filter == null) ? file.listFiles() : file.listFiles(this.filter));\n+                if (filterDirectoryContents == null) {\n+                    this.handleRestricted(file, n2, collection);\n                 }\n                 else {\n-                    for (final File childFile : childFiles) {\n-                        if (childFile.isDirectory()) {\n-                            this.walk(childFile, childDepth, results);\n+                    for (final File file2 : filterDirectoryContents) {\n+                        if (file2.isDirectory()) {\n+                            this.walk(file2, n2, collection);\n                         }\n                         else {\n-                            this.checkIfCancelled(childFile, childDepth, results);\n-                            this.handleFile(childFile, childDepth, results);\n-                            this.checkIfCancelled(childFile, childDepth, results);\n+                            this.checkIfCancelled(file2, n2, collection);\n+                            this.handleFile(file2, n2, collection);\n+                            this.checkIfCancelled(file2, n2, collection);\n                         }\n                     }\n                 }\n             }\n-            this.handleDirectoryEnd(directory, depth, results);\n+            this.handleDirectoryEnd(file, n, collection);\n         }\n-        this.checkIfCancelled(directory, depth, results);\n+        this.checkIfCancelled(file, n, collection);\n     }\n     \n-    protected final void checkIfCancelled(final File file, final int depth, final Collection<T> results) throws IOException {\n-        if (this.handleIsCancelled(file, depth, results)) {\n-            throw new DirectoryWalker.CancelException(file, depth);\n+    protected final void checkIfCancelled(final File file, final int n, final Collection<T> collection) throws IOException {\n+        if (this.handleIsCancelled(file, n, collection)) {\n+            throw new DirectoryWalker.CancelException(file, n);\n         }\n     }\n     \n-    protected boolean handleIsCancelled(final File file, final int depth, final Collection<T> results) throws IOException {\n+    protected boolean handleIsCancelled(final File file, final int n, final Collection<T> collection) throws IOException {\n         return false;\n     }\n     \n-    protected void handleCancelled(final File startDirectory, final Collection<T> results, final DirectoryWalker.CancelException cancel) throws IOException {\n-        throw cancel;\n+    protected void handleCancelled(final File file, final Collection<T> collection, final DirectoryWalker.CancelException ex) throws IOException {\n+        throw ex;\n     }\n     \n-    protected void handleStart(final File startDirectory, final Collection<T> results) throws IOException {\n+    protected void handleStart(final File file, final Collection<T> collection) throws IOException {\n     }\n     \n-    protected boolean handleDirectory(final File directory, final int depth, final Collection<T> results) throws IOException {\n+    protected boolean handleDirectory(final File file, final int n, final Collection<T> collection) throws IOException {\n         return true;\n     }\n     \n-    protected void handleDirectoryStart(final File directory, final int depth, final Collection<T> results) throws IOException {\n+    protected void handleDirectoryStart(final File file, final int n, final Collection<T> collection) throws IOException {\n     }\n     \n-    protected File[] filterDirectoryContents(final File directory, final int depth, final File... files) throws IOException {\n-        return files;\n+    protected File[] filterDirectoryContents(final File file, final int n, final File... array) throws IOException {\n+        return array;\n     }\n     \n-    protected void handleFile(final File file, final int depth, final Collection<T> results) throws IOException {\n+    protected void handleFile(final File file, final int n, final Collection<T> collection) throws IOException {\n     }\n     \n-    protected void handleRestricted(final File directory, final int depth, final Collection<T> results) throws IOException {\n+    protected void handleRestricted(final File file, final int n, final Collection<T> collection) throws IOException {\n     }\n     \n-    protected void handleDirectoryEnd(final File directory, final int depth, final Collection<T> results) throws IOException {\n+    protected void handleDirectoryEnd(final File file, final int n, final Collection<T> collection) throws IOException {\n     }\n     \n-    protected void handleEnd(final Collection<T> results) throws IOException {\n+    protected void handleEnd(final Collection<T> collection) throws IOException {\n     }\n }\n"}]}
