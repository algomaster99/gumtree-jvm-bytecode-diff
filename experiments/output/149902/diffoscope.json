{"diffoscope-json-version": 1, "source1": "first/ZipArchiveInputStream.class", "source2": "second/ZipArchiveInputStream.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -48,14 +48,22 @@\n     private final byte[] lfhBuf;\n     private final byte[] skipBuf;\n     private final byte[] shortBuf;\n     private final byte[] wordBuf;\n     private final byte[] twoDwordBuf;\n     private int entriesRead;\n     \n+    static {\n+        LFH = ZipLong.LFH_SIG.getBytes();\n+        CFH = ZipLong.CFH_SIG.getBytes();\n+        DD = ZipLong.DD_SIG.getBytes();\n+        APK_SIGNING_BLOCK_MAGIC = new byte[] { 65, 80, 75, 32, 83, 105, 103, 32, 66, 108, 111, 99, 107, 32, 52, 50 };\n+        LONG_MAX = BigInteger.valueOf(Long.MAX_VALUE);\n+    }\n+    \n     private static boolean checksig(final byte[] signature, final byte[] expected) {\n         for (int i = 0; i < expected.length; ++i) {\n             if (signature[i] != expected[i]) {\n                 return false;\n             }\n         }\n         return true;\n@@ -146,14 +154,15 @@\n             this.closed = true;\n             try {\n                 this.inputStream.close();\n             }\n             finally {\n                 this.inf.end();\n             }\n+            this.inf.end();\n         }\n     }\n     \n     private void closeEntry() throws IOException {\n         if (this.closed) {\n             throw new IOException(\"The stream is closed\");\n         }\n@@ -161,43 +170,44 @@\n             return;\n         }\n         if (this.currentEntryHasOutstandingBytes()) {\n             this.drainCurrentEntryData();\n         }\n         else {\n             this.skip(Long.MAX_VALUE);\n-            final long inB = (ZipArchiveInputStream.CurrentEntry.access$400(this.current).getMethod() == 8) ? this.getBytesInflated() : ZipArchiveInputStream.CurrentEntry.access$500(this.current);\n-            final int diff = (int)(ZipArchiveInputStream.CurrentEntry.access$200(this.current) - inB);\n+            final long inB = (ZipArchiveInputStream.CurrentEntry.access$2(this.current).getMethod() == 8) ? this.getBytesInflated() : ZipArchiveInputStream.CurrentEntry.access$3(this.current);\n+            final int diff = (int)(ZipArchiveInputStream.CurrentEntry.access$0(this.current) - inB);\n             if (diff > 0) {\n                 this.pushback(this.buf.array(), this.buf.limit() - diff, diff);\n-                ZipArchiveInputStream.CurrentEntry.access$222(this.current, (long)diff);\n+                final ZipArchiveInputStream.CurrentEntry current = this.current;\n+                ZipArchiveInputStream.CurrentEntry.access$1(current, ZipArchiveInputStream.CurrentEntry.access$0(current) - (long)diff);\n             }\n             if (this.currentEntryHasOutstandingBytes()) {\n                 this.drainCurrentEntryData();\n             }\n         }\n-        if (this.lastStoredEntry == null && ZipArchiveInputStream.CurrentEntry.access$600(this.current)) {\n+        if (this.lastStoredEntry == null && ZipArchiveInputStream.CurrentEntry.access$4(this.current)) {\n             this.readDataDescriptor();\n         }\n         this.inf.reset();\n         this.buf.clear().flip();\n         this.current = null;\n         this.lastStoredEntry = null;\n     }\n     \n     private boolean currentEntryHasOutstandingBytes() {\n-        return ZipArchiveInputStream.CurrentEntry.access$200(this.current) <= ZipArchiveInputStream.CurrentEntry.access$400(this.current).getCompressedSize() && !ZipArchiveInputStream.CurrentEntry.access$600(this.current);\n+        return ZipArchiveInputStream.CurrentEntry.access$0(this.current) <= ZipArchiveInputStream.CurrentEntry.access$2(this.current).getCompressedSize() && !ZipArchiveInputStream.CurrentEntry.access$4(this.current);\n     }\n     \n     private void drainCurrentEntryData() throws IOException {\n         long n;\n-        for (long remaining = ZipArchiveInputStream.CurrentEntry.access$400(this.current).getCompressedSize() - ZipArchiveInputStream.CurrentEntry.access$200(this.current); remaining > 0L; remaining -= n) {\n+        for (long remaining = ZipArchiveInputStream.CurrentEntry.access$2(this.current).getCompressedSize() - ZipArchiveInputStream.CurrentEntry.access$0(this.current); remaining > 0L; remaining -= n) {\n             n = this.inputStream.read(this.buf.array(), 0, (int)Math.min(this.buf.capacity(), remaining));\n             if (n < 0L) {\n-                throw new EOFException(\"Truncated ZIP entry: \" + ArchiveUtils.sanitize(ZipArchiveInputStream.CurrentEntry.access$400(this.current).getName()));\n+                throw new EOFException(\"Truncated ZIP entry: \" + ArchiveUtils.sanitize(ZipArchiveInputStream.CurrentEntry.access$2(this.current).getName()));\n             }\n             this.count(n);\n         }\n     }\n     \n     private int fill() throws IOException {\n         if (this.closed) {\n@@ -248,32 +258,32 @@\n             }\n         }\n         return false;\n     }\n     \n     private long getBytesInflated() {\n         long inB = this.inf.getBytesRead();\n-        if (ZipArchiveInputStream.CurrentEntry.access$200(this.current) >= 4294967296L) {\n-            while (inB + 4294967296L <= ZipArchiveInputStream.CurrentEntry.access$200(this.current)) {\n+        if (ZipArchiveInputStream.CurrentEntry.access$0(this.current) >= 4294967296L) {\n+            while (inB + 4294967296L <= ZipArchiveInputStream.CurrentEntry.access$0(this.current)) {\n                 inB += 4294967296L;\n             }\n         }\n         return inB;\n     }\n     \n     public long getCompressedCount() {\n-        final int method = ZipArchiveInputStream.CurrentEntry.access$400(this.current).getMethod();\n+        final int method = ZipArchiveInputStream.CurrentEntry.access$2(this.current).getMethod();\n         if (method == 0) {\n-            return ZipArchiveInputStream.CurrentEntry.access$500(this.current);\n+            return ZipArchiveInputStream.CurrentEntry.access$3(this.current);\n         }\n         if (method == 8) {\n             return this.getBytesInflated();\n         }\n         if (method == ZipMethod.UNSHRINKING.getCode() || method == ZipMethod.IMPLODING.getCode() || method == ZipMethod.ENHANCED_DEFLATED.getCode() || method == ZipMethod.BZIP2.getCode()) {\n-            return ((InputStreamStatistics)ZipArchiveInputStream.CurrentEntry.access$700(this.current)).getCompressedCount();\n+            return ((InputStreamStatistics)ZipArchiveInputStream.CurrentEntry.access$5(this.current)).getCompressedCount();\n         }\n         return -1L;\n     }\n     \n     public ArchiveEntry getNextEntry() throws IOException {\n         return (ArchiveEntry)this.getNextZipEntry();\n     }\n@@ -299,101 +309,101 @@\n         }\n         catch (final EOFException e) {\n             return null;\n         }\n         final ZipLong sig = new ZipLong(this.lfhBuf);\n         if (sig.equals((Object)ZipLong.LFH_SIG)) {\n             int off = 4;\n-            this.current = new ZipArchiveInputStream.CurrentEntry((ZipArchiveInputStream.ZipArchiveInputStream$1)null);\n+            this.current = new ZipArchiveInputStream.CurrentEntry((ZipArchiveInputStream.CurrentEntry)null);\n             final int versionMadeBy = ZipShort.getValue(this.lfhBuf, off);\n             off += 2;\n-            ZipArchiveInputStream.CurrentEntry.access$400(this.current).setPlatform(versionMadeBy >> 8 & 0xF);\n+            ZipArchiveInputStream.CurrentEntry.access$2(this.current).setPlatform(versionMadeBy >> 8 & 0xF);\n             final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(this.lfhBuf, off);\n             final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n             final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : this.zipEncoding;\n-            ZipArchiveInputStream.CurrentEntry.access$602(this.current, gpFlag.usesDataDescriptor());\n-            ZipArchiveInputStream.CurrentEntry.access$400(this.current).setGeneralPurposeBit(gpFlag);\n+            ZipArchiveInputStream.CurrentEntry.access$7(this.current, gpFlag.usesDataDescriptor());\n+            ZipArchiveInputStream.CurrentEntry.access$2(this.current).setGeneralPurposeBit(gpFlag);\n             off += 2;\n-            ZipArchiveInputStream.CurrentEntry.access$400(this.current).setMethod(ZipShort.getValue(this.lfhBuf, off));\n+            ZipArchiveInputStream.CurrentEntry.access$2(this.current).setMethod(ZipShort.getValue(this.lfhBuf, off));\n             off += 2;\n             final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(this.lfhBuf, off));\n-            ZipArchiveInputStream.CurrentEntry.access$400(this.current).setTime(time);\n+            ZipArchiveInputStream.CurrentEntry.access$2(this.current).setTime(time);\n             off += 4;\n             ZipLong size = null;\n             ZipLong cSize = null;\n-            if (!ZipArchiveInputStream.CurrentEntry.access$600(this.current)) {\n-                ZipArchiveInputStream.CurrentEntry.access$400(this.current).setCrc(ZipLong.getValue(this.lfhBuf, off));\n+            if (!ZipArchiveInputStream.CurrentEntry.access$4(this.current)) {\n+                ZipArchiveInputStream.CurrentEntry.access$2(this.current).setCrc(ZipLong.getValue(this.lfhBuf, off));\n                 off += 4;\n                 cSize = new ZipLong(this.lfhBuf, off);\n                 off += 4;\n                 size = new ZipLong(this.lfhBuf, off);\n                 off += 4;\n             }\n             else {\n                 off += 12;\n             }\n             final int fileNameLen = ZipShort.getValue(this.lfhBuf, off);\n             off += 2;\n             final int extraLen = ZipShort.getValue(this.lfhBuf, off);\n             off += 2;\n             final byte[] fileName = this.readRange(fileNameLen);\n-            ZipArchiveInputStream.CurrentEntry.access$400(this.current).setName(entryEncoding.decode(fileName), fileName);\n+            ZipArchiveInputStream.CurrentEntry.access$2(this.current).setName(entryEncoding.decode(fileName), fileName);\n             if (hasUTF8Flag) {\n-                ZipArchiveInputStream.CurrentEntry.access$400(this.current).setNameSource(ZipArchiveEntry.NameSource.NAME_WITH_EFS_FLAG);\n+                ZipArchiveInputStream.CurrentEntry.access$2(this.current).setNameSource(ZipArchiveEntry.NameSource.NAME_WITH_EFS_FLAG);\n             }\n             final byte[] extraData = this.readRange(extraLen);\n             try {\n-                ZipArchiveInputStream.CurrentEntry.access$400(this.current).setExtra(extraData);\n+                ZipArchiveInputStream.CurrentEntry.access$2(this.current).setExtra(extraData);\n             }\n             catch (final RuntimeException ex) {\n-                final ZipException z = new ZipException(\"Invalid extra data in entry \" + ZipArchiveInputStream.CurrentEntry.access$400(this.current).getName());\n+                final ZipException z = new ZipException(\"Invalid extra data in entry \" + ZipArchiveInputStream.CurrentEntry.access$2(this.current).getName());\n                 z.initCause(ex);\n                 throw z;\n             }\n             if (!hasUTF8Flag && this.useUnicodeExtraFields) {\n-                ZipUtil.setNameAndCommentFromExtraFields(ZipArchiveInputStream.CurrentEntry.access$400(this.current), fileName, (byte[])null);\n+                ZipUtil.setNameAndCommentFromExtraFields(ZipArchiveInputStream.CurrentEntry.access$2(this.current), fileName, (byte[])null);\n             }\n             this.processZip64Extra(size, cSize);\n-            ZipArchiveInputStream.CurrentEntry.access$400(this.current).setLocalHeaderOffset(currentHeaderOffset);\n-            ZipArchiveInputStream.CurrentEntry.access$400(this.current).setDataOffset(this.getBytesRead());\n-            ZipArchiveInputStream.CurrentEntry.access$400(this.current).setStreamContiguous(true);\n-            final ZipMethod m = ZipMethod.getMethodByCode(ZipArchiveInputStream.CurrentEntry.access$400(this.current).getMethod());\n-            if (ZipArchiveInputStream.CurrentEntry.access$400(this.current).getCompressedSize() != -1L) {\n-                if (ZipUtil.canHandleEntryData(ZipArchiveInputStream.CurrentEntry.access$400(this.current)) && m != ZipMethod.STORED && m != ZipMethod.DEFLATED) {\n-                    final InputStream bis = (InputStream)new ZipArchiveInputStream.BoundedInputStream(this, this.inputStream, ZipArchiveInputStream.CurrentEntry.access$400(this.current).getCompressedSize());\n-                    switch (ZipArchiveInputStream.ZipArchiveInputStream$1.$SwitchMap$org$apache$commons$compress$archivers$zip$ZipMethod[m.ordinal()]) {\n-                        case 1: {\n-                            ZipArchiveInputStream.CurrentEntry.access$902(this.current, (InputStream)new UnshrinkingInputStream(bis));\n+            ZipArchiveInputStream.CurrentEntry.access$2(this.current).setLocalHeaderOffset(currentHeaderOffset);\n+            ZipArchiveInputStream.CurrentEntry.access$2(this.current).setDataOffset(this.getBytesRead());\n+            ZipArchiveInputStream.CurrentEntry.access$2(this.current).setStreamContiguous(true);\n+            final ZipMethod m = ZipMethod.getMethodByCode(ZipArchiveInputStream.CurrentEntry.access$2(this.current).getMethod());\n+            if (ZipArchiveInputStream.CurrentEntry.access$2(this.current).getCompressedSize() != -1L) {\n+                if (ZipUtil.canHandleEntryData(ZipArchiveInputStream.CurrentEntry.access$2(this.current)) && m != ZipMethod.STORED && m != ZipMethod.DEFLATED) {\n+                    final InputStream bis = (InputStream)new ZipArchiveInputStream.BoundedInputStream(this, this.inputStream, ZipArchiveInputStream.CurrentEntry.access$2(this.current).getCompressedSize());\n+                    switch (m) {\n+                        case UNSHRINKING: {\n+                            ZipArchiveInputStream.CurrentEntry.access$8(this.current, (InputStream)new UnshrinkingInputStream(bis));\n                             break;\n                         }\n-                        case 2: {\n+                        case IMPLODING: {\n                             try {\n-                                ZipArchiveInputStream.CurrentEntry.access$902(this.current, (InputStream)new ExplodingInputStream(ZipArchiveInputStream.CurrentEntry.access$400(this.current).getGeneralPurposeBit().getSlidingDictionarySize(), ZipArchiveInputStream.CurrentEntry.access$400(this.current).getGeneralPurposeBit().getNumberOfShannonFanoTrees(), bis));\n+                                ZipArchiveInputStream.CurrentEntry.access$8(this.current, (InputStream)new ExplodingInputStream(ZipArchiveInputStream.CurrentEntry.access$2(this.current).getGeneralPurposeBit().getSlidingDictionarySize(), ZipArchiveInputStream.CurrentEntry.access$2(this.current).getGeneralPurposeBit().getNumberOfShannonFanoTrees(), bis));\n                                 break;\n                             }\n                             catch (final IllegalArgumentException ex2) {\n                                 throw new IOException(\"bad IMPLODE data\", ex2);\n                             }\n                         }\n-                        case 3: {\n-                            ZipArchiveInputStream.CurrentEntry.access$902(this.current, (InputStream)new BZip2CompressorInputStream(bis));\n+                        case BZIP2: {\n+                            ZipArchiveInputStream.CurrentEntry.access$8(this.current, (InputStream)new BZip2CompressorInputStream(bis));\n                             break;\n                         }\n-                        case 4: {\n-                            ZipArchiveInputStream.CurrentEntry.access$902(this.current, (InputStream)new Deflate64CompressorInputStream(bis));\n+                        case ENHANCED_DEFLATED: {\n+                            ZipArchiveInputStream.CurrentEntry.access$8(this.current, (InputStream)new Deflate64CompressorInputStream(bis));\n                             break;\n                         }\n                     }\n                 }\n             }\n             else if (m == ZipMethod.ENHANCED_DEFLATED) {\n-                ZipArchiveInputStream.CurrentEntry.access$902(this.current, (InputStream)new Deflate64CompressorInputStream(this.inputStream));\n+                ZipArchiveInputStream.CurrentEntry.access$8(this.current, (InputStream)new Deflate64CompressorInputStream(this.inputStream));\n             }\n             ++this.entriesRead;\n-            return ZipArchiveInputStream.CurrentEntry.access$400(this.current);\n+            return ZipArchiveInputStream.CurrentEntry.access$2(this.current);\n         }\n         if (sig.equals((Object)ZipLong.CFH_SIG) || sig.equals((Object)ZipLong.AED_SIG) || this.isApkSigningBlock(this.lfhBuf)) {\n             this.hitCentralDirectory = true;\n             this.skipRemainderOfArchive();\n             return null;\n         }\n         throw new ZipException(String.format(\"Unexpected record signature: 0x%x\", Long.valueOf(sig.getValue())));\n@@ -435,45 +445,45 @@\n     }\n     \n     private boolean isFirstByteOfEocdSig(final int b) {\n         return b == ZipArchiveOutputStream.EOCD_SIG[0];\n     }\n     \n     private void processZip64Extra(final ZipLong size, final ZipLong cSize) throws ZipException {\n-        final ZipExtraField extra = ZipArchiveInputStream.CurrentEntry.access$400(this.current).getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n+        final ZipExtraField extra = ZipArchiveInputStream.CurrentEntry.access$2(this.current).getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n         if (extra != null && !(extra instanceof Zip64ExtendedInformationExtraField)) {\n             throw new ZipException(\"archive contains unparseable zip64 extra field\");\n         }\n         final Zip64ExtendedInformationExtraField z64 = (Zip64ExtendedInformationExtraField)extra;\n-        ZipArchiveInputStream.CurrentEntry.access$1002(this.current, z64 != null);\n-        if (!ZipArchiveInputStream.CurrentEntry.access$600(this.current)) {\n+        ZipArchiveInputStream.CurrentEntry.access$9(this.current, z64 != null);\n+        if (!ZipArchiveInputStream.CurrentEntry.access$4(this.current)) {\n             if (z64 != null && (ZipLong.ZIP64_MAGIC.equals((Object)cSize) || ZipLong.ZIP64_MAGIC.equals((Object)size))) {\n                 if (z64.getCompressedSize() == null || z64.getSize() == null) {\n                     throw new ZipException(\"archive contains corrupted zip64 extra field\");\n                 }\n                 long s = z64.getCompressedSize().getLongValue();\n                 if (s < 0L) {\n                     throw new ZipException(\"broken archive, entry with negative compressed size\");\n                 }\n-                ZipArchiveInputStream.CurrentEntry.access$400(this.current).setCompressedSize(s);\n+                ZipArchiveInputStream.CurrentEntry.access$2(this.current).setCompressedSize(s);\n                 s = z64.getSize().getLongValue();\n                 if (s < 0L) {\n                     throw new ZipException(\"broken archive, entry with negative size\");\n                 }\n-                ZipArchiveInputStream.CurrentEntry.access$400(this.current).setSize(s);\n+                ZipArchiveInputStream.CurrentEntry.access$2(this.current).setSize(s);\n             }\n             else if (cSize != null && size != null) {\n                 if (cSize.getValue() < 0L) {\n                     throw new ZipException(\"broken archive, entry with negative compressed size\");\n                 }\n-                ZipArchiveInputStream.CurrentEntry.access$400(this.current).setCompressedSize(cSize.getValue());\n+                ZipArchiveInputStream.CurrentEntry.access$2(this.current).setCompressedSize(cSize.getValue());\n                 if (size.getValue() < 0L) {\n                     throw new ZipException(\"broken archive, entry with negative size\");\n                 }\n-                ZipArchiveInputStream.CurrentEntry.access$400(this.current).setSize(size.getValue());\n+                ZipArchiveInputStream.CurrentEntry.access$2(this.current).setSize(size.getValue());\n             }\n         }\n     }\n     \n     private void pushback(final byte[] buf, final int offset, final int length) throws IOException {\n         ((PushbackInputStream)this.inputStream).unread(buf, offset, length);\n         this.pushedBackBytes((long)length);\n@@ -488,75 +498,75 @@\n         }\n         if (this.current == null) {\n             return -1;\n         }\n         if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n             throw new ArrayIndexOutOfBoundsException();\n         }\n-        ZipUtil.checkRequestedFeatures(ZipArchiveInputStream.CurrentEntry.access$400(this.current));\n-        if (!this.supportsDataDescriptorFor(ZipArchiveInputStream.CurrentEntry.access$400(this.current))) {\n-            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, ZipArchiveInputStream.CurrentEntry.access$400(this.current));\n+        ZipUtil.checkRequestedFeatures(ZipArchiveInputStream.CurrentEntry.access$2(this.current));\n+        if (!this.supportsDataDescriptorFor(ZipArchiveInputStream.CurrentEntry.access$2(this.current))) {\n+            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, ZipArchiveInputStream.CurrentEntry.access$2(this.current));\n         }\n-        if (!this.supportsCompressedSizeFor(ZipArchiveInputStream.CurrentEntry.access$400(this.current))) {\n-            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.UNKNOWN_COMPRESSED_SIZE, ZipArchiveInputStream.CurrentEntry.access$400(this.current));\n+        if (!this.supportsCompressedSizeFor(ZipArchiveInputStream.CurrentEntry.access$2(this.current))) {\n+            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.UNKNOWN_COMPRESSED_SIZE, ZipArchiveInputStream.CurrentEntry.access$2(this.current));\n         }\n         int read;\n-        if (ZipArchiveInputStream.CurrentEntry.access$400(this.current).getMethod() == 0) {\n+        if (ZipArchiveInputStream.CurrentEntry.access$2(this.current).getMethod() == 0) {\n             read = this.readStored(buffer, offset, length);\n         }\n-        else if (ZipArchiveInputStream.CurrentEntry.access$400(this.current).getMethod() == 8) {\n+        else if (ZipArchiveInputStream.CurrentEntry.access$2(this.current).getMethod() == 8) {\n             read = this.readDeflated(buffer, offset, length);\n         }\n         else {\n-            if (ZipArchiveInputStream.CurrentEntry.access$400(this.current).getMethod() != ZipMethod.UNSHRINKING.getCode() && ZipArchiveInputStream.CurrentEntry.access$400(this.current).getMethod() != ZipMethod.IMPLODING.getCode() && ZipArchiveInputStream.CurrentEntry.access$400(this.current).getMethod() != ZipMethod.ENHANCED_DEFLATED.getCode() && ZipArchiveInputStream.CurrentEntry.access$400(this.current).getMethod() != ZipMethod.BZIP2.getCode()) {\n-                throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(ZipArchiveInputStream.CurrentEntry.access$400(this.current).getMethod()), ZipArchiveInputStream.CurrentEntry.access$400(this.current));\n+            if (ZipArchiveInputStream.CurrentEntry.access$2(this.current).getMethod() != ZipMethod.UNSHRINKING.getCode() && ZipArchiveInputStream.CurrentEntry.access$2(this.current).getMethod() != ZipMethod.IMPLODING.getCode() && ZipArchiveInputStream.CurrentEntry.access$2(this.current).getMethod() != ZipMethod.ENHANCED_DEFLATED.getCode() && ZipArchiveInputStream.CurrentEntry.access$2(this.current).getMethod() != ZipMethod.BZIP2.getCode()) {\n+                throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(ZipArchiveInputStream.CurrentEntry.access$2(this.current).getMethod()), ZipArchiveInputStream.CurrentEntry.access$2(this.current));\n             }\n-            read = ZipArchiveInputStream.CurrentEntry.access$900(this.current).read(buffer, offset, length);\n+            read = ZipArchiveInputStream.CurrentEntry.access$10(this.current).read(buffer, offset, length);\n         }\n         if (read >= 0) {\n-            ZipArchiveInputStream.CurrentEntry.access$1100(this.current).update(buffer, offset, read);\n+            ZipArchiveInputStream.CurrentEntry.access$11(this.current).update(buffer, offset, read);\n             this.uncompressedCount += read;\n         }\n         return read;\n     }\n     \n     private void readDataDescriptor() throws IOException {\n         this.readFully(this.wordBuf);\n         ZipLong val = new ZipLong(this.wordBuf);\n         if (ZipLong.DD_SIG.equals((Object)val)) {\n             this.readFully(this.wordBuf);\n             val = new ZipLong(this.wordBuf);\n         }\n-        ZipArchiveInputStream.CurrentEntry.access$400(this.current).setCrc(val.getValue());\n+        ZipArchiveInputStream.CurrentEntry.access$2(this.current).setCrc(val.getValue());\n         this.readFully(this.twoDwordBuf);\n         final ZipLong potentialSig = new ZipLong(this.twoDwordBuf, 8);\n         if (potentialSig.equals((Object)ZipLong.CFH_SIG) || potentialSig.equals((Object)ZipLong.LFH_SIG)) {\n             this.pushback(this.twoDwordBuf, 8, 8);\n             long size = ZipLong.getValue(this.twoDwordBuf);\n             if (size < 0L) {\n                 throw new ZipException(\"broken archive, entry with negative compressed size\");\n             }\n-            ZipArchiveInputStream.CurrentEntry.access$400(this.current).setCompressedSize(size);\n+            ZipArchiveInputStream.CurrentEntry.access$2(this.current).setCompressedSize(size);\n             size = ZipLong.getValue(this.twoDwordBuf, 4);\n             if (size < 0L) {\n                 throw new ZipException(\"broken archive, entry with negative size\");\n             }\n-            ZipArchiveInputStream.CurrentEntry.access$400(this.current).setSize(size);\n+            ZipArchiveInputStream.CurrentEntry.access$2(this.current).setSize(size);\n         }\n         else {\n             long size = ZipEightByteInteger.getLongValue(this.twoDwordBuf);\n             if (size < 0L) {\n                 throw new ZipException(\"broken archive, entry with negative compressed size\");\n             }\n-            ZipArchiveInputStream.CurrentEntry.access$400(this.current).setCompressedSize(size);\n+            ZipArchiveInputStream.CurrentEntry.access$2(this.current).setCompressedSize(size);\n             size = ZipEightByteInteger.getLongValue(this.twoDwordBuf, 8);\n             if (size < 0L) {\n                 throw new ZipException(\"broken archive, entry with negative size\");\n             }\n-            ZipArchiveInputStream.CurrentEntry.access$400(this.current).setSize(size);\n+            ZipArchiveInputStream.CurrentEntry.access$2(this.current).setSize(size);\n         }\n     }\n     \n     private int readDeflated(final byte[] buffer, final int offset, final int length) throws IOException {\n         final int read = this.readFromInflater(buffer, offset, length);\n         if (read <= 0) {\n             if (this.inf.finished()) {\n@@ -588,15 +598,16 @@\n     \n     private int readFromInflater(final byte[] buffer, final int offset, final int length) throws IOException {\n         int read = 0;\n         do {\n             if (this.inf.needsInput()) {\n                 final int l = this.fill();\n                 if (l > 0) {\n-                    ZipArchiveInputStream.CurrentEntry.access$214(this.current, (long)this.buf.limit());\n+                    final ZipArchiveInputStream.CurrentEntry current = this.current;\n+                    ZipArchiveInputStream.CurrentEntry.access$1(current, ZipArchiveInputStream.CurrentEntry.access$0(current) + (long)this.buf.limit());\n                 }\n                 else {\n                     if (l == -1) {\n                         return -1;\n                     }\n                     break;\n                 }\n@@ -638,49 +649,51 @@\n         if (ret.length < len) {\n             throw new EOFException();\n         }\n         return ret;\n     }\n     \n     private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n-        if (ZipArchiveInputStream.CurrentEntry.access$600(this.current)) {\n+        if (ZipArchiveInputStream.CurrentEntry.access$4(this.current)) {\n             if (this.lastStoredEntry == null) {\n                 this.readStoredEntry();\n             }\n             return this.lastStoredEntry.read(buffer, offset, length);\n         }\n-        final long csize = ZipArchiveInputStream.CurrentEntry.access$400(this.current).getSize();\n-        if (ZipArchiveInputStream.CurrentEntry.access$500(this.current) >= csize) {\n+        final long csize = ZipArchiveInputStream.CurrentEntry.access$2(this.current).getSize();\n+        if (ZipArchiveInputStream.CurrentEntry.access$3(this.current) >= csize) {\n             return -1;\n         }\n         if (this.buf.position() >= this.buf.limit()) {\n             this.buf.position();\n             final int l = this.inputStream.read(this.buf.array());\n             if (l == -1) {\n                 this.buf.limit();\n                 throw new IOException(\"Truncated ZIP file\");\n             }\n             this.buf.limit();\n             this.count(l);\n-            ZipArchiveInputStream.CurrentEntry.access$214(this.current, (long)l);\n+            final ZipArchiveInputStream.CurrentEntry current = this.current;\n+            ZipArchiveInputStream.CurrentEntry.access$1(current, ZipArchiveInputStream.CurrentEntry.access$0(current) + (long)l);\n         }\n         int toRead = Math.min(this.buf.remaining(), length);\n-        if (csize - ZipArchiveInputStream.CurrentEntry.access$500(this.current) < toRead) {\n-            toRead = (int)(csize - ZipArchiveInputStream.CurrentEntry.access$500(this.current));\n+        if (csize - ZipArchiveInputStream.CurrentEntry.access$3(this.current) < toRead) {\n+            toRead = (int)(csize - ZipArchiveInputStream.CurrentEntry.access$3(this.current));\n         }\n         this.buf.get(buffer, offset, toRead);\n-        ZipArchiveInputStream.CurrentEntry.access$514(this.current, (long)toRead);\n+        final ZipArchiveInputStream.CurrentEntry current2 = this.current;\n+        ZipArchiveInputStream.CurrentEntry.access$12(current2, ZipArchiveInputStream.CurrentEntry.access$3(current2) + (long)toRead);\n         return toRead;\n     }\n     \n     private void readStoredEntry() throws IOException {\n         final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n         int off = 0;\n         boolean done = false;\n-        final int ddLen = ZipArchiveInputStream.CurrentEntry.access$1000(this.current) ? 20 : 12;\n+        final int ddLen = ZipArchiveInputStream.CurrentEntry.access$13(this.current) ? 20 : 12;\n         while (!done) {\n             final int r = this.inputStream.read(this.buf.array(), off, 512 - off);\n             if (r <= 0) {\n                 throw new IOException(\"Truncated ZIP file\");\n             }\n             if (r + off < 4) {\n                 off += r;\n@@ -689,19 +702,19 @@\n                 done = this.bufferContainsSignature(bos, off, r, ddLen);\n                 if (done) {\n                     continue;\n                 }\n                 off = this.cacheBytesRead(bos, off, r, ddLen);\n             }\n         }\n-        if (ZipArchiveInputStream.CurrentEntry.access$400(this.current).getCompressedSize() != ZipArchiveInputStream.CurrentEntry.access$400(this.current).getSize()) {\n+        if (ZipArchiveInputStream.CurrentEntry.access$2(this.current).getCompressedSize() != ZipArchiveInputStream.CurrentEntry.access$2(this.current).getSize()) {\n             throw new ZipException(\"compressed and uncompressed size don't match while reading a stored entry using data descriptor. Either the archive is broken or it can not be read using ZipArchiveInputStream and you must use ZipFile. A common cause for this is a ZIP archive containing a ZIP archive. See http://commons.apache.org/proper/commons-compress/zip.html#ZipArchiveInputStream_vs_ZipFile\");\n         }\n         final byte[] b = bos.toByteArray();\n-        if (b.length != ZipArchiveInputStream.CurrentEntry.access$400(this.current).getSize()) {\n+        if (b.length != ZipArchiveInputStream.CurrentEntry.access$2(this.current).getSize()) {\n             throw new ZipException(\"actual and claimed size don't match while reading a stored entry using data descriptor. Either the archive is broken or it can not be read using ZipArchiveInputStream and you must use ZipFile. A common cause for this is a ZIP archive containing a ZIP archive. See http://commons.apache.org/proper/commons-compress/zip.html#ZipArchiveInputStream_vs_ZipFile\");\n         }\n         this.lastStoredEntry = new ByteArrayInputStream(b);\n     }\n     \n     private void realSkip(final long value) throws IOException {\n         if (value >= 0L) {\n@@ -755,16 +768,8 @@\n     private boolean supportsCompressedSizeFor(final ZipArchiveEntry entry) {\n         return entry.getCompressedSize() != -1L || entry.getMethod() == 8 || entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || (entry.getGeneralPurposeBit().usesDataDescriptor() && this.allowStoredEntriesWithDataDescriptor && entry.getMethod() == 0);\n     }\n     \n     private boolean supportsDataDescriptorFor(final ZipArchiveEntry entry) {\n         return !entry.getGeneralPurposeBit().usesDataDescriptor() || (this.allowStoredEntriesWithDataDescriptor && entry.getMethod() == 0) || entry.getMethod() == 8 || entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode();\n     }\n-    \n-    static {\n-        LFH = ZipLong.LFH_SIG.getBytes();\n-        CFH = ZipLong.CFH_SIG.getBytes();\n-        DD = ZipLong.DD_SIG.getBytes();\n-        APK_SIGNING_BLOCK_MAGIC = new byte[] { 65, 80, 75, 32, 83, 105, 103, 32, 66, 108, 111, 99, 107, 32, 52, 50 };\n-        LONG_MAX = BigInteger.valueOf(Long.MAX_VALUE);\n-    }\n }\n"}]}
