{"diffoscope-json-version": 1, "source1": "first/LDC.class", "source2": "second/LDC.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -2,55 +2,55 @@\n package org.apache.bcel.generic;\n \n import org.apache.bcel.util.ByteSequence;\n import org.apache.bcel.classfile.Constant;\n import org.apache.bcel.classfile.ConstantClass;\n import org.apache.bcel.classfile.ConstantInteger;\n import org.apache.bcel.classfile.ConstantFloat;\n-import org.apache.bcel.classfile.ConstantUtf8;\n import org.apache.bcel.classfile.ConstantString;\n+import org.apache.bcel.classfile.ConstantUtf8;\n import org.apache.bcel.ExceptionConst;\n import java.io.IOException;\n import java.io.DataOutputStream;\n \n public class LDC extends CPInstruction implements PushInstruction, ExceptionThrower\n {\n     LDC() {\n     }\n     \n-    public LDC(final int index) {\n-        super((short)19, index);\n+    public LDC(final int n) {\n+        super((short)19, n);\n         this.setSize();\n     }\n     \n-    public void accept(final Visitor v) {\n-        v.visitStackProducer((StackProducer)this);\n-        v.visitPushInstruction((PushInstruction)this);\n-        v.visitExceptionThrower((ExceptionThrower)this);\n-        v.visitTypedInstruction((TypedInstruction)this);\n-        v.visitCPInstruction((CPInstruction)this);\n-        v.visitLDC(this);\n+    public void accept(final Visitor visitor) {\n+        visitor.visitStackProducer((StackProducer)this);\n+        visitor.visitPushInstruction((PushInstruction)this);\n+        visitor.visitExceptionThrower((ExceptionThrower)this);\n+        visitor.visitTypedInstruction((TypedInstruction)this);\n+        visitor.visitCPInstruction((CPInstruction)this);\n+        visitor.visitLDC(this);\n     }\n     \n-    public void dump(final DataOutputStream out) throws IOException {\n-        out.writeByte(super.getOpcode());\n+    public void dump(final DataOutputStream dataOutputStream) throws IOException {\n+        dataOutputStream.writeByte(super.getOpcode());\n         if (super.getLength() == 2) {\n-            out.writeByte(super.getIndex());\n+            dataOutputStream.writeByte(super.getIndex());\n         }\n         else {\n-            out.writeShort(super.getIndex());\n+            dataOutputStream.writeShort(super.getIndex());\n         }\n     }\n     \n     public Class<?>[] getExceptions() {\n         return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_STRING_RESOLUTION, new Class[0]);\n     }\n     \n-    public Type getType(final ConstantPoolGen cpg) {\n-        switch (cpg.getConstantPool().getConstant(super.getIndex()).getTag()) {\n+    public Type getType(final ConstantPoolGen constantPoolGen) {\n+        switch (constantPoolGen.getConstantPool().getConstant(super.getIndex()).getTag()) {\n             case 8: {\n                 return (Type)Type.STRING;\n             }\n             case 4: {\n                 return (Type)Type.FLOAT;\n             }\n             case 3: {\n@@ -61,42 +61,38 @@\n             }\n             default: {\n                 throw new IllegalArgumentException(\"Unknown or invalid constant type at \" + super.getIndex());\n             }\n         }\n     }\n     \n-    public Object getValue(final ConstantPoolGen cpg) {\n-        Constant c = cpg.getConstantPool().getConstant(super.getIndex());\n-        switch (c.getTag()) {\n+    public Object getValue(final ConstantPoolGen constantPoolGen) {\n+        final Constant constant = constantPoolGen.getConstantPool().getConstant(super.getIndex());\n+        switch (constant.getTag()) {\n             case 8: {\n-                final int i = ((ConstantString)c).getStringIndex();\n-                c = cpg.getConstantPool().getConstant(i);\n-                return ((ConstantUtf8)c).getBytes();\n+                return ((ConstantUtf8)constantPoolGen.getConstantPool().getConstant(((ConstantString)constant).getStringIndex())).getBytes();\n             }\n             case 4: {\n-                return Float.valueOf(((ConstantFloat)c).getBytes());\n+                return Float.valueOf(((ConstantFloat)constant).getBytes());\n             }\n             case 3: {\n-                return Integer.valueOf(((ConstantInteger)c).getBytes());\n+                return Integer.valueOf(((ConstantInteger)constant).getBytes());\n             }\n             case 7: {\n-                final int nameIndex = ((ConstantClass)c).getNameIndex();\n-                c = cpg.getConstantPool().getConstant(nameIndex);\n-                return new ObjectType(((ConstantUtf8)c).getBytes());\n+                return new ObjectType(((ConstantUtf8)constantPoolGen.getConstantPool().getConstant(((ConstantClass)constant).getNameIndex())).getBytes());\n             }\n             default: {\n                 throw new IllegalArgumentException(\"Unknown or invalid constant type at \" + super.getIndex());\n             }\n         }\n     }\n     \n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+    protected void initFromFile(final ByteSequence byteSequence, final boolean b) throws IOException {\n         super.setLength(2);\n-        super.setIndex(bytes.readUnsignedByte());\n+        super.setIndex(byteSequence.readUnsignedByte());\n     }\n     \n     public final void setIndex(final int index) {\n         super.setIndex(index);\n         this.setSize();\n     }\n     \n"}]}
