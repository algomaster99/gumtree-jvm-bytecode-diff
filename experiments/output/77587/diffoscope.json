{"diffoscope-json-version": 1, "source1": "first/MethodUtils.class", "source2": "second/MethodUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -3,78 +3,80 @@\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.TypeVariable;\n import java.util.Map;\n import java.lang.reflect.Type;\n import java.util.LinkedHashSet;\n import java.util.Set;\n-import java.util.stream.Stream;\n import java.util.TreeMap;\n import java.util.function.Consumer;\n-import java.util.Objects;\n-import java.util.function.Function;\n import java.util.stream.Collector;\n import java.util.stream.Collectors;\n import java.util.Arrays;\n import org.apache.commons.lang3.Validate;\n import java.util.Iterator;\n import java.util.List;\n import java.util.ArrayList;\n import java.lang.reflect.AccessibleObject;\n import java.lang.reflect.Modifier;\n import java.lang.reflect.Member;\n import java.lang.reflect.Array;\n import org.apache.commons.lang3.ClassUtils;\n import java.lang.reflect.InvocationTargetException;\n import org.apache.commons.lang3.ArrayUtils;\n+import java.util.function.Function;\n import java.lang.reflect.Method;\n import java.util.Comparator;\n \n public class MethodUtils\n {\n     private static final Comparator<Method> METHOD_BY_SIGNATURE;\n     \n+    static {\n+        METHOD_BY_SIGNATURE = Comparator.comparing((Function<? super Method, ? extends Comparable>)Method::toString);\n+    }\n+    \n     public static Object invokeMethod(final Object object, final String methodName) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n         return invokeMethod(object, methodName, ArrayUtils.EMPTY_OBJECT_ARRAY, null);\n     }\n     \n     public static Object invokeMethod(final Object object, final boolean forceAccess, final String methodName) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n         return invokeMethod(object, forceAccess, methodName, ArrayUtils.EMPTY_OBJECT_ARRAY, null);\n     }\n     \n     public static Object invokeMethod(final Object object, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n         args = ArrayUtils.nullToEmpty(args);\n-        final Class<?>[] parameterTypes = ClassUtils.toClass(args);\n+        final Class[] parameterTypes = ClassUtils.toClass(args);\n         return invokeMethod(object, methodName, args, parameterTypes);\n     }\n     \n     public static Object invokeMethod(final Object object, final boolean forceAccess, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n         args = ArrayUtils.nullToEmpty(args);\n-        final Class<?>[] parameterTypes = ClassUtils.toClass(args);\n+        final Class[] parameterTypes = ClassUtils.toClass(args);\n         return invokeMethod(object, forceAccess, methodName, args, parameterTypes);\n     }\n     \n     public static Object invokeMethod(final Object object, final boolean forceAccess, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n-        parameterTypes = ArrayUtils.nullToEmpty((Class[])parameterTypes);\n+        parameterTypes = ArrayUtils.nullToEmpty(parameterTypes);\n         args = ArrayUtils.nullToEmpty(args);\n         Method method = null;\n         String messagePrefix;\n         if (forceAccess) {\n             messagePrefix = \"No such method: \";\n-            method = getMatchingMethod(object.getClass(), methodName, parameterTypes);\n+            method = getMatchingMethod(object.getClass(), methodName, (Class<?>[])parameterTypes);\n             if (method != null && !method.isAccessible()) {\n                 method.setAccessible(true);\n             }\n         }\n         else {\n             messagePrefix = \"No such accessible method: \";\n-            method = getMatchingAccessibleMethod(object.getClass(), methodName, parameterTypes);\n+            method = getMatchingAccessibleMethod(object.getClass(), methodName, (Class<?>[])parameterTypes);\n         }\n         if (method == null) {\n-            throw new NoSuchMethodException(messagePrefix + methodName + \"() on object: \" + object.getClass().getName());\n+            throw new NoSuchMethodException(String.valueOf(messagePrefix) + methodName + \"() on object: \" + object.getClass().getName());\n         }\n         args = toVarArgs(method, args);\n         return method.invoke(object, args);\n     }\n     \n     public static Object invokeMethod(final Object object, final String methodName, final Object[] args, final Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n         return invokeMethod(object, false, methodName, args, parameterTypes);\n@@ -82,58 +84,58 @@\n     \n     public static Object invokeExactMethod(final Object object, final String methodName) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n         return invokeExactMethod(object, methodName, ArrayUtils.EMPTY_OBJECT_ARRAY, null);\n     }\n     \n     public static Object invokeExactMethod(final Object object, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n         args = ArrayUtils.nullToEmpty(args);\n-        final Class<?>[] parameterTypes = ClassUtils.toClass(args);\n+        final Class[] parameterTypes = ClassUtils.toClass(args);\n         return invokeExactMethod(object, methodName, args, parameterTypes);\n     }\n     \n     public static Object invokeExactMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n         args = ArrayUtils.nullToEmpty(args);\n-        parameterTypes = ArrayUtils.nullToEmpty((Class[])parameterTypes);\n-        final Method method = getAccessibleMethod(object.getClass(), methodName, parameterTypes);\n+        parameterTypes = ArrayUtils.nullToEmpty(parameterTypes);\n+        final Method method = getAccessibleMethod(object.getClass(), methodName, (Class<?>[])parameterTypes);\n         if (method == null) {\n             throw new NoSuchMethodException(\"No such accessible method: \" + methodName + \"() on object: \" + object.getClass().getName());\n         }\n         return method.invoke(object, args);\n     }\n     \n     public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n         args = ArrayUtils.nullToEmpty(args);\n-        parameterTypes = ArrayUtils.nullToEmpty((Class[])parameterTypes);\n-        final Method method = getAccessibleMethod(cls, methodName, parameterTypes);\n+        parameterTypes = ArrayUtils.nullToEmpty(parameterTypes);\n+        final Method method = getAccessibleMethod(cls, methodName, (Class<?>[])parameterTypes);\n         if (method == null) {\n             throw new NoSuchMethodException(\"No such accessible method: \" + methodName + \"() on class: \" + cls.getName());\n         }\n         return method.invoke(null, args);\n     }\n     \n     public static Object invokeStaticMethod(final Class<?> cls, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n         args = ArrayUtils.nullToEmpty(args);\n-        final Class<?>[] parameterTypes = ClassUtils.toClass(args);\n+        final Class[] parameterTypes = ClassUtils.toClass(args);\n         return invokeStaticMethod(cls, methodName, args, parameterTypes);\n     }\n     \n     public static Object invokeStaticMethod(final Class<?> cls, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n         args = ArrayUtils.nullToEmpty(args);\n-        parameterTypes = ArrayUtils.nullToEmpty((Class[])parameterTypes);\n-        final Method method = getMatchingAccessibleMethod(cls, methodName, parameterTypes);\n+        parameterTypes = ArrayUtils.nullToEmpty(parameterTypes);\n+        final Method method = getMatchingAccessibleMethod(cls, methodName, (Class<?>[])parameterTypes);\n         if (method == null) {\n             throw new NoSuchMethodException(\"No such accessible method: \" + methodName + \"() on class: \" + cls.getName());\n         }\n         args = toVarArgs(method, args);\n         return method.invoke(null, args);\n     }\n     \n     private static Object[] toVarArgs(final Method method, Object[] args) {\n         if (method.isVarArgs()) {\n-            final Class<?>[] methodParameterTypes = method.getParameterTypes();\n+            final Class[] methodParameterTypes = method.getParameterTypes();\n             args = getVarArgs(args, methodParameterTypes);\n         }\n         return args;\n     }\n     \n     static Object[] getVarArgs(final Object[] args, final Class<?>[] methodParameterTypes) {\n         if (args.length == methodParameterTypes.length && (args[args.length - 1] == null || args[args.length - 1].getClass().equals(methodParameterTypes[methodParameterTypes.length - 1]))) {\n@@ -150,15 +152,15 @@\n         }\n         newArgs[methodParameterTypes.length - 1] = varArgsArray;\n         return newArgs;\n     }\n     \n     public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n         args = ArrayUtils.nullToEmpty(args);\n-        final Class<?>[] parameterTypes = ClassUtils.toClass(args);\n+        final Class[] parameterTypes = ClassUtils.toClass(args);\n         return invokeExactStaticMethod(cls, methodName, args, parameterTypes);\n     }\n     \n     public static Method getAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) {\n         try {\n             return getAccessibleMethod(cls.getMethod(methodName, parameterTypes));\n         }\n@@ -172,18 +174,18 @@\n             return null;\n         }\n         final Class<?> cls = method.getDeclaringClass();\n         if (Modifier.isPublic(cls.getModifiers())) {\n             return method;\n         }\n         final String methodName = method.getName();\n-        final Class<?>[] parameterTypes = method.getParameterTypes();\n-        method = getAccessibleMethodFromInterfaceNest(cls, methodName, parameterTypes);\n+        final Class[] parameterTypes = method.getParameterTypes();\n+        method = getAccessibleMethodFromInterfaceNest(cls, methodName, (Class<?>[])parameterTypes);\n         if (method == null) {\n-            method = getAccessibleMethodFromSuperclass(cls, methodName, parameterTypes);\n+            method = getAccessibleMethodFromSuperclass(cls, methodName, (Class<?>[])parameterTypes);\n         }\n         return method;\n     }\n     \n     private static Method getAccessibleMethodFromSuperclass(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) {\n         for (Class<?> parentClass = cls.getSuperclass(); parentClass != null; parentClass = parentClass.getSuperclass()) {\n             if (Modifier.isPublic(parentClass.getModifiers())) {\n@@ -196,17 +198,18 @@\n             }\n         }\n         return null;\n     }\n     \n     private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls, final String methodName, final Class<?>... parameterTypes) {\n         while (cls != null) {\n-            final Class<?>[] interfaces2;\n-            final Class<?>[] interfaces = interfaces2 = cls.getInterfaces();\n-            for (final Class<?> anInterface : interfaces2) {\n+            final Class[] interfaces = cls.getInterfaces();\n+            Class[] array;\n+            for (int length = (array = interfaces).length, i = 0; i < length; ++i) {\n+                final Class<?> anInterface = array[i];\n                 if (Modifier.isPublic(anInterface.getModifiers())) {\n                     try {\n                         return anInterface.getDeclaredMethod(methodName, parameterTypes);\n                     }\n                     catch (final NoSuchMethodException ex) {\n                         final Method method = getAccessibleMethodFromInterfaceNest(anInterface, methodName, parameterTypes);\n                         if (method != null) {\n@@ -225,15 +228,17 @@\n             final Method method = cls.getMethod(methodName, parameterTypes);\n             MemberUtils.setAccessibleWorkaround((AccessibleObject)method);\n             return method;\n         }\n         catch (final NoSuchMethodException ex) {\n             final Method[] methods = cls.getMethods();\n             final List<Method> matchingMethods = new ArrayList<Method>();\n-            for (final Method method2 : methods) {\n+            Method[] array;\n+            for (int length = (array = methods).length, i = 0; i < length; ++i) {\n+                final Method method2 = array[i];\n                 if (method2.getName().equals(methodName) && MemberUtils.isMatchingMethod(method2, (Class[])parameterTypes)) {\n                     matchingMethods.add(method2);\n                 }\n             }\n             matchingMethods.sort(MethodUtils.METHOD_BY_SIGNATURE);\n             Method bestMatch = null;\n             for (final Method method3 : matchingMethods) {\n@@ -242,15 +247,15 @@\n                     bestMatch = accessibleMethod;\n                 }\n             }\n             if (bestMatch != null) {\n                 MemberUtils.setAccessibleWorkaround((AccessibleObject)bestMatch);\n             }\n             if (bestMatch != null && bestMatch.isVarArgs() && bestMatch.getParameterTypes().length > 0 && parameterTypes.length > 0) {\n-                final Class<?>[] methodParameterTypes = bestMatch.getParameterTypes();\n+                final Class[] methodParameterTypes = bestMatch.getParameterTypes();\n                 final Class<?> methodParameterComponentType = methodParameterTypes[methodParameterTypes.length - 1].getComponentType();\n                 final String methodParameterComponentTypeName = ClassUtils.primitiveToWrapper((Class)methodParameterComponentType).getName();\n                 final Class<?> lastParameterType = parameterTypes[parameterTypes.length - 1];\n                 final String parameterTypeName = (lastParameterType == null) ? null : lastParameterType.getName();\n                 final String parameterTypeSuperClassName = (lastParameterType == null) ? null : lastParameterType.getSuperclass().getName();\n                 if (parameterTypeName != null && parameterTypeSuperClassName != null && !methodParameterComponentTypeName.equals(parameterTypeName) && !methodParameterComponentTypeName.equals(parameterTypeSuperClassName)) {\n                     return null;\n@@ -260,41 +265,38 @@\n         }\n     }\n     \n     public static Method getMatchingMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) {\n         Validate.notNull((Object)cls, \"cls\", new Object[0]);\n         Validate.notEmpty((CharSequence)methodName, \"methodName\", new Object[0]);\n         Method method = null;\n-        final List<Method> methods = (List<Method>)Arrays.stream(cls.getDeclaredMethods()).filter(method -> method.getName().equals(methodName)).collect((Collector<? super Method, ?, List<Method>>)Collectors.toList());\n-        final Stream filter = ClassUtils.getAllSuperclasses((Class)cls).stream().map(Class::getDeclaredMethods).flatMap(Arrays::stream).filter(method -> method.getName().equals(methodName));\n-        final List<Method> obj = methods;\n-        Objects.requireNonNull(obj);\n-        filter.forEach(obj::add);\n+        final List<Method> methods = (List<Method>)Arrays.stream(cls.getDeclaredMethods()).filter(method -> method.getName().equals(anObject)).collect((Collector<? super Method, ?, List<Method>>)Collectors.toList());\n+        ClassUtils.getAllSuperclasses((Class)cls).stream().map(Class::getDeclaredMethods).flatMap(Arrays::stream).filter(method -> method.getName().equals(anObject2)).forEach(methods::add);\n         final Iterator<Method> iterator = methods.iterator();\n         while (iterator.hasNext()) {\n             method = iterator.next();\n             if (Arrays.deepEquals(method.getParameterTypes(), parameterTypes)) {\n                 return method;\n             }\n         }\n         final TreeMap<Integer, List<Method>> candidates = new TreeMap<Integer, List<Method>>();\n-        methods.stream().filter(method -> ClassUtils.isAssignable(parameterTypes, (Class[])method.getParameterTypes(), true)).forEach(method -> {\n-            final int distance = distance(parameterTypes, method.getParameterTypes());\n-            final List<Method> candidatesAtDistance = (List<Method>)candidates.computeIfAbsent(Integer.valueOf(distance), k -> new ArrayList());\n+        methods.stream().filter(method -> ClassUtils.isAssignable(array, (Class[])method.getParameterTypes(), true)).forEach(method -> {\n+            final int distance = distance(fromClassArray, method.getParameterTypes());\n+            final List<Method> candidatesAtDistance = (List<Method>)treeMap.computeIfAbsent(Integer.valueOf(distance), k -> new ArrayList());\n             candidatesAtDistance.add(method);\n             return;\n         });\n         if (candidates.isEmpty()) {\n             return null;\n         }\n         final List<Method> bestCandidates = (List<Method>)candidates.values().iterator().next();\n         if (bestCandidates.size() == 1) {\n             return bestCandidates.get(0);\n         }\n-        throw new IllegalStateException(String.format(\"Found multiple candidates for method %s on class %s : %s\", methodName + Arrays.stream(parameterTypes).map((Function<? super Class<?>, ?>)String::valueOf).collect((Collector<? super Object, ?, String>)Collectors.joining(\",\", \"(\", \")\")), cls.getName(), bestCandidates.stream().map((Function<? super Object, ?>)Method::toString).collect((Collector<? super Object, ?, String>)Collectors.joining(\",\", \"[\", \"]\"))));\n+        throw new IllegalStateException(String.format(\"Found multiple candidates for method %s on class %s : %s\", String.valueOf(methodName) + Arrays.stream(parameterTypes).map((Function<? super Class<?>, ?>)String::valueOf).collect((Collector<? super Object, ?, String>)Collectors.joining(\",\", \"(\", \")\")), cls.getName(), bestCandidates.stream().map((Function<? super Object, ?>)Method::toString).collect((Collector<? super Object, ?, String>)Collectors.joining(\",\", \"[\", \"]\"))));\n     }\n     \n     private static int distance(final Class<?>[] fromClassArray, final Class<?>[] toClassArray) {\n         int answer = 0;\n         if (!ClassUtils.isAssignable((Class[])fromClassArray, (Class[])toClassArray, true)) {\n             return -1;\n         }\n@@ -315,35 +317,35 @@\n         return answer;\n     }\n     \n     public static Set<Method> getOverrideHierarchy(final Method method, final ClassUtils.Interfaces interfacesBehavior) {\n         Validate.notNull((Object)method);\n         final Set<Method> result = new LinkedHashSet<Method>();\n         result.add(method);\n-        final Class<?>[] parameterTypes = method.getParameterTypes();\n+        final Class[] parameterTypes = method.getParameterTypes();\n         final Class<?> declaringClass = method.getDeclaringClass();\n         final Iterator<Class<?>> hierarchy = ClassUtils.hierarchy((Class)declaringClass, interfacesBehavior).iterator();\n         hierarchy.next();\n-    Label_0053:\n+    Label_0191:\n         while (hierarchy.hasNext()) {\n             final Class<?> c = (Class<?>)hierarchy.next();\n-            final Method m = getMatchingAccessibleMethod(c, method.getName(), parameterTypes);\n+            final Method m = getMatchingAccessibleMethod(c, method.getName(), (Class<?>[])parameterTypes);\n             if (m == null) {\n                 continue;\n             }\n             if (Arrays.equals(m.getParameterTypes(), parameterTypes)) {\n                 result.add(m);\n             }\n             else {\n                 final Map<TypeVariable<?>, Type> typeArguments = TypeUtils.getTypeArguments((Type)declaringClass, (Class)m.getDeclaringClass());\n                 for (int i = 0; i < parameterTypes.length; ++i) {\n                     final Type childType = TypeUtils.unrollVariables((Map)typeArguments, method.getGenericParameterTypes()[i]);\n                     final Type parentType = TypeUtils.unrollVariables((Map)typeArguments, m.getGenericParameterTypes()[i]);\n                     if (!TypeUtils.equals(childType, parentType)) {\n-                        continue Label_0053;\n+                        continue Label_0191;\n                     }\n                 }\n                 result.add(m);\n             }\n         }\n         return result;\n     }\n@@ -364,17 +366,18 @@\n     public static List<Method> getMethodsListWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls, final boolean searchSupers, final boolean ignoreAccess) {\n         Validate.notNull((Object)cls, \"cls\", new Object[0]);\n         Validate.notNull((Object)annotationCls, \"annotationCls\", new Object[0]);\n         final List<Class<?>> classes = searchSupers ? getAllSuperclassesAndInterfaces(cls) : new ArrayList<Class<?>>();\n         classes.add(0, cls);\n         final List<Method> annotatedMethods = new ArrayList<Method>();\n         for (final Class<?> acls : classes) {\n-            final Method[] array;\n-            final Method[] methods = array = (ignoreAccess ? acls.getDeclaredMethods() : acls.getMethods());\n-            for (final Method method : array) {\n+            final Method[] methods = ignoreAccess ? acls.getDeclaredMethods() : acls.getMethods();\n+            Method[] array;\n+            for (int length = (array = methods).length, i = 0; i < length; ++i) {\n+                final Method method = array[i];\n                 if (method.getAnnotation(annotationCls) != null) {\n                     annotatedMethods.add(method);\n                 }\n             }\n         }\n         return annotatedMethods;\n     }\n@@ -423,12 +426,8 @@\n             else {\n                 acls = allSuperclasses.get(superClassIndex++);\n             }\n             allSuperClassesAndInterfaces.add(acls);\n         }\n         return allSuperClassesAndInterfaces;\n     }\n-    \n-    static {\n-        METHOD_BY_SIGNATURE = Comparator.comparing((Function<? super Method, ? extends Comparable>)Method::toString);\n-    }\n }\n"}]}
