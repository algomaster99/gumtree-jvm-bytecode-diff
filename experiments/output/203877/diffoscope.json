{"diffoscope-json-version": 1, "source1": "first/RunCodec.class", "source2": "second/RunCodec.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -21,105 +21,104 @@\n             throw new Pack200Exception(\"Must supply both codecs for a RunCodec\");\n         }\n         this.k = k;\n         this.aCodec = aCodec;\n         this.bCodec = bCodec;\n     }\n     \n-    public int decode(final InputStream in) throws IOException, Pack200Exception {\n-        return this.decode(in, this.last);\n+    public int decode(final InputStream inputStream) throws IOException, Pack200Exception {\n+        return this.decode(inputStream, this.last);\n     }\n     \n-    public int decode(final InputStream in, final long last) throws IOException, Pack200Exception {\n+    public int decode(final InputStream inputStream, final long n) throws IOException, Pack200Exception {\n         final int k = this.k - 1;\n         this.k = k;\n         if (k >= 0) {\n-            final int value = this.aCodec.decode(in, (long)this.last);\n-            this.last = ((this.k == 0) ? 0 : value);\n-            return this.normalise(value, this.aCodec);\n+            final int decode = this.aCodec.decode(inputStream, (long)this.last);\n+            this.last = ((this.k == 0) ? 0 : decode);\n+            return this.normalise(decode, this.aCodec);\n         }\n-        this.last = this.bCodec.decode(in, (long)this.last);\n+        this.last = this.bCodec.decode(inputStream, (long)this.last);\n         return this.normalise(this.last, this.bCodec);\n     }\n     \n-    private int normalise(int value, final Codec codecUsed) {\n-        if (codecUsed instanceof BHSDCodec) {\n-            final BHSDCodec bhsd = (BHSDCodec)codecUsed;\n-            if (bhsd.isDelta()) {\n+    private int normalise(int add, final Codec codec) {\n+        if (codec instanceof BHSDCodec) {\n+            final BHSDCodec bhsdCodec = (BHSDCodec)codec;\n+            if (bhsdCodec.isDelta()) {\n                 long cardinality;\n-                for (cardinality = bhsd.cardinality(); value > bhsd.largest(); value -= cardinality) {}\n-                while (value < bhsd.smallest()) {\n-                    value = ExactMath.add(value, cardinality);\n+                for (cardinality = bhsdCodec.cardinality(); add > bhsdCodec.largest(); add -= cardinality) {}\n+                while (add < bhsdCodec.smallest()) {\n+                    add = ExactMath.add(add, cardinality);\n                 }\n             }\n         }\n-        return value;\n+        return add;\n     }\n     \n-    public int[] decodeInts(final int n, final InputStream in) throws IOException, Pack200Exception {\n-        final int[] band = new int[n];\n-        final int[] aValues = this.aCodec.decodeInts(this.k, in);\n-        this.normalise(aValues, this.aCodec);\n-        final int[] bValues = this.bCodec.decodeInts(n - this.k, in);\n-        this.normalise(bValues, this.bCodec);\n-        System.arraycopy(aValues, 0, band, 0, this.k);\n-        System.arraycopy(bValues, 0, band, this.k, n - this.k);\n+    public int[] decodeInts(final int n, final InputStream inputStream) throws IOException, Pack200Exception {\n+        final int[] array = new int[n];\n+        final int[] decodeInts = this.aCodec.decodeInts(this.k, inputStream);\n+        this.normalise(decodeInts, this.aCodec);\n+        final int[] decodeInts2 = this.bCodec.decodeInts(n - this.k, inputStream);\n+        this.normalise(decodeInts2, this.bCodec);\n+        System.arraycopy(decodeInts, 0, array, 0, this.k);\n+        System.arraycopy(decodeInts2, 0, array, this.k, n - this.k);\n         this.lastBandLength = this.aCodec.lastBandLength + this.bCodec.lastBandLength;\n-        return band;\n+        return array;\n     }\n     \n-    private void normalise(final int[] band, final Codec codecUsed) {\n-        if (codecUsed instanceof BHSDCodec) {\n-            final BHSDCodec bhsd = (BHSDCodec)codecUsed;\n-            if (bhsd.isDelta()) {\n-                final long cardinality = bhsd.cardinality();\n-                for (int i = 0; i < band.length; ++i) {\n-                    while (band[i] > bhsd.largest()) {\n+    private void normalise(final int[] array, final Codec codec) {\n+        if (codec instanceof BHSDCodec) {\n+            final BHSDCodec bhsdCodec = (BHSDCodec)codec;\n+            if (bhsdCodec.isDelta()) {\n+                final long cardinality = bhsdCodec.cardinality();\n+                for (int i = 0; i < array.length; ++i) {\n+                    while (array[i] > bhsdCodec.largest()) {\n                         final int n = i;\n-                        band[n] -= cardinality;\n+                        array[n] -= cardinality;\n                     }\n-                    while (band[i] < bhsd.smallest()) {\n-                        band[i] = ExactMath.add(band[i], cardinality);\n+                    while (array[i] < bhsdCodec.smallest()) {\n+                        array[i] = ExactMath.add(array[i], cardinality);\n                     }\n                 }\n             }\n         }\n-        else if (codecUsed instanceof PopulationCodec) {\n-            final PopulationCodec popCodec = (PopulationCodec)codecUsed;\n-            final int[] favoured = (int[])popCodec.getFavoured().clone();\n-            Arrays.sort(favoured);\n-            for (int j = 0; j < band.length; ++j) {\n-                final boolean favouredValue = Arrays.binarySearch(favoured, band[j]) > -1;\n-                final Codec theCodec = favouredValue ? popCodec.getFavouredCodec() : popCodec.getUnfavouredCodec();\n-                if (theCodec instanceof BHSDCodec) {\n-                    final BHSDCodec bhsd2 = (BHSDCodec)theCodec;\n-                    if (bhsd2.isDelta()) {\n-                        final long cardinality2 = bhsd2.cardinality();\n-                        while (band[j] > bhsd2.largest()) {\n+        else if (codec instanceof PopulationCodec) {\n+            final PopulationCodec populationCodec = (PopulationCodec)codec;\n+            final int[] array2 = (int[])populationCodec.getFavoured().clone();\n+            Arrays.sort(array2);\n+            for (int j = 0; j < array.length; ++j) {\n+                final Codec codec2 = (Arrays.binarySearch(array2, array[j]) > -1) ? populationCodec.getFavouredCodec() : populationCodec.getUnfavouredCodec();\n+                if (codec2 instanceof BHSDCodec) {\n+                    final BHSDCodec bhsdCodec2 = (BHSDCodec)codec2;\n+                    if (bhsdCodec2.isDelta()) {\n+                        final long cardinality2 = bhsdCodec2.cardinality();\n+                        while (array[j] > bhsdCodec2.largest()) {\n                             final int n2 = j;\n-                            band[n2] -= cardinality2;\n+                            array[n2] -= cardinality2;\n                         }\n-                        while (band[j] < bhsd2.smallest()) {\n-                            band[j] = ExactMath.add(band[j], cardinality2);\n+                        while (array[j] < bhsdCodec2.smallest()) {\n+                            array[j] = ExactMath.add(array[j], cardinality2);\n                         }\n                     }\n                 }\n             }\n         }\n     }\n     \n     public String toString() {\n         return \"RunCodec[k=\" + this.k + \";aCodec=\" + this.aCodec + \"bCodec=\" + this.bCodec + \"]\";\n     }\n     \n-    public byte[] encode(final int value, final int last) throws Pack200Exception {\n+    public byte[] encode(final int n, final int n2) throws Pack200Exception {\n         throw new Pack200Exception(\"Must encode entire band at once with a RunCodec\");\n     }\n     \n-    public byte[] encode(final int value) throws Pack200Exception {\n+    public byte[] encode(final int n) throws Pack200Exception {\n         throw new Pack200Exception(\"Must encode entire band at once with a RunCodec\");\n     }\n     \n     public int getK() {\n         return this.k;\n     }\n     \n"}]}
