{"diffoscope-json-version": 1, "source1": "first/StringUtils.class", "source2": "second/StringUtils.class", "unified_diff": null, "details": [{"source1": "procyon -ec {}", "source2": "procyon -ec {}", "unified_diff": "@@ -1,13 +1,12 @@\n \n package org.apache.commons.lang3;\n \n import java.text.Normalizer;\n import java.util.ArrayList;\n-import java.util.Set;\n import java.util.Collection;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Objects;\n import java.util.Iterator;\n import java.util.StringJoiner;\n import java.util.Arrays;\n@@ -25,3008 +24,2979 @@\n     public static final String EMPTY = \"\";\n     public static final String LF = \"\\n\";\n     public static final String CR = \"\\r\";\n     public static final int INDEX_NOT_FOUND = -1;\n     private static final int PAD_LIMIT = 8192;\n     private static final Pattern STRIP_ACCENTS_PATTERN;\n     \n-    public static String abbreviate(final String str, final int maxWidth) {\n-        return abbreviate(str, \"...\", 0, maxWidth);\n+    public static String abbreviate(final String s, final int n) {\n+        return abbreviate(s, \"...\", 0, n);\n     }\n     \n-    public static String abbreviate(final String str, final int offset, final int maxWidth) {\n-        return abbreviate(str, \"...\", offset, maxWidth);\n+    public static String abbreviate(final String s, final int n, final int n2) {\n+        return abbreviate(s, \"...\", n, n2);\n     }\n     \n-    public static String abbreviate(final String str, final String abbrevMarker, final int maxWidth) {\n-        return abbreviate(str, abbrevMarker, 0, maxWidth);\n+    public static String abbreviate(final String s, final String s2, final int n) {\n+        return abbreviate(s, s2, 0, n);\n     }\n     \n-    public static String abbreviate(final String str, final String abbrevMarker, int offset, final int maxWidth) {\n-        if (isNotEmpty(str) && \"\".equals(abbrevMarker) && maxWidth > 0) {\n-            return substring(str, 0, maxWidth);\n+    public static String abbreviate(final String s, final String s2, int beginIndex, final int n) {\n+        if (isNotEmpty(s) && \"\".equals(s2) && n > 0) {\n+            return substring(s, 0, n);\n         }\n-        if (isAnyEmpty(str, abbrevMarker)) {\n-            return str;\n+        if (isAnyEmpty(s, s2)) {\n+            return s;\n         }\n-        final int abbrevMarkerLength = abbrevMarker.length();\n-        final int minAbbrevWidth = abbrevMarkerLength + 1;\n-        final int minAbbrevWidthOffset = abbrevMarkerLength + abbrevMarkerLength + 1;\n-        if (maxWidth < minAbbrevWidth) {\n-            throw new IllegalArgumentException(String.format(\"Minimum abbreviation width is %d\", Integer.valueOf(minAbbrevWidth)));\n+        final int length = s2.length();\n+        final int i = length + 1;\n+        final int j = length + length + 1;\n+        if (n < i) {\n+            throw new IllegalArgumentException(String.format(\"Minimum abbreviation width is %d\", Integer.valueOf(i)));\n         }\n-        final int strLen = str.length();\n-        if (strLen <= maxWidth) {\n-            return str;\n+        final int length2 = s.length();\n+        if (length2 <= n) {\n+            return s;\n         }\n-        if (offset > strLen) {\n-            offset = strLen;\n+        if (beginIndex > length2) {\n+            beginIndex = length2;\n         }\n-        if (strLen - offset < maxWidth - abbrevMarkerLength) {\n-            offset = strLen - (maxWidth - abbrevMarkerLength);\n+        if (length2 - beginIndex < n - length) {\n+            beginIndex = length2 - (n - length);\n         }\n-        if (offset <= abbrevMarkerLength + 1) {\n-            return str.substring(0, maxWidth - abbrevMarkerLength) + abbrevMarker;\n+        if (beginIndex <= length + 1) {\n+            return s.substring(0, n - length) + s2;\n         }\n-        if (maxWidth < minAbbrevWidthOffset) {\n-            throw new IllegalArgumentException(String.format(\"Minimum abbreviation width with offset is %d\", Integer.valueOf(minAbbrevWidthOffset)));\n+        if (n < j) {\n+            throw new IllegalArgumentException(String.format(\"Minimum abbreviation width with offset is %d\", Integer.valueOf(j)));\n         }\n-        if (offset + maxWidth - abbrevMarkerLength < strLen) {\n-            return abbrevMarker + abbreviate(str.substring(offset), abbrevMarker, maxWidth - abbrevMarkerLength);\n+        if (beginIndex + n - length < length2) {\n+            return s2 + abbreviate(s.substring(beginIndex), s2, n - length);\n         }\n-        return abbrevMarker + str.substring(strLen - (maxWidth - abbrevMarkerLength));\n+        return s2 + s.substring(length2 - (n - length));\n     }\n     \n-    public static String abbreviateMiddle(final String str, final String middle, final int length) {\n-        if (isAnyEmpty(str, middle) || length >= str.length() || length < middle.length() + 2) {\n-            return str;\n+    public static String abbreviateMiddle(final String s, final String str, final int n) {\n+        if (isAnyEmpty(s, str) || n >= s.length() || n < str.length() + 2) {\n+            return s;\n         }\n-        final int targetSting = length - middle.length();\n-        final int startOffset = targetSting / 2 + targetSting % 2;\n-        final int endOffset = str.length() - targetSting / 2;\n-        return str.substring(0, startOffset) + middle + str.substring(endOffset);\n+        final int n2 = n - str.length();\n+        return s.substring(0, n2 / 2 + n2 % 2) + str + s.substring(s.length() - n2 / 2);\n     }\n     \n-    private static String appendIfMissing(final String str, final CharSequence suffix, final boolean ignoreCase, final CharSequence... suffixes) {\n-        if (str == null || isEmpty(suffix) || endsWith(str, suffix, ignoreCase)) {\n+    private static String appendIfMissing(final String str, final CharSequence charSequence, final boolean b, final CharSequence... array) {\n+        if (str == null || isEmpty(charSequence) || endsWith(str, charSequence, b)) {\n             return str;\n         }\n-        if (ArrayUtils.isNotEmpty((Object[])suffixes)) {\n-            for (final CharSequence s : suffixes) {\n-                if (endsWith(str, s, ignoreCase)) {\n+        if (ArrayUtils.isNotEmpty((Object[])array)) {\n+            for (int length = array.length, i = 0; i < length; ++i) {\n+                if (endsWith(str, array[i], b)) {\n                     return str;\n                 }\n             }\n         }\n-        return str + suffix.toString();\n+        return str + charSequence.toString();\n     }\n     \n-    public static String appendIfMissing(final String str, final CharSequence suffix, final CharSequence... suffixes) {\n-        return appendIfMissing(str, suffix, false, suffixes);\n+    public static String appendIfMissing(final String s, final CharSequence charSequence, final CharSequence... array) {\n+        return appendIfMissing(s, charSequence, false, array);\n     }\n     \n-    public static String appendIfMissingIgnoreCase(final String str, final CharSequence suffix, final CharSequence... suffixes) {\n-        return appendIfMissing(str, suffix, true, suffixes);\n+    public static String appendIfMissingIgnoreCase(final String s, final CharSequence charSequence, final CharSequence... array) {\n+        return appendIfMissing(s, charSequence, true, array);\n     }\n     \n-    public static String capitalize(final String str) {\n-        final int strLen = length(str);\n-        if (strLen == 0) {\n-            return str;\n+    public static String capitalize(final String s) {\n+        final int length = length(s);\n+        if (length == 0) {\n+            return s;\n         }\n-        final int firstCodepoint = str.codePointAt(0);\n-        final int newCodePoint = Character.toTitleCase(firstCodepoint);\n-        if (firstCodepoint == newCodePoint) {\n-            return str;\n+        final int codePoint = s.codePointAt(0);\n+        final int titleCase = Character.toTitleCase(codePoint);\n+        if (codePoint == titleCase) {\n+            return s;\n         }\n-        final int[] newCodePoints = new int[strLen];\n-        int outOffset = 0;\n-        newCodePoints[outOffset++] = newCodePoint;\n-        int codepoint;\n-        for (int inOffset = Character.charCount(firstCodepoint); inOffset < strLen; inOffset += Character.charCount(codepoint)) {\n-            codepoint = str.codePointAt(inOffset);\n-            newCodePoints[outOffset++] = codepoint;\n+        final int[] codePoints = new int[length];\n+        int count = 0;\n+        codePoints[count++] = titleCase;\n+        int codePoint2;\n+        for (int i = Character.charCount(codePoint); i < length; i += Character.charCount(codePoint2)) {\n+            codePoint2 = s.codePointAt(i);\n+            codePoints[count++] = codePoint2;\n         }\n-        return new String(newCodePoints, 0, outOffset);\n+        return new String(codePoints, 0, count);\n     }\n     \n-    public static String center(final String str, final int size) {\n-        return center(str, size, ' ');\n+    public static String center(final String s, final int n) {\n+        return center(s, n, ' ');\n     }\n     \n-    public static String center(String str, final int size, final char padChar) {\n-        if (str == null || size <= 0) {\n-            return str;\n+    public static String center(String s, final int n, final char c) {\n+        if (s == null || n <= 0) {\n+            return s;\n         }\n-        final int strLen = str.length();\n-        final int pads = size - strLen;\n-        if (pads <= 0) {\n-            return str;\n+        final int length = s.length();\n+        final int n2 = n - length;\n+        if (n2 <= 0) {\n+            return s;\n         }\n-        str = leftPad(str, strLen + pads / 2, padChar);\n-        str = rightPad(str, size, padChar);\n-        return str;\n+        s = leftPad(s, length + n2 / 2, c);\n+        s = rightPad(s, n, c);\n+        return s;\n     }\n     \n-    public static String center(String str, final int size, String padStr) {\n-        if (str == null || size <= 0) {\n-            return str;\n+    public static String center(String s, final int n, String s2) {\n+        if (s == null || n <= 0) {\n+            return s;\n         }\n-        if (isEmpty(padStr)) {\n-            padStr = \" \";\n+        if (isEmpty(s2)) {\n+            s2 = \" \";\n         }\n-        final int strLen = str.length();\n-        final int pads = size - strLen;\n-        if (pads <= 0) {\n-            return str;\n+        final int length = s.length();\n+        final int n2 = n - length;\n+        if (n2 <= 0) {\n+            return s;\n         }\n-        str = leftPad(str, strLen + pads / 2, padStr);\n-        str = rightPad(str, size, padStr);\n-        return str;\n+        s = leftPad(s, length + n2 / 2, s2);\n+        s = rightPad(s, n, s2);\n+        return s;\n     }\n     \n-    public static String chomp(final String str) {\n-        if (isEmpty(str)) {\n-            return str;\n+    public static String chomp(final String s) {\n+        if (isEmpty(s)) {\n+            return s;\n         }\n-        if (str.length() != 1) {\n-            int lastIdx = str.length() - 1;\n-            final char last = str.charAt(lastIdx);\n-            if (last == '\\n') {\n-                if (str.charAt(lastIdx - 1) == '\\r') {\n-                    --lastIdx;\n+        if (s.length() != 1) {\n+            int n = s.length() - 1;\n+            final char char1 = s.charAt(n);\n+            if (char1 == '\\n') {\n+                if (s.charAt(n - 1) == '\\r') {\n+                    --n;\n                 }\n             }\n-            else if (last != '\\r') {\n-                ++lastIdx;\n+            else if (char1 != '\\r') {\n+                ++n;\n             }\n-            return str.substring(0, lastIdx);\n+            return s.substring(0, n);\n         }\n-        final char ch = str.charAt(0);\n-        if (ch == '\\r' || ch == '\\n') {\n+        final char char2 = s.charAt(0);\n+        if (char2 == '\\r' || char2 == '\\n') {\n             return \"\";\n         }\n-        return str;\n+        return s;\n     }\n     \n     @Deprecated\n-    public static String chomp(final String str, final String separator) {\n-        return removeEnd(str, separator);\n+    public static String chomp(final String s, final String s2) {\n+        return removeEnd(s, s2);\n     }\n     \n-    public static String chop(final String str) {\n-        if (str == null) {\n+    public static String chop(final String s) {\n+        if (s == null) {\n             return null;\n         }\n-        final int strLen = str.length();\n-        if (strLen < 2) {\n+        final int length = s.length();\n+        if (length < 2) {\n             return \"\";\n         }\n-        final int lastIdx = strLen - 1;\n-        final String ret = str.substring(0, lastIdx);\n-        final char last = str.charAt(lastIdx);\n-        if (last == '\\n' && ret.charAt(lastIdx - 1) == '\\r') {\n-            return ret.substring(0, lastIdx - 1);\n+        final int n = length - 1;\n+        final String substring = s.substring(0, n);\n+        if (s.charAt(n) == '\\n' && substring.charAt(n - 1) == '\\r') {\n+            return substring.substring(0, n - 1);\n         }\n-        return ret;\n+        return substring;\n     }\n     \n-    public static int compare(final String str1, final String str2) {\n-        return compare(str1, str2, true);\n+    public static int compare(final String s, final String s2) {\n+        return compare(s, s2, true);\n     }\n     \n-    public static int compare(final String str1, final String str2, final boolean nullIsLess) {\n-        if (str1 == str2) {\n+    public static int compare(final String s, final String anotherString, final boolean b) {\n+        if (s == anotherString) {\n             return 0;\n         }\n-        if (str1 == null) {\n-            return nullIsLess ? -1 : 1;\n+        if (s == null) {\n+            return b ? -1 : 1;\n         }\n-        if (str2 == null) {\n-            return nullIsLess ? 1 : -1;\n+        if (anotherString == null) {\n+            return b ? 1 : -1;\n         }\n-        return str1.compareTo(str2);\n+        return s.compareTo(anotherString);\n     }\n     \n-    public static int compareIgnoreCase(final String str1, final String str2) {\n-        return compareIgnoreCase(str1, str2, true);\n+    public static int compareIgnoreCase(final String s, final String s2) {\n+        return compareIgnoreCase(s, s2, true);\n     }\n     \n-    public static int compareIgnoreCase(final String str1, final String str2, final boolean nullIsLess) {\n-        if (str1 == str2) {\n+    public static int compareIgnoreCase(final String s, final String str, final boolean b) {\n+        if (s == str) {\n             return 0;\n         }\n-        if (str1 == null) {\n-            return nullIsLess ? -1 : 1;\n+        if (s == null) {\n+            return b ? -1 : 1;\n         }\n-        if (str2 == null) {\n-            return nullIsLess ? 1 : -1;\n+        if (str == null) {\n+            return b ? 1 : -1;\n         }\n-        return str1.compareToIgnoreCase(str2);\n+        return s.compareToIgnoreCase(str);\n     }\n     \n-    public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {\n-        return seq != null && searchSeq != null && CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;\n+    public static boolean contains(final CharSequence charSequence, final CharSequence charSequence2) {\n+        return charSequence != null && charSequence2 != null && CharSequenceUtils.indexOf(charSequence, charSequence2, 0) >= 0;\n     }\n     \n-    public static boolean contains(final CharSequence seq, final int searchChar) {\n-        return !isEmpty(seq) && CharSequenceUtils.indexOf(seq, searchChar, 0) >= 0;\n+    public static boolean contains(final CharSequence charSequence, final int n) {\n+        return !isEmpty(charSequence) && CharSequenceUtils.indexOf(charSequence, n, 0) >= 0;\n     }\n     \n-    public static boolean containsAny(final CharSequence cs, final char... searchChars) {\n-        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n+    public static boolean containsAny(final CharSequence charSequence, final char... array) {\n+        if (isEmpty(charSequence) || ArrayUtils.isEmpty(array)) {\n             return false;\n         }\n-        final int csLength = cs.length();\n-        final int searchLength = searchChars.length;\n-        final int csLast = csLength - 1;\n-        final int searchLast = searchLength - 1;\n-        for (int i = 0; i < csLength; ++i) {\n-            final char ch = cs.charAt(i);\n-            for (int j = 0; j < searchLength; ++j) {\n-                if (searchChars[j] == ch) {\n-                    if (!Character.isHighSurrogate(ch)) {\n+        final int length = charSequence.length();\n+        final int length2 = array.length;\n+        final int n = length - 1;\n+        final int n2 = length2 - 1;\n+        for (int i = 0; i < length; ++i) {\n+            final char char1 = charSequence.charAt(i);\n+            for (int j = 0; j < length2; ++j) {\n+                if (array[j] == char1) {\n+                    if (!Character.isHighSurrogate(char1)) {\n                         return true;\n                     }\n-                    if (j == searchLast) {\n+                    if (j == n2) {\n                         return true;\n                     }\n-                    if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {\n+                    if (i < n && array[j + 1] == charSequence.charAt(i + 1)) {\n                         return true;\n                     }\n                 }\n             }\n         }\n         return false;\n     }\n     \n-    public static boolean containsAny(final CharSequence cs, final CharSequence searchChars) {\n-        return searchChars != null && containsAny(cs, CharSequenceUtils.toCharArray(searchChars));\n+    public static boolean containsAny(final CharSequence charSequence, final CharSequence charSequence2) {\n+        return charSequence2 != null && containsAny(charSequence, CharSequenceUtils.toCharArray(charSequence2));\n     }\n     \n-    public static boolean containsAny(final CharSequence cs, final CharSequence... searchCharSequences) {\n-        return containsAny((ToBooleanBiFunction<CharSequence, CharSequence>)StringUtils::contains, cs, searchCharSequences);\n+    public static boolean containsAny(final CharSequence charSequence, final CharSequence... array) {\n+        return containsAny((ToBooleanBiFunction<CharSequence, CharSequence>)StringUtils::contains, charSequence, array);\n     }\n     \n-    private static boolean containsAny(final ToBooleanBiFunction<CharSequence, CharSequence> test, final CharSequence cs, final CharSequence... searchCharSequences) {\n-        if (isEmpty(cs) || ArrayUtils.isEmpty((Object[])searchCharSequences)) {\n+    private static boolean containsAny(final ToBooleanBiFunction<CharSequence, CharSequence> toBooleanBiFunction, final CharSequence charSequence, final CharSequence... array) {\n+        if (isEmpty(charSequence) || ArrayUtils.isEmpty((Object[])array)) {\n             return false;\n         }\n-        for (final CharSequence searchCharSequence : searchCharSequences) {\n-            if (test.applyAsBoolean((Object)cs, (Object)searchCharSequence)) {\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            if (toBooleanBiFunction.applyAsBoolean((Object)charSequence, (Object)array[i])) {\n                 return true;\n             }\n         }\n         return false;\n     }\n     \n-    public static boolean containsAnyIgnoreCase(final CharSequence cs, final CharSequence... searchCharSequences) {\n-        return containsAny((ToBooleanBiFunction<CharSequence, CharSequence>)StringUtils::containsIgnoreCase, cs, searchCharSequences);\n+    public static boolean containsAnyIgnoreCase(final CharSequence charSequence, final CharSequence... array) {\n+        return containsAny((ToBooleanBiFunction<CharSequence, CharSequence>)StringUtils::containsIgnoreCase, charSequence, array);\n     }\n     \n-    public static boolean containsIgnoreCase(final CharSequence str, final CharSequence searchStr) {\n-        if (str == null || searchStr == null) {\n+    public static boolean containsIgnoreCase(final CharSequence charSequence, final CharSequence charSequence2) {\n+        if (charSequence == null || charSequence2 == null) {\n             return false;\n         }\n-        final int len = searchStr.length();\n-        for (int max = str.length() - len, i = 0; i <= max; ++i) {\n-            if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) {\n+        final int length = charSequence2.length();\n+        for (int n = charSequence.length() - length, i = 0; i <= n; ++i) {\n+            if (CharSequenceUtils.regionMatches(charSequence, true, i, charSequence2, 0, length)) {\n                 return true;\n             }\n         }\n         return false;\n     }\n     \n-    public static boolean containsNone(final CharSequence cs, final char... searchChars) {\n-        if (cs == null || searchChars == null) {\n+    public static boolean containsNone(final CharSequence charSequence, final char... array) {\n+        if (charSequence == null || array == null) {\n             return true;\n         }\n-        final int csLen = cs.length();\n-        final int csLast = csLen - 1;\n-        final int searchLen = searchChars.length;\n-        final int searchLast = searchLen - 1;\n-        for (int i = 0; i < csLen; ++i) {\n-            final char ch = cs.charAt(i);\n-            for (int j = 0; j < searchLen; ++j) {\n-                if (searchChars[j] == ch) {\n-                    if (!Character.isHighSurrogate(ch)) {\n+        final int length = charSequence.length();\n+        final int n = length - 1;\n+        final int length2 = array.length;\n+        final int n2 = length2 - 1;\n+        for (int i = 0; i < length; ++i) {\n+            final char char1 = charSequence.charAt(i);\n+            for (int j = 0; j < length2; ++j) {\n+                if (array[j] == char1) {\n+                    if (!Character.isHighSurrogate(char1)) {\n                         return false;\n                     }\n-                    if (j == searchLast) {\n+                    if (j == n2) {\n                         return false;\n                     }\n-                    if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {\n+                    if (i < n && array[j + 1] == charSequence.charAt(i + 1)) {\n                         return false;\n                     }\n                 }\n             }\n         }\n         return true;\n     }\n     \n-    public static boolean containsNone(final CharSequence cs, final String invalidChars) {\n-        return invalidChars == null || containsNone(cs, invalidChars.toCharArray());\n+    public static boolean containsNone(final CharSequence charSequence, final String s) {\n+        return s == null || containsNone(charSequence, s.toCharArray());\n     }\n     \n-    public static boolean containsOnly(final CharSequence cs, final char... valid) {\n-        return valid != null && cs != null && (cs.length() == 0 || (valid.length != 0 && indexOfAnyBut(cs, valid) == -1));\n+    public static boolean containsOnly(final CharSequence charSequence, final char... array) {\n+        return array != null && charSequence != null && (charSequence.length() == 0 || (array.length != 0 && indexOfAnyBut(charSequence, array) == -1));\n     }\n     \n-    public static boolean containsOnly(final CharSequence cs, final String validChars) {\n-        return cs != null && validChars != null && containsOnly(cs, validChars.toCharArray());\n+    public static boolean containsOnly(final CharSequence charSequence, final String s) {\n+        return charSequence != null && s != null && containsOnly(charSequence, s.toCharArray());\n     }\n     \n-    public static boolean containsWhitespace(final CharSequence seq) {\n-        if (isEmpty(seq)) {\n+    public static boolean containsWhitespace(final CharSequence charSequence) {\n+        if (isEmpty(charSequence)) {\n             return false;\n         }\n-        for (int strLen = seq.length(), i = 0; i < strLen; ++i) {\n-            if (Character.isWhitespace(seq.charAt(i))) {\n+        for (int length = charSequence.length(), i = 0; i < length; ++i) {\n+            if (Character.isWhitespace(charSequence.charAt(i))) {\n                 return true;\n             }\n         }\n         return false;\n     }\n     \n-    private static void convertRemainingAccentCharacters(final StringBuilder decomposed) {\n-        for (int i = 0; i < decomposed.length(); ++i) {\n-            if (decomposed.charAt() == '\\u0141') {\n-                decomposed.setCharAt();\n+    private static void convertRemainingAccentCharacters(final StringBuilder sb) {\n+        for (int i = 0; i < sb.length(); ++i) {\n+            if (sb.charAt() == '\\u0141') {\n+                sb.setCharAt();\n             }\n-            else if (decomposed.charAt() == '\\u0142') {\n-                decomposed.setCharAt();\n+            else if (sb.charAt() == '\\u0142') {\n+                sb.setCharAt();\n             }\n         }\n     }\n     \n-    public static int countMatches(final CharSequence str, final char ch) {\n-        if (isEmpty(str)) {\n+    public static int countMatches(final CharSequence charSequence, final char c) {\n+        if (isEmpty(charSequence)) {\n             return 0;\n         }\n-        int count = 0;\n-        for (int i = 0; i < str.length(); ++i) {\n-            if (ch == str.charAt(i)) {\n-                ++count;\n+        int n = 0;\n+        for (int i = 0; i < charSequence.length(); ++i) {\n+            if (c == charSequence.charAt(i)) {\n+                ++n;\n             }\n         }\n-        return count;\n+        return n;\n     }\n     \n-    public static int countMatches(final CharSequence str, final CharSequence sub) {\n-        if (isEmpty(str) || isEmpty(sub)) {\n+    public static int countMatches(final CharSequence charSequence, final CharSequence charSequence2) {\n+        if (isEmpty(charSequence) || isEmpty(charSequence2)) {\n             return 0;\n         }\n-        int count = 0;\n-        for (int idx = 0; (idx = CharSequenceUtils.indexOf(str, sub, idx)) != -1; idx += sub.length()) {\n-            ++count;\n+        int n = 0;\n+        int index;\n+        for (int n2 = 0; (index = CharSequenceUtils.indexOf(charSequence, charSequence2, n2)) != -1; n2 = index + charSequence2.length()) {\n+            ++n;\n         }\n-        return count;\n+        return n;\n     }\n     \n-    public static <T extends CharSequence> T defaultIfBlank(final T str, final T defaultStr) {\n-        return isBlank(str) ? defaultStr : str;\n+    public static <T extends CharSequence> T defaultIfBlank(final T t, final T t2) {\n+        return isBlank(t) ? t2 : t;\n     }\n     \n-    public static <T extends CharSequence> T defaultIfEmpty(final T str, final T defaultStr) {\n-        return isEmpty(str) ? defaultStr : str;\n+    public static <T extends CharSequence> T defaultIfEmpty(final T t, final T t2) {\n+        return isEmpty(t) ? t2 : t;\n     }\n     \n-    public static String defaultString(final String str) {\n-        return defaultString(str, \"\");\n+    public static String defaultString(final String s) {\n+        return defaultString(s, \"\");\n     }\n     \n-    public static String defaultString(final String str, final String defaultStr) {\n-        return (str == null) ? defaultStr : str;\n+    public static String defaultString(final String s, final String s2) {\n+        return (s == null) ? s2 : s;\n     }\n     \n-    public static String deleteWhitespace(final String str) {\n-        if (isEmpty(str)) {\n-            return str;\n+    public static String deleteWhitespace(final String s) {\n+        if (isEmpty(s)) {\n+            return s;\n         }\n-        final int sz = str.length();\n-        final char[] chs = new char[sz];\n+        final int length = s.length();\n+        final char[] value = new char[length];\n         int count = 0;\n-        for (int i = 0; i < sz; ++i) {\n-            if (!Character.isWhitespace(str.charAt(i))) {\n-                chs[count++] = str.charAt(i);\n+        for (int i = 0; i < length; ++i) {\n+            if (!Character.isWhitespace(s.charAt(i))) {\n+                value[count++] = s.charAt(i);\n             }\n         }\n-        if (count == sz) {\n-            return str;\n+        if (count == length) {\n+            return s;\n         }\n         if (count == 0) {\n             return \"\";\n         }\n-        return new String(chs, 0, count);\n+        return new String(value, 0, count);\n     }\n     \n-    public static String difference(final String str1, final String str2) {\n-        if (str1 == null) {\n-            return str2;\n+    public static String difference(final String s, final String s2) {\n+        if (s == null) {\n+            return s2;\n         }\n-        if (str2 == null) {\n-            return str1;\n+        if (s2 == null) {\n+            return s;\n         }\n-        final int at = indexOfDifference(str1, str2);\n-        if (at == -1) {\n+        final int indexOfDifference = indexOfDifference(s, s2);\n+        if (indexOfDifference == -1) {\n             return \"\";\n         }\n-        return str2.substring(at);\n+        return s2.substring(indexOfDifference);\n     }\n     \n-    public static boolean endsWith(final CharSequence str, final CharSequence suffix) {\n-        return endsWith(str, suffix, false);\n+    public static boolean endsWith(final CharSequence charSequence, final CharSequence charSequence2) {\n+        return endsWith(charSequence, charSequence2, false);\n     }\n     \n-    private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) {\n-        if (str == null || suffix == null) {\n-            return str == suffix;\n-        }\n-        if (suffix.length() > str.length()) {\n-            return false;\n+    private static boolean endsWith(final CharSequence charSequence, final CharSequence charSequence2, final boolean b) {\n+        if (charSequence == null || charSequence2 == null) {\n+            return charSequence == charSequence2;\n         }\n-        final int strOffset = str.length() - suffix.length();\n-        return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());\n+        return charSequence2.length() <= charSequence.length() && CharSequenceUtils.regionMatches(charSequence, b, charSequence.length() - charSequence2.length(), charSequence2, 0, charSequence2.length());\n     }\n     \n-    public static boolean endsWithAny(final CharSequence sequence, final CharSequence... searchStrings) {\n-        if (isEmpty(sequence) || ArrayUtils.isEmpty((Object[])searchStrings)) {\n+    public static boolean endsWithAny(final CharSequence charSequence, final CharSequence... array) {\n+        if (isEmpty(charSequence) || ArrayUtils.isEmpty((Object[])array)) {\n             return false;\n         }\n-        for (final CharSequence searchString : searchStrings) {\n-            if (endsWith(sequence, searchString)) {\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            if (endsWith(charSequence, array[i])) {\n                 return true;\n             }\n         }\n         return false;\n     }\n     \n-    public static boolean endsWithIgnoreCase(final CharSequence str, final CharSequence suffix) {\n-        return endsWith(str, suffix, true);\n+    public static boolean endsWithIgnoreCase(final CharSequence charSequence, final CharSequence charSequence2) {\n+        return endsWith(charSequence, charSequence2, true);\n     }\n     \n-    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n-        if (cs1 == cs2) {\n+    public static boolean equals(final CharSequence charSequence, final CharSequence obj) {\n+        if (charSequence == obj) {\n             return true;\n         }\n-        if (cs1 == null || cs2 == null) {\n+        if (charSequence == null || obj == null) {\n             return false;\n         }\n-        if (cs1.length() != cs2.length()) {\n+        if (charSequence.length() != obj.length()) {\n             return false;\n         }\n-        if (cs1 instanceof String && cs2 instanceof String) {\n-            return cs1.equals(cs2);\n+        if (charSequence instanceof String && obj instanceof String) {\n+            return charSequence.equals(obj);\n         }\n-        for (int length = cs1.length(), i = 0; i < length; ++i) {\n-            if (cs1.charAt(i) != cs2.charAt(i)) {\n+        for (int length = charSequence.length(), i = 0; i < length; ++i) {\n+            if (charSequence.charAt(i) != obj.charAt(i)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    public static boolean equalsAny(final CharSequence string, final CharSequence... searchStrings) {\n-        if (ArrayUtils.isNotEmpty((Object[])searchStrings)) {\n-            for (final CharSequence next : searchStrings) {\n-                if (equals(string, next)) {\n+    public static boolean equalsAny(final CharSequence charSequence, final CharSequence... array) {\n+        if (ArrayUtils.isNotEmpty((Object[])array)) {\n+            for (int length = array.length, i = 0; i < length; ++i) {\n+                if (equals(charSequence, array[i])) {\n                     return true;\n                 }\n             }\n         }\n         return false;\n     }\n     \n-    public static boolean equalsAnyIgnoreCase(final CharSequence string, final CharSequence... searchStrings) {\n-        if (ArrayUtils.isNotEmpty((Object[])searchStrings)) {\n-            for (final CharSequence next : searchStrings) {\n-                if (equalsIgnoreCase(string, next)) {\n+    public static boolean equalsAnyIgnoreCase(final CharSequence charSequence, final CharSequence... array) {\n+        if (ArrayUtils.isNotEmpty((Object[])array)) {\n+            for (int length = array.length, i = 0; i < length; ++i) {\n+                if (equalsIgnoreCase(charSequence, array[i])) {\n                     return true;\n                 }\n             }\n         }\n         return false;\n     }\n     \n-    public static boolean equalsIgnoreCase(final CharSequence cs1, final CharSequence cs2) {\n-        return cs1 == cs2 || (cs1 != null && cs2 != null && cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, cs1.length()));\n+    public static boolean equalsIgnoreCase(final CharSequence charSequence, final CharSequence charSequence2) {\n+        return charSequence == charSequence2 || (charSequence != null && charSequence2 != null && charSequence.length() == charSequence2.length() && CharSequenceUtils.regionMatches(charSequence, true, 0, charSequence2, 0, charSequence.length()));\n     }\n     \n     @SafeVarargs\n-    public static <T extends CharSequence> T firstNonBlank(final T... values) {\n-        if (values != null) {\n-            for (final T val : values) {\n-                if (isNotBlank(val)) {\n-                    return val;\n+    public static <T extends CharSequence> T firstNonBlank(final T... array) {\n+        if (array != null) {\n+            for (final CharSequence charSequence : array) {\n+                if (isNotBlank(charSequence)) {\n+                    return (T)charSequence;\n                 }\n             }\n         }\n         return null;\n     }\n     \n     @SafeVarargs\n-    public static <T extends CharSequence> T firstNonEmpty(final T... values) {\n-        if (values != null) {\n-            for (final T val : values) {\n-                if (isNotEmpty(val)) {\n-                    return val;\n+    public static <T extends CharSequence> T firstNonEmpty(final T... array) {\n+        if (array != null) {\n+            for (final CharSequence charSequence : array) {\n+                if (isNotEmpty(charSequence)) {\n+                    return (T)charSequence;\n                 }\n             }\n         }\n         return null;\n     }\n     \n-    public static byte[] getBytes(final String string, final Charset charset) {\n-        return (string == null) ? ArrayUtils.EMPTY_BYTE_ARRAY : string.getBytes(Charsets.toCharset(charset));\n+    public static byte[] getBytes(final String s, final Charset charset) {\n+        return (s == null) ? ArrayUtils.EMPTY_BYTE_ARRAY : s.getBytes(Charsets.toCharset(charset));\n     }\n     \n-    public static byte[] getBytes(final String string, final String charset) throws UnsupportedEncodingException {\n-        return (string == null) ? ArrayUtils.EMPTY_BYTE_ARRAY : string.getBytes(Charsets.toCharsetName(charset));\n+    public static byte[] getBytes(final String s, final String s2) throws UnsupportedEncodingException {\n+        return (s == null) ? ArrayUtils.EMPTY_BYTE_ARRAY : s.getBytes(Charsets.toCharsetName(s2));\n     }\n     \n-    public static String getCommonPrefix(final String... strs) {\n-        if (ArrayUtils.isEmpty((Object[])strs)) {\n+    public static String getCommonPrefix(final String... array) {\n+        if (ArrayUtils.isEmpty((Object[])array)) {\n             return \"\";\n         }\n-        final int smallestIndexOfDiff = indexOfDifference((CharSequence[])strs);\n-        if (smallestIndexOfDiff == -1) {\n-            if (strs[0] == null) {\n+        final int indexOfDifference = indexOfDifference((CharSequence[])array);\n+        if (indexOfDifference == -1) {\n+            if (array[0] == null) {\n                 return \"\";\n             }\n-            return strs[0];\n+            return array[0];\n         }\n         else {\n-            if (smallestIndexOfDiff == 0) {\n+            if (indexOfDifference == 0) {\n                 return \"\";\n             }\n-            return strs[0].substring(0, smallestIndexOfDiff);\n+            return array[0].substring(0, indexOfDifference);\n         }\n     }\n     \n-    public static String getDigits(final String str) {\n-        if (isEmpty(str)) {\n-            return str;\n+    public static String getDigits(final String s) {\n+        if (isEmpty(s)) {\n+            return s;\n         }\n-        final int sz = str.length();\n-        final StringBuilder strDigits = new StringBuilder(sz);\n-        for (int i = 0; i < sz; ++i) {\n-            final char tempChar = str.charAt(i);\n-            if (Character.isDigit(tempChar)) {\n-                strDigits.append(tempChar);\n+        final int length = s.length();\n+        final StringBuilder sb = new StringBuilder(length);\n+        for (int i = 0; i < length; ++i) {\n+            final char char1 = s.charAt(i);\n+            if (Character.isDigit(char1)) {\n+                sb.append(char1);\n             }\n         }\n-        return strDigits.toString();\n+        return sb.toString();\n     }\n     \n     @Deprecated\n-    public static int getFuzzyDistance(final CharSequence term, final CharSequence query, final Locale locale) {\n-        if (term == null || query == null) {\n+    public static int getFuzzyDistance(final CharSequence charSequence, final CharSequence charSequence2, final Locale locale) {\n+        if (charSequence == null || charSequence2 == null) {\n             throw new IllegalArgumentException(\"Strings must not be null\");\n         }\n         if (locale == null) {\n             throw new IllegalArgumentException(\"Locale must not be null\");\n         }\n-        final String termLowerCase = term.toString().toLowerCase(locale);\n-        final String queryLowerCase = query.toString().toLowerCase(locale);\n-        int score = 0;\n-        int termIndex = 0;\n-        int previousMatchingCharacterIndex = Integer.MIN_VALUE;\n-        for (int queryIndex = 0; queryIndex < queryLowerCase.length(); ++queryIndex) {\n-            final char queryChar = queryLowerCase.charAt(queryIndex);\n-            for (boolean termCharacterMatchFound = false; termIndex < termLowerCase.length() && !termCharacterMatchFound; ++termIndex) {\n-                final char termChar = termLowerCase.charAt(termIndex);\n-                if (queryChar == termChar) {\n-                    ++score;\n-                    if (previousMatchingCharacterIndex + 1 == termIndex) {\n-                        score += 2;\n+        final String lowerCase = charSequence.toString().toLowerCase(locale);\n+        final String lowerCase2 = charSequence2.toString().toLowerCase(locale);\n+        int n = 0;\n+        int index = 0;\n+        int n2 = Integer.MIN_VALUE;\n+        for (int i = 0; i < lowerCase2.length(); ++i) {\n+            final char char1 = lowerCase2.charAt(i);\n+            for (int n3 = 0; index < lowerCase.length() && n3 == 0; ++index) {\n+                if (char1 == lowerCase.charAt(index)) {\n+                    ++n;\n+                    if (n2 + 1 == index) {\n+                        n += 2;\n                     }\n-                    previousMatchingCharacterIndex = termIndex;\n-                    termCharacterMatchFound = true;\n+                    n2 = index;\n+                    n3 = 1;\n                 }\n             }\n         }\n-        return score;\n+        return n;\n     }\n     \n-    public static <T extends CharSequence> T getIfBlank(final T str, final Supplier<T> defaultSupplier) {\n-        return (T)(isBlank(str) ? ((defaultSupplier == null) ? null : ((T)defaultSupplier.get())) : str);\n+    public static <T extends CharSequence> T getIfBlank(final T t, final Supplier<T> supplier) {\n+        return (T)(isBlank(t) ? ((supplier == null) ? null : ((T)supplier.get())) : t);\n     }\n     \n-    public static <T extends CharSequence> T getIfEmpty(final T str, final Supplier<T> defaultSupplier) {\n-        return (T)(isEmpty(str) ? ((defaultSupplier == null) ? null : ((T)defaultSupplier.get())) : str);\n+    public static <T extends CharSequence> T getIfEmpty(final T t, final Supplier<T> supplier) {\n+        return (T)(isEmpty(t) ? ((supplier == null) ? null : ((T)supplier.get())) : t);\n     }\n     \n     @Deprecated\n-    public static double getJaroWinklerDistance(final CharSequence first, final CharSequence second) {\n-        final double DEFAULT_SCALING_FACTOR = 0.1;\n-        if (first == null || second == null) {\n+    public static double getJaroWinklerDistance(final CharSequence charSequence, final CharSequence charSequence2) {\n+        if (charSequence == null || charSequence2 == null) {\n             throw new IllegalArgumentException(\"Strings must not be null\");\n         }\n-        final int[] mtp = matches(first, second);\n-        final double m = (double)mtp[0];\n-        if (m == 0.0) {\n+        final int[] matches = matches(charSequence, charSequence2);\n+        final double n = (double)matches[0];\n+        if (n == 0.0) {\n             return 0.0;\n         }\n-        final double j = (m / first.length() + m / second.length() + (m - mtp[1]) / m) / 3.0;\n-        final double jw = (j < 0.7) ? j : (j + Math.min(0.1, 1.0 / (double)mtp[3]) * mtp[2] * (1.0 - j));\n-        return Math.round(jw * 100.0) / 100.0;\n+        final double n2 = (n / charSequence.length() + n / charSequence2.length() + (n - matches[1]) / n) / 3.0;\n+        return Math.round(((n2 < 0.7) ? n2 : (n2 + Math.min(0.1, 1.0 / (double)matches[3]) * matches[2] * (1.0 - n2))) * 100.0) / 100.0;\n     }\n     \n     @Deprecated\n-    public static int getLevenshteinDistance(CharSequence s, CharSequence t) {\n-        if (s == null || t == null) {\n+    public static int getLevenshteinDistance(CharSequence charSequence, CharSequence charSequence2) {\n+        if (charSequence == null || charSequence2 == null) {\n             throw new IllegalArgumentException(\"Strings must not be null\");\n         }\n-        int n = s.length();\n-        int m = t.length();\n-        if (n == 0) {\n-            return m;\n-        }\n-        if (m == 0) {\n+        int length = charSequence.length();\n+        int n = charSequence2.length();\n+        if (length == 0) {\n             return n;\n         }\n-        if (n > m) {\n-            final CharSequence tmp = s;\n-            s = t;\n-            t = tmp;\n-            n = m;\n-            m = t.length();\n-        }\n-        final int[] p = new int[n + 1];\n-        for (int i = 0; i <= n; ++i) {\n-            p[i] = i;\n-        }\n-        for (int j = 1; j <= m; ++j) {\n-            int upper_left = p[0];\n-            final char t_j = t.charAt(j - 1);\n-            p[0] = j;\n-            for (int i = 1; i <= n; ++i) {\n-                final int upper = p[i];\n-                final int cost = (s.charAt(i - 1) != t_j) ? 1 : 0;\n-                p[i] = Math.min(Math.min(p[i - 1] + 1, p[i] + 1), upper_left + cost);\n-                upper_left = upper;\n+        if (n == 0) {\n+            return length;\n+        }\n+        if (length > n) {\n+            final CharSequence charSequence3 = charSequence;\n+            charSequence = charSequence2;\n+            charSequence2 = charSequence3;\n+            length = n;\n+            n = charSequence2.length();\n+        }\n+        final int[] array = new int[length + 1];\n+        for (int i = 0; i <= length; ++i) {\n+            array[i] = i;\n+        }\n+        for (int j = 1; j <= n; ++j) {\n+            int n2 = array[0];\n+            final char char1 = charSequence2.charAt(j - 1);\n+            array[0] = j;\n+            for (int k = 1; k <= length; ++k) {\n+                final int n3 = array[k];\n+                array[k] = Math.min(Math.min(array[k - 1] + 1, array[k] + 1), n2 + ((charSequence.charAt(k - 1) != char1) ? 1 : 0));\n+                n2 = n3;\n             }\n         }\n-        return p[n];\n+        return array[length];\n     }\n     \n     @Deprecated\n-    public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {\n-        if (s == null || t == null) {\n+    public static int getLevenshteinDistance(CharSequence charSequence, CharSequence charSequence2, final int b) {\n+        if (charSequence == null || charSequence2 == null) {\n             throw new IllegalArgumentException(\"Strings must not be null\");\n         }\n-        if (threshold < 0) {\n+        if (b < 0) {\n             throw new IllegalArgumentException(\"Threshold must not be negative\");\n         }\n-        int n = s.length();\n-        int m = t.length();\n-        if (n == 0) {\n-            return (m <= threshold) ? m : -1;\n+        int length = charSequence.length();\n+        int n = charSequence2.length();\n+        if (length == 0) {\n+            return (n <= b) ? n : -1;\n         }\n-        if (m == 0) {\n-            return (n <= threshold) ? n : -1;\n+        if (n == 0) {\n+            return (length <= b) ? length : -1;\n         }\n-        if (Math.abs(n - m) > threshold) {\n+        if (Math.abs(length - n) > b) {\n             return -1;\n         }\n-        if (n > m) {\n-            final CharSequence tmp = s;\n-            s = t;\n-            t = tmp;\n-            n = m;\n-            m = t.length();\n-        }\n-        int[] p = new int[n + 1];\n-        int[] d = new int[n + 1];\n-        final int boundary = Math.min(n, threshold) + 1;\n-        for (int i = 0; i < boundary; ++i) {\n-            p[i] = i;\n-        }\n-        Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);\n-        Arrays.fill(d, Integer.MAX_VALUE);\n-        for (int j = 1; j <= m; ++j) {\n-            final char t_j = t.charAt(j - 1);\n-            d[0] = j;\n-            final int min = Math.max(1, j - threshold);\n-            final int max = (j > Integer.MAX_VALUE - threshold) ? n : Math.min(n, j + threshold);\n-            if (min > max) {\n+        if (length > n) {\n+            final CharSequence charSequence3 = charSequence;\n+            charSequence = charSequence2;\n+            charSequence2 = charSequence3;\n+            length = n;\n+            n = charSequence2.length();\n+        }\n+        int[] a = new int[length + 1];\n+        int[] a2 = new int[length + 1];\n+        final int fromIndex = Math.min(length, b) + 1;\n+        for (int i = 0; i < fromIndex; ++i) {\n+            a[i] = i;\n+        }\n+        Arrays.fill(a, fromIndex, a.length, Integer.MAX_VALUE);\n+        Arrays.fill(a2, Integer.MAX_VALUE);\n+        for (int j = 1; j <= n; ++j) {\n+            final char char1 = charSequence2.charAt(j - 1);\n+            a2[0] = j;\n+            final int max = Math.max(1, j - b);\n+            final int n2 = (j > Integer.MAX_VALUE - b) ? length : Math.min(length, j + b);\n+            if (max > n2) {\n                 return -1;\n             }\n-            if (min > 1) {\n-                d[min - 1] = Integer.MAX_VALUE;\n+            if (max > 1) {\n+                a2[max - 1] = Integer.MAX_VALUE;\n             }\n-            for (int k = min; k <= max; ++k) {\n-                if (s.charAt(k - 1) == t_j) {\n-                    d[k] = p[k - 1];\n+            for (int k = max; k <= n2; ++k) {\n+                if (charSequence.charAt(k - 1) == char1) {\n+                    a2[k] = a[k - 1];\n                 }\n                 else {\n-                    d[k] = 1 + Math.min(Math.min(d[k - 1], p[k]), p[k - 1]);\n+                    a2[k] = 1 + Math.min(Math.min(a2[k - 1], a[k]), a[k - 1]);\n                 }\n             }\n-            final int[] _d = p;\n-            p = d;\n-            d = _d;\n+            final int[] array = a;\n+            a = a2;\n+            a2 = array;\n         }\n-        if (p[n] <= threshold) {\n-            return p[n];\n+        if (a[length] <= b) {\n+            return a[length];\n         }\n         return -1;\n     }\n     \n-    public static int indexOf(final CharSequence seq, final CharSequence searchSeq) {\n-        if (seq == null || searchSeq == null) {\n+    public static int indexOf(final CharSequence charSequence, final CharSequence charSequence2) {\n+        if (charSequence == null || charSequence2 == null) {\n             return -1;\n         }\n-        return CharSequenceUtils.indexOf(seq, searchSeq, 0);\n+        return CharSequenceUtils.indexOf(charSequence, charSequence2, 0);\n     }\n     \n-    public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {\n-        if (seq == null || searchSeq == null) {\n+    public static int indexOf(final CharSequence charSequence, final CharSequence charSequence2, final int n) {\n+        if (charSequence == null || charSequence2 == null) {\n             return -1;\n         }\n-        return CharSequenceUtils.indexOf(seq, searchSeq, startPos);\n+        return CharSequenceUtils.indexOf(charSequence, charSequence2, n);\n     }\n     \n-    public static int indexOf(final CharSequence seq, final int searchChar) {\n-        if (isEmpty(seq)) {\n+    public static int indexOf(final CharSequence charSequence, final int n) {\n+        if (isEmpty(charSequence)) {\n             return -1;\n         }\n-        return CharSequenceUtils.indexOf(seq, searchChar, 0);\n+        return CharSequenceUtils.indexOf(charSequence, n, 0);\n     }\n     \n-    public static int indexOf(final CharSequence seq, final int searchChar, final int startPos) {\n-        if (isEmpty(seq)) {\n+    public static int indexOf(final CharSequence charSequence, final int n, final int n2) {\n+        if (isEmpty(charSequence)) {\n             return -1;\n         }\n-        return CharSequenceUtils.indexOf(seq, searchChar, startPos);\n+        return CharSequenceUtils.indexOf(charSequence, n, n2);\n     }\n     \n-    public static int indexOfAny(final CharSequence cs, final char... searchChars) {\n-        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n+    public static int indexOfAny(final CharSequence charSequence, final char... array) {\n+        if (isEmpty(charSequence) || ArrayUtils.isEmpty(array)) {\n             return -1;\n         }\n-        final int csLen = cs.length();\n-        final int csLast = csLen - 1;\n-        final int searchLen = searchChars.length;\n-        final int searchLast = searchLen - 1;\n-        for (int i = 0; i < csLen; ++i) {\n-            final char ch = cs.charAt(i);\n-            for (int j = 0; j < searchLen; ++j) {\n-                if (searchChars[j] == ch) {\n-                    if (i >= csLast || j >= searchLast || !Character.isHighSurrogate(ch)) {\n+        final int length = charSequence.length();\n+        final int n = length - 1;\n+        final int length2 = array.length;\n+        final int n2 = length2 - 1;\n+        for (int i = 0; i < length; ++i) {\n+            final char char1 = charSequence.charAt(i);\n+            for (int j = 0; j < length2; ++j) {\n+                if (array[j] == char1) {\n+                    if (i >= n || j >= n2 || !Character.isHighSurrogate(char1)) {\n                         return i;\n                     }\n-                    if (searchChars[j + 1] == cs.charAt(i + 1)) {\n+                    if (array[j + 1] == charSequence.charAt(i + 1)) {\n                         return i;\n                     }\n                 }\n             }\n         }\n         return -1;\n     }\n     \n-    public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {\n-        if (str == null || searchStrs == null) {\n+    public static int indexOfAny(final CharSequence charSequence, final CharSequence... array) {\n+        if (charSequence == null || array == null) {\n             return -1;\n         }\n-        int ret = Integer.MAX_VALUE;\n-        int tmp = 0;\n-        for (final CharSequence search : searchStrs) {\n-            if (search != null) {\n-                tmp = CharSequenceUtils.indexOf(str, search, 0);\n-                if (tmp != -1) {\n-                    if (tmp < ret) {\n-                        ret = tmp;\n+        int n = Integer.MAX_VALUE;\n+        for (final CharSequence charSequence2 : array) {\n+            if (charSequence2 != null) {\n+                final int index = CharSequenceUtils.indexOf(charSequence, charSequence2, 0);\n+                if (index != -1) {\n+                    if (index < n) {\n+                        n = index;\n                     }\n                 }\n             }\n         }\n-        return (ret == Integer.MAX_VALUE) ? -1 : ret;\n+        return (n == Integer.MAX_VALUE) ? -1 : n;\n     }\n     \n-    public static int indexOfAny(final CharSequence cs, final String searchChars) {\n-        if (isEmpty(cs) || isEmpty(searchChars)) {\n+    public static int indexOfAny(final CharSequence charSequence, final String s) {\n+        if (isEmpty(charSequence) || isEmpty(s)) {\n             return -1;\n         }\n-        return indexOfAny(cs, searchChars.toCharArray());\n+        return indexOfAny(charSequence, s.toCharArray());\n     }\n     \n-    public static int indexOfAnyBut(final CharSequence cs, final char... searchChars) {\n-        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n+    public static int indexOfAnyBut(final CharSequence charSequence, final char... array) {\n+        if (isEmpty(charSequence) || ArrayUtils.isEmpty(array)) {\n             return -1;\n         }\n-        final int csLen = cs.length();\n-        final int csLast = csLen - 1;\n-        final int searchLen = searchChars.length;\n-        final int searchLast = searchLen - 1;\n+        final int length = charSequence.length();\n+        final int n = length - 1;\n+        final int length2 = array.length;\n+        final int n2 = length2 - 1;\n         int i = 0;\n     Label_0040:\n-        while (i < csLen) {\n-            final char ch = cs.charAt(i);\n-            for (int j = 0; j < searchLen; ++j) {\n-                if (searchChars[j] == ch && (i >= csLast || j >= searchLast || !Character.isHighSurrogate(ch) || searchChars[j + 1] == cs.charAt(i + 1))) {\n+        while (i < length) {\n+            final char char1 = charSequence.charAt(i);\n+            for (int j = 0; j < length2; ++j) {\n+                if (array[j] == char1 && (i >= n || j >= n2 || !Character.isHighSurrogate(char1) || array[j + 1] == charSequence.charAt(i + 1))) {\n                     ++i;\n                     continue Label_0040;\n                 }\n             }\n             return i;\n         }\n         return -1;\n     }\n     \n-    public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) {\n-        if (isEmpty(seq) || isEmpty(searchChars)) {\n+    public static int indexOfAnyBut(final CharSequence charSequence, final CharSequence charSequence2) {\n+        if (isEmpty(charSequence) || isEmpty(charSequence2)) {\n             return -1;\n         }\n-        for (int strLen = seq.length(), i = 0; i < strLen; ++i) {\n-            final char ch = seq.charAt(i);\n-            final boolean chFound = CharSequenceUtils.indexOf(searchChars, (int)ch, 0) >= 0;\n-            if (i + 1 < strLen && Character.isHighSurrogate(ch)) {\n-                final char ch2 = seq.charAt(i + 1);\n-                if (chFound && CharSequenceUtils.indexOf(searchChars, (int)ch2, 0) < 0) {\n+        for (int length = charSequence.length(), i = 0; i < length; ++i) {\n+            final char char1 = charSequence.charAt(i);\n+            final boolean b = CharSequenceUtils.indexOf(charSequence2, (int)char1, 0) >= 0;\n+            if (i + 1 < length && Character.isHighSurrogate(char1)) {\n+                final char char2 = charSequence.charAt(i + 1);\n+                if (b && CharSequenceUtils.indexOf(charSequence2, (int)char2, 0) < 0) {\n                     return i;\n                 }\n             }\n-            else if (!chFound) {\n+            else if (!b) {\n                 return i;\n             }\n         }\n         return -1;\n     }\n     \n-    public static int indexOfDifference(final CharSequence... css) {\n-        if (ArrayUtils.getLength((Object)css) <= 1) {\n+    public static int indexOfDifference(final CharSequence... array) {\n+        if (ArrayUtils.getLength((Object)array) <= 1) {\n             return -1;\n         }\n-        boolean anyStringNull = false;\n-        boolean allStringsNull = true;\n-        final int arrayLen = css.length;\n-        int shortestStrLen = Integer.MAX_VALUE;\n-        int longestStrLen = 0;\n-        for (final CharSequence cs : css) {\n-            if (cs == null) {\n-                anyStringNull = true;\n-                shortestStrLen = 0;\n+        boolean b = false;\n+        boolean b2 = true;\n+        final int length = array.length;\n+        int min = Integer.MAX_VALUE;\n+        int max = 0;\n+        for (final CharSequence charSequence : array) {\n+            if (charSequence == null) {\n+                b = true;\n+                min = 0;\n             }\n             else {\n-                allStringsNull = false;\n-                shortestStrLen = Math.min(cs.length(), shortestStrLen);\n-                longestStrLen = Math.max(cs.length(), longestStrLen);\n+                b2 = false;\n+                min = Math.min(charSequence.length(), min);\n+                max = Math.max(charSequence.length(), max);\n             }\n         }\n-        if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) {\n+        if (b2 || (max == 0 && !b)) {\n             return -1;\n         }\n-        if (shortestStrLen == 0) {\n+        if (min == 0) {\n             return 0;\n         }\n-        int firstDiff = -1;\n-        for (int stringPos = 0; stringPos < shortestStrLen; ++stringPos) {\n-            final char comparisonChar = css[0].charAt(stringPos);\n-            for (int arrayPos = 1; arrayPos < arrayLen; ++arrayPos) {\n-                if (css[arrayPos].charAt(stringPos) != comparisonChar) {\n-                    firstDiff = stringPos;\n+        int n = -1;\n+        for (int j = 0; j < min; ++j) {\n+            final char char1 = array[0].charAt(j);\n+            for (int k = 1; k < length; ++k) {\n+                if (array[k].charAt(j) != char1) {\n+                    n = j;\n                     break;\n                 }\n             }\n-            if (firstDiff != -1) {\n+            if (n != -1) {\n                 break;\n             }\n         }\n-        if (firstDiff == -1 && shortestStrLen != longestStrLen) {\n-            return shortestStrLen;\n+        if (n == -1 && min != max) {\n+            return min;\n         }\n-        return firstDiff;\n+        return n;\n     }\n     \n-    public static int indexOfDifference(final CharSequence cs1, final CharSequence cs2) {\n-        if (cs1 == cs2) {\n+    public static int indexOfDifference(final CharSequence charSequence, final CharSequence charSequence2) {\n+        if (charSequence == charSequence2) {\n             return -1;\n         }\n-        if (cs1 == null || cs2 == null) {\n+        if (charSequence == null || charSequence2 == null) {\n             return 0;\n         }\n-        int i;\n-        for (i = 0; i < cs1.length() && i < cs2.length() && cs1.charAt(i) == cs2.charAt(i); ++i) {}\n-        if (i < cs2.length() || i < cs1.length()) {\n-            return i;\n+        int n;\n+        for (n = 0; n < charSequence.length() && n < charSequence2.length() && charSequence.charAt(n) == charSequence2.charAt(n); ++n) {}\n+        if (n < charSequence2.length() || n < charSequence.length()) {\n+            return n;\n         }\n         return -1;\n     }\n     \n-    public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr) {\n-        return indexOfIgnoreCase(str, searchStr, 0);\n+    public static int indexOfIgnoreCase(final CharSequence charSequence, final CharSequence charSequence2) {\n+        return indexOfIgnoreCase(charSequence, charSequence2, 0);\n     }\n     \n-    public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {\n-        if (str == null || searchStr == null) {\n+    public static int indexOfIgnoreCase(final CharSequence charSequence, final CharSequence charSequence2, int n) {\n+        if (charSequence == null || charSequence2 == null) {\n             return -1;\n         }\n-        if (startPos < 0) {\n-            startPos = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        final int endLimit = str.length() - searchStr.length() + 1;\n-        if (startPos > endLimit) {\n+        final int n2 = charSequence.length() - charSequence2.length() + 1;\n+        if (n > n2) {\n             return -1;\n         }\n-        if (searchStr.length() == 0) {\n-            return startPos;\n+        if (charSequence2.length() == 0) {\n+            return n;\n         }\n-        for (int i = startPos; i < endLimit; ++i) {\n-            if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {\n+        for (int i = n; i < n2; ++i) {\n+            if (CharSequenceUtils.regionMatches(charSequence, true, i, charSequence2, 0, charSequence2.length())) {\n                 return i;\n             }\n         }\n         return -1;\n     }\n     \n-    public static boolean isAllBlank(final CharSequence... css) {\n-        if (ArrayUtils.isEmpty((Object[])css)) {\n+    public static boolean isAllBlank(final CharSequence... array) {\n+        if (ArrayUtils.isEmpty((Object[])array)) {\n             return true;\n         }\n-        for (final CharSequence cs : css) {\n-            if (isNotBlank(cs)) {\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            if (isNotBlank(array[i])) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    public static boolean isAllEmpty(final CharSequence... css) {\n-        if (ArrayUtils.isEmpty((Object[])css)) {\n+    public static boolean isAllEmpty(final CharSequence... array) {\n+        if (ArrayUtils.isEmpty((Object[])array)) {\n             return true;\n         }\n-        for (final CharSequence cs : css) {\n-            if (isNotEmpty(cs)) {\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            if (isNotEmpty(array[i])) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    public static boolean isAllLowerCase(final CharSequence cs) {\n-        if (isEmpty(cs)) {\n+    public static boolean isAllLowerCase(final CharSequence charSequence) {\n+        if (isEmpty(charSequence)) {\n             return false;\n         }\n-        for (int sz = cs.length(), i = 0; i < sz; ++i) {\n-            if (!Character.isLowerCase(cs.charAt(i))) {\n+        for (int length = charSequence.length(), i = 0; i < length; ++i) {\n+            if (!Character.isLowerCase(charSequence.charAt(i))) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    public static boolean isAllUpperCase(final CharSequence cs) {\n-        if (isEmpty(cs)) {\n+    public static boolean isAllUpperCase(final CharSequence charSequence) {\n+        if (isEmpty(charSequence)) {\n             return false;\n         }\n-        for (int sz = cs.length(), i = 0; i < sz; ++i) {\n-            if (!Character.isUpperCase(cs.charAt(i))) {\n+        for (int length = charSequence.length(), i = 0; i < length; ++i) {\n+            if (!Character.isUpperCase(charSequence.charAt(i))) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    public static boolean isAlpha(final CharSequence cs) {\n-        if (isEmpty(cs)) {\n+    public static boolean isAlpha(final CharSequence charSequence) {\n+        if (isEmpty(charSequence)) {\n             return false;\n         }\n-        for (int sz = cs.length(), i = 0; i < sz; ++i) {\n-            if (!Character.isLetter(cs.charAt(i))) {\n+        for (int length = charSequence.length(), i = 0; i < length; ++i) {\n+            if (!Character.isLetter(charSequence.charAt(i))) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    public static boolean isAlphanumeric(final CharSequence cs) {\n-        if (isEmpty(cs)) {\n+    public static boolean isAlphanumeric(final CharSequence charSequence) {\n+        if (isEmpty(charSequence)) {\n             return false;\n         }\n-        for (int sz = cs.length(), i = 0; i < sz; ++i) {\n-            if (!Character.isLetterOrDigit(cs.charAt(i))) {\n+        for (int length = charSequence.length(), i = 0; i < length; ++i) {\n+            if (!Character.isLetterOrDigit(charSequence.charAt(i))) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    public static boolean isAlphanumericSpace(final CharSequence cs) {\n-        if (cs == null) {\n+    public static boolean isAlphanumericSpace(final CharSequence charSequence) {\n+        if (charSequence == null) {\n             return false;\n         }\n-        for (int sz = cs.length(), i = 0; i < sz; ++i) {\n-            final char nowChar = cs.charAt(i);\n-            if (nowChar != ' ' && !Character.isLetterOrDigit(nowChar)) {\n+        for (int length = charSequence.length(), i = 0; i < length; ++i) {\n+            final char char1 = charSequence.charAt(i);\n+            if (char1 != ' ' && !Character.isLetterOrDigit(char1)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    public static boolean isAlphaSpace(final CharSequence cs) {\n-        if (cs == null) {\n+    public static boolean isAlphaSpace(final CharSequence charSequence) {\n+        if (charSequence == null) {\n             return false;\n         }\n-        for (int sz = cs.length(), i = 0; i < sz; ++i) {\n-            final char nowChar = cs.charAt(i);\n-            if (nowChar != ' ' && !Character.isLetter(nowChar)) {\n+        for (int length = charSequence.length(), i = 0; i < length; ++i) {\n+            final char char1 = charSequence.charAt(i);\n+            if (char1 != ' ' && !Character.isLetter(char1)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    public static boolean isAnyBlank(final CharSequence... css) {\n-        if (ArrayUtils.isEmpty((Object[])css)) {\n+    public static boolean isAnyBlank(final CharSequence... array) {\n+        if (ArrayUtils.isEmpty((Object[])array)) {\n             return false;\n         }\n-        for (final CharSequence cs : css) {\n-            if (isBlank(cs)) {\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            if (isBlank(array[i])) {\n                 return true;\n             }\n         }\n         return false;\n     }\n     \n-    public static boolean isAnyEmpty(final CharSequence... css) {\n-        if (ArrayUtils.isEmpty((Object[])css)) {\n+    public static boolean isAnyEmpty(final CharSequence... array) {\n+        if (ArrayUtils.isEmpty((Object[])array)) {\n             return false;\n         }\n-        for (final CharSequence cs : css) {\n-            if (isEmpty(cs)) {\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            if (isEmpty(array[i])) {\n                 return true;\n             }\n         }\n         return false;\n     }\n     \n-    public static boolean isAsciiPrintable(final CharSequence cs) {\n-        if (cs == null) {\n+    public static boolean isAsciiPrintable(final CharSequence charSequence) {\n+        if (charSequence == null) {\n             return false;\n         }\n-        for (int sz = cs.length(), i = 0; i < sz; ++i) {\n-            if (!CharUtils.isAsciiPrintable(cs.charAt(i))) {\n+        for (int length = charSequence.length(), i = 0; i < length; ++i) {\n+            if (!CharUtils.isAsciiPrintable(charSequence.charAt(i))) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    public static boolean isBlank(final CharSequence cs) {\n-        final int strLen = length(cs);\n-        if (strLen == 0) {\n+    public static boolean isBlank(final CharSequence charSequence) {\n+        final int length = length(charSequence);\n+        if (length == 0) {\n             return true;\n         }\n-        for (int i = 0; i < strLen; ++i) {\n-            if (!Character.isWhitespace(cs.charAt(i))) {\n+        for (int i = 0; i < length; ++i) {\n+            if (!Character.isWhitespace(charSequence.charAt(i))) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    public static boolean isEmpty(final CharSequence cs) {\n-        return cs == null || cs.length() == 0;\n+    public static boolean isEmpty(final CharSequence charSequence) {\n+        return charSequence == null || charSequence.length() == 0;\n     }\n     \n-    public static boolean isMixedCase(final CharSequence cs) {\n-        if (isEmpty(cs) || cs.length() == 1) {\n+    public static boolean isMixedCase(final CharSequence charSequence) {\n+        if (isEmpty(charSequence) || charSequence.length() == 1) {\n             return false;\n         }\n-        boolean containsUppercase = false;\n-        boolean containsLowercase = false;\n-        for (int sz = cs.length(), i = 0; i < sz; ++i) {\n-            if (containsUppercase && containsLowercase) {\n+        int n = 0;\n+        int n2 = 0;\n+        for (int length = charSequence.length(), i = 0; i < length; ++i) {\n+            if (n != 0 && n2 != 0) {\n                 return true;\n             }\n-            if (Character.isUpperCase(cs.charAt(i))) {\n-                containsUppercase = true;\n+            if (Character.isUpperCase(charSequence.charAt(i))) {\n+                n = 1;\n             }\n-            else if (Character.isLowerCase(cs.charAt(i))) {\n-                containsLowercase = true;\n+            else if (Character.isLowerCase(charSequence.charAt(i))) {\n+                n2 = 1;\n             }\n         }\n-        return containsUppercase && containsLowercase;\n+        return n != 0 && n2 != 0;\n     }\n     \n-    public static boolean isNoneBlank(final CharSequence... css) {\n-        return !isAnyBlank(css);\n+    public static boolean isNoneBlank(final CharSequence... array) {\n+        return !isAnyBlank(array);\n     }\n     \n-    public static boolean isNoneEmpty(final CharSequence... css) {\n-        return !isAnyEmpty(css);\n+    public static boolean isNoneEmpty(final CharSequence... array) {\n+        return !isAnyEmpty(array);\n     }\n     \n-    public static boolean isNotBlank(final CharSequence cs) {\n-        return !isBlank(cs);\n+    public static boolean isNotBlank(final CharSequence charSequence) {\n+        return !isBlank(charSequence);\n     }\n     \n-    public static boolean isNotEmpty(final CharSequence cs) {\n-        return !isEmpty(cs);\n+    public static boolean isNotEmpty(final CharSequence charSequence) {\n+        return !isEmpty(charSequence);\n     }\n     \n-    public static boolean isNumeric(final CharSequence cs) {\n-        if (isEmpty(cs)) {\n+    public static boolean isNumeric(final CharSequence charSequence) {\n+        if (isEmpty(charSequence)) {\n             return false;\n         }\n-        for (int sz = cs.length(), i = 0; i < sz; ++i) {\n-            if (!Character.isDigit(cs.charAt(i))) {\n+        for (int length = charSequence.length(), i = 0; i < length; ++i) {\n+            if (!Character.isDigit(charSequence.charAt(i))) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    public static boolean isNumericSpace(final CharSequence cs) {\n-        if (cs == null) {\n+    public static boolean isNumericSpace(final CharSequence charSequence) {\n+        if (charSequence == null) {\n             return false;\n         }\n-        for (int sz = cs.length(), i = 0; i < sz; ++i) {\n-            final char nowChar = cs.charAt(i);\n-            if (nowChar != ' ' && !Character.isDigit(nowChar)) {\n+        for (int length = charSequence.length(), i = 0; i < length; ++i) {\n+            final char char1 = charSequence.charAt(i);\n+            if (char1 != ' ' && !Character.isDigit(char1)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    public static boolean isWhitespace(final CharSequence cs) {\n-        if (cs == null) {\n+    public static boolean isWhitespace(final CharSequence charSequence) {\n+        if (charSequence == null) {\n             return false;\n         }\n-        for (int sz = cs.length(), i = 0; i < sz; ++i) {\n-            if (!Character.isWhitespace(cs.charAt(i))) {\n+        for (int length = charSequence.length(), i = 0; i < length; ++i) {\n+            if (!Character.isWhitespace(charSequence.charAt(i))) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     \n-    public static String join(final boolean[] array, final char delimiter) {\n+    public static String join(final boolean[] array, final char c) {\n         if (array == null) {\n             return null;\n         }\n-        return join(array, delimiter, 0, array.length);\n+        return join(array, c, 0, array.length);\n     }\n     \n-    public static String join(final boolean[] array, final char delimiter, final int startIndex, final int endIndex) {\n+    public static String join(final boolean[] array, final char c, final int n, final int n2) {\n         if (array == null) {\n             return null;\n         }\n-        if (endIndex - startIndex <= 0) {\n+        if (n2 - n <= 0) {\n             return \"\";\n         }\n-        final StringJoiner joiner = newStringJoiner(delimiter);\n-        for (int i = startIndex; i < endIndex; ++i) {\n-            joiner.add(String.valueOf(array[i]));\n+        final StringJoiner stringJoiner = newStringJoiner(c);\n+        for (int i = n; i < n2; ++i) {\n+            stringJoiner.add(String.valueOf(array[i]));\n         }\n-        return joiner.toString();\n+        return stringJoiner.toString();\n     }\n     \n-    public static String join(final byte[] array, final char delimiter) {\n+    public static String join(final byte[] array, final char c) {\n         if (array == null) {\n             return null;\n         }\n-        return join(array, delimiter, 0, array.length);\n+        return join(array, c, 0, array.length);\n     }\n     \n-    public static String join(final byte[] array, final char delimiter, final int startIndex, final int endIndex) {\n+    public static String join(final byte[] array, final char c, final int n, final int n2) {\n         if (array == null) {\n             return null;\n         }\n-        if (endIndex - startIndex <= 0) {\n+        if (n2 - n <= 0) {\n             return \"\";\n         }\n-        final StringJoiner joiner = newStringJoiner(delimiter);\n-        for (int i = startIndex; i < endIndex; ++i) {\n-            joiner.add(String.valueOf(array[i]));\n+        final StringJoiner stringJoiner = newStringJoiner(c);\n+        for (int i = n; i < n2; ++i) {\n+            stringJoiner.add(String.valueOf(array[i]));\n         }\n-        return joiner.toString();\n+        return stringJoiner.toString();\n     }\n     \n-    public static String join(final char[] array, final char delimiter) {\n+    public static String join(final char[] array, final char c) {\n         if (array == null) {\n             return null;\n         }\n-        return join(array, delimiter, 0, array.length);\n+        return join(array, c, 0, array.length);\n     }\n     \n-    public static String join(final char[] array, final char delimiter, final int startIndex, final int endIndex) {\n+    public static String join(final char[] array, final char c, final int n, final int n2) {\n         if (array == null) {\n             return null;\n         }\n-        if (endIndex - startIndex <= 0) {\n+        if (n2 - n <= 0) {\n             return \"\";\n         }\n-        final StringJoiner joiner = newStringJoiner(delimiter);\n-        for (int i = startIndex; i < endIndex; ++i) {\n-            joiner.add(String.valueOf(array[i]));\n+        final StringJoiner stringJoiner = newStringJoiner(c);\n+        for (int i = n; i < n2; ++i) {\n+            stringJoiner.add(String.valueOf(array[i]));\n         }\n-        return joiner.toString();\n+        return stringJoiner.toString();\n     }\n     \n-    public static String join(final double[] array, final char delimiter) {\n+    public static String join(final double[] array, final char c) {\n         if (array == null) {\n             return null;\n         }\n-        return join(array, delimiter, 0, array.length);\n+        return join(array, c, 0, array.length);\n     }\n     \n-    public static String join(final double[] array, final char delimiter, final int startIndex, final int endIndex) {\n+    public static String join(final double[] array, final char c, final int n, final int n2) {\n         if (array == null) {\n             return null;\n         }\n-        if (endIndex - startIndex <= 0) {\n+        if (n2 - n <= 0) {\n             return \"\";\n         }\n-        final StringJoiner joiner = newStringJoiner(delimiter);\n-        for (int i = startIndex; i < endIndex; ++i) {\n-            joiner.add(String.valueOf(array[i]));\n+        final StringJoiner stringJoiner = newStringJoiner(c);\n+        for (int i = n; i < n2; ++i) {\n+            stringJoiner.add(String.valueOf(array[i]));\n         }\n-        return joiner.toString();\n+        return stringJoiner.toString();\n     }\n     \n-    public static String join(final float[] array, final char delimiter) {\n+    public static String join(final float[] array, final char c) {\n         if (array == null) {\n             return null;\n         }\n-        return join(array, delimiter, 0, array.length);\n+        return join(array, c, 0, array.length);\n     }\n     \n-    public static String join(final float[] array, final char delimiter, final int startIndex, final int endIndex) {\n+    public static String join(final float[] array, final char c, final int n, final int n2) {\n         if (array == null) {\n             return null;\n         }\n-        if (endIndex - startIndex <= 0) {\n+        if (n2 - n <= 0) {\n             return \"\";\n         }\n-        final StringJoiner joiner = newStringJoiner(delimiter);\n-        for (int i = startIndex; i < endIndex; ++i) {\n-            joiner.add(String.valueOf(array[i]));\n+        final StringJoiner stringJoiner = newStringJoiner(c);\n+        for (int i = n; i < n2; ++i) {\n+            stringJoiner.add(String.valueOf(array[i]));\n         }\n-        return joiner.toString();\n+        return stringJoiner.toString();\n     }\n     \n-    public static String join(final int[] array, final char separator) {\n+    public static String join(final int[] array, final char c) {\n         if (array == null) {\n             return null;\n         }\n-        return join(array, separator, 0, array.length);\n+        return join(array, c, 0, array.length);\n     }\n     \n-    public static String join(final int[] array, final char delimiter, final int startIndex, final int endIndex) {\n+    public static String join(final int[] array, final char c, final int n, final int n2) {\n         if (array == null) {\n             return null;\n         }\n-        if (endIndex - startIndex <= 0) {\n+        if (n2 - n <= 0) {\n             return \"\";\n         }\n-        final StringJoiner joiner = newStringJoiner(delimiter);\n-        for (int i = startIndex; i < endIndex; ++i) {\n-            joiner.add(String.valueOf(array[i]));\n+        final StringJoiner stringJoiner = newStringJoiner(c);\n+        for (int i = n; i < n2; ++i) {\n+            stringJoiner.add(String.valueOf(array[i]));\n         }\n-        return joiner.toString();\n+        return stringJoiner.toString();\n     }\n     \n-    public static String join(final Iterable<?> iterable, final char separator) {\n+    public static String join(final Iterable<?> iterable, final char c) {\n         if (iterable == null) {\n             return null;\n         }\n-        return join(iterable.iterator(), separator);\n+        return join(iterable.iterator(), c);\n     }\n     \n-    public static String join(final Iterable<?> iterable, final String separator) {\n+    public static String join(final Iterable<?> iterable, final String s) {\n         if (iterable == null) {\n             return null;\n         }\n-        return join(iterable.iterator(), separator);\n+        return join(iterable.iterator(), s);\n     }\n     \n-    public static String join(final Iterator<?> iterator, final char separator) {\n+    public static String join(final Iterator<?> iterator, final char c) {\n         if (iterator == null) {\n             return null;\n         }\n         if (!iterator.hasNext()) {\n             return \"\";\n         }\n-        final Object first = iterator.next();\n+        final Object next = iterator.next();\n         if (!iterator.hasNext()) {\n-            return toStringOrEmpty(first);\n+            return toStringOrEmpty(next);\n         }\n-        final StringBuilder buf = new StringBuilder(256);\n-        if (first != null) {\n-            buf.append(first);\n+        final StringBuilder sb = new StringBuilder(256);\n+        if (next != null) {\n+            sb.append(next);\n         }\n         while (iterator.hasNext()) {\n-            buf.append(separator);\n-            final Object obj = iterator.next();\n-            if (obj != null) {\n-                buf.append(obj);\n+            sb.append(c);\n+            final Object next2 = iterator.next();\n+            if (next2 != null) {\n+                sb.append(next2);\n             }\n         }\n-        return buf.toString();\n+        return sb.toString();\n     }\n     \n-    public static String join(final Iterator<?> iterator, final String separator) {\n+    public static String join(final Iterator<?> iterator, final String str) {\n         if (iterator == null) {\n             return null;\n         }\n         if (!iterator.hasNext()) {\n             return \"\";\n         }\n-        final Object first = iterator.next();\n+        final Object next = iterator.next();\n         if (!iterator.hasNext()) {\n-            return Objects.toString(first, \"\");\n+            return Objects.toString(next, \"\");\n         }\n-        final StringBuilder buf = new StringBuilder(256);\n-        if (first != null) {\n-            buf.append(first);\n+        final StringBuilder sb = new StringBuilder(256);\n+        if (next != null) {\n+            sb.append(next);\n         }\n         while (iterator.hasNext()) {\n-            if (separator != null) {\n-                buf.append(separator);\n+            if (str != null) {\n+                sb.append(str);\n             }\n-            final Object obj = iterator.next();\n-            if (obj != null) {\n-                buf.append(obj);\n+            final Object next2 = iterator.next();\n+            if (next2 != null) {\n+                sb.append(next2);\n             }\n         }\n-        return buf.toString();\n+        return sb.toString();\n     }\n     \n-    public static String join(final List<?> list, final char separator, final int startIndex, final int endIndex) {\n+    public static String join(final List<?> list, final char c, final int n, final int n2) {\n         if (list == null) {\n             return null;\n         }\n-        final int noOfItems = endIndex - startIndex;\n-        if (noOfItems <= 0) {\n+        if (n2 - n <= 0) {\n             return \"\";\n         }\n-        final List<?> subList = list.subList(startIndex, endIndex);\n-        return join(subList.iterator(), separator);\n+        return join(list.subList(n, n2).iterator(), c);\n     }\n     \n-    public static String join(final List<?> list, final String separator, final int startIndex, final int endIndex) {\n+    public static String join(final List<?> list, final String s, final int n, final int n2) {\n         if (list == null) {\n             return null;\n         }\n-        final int noOfItems = endIndex - startIndex;\n-        if (noOfItems <= 0) {\n+        if (n2 - n <= 0) {\n             return \"\";\n         }\n-        final List<?> subList = list.subList(startIndex, endIndex);\n-        return join(subList.iterator(), separator);\n+        return join(list.subList(n, n2).iterator(), s);\n     }\n     \n-    public static String join(final long[] array, final char separator) {\n+    public static String join(final long[] array, final char c) {\n         if (array == null) {\n             return null;\n         }\n-        return join(array, separator, 0, array.length);\n+        return join(array, c, 0, array.length);\n     }\n     \n-    public static String join(final long[] array, final char delimiter, final int startIndex, final int endIndex) {\n+    public static String join(final long[] array, final char c, final int n, final int n2) {\n         if (array == null) {\n             return null;\n         }\n-        if (endIndex - startIndex <= 0) {\n+        if (n2 - n <= 0) {\n             return \"\";\n         }\n-        final StringJoiner joiner = newStringJoiner(delimiter);\n-        for (int i = startIndex; i < endIndex; ++i) {\n-            joiner.add(String.valueOf(array[i]));\n+        final StringJoiner stringJoiner = newStringJoiner(c);\n+        for (int i = n; i < n2; ++i) {\n+            stringJoiner.add(String.valueOf(array[i]));\n         }\n-        return joiner.toString();\n+        return stringJoiner.toString();\n     }\n     \n-    public static String join(final Object[] array, final char delimiter) {\n+    public static String join(final Object[] array, final char c) {\n         if (array == null) {\n             return null;\n         }\n-        return join(array, delimiter, 0, array.length);\n+        return join(array, c, 0, array.length);\n     }\n     \n-    public static String join(final Object[] array, final char delimiter, final int startIndex, final int endIndex) {\n+    public static String join(final Object[] array, final char c, final int n, final int n2) {\n         if (array == null) {\n             return null;\n         }\n-        if (endIndex - startIndex <= 0) {\n+        if (n2 - n <= 0) {\n             return \"\";\n         }\n-        final StringJoiner joiner = newStringJoiner(delimiter);\n-        for (int i = startIndex; i < endIndex; ++i) {\n-            joiner.add(toStringOrEmpty(array[i]));\n+        final StringJoiner stringJoiner = newStringJoiner(c);\n+        for (int i = n; i < n2; ++i) {\n+            stringJoiner.add(toStringOrEmpty(array[i]));\n         }\n-        return joiner.toString();\n+        return stringJoiner.toString();\n     }\n     \n-    public static String join(final Object[] array, final String delimiter) {\n+    public static String join(final Object[] array, final String s) {\n         if (array == null) {\n             return null;\n         }\n-        return join(array, delimiter, 0, array.length);\n+        return join(array, s, 0, array.length);\n     }\n     \n-    public static String join(final Object[] array, final String delimiter, final int startIndex, final int endIndex) {\n+    public static String join(final Object[] array, final String s, final int n, final int n2) {\n         if (array == null) {\n             return null;\n         }\n-        if (endIndex - startIndex <= 0) {\n+        if (n2 - n <= 0) {\n             return \"\";\n         }\n-        final StringJoiner joiner = new StringJoiner(toStringOrEmpty(delimiter));\n-        for (int i = startIndex; i < endIndex; ++i) {\n-            joiner.add(toStringOrEmpty(array[i]));\n+        final StringJoiner stringJoiner = new StringJoiner(toStringOrEmpty(s));\n+        for (int i = n; i < n2; ++i) {\n+            stringJoiner.add(toStringOrEmpty(array[i]));\n         }\n-        return joiner.toString();\n+        return stringJoiner.toString();\n     }\n     \n-    public static String join(final short[] array, final char delimiter) {\n+    public static String join(final short[] array, final char c) {\n         if (array == null) {\n             return null;\n         }\n-        return join(array, delimiter, 0, array.length);\n+        return join(array, c, 0, array.length);\n     }\n     \n-    public static String join(final short[] array, final char delimiter, final int startIndex, final int endIndex) {\n+    public static String join(final short[] array, final char c, final int n, final int n2) {\n         if (array == null) {\n             return null;\n         }\n-        if (endIndex - startIndex <= 0) {\n+        if (n2 - n <= 0) {\n             return \"\";\n         }\n-        final StringJoiner joiner = newStringJoiner(delimiter);\n-        for (int i = startIndex; i < endIndex; ++i) {\n-            joiner.add(String.valueOf(array[i]));\n+        final StringJoiner stringJoiner = newStringJoiner(c);\n+        for (int i = n; i < n2; ++i) {\n+            stringJoiner.add(String.valueOf(array[i]));\n         }\n-        return joiner.toString();\n+        return stringJoiner.toString();\n     }\n     \n     @SafeVarargs\n-    public static <T> String join(final T... elements) {\n-        return join(elements, (String)null);\n+    public static <T> String join(final T... array) {\n+        return join(array, (String)null);\n     }\n     \n-    public static String joinWith(final String delimiter, final Object... array) {\n+    public static String joinWith(final String s, final Object... array) {\n         if (array == null) {\n             throw new IllegalArgumentException(\"Object varargs must not be null\");\n         }\n-        return join(array, delimiter);\n+        return join(array, s);\n     }\n     \n-    public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq) {\n-        if (seq == null) {\n+    public static int lastIndexOf(final CharSequence charSequence, final CharSequence charSequence2) {\n+        if (charSequence == null) {\n             return -1;\n         }\n-        return CharSequenceUtils.lastIndexOf(seq, searchSeq, seq.length());\n+        return CharSequenceUtils.lastIndexOf(charSequence, charSequence2, charSequence.length());\n     }\n     \n-    public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {\n-        return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);\n+    public static int lastIndexOf(final CharSequence charSequence, final CharSequence charSequence2, final int n) {\n+        return CharSequenceUtils.lastIndexOf(charSequence, charSequence2, n);\n     }\n     \n-    public static int lastIndexOf(final CharSequence seq, final int searchChar) {\n-        if (isEmpty(seq)) {\n+    public static int lastIndexOf(final CharSequence charSequence, final int n) {\n+        if (isEmpty(charSequence)) {\n             return -1;\n         }\n-        return CharSequenceUtils.lastIndexOf(seq, searchChar, seq.length());\n+        return CharSequenceUtils.lastIndexOf(charSequence, n, charSequence.length());\n     }\n     \n-    public static int lastIndexOf(final CharSequence seq, final int searchChar, final int startPos) {\n-        if (isEmpty(seq)) {\n+    public static int lastIndexOf(final CharSequence charSequence, final int n, final int n2) {\n+        if (isEmpty(charSequence)) {\n             return -1;\n         }\n-        return CharSequenceUtils.lastIndexOf(seq, searchChar, startPos);\n+        return CharSequenceUtils.lastIndexOf(charSequence, n, n2);\n     }\n     \n-    public static int lastIndexOfAny(final CharSequence str, final CharSequence... searchStrs) {\n-        if (str == null || searchStrs == null) {\n+    public static int lastIndexOfAny(final CharSequence charSequence, final CharSequence... array) {\n+        if (charSequence == null || array == null) {\n             return -1;\n         }\n-        int ret = -1;\n-        int tmp = 0;\n-        for (final CharSequence search : searchStrs) {\n-            if (search != null) {\n-                tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());\n-                if (tmp > ret) {\n-                    ret = tmp;\n+        int n = -1;\n+        for (final CharSequence charSequence2 : array) {\n+            if (charSequence2 != null) {\n+                final int lastIndex = CharSequenceUtils.lastIndexOf(charSequence, charSequence2, charSequence.length());\n+                if (lastIndex > n) {\n+                    n = lastIndex;\n                 }\n             }\n         }\n-        return ret;\n+        return n;\n     }\n     \n-    public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr) {\n-        if (str == null || searchStr == null) {\n+    public static int lastIndexOfIgnoreCase(final CharSequence charSequence, final CharSequence charSequence2) {\n+        if (charSequence == null || charSequence2 == null) {\n             return -1;\n         }\n-        return lastIndexOfIgnoreCase(str, searchStr, str.length());\n+        return lastIndexOfIgnoreCase(charSequence, charSequence2, charSequence.length());\n     }\n     \n-    public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {\n-        if (str == null || searchStr == null) {\n+    public static int lastIndexOfIgnoreCase(final CharSequence charSequence, final CharSequence charSequence2, int n) {\n+        if (charSequence == null || charSequence2 == null) {\n             return -1;\n         }\n-        final int searchStrLength = searchStr.length();\n-        final int strLength = str.length();\n-        if (startPos > strLength - searchStrLength) {\n-            startPos = strLength - searchStrLength;\n+        final int length = charSequence2.length();\n+        final int length2 = charSequence.length();\n+        if (n > length2 - length) {\n+            n = length2 - length;\n         }\n-        if (startPos < 0) {\n+        if (n < 0) {\n             return -1;\n         }\n-        if (searchStrLength == 0) {\n-            return startPos;\n+        if (length == 0) {\n+            return n;\n         }\n-        for (int i = startPos; i >= 0; --i) {\n-            if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStrLength)) {\n+        for (int i = n; i >= 0; --i) {\n+            if (CharSequenceUtils.regionMatches(charSequence, true, i, charSequence2, 0, length)) {\n                 return i;\n             }\n         }\n         return -1;\n     }\n     \n-    public static int lastOrdinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) {\n-        return ordinalIndexOf(str, searchStr, ordinal, true);\n+    public static int lastOrdinalIndexOf(final CharSequence charSequence, final CharSequence charSequence2, final int n) {\n+        return ordinalIndexOf(charSequence, charSequence2, n, true);\n     }\n     \n-    public static String left(final String str, final int len) {\n-        if (str == null) {\n+    public static String left(final String s, final int endIndex) {\n+        if (s == null) {\n             return null;\n         }\n-        if (len < 0) {\n+        if (endIndex < 0) {\n             return \"\";\n         }\n-        if (str.length() <= len) {\n-            return str;\n+        if (s.length() <= endIndex) {\n+            return s;\n         }\n-        return str.substring(0, len);\n+        return s.substring(0, endIndex);\n     }\n     \n-    public static String leftPad(final String str, final int size) {\n-        return leftPad(str, size, ' ');\n+    public static String leftPad(final String s, final int n) {\n+        return leftPad(s, n, ' ');\n     }\n     \n-    public static String leftPad(final String str, final int size, final char padChar) {\n+    public static String leftPad(final String str, final int n, final char c) {\n         if (str == null) {\n             return null;\n         }\n-        final int pads = size - str.length();\n-        if (pads <= 0) {\n+        final int n2 = n - str.length();\n+        if (n2 <= 0) {\n             return str;\n         }\n-        if (pads > 8192) {\n-            return leftPad(str, size, String.valueOf(padChar));\n+        if (n2 > 8192) {\n+            return leftPad(str, n, String.valueOf(c));\n         }\n-        return repeat(padChar, pads).concat(str);\n+        return repeat(c, n2).concat(str);\n     }\n     \n-    public static String leftPad(final String str, final int size, String padStr) {\n+    public static String leftPad(final String str, final int n, String s) {\n         if (str == null) {\n             return null;\n         }\n-        if (isEmpty(padStr)) {\n-            padStr = \" \";\n+        if (isEmpty(s)) {\n+            s = \" \";\n         }\n-        final int padLen = padStr.length();\n-        final int strLen = str.length();\n-        final int pads = size - strLen;\n-        if (pads <= 0) {\n+        final int length = s.length();\n+        final int endIndex = n - str.length();\n+        if (endIndex <= 0) {\n             return str;\n         }\n-        if (padLen == 1 && pads <= 8192) {\n-            return leftPad(str, size, padStr.charAt(0));\n+        if (length == 1 && endIndex <= 8192) {\n+            return leftPad(str, n, s.charAt(0));\n         }\n-        if (pads == padLen) {\n-            return padStr.concat(str);\n+        if (endIndex == length) {\n+            return s.concat(str);\n         }\n-        if (pads < padLen) {\n-            return padStr.substring(0, pads).concat(str);\n+        if (endIndex < length) {\n+            return s.substring(0, endIndex).concat(str);\n         }\n-        final char[] padding = new char[pads];\n-        final char[] padChars = padStr.toCharArray();\n-        for (int i = 0; i < pads; ++i) {\n-            padding[i] = padChars[i % padLen];\n+        final char[] value = new char[endIndex];\n+        final char[] charArray = s.toCharArray();\n+        for (int i = 0; i < endIndex; ++i) {\n+            value[i] = charArray[i % length];\n         }\n-        return new String(padding).concat(str);\n+        return new String(value).concat(str);\n     }\n     \n-    public static int length(final CharSequence cs) {\n-        return (cs == null) ? 0 : cs.length();\n+    public static int length(final CharSequence charSequence) {\n+        return (charSequence == null) ? 0 : charSequence.length();\n     }\n     \n-    public static String lowerCase(final String str) {\n-        if (str == null) {\n+    public static String lowerCase(final String s) {\n+        if (s == null) {\n             return null;\n         }\n-        return str.toLowerCase();\n+        return s.toLowerCase();\n     }\n     \n-    public static String lowerCase(final String str, final Locale locale) {\n-        if (str == null) {\n+    public static String lowerCase(final String s, final Locale locale) {\n+        if (s == null) {\n             return null;\n         }\n-        return str.toLowerCase(LocaleUtils.toLocale(locale));\n+        return s.toLowerCase(LocaleUtils.toLocale(locale));\n     }\n     \n-    private static int[] matches(final CharSequence first, final CharSequence second) {\n-        CharSequence max;\n-        CharSequence min;\n-        if (first.length() > second.length()) {\n-            max = first;\n-            min = second;\n+    private static int[] matches(final CharSequence charSequence, final CharSequence charSequence2) {\n+        CharSequence charSequence3;\n+        CharSequence charSequence4;\n+        if (charSequence.length() > charSequence2.length()) {\n+            charSequence3 = charSequence;\n+            charSequence4 = charSequence2;\n         }\n         else {\n-            max = second;\n-            min = first;\n+            charSequence3 = charSequence2;\n+            charSequence4 = charSequence;\n         }\n-        final int range = Math.max(max.length() / 2 - 1, 0);\n-        final int[] matchIndexes = new int[min.length()];\n-        Arrays.fill(matchIndexes, -1);\n-        final boolean[] matchFlags = new boolean[max.length()];\n-        int matches = 0;\n-        for (int mi = 0; mi < min.length(); ++mi) {\n-            final char c1 = min.charAt(mi);\n-            for (int xi = Math.max(mi - range, 0), xn = Math.min(mi + range + 1, max.length()); xi < xn; ++xi) {\n-                if (!matchFlags[xi] && c1 == max.charAt(xi)) {\n-                    matchFlags[matchIndexes[mi] = xi] = true;\n-                    ++matches;\n+        final int max = Math.max(charSequence3.length() / 2 - 1, 0);\n+        final int[] a = new int[charSequence4.length()];\n+        Arrays.fill(a, -1);\n+        final boolean[] array = new boolean[charSequence3.length()];\n+        int n = 0;\n+        for (int i = 0; i < charSequence4.length(); ++i) {\n+            final char char1 = charSequence4.charAt(i);\n+            for (int j = Math.max(i - max, 0); j < Math.min(i + max + 1, charSequence3.length()); ++j) {\n+                if (!array[j] && char1 == charSequence3.charAt(j)) {\n+                    array[a[i] = j] = true;\n+                    ++n;\n                     break;\n                 }\n             }\n         }\n-        final char[] ms1 = new char[matches];\n-        final char[] ms2 = new char[matches];\n-        int i = 0;\n-        int si = 0;\n-        while (i < min.length()) {\n-            if (matchIndexes[i] != -1) {\n-                ms1[si] = min.charAt(i);\n-                ++si;\n+        final char[] array2 = new char[n];\n+        final char[] array3 = new char[n];\n+        int k = 0;\n+        int n2 = 0;\n+        while (k < charSequence4.length()) {\n+            if (a[k] != -1) {\n+                array2[n2] = charSequence4.charAt(k);\n+                ++n2;\n             }\n-            ++i;\n+            ++k;\n         }\n-        i = 0;\n-        si = 0;\n-        while (i < max.length()) {\n-            if (matchFlags[i]) {\n-                ms2[si] = max.charAt(i);\n-                ++si;\n+        int l = 0;\n+        int n3 = 0;\n+        while (l < charSequence3.length()) {\n+            if (array[l]) {\n+                array3[n3] = charSequence3.charAt(l);\n+                ++n3;\n             }\n-            ++i;\n+            ++l;\n         }\n-        int transpositions = 0;\n-        for (int mi2 = 0; mi2 < ms1.length; ++mi2) {\n-            if (ms1[mi2] != ms2[mi2]) {\n-                ++transpositions;\n+        int n4 = 0;\n+        for (int n5 = 0; n5 < array2.length; ++n5) {\n+            if (array2[n5] != array3[n5]) {\n+                ++n4;\n             }\n         }\n-        int prefix = 0;\n-        for (int mi3 = 0; mi3 < min.length() && first.charAt(mi3) == second.charAt(mi3); ++mi3) {\n-            ++prefix;\n+        int n6 = 0;\n+        for (int n7 = 0; n7 < charSequence4.length() && charSequence.charAt(n7) == charSequence2.charAt(n7); ++n7) {\n+            ++n6;\n         }\n-        return new int[] { matches, transpositions / 2, prefix, max.length() };\n+        return new int[] { n, n4 / 2, n6, charSequence3.length() };\n     }\n     \n-    public static String mid(final String str, int pos, final int len) {\n-        if (str == null) {\n+    public static String mid(final String s, int n, final int n2) {\n+        if (s == null) {\n             return null;\n         }\n-        if (len < 0 || pos > str.length()) {\n+        if (n2 < 0 || n > s.length()) {\n             return \"\";\n         }\n-        if (pos < 0) {\n-            pos = 0;\n+        if (n < 0) {\n+            n = 0;\n         }\n-        if (str.length() <= pos + len) {\n-            return str.substring(pos);\n+        if (s.length() <= n + n2) {\n+            return s.substring(n);\n         }\n-        return str.substring(pos, pos + len);\n+        return s.substring(n, n + n2);\n     }\n     \n-    private static StringJoiner newStringJoiner(final char delimiter) {\n-        return new StringJoiner(String.valueOf(delimiter));\n+    private static StringJoiner newStringJoiner(final char c) {\n+        return new StringJoiner(String.valueOf(c));\n     }\n     \n-    public static String normalizeSpace(final String str) {\n-        if (isEmpty(str)) {\n-            return str;\n+    public static String normalizeSpace(final String s) {\n+        if (isEmpty(s)) {\n+            return s;\n         }\n-        final int size = str.length();\n-        final char[] newChars = new char[size];\n-        int count = 0;\n-        int whitespacesCount = 0;\n-        boolean startWhitespaces = true;\n-        for (int i = 0; i < size; ++i) {\n-            final char actualChar = str.charAt(i);\n-            final boolean isWhitespace = Character.isWhitespace(actualChar);\n-            if (isWhitespace) {\n-                if (whitespacesCount == 0 && !startWhitespaces) {\n-                    newChars[count++] = \" \".charAt(0);\n+        final int length = s.length();\n+        final char[] value = new char[length];\n+        int n = 0;\n+        int n2 = 0;\n+        int n3 = 1;\n+        for (int i = 0; i < length; ++i) {\n+            final char char1 = s.charAt(i);\n+            if (Character.isWhitespace(char1)) {\n+                if (n2 == 0 && n3 == 0) {\n+                    value[n++] = \" \".charAt(0);\n                 }\n-                ++whitespacesCount;\n+                ++n2;\n             }\n             else {\n-                startWhitespaces = false;\n-                newChars[count++] = ((actualChar == '\u00a0') ? ' ' : actualChar);\n-                whitespacesCount = 0;\n+                n3 = 0;\n+                value[n++] = ((char1 == '\u00a0') ? ' ' : char1);\n+                n2 = 0;\n             }\n         }\n-        if (startWhitespaces) {\n+        if (n3 != 0) {\n             return \"\";\n         }\n-        return new String(newChars, 0, count - ((whitespacesCount > 0) ? 1 : 0)).trim();\n+        return new String(value, 0, n - ((n2 > 0) ? 1 : 0)).trim();\n     }\n     \n-    public static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) {\n-        return ordinalIndexOf(str, searchStr, ordinal, false);\n+    public static int ordinalIndexOf(final CharSequence charSequence, final CharSequence charSequence2, final int n) {\n+        return ordinalIndexOf(charSequence, charSequence2, n, false);\n     }\n     \n-    private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) {\n-        if (str == null || searchStr == null || ordinal <= 0) {\n+    private static int ordinalIndexOf(final CharSequence charSequence, final CharSequence charSequence2, final int n, final boolean b) {\n+        if (charSequence == null || charSequence2 == null || n <= 0) {\n             return -1;\n         }\n-        if (searchStr.length() == 0) {\n-            return lastIndex ? str.length() : 0;\n+        if (charSequence2.length() == 0) {\n+            return b ? charSequence.length() : 0;\n         }\n-        int found = 0;\n-        int index = lastIndex ? str.length() : -1;\n+        int n2 = 0;\n+        int n3 = b ? charSequence.length() : -1;\n         do {\n-            if (lastIndex) {\n-                index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1);\n+            if (b) {\n+                n3 = CharSequenceUtils.lastIndexOf(charSequence, charSequence2, n3 - 1);\n             }\n             else {\n-                index = CharSequenceUtils.indexOf(str, searchStr, index + 1);\n+                n3 = CharSequenceUtils.indexOf(charSequence, charSequence2, n3 + 1);\n             }\n-            if (index < 0) {\n-                return index;\n+            if (n3 < 0) {\n+                return n3;\n             }\n-        } while (++found < ordinal);\n-        return index;\n+        } while (++n2 < n);\n+        return n3;\n     }\n     \n-    public static String overlay(final String str, String overlay, int start, int end) {\n-        if (str == null) {\n+    public static String overlay(final String s, String str, int endIndex, int beginIndex) {\n+        if (s == null) {\n             return null;\n         }\n-        if (overlay == null) {\n-            overlay = \"\";\n+        if (str == null) {\n+            str = \"\";\n         }\n-        final int len = str.length();\n-        if (start < 0) {\n-            start = 0;\n+        final int length = s.length();\n+        if (endIndex < 0) {\n+            endIndex = 0;\n         }\n-        if (start > len) {\n-            start = len;\n+        if (endIndex > length) {\n+            endIndex = length;\n         }\n-        if (end < 0) {\n-            end = 0;\n+        if (beginIndex < 0) {\n+            beginIndex = 0;\n         }\n-        if (end > len) {\n-            end = len;\n+        if (beginIndex > length) {\n+            beginIndex = length;\n         }\n-        if (start > end) {\n-            final int temp = start;\n-            start = end;\n-            end = temp;\n+        if (endIndex > beginIndex) {\n+            final int n = endIndex;\n+            endIndex = beginIndex;\n+            beginIndex = n;\n         }\n-        return str.substring(0, start) + overlay + str.substring(end);\n+        return s.substring(0, endIndex) + str + s.substring(beginIndex);\n     }\n     \n-    private static String prependIfMissing(final String str, final CharSequence prefix, final boolean ignoreCase, final CharSequence... prefixes) {\n-        if (str == null || isEmpty(prefix) || startsWith(str, prefix, ignoreCase)) {\n+    private static String prependIfMissing(final String str, final CharSequence charSequence, final boolean b, final CharSequence... array) {\n+        if (str == null || isEmpty(charSequence) || startsWith(str, charSequence, b)) {\n             return str;\n         }\n-        if (ArrayUtils.isNotEmpty((Object[])prefixes)) {\n-            for (final CharSequence p : prefixes) {\n-                if (startsWith(str, p, ignoreCase)) {\n+        if (ArrayUtils.isNotEmpty((Object[])array)) {\n+            for (int length = array.length, i = 0; i < length; ++i) {\n+                if (startsWith(str, array[i], b)) {\n                     return str;\n                 }\n             }\n         }\n-        return prefix.toString() + str;\n+        return charSequence.toString() + str;\n     }\n     \n-    public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {\n-        return prependIfMissing(str, prefix, false, prefixes);\n+    public static String prependIfMissing(final String s, final CharSequence charSequence, final CharSequence... array) {\n+        return prependIfMissing(s, charSequence, false, array);\n     }\n     \n-    public static String prependIfMissingIgnoreCase(final String str, final CharSequence prefix, final CharSequence... prefixes) {\n-        return prependIfMissing(str, prefix, true, prefixes);\n+    public static String prependIfMissingIgnoreCase(final String s, final CharSequence charSequence, final CharSequence... array) {\n+        return prependIfMissing(s, charSequence, true, array);\n     }\n     \n-    public static String remove(final String str, final char remove) {\n-        if (isEmpty(str) || str.indexOf(remove) == -1) {\n-            return str;\n+    public static String remove(final String s, final char ch) {\n+        if (isEmpty(s) || s.indexOf(ch) == -1) {\n+            return s;\n         }\n-        final char[] chars = str.toCharArray();\n-        int pos = 0;\n-        for (int i = 0; i < chars.length; ++i) {\n-            if (chars[i] != remove) {\n-                chars[pos++] = chars[i];\n+        final char[] charArray = s.toCharArray();\n+        int count = 0;\n+        for (int i = 0; i < charArray.length; ++i) {\n+            if (charArray[i] != ch) {\n+                charArray[count++] = charArray[i];\n             }\n         }\n-        return new String(chars, 0, pos);\n+        return new String(charArray, 0, count);\n     }\n     \n-    public static String remove(final String str, final String remove) {\n-        if (isEmpty(str) || isEmpty(remove)) {\n-            return str;\n+    public static String remove(final String s, final String s2) {\n+        if (isEmpty(s) || isEmpty(s2)) {\n+            return s;\n         }\n-        return replace(str, remove, \"\", -1);\n+        return replace(s, s2, \"\", -1);\n     }\n     \n     @Deprecated\n-    public static String removeAll(final String text, final String regex) {\n-        return RegExUtils.removeAll(text, regex);\n+    public static String removeAll(final String s, final String s2) {\n+        return RegExUtils.removeAll(s, s2);\n     }\n     \n-    public static String removeEnd(final String str, final String remove) {\n-        if (isEmpty(str) || isEmpty(remove)) {\n-            return str;\n+    public static String removeEnd(final String s, final String suffix) {\n+        if (isEmpty(s) || isEmpty(suffix)) {\n+            return s;\n         }\n-        if (str.endsWith(remove)) {\n-            return str.substring(0, str.length() - remove.length());\n+        if (s.endsWith(suffix)) {\n+            return s.substring(0, s.length() - suffix.length());\n         }\n-        return str;\n+        return s;\n     }\n     \n-    public static String removeEndIgnoreCase(final String str, final String remove) {\n-        if (isEmpty(str) || isEmpty(remove)) {\n-            return str;\n+    public static String removeEndIgnoreCase(final String s, final String s2) {\n+        if (isEmpty(s) || isEmpty(s2)) {\n+            return s;\n         }\n-        if (endsWithIgnoreCase(str, remove)) {\n-            return str.substring(0, str.length() - remove.length());\n+        if (endsWithIgnoreCase(s, s2)) {\n+            return s.substring(0, s.length() - s2.length());\n         }\n-        return str;\n+        return s;\n     }\n     \n     @Deprecated\n-    public static String removeFirst(final String text, final String regex) {\n-        return replaceFirst(text, regex, \"\");\n+    public static String removeFirst(final String s, final String s2) {\n+        return replaceFirst(s, s2, \"\");\n     }\n     \n-    public static String removeIgnoreCase(final String str, final String remove) {\n-        return replaceIgnoreCase(str, remove, \"\", -1);\n+    public static String removeIgnoreCase(final String s, final String s2) {\n+        return replaceIgnoreCase(s, s2, \"\", -1);\n     }\n     \n     @Deprecated\n-    public static String removePattern(final String source, final String regex) {\n-        return RegExUtils.removePattern(source, regex);\n+    public static String removePattern(final String s, final String s2) {\n+        return RegExUtils.removePattern(s, s2);\n     }\n     \n-    public static String removeStart(final String str, final String remove) {\n-        if (isEmpty(str) || isEmpty(remove)) {\n-            return str;\n+    public static String removeStart(final String s, final String prefix) {\n+        if (isEmpty(s) || isEmpty(prefix)) {\n+            return s;\n         }\n-        if (str.startsWith(remove)) {\n-            return str.substring(remove.length());\n+        if (s.startsWith(prefix)) {\n+            return s.substring(prefix.length());\n         }\n-        return str;\n+        return s;\n     }\n     \n-    public static String removeStartIgnoreCase(final String str, final String remove) {\n-        if (str != null && startsWithIgnoreCase(str, remove)) {\n-            return str.substring(length((CharSequence)remove));\n+    public static String removeStartIgnoreCase(final String s, final String s2) {\n+        if (s != null && startsWithIgnoreCase(s, s2)) {\n+            return s.substring(length((CharSequence)s2));\n         }\n-        return str;\n+        return s;\n     }\n     \n-    public static String repeat(final char ch, final int repeat) {\n-        if (repeat <= 0) {\n+    public static String repeat(final char val, final int n) {\n+        if (n <= 0) {\n             return \"\";\n         }\n-        final char[] buf = new char[repeat];\n-        Arrays.fill(buf, ch);\n-        return new String(buf);\n+        final char[] array = new char[n];\n+        Arrays.fill(array, val);\n+        return new String(array);\n     }\n     \n-    public static String repeat(final String str, final int repeat) {\n+    public static String repeat(final String str, final int n) {\n         if (str == null) {\n             return null;\n         }\n-        if (repeat <= 0) {\n+        if (n <= 0) {\n             return \"\";\n         }\n-        final int inputLength = str.length();\n-        if (repeat == 1 || inputLength == 0) {\n+        final int length = str.length();\n+        if (n == 1 || length == 0) {\n             return str;\n         }\n-        if (inputLength == 1 && repeat <= 8192) {\n-            return repeat(str.charAt(0), repeat);\n+        if (length == 1 && n <= 8192) {\n+            return repeat(str.charAt(0), n);\n         }\n-        final int outputLength = inputLength * repeat;\n-        switch (inputLength) {\n+        final int capacity = length * n;\n+        switch (length) {\n             case 1: {\n-                return repeat(str.charAt(0), repeat);\n+                return repeat(str.charAt(0), n);\n             }\n             case 2: {\n-                final char ch0 = str.charAt(0);\n-                final char ch2 = str.charAt(1);\n-                final char[] output2 = new char[outputLength];\n-                for (int i = repeat * 2 - 2; i >= 0; --i, --i) {\n-                    output2[i] = ch0;\n-                    output2[i + 1] = ch2;\n+                final char char1 = str.charAt(0);\n+                final char char2 = str.charAt(1);\n+                final char[] value = new char[capacity];\n+                for (int i = n * 2 - 2; i >= 0; --i, --i) {\n+                    value[i] = char1;\n+                    value[i + 1] = char2;\n                 }\n-                return new String(output2);\n+                return new String(value);\n             }\n             default: {\n-                final StringBuilder buf = new StringBuilder(outputLength);\n-                for (int j = 0; j < repeat; ++j) {\n-                    buf.append(str);\n+                final StringBuilder sb = new StringBuilder(capacity);\n+                for (int j = 0; j < n; ++j) {\n+                    sb.append(str);\n                 }\n-                return buf.toString();\n+                return sb.toString();\n             }\n         }\n     }\n     \n-    public static String repeat(final String str, final String separator, final int repeat) {\n-        if (str == null || separator == null) {\n-            return repeat(str, repeat);\n+    public static String repeat(final String str, final String str2, final int n) {\n+        if (str == null || str2 == null) {\n+            return repeat(str, n);\n         }\n-        final String result = repeat(str + separator, repeat);\n-        return removeEnd(result, separator);\n+        return removeEnd(repeat(str + str2, n), str2);\n     }\n     \n-    public static String replace(final String text, final String searchString, final String replacement) {\n-        return replace(text, searchString, replacement, -1);\n+    public static String replace(final String s, final String s2, final String s3) {\n+        return replace(s, s2, s3, -1);\n     }\n     \n-    public static String replace(final String text, final String searchString, final String replacement, final int max) {\n-        return replace(text, searchString, replacement, max, false);\n+    public static String replace(final String s, final String s2, final String s3, final int n) {\n+        return replace(s, s2, s3, n, false);\n     }\n     \n-    private static String replace(final String text, String searchString, final String replacement, int max, final boolean ignoreCase) {\n-        if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {\n-            return text;\n+    private static String replace(final String s, String lowerCase, final String str, int a, final boolean b) {\n+        if (isEmpty(s) || isEmpty(lowerCase) || str == null || a == 0) {\n+            return s;\n         }\n-        if (ignoreCase) {\n-            searchString = searchString.toLowerCase();\n+        if (b) {\n+            lowerCase = lowerCase.toLowerCase();\n         }\n-        int start = 0;\n-        int end = ignoreCase ? indexOfIgnoreCase(text, searchString, start) : indexOf(text, searchString, start);\n-        if (end == -1) {\n-            return text;\n+        int n = 0;\n+        int i = b ? indexOfIgnoreCase(s, lowerCase, n) : indexOf(s, lowerCase, n);\n+        if (i == -1) {\n+            return s;\n         }\n-        final int replLength = searchString.length();\n-        int increase = Math.max(replacement.length() - replLength, 0);\n-        increase *= ((max < 0) ? 16 : Math.min(max, 64));\n-        final StringBuilder buf = new StringBuilder(text.length() + increase);\n-        while (end != -1) {\n-            buf.append(text, start, end).append(replacement);\n-            start = end + replLength;\n-            if (--max == 0) {\n+        final int length = lowerCase.length();\n+        final StringBuilder sb = new StringBuilder(s.length() + Math.max(str.length() - length, 0) * ((a < 0) ? 16 : Math.min(a, 64)));\n+        while (i != -1) {\n+            sb.append(s, n, i).append(str);\n+            n = i + length;\n+            if (--a == 0) {\n                 break;\n             }\n-            end = (ignoreCase ? indexOfIgnoreCase(text, searchString, start) : indexOf(text, searchString, start));\n+            i = (b ? indexOfIgnoreCase(s, lowerCase, n) : indexOf(s, lowerCase, n));\n         }\n-        buf.append(text, start, text.length());\n-        return buf.toString();\n+        sb.append(s, n, s.length());\n+        return sb.toString();\n     }\n     \n     @Deprecated\n-    public static String replaceAll(final String text, final String regex, final String replacement) {\n-        return RegExUtils.replaceAll(text, regex, replacement);\n+    public static String replaceAll(final String s, final String s2, final String s3) {\n+        return RegExUtils.replaceAll(s, s2, s3);\n     }\n     \n-    public static String replaceChars(final String str, final char searchChar, final char replaceChar) {\n-        if (str == null) {\n+    public static String replaceChars(final String s, final char oldChar, final char newChar) {\n+        if (s == null) {\n             return null;\n         }\n-        return str.replace(searchChar, replaceChar);\n+        return s.replace(oldChar, newChar);\n     }\n     \n-    public static String replaceChars(final String str, final String searchChars, String replaceChars) {\n-        if (isEmpty(str) || isEmpty(searchChars)) {\n-            return str;\n+    public static String replaceChars(final String s, final String s2, String s3) {\n+        if (isEmpty(s) || isEmpty(s2)) {\n+            return s;\n         }\n-        if (replaceChars == null) {\n-            replaceChars = \"\";\n+        if (s3 == null) {\n+            s3 = \"\";\n         }\n-        boolean modified = false;\n-        final int replaceCharsLength = replaceChars.length();\n-        final int strLength = str.length();\n-        final StringBuilder buf = new StringBuilder(strLength);\n-        for (int i = 0; i < strLength; ++i) {\n-            final char ch = str.charAt(i);\n-            final int index = searchChars.indexOf(ch);\n+        boolean b = false;\n+        final int length = s3.length();\n+        final int length2 = s.length();\n+        final StringBuilder sb = new StringBuilder(length2);\n+        for (int i = 0; i < length2; ++i) {\n+            final char char1 = s.charAt(i);\n+            final int index = s2.indexOf(char1);\n             if (index >= 0) {\n-                modified = true;\n-                if (index < replaceCharsLength) {\n-                    buf.append(replaceChars.charAt(index));\n+                b = true;\n+                if (index < length) {\n+                    sb.append(s3.charAt(index));\n                 }\n             }\n             else {\n-                buf.append(ch);\n+                sb.append(char1);\n             }\n         }\n-        if (modified) {\n-            return buf.toString();\n+        if (b) {\n+            return sb.toString();\n         }\n-        return str;\n+        return s;\n     }\n     \n-    public static String replaceEach(final String text, final String[] searchList, final String[] replacementList) {\n-        return replaceEach(text, searchList, replacementList, false, 0);\n+    public static String replaceEach(final String s, final String[] array, final String[] array2) {\n+        return replaceEach(s, array, array2, false, 0);\n     }\n     \n-    private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {\n-        if (timeToLive < 0) {\n-            final Set<String> searchSet = new HashSet<String>(Arrays.asList(searchList));\n-            final Set<String> replacementSet = new HashSet<String>(Arrays.asList(replacementList));\n-            searchSet.retainAll(replacementSet);\n-            if (!searchSet.isEmpty()) {\n+    private static String replaceEach(final String s, final String[] a, final String[] a2, final boolean b, final int n) {\n+        if (n < 0) {\n+            final HashSet set = new HashSet((Collection<? extends E>)Arrays.asList(a));\n+            set.retainAll(new HashSet(Arrays.asList(a2)));\n+            if (!set.isEmpty()) {\n                 throw new IllegalStateException(\"Aborting to protect against StackOverflowError - output of one loop is the input of another\");\n             }\n         }\n-        if (isEmpty(text) || ArrayUtils.isEmpty((Object[])searchList) || ArrayUtils.isEmpty((Object[])replacementList) || (ArrayUtils.isNotEmpty((Object[])searchList) && timeToLive == -1)) {\n-            return text;\n+        if (isEmpty(s) || ArrayUtils.isEmpty((Object[])a) || ArrayUtils.isEmpty((Object[])a2) || (ArrayUtils.isNotEmpty((Object[])a) && n == -1)) {\n+            return s;\n         }\n-        final int searchLength = searchList.length;\n-        final int replacementLength = replacementList.length;\n-        if (searchLength != replacementLength) {\n-            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n-        }\n-        final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n-        int textIndex = -1;\n-        int replaceIndex = -1;\n-        int tempIndex = -1;\n-        for (int i = 0; i < searchLength; ++i) {\n-            if (!noMoreMatchesForReplIndex[i] && !isEmpty(searchList[i])) {\n-                if (replacementList[i] != null) {\n-                    tempIndex = text.indexOf(searchList[i]);\n-                    if (tempIndex == -1) {\n-                        noMoreMatchesForReplIndex[i] = true;\n-                    }\n-                    else if (textIndex == -1 || tempIndex < textIndex) {\n-                        textIndex = tempIndex;\n-                        replaceIndex = i;\n+        final int length = a.length;\n+        final int length2 = a2.length;\n+        if (length != length2) {\n+            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + length + \" vs \" + length2);\n+        }\n+        final boolean[] array = new boolean[length];\n+        int i = -1;\n+        int n2 = -1;\n+        for (int j = 0; j < length; ++j) {\n+            if (!array[j] && !isEmpty(a[j])) {\n+                if (a2[j] != null) {\n+                    final int index = s.indexOf(a[j]);\n+                    if (index == -1) {\n+                        array[j] = true;\n+                    }\n+                    else if (i == -1 || index < i) {\n+                        i = index;\n+                        n2 = j;\n                     }\n                 }\n             }\n         }\n-        if (textIndex == -1) {\n-            return text;\n-        }\n-        int start = 0;\n-        int increase = 0;\n-        for (int j = 0; j < searchList.length; ++j) {\n-            if (searchList[j] != null) {\n-                if (replacementList[j] != null) {\n-                    final int greater = replacementList[j].length() - searchList[j].length();\n-                    if (greater > 0) {\n-                        increase += 3 * greater;\n+        if (i == -1) {\n+            return s;\n+        }\n+        int fromIndex = 0;\n+        int a3 = 0;\n+        for (int k = 0; k < a.length; ++k) {\n+            if (a[k] != null) {\n+                if (a2[k] != null) {\n+                    final int n3 = a2[k].length() - a[k].length();\n+                    if (n3 > 0) {\n+                        a3 += 3 * n3;\n                     }\n                 }\n             }\n         }\n-        increase = Math.min(increase, text.length() / 5);\n-        final StringBuilder buf = new StringBuilder(text.length() + increase);\n-        while (textIndex != -1) {\n-            for (int k = start; k < textIndex; ++k) {\n-                buf.append(text.charAt(k));\n-            }\n-            buf.append(replacementList[replaceIndex]);\n-            start = textIndex + searchList[replaceIndex].length();\n-            textIndex = -1;\n-            replaceIndex = -1;\n-            for (int k = 0; k < searchLength; ++k) {\n-                if (!noMoreMatchesForReplIndex[k] && searchList[k] != null && !searchList[k].isEmpty()) {\n-                    if (replacementList[k] != null) {\n-                        tempIndex = text.indexOf(searchList[k], start);\n-                        if (tempIndex == -1) {\n-                            noMoreMatchesForReplIndex[k] = true;\n+        final StringBuilder sb = new StringBuilder(s.length() + Math.min(a3, s.length() / 5));\n+        while (i != -1) {\n+            for (int l = fromIndex; l < i; ++l) {\n+                sb.append(s.charAt(l));\n+            }\n+            sb.append(a2[n2]);\n+            fromIndex = i + a[n2].length();\n+            i = -1;\n+            n2 = -1;\n+            for (int n4 = 0; n4 < length; ++n4) {\n+                if (!array[n4] && a[n4] != null && !a[n4].isEmpty()) {\n+                    if (a2[n4] != null) {\n+                        final int index2 = s.indexOf(a[n4], fromIndex);\n+                        if (index2 == -1) {\n+                            array[n4] = true;\n                         }\n-                        else if (textIndex == -1 || tempIndex < textIndex) {\n-                            textIndex = tempIndex;\n-                            replaceIndex = k;\n+                        else if (i == -1 || index2 < i) {\n+                            i = index2;\n+                            n2 = n4;\n                         }\n                     }\n                 }\n             }\n         }\n-        for (int textLength = text.length(), l = start; l < textLength; ++l) {\n-            buf.append(text.charAt(l));\n+        for (int length3 = s.length(), index3 = fromIndex; index3 < length3; ++index3) {\n+            sb.append(s.charAt(index3));\n         }\n-        final String result = buf.toString();\n-        if (!repeat) {\n-            return result;\n+        final String string = sb.toString();\n+        if (!b) {\n+            return string;\n         }\n-        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n+        return replaceEach(string, a, a2, b, n - 1);\n     }\n     \n-    public static String replaceEachRepeatedly(final String text, final String[] searchList, final String[] replacementList) {\n-        final int timeToLive = (searchList == null) ? 0 : searchList.length;\n-        return replaceEach(text, searchList, replacementList, true, timeToLive);\n+    public static String replaceEachRepeatedly(final String s, final String[] array, final String[] array2) {\n+        return replaceEach(s, array, array2, true, (array == null) ? 0 : array.length);\n     }\n     \n     @Deprecated\n-    public static String replaceFirst(final String text, final String regex, final String replacement) {\n-        return RegExUtils.replaceFirst(text, regex, replacement);\n+    public static String replaceFirst(final String s, final String s2, final String s3) {\n+        return RegExUtils.replaceFirst(s, s2, s3);\n     }\n     \n-    public static String replaceIgnoreCase(final String text, final String searchString, final String replacement) {\n-        return replaceIgnoreCase(text, searchString, replacement, -1);\n+    public static String replaceIgnoreCase(final String s, final String s2, final String s3) {\n+        return replaceIgnoreCase(s, s2, s3, -1);\n     }\n     \n-    public static String replaceIgnoreCase(final String text, final String searchString, final String replacement, final int max) {\n-        return replace(text, searchString, replacement, max, true);\n+    public static String replaceIgnoreCase(final String s, final String s2, final String s3, final int n) {\n+        return replace(s, s2, s3, n, true);\n     }\n     \n-    public static String replaceOnce(final String text, final String searchString, final String replacement) {\n-        return replace(text, searchString, replacement, 1);\n+    public static String replaceOnce(final String s, final String s2, final String s3) {\n+        return replace(s, s2, s3, 1);\n     }\n     \n-    public static String replaceOnceIgnoreCase(final String text, final String searchString, final String replacement) {\n-        return replaceIgnoreCase(text, searchString, replacement, 1);\n+    public static String replaceOnceIgnoreCase(final String s, final String s2, final String s3) {\n+        return replaceIgnoreCase(s, s2, s3, 1);\n     }\n     \n     @Deprecated\n-    public static String replacePattern(final String source, final String regex, final String replacement) {\n-        return RegExUtils.replacePattern(source, regex, replacement);\n+    public static String replacePattern(final String s, final String s2, final String s3) {\n+        return RegExUtils.replacePattern(s, s2, s3);\n     }\n     \n     public static String reverse(final String str) {\n         if (str == null) {\n             return null;\n         }\n         return new StringBuilder(str).reverse().toString();\n     }\n     \n-    public static String reverseDelimited(final String str, final char separatorChar) {\n-        if (str == null) {\n+    public static String reverseDelimited(final String s, final char c) {\n+        if (s == null) {\n             return null;\n         }\n-        final String[] strs = split(str, separatorChar);\n-        ArrayUtils.reverse((Object[])strs);\n-        return join((Object[])strs, separatorChar);\n+        final String[] split = split(s, c);\n+        ArrayUtils.reverse((Object[])split);\n+        return join((Object[])split, c);\n     }\n     \n-    public static String right(final String str, final int len) {\n-        if (str == null) {\n+    public static String right(final String s, final int n) {\n+        if (s == null) {\n             return null;\n         }\n-        if (len < 0) {\n+        if (n < 0) {\n             return \"\";\n         }\n-        if (str.length() <= len) {\n-            return str;\n+        if (s.length() <= n) {\n+            return s;\n         }\n-        return str.substring(str.length() - len);\n+        return s.substring(s.length() - n);\n     }\n     \n-    public static String rightPad(final String str, final int size) {\n-        return rightPad(str, size, ' ');\n+    public static String rightPad(final String s, final int n) {\n+        return rightPad(s, n, ' ');\n     }\n     \n-    public static String rightPad(final String str, final int size, final char padChar) {\n-        if (str == null) {\n+    public static String rightPad(final String s, final int n, final char c) {\n+        if (s == null) {\n             return null;\n         }\n-        final int pads = size - str.length();\n-        if (pads <= 0) {\n-            return str;\n+        final int n2 = n - s.length();\n+        if (n2 <= 0) {\n+            return s;\n         }\n-        if (pads > 8192) {\n-            return rightPad(str, size, String.valueOf(padChar));\n+        if (n2 > 8192) {\n+            return rightPad(s, n, String.valueOf(c));\n         }\n-        return str.concat(repeat(padChar, pads));\n+        return s.concat(repeat(c, n2));\n     }\n     \n-    public static String rightPad(final String str, final int size, String padStr) {\n-        if (str == null) {\n+    public static String rightPad(final String s, final int n, String str) {\n+        if (s == null) {\n             return null;\n         }\n-        if (isEmpty(padStr)) {\n-            padStr = \" \";\n+        if (isEmpty(str)) {\n+            str = \" \";\n         }\n-        final int padLen = padStr.length();\n-        final int strLen = str.length();\n-        final int pads = size - strLen;\n-        if (pads <= 0) {\n-            return str;\n+        final int length = str.length();\n+        final int endIndex = n - s.length();\n+        if (endIndex <= 0) {\n+            return s;\n         }\n-        if (padLen == 1 && pads <= 8192) {\n-            return rightPad(str, size, padStr.charAt(0));\n+        if (length == 1 && endIndex <= 8192) {\n+            return rightPad(s, n, str.charAt(0));\n         }\n-        if (pads == padLen) {\n-            return str.concat(padStr);\n+        if (endIndex == length) {\n+            return s.concat(str);\n         }\n-        if (pads < padLen) {\n-            return str.concat(padStr.substring(0, pads));\n+        if (endIndex < length) {\n+            return s.concat(str.substring(0, endIndex));\n         }\n-        final char[] padding = new char[pads];\n-        final char[] padChars = padStr.toCharArray();\n-        for (int i = 0; i < pads; ++i) {\n-            padding[i] = padChars[i % padLen];\n+        final char[] value = new char[endIndex];\n+        final char[] charArray = str.toCharArray();\n+        for (int i = 0; i < endIndex; ++i) {\n+            value[i] = charArray[i % length];\n         }\n-        return str.concat(new String(padding));\n+        return s.concat(new String(value));\n     }\n     \n-    public static String rotate(final String str, final int shift) {\n-        if (str == null) {\n+    public static String rotate(final String s, final int n) {\n+        if (s == null) {\n             return null;\n         }\n-        final int strLen = str.length();\n-        if (shift == 0 || strLen == 0 || shift % strLen == 0) {\n-            return str;\n+        final int length = s.length();\n+        if (n == 0 || length == 0 || n % length == 0) {\n+            return s;\n         }\n-        final StringBuilder builder = new StringBuilder(strLen);\n-        final int offset = -(shift % strLen);\n-        builder.append(substring(str, offset));\n-        builder.append(substring(str, 0, offset));\n-        return builder.toString();\n+        final StringBuilder sb = new StringBuilder(length);\n+        final int n2 = -(n % length);\n+        sb.append(substring(s, n2));\n+        sb.append(substring(s, 0, n2));\n+        return sb.toString();\n     }\n     \n-    public static String[] split(final String str) {\n-        return split(str, null, -1);\n+    public static String[] split(final String s) {\n+        return split(s, null, -1);\n     }\n     \n-    public static String[] split(final String str, final char separatorChar) {\n-        return splitWorker(str, separatorChar, false);\n+    public static String[] split(final String s, final char c) {\n+        return splitWorker(s, c, false);\n     }\n     \n-    public static String[] split(final String str, final String separatorChars) {\n-        return splitWorker(str, separatorChars, -1, false);\n+    public static String[] split(final String s, final String s2) {\n+        return splitWorker(s, s2, -1, false);\n     }\n     \n-    public static String[] split(final String str, final String separatorChars, final int max) {\n-        return splitWorker(str, separatorChars, max, false);\n+    public static String[] split(final String s, final String s2, final int n) {\n+        return splitWorker(s, s2, n, false);\n     }\n     \n-    public static String[] splitByCharacterType(final String str) {\n-        return splitByCharacterType(str, false);\n+    public static String[] splitByCharacterType(final String s) {\n+        return splitByCharacterType(s, false);\n     }\n     \n-    private static String[] splitByCharacterType(final String str, final boolean camelCase) {\n-        if (str == null) {\n+    private static String[] splitByCharacterType(final String s, final boolean b) {\n+        if (s == null) {\n             return null;\n         }\n-        if (str.isEmpty()) {\n+        if (s.isEmpty()) {\n             return ArrayUtils.EMPTY_STRING_ARRAY;\n         }\n-        final char[] c = str.toCharArray();\n-        final List<String> list = new ArrayList<String>();\n-        int tokenStart = 0;\n-        int currentType = Character.getType(c[tokenStart]);\n-        for (int pos = tokenStart + 1; pos < c.length; ++pos) {\n-            final int type = Character.getType(c[pos]);\n-            if (type != currentType) {\n-                if (camelCase && type == 2 && currentType == 1) {\n-                    final int newTokenStart = pos - 1;\n-                    if (newTokenStart != tokenStart) {\n-                        list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n-                        tokenStart = newTokenStart;\n+        final char[] charArray = s.toCharArray();\n+        final ArrayList list = new ArrayList();\n+        int offset = 0;\n+        int type = Character.getType(charArray[offset]);\n+        for (int i = offset + 1; i < charArray.length; ++i) {\n+            final int type2 = Character.getType(charArray[i]);\n+            if (type2 != type) {\n+                if (b && type2 == 2 && type == 1) {\n+                    final int n = i - 1;\n+                    if (n != offset) {\n+                        list.add(new String(charArray, offset, n - offset));\n+                        offset = n;\n                     }\n                 }\n                 else {\n-                    list.add(new String(c, tokenStart, pos - tokenStart));\n-                    tokenStart = pos;\n+                    list.add(new String(charArray, offset, i - offset));\n+                    offset = i;\n                 }\n-                currentType = type;\n+                type = type2;\n             }\n         }\n-        list.add(new String(c, tokenStart, c.length - tokenStart));\n-        return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n+        list.add(new String(charArray, offset, charArray.length - offset));\n+        return (String[])list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n     }\n     \n-    public static String[] splitByCharacterTypeCamelCase(final String str) {\n-        return splitByCharacterType(str, true);\n+    public static String[] splitByCharacterTypeCamelCase(final String s) {\n+        return splitByCharacterType(s, true);\n     }\n     \n-    public static String[] splitByWholeSeparator(final String str, final String separator) {\n-        return splitByWholeSeparatorWorker(str, separator, -1, false);\n+    public static String[] splitByWholeSeparator(final String s, final String s2) {\n+        return splitByWholeSeparatorWorker(s, s2, -1, false);\n     }\n     \n-    public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {\n-        return splitByWholeSeparatorWorker(str, separator, max, false);\n+    public static String[] splitByWholeSeparator(final String s, final String s2, final int n) {\n+        return splitByWholeSeparatorWorker(s, s2, n, false);\n     }\n     \n-    public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator) {\n-        return splitByWholeSeparatorWorker(str, separator, -1, true);\n+    public static String[] splitByWholeSeparatorPreserveAllTokens(final String s, final String s2) {\n+        return splitByWholeSeparatorWorker(s, s2, -1, true);\n     }\n     \n-    public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator, final int max) {\n-        return splitByWholeSeparatorWorker(str, separator, max, true);\n+    public static String[] splitByWholeSeparatorPreserveAllTokens(final String s, final String s2, final int n) {\n+        return splitByWholeSeparatorWorker(s, s2, n, true);\n     }\n     \n-    private static String[] splitByWholeSeparatorWorker(final String str, final String separator, final int max, final boolean preserveAllTokens) {\n-        if (str == null) {\n+    private static String[] splitByWholeSeparatorWorker(final String s, final String s2, final int n, final boolean b) {\n+        if (s == null) {\n             return null;\n         }\n-        final int len = str.length();\n-        if (len == 0) {\n+        final int length = s.length();\n+        if (length == 0) {\n             return ArrayUtils.EMPTY_STRING_ARRAY;\n         }\n-        if (separator == null || \"\".equals(separator)) {\n-            return splitWorker(str, null, max, preserveAllTokens);\n+        if (s2 == null || \"\".equals(s2)) {\n+            return splitWorker(s, null, n, b);\n         }\n-        final int separatorLength = separator.length();\n-        final ArrayList<String> substrings = new ArrayList<String>();\n-        int numberOfSubstrings = 0;\n-        int beg = 0;\n-        int end = 0;\n-        while (end < len) {\n-            end = str.indexOf(separator, beg);\n-            if (end > -1) {\n-                if (end > beg) {\n-                    if (++numberOfSubstrings == max) {\n-                        end = len;\n-                        substrings.add(str.substring(beg));\n+        final int length2 = s2.length();\n+        final ArrayList list = new ArrayList();\n+        int n2 = 0;\n+        int beginIndex = 0;\n+        int i = 0;\n+        while (i < length) {\n+            i = s.indexOf(s2, beginIndex);\n+            if (i > -1) {\n+                if (i > beginIndex) {\n+                    if (++n2 == n) {\n+                        i = length;\n+                        list.add(s.substring(beginIndex));\n                     }\n                     else {\n-                        substrings.add(str.substring(beg, end));\n-                        beg = end + separatorLength;\n+                        list.add(s.substring(beginIndex, i));\n+                        beginIndex = i + length2;\n                     }\n                 }\n                 else {\n-                    if (preserveAllTokens) {\n-                        if (++numberOfSubstrings == max) {\n-                            end = len;\n-                            substrings.add(str.substring(beg));\n+                    if (b) {\n+                        if (++n2 == n) {\n+                            i = length;\n+                            list.add(s.substring(beginIndex));\n                         }\n                         else {\n-                            substrings.add(\"\");\n+                            list.add(\"\");\n                         }\n                     }\n-                    beg = end + separatorLength;\n+                    beginIndex = i + length2;\n                 }\n             }\n             else {\n-                substrings.add(str.substring(beg));\n-                end = len;\n+                list.add(s.substring(beginIndex));\n+                i = length;\n             }\n         }\n-        return substrings.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n+        return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n     }\n     \n-    public static String[] splitPreserveAllTokens(final String str) {\n-        return splitWorker(str, null, -1, true);\n+    public static String[] splitPreserveAllTokens(final String s) {\n+        return splitWorker(s, null, -1, true);\n     }\n     \n-    public static String[] splitPreserveAllTokens(final String str, final char separatorChar) {\n-        return splitWorker(str, separatorChar, true);\n+    public static String[] splitPreserveAllTokens(final String s, final char c) {\n+        return splitWorker(s, c, true);\n     }\n     \n-    public static String[] splitPreserveAllTokens(final String str, final String separatorChars) {\n-        return splitWorker(str, separatorChars, -1, true);\n+    public static String[] splitPreserveAllTokens(final String s, final String s2) {\n+        return splitWorker(s, s2, -1, true);\n     }\n     \n-    public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {\n-        return splitWorker(str, separatorChars, max, true);\n+    public static String[] splitPreserveAllTokens(final String s, final String s2, final int n) {\n+        return splitWorker(s, s2, n, true);\n     }\n     \n-    private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) {\n-        if (str == null) {\n+    private static String[] splitWorker(final String s, final char c, final boolean b) {\n+        if (s == null) {\n             return null;\n         }\n-        final int len = str.length();\n-        if (len == 0) {\n+        final int length = s.length();\n+        if (length == 0) {\n             return ArrayUtils.EMPTY_STRING_ARRAY;\n         }\n-        final List<String> list = new ArrayList<String>();\n+        final ArrayList list = new ArrayList();\n         int i = 0;\n-        int start = 0;\n-        boolean match = false;\n-        boolean lastMatch = false;\n-        while (i < len) {\n-            if (str.charAt(i) == separatorChar) {\n-                if (match || preserveAllTokens) {\n-                    list.add(str.substring(start, i));\n-                    match = false;\n-                    lastMatch = true;\n+        int n = 0;\n+        int n2 = 0;\n+        boolean b2 = false;\n+        while (i < length) {\n+            if (s.charAt(i) == c) {\n+                if (n2 != 0 || b) {\n+                    list.add(s.substring(n, i));\n+                    n2 = 0;\n+                    b2 = true;\n                 }\n-                start = ++i;\n+                n = ++i;\n             }\n             else {\n-                lastMatch = false;\n-                match = true;\n+                b2 = false;\n+                n2 = 1;\n                 ++i;\n             }\n         }\n-        if (match || (preserveAllTokens && lastMatch)) {\n-            list.add(str.substring(start, i));\n+        if (n2 != 0 || (b && b2)) {\n+            list.add(s.substring(n, i));\n         }\n-        return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n+        return (String[])list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n     }\n     \n-    private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) {\n-        if (str == null) {\n+    private static String[] splitWorker(final String s, final String s2, final int n, final boolean b) {\n+        if (s == null) {\n             return null;\n         }\n-        final int len = str.length();\n-        if (len == 0) {\n+        final int length = s.length();\n+        if (length == 0) {\n             return ArrayUtils.EMPTY_STRING_ARRAY;\n         }\n-        final List<String> list = new ArrayList<String>();\n-        int sizePlus1 = 1;\n+        final ArrayList list = new ArrayList();\n+        int n2 = 1;\n         int i = 0;\n-        int start = 0;\n-        boolean match = false;\n-        boolean lastMatch = false;\n-        if (separatorChars == null) {\n-            while (i < len) {\n-                if (Character.isWhitespace(str.charAt(i))) {\n-                    if (match || preserveAllTokens) {\n-                        lastMatch = true;\n-                        if (sizePlus1++ == max) {\n-                            i = len;\n-                            lastMatch = false;\n+        int n3 = 0;\n+        int n4 = 0;\n+        boolean b2 = false;\n+        if (s2 == null) {\n+            while (i < length) {\n+                if (Character.isWhitespace(s.charAt(i))) {\n+                    if (n4 != 0 || b) {\n+                        b2 = true;\n+                        if (n2++ == n) {\n+                            i = length;\n+                            b2 = false;\n                         }\n-                        list.add(str.substring(start, i));\n-                        match = false;\n+                        list.add(s.substring(n3, i));\n+                        n4 = 0;\n                     }\n-                    start = ++i;\n+                    n3 = ++i;\n                 }\n                 else {\n-                    lastMatch = false;\n-                    match = true;\n+                    b2 = false;\n+                    n4 = 1;\n                     ++i;\n                 }\n             }\n         }\n-        else if (separatorChars.length() == 1) {\n-            final char sep = separatorChars.charAt(0);\n-            while (i < len) {\n-                if (str.charAt(i) == sep) {\n-                    if (match || preserveAllTokens) {\n-                        lastMatch = true;\n-                        if (sizePlus1++ == max) {\n-                            i = len;\n-                            lastMatch = false;\n+        else if (s2.length() == 1) {\n+            final char char1 = s2.charAt(0);\n+            while (i < length) {\n+                if (s.charAt(i) == char1) {\n+                    if (n4 != 0 || b) {\n+                        b2 = true;\n+                        if (n2++ == n) {\n+                            i = length;\n+                            b2 = false;\n                         }\n-                        list.add(str.substring(start, i));\n-                        match = false;\n+                        list.add(s.substring(n3, i));\n+                        n4 = 0;\n                     }\n-                    start = ++i;\n+                    n3 = ++i;\n                 }\n                 else {\n-                    lastMatch = false;\n-                    match = true;\n+                    b2 = false;\n+                    n4 = 1;\n                     ++i;\n                 }\n             }\n         }\n         else {\n-            while (i < len) {\n-                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n-                    if (match || preserveAllTokens) {\n-                        lastMatch = true;\n-                        if (sizePlus1++ == max) {\n-                            i = len;\n-                            lastMatch = false;\n+            while (i < length) {\n+                if (s2.indexOf(s.charAt(i)) >= 0) {\n+                    if (n4 != 0 || b) {\n+                        b2 = true;\n+                        if (n2++ == n) {\n+                            i = length;\n+                            b2 = false;\n                         }\n-                        list.add(str.substring(start, i));\n-                        match = false;\n+                        list.add(s.substring(n3, i));\n+                        n4 = 0;\n                     }\n-                    start = ++i;\n+                    n3 = ++i;\n                 }\n                 else {\n-                    lastMatch = false;\n-                    match = true;\n+                    b2 = false;\n+                    n4 = 1;\n                     ++i;\n                 }\n             }\n         }\n-        if (match || (preserveAllTokens && lastMatch)) {\n-            list.add(str.substring(start, i));\n+        if (n4 != 0 || (b && b2)) {\n+            list.add(s.substring(n3, i));\n         }\n-        return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n+        return (String[])list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n     }\n     \n-    public static boolean startsWith(final CharSequence str, final CharSequence prefix) {\n-        return startsWith(str, prefix, false);\n+    public static boolean startsWith(final CharSequence charSequence, final CharSequence charSequence2) {\n+        return startsWith(charSequence, charSequence2, false);\n     }\n     \n-    private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {\n-        if (str == null || prefix == null) {\n-            return str == prefix;\n+    private static boolean startsWith(final CharSequence charSequence, final CharSequence charSequence2, final boolean b) {\n+        if (charSequence == null || charSequence2 == null) {\n+            return charSequence == charSequence2;\n         }\n-        final int preLen = prefix.length();\n-        return preLen <= str.length() && CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, preLen);\n+        final int length = charSequence2.length();\n+        return length <= charSequence.length() && CharSequenceUtils.regionMatches(charSequence, b, 0, charSequence2, 0, length);\n     }\n     \n-    public static boolean startsWithAny(final CharSequence sequence, final CharSequence... searchStrings) {\n-        if (isEmpty(sequence) || ArrayUtils.isEmpty((Object[])searchStrings)) {\n+    public static boolean startsWithAny(final CharSequence charSequence, final CharSequence... array) {\n+        if (isEmpty(charSequence) || ArrayUtils.isEmpty((Object[])array)) {\n             return false;\n         }\n-        for (final CharSequence searchString : searchStrings) {\n-            if (startsWith(sequence, searchString)) {\n+        for (int length = array.length, i = 0; i < length; ++i) {\n+            if (startsWith(charSequence, array[i])) {\n                 return true;\n             }\n         }\n         return false;\n     }\n     \n-    public static boolean startsWithIgnoreCase(final CharSequence str, final CharSequence prefix) {\n-        return startsWith(str, prefix, true);\n+    public static boolean startsWithIgnoreCase(final CharSequence charSequence, final CharSequence charSequence2) {\n+        return startsWith(charSequence, charSequence2, true);\n     }\n     \n-    public static String strip(final String str) {\n-        return strip(str, null);\n+    public static String strip(final String s) {\n+        return strip(s, null);\n     }\n     \n-    public static String strip(String str, final String stripChars) {\n-        str = stripStart(str, stripChars);\n-        return stripEnd(str, stripChars);\n+    public static String strip(String stripStart, final String s) {\n+        stripStart = stripStart(stripStart, s);\n+        return stripEnd(stripStart, s);\n     }\n     \n-    public static String stripAccents(final String input) {\n-        if (input == null) {\n+    public static String stripAccents(final String src) {\n+        if (src == null) {\n             return null;\n         }\n-        final StringBuilder decomposed = new StringBuilder(Normalizer.normalize(input, Normalizer.Form.NFD));\n-        convertRemainingAccentCharacters(decomposed);\n-        return StringUtils.STRIP_ACCENTS_PATTERN.matcher(decomposed).replaceAll(\"\");\n+        final StringBuilder input = new StringBuilder(Normalizer.normalize(src, Normalizer.Form.NFD));\n+        convertRemainingAccentCharacters(input);\n+        return StringUtils.STRIP_ACCENTS_PATTERN.matcher(input).replaceAll(\"\");\n     }\n     \n-    public static String[] stripAll(final String... strs) {\n-        return stripAll(strs, null);\n+    public static String[] stripAll(final String... array) {\n+        return stripAll(array, null);\n     }\n     \n-    public static String[] stripAll(final String[] strs, final String stripChars) {\n-        final int strsLen = ArrayUtils.getLength((Object)strs);\n-        if (strsLen == 0) {\n-            return strs;\n+    public static String[] stripAll(final String[] array, final String s) {\n+        final int length = ArrayUtils.getLength((Object)array);\n+        if (length == 0) {\n+            return array;\n         }\n-        final String[] newArr = new String[strsLen];\n-        for (int i = 0; i < strsLen; ++i) {\n-            newArr[i] = strip(strs[i], stripChars);\n+        final String[] array2 = new String[length];\n+        for (int i = 0; i < length; ++i) {\n+            array2[i] = strip(array[i], s);\n         }\n-        return newArr;\n+        return array2;\n     }\n     \n-    public static String stripEnd(final String str, final String stripChars) {\n-        int end = length(str);\n-        if (end == 0) {\n-            return str;\n+    public static String stripEnd(final String s, final String s2) {\n+        int length = length(s);\n+        if (length == 0) {\n+            return s;\n         }\n-        if (stripChars == null) {\n-            while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {\n-                --end;\n+        if (s2 == null) {\n+            while (length != 0 && Character.isWhitespace(s.charAt(length - 1))) {\n+                --length;\n             }\n         }\n         else {\n-            if (stripChars.isEmpty()) {\n-                return str;\n+            if (s2.isEmpty()) {\n+                return s;\n             }\n-            while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != -1) {\n-                --end;\n+            while (length != 0 && s2.indexOf(s.charAt(length - 1)) != -1) {\n+                --length;\n             }\n         }\n-        return str.substring(0, end);\n+        return s.substring(0, length);\n     }\n     \n-    public static String stripStart(final String str, final String stripChars) {\n-        final int strLen = length(str);\n-        if (strLen == 0) {\n-            return str;\n+    public static String stripStart(final String s, final String s2) {\n+        final int length = length(s);\n+        if (length == 0) {\n+            return s;\n         }\n-        int start = 0;\n-        if (stripChars == null) {\n-            while (start != strLen && Character.isWhitespace(str.charAt(start))) {\n-                ++start;\n+        int beginIndex = 0;\n+        if (s2 == null) {\n+            while (beginIndex != length && Character.isWhitespace(s.charAt(beginIndex))) {\n+                ++beginIndex;\n             }\n         }\n         else {\n-            if (stripChars.isEmpty()) {\n-                return str;\n+            if (s2.isEmpty()) {\n+                return s;\n             }\n-            while (start != strLen && stripChars.indexOf(str.charAt(start)) != -1) {\n-                ++start;\n+            while (beginIndex != length && s2.indexOf(s.charAt(beginIndex)) != -1) {\n+                ++beginIndex;\n             }\n         }\n-        return str.substring(start);\n+        return s.substring(beginIndex);\n     }\n     \n-    public static String stripToEmpty(final String str) {\n-        return (str == null) ? \"\" : strip(str, null);\n+    public static String stripToEmpty(final String s) {\n+        return (s == null) ? \"\" : strip(s, null);\n     }\n     \n-    public static String stripToNull(String str) {\n-        if (str == null) {\n+    public static String stripToNull(String strip) {\n+        if (strip == null) {\n             return null;\n         }\n-        str = strip(str, null);\n-        return str.isEmpty() ? null : str;\n+        strip = strip(strip, null);\n+        return strip.isEmpty() ? null : strip;\n     }\n     \n-    public static String substring(final String str, int start) {\n-        if (str == null) {\n+    public static String substring(final String s, int beginIndex) {\n+        if (s == null) {\n             return null;\n         }\n-        if (start < 0) {\n-            start += str.length();\n+        if (beginIndex < 0) {\n+            beginIndex += s.length();\n         }\n-        if (start < 0) {\n-            start = 0;\n+        if (beginIndex < 0) {\n+            beginIndex = 0;\n         }\n-        if (start > str.length()) {\n+        if (beginIndex > s.length()) {\n             return \"\";\n         }\n-        return str.substring(start);\n+        return s.substring(beginIndex);\n     }\n     \n-    public static String substring(final String str, int start, int end) {\n-        if (str == null) {\n+    public static String substring(final String s, int beginIndex, int length) {\n+        if (s == null) {\n             return null;\n         }\n-        if (end < 0) {\n-            end += str.length();\n+        if (length < 0) {\n+            length += s.length();\n         }\n-        if (start < 0) {\n-            start += str.length();\n+        if (beginIndex < 0) {\n+            beginIndex += s.length();\n         }\n-        if (end > str.length()) {\n-            end = str.length();\n+        if (length > s.length()) {\n+            length = s.length();\n         }\n-        if (start > end) {\n+        if (beginIndex > length) {\n             return \"\";\n         }\n-        if (start < 0) {\n-            start = 0;\n+        if (beginIndex < 0) {\n+            beginIndex = 0;\n         }\n-        if (end < 0) {\n-            end = 0;\n+        if (length < 0) {\n+            length = 0;\n         }\n-        return str.substring(start, end);\n+        return s.substring(beginIndex, length);\n     }\n     \n-    public static String substringAfter(final String str, final int separator) {\n-        if (isEmpty(str)) {\n-            return str;\n+    public static String substringAfter(final String s, final int ch) {\n+        if (isEmpty(s)) {\n+            return s;\n         }\n-        final int pos = str.indexOf(separator);\n-        if (pos == -1) {\n+        final int index = s.indexOf(ch);\n+        if (index == -1) {\n             return \"\";\n         }\n-        return str.substring(pos + 1);\n+        return s.substring(index + 1);\n     }\n     \n-    public static String substringAfter(final String str, final String separator) {\n-        if (isEmpty(str)) {\n-            return str;\n+    public static String substringAfter(final String s, final String str) {\n+        if (isEmpty(s)) {\n+            return s;\n         }\n-        if (separator == null) {\n+        if (str == null) {\n             return \"\";\n         }\n-        final int pos = str.indexOf(separator);\n-        if (pos == -1) {\n+        final int index = s.indexOf(str);\n+        if (index == -1) {\n             return \"\";\n         }\n-        return str.substring(pos + separator.length());\n+        return s.substring(index + str.length());\n     }\n     \n-    public static String substringAfterLast(final String str, final int separator) {\n-        if (isEmpty(str)) {\n-            return str;\n+    public static String substringAfterLast(final String s, final int ch) {\n+        if (isEmpty(s)) {\n+            return s;\n         }\n-        final int pos = str.lastIndexOf(separator);\n-        if (pos == -1 || pos == str.length() - 1) {\n+        final int lastIndex = s.lastIndexOf(ch);\n+        if (lastIndex == -1 || lastIndex == s.length() - 1) {\n             return \"\";\n         }\n-        return str.substring(pos + 1);\n+        return s.substring(lastIndex + 1);\n     }\n     \n-    public static String substringAfterLast(final String str, final String separator) {\n-        if (isEmpty(str)) {\n-            return str;\n+    public static String substringAfterLast(final String s, final String str) {\n+        if (isEmpty(s)) {\n+            return s;\n         }\n-        if (isEmpty(separator)) {\n+        if (isEmpty(str)) {\n             return \"\";\n         }\n-        final int pos = str.lastIndexOf(separator);\n-        if (pos == -1 || pos == str.length() - separator.length()) {\n+        final int lastIndex = s.lastIndexOf(str);\n+        if (lastIndex == -1 || lastIndex == s.length() - str.length()) {\n             return \"\";\n         }\n-        return str.substring(pos + separator.length());\n+        return s.substring(lastIndex + str.length());\n     }\n     \n-    public static String substringBefore(final String str, final int separator) {\n-        if (isEmpty(str)) {\n-            return str;\n+    public static String substringBefore(final String s, final int ch) {\n+        if (isEmpty(s)) {\n+            return s;\n         }\n-        final int pos = str.indexOf(separator);\n-        if (pos == -1) {\n-            return str;\n+        final int index = s.indexOf(ch);\n+        if (index == -1) {\n+            return s;\n         }\n-        return str.substring(0, pos);\n+        return s.substring(0, index);\n     }\n     \n-    public static String substringBefore(final String str, final String separator) {\n-        if (isEmpty(str) || separator == null) {\n-            return str;\n+    public static String substringBefore(final String s, final String str) {\n+        if (isEmpty(s) || str == null) {\n+            return s;\n         }\n-        if (separator.isEmpty()) {\n+        if (str.isEmpty()) {\n             return \"\";\n         }\n-        final int pos = str.indexOf(separator);\n-        if (pos == -1) {\n-            return str;\n+        final int index = s.indexOf(str);\n+        if (index == -1) {\n+            return s;\n         }\n-        return str.substring(0, pos);\n+        return s.substring(0, index);\n     }\n     \n-    public static String substringBeforeLast(final String str, final String separator) {\n-        if (isEmpty(str) || isEmpty(separator)) {\n-            return str;\n+    public static String substringBeforeLast(final String s, final String str) {\n+        if (isEmpty(s) || isEmpty(str)) {\n+            return s;\n         }\n-        final int pos = str.lastIndexOf(separator);\n-        if (pos == -1) {\n-            return str;\n+        final int lastIndex = s.lastIndexOf(str);\n+        if (lastIndex == -1) {\n+            return s;\n         }\n-        return str.substring(0, pos);\n+        return s.substring(0, lastIndex);\n     }\n     \n-    public static String substringBetween(final String str, final String tag) {\n-        return substringBetween(str, tag, tag);\n+    public static String substringBetween(final String s, final String s2) {\n+        return substringBetween(s, s2, s2);\n     }\n     \n-    public static String substringBetween(final String str, final String open, final String close) {\n-        if (!ObjectUtils.allNotNull(new Object[] { str, open, close })) {\n+    public static String substringBetween(final String s, final String str, final String str2) {\n+        if (!ObjectUtils.allNotNull(new Object[] { s, str, str2 })) {\n             return null;\n         }\n-        final int start = str.indexOf(open);\n-        if (start != -1) {\n-            final int end = str.indexOf(close, start + open.length());\n-            if (end != -1) {\n-                return str.substring(start + open.length(), end);\n+        final int index = s.indexOf(str);\n+        if (index != -1) {\n+            final int index2 = s.indexOf(str2, index + str.length());\n+            if (index2 != -1) {\n+                return s.substring(index + str.length(), index2);\n             }\n         }\n         return null;\n     }\n     \n-    public static String[] substringsBetween(final String str, final String open, final String close) {\n-        if (str == null || isEmpty(open) || isEmpty(close)) {\n+    public static String[] substringsBetween(final String s, final String str, final String str2) {\n+        if (s == null || isEmpty(str) || isEmpty(str2)) {\n             return null;\n         }\n-        final int strLen = str.length();\n-        if (strLen == 0) {\n+        final int length = s.length();\n+        if (length == 0) {\n             return ArrayUtils.EMPTY_STRING_ARRAY;\n         }\n-        final int closeLen = close.length();\n-        final int openLen = open.length();\n-        final List<String> list = new ArrayList<String>();\n-        int end;\n-        for (int pos = 0; pos < strLen - closeLen; pos = end + closeLen) {\n-            int start = str.indexOf(open, pos);\n-            if (start < 0) {\n+        final int length2 = str2.length();\n+        final int length3 = str.length();\n+        final ArrayList list = new ArrayList();\n+        int index2;\n+        for (int i = 0; i < length - length2; i = index2 + length2) {\n+            final int index = s.indexOf(str, i);\n+            if (index < 0) {\n                 break;\n             }\n-            start += openLen;\n-            end = str.indexOf(close, start);\n-            if (end < 0) {\n+            final int n = index + length3;\n+            index2 = s.indexOf(str2, n);\n+            if (index2 < 0) {\n                 break;\n             }\n-            list.add(str.substring(start, end));\n+            list.add(s.substring(n, index2));\n         }\n         if (list.isEmpty()) {\n             return null;\n         }\n-        return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n+        return (String[])list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n     }\n     \n-    public static String swapCase(final String str) {\n-        if (isEmpty(str)) {\n-            return str;\n+    public static String swapCase(final String s) {\n+        if (isEmpty(s)) {\n+            return s;\n         }\n-        final int strLen = str.length();\n-        final int[] newCodePoints = new int[strLen];\n-        int outOffset = 0;\n-        int newCodePoint;\n-        for (int i = 0; i < strLen; i += Character.charCount(newCodePoint)) {\n-            final int oldCodepoint = str.codePointAt(i);\n-            if (Character.isUpperCase(oldCodepoint) || Character.isTitleCase(oldCodepoint)) {\n-                newCodePoint = Character.toLowerCase(oldCodepoint);\n+        final int length = s.length();\n+        final int[] codePoints = new int[length];\n+        int count = 0;\n+        int codePoint2;\n+        for (int i = 0; i < length; i += Character.charCount(codePoint2)) {\n+            final int codePoint = s.codePointAt(i);\n+            if (Character.isUpperCase(codePoint) || Character.isTitleCase(codePoint)) {\n+                codePoint2 = Character.toLowerCase(codePoint);\n             }\n-            else if (Character.isLowerCase(oldCodepoint)) {\n-                newCodePoint = Character.toUpperCase(oldCodepoint);\n+            else if (Character.isLowerCase(codePoint)) {\n+                codePoint2 = Character.toUpperCase(codePoint);\n             }\n             else {\n-                newCodePoint = oldCodepoint;\n+                codePoint2 = codePoint;\n             }\n-            newCodePoints[outOffset++] = newCodePoint;\n+            codePoints[count++] = codePoint2;\n         }\n-        return new String(newCodePoints, 0, outOffset);\n+        return new String(codePoints, 0, count);\n     }\n     \n-    public static int[] toCodePoints(final CharSequence cs) {\n-        if (cs == null) {\n+    public static int[] toCodePoints(final CharSequence charSequence) {\n+        if (charSequence == null) {\n             return null;\n         }\n-        if (cs.length() == 0) {\n+        if (charSequence.length() == 0) {\n             return ArrayUtils.EMPTY_INT_ARRAY;\n         }\n-        final String s = cs.toString();\n-        final int[] result = new int[s.codePointCount(0, s.length())];\n+        final String string = charSequence.toString();\n+        final int[] array = new int[string.codePointCount(0, string.length())];\n         int index = 0;\n-        for (int i = 0; i < result.length; ++i) {\n-            result[i] = s.codePointAt(index);\n-            index += Character.charCount(result[i]);\n+        for (int i = 0; i < array.length; ++i) {\n+            array[i] = string.codePointAt(index);\n+            index += Character.charCount(array[i]);\n         }\n-        return result;\n+        return array;\n     }\n     \n     public static String toEncodedString(final byte[] bytes, final Charset charset) {\n         return new String(bytes, Charsets.toCharset(charset));\n     }\n     \n-    public static String toRootLowerCase(final String source) {\n-        return (source == null) ? null : source.toLowerCase(Locale.ROOT);\n+    public static String toRootLowerCase(final String s) {\n+        return (s == null) ? null : s.toLowerCase(Locale.ROOT);\n     }\n     \n-    public static String toRootUpperCase(final String source) {\n-        return (source == null) ? null : source.toUpperCase(Locale.ROOT);\n+    public static String toRootUpperCase(final String s) {\n+        return (s == null) ? null : s.toUpperCase(Locale.ROOT);\n     }\n     \n     @Deprecated\n-    public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {\n-        return new String(bytes, Charsets.toCharset(charsetName));\n+    public static String toString(final byte[] bytes, final String s) throws UnsupportedEncodingException {\n+        return new String(bytes, Charsets.toCharset(s));\n     }\n     \n-    private static String toStringOrEmpty(final Object obj) {\n-        return Objects.toString(obj, \"\");\n+    private static String toStringOrEmpty(final Object o) {\n+        return Objects.toString(o, \"\");\n     }\n     \n-    public static String trim(final String str) {\n-        return (str == null) ? null : str.trim();\n+    public static String trim(final String s) {\n+        return (s == null) ? null : s.trim();\n     }\n     \n-    public static String trimToEmpty(final String str) {\n-        return (str == null) ? \"\" : str.trim();\n+    public static String trimToEmpty(final String s) {\n+        return (s == null) ? \"\" : s.trim();\n     }\n     \n-    public static String trimToNull(final String str) {\n-        final String ts = trim(str);\n-        return isEmpty(ts) ? null : ts;\n+    public static String trimToNull(final String s) {\n+        final String trim = trim(s);\n+        return isEmpty(trim) ? null : trim;\n     }\n     \n-    public static String truncate(final String str, final int maxWidth) {\n-        return truncate(str, 0, maxWidth);\n+    public static String truncate(final String s, final int n) {\n+        return truncate(s, 0, n);\n     }\n     \n-    public static String truncate(final String str, final int offset, final int maxWidth) {\n-        if (offset < 0) {\n+    public static String truncate(final String s, final int n, final int n2) {\n+        if (n < 0) {\n             throw new IllegalArgumentException(\"offset cannot be negative\");\n         }\n-        if (maxWidth < 0) {\n+        if (n2 < 0) {\n             throw new IllegalArgumentException(\"maxWith cannot be negative\");\n         }\n-        if (str == null) {\n+        if (s == null) {\n             return null;\n         }\n-        if (offset > str.length()) {\n+        if (n > s.length()) {\n             return \"\";\n         }\n-        if (str.length() > maxWidth) {\n-            final int ix = Math.min(offset + maxWidth, str.length());\n-            return str.substring(offset, ix);\n+        if (s.length() > n2) {\n+            return s.substring(n, Math.min(n + n2, s.length()));\n         }\n-        return str.substring(offset);\n+        return s.substring(n);\n     }\n     \n-    public static String uncapitalize(final String str) {\n-        final int strLen = length(str);\n-        if (strLen == 0) {\n-            return str;\n+    public static String uncapitalize(final String s) {\n+        final int length = length(s);\n+        if (length == 0) {\n+            return s;\n         }\n-        final int firstCodepoint = str.codePointAt(0);\n-        final int newCodePoint = Character.toLowerCase(firstCodepoint);\n-        if (firstCodepoint == newCodePoint) {\n-            return str;\n+        final int codePoint = s.codePointAt(0);\n+        final int lowerCase = Character.toLowerCase(codePoint);\n+        if (codePoint == lowerCase) {\n+            return s;\n         }\n-        final int[] newCodePoints = new int[strLen];\n-        int outOffset = 0;\n-        newCodePoints[outOffset++] = newCodePoint;\n-        int codepoint;\n-        for (int inOffset = Character.charCount(firstCodepoint); inOffset < strLen; inOffset += Character.charCount(codepoint)) {\n-            codepoint = str.codePointAt(inOffset);\n-            newCodePoints[outOffset++] = codepoint;\n+        final int[] codePoints = new int[length];\n+        int count = 0;\n+        codePoints[count++] = lowerCase;\n+        int codePoint2;\n+        for (int i = Character.charCount(codePoint); i < length; i += Character.charCount(codePoint2)) {\n+            codePoint2 = s.codePointAt(i);\n+            codePoints[count++] = codePoint2;\n         }\n-        return new String(newCodePoints, 0, outOffset);\n+        return new String(codePoints, 0, count);\n     }\n     \n-    public static String unwrap(final String str, final char wrapChar) {\n-        if (isEmpty(str) || wrapChar == '\\0' || str.length() == 1) {\n-            return str;\n+    public static String unwrap(final String s, final char c) {\n+        if (isEmpty(s) || c == '\\0' || s.length() == 1) {\n+            return s;\n         }\n-        if (str.charAt(0) == wrapChar && str.charAt(str.length() - 1) == wrapChar) {\n-            final int startIndex = 0;\n-            final int endIndex = str.length() - 1;\n-            return str.substring(1, endIndex);\n+        if (s.charAt(0) == c && s.charAt(s.length() - 1) == c) {\n+            return s.substring(1, s.length() - 1);\n         }\n-        return str;\n+        return s;\n     }\n     \n-    public static String unwrap(final String str, final String wrapToken) {\n-        if (isEmpty(str) || isEmpty(wrapToken) || str.length() < 2 * wrapToken.length()) {\n-            return str;\n+    public static String unwrap(final String s, final String s2) {\n+        if (isEmpty(s) || isEmpty(s2) || s.length() < 2 * s2.length()) {\n+            return s;\n         }\n-        if (startsWith(str, wrapToken) && endsWith(str, wrapToken)) {\n-            final int startIndex = str.indexOf(wrapToken);\n-            final int endIndex = str.lastIndexOf(wrapToken);\n-            final int wrapLength = wrapToken.length();\n-            if (startIndex != -1 && endIndex != -1) {\n-                return str.substring(startIndex + wrapLength, endIndex);\n+        if (startsWith(s, s2) && endsWith(s, s2)) {\n+            final int index = s.indexOf(s2);\n+            final int lastIndex = s.lastIndexOf(s2);\n+            final int length = s2.length();\n+            if (index != -1 && lastIndex != -1) {\n+                return s.substring(index + length, lastIndex);\n             }\n         }\n-        return str;\n+        return s;\n     }\n     \n-    public static String upperCase(final String str) {\n-        if (str == null) {\n+    public static String upperCase(final String s) {\n+        if (s == null) {\n             return null;\n         }\n-        return str.toUpperCase();\n+        return s.toUpperCase();\n     }\n     \n-    public static String upperCase(final String str, final Locale locale) {\n-        if (str == null) {\n+    public static String upperCase(final String s, final Locale locale) {\n+        if (s == null) {\n             return null;\n         }\n-        return str.toUpperCase(LocaleUtils.toLocale(locale));\n+        return s.toUpperCase(LocaleUtils.toLocale(locale));\n     }\n     \n-    public static String valueOf(final char[] value) {\n-        return (value == null) ? null : String.valueOf(value);\n+    public static String valueOf(final char[] data) {\n+        return (data == null) ? null : String.valueOf(data);\n     }\n     \n-    public static String wrap(final String str, final char wrapWith) {\n-        if (isEmpty(str) || wrapWith == '\\0') {\n+    public static String wrap(final String str, final char c) {\n+        if (isEmpty(str) || c == '\\0') {\n             return str;\n         }\n-        return wrapWith + str + wrapWith;\n+        return c + str + c;\n     }\n     \n-    public static String wrap(final String str, final String wrapWith) {\n-        if (isEmpty(str) || isEmpty(wrapWith)) {\n+    public static String wrap(final String str, final String str2) {\n+        if (isEmpty(str) || isEmpty(str2)) {\n             return str;\n         }\n-        return wrapWith.concat(str).concat(wrapWith);\n+        return str2.concat(str).concat(str2);\n     }\n     \n-    public static String wrapIfMissing(final String str, final char wrapWith) {\n-        if (isEmpty(str) || wrapWith == '\\0') {\n+    public static String wrapIfMissing(final String str, final char c) {\n+        if (isEmpty(str) || c == '\\0') {\n             return str;\n         }\n-        final boolean wrapStart = str.charAt(0) != wrapWith;\n-        final boolean wrapEnd = str.charAt(str.length() - 1) != wrapWith;\n-        if (!wrapStart && !wrapEnd) {\n+        final boolean b = str.charAt(0) != c;\n+        final boolean b2 = str.charAt(str.length() - 1) != c;\n+        if (!b && !b2) {\n             return str;\n         }\n-        final StringBuilder builder = new StringBuilder(str.length() + 2);\n-        if (wrapStart) {\n-            builder.append(wrapWith);\n+        final StringBuilder sb = new StringBuilder(str.length() + 2);\n+        if (b) {\n+            sb.append(c);\n         }\n-        builder.append(str);\n-        if (wrapEnd) {\n-            builder.append(wrapWith);\n+        sb.append(str);\n+        if (b2) {\n+            sb.append(c);\n         }\n-        return builder.toString();\n+        return sb.toString();\n     }\n     \n-    public static String wrapIfMissing(final String str, final String wrapWith) {\n-        if (isEmpty(str) || isEmpty(wrapWith)) {\n+    public static String wrapIfMissing(final String str, final String s) {\n+        if (isEmpty(str) || isEmpty(s)) {\n             return str;\n         }\n-        final boolean wrapStart = !str.startsWith(wrapWith);\n-        final boolean wrapEnd = !str.endsWith(wrapWith);\n-        if (!wrapStart && !wrapEnd) {\n+        final boolean b = !str.startsWith(s);\n+        final boolean b2 = !str.endsWith(s);\n+        if (!b && !b2) {\n             return str;\n         }\n-        final StringBuilder builder = new StringBuilder(str.length() + wrapWith.length() + wrapWith.length());\n-        if (wrapStart) {\n-            builder.append(wrapWith);\n-        }\n-        builder.append(str);\n-        if (wrapEnd) {\n-            builder.append(wrapWith);\n+        final StringBuilder sb = new StringBuilder(str.length() + s.length() + s.length());\n+        if (b) {\n+            sb.append(s);\n+        }\n+        sb.append(str);\n+        if (b2) {\n+            sb.append(s);\n         }\n-        return builder.toString();\n+        return sb.toString();\n     }\n     \n     static {\n         STRIP_ACCENTS_PATTERN = Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\");\n     }\n }\n"}]}
